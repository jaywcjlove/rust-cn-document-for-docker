<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="原始的、不安全的指针 `*const T` 和 `*mut T`。"><title>pointer - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items1.71.0.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../std/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../std/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">pointer</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.add">add</a></li><li><a href="#method.add-1">add</a></li><li><a href="#method.addr">addr</a></li><li><a href="#method.addr-1">addr</a></li><li><a href="#method.align_offset">align_offset</a></li><li><a href="#method.align_offset-1">align_offset</a></li><li><a href="#method.as_mut">as_mut</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_ref">as_ref</a></li><li><a href="#method.as_ref-1">as_ref</a></li><li><a href="#method.as_uninit_mut">as_uninit_mut</a></li><li><a href="#method.as_uninit_ref">as_uninit_ref</a></li><li><a href="#method.as_uninit_ref-1">as_uninit_ref</a></li><li><a href="#method.as_uninit_slice">as_uninit_slice</a></li><li><a href="#method.as_uninit_slice-1">as_uninit_slice</a></li><li><a href="#method.as_uninit_slice_mut">as_uninit_slice_mut</a></li><li><a href="#method.byte_add">byte_add</a></li><li><a href="#method.byte_add-1">byte_add</a></li><li><a href="#method.byte_offset">byte_offset</a></li><li><a href="#method.byte_offset-1">byte_offset</a></li><li><a href="#method.byte_offset_from">byte_offset_from</a></li><li><a href="#method.byte_offset_from-1">byte_offset_from</a></li><li><a href="#method.byte_sub">byte_sub</a></li><li><a href="#method.byte_sub-1">byte_sub</a></li><li><a href="#method.cast">cast</a></li><li><a href="#method.cast-1">cast</a></li><li><a href="#method.cast_const">cast_const</a></li><li><a href="#method.cast_mut">cast_mut</a></li><li><a href="#method.copy_from">copy_from</a></li><li><a href="#method.copy_from_nonoverlapping">copy_from_nonoverlapping</a></li><li><a href="#method.copy_to">copy_to</a></li><li><a href="#method.copy_to-1">copy_to</a></li><li><a href="#method.copy_to_nonoverlapping">copy_to_nonoverlapping</a></li><li><a href="#method.copy_to_nonoverlapping-1">copy_to_nonoverlapping</a></li><li><a href="#method.drop_in_place">drop_in_place</a></li><li><a href="#method.expose_addr">expose_addr</a></li><li><a href="#method.expose_addr-1">expose_addr</a></li><li><a href="#method.from_bits">from_bits</a></li><li><a href="#method.from_bits-1">from_bits</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.guaranteed_eq">guaranteed_eq</a></li><li><a href="#method.guaranteed_eq-1">guaranteed_eq</a></li><li><a href="#method.guaranteed_ne">guaranteed_ne</a></li><li><a href="#method.guaranteed_ne-1">guaranteed_ne</a></li><li><a href="#method.is_aligned">is_aligned</a></li><li><a href="#method.is_aligned-1">is_aligned</a></li><li><a href="#method.is_aligned_to">is_aligned_to</a></li><li><a href="#method.is_aligned_to-1">is_aligned_to</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.is_null">is_null</a></li><li><a href="#method.is_null-1">is_null</a></li><li><a href="#method.len">len</a></li><li><a href="#method.len-1">len</a></li><li><a href="#method.map_addr">map_addr</a></li><li><a href="#method.map_addr-1">map_addr</a></li><li><a href="#method.mask">mask</a></li><li><a href="#method.mask-1">mask</a></li><li><a href="#method.offset">offset</a></li><li><a href="#method.offset-1">offset</a></li><li><a href="#method.offset_from">offset_from</a></li><li><a href="#method.offset_from-1">offset_from</a></li><li><a href="#method.read">read</a></li><li><a href="#method.read-1">read</a></li><li><a href="#method.read_unaligned">read_unaligned</a></li><li><a href="#method.read_unaligned-1">read_unaligned</a></li><li><a href="#method.read_volatile">read_volatile</a></li><li><a href="#method.read_volatile-1">read_volatile</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_mut_unchecked">split_at_mut_unchecked</a></li><li><a href="#method.sub">sub</a></li><li><a href="#method.sub-1">sub</a></li><li><a href="#method.sub_ptr">sub_ptr</a></li><li><a href="#method.sub_ptr-1">sub_ptr</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.to_bits">to_bits</a></li><li><a href="#method.to_bits-1">to_bits</a></li><li><a href="#method.to_raw_parts">to_raw_parts</a></li><li><a href="#method.to_raw_parts-1">to_raw_parts</a></li><li><a href="#method.with_addr">with_addr</a></li><li><a href="#method.with_addr-1">with_addr</a></li><li><a href="#method.with_metadata_of">with_metadata_of</a></li><li><a href="#method.with_metadata_of-1">with_metadata_of</a></li><li><a href="#method.wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_add-1">wrapping_add</a></li><li><a href="#method.wrapping_byte_add">wrapping_byte_add</a></li><li><a href="#method.wrapping_byte_add-1">wrapping_byte_add</a></li><li><a href="#method.wrapping_byte_offset">wrapping_byte_offset</a></li><li><a href="#method.wrapping_byte_offset-1">wrapping_byte_offset</a></li><li><a href="#method.wrapping_byte_sub">wrapping_byte_sub</a></li><li><a href="#method.wrapping_byte_sub-1">wrapping_byte_sub</a></li><li><a href="#method.wrapping_offset">wrapping_offset</a></li><li><a href="#method.wrapping_offset-1">wrapping_offset</a></li><li><a href="#method.wrapping_sub">wrapping_sub</a></li><li><a href="#method.wrapping_sub-1">wrapping_sub</a></li><li><a href="#method.write">write</a></li><li><a href="#method.write_bytes">write_bytes</a></li><li><a href="#method.write_unaligned">write_unaligned</a></li><li><a href="#method.write_volatile">write_volatile</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Send-for-*const+T">!Send</a></li><li><a href="#impl-Send-for-*mut+T">!Send</a></li><li><a href="#impl-Sync-for-*const+T">!Sync</a></li><li><a href="#impl-Sync-for-*mut+T">!Sync</a></li><li><a href="#impl-Clone-for-*const+T">Clone</a></li><li><a href="#impl-Clone-for-*mut+T">Clone</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26'a+T">CoerceUnsized&lt;*const U&gt;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26'a+mut+T">CoerceUnsized&lt;*const U&gt;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*const+T">CoerceUnsized&lt;*const U&gt;</a></li><li><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*mut+T">CoerceUnsized&lt;*const U&gt;</a></li><li><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-%26'a+mut+T">CoerceUnsized&lt;*mut U&gt;</a></li><li><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T">CoerceUnsized&lt;*mut U&gt;</a></li><li><a href="#impl-Copy-for-*const+T">Copy</a></li><li><a href="#impl-Copy-for-*mut+T">Copy</a></li><li><a href="#impl-Debug-for-*const+T">Debug</a></li><li><a href="#impl-Debug-for-*mut+T">Debug</a></li><li><a href="#impl-DispatchFromDyn%3C*const+U%3E-for-*const+T">DispatchFromDyn&lt;*const U&gt;</a></li><li><a href="#impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T">DispatchFromDyn&lt;*mut U&gt;</a></li><li><a href="#impl-Eq-for-*const+T">Eq</a></li><li><a href="#impl-Eq-for-*mut+T">Eq</a></li><li><a href="#impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E">From&lt;*mut T&gt;</a></li><li><a href="#impl-Hash-for-*const+T">Hash</a></li><li><a href="#impl-Hash-for-*mut+T">Hash</a></li><li><a href="#impl-Ord-for-*const+T">Ord</a></li><li><a href="#impl-Ord-for-*mut+T">Ord</a></li><li><a href="#impl-PartialEq%3C*const+T%3E-for-*const+T">PartialEq&lt;*const T&gt;</a></li><li><a href="#impl-PartialEq%3C*mut+T%3E-for-*mut+T">PartialEq&lt;*mut T&gt;</a></li><li><a href="#impl-PartialOrd%3C*const+T%3E-for-*const+T">PartialOrd&lt;*const T&gt;</a></li><li><a href="#impl-PartialOrd%3C*mut+T%3E-for-*mut+T">PartialOrd&lt;*mut T&gt;</a></li><li><a href="#impl-Pointer-for-*const+T">Pointer</a></li><li><a href="#impl-Pointer-for-*mut+T">Pointer</a></li><li><a href="#impl-SimdCastPtr%3CT%3E-for-*const+U">SimdCastPtr&lt;T&gt;</a></li><li><a href="#impl-SimdCastPtr%3CT%3E-for-*mut+U">SimdCastPtr&lt;T&gt;</a></li><li><a href="#impl-SimdElement-for-*const+T">SimdElement</a></li><li><a href="#impl-SimdElement-for-*mut+T">SimdElement</a></li><li><a href="#impl-Unpin-for-*const+T">Unpin</a></li><li><a href="#impl-Unpin-for-*mut+T">Unpin</a></li><li><a href="#impl-UnwindSafe-for-*const+T">UnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-*mut+T">UnwindSafe</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-*const+T">RefUnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-*const+T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-*const+T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-*const+T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-*const+T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-*const+T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-*const+T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-*const+T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-*const+T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In std</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Primitive Type <a class="primitive" href="#">pointer</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>原始的、不安全的指针 <code>*const T</code> 和 <code>*mut T</code>。</p>
<p><em><a href="ptr/index.html" title="mod std::ptr">See also the <code>std::ptr</code> module</a>.</em></p>
<p>在 Rust 中使用裸指针并不常见，通常仅限于几种模式。
裸指针可以是未对齐的或 <a href="ptr/fn.null.html" title="fn std::ptr::null"><code>null</code></a>。但是，当解引用裸指针 (使用 <code>*</code> 运算符) 时，它必须为非 null 并对齐。</p>
<p>使用 <code>*ptr = data</code> 通过裸指针存储会在旧值上调用 <code>drop</code>，因此，如果该类型具有 drop glue 并且尚未初始化内存，则必须使用 <a href="ptr/fn.write.html" title="fn std::ptr::write"><code>write</code></a>; 否则，将在未初始化的内存上调用 <code>drop</code>。</p>
<p>使用 <a href="ptr/fn.null.html" title="fn std::ptr::null"><code>null</code></a> 和 <a href="ptr/fn.null_mut.html" title="fn std::ptr::null_mut"><code>null_mut</code></a> 函数创建空指针，并使用 <code>*const T</code> 和 <code>*mut T</code> 类型的 <a href="primitive.pointer.html#method.is_null" title="method pointer::is_null"><code>is_null</code></a> 方法检查空值。
<code>*const T</code> 和 <code>*mut T</code> 类型还定义了用于指针数学的 <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>offset</code></a> 方法。</p>
<h2 id="创建裸指针的常用方法"><a href="#创建裸指针的常用方法">创建裸指针的常用方法</a></h2><h3 id="1-强制引用-t-或可变引用-mut-t"><a href="#1-强制引用-t-或可变引用-mut-t">1. 强制引用 (<code>&amp;T</code>) 或可变引用 (<code>&amp;mut T</code>)。</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_num: i32 = <span class="number">10</span>;
<span class="kw">let </span>my_num_ptr: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>my_num;
<span class="kw">let </span><span class="kw-2">mut </span>my_speed: i32 = <span class="number">88</span>;
<span class="kw">let </span>my_speed_ptr: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>my_speed;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+my_num:+i32+=+10;%0Alet+my_num_ptr:+*const+i32+=+%26my_num;%0Alet+mut+my_speed:+i32+=+88;%0Alet+my_speed_ptr:+*mut+i32+=+%26mut+my_speed;%0A%7D&amp;edition=2021">Run</a></div>
<p>要获得指向 boxed 值的指针，请解引用 box：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_num: Box&lt;i32&gt; = Box::new(<span class="number">10</span>);
<span class="kw">let </span>my_num_ptr: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;*</span>my_num;
<span class="kw">let </span><span class="kw-2">mut </span>my_speed: Box&lt;i32&gt; = Box::new(<span class="number">88</span>);
<span class="kw">let </span>my_speed_ptr: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut *</span>my_speed;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+my_num:+Box%3Ci32%3E+=+Box::new(10);%0Alet+my_num_ptr:+*const+i32+=+%26*my_num;%0Alet+mut+my_speed:+Box%3Ci32%3E+=+Box::new(88);%0Alet+my_speed_ptr:+*mut+i32+=+%26mut+*my_speed;%0A%7D&amp;edition=2021">Run</a></div>
<p>这不会获得原始分配的所有权，并且以后不需要任何资源管理，但是您一定不能在其生命周期之后使用该指针。</p>
<h3 id="2-消费-box-boxt"><a href="#2-消费-box-boxt">2. 消费 box (<code>Box&lt;T&gt;</code>)。</a></h3>
<p><a href="boxed/struct.Box.html#method.into_raw" title="associated function std::boxed::Box::into_raw"><code>into_raw</code></a> 函数消费 box 并返回裸指针。它不会销毁 <code>T</code> 或释放任何内存。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>my_speed: Box&lt;i32&gt; = Box::new(<span class="number">88</span>);
<span class="kw">let </span>my_speed: <span class="kw-2">*mut </span>i32 = Box::into_raw(my_speed);

<span class="comment">// 通过拥有原始 `Box&lt;T&gt;` 的所有权，我们有义务稍后将其放在一起销毁。
</span><span class="kw">unsafe </span>{
    drop(Box::from_raw(my_speed));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+my_speed:+Box%3Ci32%3E+=+Box::new(88);%0Alet+my_speed:+*mut+i32+=+Box::into_raw(my_speed);%0A%0A//+%E9%80%9A%E8%BF%87%E6%8B%A5%E6%9C%89%E5%8E%9F%E5%A7%8B+%60Box%3CT%3E%60+%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E4%B9%89%E5%8A%A1%E7%A8%8D%E5%90%8E%E5%B0%86%E5%85%B6%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%E9%94%80%E6%AF%81%E3%80%82%0Aunsafe+%7B%0A++++drop(Box::from_raw(my_speed));%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>请注意，此处对 <a href="mem/fn.drop.html" title="fn std::mem::drop"><code>drop</code></a> 的调用是为了清楚起见 - 表示我们已经完成了给定值的操作，应将其销毁。</p>
<h3 id="3-使用-ptraddr_of-创建它"><a href="#3-使用-ptraddr_of-创建它">3. 使用 <code>ptr::addr_of!</code> 创建它</a></h3>
<p>您可以使用宏 <a href="ptr/macro.addr_of.html" title="macro std::ptr::addr_of"><code>ptr::addr_of!</code></a> (对于 <code>*const T</code>) 和 <a href="ptr/macro.addr_of_mut.html" title="macro std::ptr::addr_of_mut"><code>ptr::addr_of_mut!</code></a> (对于 <code>*mut T</code>)，而不是强制引用裸指针。
这些宏允许您创建裸指针指向您无法创建引用的字段 (不会导致未定义的行为)，例如未对齐的字段。
如果涉及包装的结构或未初始化的内存，这可能是必要的。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug, Default, Copy, Clone)]
#[repr(C, packed)]
</span><span class="kw">struct </span>S {
    aligned: u8,
    unaligned: u32,
}
<span class="kw">let </span>s = S::default();
<span class="kw">let </span>p = <span class="macro">std::ptr::addr_of!</span>(s.unaligned); <span class="comment">// 不允许强制转换</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Bderive(Debug,+Default,+Copy,+Clone)%5D%0A%23%5Brepr(C,+packed)%5D%0Astruct+S+%7B%0A++++aligned:+u8,%0A++++unaligned:+u32,%0A%7D%0Alet+s+=+S::default();%0Alet+p+=+std::ptr::addr_of!(s.unaligned);+//+%E4%B8%8D%E5%85%81%E8%AE%B8%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="4-从-c-获取它"><a href="#4-从-c-获取它">4. 从 C 获取它。</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[allow(unused_extern_crates)]
</span><span class="kw">extern crate </span>libc;

<span class="kw">use </span>std::mem;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>my_num: <span class="kw-2">*mut </span>i32 = libc::malloc(mem::size_of::&lt;i32&gt;()) <span class="kw">as </span><span class="kw-2">*mut </span>i32;
    <span class="kw">if </span>my_num.is_null() {
        <span class="macro">panic!</span>(<span class="string">&quot;failed to allocate memory&quot;</span>);
    }
    libc::free(my_num <span class="kw">as </span><span class="kw-2">*mut </span>libc::c_void);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(rustc_private)%5D%0Afn+main()+%7B%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+libc;%0A%0Ause+std::mem;%0A%0Aunsafe+%7B%0A++++let+my_num:+*mut+i32+=+libc::malloc(mem::size_of::%3Ci32%3E())+as+*mut+i32;%0A++++if+my_num.is_null()+%7B%0A++++++++panic!(%22failed+to+allocate+memory%22);%0A++++%7D%0A++++libc::free(my_num+as+*mut+libc::c_void);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>通常，您实际上不会使用 Rust 中的 <code>malloc</code> 和 <code>free</code>，但是 C API 通常会发出很多指针，因此 Rust 中的裸指针常见来源。</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-*const+%5BT%5D" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1596">source</a><a href="#impl-*const+%5BT%5D" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[T]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/71146" title="Tracking issue for const_slice_ptr_len">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1617">source</a></span><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</span></div></span></summary><div class="docblock"><p>返回原始切片的长度。</p>
<p>返回的值是 <strong>元素</strong> 的数量，而不是字节数。</p>
<p>即使原始切片由于指针为空或未对齐而无法转换为切片引用，此函数也是安全的。</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_len)]

</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i8] = ptr::slice_from_raw_parts(ptr::null(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0A%0Afn+main()+%7B%0Ause+std::ptr;%0A%0Alet+slice:+*const+%5Bi8%5D+=+ptr::slice_from_raw_parts(ptr::null(),+3);%0Aassert_eq!(slice.len(),+3);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/74265" title="Tracking issue for slice_ptr_get">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1637">source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>将裸指针返回到切片的缓冲区。</p>
<p>这等效于将 <code>self</code> 强制转换为 <code>*const T</code>，但类型安全性更高。</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*const </span>[i8] = ptr::slice_from_raw_parts(ptr::null(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.as_ptr(), ptr::null());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn+main()+%7B%0Ause+std::ptr;%0A%0Alet+slice:+*const+%5Bi8%5D+=+ptr::slice_from_raw_parts(ptr::null(),+3);%0Aassert_eq!(slice.as_ptr(),+ptr::null());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1662-1664">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(
    self,
    index: I
) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>将裸指针返回到元素或子切片，而不进行边界检查。</p>
<p>使用越界索引或当 <code>self</code> 不可解引用时调用此方法是 <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">未定义行为</a></em>，即使未使用结果指针。</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]

</span><span class="kw">let </span>x = <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as </span><span class="kw-2">*const </span>[i32];

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(x.get_unchecked(<span class="number">1</span>), x.as_ptr().add(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn+main()+%7B%0Alet+x+=+%26%5B1,+2,+4%5D+as+*const+%5Bi32%5D;%0A%0Aunsafe+%7B%0A++++assert_eq!(x.get_unchecked(1),+x.as_ptr().add(1));%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1710">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice" class="fn">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a [<a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回共享切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_ref"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须为 <a href="ptr/index.html#safety" title="mod std::ptr">有效</a> 的，才能读取许多字节的 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code>，并且必须正确对齐。这尤其意味着：</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 内！
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="associated function std::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
<p>另请参见 <a href="slice/fn.from_raw_parts.html" title="fn std::slice::from_raw_parts"><code>slice::from_raw_parts</code></a>。</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#7">source</a><a href="#impl-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_null" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/74939" title="Tracking issue for const_ptr_is_null">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#34">source</a></span><h4 class="code-header">pub fn <a href="#method.is_null" class="fn">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>如果指针为空，则返回 <code>true</code>。</p>
<p>请注意，未定义大小的类型具有许多可能的空指针，因为仅考虑原始数据指针，而不考虑其长度，vtable 等。
因此，两个为空的指针可能仍不能相互比较相等。</p>
<h6 id="常量评估期间的行为"><a href="#常量评估期间的行为">常量评估期间的行为</a></h6>
<p>在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能返回 <code>false</code>。
具体来说，当指向某个内存的指针超出其范围的偏移量 (使结果指针为空) 时，函数仍将返回 <code>false</code>。</p>
<p>CTFE 无法知道该内存的绝对位置，因此我们无法确定指针是否为空。</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;Follow the rabbit&quot;</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();
<span class="macro">assert!</span>(!ptr.is_null());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22Follow+the+rabbit%22;%0Alet+ptr:+*const+u8+=+s.as_ptr();%0Aassert!(!ptr.is_null());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#58">source</a></span><h4 class="code-header">pub const fn <a href="#method.cast" class="fn">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a></h4></section></summary><div class="docblock"><p>强制转换为另一种类型的指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_metadata_of" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/75091" title="Tracking issue for set_ptr_value">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#94-96">source</a></span><h4 class="code-header">pub fn <a href="#method.with_metadata_of" class="fn">with_metadata_of</a>&lt;U&gt;(self, meta: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a><span class="where fmt-newline">where
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</span></div></span></summary><div class="docblock"><p>在另一种类型的新指针中使用指针值。</p>
<p>如果 <code>meta</code> 是指向未定义大小类型的 (fat) 指针，此操作将忽略指针部分，而对于指向大小类型的 (thin) 指针，这与简单强制转换具有相同的效果。</p>
<p>生成的指针将具有 <code>self</code> 的来源，即，对于胖指针，此操作在语义上与创建数据指针值为 <code>self</code> 但元数据为 <code>meta</code> 的新胖指针相同。</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>此函数主要用于允许对潜在的胖指针进行按字节指针算术运算：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span>arr: [i32; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr = arr.as_ptr() <span class="kw">as </span><span class="kw-2">*const </span><span class="kw">dyn </span>Debug;
<span class="kw">let </span>thin = ptr <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">unsafe </span>{
    ptr = thin.add(<span class="number">8</span>).with_metadata_of(ptr);
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;*</span>ptr); <span class="comment">// 将打印 &quot;3&quot;
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn+main()+%7B%0Ause+core::fmt::Debug;%0Alet+arr:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0Alet+mut+ptr+=+arr.as_ptr()+as+*const+dyn+Debug;%0Alet+thin+=+ptr+as+*const+u8;%0Aunsafe+%7B%0A++++ptr+=+thin.add(8).with_metadata_of(ptr);%0Aassert_eq!(*(ptr+as+*const+i32),+3);%0A++++println!(%22%7B:?%7D%22,+%26*ptr);+//+%E5%B0%86%E6%89%93%E5%8D%B0+%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0, const since 1.65.0">1.65.0 (const: 1.65.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#108">source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_mut" class="fn">cast_mut</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>更改常量而不更改类型。</p>
<p>这比 <code>as</code> 安全一点，因为如果重构代码，它不会默默地改变类型。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bits" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#140-142">source</a><h4 class="code-header">pub fn <a href="#method.to_bits" class="fn">to_bits</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.67.0: replaced by the <code>expose_addr</code> method, or update your code to follow the strict provenance rules using its APIs</span></div><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_to_from_bits</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91126">#91126</a>)</span></div></span></summary><div class="docblock"><p>将指针强制转换为原始位。</p>
<p>这等效于 <code>as usize</code>，但更具体以增强可读性。
相反的方法是 <a href="#method.from_bits"><code>from_bits</code></a>。</p>
<p>特别是，<code>*p as usize</code> 和 <code>p as usize</code> 都会编译指向数字类型的指针，但做的事情却截然不同，因此使用它有助于强调读取位是有意的。</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_to_from_bits)]
</span><span class="kw">let </span>array = [<span class="number">13</span>, <span class="number">42</span>];
<span class="kw">let </span>p0: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>array[<span class="number">0</span>];
<span class="macro">assert_eq!</span>(&lt;<span class="kw-2">*const </span><span class="kw">_</span>&gt;::from_bits(p0.to_bits()), p0);
<span class="kw">let </span>p1: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>array[<span class="number">1</span>];
<span class="macro">assert_eq!</span>(p1.to_bits() - p0.to_bits(), <span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_to_from_bits)%5D%0Afn+main()+%7B%0A%23%5Bcfg(not(miri))%5D+%7B+//+doctest+%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%A5%E6%A0%BC%E7%9A%84%E5%87%BA%E5%A4%84%0Alet+array+=+%5B13,+42%5D;%0Alet+p0:+*const+i32+=+%26array%5B0%5D;%0Aassert_eq!(%3C*const+_%3E::from_bits(p0.to_bits()),+p0);%0Alet+p1:+*const+i32+=+%26array%5B1%5D;%0Aassert_eq!(p1.to_bits()+-+p0.to_bits(),+4);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bits" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#170-172">source</a><h4 class="code-header">pub fn <a href="#method.from_bits" class="fn">from_bits</a>(bits: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.67.0: replaced by the <code>ptr::from_exposed_addr</code> function, or update your code to follow the strict provenance rules using its APIs</span></div><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_to_from_bits</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91126">#91126</a>)</span></div></span></summary><div class="docblock"><p>从其原始位创建一个指针。</p>
<p>这等效于 <code>as *const T</code>，但更具体地说是为了增强可读性。
相反的方法是 <a href="#method.to_bits"><code>to_bits</code></a>。</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_to_from_bits)]
</span><span class="kw">use </span>std::ptr::NonNull;
<span class="kw">let </span>dangling: <span class="kw-2">*const </span>u8 = NonNull::dangling().as_ptr();
<span class="macro">assert_eq!</span>(&lt;<span class="kw-2">*const </span>u8&gt;::from_bits(<span class="number">1</span>), dangling);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_to_from_bits)%5D%0Afn+main()+%7B%0A%23%5Bcfg(not(miri))%5D+%7B+//+doctest+%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%A5%E6%A0%BC%E7%9A%84%E5%87%BA%E5%A4%84%0Ause+std::ptr::NonNull;%0Alet+dangling:+*const+u8+=+NonNull::dangling().as_ptr();%0Aassert_eq!(%3C*const+u8%3E::from_bits(1),+dangling);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.addr" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#203">source</a><h4 class="code-header">pub fn <a href="#method.addr" class="fn">addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>获取指针的 “address” 部分。</p>
<p>这类似于 <code>self as usize</code>，它在语义上丢弃了<em>provenance</em> 和<em>address-space</em> 信息。
但是，与 <code>self as usize</code> 不同，将返回的地址转换回指针会产生 <a href="ptr/fn.invalid.html" title="fn std::ptr::invalid"><code>invalid</code></a>，这对于解引用来说是未定义的行为。
要正确恢复丢失的信息并获得可解引用的指针，请使用 <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> 或 <a href="primitive.pointer.html#method.map_addr" title="method pointer::map_addr"><code>map_addr</code></a>。</p>
<p>如果由于无法保留具有所需出处的指针而无法使用这些 API，请改用 <a href="primitive.pointer.html#method.expose_addr" title="method pointer::expose_addr"><code>expose_addr</code></a> 和 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a>。</p>
<p>但是，请注意，这会降低您的代码的可移植性，并且不太适合用于检查是否符合 Rust 内存模型的工具。</p>
<p>在大多数平台上，这将产生一个与原始指针具有相同字节的值，因为所有字节都专用于描述地址。
需要在指针中存储附加信息的平台可以执行表示的改变，以产生仅包含指针的地址部分的值。
这意味着什么取决于平台来定义。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，因此可能会在 future 中发生变化 (包括可能削弱这一点，使其完全等同于 <code>self as usize</code>)。
有关详细信息，请参见 [<a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expose_addr" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#237">source</a><h4 class="code-header">pub fn <a href="#method.expose_addr" class="fn">expose_addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>获取指针的 “address” 部分，并暴露 “provenance” 部分，以便将来在 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a> 中使用。</p>
<p>这相当于 <code>self as usize</code>，它在语义上丢弃了 <em>provenance</em> 和 <em>address-space</em> 信息。
此外，这 (如 <code>as</code> cast  一样) 具有将出处标记为 ‘exposed’ 的隐式副作用，因此在支持它的平台上，您可以稍后调用 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a> 来重构原始指针，包括其出处。</p>
<p>(如果需要，重建地址空间信息是您的责任。)</p>
<p>使用这种方法意味着代码没有遵循严格的出处规则。
支持 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a> 会使规范和推理复杂化，并且可能不受帮助您与 Rust 内存模型保持一致的工具的支持，因此建议尽可能使用 <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a>。</p>
<p>在大多数平台上，这将产生一个与原始指针具有相同字节的值，因为所有字节都专用于描述地址。
需要在指针中存储附加信息的平台可能不支持此操作，因为 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a> 工作所需的 ‘expose’ 副作用通常不可用。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_addr" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#257">source</a><h4 class="code-header">pub fn <a href="#method.with_addr" class="fn">with_addr</a>(self, addr: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>使用给定地址创建一个新指针。</p>
<p>这执行与 <code>addr as ptr</code> 强制转换相同的操作，但将 <code>self</code> 的 <em>address-space</em> 和 <em>provenance</em> 复制到新指针。
这使我们能够动态地保存和传播这些重要信息，而这在其他情况下使用一元强制转换是不可能的。</p>
<p>这相当于使用 <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> 将 <code>self</code> 偏移到给定地址，因此具有所有相同的功能和限制。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_addr" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#280">source</a><h4 class="code-header">pub fn <a href="#method.map_addr" class="fn">map_addr</a>(self, f: impl <a class="trait" href="ops/trait.FnOnce.html" title="trait std::ops::FnOnce">FnOnce</a>(<a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>通过将 <code>self</code> 的地址映射到新地址来创建新指针。</p>
<p>这对 <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> 来说是一种方便，有关详细信息，请参见该方法。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_raw_parts" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/81513" title="Tracking issue for ptr_metadata">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#290">source</a></span><h4 class="code-header">pub fn <a href="#method.to_raw_parts" class="fn">to_raw_parts</a>(self) -&gt; (<a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</span></div></span></summary><div class="docblock"><p>将指针 (可能是宽指针) 分解为其地址和元数据组件。</p>
<p>以后可以使用 <a href="ptr/fn.from_raw_parts.html" title="fn std::ptr::from_raw_parts"><code>from_raw_parts</code></a> 重建指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#351">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_ref" class="fn">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a T</a>&gt;</h4></section></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a>。</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_ref() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {val_back}!&quot;</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A%0Aunsafe+%7B%0A++++if+let+Some(val_back)+=+ptr.as_ref()+%7B%0A++++++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A++++%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h5 id="空未经检查的版本"><a href="#空未经检查的版本">空未经检查的版本</a></h5>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;T</code> 而不是 <code>Option&lt;&amp;T&gt;</code> 的 <code>as_ref_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>val_back = <span class="kw-2">&amp;*</span>ptr;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {val_back}!&quot;</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A%0Aunsafe+%7B%0A++++let+val_back+=+%26*ptr;%0A++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_ref" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#397-399">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref" class="fn">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。
与 <a href="#method.as_ref"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_uninit)]

</span><span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = <span class="kw-2">&amp;</span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_uninit_ref() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, val_back.assume_init());
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn+main()+%7B%0Alet+ptr:+*const+u8+=+%2610u8+as+*const+u8;%0A%0Aunsafe+%7B%0A++++if+let+Some(val_back)+=+ptr.as_uninit_ref()+%7B%0A++++++++println!(%22We+got+back+the+value:+%7B%7D!%22,+val_back.assume_init());%0A++++%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><span class="rightside"><span class="since" title="const since 1.61.0">const: 1.61.0</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#460-462">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset" class="fn">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度总和 (以字节为单位) 必须适合于 usize。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_offset"><code>wrapping_offset</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;123&quot;</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22123%22;%0Alet+ptr:+*const+u8+=+s.as_ptr();%0A%0Aunsafe+%7B%0A++++println!(%22%7B%7D%22,+*ptr.offset(1)+as+char);%0A++++println!(%22%7B%7D%22,+*ptr.offset(2)+as+char);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#483">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_offset" class="fn">byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>计算与指针的偏移量 (以字节为单位)。</p>
<p><code>count</code> 以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.offset" title="method pointer::offset">offset</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const since 1.61.0">1.16.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#540-542">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_offset" class="fn">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.offset"><code>offset</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.offset"><code>offset</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_offset</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.offset"><code>offset</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素为增量进行迭代
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_offset(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;
</span><span class="kw">while </span>ptr != end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_offset(step);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*const+u8+=+data.as_ptr();%0Alet+step+=+2;%0Alet+end_rounded_up+=+ptr.wrapping_offset(6);%0A%0A//+%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0+%221,+3,+5,+%22%0Awhile+ptr+!=+end_rounded_up+%7B%0A++++unsafe+%7B%0A++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++%7D%0A++++ptr+=+ptr.wrapping_offset(step);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_offset" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#562">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_offset" class="fn">wrapping_byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。</p>
<p><code>count</code> 以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset">wrapping_offset</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mask" class="method"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#600">source</a><h4 class="code-header">pub fn <a href="#method.mask" class="fn">mask</a>(self, mask: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_mask</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/98290">#98290</a>)</span></div></span></summary><div class="docblock"><p>根据掩码屏蔽指针的位。</p>
<p>这对 <code>ptr.map_addr(|a| a &amp; mask)</code> 来说很方便。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
<h6 id="examples-11"><a href="#examples-11">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_mask, strict_provenance)]
</span><span class="kw">let </span>v = <span class="number">17_u32</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u32 = <span class="kw-2">&amp;</span>v;

<span class="comment">// `u32` 是 4 字节对齐的，这意味着低 2 位总是 0.
</span><span class="kw">let </span>tag_mask = <span class="number">0b11</span>;
<span class="kw">let </span>ptr_mask = !tag_mask;

<span class="comment">// 我们可以在这些低位存储一些东西
</span><span class="kw">let </span>tagged_ptr = ptr.map_addr(|a| a | <span class="number">0b10</span>);

<span class="comment">// 取回 &quot;tag&quot;
</span><span class="kw">let </span>tag = tagged_ptr.addr() &amp; tag_mask;
<span class="macro">assert_eq!</span>(tag, <span class="number">0b10</span>);

<span class="comment">// 注意 `tagged_ptr` 是未对齐的，它是 UB 读取它。
// 要获得原始指针 `mask` 可以使用:
</span><span class="kw">let </span>masked_ptr = tagged_ptr.mask(ptr_mask);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr }, <span class="number">17</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_mask,+strict_provenance)%5D%0Afn+main()+%7B%0Alet+v+=+17_u32;%0Alet+ptr:+*const+u32+=+%26v;%0A%0A//+%60u32%60+%E6%98%AF+4+%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E7%9A%84%EF%BC%8C%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E4%BD%8E+2+%E4%BD%8D%E6%80%BB%E6%98%AF+0.%0Alet+tag_mask+=+0b11;%0Alet+ptr_mask+=+!tag_mask;%0A%0A//+%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%BA%9B%E4%BD%8E%E4%BD%8D%E5%AD%98%E5%82%A8%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%0Alet+tagged_ptr+=+ptr.map_addr(%7Ca%7C+a+%7C+0b10);%0A%0A//+%E5%8F%96%E5%9B%9E+%22tag%22%0Alet+tag+=+tagged_ptr.addr()+%26+tag_mask;%0Aassert_eq!(tag,+0b10);%0A%0A//+%E6%B3%A8%E6%84%8F+%60tagged_ptr%60+%E6%98%AF%E6%9C%AA%E5%AF%B9%E9%BD%90%E7%9A%84%EF%BC%8C%E5%AE%83%E6%98%AF+UB+%E8%AF%BB%E5%8F%96%E5%AE%83%E3%80%82%0A//+%E8%A6%81%E8%8E%B7%E5%BE%97%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88+%60mask%60+%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8:%0Alet+masked_ptr+=+tagged_ptr.mask(ptr_mask);%0Aassert_eq!(unsafe+%7B+*masked_ptr+%7D,+17);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const since 1.65.0">1.47.0 (const: 1.65.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#689-691">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from" class="fn">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>计算两个指针之间的距离。返回值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>该函数是 <a href="#method.offset"><code>offset</code></a> 的逆函数。</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和其他指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>两个指针必须是指向同一对象的指针的 *derived。
(请参见下面的示例。)</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 必须是 <code>T</code> 大小的精确倍数。</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 不会溢出 <code>isize</code>。</p>
</li>
<li>
<p>该距离不能依赖于 “wrapping around” 地址空间。</p>
</li>
</ul>
<p>Rust 类型从不大于 <code>isize::MAX</code>，并且 Rust 分配从不环绕地址空间，因此，任何 Rust 类型 <code>T</code> 的某个值内的两个指针将始终满足最后两个条件。</p>
<p>标准库通常还确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不超过 <code>isize::MAX</code> 字节，因此 <code>ptr_into_vec.offset_from(vec.as_ptr())</code> 始终满足最后两个条件。</p>
<p>从根本上说，大多数平台甚至都无法构建如此大的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。
因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。
(请注意，<a href="#method.offset"><code>offset</code></a> 和 <a href="#method.add"><code>add</code></a> 也具有类似的限制，因此也不能在如此大的分配上使用。)</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<p>基本用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.offset_from(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset_from(ptr2), -<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.offset(-<span class="number">2</span>), ptr1);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+a+=+%5B0;+5%5D;%0Alet+ptr1:+*const+i32+=+%26a%5B1%5D;%0Alet+ptr2:+*const+i32+=+%26a%5B3%5D;%0Aunsafe+%7B%0A++++assert_eq!(ptr2.offset_from(ptr1),+2);%0A++++assert_eq!(ptr1.offset_from(ptr2),+-2);%0A++++assert_eq!(ptr1.offset(2),+ptr2);%0A++++assert_eq!(ptr2.offset(-2),+ptr1);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>不正确</em> 用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr1 = Box::into_raw(Box::new(<span class="number">0u8</span>)) <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">let </span>ptr2 = Box::into_raw(Box::new(<span class="number">1u8</span>)) <span class="kw">as </span><span class="kw-2">*const </span>u8;
<span class="kw">let </span>diff = (ptr2 <span class="kw">as </span>isize).wrapping_sub(ptr1 <span class="kw">as </span>isize);
<span class="comment">// 将 ptr2_other 设置为 ptr2 的 &quot;alias&quot;，但从 ptr1 派生。
</span><span class="kw">let </span>ptr2_other = (ptr1 <span class="kw">as </span><span class="kw-2">*const </span>u8).wrapping_offset(diff);
<span class="macro">assert_eq!</span>(ptr2 <span class="kw">as </span>usize, ptr2_other <span class="kw">as </span>usize);
<span class="comment">// 由于 ptr2_other 和 ptr2 是从指向不同对象的指针派生的，因此即使它们指向相同的地址，计算其偏移量也是未定义的行为！
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>zero = ptr2_other.offset_from(ptr2); <span class="comment">// 未定义的行为
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr1+=+Box::into_raw(Box::new(0u8))+as+*const+u8;%0Alet+ptr2+=+Box::into_raw(Box::new(1u8))+as+*const+u8;%0Alet+diff+=+(ptr2+as+isize).wrapping_sub(ptr1+as+isize);%0A//+%E5%B0%86+ptr2_other+%E8%AE%BE%E7%BD%AE%E4%B8%BA+ptr2+%E7%9A%84+%22alias%22%EF%BC%8C%E4%BD%86%E4%BB%8E+ptr1+%E6%B4%BE%E7%94%9F%E3%80%82%0Alet+ptr2_other+=+(ptr1+as+*const+u8).wrapping_offset(diff);%0Aassert_eq!(ptr2+as+usize,+ptr2_other+as+usize);%0A//+%E7%94%B1%E4%BA%8E+ptr2_other+%E5%92%8C+ptr2+%E6%98%AF%E4%BB%8E%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E6%B4%BE%E7%94%9F%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8D%B3%E4%BD%BF%E5%AE%83%E4%BB%AC%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%85%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%9F%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81%0Aunsafe+%7B%0A++++let+zero+=+ptr2_other.offset_from(ptr2);+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#712">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_offset_from" class="fn">byte_offset_from</a>&lt;U&gt;(self, origin: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a><span class="where fmt-newline">where
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>计算两个指针之间的距离。返回值以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.offset_from" title="method pointer::offset_from">offset_from</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅考虑数据指针，忽略元数据。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/95892" title="Tracking issue for const_ptr_sub_ptr">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#781-783">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.sub_ptr" class="fn">sub_ptr</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_sub_ptr</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95892">#95892</a>)</span></div></span></summary><div class="docblock"><p>计算两个指针之间的距离，<em>where 已知 <code>self</code> 等于或大于 <code>origin</code></em>。返回值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>这将计算 <a href="#method.offset_from"><code>offset_from</code></a> 将计算的相同值，但附加的前提条件是偏移量保证为非 negative。
此方法等同于 <code>usize::try_from(self.offset_from(origin)).unwrap_unchecked()</code>，但它为优化器提供了更多的信息，这有时可以使其在某些后端优化得更好。</p>
<p>这个方法可以看作是恢复传递给 <a href="#method.add"><code>add</code></a> 的 <code>count</code> (或者，使用其他顺序的参数，到 <a href="#method.sub"><code>sub</code></a>).
以下都是等价的，假设它们的安全先决条件得到满足:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ptr.sub_ptr(origin) == count
origin.add(count) == ptr
ptr.sub(count) == origin</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_sub_ptr)%5D%0Afn+main()+%7B%0Aunsafe+fn+blah(ptr:+*const+i32,+origin:+*const+i32,+count:+usize)+-%3E+bool+%7B%0Aptr.sub_ptr(origin)+==+count%0A%26%26%0Aorigin.add(count)+==+ptr%0A%26%26%0Aptr.sub(count)+==+origin%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<ul>
<li>
<p>指针之间的距离必须是非 negative (<code>self &gt;= origin</code>)</p>
</li>
<li>
<p><em>所有</em><a href="#method.offset_from"><code>offset_from</code></a> 的安全条件也适用于此方法; 查看完整的详细信息。</p>
</li>
</ul>
<p>重要的是，尽管此方法的返回类型能够表示更大的偏移量，但仍然<em>不允许</em>传递相差超过 <code>isize::MAX</code> <em>bytes</em> 的指针。
因此，此方法的结果将始终小于或等于 <code>isize::MAX as usize</code>。</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_sub_ptr)]

</span><span class="kw">let </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*const </span>i32 = <span class="kw-2">&amp;</span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.sub_ptr(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.add(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.sub(<span class="number">2</span>), ptr1);
    <span class="macro">assert_eq!</span>(ptr2.sub_ptr(ptr2), <span class="number">0</span>);
}

<span class="comment">// 这是不正确的，因为指针的顺序不正确:
// ptr1.sub_ptr(ptr2)</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_sub_ptr)%5D%0A%0Afn+main()+%7B%0Alet+a+=+%5B0;+5%5D;%0Alet+ptr1:+*const+i32+=+%26a%5B1%5D;%0Alet+ptr2:+*const+i32+=+%26a%5B3%5D;%0Aunsafe+%7B%0A++++assert_eq!(ptr2.sub_ptr(ptr1),+2);%0A++++assert_eq!(ptr1.add(2),+ptr2);%0A++++assert_eq!(ptr2.sub(2),+ptr1);%0A++++assert_eq!(ptr2.sub_ptr(ptr2),+0);%0A%7D%0A%0A//+%E8%BF%99%E6%98%AF%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E6%AD%A3%E7%A1%AE:%0A//+ptr1.sub_ptr(ptr2)%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_eq" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/53020" title="Tracking issue for const_raw_ptr_comparison">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#821-823">source</a></span><h4 class="code-header">pub fn <a href="#method.guaranteed_eq" class="fn">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>返回两个指针是否保证相等。</p>
<p>在运行时，这个函数的行为类似于 <code>Some(self == other)</code>。
但是，在某些情况下 (例如，编译时评估)，并不总是可以确定两个指针的相等性，因此该函数可能会虚假地返回 <code>None</code> 以获取稍后实际上证明其相等性已知的指针。</p>
<p>但是当它返回 <code>Some</code> 时，可以保证知道指针的相等性。</p>
<p>返回值可能会从 <code>Some</code> 更改为 <code>None</code>，反之亦然，具体取决于编译器版本，并且不安全的代码不能依赖此函数的结果来保证可靠性。
建议仅将此函数用于性能优化，其中此函数的虚假 <code>None</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_ne" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/53020" title="Tracking issue for const_raw_ptr_comparison">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#851-853">source</a></span><h4 class="code-header">pub fn <a href="#method.guaranteed_ne" class="fn">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>返回是否保证两个指针不相等。</p>
<p>在运行时，这个函数的行为类似于 <code>Some(self != other)</code>。
然而，在某些情况下 (例如，编译时求值)，并不总是可以确定两个指针的不等式，因此该函数可能会虚假地返回 <code>None</code> 以获取后来实际证明其不等式的指针。</p>
<p>但是当它返回 <code>Some</code> 时，指针的不等式保证是已知的。</p>
<p>返回值可能会从 <code>Some</code> 更改为 <code>None</code>，反之亦然，具体取决于编译器版本，并且不安全的代码不能依赖此函数的结果来保证可靠性。
建议仅将此函数用于性能优化，其中此函数的虚假 <code>None</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#915-917">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.add" class="fn">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset(count as isize)</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须符合 <code>usize</code>。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_add"><code>wrapping_add</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;123&quot;</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.add(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.add(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22123%22;%0Alet+ptr:+*const+u8+=+s.as_ptr();%0A%0Aunsafe+%7B%0A++++println!(%22%7B%7D%22,+*ptr.add(1)+as+char);%0A++++println!(%22%7B%7D%22,+*ptr.add(2)+as+char);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_add" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#946">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_add" class="fn">byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>以字节为单位计算指针的偏移量 (方便 <code>.byte_offset(count as isize)</code>)。</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.add" title="method pointer::add">add</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1006-1008">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.sub" class="fn">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset((count as isize).wrapping_neg())</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量不能超过 <code>isize::MAX</code> 个 <strong>字节</strong>。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须符合使用大小。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_sub"><code>wrapping_sub</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>end: <span class="kw-2">*const </span>u8 = s.as_ptr().add(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>end.sub(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>end.sub(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22123%22;%0A%0Aunsafe+%7B%0A++++let+end:+*const+u8+=+s.as_ptr().add(3);%0A++++println!(%22%7B%7D%22,+*end.sub(1)+as+char);%0A++++println!(%22%7B%7D%22,+*end.sub(2)+as+char);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_sub" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1030">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_sub" class="fn">byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>以字节为单位计算指针的偏移量 (方便 <code>.byte_offset((count as isize).wrapping_neg())</code>)。</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.sub" title="method pointer::sub">sub</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1088-1090">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset(count as isize)</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-9"><a href="#safety-9">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_add((y as usize) - (x as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.add"><code>add</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.add"><code>add</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_add</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.add"><code>add</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素为增量进行迭代
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_add(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;
</span><span class="kw">while </span>ptr != end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_add(step);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*const+u8+=+data.as_ptr();%0Alet+step+=+2;%0Alet+end_rounded_up+=+ptr.wrapping_add(6);%0A%0A//+%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0+%221,+3,+5,+%22%0Awhile+ptr+!=+end_rounded_up+%7B%0A++++unsafe+%7B%0A++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++%7D%0A++++ptr+=+ptr.wrapping_add(step);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_add" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1109">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_add" class="fn">wrapping_byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。
(便于 <code>.wrapping_byte_offset(计为 isize)</code>)</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_add" title="method pointer::wrapping_add">wrapping_add</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1166-1168">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-10"><a href="#safety-10">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.sub"><code>sub</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.sub"><code>sub</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_sub</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.sub"><code>sub</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素 (backwards) 为增量进行迭代
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>start_rounded_down = ptr.wrapping_sub(<span class="number">2</span>);
ptr = ptr.wrapping_add(<span class="number">4</span>);
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="comment">// 此循环打印 &quot;5, 3, 1, &quot;
</span><span class="kw">while </span>ptr != start_rounded_down {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_sub(step);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0+(backwards)+%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*const+u8+=+data.as_ptr();%0Alet+start_rounded_down+=+ptr.wrapping_sub(2);%0Aptr+=+ptr.wrapping_add(4);%0Alet+step+=+2;%0A//+%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0+%225,+3,+1,+%22%0Awhile+ptr+!=+start_rounded_down+%7B%0A++++unsafe+%7B%0A++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++%7D%0A++++ptr+=+ptr.wrapping_sub(step);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_sub" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1187">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_sub" class="fn">wrapping_byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_sub" title="method pointer::wrapping_sub">wrapping_sub</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1201-1203">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read" class="fn">read</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read.html" title="fn std::ptr::read"><code>ptr::read</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_volatile" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1222-1224">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile" class="fn">read_volatile</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>对 <code>self</code> 的值进行易失性读取，而无需移动它。这将使 <code>self</code> 中的内存保持不变。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_volatile.html" title="fn std::ptr::read_volatile"><code>ptr::read_volatile</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_unaligned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1242-1244">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned" class="fn">read_unaligned</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>与 <code>read</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_unaligned.html" title="fn std::ptr::read_unaligned"><code>ptr::read_unaligned</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1262-1264">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to" class="fn">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to_nonoverlapping" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1282-1284">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping" class="fn">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_offset" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const unstable">1.36.0 (const: <a href="https://github.com/rust-lang/rust/issues/90962" title="Tracking issue for const_align_offset">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1334-1336">source</a></span><h4 class="code-header">pub fn <a href="#method.align_offset" class="fn">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>计算为使其与 <code>align</code> 对齐而需要应用到指针的偏移量。</p>
<p>如果无法对齐指针，则实现将返回 <code>usize::MAX</code>。
允许实现 <em>始终</em> 返回 <code>usize::MAX</code>。
只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。</p>
<p>偏移量以 <code>T</code> 元素的数量表示，而不是以字节表示。返回的值可以与 <code>wrapping_add</code> 方法一起使用。</p>
<p>不能保证偏移指针不会溢出或超出指针所指向的分配范围。</p>
<p>调用者应确保返回的偏移量在对齐方式以外的所有方面都是正确的。</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>如果 <code>align</code> 不是 2 的幂，则函数 panics。</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<p>将相邻的 <code>u8</code> 作为 <code>u16</code> 进行访问</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::align_of;

<span class="kw">let </span>x = [<span class="number">5_u8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];
<span class="kw">let </span>ptr = x.as_ptr();
<span class="kw">let </span>offset = ptr.align_offset(align_of::&lt;u16&gt;());

<span class="kw">if </span>offset &lt; x.len() - <span class="number">1 </span>{
    <span class="kw">let </span>u16_ptr = ptr.add(offset).cast::&lt;u16&gt;();
    <span class="macro">assert!</span>(<span class="kw-2">*</span>u16_ptr == u16::from_ne_bytes([<span class="number">5</span>, <span class="number">6</span>]) || <span class="kw-2">*</span>u16_ptr == u16::from_ne_bytes([<span class="number">6</span>, <span class="number">7</span>]));
} <span class="kw">else </span>{
    <span class="comment">// 虽然指针可以通过 `offset` 对齐，但它会指向分配之外
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::align_of;%0A%0Aunsafe+%7B%0Alet+x+=+%5B5_u8,+6,+7,+8,+9%5D;%0Alet+ptr+=+x.as_ptr();%0Alet+offset+=+ptr.align_offset(align_of::%3Cu16%3E());%0A%0Aif+offset+%3C+x.len()+-+1+%7B%0A++++let+u16_ptr+=+ptr.add(offset).cast::%3Cu16%3E();%0A++++assert!(*u16_ptr+==+u16::from_ne_bytes(%5B5,+6%5D)+%7C%7C+*u16_ptr+==+u16::from_ne_bytes(%5B6,+7%5D));%0A%7D+else+%7B%0A++++//+%E8%99%BD%E7%84%B6%E6%8C%87%E9%92%88%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87+%60offset%60+%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%AE%83%E4%BC%9A%E6%8C%87%E5%90%91%E5%88%86%E9%85%8D%E4%B9%8B%E5%A4%96%0A%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/104203" title="Tracking issue for const_pointer_is_aligned">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1456-1458">source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned" class="fn">is_aligned</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>返回指针是否为 <code>T</code> 正确对齐。</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(pointer_byte_offsets)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned());
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">1</span>).is_aligned());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(pointer_byte_offsets)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Alet+data+=+AlignedI32(42);%0Alet+ptr+=+%26data+as+*const+AlignedI32;%0A%0Aassert!(ptr.is_aligned());%0Aassert!(!ptr.wrapping_byte_add(1).is_aligned());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="在编译时"><a href="#在编译时">在编译时</a></h5>
<p><strong>Note: 编译时的对齐是实验性的，可能会发生变化。有关详细信息，请参见 <a href="https://github.com/rust-lang/rust/issues/104203">tracking issue</a>。</strong></p>
<p>在编译时，编译器可能不知道值将在内存中的何处结束。
在编译时对从引用创建的指针调用此函数将仅在保证指针对齐的情况下返回 <code>true</code>。
这意味着如果将指针转换为比引用的底层分配具有更严格对齐的类型，则指针永远不会对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;
    <span class="macro">assert!</span>(ptr.is_aligned());

    <span class="comment">// 在运行时 `ptr1` 或 `ptr2` 将对齐，但在编译时两者都不对齐。
    </span><span class="kw">let </span>ptr1 = ptr.cast::&lt;AlignedI64&gt;();
    <span class="kw">let </span>ptr2 = ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;();
    <span class="macro">assert!</span>(!ptr1.is_aligned());
    <span class="macro">assert!</span>(!ptr2.is_aligned());
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0Aconst+_:+()+=+%7B%0A++++let+data+=+AlignedI32(42);%0A++++let+ptr+=+%26data+as+*const+AlignedI32;%0A++++assert!(ptr.is_aligned());%0A%0A++++//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6+%60ptr1%60+%E6%88%96+%60ptr2%60+%E5%B0%86%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E4%B8%A4%E8%80%85%E9%83%BD%E4%B8%8D%E5%AF%B9%E9%BD%90%E3%80%82%0A++++let+ptr1+=+ptr.cast::%3CAlignedI64%3E();%0A++++let+ptr2+=+ptr.wrapping_add(1).cast::%3CAlignedI64%3E();%0A++++assert!(!ptr1.is_aligned());%0A++++assert!(!ptr2.is_aligned());%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>由于此行为，即使编译时指针未对齐，派生自编译时指针的运行时指针也可能对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="comment">// 在编译时，`COMPTIME_PTR` 和 `COMPTIME_PTR + 1` 都没有对齐。
</span><span class="kw">const </span>COMPTIME_PTR: <span class="kw-2">*const </span>AlignedI32 = <span class="kw-2">&amp;</span>AlignedI32(<span class="number">42</span>);
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.cast::&lt;AlignedI64&gt;().is_aligned());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;().is_aligned());

<span class="comment">// 在运行时，`runtime_ptr` 或 `runtime_ptr + 1` 对齐。
</span><span class="kw">let </span>runtime_ptr = COMPTIME_PTR;
<span class="macro">assert_ne!</span>(
    runtime_ptr.cast::&lt;AlignedI64&gt;().is_aligned(),
    runtime_ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;().is_aligned(),
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0A//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%60COMPTIME_PTR%60+%E5%92%8C+%60COMPTIME_PTR+%2B+1%60+%E9%83%BD%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E3%80%82%0Aconst+COMPTIME_PTR:+*const+AlignedI32+=+%26AlignedI32(42);%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.cast::%3CAlignedI64%3E().is_aligned());%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.wrapping_add(1).cast::%3CAlignedI64%3E().is_aligned());%0A%0A//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%60runtime_ptr%60+%E6%88%96+%60runtime_ptr+%2B+1%60+%E5%AF%B9%E9%BD%90%E3%80%82%0Alet+runtime_ptr+=+COMPTIME_PTR;%0Aassert_ne!(%0A++++runtime_ptr.cast::%3CAlignedI64%3E().is_aligned(),%0A++++runtime_ptr.wrapping_add(1).cast::%3CAlignedI64%3E().is_aligned(),%0A);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>如果指针是从固定地址创建的，则此函数在运行时和编译时的行为相同。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span>ptr = <span class="number">40 </span><span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;
    <span class="macro">assert!</span>(ptr.is_aligned());

    <span class="comment">// 对于具有已知地址的指针，运行时和编译时行为是相同的。
    </span><span class="kw">let </span>ptr1 = ptr.cast::&lt;AlignedI64&gt;();
    <span class="kw">let </span>ptr2 = ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;();
    <span class="macro">assert!</span>(ptr1.is_aligned());
    <span class="macro">assert!</span>(!ptr2.is_aligned());
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0Aconst+_:+()+=+%7B%0A++++let+ptr+=+40+as+*const+AlignedI32;%0A++++assert!(ptr.is_aligned());%0A%0A++++//+%E5%AF%B9%E4%BA%8E%E5%85%B7%E6%9C%89%E5%B7%B2%E7%9F%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E8%A1%8C%E4%B8%BA%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%0A++++let+ptr1+=+ptr.cast::%3CAlignedI64%3E();%0A++++let+ptr2+=+ptr.wrapping_add(1).cast::%3CAlignedI64%3E();%0A++++assert!(ptr1.is_aligned());%0A++++assert!(!ptr2.is_aligned());%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned_to" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/104203" title="Tracking issue for const_pointer_is_aligned">unstable</a></span> · <a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1572">source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned_to" class="fn">is_aligned_to</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>返回指针是否与 <code>align</code> 对齐。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅考虑数据指针，而忽略元数据。</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>如果 <code>align</code> 不是 2 的幂 (包括 0)，函数会出现 panic。</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(pointer_byte_offsets)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

<span class="macro">assert!</span>(ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">4</span>));

<span class="macro">assert_ne!</span>(ptr.is_aligned_to(<span class="number">8</span>), ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(pointer_byte_offsets)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Alet+data+=+AlignedI32(42);%0Alet+ptr+=+%26data+as+*const+AlignedI32;%0A%0Aassert!(ptr.is_aligned_to(1));%0Aassert!(ptr.is_aligned_to(2));%0Aassert!(ptr.is_aligned_to(4));%0A%0Aassert!(ptr.wrapping_byte_add(2).is_aligned_to(2));%0Aassert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));%0A%0Aassert_ne!(ptr.is_aligned_to(8),+ptr.wrapping_add(1).is_aligned_to(8));%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="在编译时-1"><a href="#在编译时-1">在编译时</a></h5>
<p><strong>Note: 编译时的对齐是实验性的，可能会发生变化。有关详细信息，请参见 <a href="https://github.com/rust-lang/rust/issues/104203">tracking issue</a>。</strong></p>
<p>在编译时，编译器可能不知道值将在内存中的何处结束。
在编译时对从引用创建的指针调用此函数将仅在保证指针对齐的情况下返回 <code>true</code>。
这意味着指针不能比引用的底层分配更严格地对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span>data = AlignedI32(<span class="number">42</span>);
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>data <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32;

    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

    <span class="comment">// 在编译时，我们确定指针没有对齐到 8.
    </span><span class="macro">assert!</span>(!ptr.is_aligned_to(<span class="number">8</span>));
    <span class="macro">assert!</span>(!ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Aconst+_:+()+=+%7B%0A++++let+data+=+AlignedI32(42);%0A++++let+ptr+=+%26data+as+*const+AlignedI32;%0A%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A%0A++++//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A1%AE%E5%AE%9A%E6%8C%87%E9%92%88%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E5%88%B0+8.%0A++++assert!(!ptr.is_aligned_to(8));%0A++++assert!(!ptr.wrapping_add(1).is_aligned_to(8));%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>由于此行为，即使编译时指针未对齐，派生自编译时指针的运行时指针也可能对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="comment">// 在编译时，`COMPTIME_PTR` 和 `COMPTIME_PTR + 1` 都没有对齐。
</span><span class="kw">const </span>COMPTIME_PTR: <span class="kw-2">*const </span>AlignedI32 = <span class="kw-2">&amp;</span>AlignedI32(<span class="number">42</span>);
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.is_aligned_to(<span class="number">8</span>));
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));

<span class="comment">// 在运行时，`runtime_ptr` 或 `runtime_ptr + 1` 对齐。
</span><span class="kw">let </span>runtime_ptr = COMPTIME_PTR;
<span class="macro">assert_ne!</span>(
    runtime_ptr.is_aligned_to(<span class="number">8</span>),
    runtime_ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>),
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0A//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%60COMPTIME_PTR%60+%E5%92%8C+%60COMPTIME_PTR+%2B+1%60+%E9%83%BD%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E3%80%82%0Aconst+COMPTIME_PTR:+*const+AlignedI32+=+%26AlignedI32(42);%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.is_aligned_to(8));%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));%0A%0A//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%60runtime_ptr%60+%E6%88%96+%60runtime_ptr+%2B+1%60+%E5%AF%B9%E9%BD%90%E3%80%82%0Alet+runtime_ptr+=+COMPTIME_PTR;%0Aassert_ne!(%0A++++runtime_ptr.is_aligned_to(8),%0A++++runtime_ptr.wrapping_add(1).is_aligned_to(8),%0A);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>如果指针是从固定地址创建的，则此函数在运行时和编译时的行为相同。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="kw">const _</span>: () = {
    <span class="kw">let </span>ptr = <span class="number">40 </span><span class="kw">as </span><span class="kw-2">*const </span>u8;
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">8</span>));
    <span class="macro">assert!</span>(!ptr.is_aligned_to(<span class="number">16</span>));
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0Afn+main()+%7B%0Aconst+_:+()+=+%7B%0A++++let+ptr+=+40+as+*const+u8;%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A++++assert!(ptr.is_aligned_to(8));%0A++++assert!(!ptr.is_aligned_to(16));%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#6">source</a><a href="#impl-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_null-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/74939" title="Tracking issue for const_ptr_is_null">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#33">source</a></span><h4 class="code-header">pub fn <a href="#method.is_null-1" class="fn">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>如果指针为空，则返回 <code>true</code>。</p>
<p>请注意，未定义大小的类型具有许多可能的空指针，因为仅考虑原始数据指针，而不考虑其长度，vtable 等。
因此，两个为空的指针可能仍不能相互比较相等。</p>
<h6 id="常量评估期间的行为-1"><a href="#常量评估期间的行为-1">常量评估期间的行为</a></h6>
<p>在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能返回 <code>false</code>。
具体来说，当指向某个内存的指针超出其范围的偏移量 (使结果指针为空) 时，函数仍将返回 <code>false</code>。</p>
<p>CTFE 无法知道该内存的绝对位置，因此我们无法确定指针是否为空。</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="macro">assert!</span>(!ptr.is_null());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+s+=+%5B1,+2,+3%5D;%0Alet+ptr:+*mut+u32+=+s.as_mut_ptr();%0Aassert!(!ptr.is_null());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#57">source</a></span><h4 class="code-header">pub const fn <a href="#method.cast-1" class="fn">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a></h4></section></summary><div class="docblock"><p>强制转换为另一种类型的指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_metadata_of-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/75091" title="Tracking issue for set_ptr_value">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#93-95">source</a></span><h4 class="code-header">pub fn <a href="#method.with_metadata_of-1" class="fn">with_metadata_of</a>&lt;U&gt;(self, meta: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a><span class="where fmt-newline">where
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</span></div></span></summary><div class="docblock"><p>在另一种类型的新指针中使用指针值。</p>
<p>如果 <code>meta</code> 是指向未定义大小类型的 (fat) 指针，此操作将忽略指针部分，而对于指向大小类型的 (thin) 指针，这与简单强制转换具有相同的效果。</p>
<p>生成的指针将具有 <code>self</code> 的来源，即，对于胖指针，此操作在语义上与创建数据指针值为 <code>self</code> 但元数据为 <code>meta</code> 的新胖指针相同。</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>此函数主要用于允许对潜在的胖指针进行按字节指针算术运算：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(set_ptr_value)]
</span><span class="kw">let </span><span class="kw-2">mut </span>arr: [i32; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr = arr.as_mut_ptr() <span class="kw">as </span><span class="kw-2">*mut </span><span class="kw">dyn </span>Debug;
<span class="kw">let </span>thin = ptr <span class="kw">as </span><span class="kw-2">*mut </span>u8;
<span class="kw">unsafe </span>{
    ptr = thin.add(<span class="number">8</span>).with_metadata_of(ptr);
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;*</span>ptr); <span class="comment">// 将打印 &quot;3&quot;
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn+main()+%7B%0Ause+core::fmt::Debug;%0Alet+mut+arr:+%5Bi32;+3%5D+=+%5B1,+2,+3%5D;%0Alet+mut+ptr+=+arr.as_mut_ptr()+as+*mut+dyn+Debug;%0Alet+thin+=+ptr+as+*mut+u8;%0Aunsafe+%7B%0A++++ptr+=+thin.add(8).with_metadata_of(ptr);%0Aassert_eq!(*(ptr+as+*mut+i32),+3);%0A++++println!(%22%7B:?%7D%22,+%26*ptr);+//+%E5%B0%86%E6%89%93%E5%8D%B0+%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast_const" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.65.0, const since 1.65.0">1.65.0 (const: 1.65.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#113">source</a></span><h4 class="code-header">pub const fn <a href="#method.cast_const" class="fn">cast_const</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>更改常量而不更改类型。</p>
<p>这比 <code>as</code> 安全一点，因为如果重构代码，它不会默默地改变类型。</p>
<p>虽然不是严格要求 (<code>*mut T</code> 强制转换为 <code>*const T</code>)，但这是为了与 <code>*const T</code> 上的 <a href="#method.cast_mut"><code>cast_mut</code></a> 对称而提供的，如果使用它来代替隐式强制，则可能具有文档值。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_bits-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#146-148">source</a><h4 class="code-header">pub fn <a href="#method.to_bits-1" class="fn">to_bits</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.67.0: replaced by the <code>expose_addr</code> method, or update your code to follow the strict provenance rules using its APIs</span></div><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_to_from_bits</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91126">#91126</a>)</span></div></span></summary><div class="docblock"><p>将指针强制转换为原始位。</p>
<p>这等效于 <code>as usize</code>，但更具体以增强可读性。
相反的方法是 <a href="#method.from_bits-1"><code>from_bits</code></a>。</p>
<p>特别是，<code>*p as usize</code> 和 <code>p as usize</code> 都会编译指向数字类型的指针，但做的事情却截然不同，因此使用它有助于强调读取位是有意的。</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_to_from_bits)]
</span><span class="kw">let </span><span class="kw-2">mut </span>array = [<span class="number">13</span>, <span class="number">42</span>];
<span class="kw">let </span><span class="kw-2">mut </span>it = array.iter_mut();
<span class="kw">let </span>p0: <span class="kw-2">*mut </span>i32 = it.next().unwrap();
<span class="macro">assert_eq!</span>(&lt;<span class="kw-2">*mut </span><span class="kw">_</span>&gt;::from_bits(p0.to_bits()), p0);
<span class="kw">let </span>p1: <span class="kw-2">*mut </span>i32 = it.next().unwrap();
<span class="macro">assert_eq!</span>(p1.to_bits() - p0.to_bits(), <span class="number">4</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_to_from_bits)%5D%0Afn+main()+%7B%0A%23%5Bcfg(not(miri))%5D+%7B+//+doctest+%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%A5%E6%A0%BC%E7%9A%84%E5%87%BA%E5%A4%84%0Alet+mut+array+=+%5B13,+42%5D;%0Alet+mut+it+=+array.iter_mut();%0Alet+p0:+*mut+i32+=+it.next().unwrap();%0Aassert_eq!(%3C*mut+_%3E::from_bits(p0.to_bits()),+p0);%0Alet+p1:+*mut+i32+=+it.next().unwrap();%0Aassert_eq!(p1.to_bits()+-+p0.to_bits(),+4);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bits-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#176-178">source</a><h4 class="code-header">pub fn <a href="#method.from_bits-1" class="fn">from_bits</a>(bits: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.67.0: replaced by the <code>ptr::from_exposed_addr_mut</code> function, or update your code to follow the strict provenance rules using its APIs</span></div><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_to_from_bits</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/91126">#91126</a>)</span></div></span></summary><div class="docblock"><p>从其原始位创建一个指针。</p>
<p>这等效于 <code>as *mut T</code>，但更具体以增强可读性。
相反的方法是 <a href="#method.to_bits-1"><code>to_bits</code></a>。</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_to_from_bits)]
</span><span class="kw">use </span>std::ptr::NonNull;
<span class="kw">let </span>dangling: <span class="kw-2">*mut </span>u8 = NonNull::dangling().as_ptr();
<span class="macro">assert_eq!</span>(&lt;<span class="kw-2">*mut </span>u8&gt;::from_bits(<span class="number">1</span>), dangling);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_to_from_bits)%5D%0Afn+main()+%7B%0A%23%5Bcfg(not(miri))%5D+%7B+//+doctest+%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%A5%E6%A0%BC%E7%9A%84%E5%87%BA%E5%A4%84%0Ause+std::ptr::NonNull;%0Alet+dangling:+*mut+u8+=+NonNull::dangling().as_ptr();%0Aassert_eq!(%3C*mut+u8%3E::from_bits(1),+dangling);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.addr-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#209">source</a><h4 class="code-header">pub fn <a href="#method.addr-1" class="fn">addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>获取指针的 “address” 部分。</p>
<p>这类似于 <code>self as usize</code>，它在语义上丢弃了<em>provenance</em> 和<em>address-space</em> 信息。
但是，与 <code>self as usize</code> 不同，将返回的地址转换回指针会产生 <a href="ptr/fn.invalid.html" title="fn std::ptr::invalid"><code>invalid</code></a>，这对于解引用来说是未定义的行为。
要正确恢复丢失的信息并获得可解引用的指针，请使用 <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> 或 <a href="primitive.pointer.html#method.map_addr" title="method pointer::map_addr"><code>map_addr</code></a>。</p>
<p>如果由于无法保留具有所需出处的指针而无法使用这些 API，请改用 <a href="primitive.pointer.html#method.expose_addr" title="method pointer::expose_addr"><code>expose_addr</code></a> 和 <a href="ptr/fn.from_exposed_addr_mut.html" title="fn std::ptr::from_exposed_addr_mut"><code>from_exposed_addr_mut</code></a>。</p>
<p>但是，请注意，这会降低您的代码的可移植性，并且不太适合用于检查是否符合 Rust 内存模型的工具。</p>
<p>在大多数平台上，这将产生一个与原始指针具有相同字节的值，因为所有字节都专用于描述地址。
需要在指针中存储附加信息的平台可以执行表示的改变，以产生仅包含指针的地址部分的值。
这意味着什么取决于平台来定义。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，因此可能会在 future 中发生变化 (包括可能削弱这一点，使其完全等同于 <code>self as usize</code>)。
有关详细信息，请参见 [<a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.expose_addr-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#243">source</a><h4 class="code-header">pub fn <a href="#method.expose_addr-1" class="fn">expose_addr</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>获取指针的 “address” 部分，并暴露 “provenance” 部分，以便将来在 <a href="ptr/fn.from_exposed_addr.html" title="fn std::ptr::from_exposed_addr"><code>from_exposed_addr</code></a> 中使用。</p>
<p>这相当于 <code>self as usize</code>，它在语义上丢弃了 <em>provenance</em> 和 <em>address-space</em> 信息。
此外，这 (如 <code>as</code> 演员表) 具有将出处标记为 ‘exposed’ 的隐式副作用，因此在支持它的平台上，您可以稍后调用 <a href="ptr/fn.from_exposed_addr_mut.html" title="fn std::ptr::from_exposed_addr_mut"><code>from_exposed_addr_mut</code></a> 来重构原始指针，包括其出处。</p>
<p>(如果需要，重建地址空间信息是您的责任。)</p>
<p>使用这种方法意味着代码没有遵循严格的出处规则。
支持 <a href="ptr/fn.from_exposed_addr_mut.html" title="fn std::ptr::from_exposed_addr_mut"><code>from_exposed_addr_mut</code></a> 会使规范和推理复杂化，并且可能不受帮助您与 Rust 内存模型保持一致的工具的支持，因此建议尽可能使用 <a href="primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a>。</p>
<p>在大多数平台上，这将产生一个与原始指针具有相同字节的值，因为所有字节都专用于描述地址。
需要在指针中存储附加信息的平台可能不支持此操作，因为 <a href="ptr/fn.from_exposed_addr_mut.html" title="fn std::ptr::from_exposed_addr_mut"><code>from_exposed_addr_mut</code></a> 工作所需的 ‘expose’ 副作用通常不可用。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_addr-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#263">source</a><h4 class="code-header">pub fn <a href="#method.with_addr-1" class="fn">with_addr</a>(self, addr: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>使用给定地址创建一个新指针。</p>
<p>这执行与 <code>addr as ptr</code> 强制转换相同的操作，但将 <code>self</code> 的 <em>address-space</em> 和 <em>provenance</em> 复制到新指针。
这使我们能够动态地保存和传播这些重要信息，而这在其他情况下使用一元强制转换是不可能的。</p>
<p>这相当于使用 <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> 将 <code>self</code> 偏移到给定地址，因此具有所有相同的功能和限制。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_addr-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#286">source</a><h4 class="code-header">pub fn <a href="#method.map_addr-1" class="fn">map_addr</a>(self, f: impl <a class="trait" href="ops/trait.FnOnce.html" title="trait std::ops::FnOnce">FnOnce</a>(<a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>strict_provenance</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95228">#95228</a>)</span></div></span></summary><div class="docblock"><p>通过将 <code>self</code> 的地址映射到新地址来创建新指针。</p>
<p>这对 <a href="primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> 来说是一种方便，有关详细信息，请参见该方法。</p>
<p>此 API 及其声明的语义是 Strict Provenance 实验的一部分，有关详细信息，请参见 <a href="ptr/index.html" title="mod std::ptr">模块文档</a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_raw_parts-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/81513" title="Tracking issue for ptr_metadata">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#296">source</a></span><h4 class="code-header">pub fn <a href="#method.to_raw_parts-1" class="fn">to_raw_parts</a>(self) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</span></div></span></summary><div class="docblock"><p>将指针 (可能是宽指针) 分解为其地址和元数据组件。</p>
<p>以后可以使用 <a href="ptr/fn.from_raw_parts_mut.html" title="fn std::ptr::from_raw_parts_mut"><code>from_raw_parts_mut</code></a> 重建指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#360">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_ref-1" class="fn">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a T</a>&gt;</h4></section></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_mut"><code>as_mut</code></a>。</p>
<h5 id="safety-11"><a href="#safety-11">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_ref() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {val_back}!&quot;</span>);
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A%0Aunsafe+%7B%0A++++if+let+Some(val_back)+=+ptr.as_ref()+%7B%0A++++++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A++++%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h5 id="空未经检查的版本-1"><a href="#空未经检查的版本-1">空未经检查的版本</a></h5>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;T</code> 而不是 <code>Option&lt;&amp;T&gt;</code> 的 <code>as_ref_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>val_back = <span class="kw-2">&amp;*</span>ptr;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {val_back}!&quot;</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A%0Aunsafe+%7B%0A++++let+val_back+=+%26*ptr;%0A++++println!(%22We+got+back+the+value:+%7Bval_back%7D!%22);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_ref-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#409-411">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref-1" class="fn">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。
与 <a href="#method.as_ref-1"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>。</p>
<h5 id="safety-12"><a href="#safety-12">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_as_uninit)]

</span><span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u8 = <span class="kw-2">&amp;mut </span><span class="number">10u8 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;

<span class="kw">unsafe </span>{
    <span class="kw">if let </span><span class="prelude-val">Some</span>(val_back) = ptr.as_uninit_ref() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, val_back.assume_init());
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn+main()+%7B%0Alet+ptr:+*mut+u8+=+%26mut+10u8+as+*mut+u8;%0A%0Aunsafe+%7B%0A++++if+let+Some(val_back)+=+ptr.as_uninit_ref()+%7B%0A++++++++println!(%22We+got+back+the+value:+%7B%7D!%22,+val_back.assume_init());%0A++++%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset-1" class="method"><span class="rightside"><span class="since" title="const since 1.61.0">const: 1.61.0</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#472-474">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset-1" class="fn">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-13"><a href="#safety-13">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度总和 (以字节为单位) 必须适合于 usize。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_offset"><code>wrapping_offset</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.offset(<span class="number">2</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+s+=+%5B1,+2,+3%5D;%0Alet+ptr:+*mut+u32+=+s.as_mut_ptr();%0A%0Aunsafe+%7B%0A++++println!(%22%7B%7D%22,+*ptr.offset(1));%0A++++println!(%22%7B%7D%22,+*ptr.offset(2));%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#507">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_offset-1" class="fn">byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>计算与指针的偏移量 (以字节为单位)。</p>
<p><code>count</code> 以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.offset" title="method pointer::offset">offset</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0, const since 1.61.0">1.16.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#563-565">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_offset-1" class="fn">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
<code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-14"><a href="#safety-14">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.offset"><code>offset</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.offset"><code>offset</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_offset</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.offset"><code>offset</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素为增量进行迭代
</span><span class="kw">let </span><span class="kw-2">mut </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*mut </span>u8 = data.as_mut_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_offset(<span class="number">6</span>);

<span class="kw">while </span>ptr != end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="kw-2">*</span>ptr = <span class="number">0</span>;
    }
    ptr = ptr.wrapping_offset(step);
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>data, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+mut+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*mut+u8+=+data.as_mut_ptr();%0Alet+step+=+2;%0Alet+end_rounded_up+=+ptr.wrapping_offset(6);%0A%0Awhile+ptr+!=+end_rounded_up+%7B%0A++++unsafe+%7B%0A++++++++*ptr+=+0;%0A++++%7D%0A++++ptr+=+ptr.wrapping_offset(step);%0A%7D%0Aassert_eq!(%26data,+%26%5B0,+2,+0,+4,+0%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_offset-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#585">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_offset-1" class="fn">wrapping_byte_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。</p>
<p><code>count</code> 以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset">wrapping_offset</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mask-1" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#626">source</a><h4 class="code-header">pub fn <a href="#method.mask-1" class="fn">mask</a>(self, mask: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_mask</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/98290">#98290</a>)</span></div></span></summary><div class="docblock"><p>根据掩码屏蔽指针的位。</p>
<p>这对 <code>ptr.map_addr(|a| a &amp; mask)</code> 来说很方便。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
<h6 id="examples-29"><a href="#examples-29">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_mask, strict_provenance)]
</span><span class="kw">let </span><span class="kw-2">mut </span>v = <span class="number">17_u32</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = <span class="kw-2">&amp;mut </span>v;

<span class="comment">// `u32` 是 4 字节对齐的，这意味着低 2 位总是 0.
</span><span class="kw">let </span>tag_mask = <span class="number">0b11</span>;
<span class="kw">let </span>ptr_mask = !tag_mask;

<span class="comment">// 我们可以在这些低位存储一些东西
</span><span class="kw">let </span>tagged_ptr = ptr.map_addr(|a| a | <span class="number">0b10</span>);

<span class="comment">// 取回 &quot;tag&quot;
</span><span class="kw">let </span>tag = tagged_ptr.addr() &amp; tag_mask;
<span class="macro">assert_eq!</span>(tag, <span class="number">0b10</span>);

<span class="comment">// 注意 `tagged_ptr` 是未对齐的，它是 UB 读取 from/write 到它。
// 要获得原始指针 `mask` 可以使用:
</span><span class="kw">let </span>masked_ptr = tagged_ptr.mask(ptr_mask);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr }, <span class="number">17</span>);

<span class="kw">unsafe </span>{ <span class="kw-2">*</span>masked_ptr = <span class="number">0 </span>};
<span class="macro">assert_eq!</span>(v, <span class="number">0</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_mask,+strict_provenance)%5D%0Afn+main()+%7B%0Alet+mut+v+=+17_u32;%0Alet+ptr:+*mut+u32+=+%26mut+v;%0A%0A//+%60u32%60+%E6%98%AF+4+%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E7%9A%84%EF%BC%8C%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E4%BD%8E+2+%E4%BD%8D%E6%80%BB%E6%98%AF+0.%0Alet+tag_mask+=+0b11;%0Alet+ptr_mask+=+!tag_mask;%0A%0A//+%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%BA%9B%E4%BD%8E%E4%BD%8D%E5%AD%98%E5%82%A8%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%0Alet+tagged_ptr+=+ptr.map_addr(%7Ca%7C+a+%7C+0b10);%0A%0A//+%E5%8F%96%E5%9B%9E+%22tag%22%0Alet+tag+=+tagged_ptr.addr()+%26+tag_mask;%0Aassert_eq!(tag,+0b10);%0A%0A//+%E6%B3%A8%E6%84%8F+%60tagged_ptr%60+%E6%98%AF%E6%9C%AA%E5%AF%B9%E9%BD%90%E7%9A%84%EF%BC%8C%E5%AE%83%E6%98%AF+UB+%E8%AF%BB%E5%8F%96+from/write+%E5%88%B0%E5%AE%83%E3%80%82%0A//+%E8%A6%81%E8%8E%B7%E5%BE%97%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88+%60mask%60+%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8:%0Alet+masked_ptr+=+tagged_ptr.mask(ptr_mask);%0Aassert_eq!(unsafe+%7B+*masked_ptr+%7D,+17);%0A%0Aunsafe+%7B+*masked_ptr+=+0+%7D;%0Aassert_eq!(v,+0);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0, const unstable">1.9.0 (const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#689">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_mut" class="fn">as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut T</a>&gt;</h4></section></summary><div class="docblock"><p>如果指针为 null，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的唯一引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>。</p>
<p>有关共享副本，请参见 <a href="#method.as_ref-1"><code>as_ref</code></a>。</p>
<h5 id="safety-15"><a href="#safety-15">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能通过任何其他指针访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="kw">let </span>first_value = <span class="kw">unsafe </span>{ ptr.as_mut().unwrap() };
<span class="kw-2">*</span>first_value = <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{s:?}&quot;</span>); <span class="comment">// 它会打印: &quot;[4, 2, 3]&quot;。</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+s+=+%5B1,+2,+3%5D;%0Alet+ptr:+*mut+u32+=+s.as_mut_ptr();%0Alet+first_value+=+unsafe+%7B+ptr.as_mut().unwrap()+%7D;%0A*first_value+=+4;%0Aassert_eq!(s,+%5B4,+2,+3%5D);%0Aprintln!(%22%7Bs:?%7D%22);+//+%E5%AE%83%E4%BC%9A%E6%89%93%E5%8D%B0:+%22%5B4,+2,+3%5D%22%E3%80%82%0A%7D&amp;edition=2021">Run</a></div>
<h5 id="空未经检查的版本-2"><a href="#空未经检查的版本-2">空未经检查的版本</a></h5>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;mut T</code> 而不是 <code>Option&lt;&amp;mut T&gt;</code> 的 <code>as_mut_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr: <span class="kw-2">*mut </span>u32 = s.as_mut_ptr();
<span class="kw">let </span>first_value = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>ptr };
<span class="kw-2">*</span>first_value = <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{s:?}&quot;</span>); <span class="comment">// 它会打印: &quot;[4, 2, 3]&quot;。</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+s+=+%5B1,+2,+3%5D;%0Alet+ptr:+*mut+u32+=+s.as_mut_ptr();%0Alet+first_value+=+unsafe+%7B+%26mut+*ptr+%7D;%0A*first_value+=+4;%0Aassert_eq!(s,+%5B4,+2,+3%5D);%0Aprintln!(%22%7Bs:?%7D%22);+//+%E5%AE%83%E4%BC%9A%E6%89%93%E5%8D%B0:+%22%5B4,+2,+3%5D%22%E3%80%82%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_mut" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#724-726">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_mut" class="fn">as_uninit_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a mut <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为 null，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的唯一引用。
与 <a href="#method.as_mut"><code>as_mut</code></a> 相比，这不需要将该值初始化。</p>
<p>有关共享副本，请参见 <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>。</p>
<h5 id="safety-16"><a href="#safety-16">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety" title="mod std::ptr">模块的文档</a> 中定义的含义上，它必须是 “dereferenceable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，当这个引用存在时，指针指向的内存不能通过任何其他指针访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_eq-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/53020" title="Tracking issue for const_raw_ptr_comparison">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#753-755">source</a></span><h4 class="code-header">pub fn <a href="#method.guaranteed_eq-1" class="fn">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>返回两个指针是否保证相等。</p>
<p>在运行时，这个函数的行为类似于 <code>Some(self == other)</code>。
但是，在某些情况下 (例如，编译时评估)，并不总是可以确定两个指针的相等性，因此该函数可能会虚假地返回 <code>None</code> 以获取稍后实际上证明其相等性已知的指针。</p>
<p>但是当它返回 <code>Some</code> 时，可以保证知道指针的相等性。</p>
<p>返回值可能会从 <code>Some</code> 更改为 <code>None</code>，反之亦然，具体取决于编译器版本，并且不安全的代码不能依赖此函数的结果来保证可靠性。
建议仅将此函数用于性能优化，其中此函数的虚假 <code>None</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.guaranteed_ne-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/53020" title="Tracking issue for const_raw_ptr_comparison">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#780-782">source</a></span><h4 class="code-header">pub fn <a href="#method.guaranteed_ne-1" class="fn">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.bool.html">bool</a>&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</span></div></span></summary><div class="docblock"><p>返回是否保证两个指针不相等。</p>
<p>在运行时，这个函数的行为类似于 <code>Some(self != other)</code>。
然而，在某些情况下 (例如，编译时求值)，并不总是可以确定两个指针的不等式，因此该函数可能会虚假地返回 <code>None</code> 以获取后来实际证明其不等式的指针。</p>
<p>但是当它返回 <code>Some</code> 时，指针的不等式保证是已知的。</p>
<p>返回值可能会从 <code>Some</code> 更改为 <code>None</code>，反之亦然，具体取决于编译器版本，并且不安全的代码不能依赖此函数的结果来保证可靠性。
建议仅将此函数用于性能优化，其中此函数的虚假 <code>None</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset_from-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.47.0, const since 1.65.0">1.47.0 (const: 1.65.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#872-874">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from-1" class="fn">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><div class="docblock"><p>计算两个指针之间的距离。返回值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>该函数是 <a href="#method.offset-1"><code>offset</code></a> 的逆函数。</p>
<h5 id="safety-17"><a href="#safety-17">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和其他指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>两个指针必须是指向同一对象的指针的 *derived。
(请参见下面的示例。)</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 必须是 <code>T</code> 大小的精确倍数。</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 不会溢出 <code>isize</code>。</p>
</li>
<li>
<p>该距离不能依赖于 “wrapping around” 地址空间。</p>
</li>
</ul>
<p>Rust 类型从不大于 <code>isize::MAX</code>，并且 Rust 分配从不环绕地址空间，因此，任何 Rust 类型 <code>T</code> 的某个值内的两个指针将始终满足最后两个条件。</p>
<p>标准库通常还确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不超过 <code>isize::MAX</code> 字节，因此 <code>ptr_into_vec.offset_from(vec.as_ptr())</code> 始终满足最后两个条件。</p>
<p>从根本上说，大多数平台甚至都无法构建如此大的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。
因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。
(请注意，<a href="#method.offset-1"><code>offset</code></a> 和 <a href="#method.add"><code>add</code></a> 也具有类似的限制，因此也不能在如此大的分配上使用。)</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<p>基本用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>a[<span class="number">1</span>];
<span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>i32 = <span class="kw-2">&amp;mut </span>a[<span class="number">3</span>];
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(ptr2.offset_from(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset_from(ptr2), -<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.offset(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.offset(-<span class="number">2</span>), ptr1);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+a+=+%5B0;+5%5D;%0Alet+ptr1:+*mut+i32+=+%26mut+a%5B1%5D;%0Alet+ptr2:+*mut+i32+=+%26mut+a%5B3%5D;%0Aunsafe+%7B%0A++++assert_eq!(ptr2.offset_from(ptr1),+2);%0A++++assert_eq!(ptr1.offset_from(ptr2),+-2);%0A++++assert_eq!(ptr1.offset(2),+ptr2);%0A++++assert_eq!(ptr2.offset(-2),+ptr1);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>不正确</em> 用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ptr1 = Box::into_raw(Box::new(<span class="number">0u8</span>));
<span class="kw">let </span>ptr2 = Box::into_raw(Box::new(<span class="number">1u8</span>));
<span class="kw">let </span>diff = (ptr2 <span class="kw">as </span>isize).wrapping_sub(ptr1 <span class="kw">as </span>isize);
<span class="comment">// 将 ptr2_other 设置为 ptr2 的 &quot;alias&quot;，但从 ptr1 派生。
</span><span class="kw">let </span>ptr2_other = (ptr1 <span class="kw">as </span><span class="kw-2">*mut </span>u8).wrapping_offset(diff);
<span class="macro">assert_eq!</span>(ptr2 <span class="kw">as </span>usize, ptr2_other <span class="kw">as </span>usize);
<span class="comment">// 由于 ptr2_other 和 ptr2 是从指向不同对象的指针派生的，因此即使它们指向相同的地址，计算其偏移量也是未定义的行为！
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>zero = ptr2_other.offset_from(ptr2); <span class="comment">// 未定义的行为
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+ptr1+=+Box::into_raw(Box::new(0u8));%0Alet+ptr2+=+Box::into_raw(Box::new(1u8));%0Alet+diff+=+(ptr2+as+isize).wrapping_sub(ptr1+as+isize);%0A//+%E5%B0%86+ptr2_other+%E8%AE%BE%E7%BD%AE%E4%B8%BA+ptr2+%E7%9A%84+%22alias%22%EF%BC%8C%E4%BD%86%E4%BB%8E+ptr1+%E6%B4%BE%E7%94%9F%E3%80%82%0Alet+ptr2_other+=+(ptr1+as+*mut+u8).wrapping_offset(diff);%0Aassert_eq!(ptr2+as+usize,+ptr2_other+as+usize);%0A//+%E7%94%B1%E4%BA%8E+ptr2_other+%E5%92%8C+ptr2+%E6%98%AF%E4%BB%8E%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E6%B4%BE%E7%94%9F%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8D%B3%E4%BD%BF%E5%AE%83%E4%BB%AC%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%85%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%9F%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81%0Aunsafe+%7B%0A++++let+zero+=+ptr2_other.offset_from(ptr2);+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_offset_from-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#893">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_offset_from-1" class="fn">byte_offset_from</a>&lt;U&gt;(self, origin: <a class="primitive" href="primitive.pointer.html">*const U</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a><span class="where fmt-newline">where
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>计算两个指针之间的距离。返回值以 <strong>字节</strong> 为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.offset_from" title="method pointer::offset_from">offset_from</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅考虑数据指针，忽略元数据。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub_ptr-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/95892" title="Tracking issue for const_ptr_sub_ptr">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#963-965">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.sub_ptr-1" class="fn">sub_ptr</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_sub_ptr</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95892">#95892</a>)</span></div></span></summary><div class="docblock"><p>计算两个指针之间的距离，<em>where 已知 <code>self</code> 等于或大于 <code>origin</code></em>。返回值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>这将计算 <a href="#method.offset_from"><code>offset_from</code></a> 将计算的相同值，但附加的前提条件是偏移量保证为非 negative。
此方法等同于 <code>usize::try_from(self.offset_from(origin)).unwrap_unchecked()</code>，但它为优化器提供了更多的信息，这有时可以使其在某些后端优化得更好。</p>
<p>这个方法可以看作是恢复传递给 <a href="#method.add"><code>add</code></a> 的 <code>count</code> (或者，使用其他顺序的参数，到 <a href="#method.sub"><code>sub</code></a>).
以下都是等价的，假设它们的安全先决条件得到满足:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ptr.sub_ptr(origin) == count
origin.add(count) == ptr
ptr.sub(count) == origin</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_sub_ptr)%5D%0Afn+main()+%7B%0Aunsafe+fn+blah(ptr:+*mut+i32,+origin:+*mut+i32,+count:+usize)+-%3E+bool+%7B%0Aptr.sub_ptr(origin)+==+count%0A%26%26%0Aorigin.add(count)+==+ptr%0A%26%26%0Aptr.sub(count)+==+origin%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="safety-18"><a href="#safety-18">Safety</a></h5>
<ul>
<li>
<p>指针之间的距离必须是非 negative (<code>self &gt;= origin</code>)</p>
</li>
<li>
<p><em>所有</em><a href="#method.offset_from"><code>offset_from</code></a> 的安全条件也适用于此方法; 查看完整的详细信息。</p>
</li>
</ul>
<p>重要的是，尽管此方法的返回类型能够表示更大的偏移量，但仍然<em>不允许</em>传递相差超过 <code>isize::MAX</code> <em>bytes</em> 的指针。
因此，此方法的结果将始终小于或等于 <code>isize::MAX as usize</code>。</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(ptr_sub_ptr)]

</span><span class="kw">let </span><span class="kw-2">mut </span>a = [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let </span>p: <span class="kw-2">*mut </span>i32 = a.as_mut_ptr();
<span class="kw">unsafe </span>{ <span class="kw">let </span>ptr1: <span class="kw-2">*mut </span>i32 = p.add(<span class="number">1</span>);
    <span class="kw">let </span>ptr2: <span class="kw-2">*mut </span>i32 = p.add(<span class="number">3</span>);

    <span class="macro">assert_eq!</span>(ptr2.sub_ptr(ptr1), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(ptr1.add(<span class="number">2</span>), ptr2);
    <span class="macro">assert_eq!</span>(ptr2.sub(<span class="number">2</span>), ptr1);
    <span class="macro">assert_eq!</span>(ptr2.sub_ptr(ptr2), <span class="number">0</span>);
}

<span class="comment">// 这是不正确的，因为指针的顺序不正确:
// ptr1.offset_from(ptr2)








</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_sub_ptr)%5D%0A%0Afn+main()+%7B%0Alet+mut+a+=+%5B0;+5%5D;%0Alet+p:+*mut+i32+=+a.as_mut_ptr();%0Aunsafe+%7B+let+ptr1:+*mut+i32+=+p.add(1);%0A++++let+ptr2:+*mut+i32+=+p.add(3);%0A%0A++++assert_eq!(ptr2.sub_ptr(ptr1),+2);%0A++++assert_eq!(ptr1.add(2),+ptr2);%0A++++assert_eq!(ptr2.sub(2),+ptr1);%0A++++assert_eq!(ptr2.sub_ptr(ptr2),+0);%0A%7D%0A%0A//+%E8%BF%99%E6%98%AF%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E6%AD%A3%E7%A1%AE:%0A//+ptr1.offset_from(ptr2)%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1025-1027">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.add-1" class="fn">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset(count as isize)</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-19"><a href="#safety-19">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须符合 <code>usize</code>。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_add"><code>wrapping_add</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;123&quot;</span>;
<span class="kw">let </span>ptr: <span class="kw-2">*const </span>u8 = s.as_ptr();

<span class="kw">unsafe </span>{
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.add(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>ptr.add(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22123%22;%0Alet+ptr:+*const+u8+=+s.as_ptr();%0A%0Aunsafe+%7B%0A++++println!(%22%7B%7D%22,+*ptr.add(1)+as+char);%0A++++println!(%22%7B%7D%22,+*ptr.add(2)+as+char);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_add-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1056">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_add-1" class="fn">byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>以字节为单位计算指针的偏移量 (方便 <code>.byte_offset(count as isize)</code>)。</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.add" title="method pointer::add">add</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1116-1118">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.sub-1" class="fn">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset((count as isize).wrapping_neg())</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-20"><a href="#safety-20">Safety</a></h5>
<p>如果违反以下任一条件，则结果为未定义行为：</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量不能超过 <code>isize::MAX</code> 个 <strong>字节</strong>。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须符合使用大小。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_sub"><code>wrapping_sub</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s: <span class="kw-2">&amp;</span>str = <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="kw">let </span>end: <span class="kw-2">*const </span>u8 = s.as_ptr().add(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>end.sub(<span class="number">1</span>) <span class="kw">as </span>char);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span>end.sub(<span class="number">2</span>) <span class="kw">as </span>char);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+s:+%26str+=+%22123%22;%0A%0Aunsafe+%7B%0A++++let+end:+*const+u8+=+s.as_ptr().add(3);%0A++++println!(%22%7B%7D%22,+*end.sub(1)+as+char);%0A++++println!(%22%7B%7D%22,+*end.sub(2)+as+char);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_sub-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1140">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.byte_sub-1" class="fn">byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>以字节为单位计算指针的偏移量 (方便 <code>.byte_offset((count as isize).wrapping_neg())</code>)。</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.sub" title="method pointer::sub">sub</a>。
有关文档和安全要求，请参见该方法。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1198-1200">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_add-1" class="fn">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset(count as isize)</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-21"><a href="#safety-21">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_add((y as usize) - (x as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.add"><code>add</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.add"><code>add</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_add</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.add"><code>add</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素为增量进行迭代
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="kw">let </span>end_rounded_up = ptr.wrapping_add(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;
</span><span class="kw">while </span>ptr != end_rounded_up {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_add(step);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*const+u8+=+data.as_ptr();%0Alet+step+=+2;%0Alet+end_rounded_up+=+ptr.wrapping_add(6);%0A%0A//+%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0+%221,+3,+5,+%22%0Awhile+ptr+!=+end_rounded_up+%7B%0A++++unsafe+%7B%0A++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++%7D%0A++++ptr+=+ptr.wrapping_add(step);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_add-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1219">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_add-1" class="fn">wrapping_byte_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。
(便于 <code>.wrapping_byte_offset(计为 isize)</code>)</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_add" title="method pointer::wrapping_add">wrapping_add</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.61.0">1.26.0 (const: 1.61.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1276-1278">source</a></span><h4 class="code-header">pub const fn <a href="#method.wrapping_sub-1" class="fn">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位； 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h5 id="safety-22"><a href="#safety-22">Safety</a></h5>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a>； 它不得用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.sub"><code>sub</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.sub"><code>sub</code></a> 是跨越对象边界时的立即未定义行为； <code>wrapping_sub</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.sub"><code>sub</code></a> 可以更好地优化，因此在性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 使用裸指针以两个元素 (backwards) 为增量进行迭代
</span><span class="kw">let </span>data = [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let </span><span class="kw-2">mut </span>ptr: <span class="kw-2">*const </span>u8 = data.as_ptr();
<span class="kw">let </span>start_rounded_down = ptr.wrapping_sub(<span class="number">2</span>);
ptr = ptr.wrapping_add(<span class="number">4</span>);
<span class="kw">let </span>step = <span class="number">2</span>;
<span class="comment">// 此循环打印 &quot;5, 3, 1, &quot;
</span><span class="kw">while </span>ptr != start_rounded_down {
    <span class="kw">unsafe </span>{
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span>ptr);
    }
    ptr = ptr.wrapping_sub(step);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0+(backwards)+%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn+main()+%7B%0Alet+data+=+%5B1u8,+2,+3,+4,+5%5D;%0Alet+mut+ptr:+*const+u8+=+data.as_ptr();%0Alet+start_rounded_down+=+ptr.wrapping_sub(2);%0Aptr+=+ptr.wrapping_add(4);%0Alet+step+=+2;%0A//+%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0+%225,+3,+1,+%22%0Awhile+ptr+!=+start_rounded_down+%7B%0A++++unsafe+%7B%0A++++++++print!(%22%7B%7D,+%22,+*ptr);%0A++++%7D%0A++++ptr+=+ptr.wrapping_sub(step);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_byte_sub-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96283" title="Tracking issue for const_pointer_byte_offsets">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1297">source</a></span><h4 class="code-header">pub fn <a href="#method.wrapping_byte_sub-1" class="fn">wrapping_byte_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_byte_offsets</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96283">#96283</a>)</span></div></span></summary><div class="docblock"><p>使用环绕算法计算与指针的偏移量 (以字节为单位)。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以字节为单位。</p>
<p>这纯粹是为了方便转换为 <code>u8</code> 指针并在其上使用 <a href="primitive.pointer.html#method.wrapping_sub" title="method pointer::wrapping_sub">wrapping_sub</a>。
请参见该方法以获取文档。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅更改数据指针，而保留元数据不变。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1311-1313">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read-1" class="fn">read</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read.html" title="fn std::ptr::read"><code>ptr::read</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_volatile-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1332-1334">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile-1" class="fn">read_volatile</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>对 <code>self</code> 的值进行易失性读取，而无需移动它。这将使 <code>self</code> 中的内存保持不变。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_volatile.html" title="fn std::ptr::read_volatile"><code>ptr::read_volatile</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_unaligned-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.71.0">1.26.0 (const: 1.71.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1352-1354">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned-1" class="fn">read_unaligned</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>与 <code>read</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_unaligned.html" title="fn std::ptr::read_unaligned"><code>ptr::read_unaligned</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1372-1374">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to-1" class="fn">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_to_nonoverlapping-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1392-1394">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping-1" class="fn">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1412-1414">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from" class="fn">copy_from</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>src</code> 复制到 <code>self</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这具有 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a> 的 <em>相反</em> 参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html" title="fn std::ptr::copy"><code>ptr::copy</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from_nonoverlapping" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const since 1.63.0">1.26.0 (const: 1.63.0)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1432-1434">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from_nonoverlapping" class="fn">copy_from_nonoverlapping</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>src</code> 复制到 <code>self</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这具有 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a> 的 <em>相反</em> 参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html" title="fn std::ptr::copy_nonoverlapping"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drop_in_place" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1447">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.drop_in_place" class="fn">drop_in_place</a>(self)</h4></section></summary><div class="docblock"><p>执行指向值的析构函数 (如果有)。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.drop_in_place.html" title="fn std::ptr::drop_in_place"><code>ptr::drop_in_place</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/86302" title="Tracking issue for const_ptr_write">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1462-1464">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.write" class="fn">write</a>(self, val: T)</h4></section></summary><div class="docblock"><p>用给定值覆盖存储位置，而无需读取或丢弃旧值。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write.html" title="fn std::ptr::write"><code>ptr::write</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/86302" title="Tracking issue for const_ptr_write">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1481-1483">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.write_bytes" class="fn">write_bytes</a>(self, val: <a class="primitive" href="primitive.u8.html">u8</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>在指定的指针上调用 memset，将 <code>self</code> 开始的 <code>count * size_of::&lt;T&gt;()</code> 内存字节设置为 <code>val</code>。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_bytes.html" title="fn std::ptr::write_bytes"><code>ptr::write_bytes</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_volatile" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1502-1504">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.write_volatile" class="fn">write_volatile</a>(self, val: T)</h4></section></summary><div class="docblock"><p>使用给定值对存储单元执行易失性写操作，而无需读取或丢弃旧值。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_volatile.html" title="fn std::ptr::write_volatile"><code>ptr::write_volatile</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_unaligned" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/86302" title="Tracking issue for const_ptr_write">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1522-1524">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.write_unaligned" class="fn">write_unaligned</a>(self, val: T)</h4></section></summary><div class="docblock"><p>用给定值覆盖存储位置，而无需读取或丢弃旧值。</p>
<p>与 <code>write</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_unaligned.html" title="fn std::ptr::write_unaligned"><code>ptr::write_unaligned</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1538-1540">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.replace" class="fn">replace</a>(self, src: T) -&gt; T</h4></section></summary><div class="docblock"><p>用 <code>src</code> 替换 <code>self</code> 处的值，返回旧值，但不丢弃任何一个。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.replace.html" title="fn std::ptr::replace"><code>ptr::replace</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0, const unstable">1.26.0 (const: <a href="https://github.com/rust-lang/rust/issues/83163" title="Tracking issue for const_swap">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1556-1558">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.swap" class="fn">swap</a>(self, with: <a class="primitive" href="primitive.pointer.html">*mut T</a>)</h4></section></summary><div class="docblock"><p>在相同类型的两个可变位置交换值，而无需取消初始化任何一个。
它们可能重叠，这与 <code>mem::swap</code> 不同，后者在其他方面是等效的。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.swap.html" title="fn std::ptr::swap"><code>ptr::swap</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.align_offset-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const unstable">1.36.0 (const: <a href="https://github.com/rust-lang/rust/issues/90962" title="Tracking issue for const_align_offset">unstable</a>)</span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1610-1612">source</a></span><h4 class="code-header">pub fn <a href="#method.align_offset-1" class="fn">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>计算为使其与 <code>align</code> 对齐而需要应用到指针的偏移量。</p>
<p>如果无法对齐指针，则实现将返回 <code>usize::MAX</code>。
允许实现 <em>始终</em> 返回 <code>usize::MAX</code>。
只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。</p>
<p>偏移量以 <code>T</code> 元素的数量表示，而不是以字节表示。返回的值可以与 <code>wrapping_add</code> 方法一起使用。</p>
<p>不能保证偏移指针不会溢出或超出指针所指向的分配范围。</p>
<p>调用者应确保返回的偏移量在对齐方式以外的所有方面都是正确的。</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>如果 <code>align</code> 不是 2 的幂，则函数 panics。</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<p>将相邻的 <code>u8</code> 作为 <code>u16</code> 进行访问</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::align_of;

<span class="kw">let </span><span class="kw-2">mut </span>x = [<span class="number">5_u8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];
<span class="kw">let </span>ptr = x.as_mut_ptr();
<span class="kw">let </span>offset = ptr.align_offset(align_of::&lt;u16&gt;());

<span class="kw">if </span>offset &lt; x.len() - <span class="number">1 </span>{
    <span class="kw">let </span>u16_ptr = ptr.add(offset).cast::&lt;u16&gt;();
    <span class="kw-2">*</span>u16_ptr = <span class="number">0</span>;

    <span class="macro">assert!</span>(x == [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] || x == [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>]);
} <span class="kw">else </span>{
    <span class="comment">// 虽然指针可以通过 `offset` 对齐，但它会指向分配之外
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::align_of;%0A%0Aunsafe+%7B%0Alet+mut+x+=+%5B5_u8,+6,+7,+8,+9%5D;%0Alet+ptr+=+x.as_mut_ptr();%0Alet+offset+=+ptr.align_offset(align_of::%3Cu16%3E());%0A%0Aif+offset+%3C+x.len()+-+1+%7B%0A++++let+u16_ptr+=+ptr.add(offset).cast::%3Cu16%3E();%0A++++*u16_ptr+=+0;%0A%0A++++assert!(x+==+%5B0,+0,+7,+8,+9%5D+%7C%7C+x+==+%5B5,+0,+0,+8,+9%5D);%0A%7D+else+%7B%0A++++//+%E8%99%BD%E7%84%B6%E6%8C%87%E9%92%88%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87+%60offset%60+%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%AE%83%E4%BC%9A%E6%8C%87%E5%90%91%E5%88%86%E9%85%8D%E4%B9%8B%E5%A4%96%0A%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/104203" title="Tracking issue for const_pointer_is_aligned">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1734-1736">source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned-1" class="fn">is_aligned</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>返回指针是否为 <code>T</code> 正确对齐。</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(pointer_byte_offsets)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned());
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">1</span>).is_aligned());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(pointer_byte_offsets)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Alet+mut+data+=+AlignedI32(42);%0Alet+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A%0Aassert!(ptr.is_aligned());%0Aassert!(!ptr.wrapping_byte_add(1).is_aligned());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="在编译时-2"><a href="#在编译时-2">在编译时</a></h5>
<p><strong>Note: 编译时的对齐是实验性的，可能会发生变化。有关详细信息，请参见 <a href="https://github.com/rust-lang/rust/issues/104203">tracking issue</a>。</strong></p>
<p>在编译时，编译器可能不知道值将在内存中的何处结束。
在编译时对从引用创建的指针调用此函数将仅在保证指针对齐的情况下返回 <code>true</code>。
这意味着如果将指针转换为比引用的底层分配具有更严格对齐的类型，则指针永远不会对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]
#![feature(const_mut_refs)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;
    <span class="macro">assert!</span>(ptr.is_aligned());

    <span class="comment">// 在运行时 `ptr1` 或 `ptr2` 将对齐，但在编译时两者都不对齐。
    </span><span class="kw">let </span>ptr1 = ptr.cast::&lt;AlignedI64&gt;();
    <span class="kw">let </span>ptr2 = ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;();
    <span class="macro">assert!</span>(!ptr1.is_aligned());
    <span class="macro">assert!</span>(!ptr2.is_aligned());
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%23!%5Bfeature(const_mut_refs)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0Aconst+_:+()+=+%7B%0A++++let+mut+data+=+AlignedI32(42);%0A++++let+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A++++assert!(ptr.is_aligned());%0A%0A++++//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6+%60ptr1%60+%E6%88%96+%60ptr2%60+%E5%B0%86%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E4%B8%A4%E8%80%85%E9%83%BD%E4%B8%8D%E5%AF%B9%E9%BD%90%E3%80%82%0A++++let+ptr1+=+ptr.cast::%3CAlignedI64%3E();%0A++++let+ptr2+=+ptr.wrapping_add(1).cast::%3CAlignedI64%3E();%0A++++assert!(!ptr1.is_aligned());%0A++++assert!(!ptr2.is_aligned());%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>由于此行为，即使编译时指针未对齐，派生自编译时指针的运行时指针也可能对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="comment">// 在编译时，`COMPTIME_PTR` 和 `COMPTIME_PTR + 1` 都没有对齐。
// 另请注意，可变引用不允许出现在常量的最终值中。
</span><span class="kw">const </span>COMPTIME_PTR: <span class="kw-2">*mut </span>AlignedI32 = (<span class="kw-2">&amp;</span>AlignedI32(<span class="number">42</span>) <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32).cast_mut();
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.cast::&lt;AlignedI64&gt;().is_aligned());
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;().is_aligned());

<span class="comment">// 在运行时，`runtime_ptr` 或 `runtime_ptr + 1` 对齐。
</span><span class="kw">let </span>runtime_ptr = COMPTIME_PTR;
<span class="macro">assert_ne!</span>(
    runtime_ptr.cast::&lt;AlignedI64&gt;().is_aligned(),
    runtime_ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;().is_aligned(),
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0A//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%60COMPTIME_PTR%60+%E5%92%8C+%60COMPTIME_PTR+%2B+1%60+%E9%83%BD%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E3%80%82%0A//+%E5%8F%A6%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%80%E7%BB%88%E5%80%BC%E4%B8%AD%E3%80%82%0Aconst+COMPTIME_PTR:+*mut+AlignedI32+=+(%26AlignedI32(42)+as+*const+AlignedI32).cast_mut();%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.cast::%3CAlignedI64%3E().is_aligned());%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.wrapping_add(1).cast::%3CAlignedI64%3E().is_aligned());%0A%0A//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%60runtime_ptr%60+%E6%88%96+%60runtime_ptr+%2B+1%60+%E5%AF%B9%E9%BD%90%E3%80%82%0Alet+runtime_ptr+=+COMPTIME_PTR;%0Aassert_ne!(%0A++++runtime_ptr.cast::%3CAlignedI64%3E().is_aligned(),%0A++++runtime_ptr.wrapping_add(1).cast::%3CAlignedI64%3E().is_aligned(),%0A);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>如果指针是从固定地址创建的，则此函数在运行时和编译时的行为相同。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，图元的对齐方式小于它们的大小。
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);
<span class="attr">#[repr(align(<span class="number">8</span>))]
</span><span class="kw">struct </span>AlignedI64(i64);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span>ptr = <span class="number">40 </span><span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;
    <span class="macro">assert!</span>(ptr.is_aligned());

    <span class="comment">// 对于具有已知地址的指针，运行时和编译时行为是相同的。
    </span><span class="kw">let </span>ptr1 = ptr.cast::&lt;AlignedI64&gt;();
    <span class="kw">let </span>ptr2 = ptr.wrapping_add(<span class="number">1</span>).cast::&lt;AlignedI64&gt;();
    <span class="macro">assert!</span>(ptr1.is_aligned());
    <span class="macro">assert!</span>(!ptr2.is_aligned());
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%9B%BE%E5%85%83%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%B0%8F%E4%BA%8E%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%23%5Brepr(align(8))%5D%0Astruct+AlignedI64(i64);%0A%0Aconst+_:+()+=+%7B%0A++++let+ptr+=+40+as+*mut+AlignedI32;%0A++++assert!(ptr.is_aligned());%0A%0A++++//+%E5%AF%B9%E4%BA%8E%E5%85%B7%E6%9C%89%E5%B7%B2%E7%9F%A5%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%92%8C%E7%BC%96%E8%AF%91%E6%97%B6%E8%A1%8C%E4%B8%BA%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%0A++++let+ptr1+=+ptr.cast::%3CAlignedI64%3E();%0A++++let+ptr2+=+ptr.wrapping_add(1).cast::%3CAlignedI64%3E();%0A++++assert!(ptr1.is_aligned());%0A++++assert!(!ptr2.is_aligned());%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_aligned_to-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/104203" title="Tracking issue for const_pointer_is_aligned">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1852">source</a></span><h4 class="code-header">pub fn <a href="#method.is_aligned_to-1" class="fn">is_aligned_to</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>pointer_is_aligned</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96284">#96284</a>)</span></div></span></summary><div class="docblock"><p>返回指针是否与 <code>align</code> 对齐。</p>
<p>对于非 <code>Sized</code> 指针，此操作仅考虑数据指针，而忽略元数据。</p>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>如果 <code>align</code> 不是 2 的幂 (包括 0)，函数会出现 panic。</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(pointer_byte_offsets)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;

<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

<span class="macro">assert!</span>(ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">2</span>));
<span class="macro">assert!</span>(!ptr.wrapping_byte_add(<span class="number">2</span>).is_aligned_to(<span class="number">4</span>));

<span class="macro">assert_ne!</span>(ptr.is_aligned_to(<span class="number">8</span>), ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(pointer_byte_offsets)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Alet+mut+data+=+AlignedI32(42);%0Alet+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A%0Aassert!(ptr.is_aligned_to(1));%0Aassert!(ptr.is_aligned_to(2));%0Aassert!(ptr.is_aligned_to(4));%0A%0Aassert!(ptr.wrapping_byte_add(2).is_aligned_to(2));%0Aassert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));%0A%0Aassert_ne!(ptr.is_aligned_to(8),+ptr.wrapping_add(1).is_aligned_to(8));%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="在编译时-3"><a href="#在编译时-3">在编译时</a></h5>
<p><strong>Note: 编译时的对齐是实验性的，可能会发生变化。有关详细信息，请参见 <a href="https://github.com/rust-lang/rust/issues/104203">tracking issue</a>。</strong></p>
<p>在编译时，编译器可能不知道值将在内存中的何处结束。
在编译时对从引用创建的指针调用此函数将仅在保证指针对齐的情况下返回 <code>true</code>。
这意味着指针不能比引用的底层分配更严格地对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]
#![feature(const_mut_refs)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="kw">const _</span>: () = {
    <span class="kw">let </span><span class="kw-2">mut </span>data = AlignedI32(<span class="number">42</span>);
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>data <span class="kw">as </span><span class="kw-2">*mut </span>AlignedI32;

    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));

    <span class="comment">// 在编译时，我们确定指针没有对齐到 8.
    </span><span class="macro">assert!</span>(!ptr.is_aligned_to(<span class="number">8</span>));
    <span class="macro">assert!</span>(!ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%23!%5Bfeature(const_mut_refs)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0Aconst+_:+()+=+%7B%0A++++let+mut+data+=+AlignedI32(42);%0A++++let+ptr+=+%26mut+data+as+*mut+AlignedI32;%0A%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A%0A++++//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A1%AE%E5%AE%9A%E6%8C%87%E9%92%88%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E5%88%B0+8.%0A++++assert!(!ptr.is_aligned_to(8));%0A++++assert!(!ptr.wrapping_add(1).is_aligned_to(8));%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>由于此行为，即使编译时指针未对齐，派生自编译时指针的运行时指针也可能对齐。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="comment">// 在某些平台上，i32 的对齐小于 4.
</span><span class="attr">#[repr(align(<span class="number">4</span>))]
</span><span class="kw">struct </span>AlignedI32(i32);

<span class="comment">// 在编译时，`COMPTIME_PTR` 和 `COMPTIME_PTR + 1` 都没有对齐。
// 另请注意，可变引用不允许出现在常量的最终值中。
</span><span class="kw">const </span>COMPTIME_PTR: <span class="kw-2">*mut </span>AlignedI32 = (<span class="kw-2">&amp;</span>AlignedI32(<span class="number">42</span>) <span class="kw">as </span><span class="kw-2">*const </span>AlignedI32).cast_mut();
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.is_aligned_to(<span class="number">8</span>));
<span class="kw">const _</span>: () = <span class="macro">assert!</span>(!COMPTIME_PTR.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>));

<span class="comment">// 在运行时，`runtime_ptr` 或 `runtime_ptr + 1` 对齐。
</span><span class="kw">let </span>runtime_ptr = COMPTIME_PTR;
<span class="macro">assert_ne!</span>(
    runtime_ptr.is_aligned_to(<span class="number">8</span>),
    runtime_ptr.wrapping_add(<span class="number">1</span>).is_aligned_to(<span class="number">8</span>),
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0A//+%E5%9C%A8%E6%9F%90%E4%BA%9B%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8Ci32+%E7%9A%84%E5%AF%B9%E9%BD%90%E5%B0%8F%E4%BA%8E+4.%0Afn+main()+%7B%0A%23%5Brepr(align(4))%5D%0Astruct+AlignedI32(i32);%0A%0A//+%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%EF%BC%8C%60COMPTIME_PTR%60+%E5%92%8C+%60COMPTIME_PTR+%2B+1%60+%E9%83%BD%E6%B2%A1%E6%9C%89%E5%AF%B9%E9%BD%90%E3%80%82%0A//+%E5%8F%A6%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%80%E7%BB%88%E5%80%BC%E4%B8%AD%E3%80%82%0Aconst+COMPTIME_PTR:+*mut+AlignedI32+=+(%26AlignedI32(42)+as+*const+AlignedI32).cast_mut();%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.is_aligned_to(8));%0Aconst+_:+()+=+assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));%0A%0A//+%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%60runtime_ptr%60+%E6%88%96+%60runtime_ptr+%2B+1%60+%E5%AF%B9%E9%BD%90%E3%80%82%0Alet+runtime_ptr+=+COMPTIME_PTR;%0Aassert_ne!(%0A++++runtime_ptr.is_aligned_to(8),%0A++++runtime_ptr.wrapping_add(1).is_aligned_to(8),%0A);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>如果指针是从固定地址创建的，则此函数在运行时和编译时的行为相同。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(pointer_is_aligned)]
#![feature(const_pointer_is_aligned)]

</span><span class="kw">const _</span>: () = {
    <span class="kw">let </span>ptr = <span class="number">40 </span><span class="kw">as </span><span class="kw-2">*mut </span>u8;
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">1</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">2</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">4</span>));
    <span class="macro">assert!</span>(ptr.is_aligned_to(<span class="number">8</span>));
    <span class="macro">assert!</span>(!ptr.is_aligned_to(<span class="number">16</span>));
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(pointer_is_aligned)%5D%0A%23!%5Bfeature(const_pointer_is_aligned)%5D%0A%0Afn+main()+%7B%0Aconst+_:+()+=+%7B%0A++++let+ptr+=+40+as+*mut+u8;%0A++++assert!(ptr.is_aligned_to(1));%0A++++assert!(ptr.is_aligned_to(2));%0A++++assert!(ptr.is_aligned_to(4));%0A++++assert!(ptr.is_aligned_to(8));%0A++++assert!(!ptr.is_aligned_to(16));%0A%7D;%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-*mut+%5BT%5D" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#1876">source</a><a href="#impl-*mut+%5BT%5D" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/71146" title="Tracking issue for const_slice_ptr_len">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1896">source</a></span><h4 class="code-header">pub fn <a href="#method.len-1" class="fn">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</span></div></span></summary><div class="docblock"><p>返回原始切片的长度。</p>
<p>返回的值是 <strong>元素</strong> 的数量，而不是字节数。</p>
<p>即使原始切片由于指针为空或未对齐而无法转换为切片引用，此函数也是安全的。</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_len)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*mut </span>[i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0Afn+main()+%7B%0Ause+std::ptr;%0A%0Alet+slice:+*mut+%5Bi8%5D+=+ptr::slice_from_raw_parts_mut(ptr::null_mut(),+3);%0Aassert_eq!(slice.len(),+3);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/71146" title="Tracking issue for const_slice_ptr_len">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1914">source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</span></div></span></summary><div class="docblock"><p>如果原始切片的长度为 0.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_len)]

</span><span class="kw">let </span><span class="kw-2">mut </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>a <span class="kw">as </span><span class="kw-2">*mut </span>[<span class="kw">_</span>];
<span class="macro">assert!</span>(!ptr.is_empty());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0A%0Afn+main()+%7B%0Alet+mut+a+=+%5B1,+2,+3%5D;%0Alet+ptr+=+%26mut+a+as+*mut+%5B_%5D;%0Aassert!(!ptr.is_empty());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#1961">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_mut" class="fn">split_at_mut</a>(self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>, <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>raw_slice_split</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95595">#95595</a>)</span></div></span></summary><div class="docblock"><p>在索引处将一个线性原始切片分成两部分。</p>
<p>第一个将包含 <code>[0, mid)</code> 的所有索引 (不包括索引 <code>mid</code> 本身)，第二个将包含 <code>[mid, len)</code> 的所有索引 (不包括索引 <code>len</code> 本身)。</p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>如果为 <code>mid &gt; len</code>，就会出现 panics。</p>
<h5 id="safety-23"><a href="#safety-23">Safety</a></h5>
<p><code>mid</code> 必须是底层 <a href="ptr/index.html#allocated-object" title="mod std::ptr">allocated object</a> 的 <a href="#method.add">in-bounds</a>。
这意味着 <code>self</code> 必须是可解引用的，并且跨越一个至少 <code>mid * size_of::&lt;T&gt;()</code> 字节长的分配。
不支持这些要求是 <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>，即使不使用结果指针。</p>
<p>由于 <code>len</code> 在边界内，它不是 <code>*mut [T]</code> 的安全不，变体，因此此方法的安全要求与 <a href="#method.split_at_mut_unchecked"><code>split_at_mut_unchecked</code></a> 相同。
显式边界检查仅在 <code>len</code> 正确时才有用。</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(raw_slice_split)]
#![feature(slice_ptr_get)]

</span><span class="kw">let </span><span class="kw-2">mut </span>v = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>v <span class="kw">as </span><span class="kw-2">*mut </span>[<span class="kw">_</span>];
<span class="kw">unsafe </span>{
    <span class="kw">let </span>(left, right) = ptr.split_at_mut(<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>left, [<span class="number">1</span>, <span class="number">0</span>]);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>right, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(raw_slice_split)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn+main()+%7B%0Alet+mut+v+=+%5B1,+0,+3,+0,+5,+6%5D;%0Alet+ptr+=+%26mut+v+as+*mut+%5B_%5D;%0Aunsafe+%7B%0A++++let+(left,+right)+=+ptr.split_at_mut(2);%0A++++assert_eq!(%26*left,+%5B1,+0%5D);%0A++++assert_eq!(%26*right,+%5B3,+0,+5,+6%5D);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_mut_unchecked" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2004">source</a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_mut_unchecked" class="fn">split_at_mut_unchecked</a>(self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>, <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[T]</a>)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>raw_slice_split</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/95595">#95595</a>)</span></div></span></summary><div class="docblock"><p>在索引处将一个原始切片分成两部分，而不进行边界检查。</p>
<p>第一个将包含 <code>[0, mid)</code> 的所有索引 (不包括索引 <code>mid</code> 本身)，第二个将包含 <code>[mid, len)</code> 的所有索引 (不包括索引 <code>len</code> 本身)。</p>
<h5 id="safety-24"><a href="#safety-24">Safety</a></h5>
<p><code>mid</code> 必须是底层 [allocated object] 的 <a href="#method.add">in-bounds</a>。
这意味着 <code>self</code> 必须是可解引用的，并且跨越一个至少 <code>mid * size_of::&lt;T&gt;()</code> 字节长的分配。
不支持这些要求是 <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>，即使不使用结果指针。</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(raw_slice_split)]

</span><span class="kw">let </span><span class="kw-2">mut </span>v = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="comment">// 限制借用的生命周期
</span><span class="kw">unsafe </span>{
    <span class="kw">let </span>ptr = <span class="kw-2">&amp;mut </span>v <span class="kw">as </span><span class="kw-2">*mut </span>[<span class="kw">_</span>];
    <span class="kw">let </span>(left, right) = ptr.split_at_mut_unchecked(<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>left, [<span class="number">1</span>, <span class="number">0</span>]);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>right, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]);
    (<span class="kw-2">&amp;mut *</span>left)[<span class="number">1</span>] = <span class="number">2</span>;
    (<span class="kw-2">&amp;mut *</span>right)[<span class="number">1</span>] = <span class="number">4</span>;
}
<span class="macro">assert_eq!</span>(v, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(raw_slice_split)%5D%0A%0Afn+main()+%7B%0Alet+mut+v+=+%5B1,+0,+3,+0,+5,+6%5D;%0A//+%E9%99%90%E5%88%B6%E5%80%9F%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%0Aunsafe+%7B%0A++++let+ptr+=+%26mut+v+as+*mut+%5B_%5D;%0A++++let+(left,+right)+=+ptr.split_at_mut_unchecked(2);%0A++++assert_eq!(%26*left,+%5B1,+0%5D);%0A++++assert_eq!(%26*right,+%5B3,+0,+5,+6%5D);%0A++++(%26mut+*left)%5B1%5D+=+2;%0A++++(%26mut+*right)%5B1%5D+=+4;%0A%7D%0Aassert_eq!(v,+%5B1,+2,+3,+4,+5,+6%5D);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/74265" title="Tracking issue for slice_ptr_get">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#2032">source</a></span><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>将裸指针返回到切片的缓冲区。</p>
<p>这等效于将 <code>self</code> 强制转换为 <code>*mut T</code>，但类型安全性更高。</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]
</span><span class="kw">use </span>std::ptr;

<span class="kw">let </span>slice: <span class="kw-2">*mut </span>[i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(slice.as_mut_ptr(), ptr::null_mut());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn+main()+%7B%0Ause+std::ptr;%0A%0Alet+slice:+*mut+%5Bi8%5D+=+ptr::slice_from_raw_parts_mut(ptr::null_mut(),+3);%0Aassert_eq!(slice.as_mut_ptr(),+ptr::null_mut());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2058-2060">source</a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fn">get_unchecked_mut</a>&lt;I&gt;(
    self,
    index: I
) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[T]</a>&gt;,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</span></div></span></summary><div class="docblock"><p>将裸指针返回到元素或子切片，而不进行边界检查。</p>
<p>使用 <a href="#method.add">out-of-bounds index</a> 或当 <code>self</code> 不可解引用时调用此方法是 <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>，即使未使用结果指针。</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_ptr_get)]

</span><span class="kw">let </span>x = <span class="kw-2">&amp;mut </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as </span><span class="kw-2">*mut </span>[i32];

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(x.get_unchecked_mut(<span class="number">1</span>), x.as_mut_ptr().add(<span class="number">1</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn+main()+%7B%0Alet+x+=+%26mut+%5B1,+2,+4%5D+as+*mut+%5Bi32%5D;%0A%0Aunsafe+%7B%0A++++assert_eq!(x.get_unchecked_mut(1),+x.as_mut_ptr().add(1));%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice-1" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#2109">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice-1" class="fn">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a [<a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回共享切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_ref-1"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_uninit_slice_mut"><code>as_uninit_slice_mut</code></a>。</p>
<h5 id="safety-25"><a href="#safety-25">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须为 <a href="ptr/index.html#safety" title="mod std::ptr">有效</a> 的，才能读取许多字节的 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code>，并且必须正确对齐。这尤其意味着：</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 内！
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="associated function std::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能发生可变 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
<p>另请参见 <a href="slice/fn.from_raw_parts.html" title="fn std::slice::from_raw_parts"><code>slice::from_raw_parts</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_uninit_slice_mut" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91822" title="Tracking issue for const_ptr_as_ref">unstable</a></span> · <a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#2161">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice_mut" class="fn">as_uninit_slice_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a mut [<a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</span></div></span></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回一个唯一的切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_mut"><code>as_mut</code></a> 相比，这不需要将该值初始化。</p>
<p>有关共享副本，请参见 <a href="#method.as_uninit_slice-1"><code>as_uninit_slice</code></a>。</p>
<h5 id="safety-26"><a href="#safety-26">Safety</a></h5>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为 true：</p>
<ul>
<li>
<p>指针必须是 <a href="ptr/index.html#safety" title="mod std::ptr">有效</a> 的才能进行 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 多个字节的读取和写入，并且必须正确对齐。这尤其意味着：</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object" title="mod std::ptr">分配对象</a> 内！
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="associated function std::ptr::NonNull::dangling"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，当这个引用存在时，指针指向的内存不能通过任何其他指针访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此！</p>
<p>另请参见 <a href="slice/fn.from_raw_parts_mut.html" title="fn std::slice::from_raw_parts_mut"><code>slice::from_raw_parts_mut</code></a>。</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/clone.rs.html#205">source</a><a href="#impl-Clone-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/clone.rs.html#207">source</a><a href="#method.clone-1" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4></section></summary><div class='docblock'>返回值的副本。 <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/clone.rs.html#129">source</a><a href="#method.clone_from-1" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>从 <code>source</code> 执行复制分配。 <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/clone.rs.html#213">source</a><a href="#impl-Clone-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../src/core/clone.rs.html#215">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4></section></summary><div class='docblock'>返回值的副本。 <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><a class="srclink rightside" href="../src/core/clone.rs.html#129">source</a><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>从 <code>source</code> 执行复制分配。 <a href="clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2433">source</a><a href="#impl-Debug-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2434">source</a><a href="#method.fmt-2" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>使用给定的格式化程序格式化该值。 <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2439">source</a><a href="#impl-Debug-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2440">source</a><a href="#method.fmt-3" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>使用给定的格式化程序格式化该值。 <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="srclink" href="../src/core/sync/atomic.rs.html#1935">source</a></span><a href="#impl-From%3C*mut+T%3E-for-AtomicPtr%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="struct" href="sync/atomic/struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../src/core/sync/atomic.rs.html#1938">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(p: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="struct" href="sync/atomic/struct.AtomicPtr.html" title="struct std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>将 <code>*mut T</code> 转换为 <code>AtomicPtr&lt;T&gt;</code>。</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/hash/mod.rs.html#958">source</a><a href="#impl-Hash-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="srclink rightside" href="../src/core/hash/mod.rs.html#960">source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>将该值输入给定的 <a href="hash/trait.Hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>。 <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="primitive.slice.html">[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>将这种类型的切片送入给定的 <a href="hash/trait.Hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a> 中。 <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/hash/mod.rs.html#968">source</a><a href="#impl-Hash-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/hash/mod.rs.html#970">source</a><a href="#method.hash-1" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,</span></h4></section></summary><div class='docblock'>将该值输入给定的 <a href="hash/trait.Hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a>。 <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice-1" class="anchor">§</a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="primitive.slice.html">[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut H</a>)<span class="where fmt-newline">where
    H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>将这种类型的切片送入给定的 <a href="hash/trait.Hasher.html" title="trait std::hash::Hasher"><code>Hasher</code></a> 中。 <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1734">source</a><a href="#impl-Ord-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1736">source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>此方法返回 <code>self</code> 和 <code>other</code> 之间的 <a href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a>。 <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#790-792">source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>比较并返回两个值中的最大值。 <a href="cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#810-812">source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>比较并返回两个值中的最小值。 <a href="cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#835-838">source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;Self&gt;,</span></h4></section></summary><div class='docblock'>将值限制在某个时间间隔内。 <a href="cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2184">source</a><a href="#impl-Ord-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2186">source</a><a href="#method.cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>此方法返回 <code>self</code> 和 <code>other</code> 之间的 <a href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering"><code>Ordering</code></a>。 <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#790-792">source</a></span><a href="#method.max-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>比较并返回两个值中的最大值。 <a href="cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#810-812">source</a></span><a href="#method.min-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h4></section></summary><div class='docblock'>比较并返回两个值中的最小值。 <a href="cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="srclink" href="../src/core/cmp.rs.html#835-838">source</a></span><a href="#method.clamp-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<span class="where fmt-newline">where
    Self: <a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;Self&gt;,</span></h4></section></summary><div class='docblock'>将值限制在某个时间间隔内。 <a href="cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C*const+T%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1722">source</a><a href="#impl-PartialEq%3C*const+T%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1724">source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试 <code>self</code> 和 <code>other</code> 值是否相等，并由 <code>==</code> 使用。</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/cmp.rs.html#226">source</a><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试 <code>!=</code>。
默认实现几乎总是足够的，并且不应在没有充分理由的情况下被覆盖。</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C*mut+T%3E-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2173">source</a><a href="#impl-PartialEq%3C*mut+T%3E-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2175">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试 <code>self</code> 和 <code>other</code> 值是否相等，并由 <code>==</code> 使用。</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><a class="srclink rightside" href="../src/core/cmp.rs.html#226">source</a><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试 <code>!=</code>。
默认实现几乎总是足够的，并且不应在没有充分理由的情况下被覆盖。</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C*const+T%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1748">source</a><a href="#impl-PartialOrd%3C*const+T%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1750">source</a><a href="#method.partial_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>如果存在，则此方法返回 <code>self</code> 和 <code>other</code> 值之间的顺序。 <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1755">source</a><a href="#method.lt-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试的内容少于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1760">source</a><a href="#method.le-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试小于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1765">source</a><a href="#method.gt-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试大于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1770">source</a><a href="#method.ge-1" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试是否大于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C*mut+T%3E-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2198">source</a><a href="#impl-PartialOrd%3C*mut+T%3E-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2200">source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>如果存在，则此方法返回 <code>self</code> 和 <code>other</code> 值之间的顺序。 <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2205">source</a><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试的内容少于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2210">source</a><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试小于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2215">source</a><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试大于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2220">source</a><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>此方法测试是否大于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2370">source</a><a href="#impl-Pointer-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2371">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>使用给定的格式化程序格式化该值。</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pointer-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2410">source</a><a href="#impl-Pointer-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../src/core/fmt/mod.rs.html#2411">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>使用给定的格式化程序格式化该值。</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdElement-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1010">source</a><a href="#impl-SimdElement-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="simd/trait.SimdElement.html" title="trait std::simd::SimdElement">SimdElement</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&lt;Metadata = <a class="primitive" href="primitive.unit.html">()</a>&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Mask" class="associatedtype trait-impl"><a href="#associatedtype.Mask" class="anchor">§</a><h4 class="code-header">type <a href="simd/trait.SimdElement.html#associatedtype.Mask" class="associatedtype">Mask</a> = <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span></div></span><div class='docblock'>此元素类型对应的掩码元素类型。</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SimdElement-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/portable-simd/crates/core_simd/src/vector.rs.html#1022">source</a><a href="#impl-SimdElement-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="simd/trait.SimdElement.html" title="trait std::simd::SimdElement">SimdElement</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&lt;Metadata = <a class="primitive" href="primitive.unit.html">()</a>&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Mask-1" class="associatedtype trait-impl"><a href="#associatedtype.Mask-1" class="anchor">§</a><h4 class="code-header">type <a href="simd/trait.SimdElement.html#associatedtype.Mask" class="associatedtype">Mask</a> = <a class="primitive" href="primitive.isize.html">isize</a></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/86656">#86656</a>)</span></div></span><div class='docblock'>此元素类型对应的掩码元素类型。</div></details></div></details><section id="impl-CoerceUnsized%3C*const+U%3E-for-%26'a+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#58">source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26'a+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-%26'a+mut+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#51">source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-%26'a+mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#69">source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-CoerceUnsized%3C*const+U%3E-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#65">source</a><a href="#impl-CoerceUnsized%3C*const+U%3E-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-CoerceUnsized%3C*mut+U%3E-for-%26'a+mut+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#48">source</a><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-%26'a+mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;'a, T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.reference.html">&amp;'a mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#62">source</a><a href="#impl-CoerceUnsized%3C*mut+U%3E-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Copy-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#467-477">source</a><a href="#impl-Copy-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Copy-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#467-477">source</a><a href="#impl-Copy-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-DispatchFromDyn%3C*const+U%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#129">source</a><a href="#impl-DispatchFromDyn%3C*const+U%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ops/unsize.rs.html#132">source</a><a href="#impl-DispatchFromDyn%3C*mut+U%3E-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,
    U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Eq-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/const_ptr.rs.html#1730">source</a><a href="#impl-Eq-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Eq-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/ptr/mut_ptr.rs.html#2181">source</a><a href="#impl-Eq-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Send-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#87">source</a><a href="#impl-Send-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Send-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#89">source</a><a href="#impl-Send-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-SimdCastPtr%3CT%3E-for-*const+U" class="impl"><a class="srclink rightside" href="../src/core/portable-simd/crates/core_simd/src/cast.rs.html#43">source</a><a href="#impl-SimdCastPtr%3CT%3E-for-*const+U" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="simd/trait.SimdCastPtr.html" title="trait std::simd::SimdCastPtr">SimdCastPtr</a>&lt;T&gt; for <a class="primitive" href="primitive.pointer.html">*const U</a><span class="where fmt-newline">where
    U: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>,
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&lt;Metadata = &lt;U as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a>&gt;,</span></h3></section><section id="impl-SimdCastPtr%3CT%3E-for-*mut+U" class="impl"><a class="srclink rightside" href="../src/core/portable-simd/crates/core_simd/src/cast.rs.html#50">source</a><a href="#impl-SimdCastPtr%3CT%3E-for-*mut+U" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="simd/trait.SimdCastPtr.html" title="trait std::simd::SimdCastPtr">SimdCastPtr</a>&lt;T&gt; for <a class="primitive" href="primitive.pointer.html">*mut U</a><span class="where fmt-newline">where
    U: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>,
    T: <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&lt;Metadata = &lt;U as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="associatedtype" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a>&gt;,</span></h3></section><section id="impl-Sync-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#634">source</a><a href="#impl-Sync-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Sync-for-*mut+T" class="impl"><a class="srclink rightside" href="../src/core/marker.rs.html#636">source</a><a href="#impl-Sync-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Unpin-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> · <a class="srclink" href="../src/core/marker.rs.html#933-938">source</a></span><a href="#impl-Unpin-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-Unpin-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span> · <a class="srclink" href="../src/core/marker.rs.html#933-938">source</a></span><a href="#impl-Unpin-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-UnwindSafe-for-*const+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · <a class="srclink" href="../src/core/panic/unwind_safe.rs.html#185">source</a></span><a href="#impl-UnwindSafe-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section><section id="impl-UnwindSafe-for-*mut+T" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · <a class="srclink" href="../src/core/panic/unwind_safe.rs.html#187">source</a></span><a href="#impl-UnwindSafe-for-*mut+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a><span class="where fmt-newline">where
    T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-*const+T" class="impl"><a href="#impl-RefUnwindSafe-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a><span class="where fmt-newline">where
    T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/any.rs.html#200">source</a><a href="#impl-Any-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="../src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="../src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>从拥有的值中一成不变地借用。 <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="../src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>从拥有的值中借用。 <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#723">source</a><a href="#impl-From%3CT%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#726">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>返回未更改的参数。</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#707">source</a><a href="#impl-Into%3CU%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#716">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>调用 <code>U::from(self)</code>。</p>
<p>也就是说，这种转换是 <code><a href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> 实现选择执行的任何操作。</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-*const+T" class="impl"><a class="srclink rightside" href="../src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>获得所有权后的结果类型。</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="srclink rightside" href="../src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>从借用的数据创建拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="srclink rightside" href="../src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>使用借来的数据来替换拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#763">source</a><a href="#impl-TryFrom%3CU%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>发生转换错误时返回的类型。</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#770">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>执行转换。</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-*const+T" class="impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#748">source</a><a href="#impl-TryInto%3CU%3E-for-*const+T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>发生转换错误时返回的类型。</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="../src/core/convert/mod.rs.html#755">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>执行转换。</div></details></div></details></div></section></div></main></body></html>