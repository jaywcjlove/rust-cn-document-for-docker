<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="用于格式化和打印 `String`s 的实用工具。"><title>std::fmt - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../std/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../std/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module fmt</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">std</a>::<wbr><a class="mod" href="#">fmt</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../src/alloc/lib.rs.html#244">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>用于格式化和打印 <code>String</code>s 的实用工具。</p>
<p>该模块包含对 <a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 语法扩展的运行时支持。
该宏在编译器中实现，以发出对该模块的调用，以便在运行时将参数格式化为字符串。</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p><a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 宏旨在使那些使用 C 的 <code>printf</code>/<code>fprintf</code> 函数或 Python 的 <code>str.format</code> 函数的用户熟悉。</p>
<p><a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 扩展的一些示例是：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">format!</span>(<span class="string">&quot;Hello&quot;</span>);                 <span class="comment">// =&gt; &quot;Hello&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;Hello, {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);   <span class="comment">// =&gt; &quot;Hello, world!&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;The number is {}&quot;</span>, <span class="number">1</span>);   <span class="comment">// =&gt; &quot;The number is 1&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, (<span class="number">3</span>, <span class="number">4</span>));          <span class="comment">// =&gt; &quot;(3, 4)&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{value}&quot;</span>, value=<span class="number">4</span>);      <span class="comment">// =&gt; &quot;4&quot;
</span><span class="kw">let </span>people = <span class="string">&quot;Rustaceans&quot;</span>;
<span class="macro">format!</span>(<span class="string">&quot;Hello {people}!&quot;</span>);       <span class="comment">// =&gt; &quot;Hello Rustaceans!&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);           <span class="comment">// =&gt; &quot;1 2&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{:04}&quot;</span>, <span class="number">42</span>);             <span class="comment">// =&gt; 带前导零的 &quot;0042&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{:#?}&quot;</span>, (<span class="number">100</span>, <span class="number">200</span>));     <span class="comment">// =&gt; &quot;(
                                  // 100,
                                  //       200, )&quot;
                                  //</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aformat!(%22Hello%22);+++++++++++++++++//+=%3E+%22Hello%22%0Aformat!(%22Hello,+%7B%7D!%22,+%22world%22);+++//+=%3E+%22Hello,+world!%22%0Aformat!(%22The+number+is+%7B%7D%22,+1);+++//+=%3E+%22The+number+is+1%22%0Aformat!(%22%7B:?%7D%22,+(3,+4));++++++++++//+=%3E+%22(3,+4)%22%0Aformat!(%22%7Bvalue%7D%22,+value=4);++++++//+=%3E+%224%22%0Alet+people+=+%22Rustaceans%22;%0Aformat!(%22Hello+%7Bpeople%7D!%22);+++++++//+=%3E+%22Hello+Rustaceans!%22%0Aformat!(%22%7B%7D+%7B%7D%22,+1,+2);+++++++++++//+=%3E+%221+2%22%0Aformat!(%22%7B:04%7D%22,+42);+++++++++++++//+=%3E+%E5%B8%A6%E5%89%8D%E5%AF%BC%E9%9B%B6%E7%9A%84+%220042%22%0Aformat!(%22%7B:%23?%7D%22,+(100,+200));+++++//+=%3E+%22(%0A++++++++++++++++++++++++++++++++++//+100,%0A++++++++++++++++++++++++++++++++++//+++++++200,+)%22%0A++++++++++++++++++++++++++++++++++//%0A%7D&amp;edition=2021">Run</a></div>
<p>从这些中，您可以看到第一个参数是格式字符串。编译器要求它是字符串字面量； 它不能是传入的变量 (以执行有效性检查)。
然后，编译器将解析格式字符串，并确定所提供的参数列表是否适合传递给该格式字符串。</p>
<p>要将单个值转换为字符串，请使用 <a href="../string/trait.ToString.html#tymethod.to_string" title="ToString::to_string"><code>to_string</code></a> 方法。这将使用 <a href="trait.Display.html" title="trait std::fmt::Display"><code>Display</code></a> 格式 trait。</p>
<h3 id="位置参数"><a href="#位置参数">位置参数</a></h3>
<p>每个格式化参数都可以指定它引用的值参数，如果省略，则假定它是 “下一个参数”。
例如，格式字符串 <code>{} {} {}</code> 将带有三个参数，并且将按照给定的顺序对其进行格式化。
但是，格式字符串 <code>{2} {1} {0}</code> 将以相反的顺序格式化参数。</p>
<p>一旦开始将两种类型的位置说明符混合在一起，事情就会变得有些棘手。可以将 “下一个参数” 说明符可以看作是参数的迭代器。
每次看到 “下一个参数” 说明符时，迭代器都会前进。这会导致这样的行为：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">format!</span>(<span class="string">&quot;{1} {} {0} {}&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; &quot;2 1 1 2&quot;</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aformat!(%22%7B1%7D+%7B%7D+%7B0%7D+%7B%7D%22,+1,+2);+//+=%3E+%222+1+1+2%22%0A%7D&amp;edition=2021">Run</a></div>
<p>看到第一个 <code>{}</code> 时，尚未对参数进行内部迭代，因此它将打印第一个参数。然后，在到达第二个 <code>{}</code> 时，迭代器已前进到第二个参数。
本质上，在位置说明符方面，明确命名其参数的参数不会影响未命名参数的参数。</p>
<p>必须使用格式字符串才能使用其所有参数，否则将导致编译时错误。您可能在格式字符串中多次引用同一参数。</p>
<h3 id="命名参数"><a href="#命名参数">命名参数</a></h3>
<p>Rust 本身不具有类似于 Python 的等效于函数的命名参数，但是 <a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 宏是一种语法扩展，允许它利用命名参数。
命名参数列在参数列表的末尾，并具有以下语法：</p>
<div class="example-wrap"><pre class="language-text"><code>identifier &#39;=&#39; expression
</code></pre></div>
<p>例如，以下 <a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 表达式都使用命名参数:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">format!</span>(<span class="string">&quot;{argument}&quot;</span>, argument = <span class="string">&quot;test&quot;</span>);   <span class="comment">// =&gt; &quot;test&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{name} {}&quot;</span>, <span class="number">1</span>, name = <span class="number">2</span>);          <span class="comment">// =&gt; &quot;2 1&quot;
</span><span class="macro">format!</span>(<span class="string">&quot;{a} {c} {b}&quot;</span>, a=<span class="string">&quot;a&quot;</span>, b=<span class="string">&#39;b&#39;</span>, c=<span class="number">3</span>);  <span class="comment">// =&gt; &quot;a 3 b&quot;</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aformat!(%22%7Bargument%7D%22,+argument+=+%22test%22);+++//+=%3E+%22test%22%0Aformat!(%22%7Bname%7D+%7B%7D%22,+1,+name+=+2);++++++++++//+=%3E+%222+1%22%0Aformat!(%22%7Ba%7D+%7Bc%7D+%7Bb%7D%22,+a=%22a%22,+b='b',+c=3);++//+=%3E+%22a+3+b%22%0A%7D&amp;edition=2021">Run</a></div>
<p>如果命名参数没有出现在参数列表中，<code>format!</code> 将引用当前作用域中的同名变量。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>argument = <span class="number">2 </span>+ <span class="number">2</span>;
<span class="macro">format!</span>(<span class="string">&quot;{argument}&quot;</span>);   <span class="comment">// =&gt; &quot;4&quot;

</span><span class="kw">fn </span>make_string(a: u32, b: <span class="kw-2">&amp;</span>str) -&gt; String {
    <span class="macro">format!</span>(<span class="string">&quot;{b} {a}&quot;</span>)
}
make_string(<span class="number">927</span>, <span class="string">&quot;label&quot;</span>); <span class="comment">// =&gt; &quot;label 927&quot;</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+argument+=+2+%2B+2;%0Aformat!(%22%7Bargument%7D%22);+++//+=%3E+%224%22%0A%0Afn+make_string(a:+u32,+b:+%26str)+-%3E+String+%7B%0A++++format!(%22%7Bb%7D+%7Ba%7D%22)%0A%7D%0Amake_string(927,+%22label%22);+//+=%3E+%22label+927%22%0A%7D&amp;edition=2021">Run</a></div>
<p>在具有名称的参数之后放置位置参数 (那些没有名称的参数) 是无效的。与位置参数一样，提供格式字符串未使用的命名参数也是无效的。</p>
<h2 id="格式化参数"><a href="#格式化参数">格式化参数</a></h2>
<p>每个要格式化的参数都可以通过许多格式化参数进行转换 (对应于 <a href="#syntax">语法</a>) 中的 <code>format_spec</code>。这些参数会影响所格式化内容的字符串表示形式。</p>
<h3 id="width"><a href="#width">Width</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 所有这些打印 &quot;Hello x !&quot;
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {:5}!&quot;</span>, <span class="string">&quot;x&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {:1$}!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {1:0$}!&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {:width$}!&quot;</span>, <span class="string">&quot;x&quot;</span>, width = <span class="number">5</span>);
<span class="kw">let </span>width = <span class="number">5</span>;
<span class="macro">println!</span>(<span class="string">&quot;Hello {:width$}!&quot;</span>, <span class="string">&quot;x&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+%E6%89%80%E6%9C%89%E8%BF%99%E4%BA%9B%E6%89%93%E5%8D%B0+%22Hello+x+!%22%0Afn+main()+%7B%0Aprintln!(%22Hello+%7B:5%7D!%22,+%22x%22);%0Aprintln!(%22Hello+%7B:1%24%7D!%22,+%22x%22,+5);%0Aprintln!(%22Hello+%7B1:0%24%7D!%22,+5,+%22x%22);%0Aprintln!(%22Hello+%7B:width%24%7D!%22,+%22x%22,+width+=+5);%0Alet+width+=+5;%0Aprintln!(%22Hello+%7B:width%24%7D!%22,+%22x%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>这是格式应使用的 “最小宽度” 的参数。
如果值的字符串不能填满这么多字符，则 fill/alignment 指定的填充将用于占用所需的空间 (请参见下文)。</p>
<p>通过添加后缀 <code>$</code> (表示第二个参数是指定宽度的 <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a>)，也可以在参数列表中以 <a href="../primitive.usize.html" title="primitive usize"><code>usize</code></a> 的形式提供宽度值。</p>
<p>使用 Dollar 语法引用参数不会影响 “下一个参数” 计数器，因此按位置引用参数或使用命名参数通常是一个好主意。</p>
<h3 id="fillalignment"><a href="#fillalignment">Fill/Alignment</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:&lt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello x    !&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:-&lt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x----!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:^5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello   x  !&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:&gt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello     x!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert_eq!(format!(%22Hello+%7B:%3C5%7D!%22,+%22x%22),++%22Hello+x++++!%22);%0Aassert_eq!(format!(%22Hello+%7B:-%3C5%7D!%22,+%22x%22),+%22Hello+x----!%22);%0Aassert_eq!(format!(%22Hello+%7B:%5E5%7D!%22,+%22x%22),++%22Hello+++x++!%22);%0Aassert_eq!(format!(%22Hello+%7B:%3E5%7D!%22,+%22x%22),++%22Hello+++++x!%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>可选的填充字符和对齐方式通常与 <a href="#width"><code>width</code></a> 参数一起提供。必须在 <code>width</code> 之前，<code>:</code> 之后定义。
这表示如果要格式化的值小于 <code>width</code>，则将在其周围打印一些额外的字符。
对于不同的对齐方式，填充有以下变体：</p>
<ul>
<li><code>[fill]&lt;</code> - 参数在 <code>width</code> 列中左对齐</li>
<li><code>[fill]^</code> - 参数在 <code>width</code> 列中居中对齐</li>
<li><code>[fill]&gt;</code> - 参数在 <code>width</code> 列中右对齐</li>
</ul>
<p>非数字的默认 <a href="#fillalignment">fill/alignment</a> 是空格，并且左对齐。数字格式器的默认值也是空格字符，但带有右对齐。
如果为数字指定了 <code>0</code> 标志 (见下文)，则隐式填充字符为 <code>0</code>。</p>
<p>请注意，某些类型可能不会实现对齐。特别是，对于 <code>Debug</code> trait，通常不会实现该功能。
确保应用填充的一种好方法是格式化输入，然后填充此结果字符串以获得输出：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;Hello {:^15}!&quot;</span>, <span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;hi&quot;</span>))); <span class="comment">// =&gt; &quot;Hello   Some(&quot;hi&quot;)   !&quot;</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aprintln!(%22Hello+%7B:%5E15%7D!%22,+format!(%22%7B:?%7D%22,+Some(%22hi%22)));+//+=%3E+%22Hello+++Some(%22hi%22)+++!%22%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="sign0"><a href="#sign0">Sign/<code>#</code>/<code>0</code></a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:+}!&quot;</span>, <span class="number">5</span>), <span class="string">&quot;Hello +5!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:#x}!&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1b!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:05}!&quot;</span>, <span class="number">5</span>),  <span class="string">&quot;Hello 00005!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:05}!&quot;</span>, -<span class="number">5</span>), <span class="string">&quot;Hello -0005!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:#010x}!&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x0000001b!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert_eq!(format!(%22Hello+%7B:%2B%7D!%22,+5),+%22Hello+%2B5!%22);%0Aassert_eq!(format!(%22%7B:%23x%7D!%22,+27),+%220x1b!%22);%0Aassert_eq!(format!(%22Hello+%7B:05%7D!%22,+5),++%22Hello+00005!%22);%0Aassert_eq!(format!(%22Hello+%7B:05%7D!%22,+-5),+%22Hello+-0005!%22);%0Aassert_eq!(format!(%22%7B:%23010x%7D!%22,+27),+%220x0000001b!%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>这些都是更改格式化程序行为的标志。</p>
<ul>
<li><code>+</code> - 这适用于数字类型并指示应始终打印符号。默认情况下从不打印正号，默认情况下仅对有符号值打印负号。
该标志指示应始终打印正确的符号 (<code>+</code> 或 <code>-</code>)。</li>
<li><code>-</code> - 当前未使用</li>
<li><code>#</code> - 此标志表示应使用 “alternate” 打印形式。替代形式为：
<ul>
<li><code>#?</code> - 漂亮地打印 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>Debug</code></a> 格式 (添加换行符和缩进)</li>
<li><code>#x</code> - 在参数前面加上 <code>0x</code></li>
<li><code>#X</code> - 在参数前面加上 <code>0x</code></li>
<li><code>#b</code> - 在参数前面加上 <code>0b</code></li>
<li><code>#o</code> - 在参数前面加上 <code>0o</code></li>
</ul>
</li>
<li><code>0</code> - 这用于指示对于整数格式，向 <code>width</code> 的填充应该使用 <code>0</code> 字符，并且是符号感知的。
像 <code>{:08}</code> 这样的格式将为整数 <code>1</code> 产生 <code>00000001</code>，而相同格式将为整数 <code>-1</code> 产生 <code>-0000001</code>。
请注意，负版本的零比正版本的少零。
请注意，填充零总是放在符号 (如果有) 之后和数字之前。当与 <code>#</code> 标志一起使用时，将应用类似的规则：在前缀之后但在数字之前插入填充零。
前缀包括在总宽度中。</li>
</ul>
<h3 id="precision"><a href="#precision">Precision</a></h3>
<p>对于非数字类型，可以将其视为 “最大宽度”。
如果结果字符串的长度大于此宽度，则将其截断为这么多个字符，并且如果设置了这些参数，则会使用适当的 <code>fill</code>，<code>alignment</code> 和 <code>width</code> 发出该截断的值。</p>
<p>对于整数类型，这将被忽略。</p>
<p>对于浮点类型，这指示小数点后应打印多少位。</p>
<p>有三种可能的方法来指定所需的 <code>precision</code>：</p>
<ol>
<li>
<p>一个整数 <code>.N</code>：</p>
<p>整数 <code>N</code> 本身就是精度。</p>
</li>
<li>
<p>整数或名称后跟美元符号 <code>.N$</code>：</p>
<p>使用格式参数 <code>N</code> (必须是 <code>usize</code>) 作为精度。</p>
</li>
<li>
<p>星号 <code>.*</code>：</p>
<p><code>.*</code> 意味着这个 <code>{...}</code> 与<em>两个</em>格式输入相关联，而不是一个:</p>
<ul>
<li>如果使用 <code>{:&lt;spec&gt;.*}</code> 格式的字符串，则第一个输入保存 <code>usize</code> 精度，第二个输入保存要打印的值。</li>
<li>如果使用 <code>{&lt;arg&gt;:&lt;spec&gt;.*}</code> 格式的字符串，则 <code>&lt;arg&gt;</code> 部分指的是要打印的值，并且 <code>precision</code> 被视为使用省略的位置参数指定 (<code>{}</code> 而不是 <code>{&lt;arg&gt;:}</code>)。</li>
</ul>
</li>
</ol>
<p>例如，以下所有调用均打印相同的内容 <code>Hello x is 0.01000</code>：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hello {arg 0 (&quot;x&quot;)} is {arg 1 (0.01) with precision specified inline (5)}
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {0} is {1:.5}&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {arg 1 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 0 (5)}
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {1} is {2:.0$}&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {arg 0 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 1 (5)}
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {0} is {2:.1$}&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg -&gt; arg 0 (&quot;x&quot;)} is {second of next two args -&gt; arg 2 (0.01) with precision specified in first of next two args -&gt; arg 1 (5)}
//
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {} is {:.*}&quot;</span>,    <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {arg 1 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in next arg -&gt; arg 0 (5)}
//
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {1} is {2:.*}&quot;</span>,  <span class="number">5</span>, <span class="string">&quot;x&quot;</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg -&gt; arg 0 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in next arg -&gt; arg 1 (5)}
//
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {} is {2:.*}&quot;</span>,   <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg -&gt; arg 0 (&quot;x&quot;)} is {arg &quot;number&quot; (0.01) with precision specified in arg &quot;prec&quot; (5)}
//
</span><span class="macro">println!</span>(<span class="string">&quot;Hello {} is {number:.prec$}&quot;</span>, <span class="string">&quot;x&quot;</span>, prec = <span class="number">5</span>, number = <span class="number">0.01</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+1+(0.01)+with+precision+specified+inline+(5)%7D%0Afn+main()+%7B%0Aprintln!(%22Hello+%7B0%7D+is+%7B1:.5%7D%22,+%22x%22,+0.01);%0A%0A//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+0+(5)%7D%0Aprintln!(%22Hello+%7B1%7D+is+%7B2:.0%24%7D%22,+5,+%22x%22,+0.01);%0A%0A//+Hello+%7Barg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+arg+1+(5)%7D%0Aprintln!(%22Hello+%7B0%7D+is+%7B2:.1%24%7D%22,+%22x%22,+5,+0.01);%0A%0A//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Bsecond+of+next+two+args+-%3E+arg+2+(0.01)+with+precision+specified+in+first+of+next+two+args+-%3E+arg+1+(5)%7D%0A//%0Aprintln!(%22Hello+%7B%7D+is+%7B:.*%7D%22,++++%22x%22,+5,+0.01);%0A%0A//+Hello+%7Barg+1+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+next+arg+-%3E+arg+0+(5)%7D%0A//%0Aprintln!(%22Hello+%7B1%7D+is+%7B2:.*%7D%22,++5,+%22x%22,+0.01);%0A%0A//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+2+(0.01)+with+precision+specified+in+next+arg+-%3E+arg+1+(5)%7D%0A//%0Aprintln!(%22Hello+%7B%7D+is+%7B2:.*%7D%22,+++%22x%22,+5,+0.01);%0A%0A//+Hello+%7Bnext+arg+-%3E+arg+0+(%22x%22)%7D+is+%7Barg+%22number%22+(0.01)+with+precision+specified+in+arg+%22prec%22+(5)%7D%0A//%0Aprintln!(%22Hello+%7B%7D+is+%7Bnumber:.prec%24%7D%22,+%22x%22,+prec+=+5,+number+=+0.01);%0A%7D&amp;edition=2021">Run</a></div>
<p>而这些：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}, `{name:.*}` has 3 fractional digits&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, name=<span class="number">1234.56</span>);
<span class="macro">println!</span>(<span class="string">&quot;{}, `{name:.*}` has 3 characters&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, name=<span class="string">&quot;1234.56&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;{}, `{name:&gt;8.*}` has 3 right-aligned characters&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, name=<span class="string">&quot;1234.56&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aprintln!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+fractional+digits%22,+%22Hello%22,+3,+name=1234.56);%0Aprintln!(%22%7B%7D,+%60%7Bname:.*%7D%60+has+3+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0Aprintln!(%22%7B%7D,+%60%7Bname:%3E8.*%7D%60+has+3+right-aligned+characters%22,+%22Hello%22,+3,+name=%221234.56%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>打印三个明显不同的内容：</p>
<div class="example-wrap"><pre class="language-text"><code>Hello, `1234.560` has 3 fractional digits
Hello, `123` has 3 characters
Hello, `     123` has 3 right-aligned characters
</code></pre></div><h3 id="localization"><a href="#localization">Localization</a></h3>
<p>在某些编程语言中，字符串格式函数的行为取决于操作系统的语言环境设置。
Rust 标准库提供的格式函数没有任何语言环境的概念，并且无论用户配置如何，在所有系统上都会产生相同的结果。</p>
<p>例如，即使系统区域设置使用小数点分隔符 (而不是点)，以下代码也将始终打印 <code>1.5</code>。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;The value is {}&quot;</span>, <span class="number">1.5</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aprintln!(%22The+value+is+%7B%7D%22,+1.5);%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="escaping"><a href="#escaping">Escaping</a></h2>
<p>字面量字符 <code>{</code> 和 <code>}</code> 可以通过在它们之前添加相同的字符而包含在字符串中。例如，<code>{</code> 字符使用 <code>{{</code> 进行转义，而 <code>}</code> 字符使用 <code>}}</code> 进行转义。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {{}}&quot;</span>), <span class="string">&quot;Hello {}&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{{ Hello&quot;</span>), <span class="string">&quot;{ Hello&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert_eq!(format!(%22Hello+%7B%7B%7D%7D%22),+%22Hello+%7B%7D%22);%0Aassert_eq!(format!(%22%7B%7B+Hello%22),+%22%7B+Hello%22);%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="syntax"><a href="#syntax">Syntax</a></h2>
<p>总结一下，您可以在这里找到格式字符串的完整语法。
所用格式语言的语法是从其他语言中提取的，因此不应太陌生。参数使用类似 Python 的语法格式化，这意味着参数被 <code>{}</code> 包围，而不是类似 C 的 <code>%</code>。
格式化语法的实际语法为：</p>
<div class="example-wrap"><pre class="language-text"><code>format_string := text [ maybe_format text ] *
maybe_format := &#39;{&#39; &#39;{&#39; | &#39;}&#39; &#39;}&#39; | format
format := &#39;{&#39; [ argument ] [ &#39;:&#39; format_spec ] [ ws ] * &#39;}&#39;
argument := integer | identifier

format_spec := [[fill]align][sign][&#39;#&#39;][&#39;0&#39;][width][&#39;.&#39; precision]type
fill := character
align := &#39;&lt;&#39; | &#39;^&#39; | &#39;&gt;&#39;
sign := &#39;+&#39; | &#39;-&#39;
width := count
precision := count | &#39;*&#39;
type := &#39;&#39; | &#39;?&#39; | &#39;x?&#39; | &#39;X?&#39; | identifier
count := parameter | integer
parameter := argument &#39;$&#39;
</code></pre></div>
<p>在上面的语法中，</p>
<ul>
<li><code>text</code> 不得包含任何 <code>'{'</code> 或 <code>'}'</code> 字符，</li>
<li><code>ws</code> 是 <a href="../primitive.char.html#method.is_whitespace" title="method char::is_whitespace"><code>char::is_whitespace</code></a> 为其返回 <code>true</code> 的任何字符，没有语义意义并且是完全可选的，</li>
<li><code>integer</code> 是一个十进制整数，可能包含前导零，并且必须适合 <code>usize</code> 和</li>
<li><code>identifier</code> 是由 [Rust 语言参考]<a href="https://doc.rust-lang.org/reference/identifiers.html">Rust language reference</a> 定义的 <code>IDENTIFIER_OR_KEYWORD</code> (不是 <code>IDENTIFIER</code>)。</li>
</ul>
<h2 id="格式化-traits"><a href="#格式化-traits">格式化 traits</a></h2>
<p>当请求使用特定类型的参数格式化时，实际上是在请求将参数归因于特定的 trait。
这允许通过 <code>{:x}</code> 格式化多种实际类型 (例如 <a href="../primitive.i8.html" title="primitive i8"><code>i8</code></a> 和 <a href="../primitive.isize.html" title="primitive isize"><code>isize</code></a>)。类型到 traits 的当前映射是：</p>
<ul>
<li><em>nothing</em> ⇒ <a href="trait.Display.html" title="trait std::fmt::Display"><code>Display</code></a></li>
<li><code>?</code> ⇒ <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>Debug</code></a></li>
<li><code>x?</code> ⇒ <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>Debug</code></a> 带有小写十六进制整数</li>
<li><code>X?</code> ⇒ <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>Debug</code></a> 带有大写十六进制整数</li>
<li><code>o</code> ⇒ <a href="trait.Octal.html" title="trait std::fmt::Octal"><code>Octal</code></a></li>
<li><code>x</code> ⇒ <a href="trait.LowerHex.html" title="trait std::fmt::LowerHex"><code>LowerHex</code></a></li>
<li><code>X</code> ⇒ <a href="trait.UpperHex.html" title="trait std::fmt::UpperHex"><code>UpperHex</code></a></li>
<li><code>p</code> ⇒ <a href="trait.Pointer.html" title="trait std::fmt::Pointer"><code>Pointer</code></a></li>
<li><code>b</code> ⇒ <a href="trait.Binary.html" title="trait std::fmt::Binary"><code>Binary</code></a></li>
<li><code>e</code> ⇒ <a href="trait.LowerExp.html" title="trait std::fmt::LowerExp"><code>LowerExp</code></a></li>
<li><code>E</code> ⇒ <a href="trait.UpperExp.html" title="trait std::fmt::UpperExp"><code>UpperExp</code></a></li>
</ul>
<p>这意味着可以使用 <code>{:b}</code> 格式化实现 <a href="trait.Binary.html" title="trait std::fmt::Binary"><code>fmt::Binary</code></a> trait 的任何类型的参数。标准库还为许多原始类型提供了针对这些 traits 的实现。</p>
<p>如果未指定格式 (如 <code>{}</code> 或 <code>{:6}</code>)，则使用的格式 trait 为 <a href="trait.Display.html" title="trait std::fmt::Display"><code>Display</code></a> trait。</p>
<p>当为您自己的类型实现格式 trait 时，您将必须实现签名的方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; fmt::Result {</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0Ause+std::fmt;%0Astruct+Foo;+//+%E6%88%91%E4%BB%AC%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%0Aimpl+fmt::Display+for+Foo+%7B%0Afn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0Awrite!(f,+%22testing,+testing%22)%0A%7D+%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>您的类型将作为 <code>self</code> 通过引用传递，然后函数应该将输出发送到实现 <code>fmt::Write</code> 的格式化程序 <code>f</code>。
正确遵守所请求的格式设置参数，取决于每种格式 trait 的实现。
这些参数的值可以通过 <a href="struct.Formatter.html" title="struct std::fmt::Formatter"><code>Formatter</code></a> 结构体的方法访问。为了解决这个问题，<a href="struct.Formatter.html" title="struct std::fmt::Formatter"><code>Formatter</code></a> 结构体还提供了一些辅助方法。</p>
<p>此外，该函数的返回值是 <a href="type.Result.html" title="fmt::Result"><code>fmt::Result</code></a>，它是 <code><a href="../result/enum.Result.html" title="std::result::Result">Result</a>&lt;(), <a href="struct.Error.html" title="fmt::Error">std::fmt::Error</a>&gt;</code> 的类型别名。
格式化实现应确保它们传播来自 <a href="struct.Formatter.html" title="struct std::fmt::Formatter"><code>Formatter</code></a> 的错误 (例如，调用 <a href="../macro.write.html" title="macro std::write"><code>write!</code></a> 时)。
但是，它们绝不能虚假地返回错误。
即，格式化实现必须并且仅在传入的 <a href="struct.Formatter.html" title="struct std::fmt::Formatter"><code>Formatter</code></a> 返回错误的情况下才返回错误。
这是因为，与函数签名可能暗示的相反，字符串格式是一项可靠的操作。
该函数仅返回结果，因为写入底层流可能会失败，并且它必须提供一种方法来将已发生错误的事实传播回栈。</p>
<p>实现格式 traits 的示例如下所示：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt;

<span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>Vector2D {
    x: isize,
    y: isize,
}

<span class="kw">impl </span>fmt::Display <span class="kw">for </span>Vector2D {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; fmt::Result {
        <span class="comment">// `f` 值实现 `Write` trait，这就是 `write`！ 宏正在等待。
        // 请注意，这种格式化将忽略为格式化字符串而提供的各种标志。
        //
        </span><span class="macro">write!</span>(f, <span class="string">&quot;({}, {})&quot;</span>, <span class="self">self</span>.x, <span class="self">self</span>.y)
    }
}

<span class="comment">// 不同的 traits 允许类型的不同形式的输出。
// 此格式的含义是打印 vector 的大小。
</span><span class="kw">impl </span>fmt::Binary <span class="kw">for </span>Vector2D {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; fmt::Result {
        <span class="kw">let </span>magnitude = (<span class="self">self</span>.x * <span class="self">self</span>.x + <span class="self">self</span>.y * <span class="self">self</span>.y) <span class="kw">as </span>f64;
        <span class="kw">let </span>magnitude = magnitude.sqrt();

        <span class="comment">// 通过使用 Formatter 对象上的帮助器方法 `pad_integral`，尊重格式设置标志。
        // 有关详细信息，请参见方法文档，并且函数 `pad` 可用于填充字符串。
        //
        //
        </span><span class="kw">let </span>decimals = f.precision().unwrap_or(<span class="number">3</span>);
        <span class="kw">let </span>string = <span class="macro">format!</span>(<span class="string">&quot;{magnitude:.decimals$}&quot;</span>);
        f.pad_integral(<span class="bool-val">true</span>, <span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span>string)
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>myvector = Vector2D { x: <span class="number">3</span>, y: <span class="number">4 </span>};

    <span class="macro">println!</span>(<span class="string">&quot;{myvector}&quot;</span>);       <span class="comment">// =&gt; &quot;(3, 4)&quot;
    </span><span class="macro">println!</span>(<span class="string">&quot;{myvector:?}&quot;</span>);     <span class="comment">// =&gt; &quot;Vector2D {x: 3, y:4}&quot;
    </span><span class="macro">println!</span>(<span class="string">&quot;{myvector:10.3b}&quot;</span>); <span class="comment">// =&gt; &quot;     5.000&quot;
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause+std::fmt;%0A%0A%23%5Bderive(Debug)%5D%0Astruct+Vector2D+%7B%0A++++x:+isize,%0A++++y:+isize,%0A%7D%0A%0Aimpl+fmt::Display+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0A++++++++//+%60f%60+%E5%80%BC%E5%AE%9E%E7%8E%B0+%60Write%60+trait%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF+%60write%60%EF%BC%81+%E5%AE%8F%E6%AD%A3%E5%9C%A8%E7%AD%89%E5%BE%85%E3%80%82%0A++++++++//+%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B0%86%E5%BF%BD%E7%95%A5%E4%B8%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%80%8C%E6%8F%90%E4%BE%9B%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97%E3%80%82%0A++++++++//%0A++++++++write!(f,+%22(%7B%7D,+%7B%7D)%22,+self.x,+self.y)%0A++++%7D%0A%7D%0A%0A//+%E4%B8%8D%E5%90%8C%E7%9A%84+traits+%E5%85%81%E8%AE%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82%0A//+%E6%AD%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E6%89%93%E5%8D%B0+vector+%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Aimpl+fmt::Binary+for+Vector2D+%7B%0A++++fn+fmt(%26self,+f:+%26mut+fmt::Formatter%3C'_%3E)+-%3E+fmt::Result+%7B%0A++++++++let+magnitude+=+(self.x+*+self.x+%2B+self.y+*+self.y)+as+f64;%0A++++++++let+magnitude+=+magnitude.sqrt();%0A%0A++++++++//+%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8+Formatter+%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%99%A8%E6%96%B9%E6%B3%95+%60pad_integral%60%EF%BC%8C%E5%B0%8A%E9%87%8D%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E3%80%82%0A++++++++//+%E6%9C%89%E5%85%B3%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%AF%B7%E5%8F%82%E8%A7%81%E6%96%B9%E6%B3%95%E6%96%87%E6%A1%A3%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%87%BD%E6%95%B0+%60pad%60+%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82%0A++++++++//%0A++++++++//%0A++++++++let+decimals+=+f.precision().unwrap_or(3);%0A++++++++let+string+=+format!(%22%7Bmagnitude:.decimals%24%7D%22);%0A++++++++f.pad_integral(true,+%22%22,+%26string)%0A++++%7D%0A%7D%0A%0Afn+main()+%7B%0A++++let+myvector+=+Vector2D+%7B+x:+3,+y:+4+%7D;%0A%0A++++println!(%22%7Bmyvector%7D%22);+++++++//+=%3E+%22(3,+4)%22%0A++++println!(%22%7Bmyvector:?%7D%22);+++++//+=%3E+%22Vector2D+%7Bx:+3,+y:4%7D%22%0A++++println!(%22%7Bmyvector:10.3b%7D%22);+//+=%3E+%22+++++5.000%22%0A%7D&amp;edition=2021">Run</a></div>
<h4 id="fmtdisplay-与-fmtdebug"><a href="#fmtdisplay-与-fmtdebug"><code>fmt::Display</code> 与 <code>fmt::Debug</code></a></h4>
<p>这两种格式 traits 具有不同的用途：</p>
<ul>
<li><a href="trait.Display.html" title="trait std::fmt::Display"><code>fmt::Display</code></a> 实现断言该类型可以始终忠实地表示为 UTF-8 字符串。并非所有类型都实现 <a href="trait.Display.html" title="trait std::fmt::Display"><code>Display</code></a> trait。</li>
<li><a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现应该为所有公共类型实现。
输出通常会尽可能忠实地代表内部状态。
<a href="trait.Debug.html" title="trait std::fmt::Debug"><code>Debug</code></a> trait 的目的是方便调试 Rust 代码。在大多数情况下，建议使用 <code>#[derive(Debug)]</code> 就足够了。</li>
</ul>
<p>这两个 traits 的输出的一些例子：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="string">&quot;3 4&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>), <span class="string">&quot;a &#39;b&#39;&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="string">&quot;foo\n&quot;</span>, <span class="string">&quot;bar\n&quot;</span>), <span class="string">&quot;foo\n \&quot;bar\\n\&quot;&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+3,+4),+%223+4%22);%0Aassert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+'a',+'b'),+%22a+'b'%22);%0Aassert_eq!(format!(%22%7B%7D+%7B:?%7D%22,+%22foo%5Cn%22,+%22bar%5Cn%22),+%22foo%5Cn+%5C%22bar%5C%5Cn%5C%22%22);%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="相关宏"><a href="#相关宏">相关宏</a></h2>
<p><a href="../macro.format.html" title="macro std::format"><code>format!</code></a> 系列中有许多相关的宏。当前实现的是：</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">format!      </span><span class="comment">// 如上所述
</span><span class="macro">write!       </span><span class="comment">// 第一个参数是 &amp;mut io::Write 或 &amp;mut fmt::Write，目的地
</span><span class="macro">writeln!     </span><span class="comment">// 与 write 相同，但追加了一个换行符
</span><span class="macro">print!       </span><span class="comment">// 格式字符串被打印到标准输出
</span><span class="macro">println!     </span><span class="comment">// 与 print 相同，但追加了一个换行符
</span><span class="macro">eprint!      </span><span class="comment">// 格式字符串被打印到标准错误
</span><span class="macro">eprintln!    </span><span class="comment">// 与 eprint 相同，但追加了一个换行符
</span><span class="macro">format_args! </span><span class="comment">// 如下面所描述的。</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aformat!++++++//+%E5%A6%82%E4%B8%8A%E6%89%80%E8%BF%B0%0Awrite!+++++++//+%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF+%26mut+io::Write+%E6%88%96+%26mut+fmt::Write%EF%BC%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%0Awriteln!+++++//+%E4%B8%8E+write+%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E8%BF%BD%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aprint!+++++++//+%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A2%AB%E6%89%93%E5%8D%B0%E5%88%B0%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%0Aprintln!+++++//+%E4%B8%8E+print+%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E8%BF%BD%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aeprint!++++++//+%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A2%AB%E6%89%93%E5%8D%B0%E5%88%B0%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%0Aeprintln!++++//+%E4%B8%8E+eprint+%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E8%BF%BD%E5%8A%A0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aformat_args!+//+%E5%A6%82%E4%B8%8B%E9%9D%A2%E6%89%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E3%80%82%0A%7D&amp;edition=2021">Run</a></div>
<h4 id="write"><a href="#write"><code>write!</code></a></h4>
<p><a href="../macro.write.html" title="macro std::write"><code>write!</code></a> 和 <a href="../macro.writeln.html" title="macro std::writeln"><code>writeln!</code></a> 是两个宏，用于将格式字符串发送到指定的流。这用于防止格式字符串的中间分配，而是直接写入输出。
在底层，这个函数实际上是调用在 <a href="../../std/io/trait.Write.html"><code>std::io::Write</code></a> 和 <a href="../../std/fmt/trait.Write.html"><code>std::fmt::Write</code></a> trait 上定义的 <a href="../../std/io/trait.Write.html#method.write_fmt"><code>write_fmt</code></a> 函数。
示例用法是：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::Write;
<span class="kw">let </span><span class="kw-2">mut </span>w = Vec::new();
<span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>w, <span class="string">&quot;Hello {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0Ause+std::io::Write;%0Alet+mut+w+=+Vec::new();%0Awrite!(%26mut+w,+%22Hello+%7B%7D!%22,+%22world%22);%0A%7D&amp;edition=2021">Run</a></div>
<h4 id="print"><a href="#print"><code>print!</code></a></h4>
<p>此和 <a href="../../std/macro.println.html" title="println!"><code>println!</code></a> 将其输出发送到 stdout。与 <a href="../macro.write.html" title="macro std::write"><code>write!</code></a> 宏类似，这些宏的目标是避免在打印输出时进行中间分配。示例用法是：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">print!</span>(<span class="string">&quot;Hello {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;I have a newline {}&quot;</span>, <span class="string">&quot;character at the end&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aprint!(%22Hello+%7B%7D!%22,+%22world%22);%0Aprintln!(%22I+have+a+newline+%7B%7D%22,+%22character+at+the+end%22);%0A%7D&amp;edition=2021">Run</a></div>
<h4 id="eprint"><a href="#eprint"><code>eprint!</code></a></h4>
<p><a href="../../std/macro.eprint.html" title="eprint!"><code>eprint!</code></a> 和 <a href="../../std/macro.eprintln.html" title="eprintln!"><code>eprintln!</code></a> 宏分别与 <a href="../../std/macro.print.html" title="print!"><code>print!</code></a> 和 <a href="../../std/macro.println.html" title="println!"><code>println!</code></a> 相同，只不过它们将其输出发送到 stderr。</p>
<h4 id="format_args"><a href="#format_args"><code>format_args!</code></a></h4>
<p><a href="../../std/macro.format_args.html" title="format_args!"><code>format_args!</code></a> 是一个奇怪的宏，用于安全地传递描述格式字符串的不透明对象。该对象不需要创建任何堆分配，并且仅引用栈上的信息。
在幕后，所有相关的宏都在此方面实现。
首先，一些示例用法是：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fmt;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Write};

<span class="kw">let </span><span class="kw-2">mut </span>some_writer = io::stdout();
<span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>some_writer, <span class="string">&quot;{}&quot;</span>, <span class="macro">format_args!</span>(<span class="string">&quot;print with a {}&quot;</span>, <span class="string">&quot;macro&quot;</span>));

<span class="kw">fn </span>my_fmt_fn(args: fmt::Arguments&lt;<span class="lifetime">&#39;_</span>&gt;) {
    <span class="macro">write!</span>(<span class="kw-2">&amp;mut </span>io::stdout(), <span class="string">&quot;{args}&quot;</span>);
}
my_fmt_fn(<span class="macro">format_args!</span>(<span class="string">&quot;, or a {} too&quot;</span>, <span class="string">&quot;function&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn+main()+%7B%0Ause+std::fmt;%0Ause+std::io::%7Bself,+Write%7D;%0A%0Alet+mut+some_writer+=+io::stdout();%0Awrite!(%26mut+some_writer,+%22%7B%7D%22,+format_args!(%22print+with+a+%7B%7D%22,+%22macro%22));%0A%0Afn+my_fmt_fn(args:+fmt::Arguments%3C'_%3E)+%7B%0A++++write!(%26mut+io::stdout(),+%22%7Bargs%7D%22);%0A%7D%0Amy_fmt_fn(format_args!(%22,+or+a+%7B%7D+too%22,+%22function%22));%0A%7D&amp;edition=2021">Run</a></div>
<p><a href="../../std/macro.format_args.html" title="format_args!"><code>format_args!</code></a> 宏的结果是 <a href="struct.Arguments.html" title="fmt::Arguments"><code>fmt::Arguments</code></a> 类型的值。
然后可以将此结构体传递到此模块内部的 <a href="fn.write.html" title="fmt::write"><code>write</code></a> 和 <a href="fn.format.html" title="fmt::format"><code>format</code></a> 函数，以处理格式字符串。
该宏的目的是在处理格式化字符串时甚至进一步防止中间分配。</p>
<p>例如，日志记录库可以使用标准格式语法，但是它将在内部绕过此结构体，直到确定了输出应该到达的位置为止。</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Arguments.html" title="struct std::fmt::Arguments">Arguments</a></div><div class="desc docblock-short">该结构体表示格式字符串及其参数的安全预编译版本。
由于无法安全地完成此操作，因此无法在运行时生成该文件，因此未提供任何构造函数，并且该字段为私有字段以防止修改。</div></li><li><div class="item-name"><a class="struct" href="struct.DebugList.html" title="struct std::fmt::DebugList">DebugList</a></div><div class="desc docblock-short">一个有助于 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现的结构体。</div></li><li><div class="item-name"><a class="struct" href="struct.DebugMap.html" title="struct std::fmt::DebugMap">DebugMap</a></div><div class="desc docblock-short">一个有助于 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现的结构体。</div></li><li><div class="item-name"><a class="struct" href="struct.DebugSet.html" title="struct std::fmt::DebugSet">DebugSet</a></div><div class="desc docblock-short">一个有助于 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现的结构体。</div></li><li><div class="item-name"><a class="struct" href="struct.DebugStruct.html" title="struct std::fmt::DebugStruct">DebugStruct</a></div><div class="desc docblock-short">一个有助于 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现的结构体。</div></li><li><div class="item-name"><a class="struct" href="struct.DebugTuple.html" title="struct std::fmt::DebugTuple">DebugTuple</a></div><div class="desc docblock-short">一个有助于 <a href="trait.Debug.html" title="trait std::fmt::Debug"><code>fmt::Debug</code></a> 实现的结构体。</div></li><li><div class="item-name"><a class="struct" href="struct.Error.html" title="struct std::fmt::Error">Error</a></div><div class="desc docblock-short">将消息格式化为流后返回的错误类型。</div></li><li><div class="item-name"><a class="struct" href="struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a></div><div class="desc docblock-short">格式化配置。</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Alignment.html" title="enum std::fmt::Alignment">Alignment</a></div><div class="desc docblock-short"><code>Formatter::align</code> 返回的可能的对齐方式</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Binary.html" title="trait std::fmt::Binary">Binary</a></div><div class="desc docblock-short"><code>b</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.Debug.html" title="trait std::fmt::Debug">Debug</a></div><div class="desc docblock-short"><code>?</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.Display.html" title="trait std::fmt::Display">Display</a></div><div class="desc docblock-short">空格式的格式 trait，<code>{}</code>。</div></li><li><div class="item-name"><a class="trait" href="trait.LowerExp.html" title="trait std::fmt::LowerExp">LowerExp</a></div><div class="desc docblock-short"><code>e</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.LowerHex.html" title="trait std::fmt::LowerHex">LowerHex</a></div><div class="desc docblock-short"><code>x</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.Octal.html" title="trait std::fmt::Octal">Octal</a></div><div class="desc docblock-short"><code>o</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a></div><div class="desc docblock-short"><code>p</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.UpperExp.html" title="trait std::fmt::UpperExp">UpperExp</a></div><div class="desc docblock-short"><code>E</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.UpperHex.html" title="trait std::fmt::UpperHex">UpperHex</a></div><div class="desc docblock-short"><code>X</code> 格式。</div></li><li><div class="item-name"><a class="trait" href="trait.Write.html" title="trait std::fmt::Write">Write</a></div><div class="desc docblock-short">一个用于写入或格式化为 Unicode 接受的缓冲区或流的 trait。</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.format.html" title="fn std::fmt::format">format</a></div><div class="desc docblock-short"><code>format</code> 函数采用 <a href="struct.Arguments.html" title="struct std::fmt::Arguments"><code>Arguments</code></a> 结构体，并返回生成的格式化字符串。</div></li><li><div class="item-name"><a class="fn" href="fn.write.html" title="fn std::fmt::write">write</a></div><div class="desc docblock-short"><code>write</code> 函数接受一个输出流，以及一个可以与 <code>format_args!</code> 宏预编译的 <code>Arguments</code> 结构体。</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type std::fmt::Result">Result</a></div><div class="desc docblock-short">格式化程序方法返回的类型。</div></li></ul><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="derive" href="derive.Debug.html" title="derive std::fmt::Debug">Debug</a></div><div class="desc docblock-short">派生宏，生成 <code>Debug</code> trait 的 impl。</div></li></ul></section></div></main></body></html>