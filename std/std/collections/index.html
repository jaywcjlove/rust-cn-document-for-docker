<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="集合类型。"><title>std::collections - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../std/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../std/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module collections</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">std</a>::<wbr><a class="mod" href="#">collections</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../src/std/collections/mod.rs.html#1-449">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>集合类型。</p>
<p>Rust 的标准集合库提供了最常见的通用编程数据结构的有效实现。通过使用标准实现，两个库在不进行大量数据转换的情况下就可以进行通信。</p>
<p>为了避免这种情况：您可能应该只使用 <a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a> 或 <a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a>。
这两个集合涵盖了泛型数据存储和处理的大多数用例。他们非常擅长于做自己的工作。标准库中的所有其他集合都具有特定的用例，在这些用例中它们是最佳选择，但相比之下，这些用例是边缘性的。
即使 <code>Vec</code> 和 <code>HashMap</code> 在技术上不是最佳选择，它们也可能是入门的足够好选择。</p>
<p>Rust 的集合可以分为四个主要类别：</p>
<ul>
<li>序列: <a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a>、<a href="struct.VecDeque.html" title="struct std::collections::VecDeque"><code>VecDeque</code></a>、<a href="struct.LinkedList.html" title="struct std::collections::LinkedList"><code>LinkedList</code></a></li>
<li>Maps: <a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a>, <a href="struct.BTreeMap.html" title="struct std::collections::BTreeMap"><code>BTreeMap</code></a></li>
<li>集合: <a href="hash_set/struct.HashSet.html" title="struct std::collections::hash_set::HashSet"><code>HashSet</code></a>、<a href="struct.BTreeSet.html" title="struct std::collections::BTreeSet"><code>BTreeSet</code></a></li>
<li>混杂: <a href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap"><code>BinaryHeap</code></a></li>
</ul>
<h2 id="什么时候应该使用哪个集合"><a href="#什么时候应该使用哪个集合">什么时候应该使用哪个集合？</a></h2>
<p>这些是应该何时考虑每个集合的较高层次且快速的细分。各个集合的优缺点的详细讨论可以在他们自己的文档页面上找到。</p>
<h4 id="在以下情况下请使用-vec"><a href="#在以下情况下请使用-vec">在以下情况下，请使用 <code>Vec</code>：</a></h4>
<ul>
<li>您想要收集项以供以后处理或发送到其他地方，而不必关心所存储的实际值的任何属性。</li>
<li>您需要一个按特定顺序排列的元素序列，并且只会追加到末尾 (或接近末尾)。</li>
<li>您想要一个栈。</li>
<li>您需要一个可调整大小的数组。</li>
<li>您需要一个堆分配的数组。</li>
</ul>
<h4 id="在以下情况下请使用-vecdeque"><a href="#在以下情况下请使用-vecdeque">在以下情况下，请使用 <code>VecDeque</code>：</a></h4>
<ul>
<li>您需要 <a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a> 支持序列两端的有效插入。</li>
<li>您想要一个队列。</li>
<li>您需要一个双端队列 (deque)。</li>
</ul>
<h4 id="在以下情况下请使用-linkedlist"><a href="#在以下情况下请使用-linkedlist">在以下情况下，请使用 <code>LinkedList</code>：</a></h4>
<ul>
<li>您需要一个未知大小的 <a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a> 或 <a href="struct.VecDeque.html" title="struct std::collections::VecDeque"><code>VecDeque</code></a>，并且不能容忍摊销。</li>
<li>您想有效地拆分和追加列表。</li>
<li>您确实，想要一个双向链表。</li>
</ul>
<h4 id="在以下情况下请使用-hashmap"><a href="#在以下情况下请使用-hashmap">在以下情况下，请使用 <code>HashMap</code>：</a></h4>
<ul>
<li>您想要将任意键与任意值相关联。</li>
<li>您需要一个缓存。</li>
<li>您需要一个没有额外功能的 map。</li>
</ul>
<h4 id="在以下情况下请使用-btreemap"><a href="#在以下情况下请使用-btreemap">在以下情况下，请使用 <code>BTreeMap</code>：</a></h4>
<ul>
<li>您需要一个按其键排序的 map。</li>
<li>您希望能够按需获取一系列条目。</li>
<li>您对最小或最大键值对是什么感兴趣。</li>
<li>您想要找到小于或大于某项的最大或最小键。</li>
</ul>
<h4 id="在以下情况下请使用任何这些-map-的-set-变体"><a href="#在以下情况下请使用任何这些-map-的-set-变体">在以下情况下，请使用任何这些 <code>Map</code> 的 <code>Set</code> 变体：</a></h4>
<ul>
<li>您只想记住您所看到的键。</li>
<li>与您的键关联没有任何有意义的值。</li>
<li>您只想要一个 set。</li>
</ul>
<h4 id="在以下情况下请使用-binaryheap"><a href="#在以下情况下请使用-binaryheap">在以下情况下，请使用 <code>BinaryHeap</code>：</a></h4>
<ul>
<li>您想存储一堆元素，但只想在任何给定时间处理 “biggest” 或 “most important”。</li>
<li>您需要一个优先级队列。</li>
</ul>
<h2 id="performance"><a href="#performance">Performance</a></h2>
<p>为工作选择合适的集合需要了解每个集合的特长。在这里，我们简要总结了某些重要操作的不同集合的性能。
有关更多详细信息，请参见每种类型的文档，并请注意，实际方法的名称可能与某些集合中的下表有所不同。</p>
<p>在整个文档中，我们将遵循一些约定。对于所有操作，集合的大小用 n 表示。如果该操作涉及另一个集合，则它包含 m 个元素。具有 <code>amortized</code> 成本的操作以 <code>*</code> 为后缀。具有 <code>expected</code> 成本的操作以 <code>~</code> 为后缀。</p>
<p>所有摊销成本均用于容量耗尽时可能需要调整的大小。如果发生调整大小，则将花费 <em>O</em>(<em>n</em>) 时间。我们的集合永远不会自动收缩，因此移除操作不会摊销。在足够多的工序系列中，每次工序的平均成本将确定性地等于给定成本。</p>
<p>由于哈希的概率性质，只有 <a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a> 具有预期的成本。
从理论上讲，<a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a> 可能会出现性能下降的情况，尽管可能性很小。</p>
<h3 id="sequences"><a href="#sequences">Sequences</a></h3><div><table><thead><tr><th></th><th>get(i)</th><th>insert(i)</th><th>remove(i)</th><th>append</th><th>split_off(i)</th></tr></thead><tbody>
<tr><td><a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(<em>n</em>-<em>i</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td></tr>
<tr><td><a href="struct.VecDeque.html" title="struct std::collections::VecDeque"><code>VecDeque</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td></tr>
<tr><td><a href="struct.LinkedList.html" title="struct std::collections::LinkedList"><code>LinkedList</code></a></td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td></tr>
</tbody></table>
</div>
<p>请注意，在发生联系的地方，<a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a> 通常比 <a href="struct.VecDeque.html" title="struct std::collections::VecDeque"><code>VecDeque</code></a> 快，而 <a href="struct.VecDeque.html" title="struct std::collections::VecDeque"><code>VecDeque</code></a> 通常比 <a href="struct.LinkedList.html" title="struct std::collections::LinkedList"><code>LinkedList</code></a> 快。</p>
<h3 id="maps"><a href="#maps">Maps</a></h3>
<p>对于集合，所有操作的成本均等价于 Map 操作。</p>
<div><table><thead><tr><th></th><th>get</th><th>insert</th><th>remove</th><th>range</th><th>append</th></tr></thead><tbody>
<tr><td><a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a></td><td><em>O</em>(1)~</td><td><em>O</em>(1)~*</td><td><em>O</em>(1)~</td><td>N/A</td><td>N/A</td></tr>
<tr><td><a href="struct.BTreeMap.html" title="struct std::collections::BTreeMap"><code>BTreeMap</code></a></td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(<em>n</em>+<em>m</em>)</td></tr>
</tbody></table>
</div><h2 id="正确有效地使用集合"><a href="#正确有效地使用集合">正确有效地使用集合</a></h2>
<p>当然，知道哪种集合最适合该工作并不能立即使您正确使用它。以下是一般有效和正确使用标准集合的一些快速技巧。如果您特别对如何使用特定集合感兴趣，请查阅其文档以获取详细的讨论和代码示例。</p>
<h3 id="容量管理"><a href="#容量管理">容量管理</a></h3>
<p>许多集合提供了一些引用 “capacity” 的构造函数和方法。这些集合通常构建在数组的顶部。
理想情况下，此数组的大小恰好适合仅适合存储在集合中的元素，但是对于集合而言，这样做效率很低。如果支持数组始终正确大小，则每次插入元素时，集合都必须增大数组以适合它。
由于在大多数计算机上分配和管理内存的方式，几乎肯定需要分配一个全新的数组，并将每个元素从旧元素复制到新元素中。
希望您能看到这样做并不是在每个操作上都非常有效。</p>
<p>因此，大多数集合使用 <code>amortized</code> 分配策略。它们通常让自己拥有大量的空闲空间，因此它们仅需要偶尔增长。当它们确实增长时，它们会分配一个更大的数组来将元素移入，以便需要一段时间才能进行另一个增长。
尽管此策略总体上不错，但如果必须 * 绝不调整其支持数组的大小，那就更好了。
不幸的是，集合本身没有足够的信息来执行此操作。
因此，由我们的程序员来提供提示。</p>
<p>任何 <code>with_capacity</code> 构造函数都将指示该集合为指定数量的元素分配足够的空间。理想情况下，这将恰好适用于许多元素，但是某些实现细节可能会阻止这种情况。有关详细信息，请参见特定于集合的文档。通常，当您确切知道要插入多少个元素，或者至少在该数目上具有合理的上限时，请使用 <code>with_capacity</code>。</p>
<p>当预期大量元素涌入时，<code>reserve</code> 系列方法可用于向集合暗示应该为即将到来的项目腾出多少空间。与 <code>with_capacity</code> 一样，这些方法的精确行为将特定于感兴趣的集合。</p>
<p>为了获得最佳性能，集合通常会避免自身收缩。如果您认为某个集合将很快不再包含任何其他元素，或者仅真的需要内存，则 <code>shrink_to_fit</code> 方法将提示该集合将后备数组缩小到能够容纳其元素的最小大小。</p>
<p>最后，如果您对集合的实际容量感兴趣，则大多数集合都会提供 <code>capacity</code> 方法来按需查询此信息。这对于调试目的或与 <code>reserve</code> 方法一起使用可能很有用。</p>
<h3 id="iterators"><a href="#iterators">Iterators</a></h3>
<p><a href="../iter/index.html" title="mod std::iter">Iterators</a>
是 Rust 标准库中使用的一种强大而稳健的机制。
迭代器以泛型，安全，有效和方便的方式提供一系列值。迭代器的内容通常是惰性求值的，因此只有实际需要的值才会实际产生，而不需要进行任何分配来临时存储它们。迭代器主要通过 <code>for</code> 循环消耗，尽管许多函数也将迭代器用于需要集合或值序列的地方。</p>
<p>所有标准集合都提供了几个用于对其内容进行批量操作的迭代器。几乎每个集合应提供的三个主要迭代器是 <code>iter</code>，<code>iter_mut</code> 和 <code>into_iter</code>。
其中的某些未在集合中提供，因此提供它们是不合理的或不合理的。</p>
<p><code>iter</code> 提供了一个迭代器，以最自然的顺序对集合的所有内容进行不可变的引用。
对于像 <a href="../vec/struct.Vec.html" title="struct std::vec::Vec"><code>Vec</code></a> 这样的序列集合，这意味着该项将以索引从 0 开始的递增顺序产生。对于 <a href="struct.BTreeMap.html" title="struct std::collections::BTreeMap"><code>BTreeMap</code></a> 之类的有序集合，这意味着该项将按排序顺序产生。
对于 <a href="hash_map/struct.HashMap.html" title="struct std::collections::hash_map::HashMap"><code>HashMap</code></a> 之类的无序集合，将以内部表示最方便的任何顺序产生该项。这对于通读集合的所有内容非常有用。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">for </span>x <span class="kw">in </span>vec.iter() {
   <span class="macro">println!</span>(<span class="string">&quot;vec contained {x:?}&quot;</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+vec+=+vec!%5B1,+2,+3,+4%5D;%0Afor+x+in+vec.iter()+%7B%0A+++println!(%22vec+contained+%7Bx:?%7D%22);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><code>iter_mut</code> 提供了一个可变引用的迭代器，其顺序与 <code>iter</code> 相同。这对于更改集合的所有内容非常有用。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>vec = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">for </span>x <span class="kw">in </span>vec.iter_mut() {
   <span class="kw-2">*</span>x += <span class="number">1</span>;
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+vec+=+vec!%5B1,+2,+3,+4%5D;%0Afor+x+in+vec.iter_mut()+%7B%0A+++*x+%2B=+1;%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><code>into_iter</code> 将实际集合转换为按值对其内容进行迭代的迭代器。当不再需要集合本身并且在其他地方需要这些值时，这非常好。将 <code>extend</code> 与 <code>into_iter</code> 一起使用是将一个集合的内容移入另一个集合的主要方法。
<code>extend</code> 自动调用 <code>into_iter</code>，并取任何 <code>T: <a href="../iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a></code>。
在迭代器本身上调用 <code>collect</code> 也是将一个集合转换为另一个集合的好方法。这两种方法都应在内部使用上一节中讨论的容量管理工具来尽可能高效地执行此操作。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>vec1 = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let </span>vec2 = <span class="macro">vec!</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];
vec1.extend(vec2);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+mut+vec1+=+vec!%5B1,+2,+3,+4%5D;%0Alet+vec2+=+vec!%5B10,+20,+30,+40%5D;%0Avec1.extend(vec2);%0A%7D&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::VecDeque;

<span class="kw">let </span>vec = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let </span>buf: VecDeque&lt;<span class="kw">_</span>&gt; = vec.into_iter().collect();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::VecDeque;%0A%0Alet+vec+=+%5B1,+2,+3,+4%5D;%0Alet+buf:+VecDeque%3C_%3E+=+vec.into_iter().collect();%0A%7D&amp;edition=2021">Run</a></div>
<p>迭代器还提供了一系列 <em>adapter</em> 方法，用于对序列执行通用线程。
在适配器中，有功能最喜欢的适配器，例如 <code>map</code>，<code>fold</code>，<code>skip</code> 和 <code>take</code>。集合特别感兴趣的是 <code>rev</code> 适配器，它反转支持此操作的任何迭代器。大多数集合都提供可逆迭代器，作为以相反顺序对其进行迭代的方式。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>vec = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">for </span>x <span class="kw">in </span>vec.iter().rev() {
   <span class="macro">println!</span>(<span class="string">&quot;vec contained {x:?}&quot;</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+vec+=+vec!%5B1,+2,+3,+4%5D;%0Afor+x+in+vec.iter().rev()+%7B%0A+++println!(%22vec+contained+%7Bx:?%7D%22);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>其他几种集合方法还返回迭代器以产生结果序列，但避免分配整个集合来存储结果。
这提供了最大的灵活性，因为如果需要，可以将 <a href="../iter/trait.Iterator.html#method.collect" title="method std::iter::Iterator::collect"><code>collect</code></a> 或 <a href="../iter/trait.Extend.html#tymethod.extend" title="method std::iter::Extend::extend"><code>extend</code></a> 调用到 “pipe” 序列到任何集合中。否则，可以使用 <code>for</code> 循环将序列循环。迭代器在部分使用后也可以丢弃，从而避免了未使用项的计算。</p>
<h3 id="entries"><a href="#entries">Entries</a></h3>
<p><code>entry</code> API 旨在提供一种有效的机制，用于根据键的存在与否来有条件地操作 map 的内容。这样做的主要动机是提供有效的累加器 maps。例如，如果希望保持对每个键被看到的次数的计数，则他们将必须执行一些条件逻辑来确定这是否是第一次被看到。</p>
<p>通常，这需要先插入 <code>find</code>，然后再插入 <code>insert</code>，以有效地重复每次插入时的搜索工作。</p>
<p>当用户调用 <code>map.entry(key)</code> 时，map 将搜索键，然后生成 <code>Entry</code> 枚举的变体。</p>
<p>如果产生 <code>Vacant(entry)</code>，则没有找到键。在这种情况下，唯一有效的操作是将值 <code>insert</code> 放入条目中。完成此操作后，将消耗空条目并将其转换为所插入值的变量引用。这允许对超出搜索本身生命周期的值进行进一步操作。
如果无论是否插入值，都需要对值执行复杂的逻辑，这将很有用。</p>
<p>如果产生 <code>Occupied(entry)</code>，则找到键 *。
在这种情况下，用户有几个选项：他们可以 <code>get</code>，<code>insert</code> 或 <code>remove</code> 占用的条目的值。此外，他们可以将占用的条目转换为其值的变量引用，从而为空缺的 <code>insert</code> 情况提供对称性。</p>
<h4 id="examples"><a href="#examples">Examples</a></h4>
<p>这是使用 <code>entry</code> 的两种主要方法。首先，一个简单的示例，其中对值执行的逻辑很简单。</p>
<h5 id="计算字符串中每个字符出现的次数"><a href="#计算字符串中每个字符出现的次数">计算字符串中每个字符出现的次数</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::btree_map::BTreeMap;

<span class="kw">let </span><span class="kw-2">mut </span>count = BTreeMap::new();
<span class="kw">let </span>message = <span class="string">&quot;she sells sea shells by the sea shore&quot;</span>;

<span class="kw">for </span>c <span class="kw">in </span>message.chars() {
    <span class="kw-2">*</span>count.entry(c).or_insert(<span class="number">0</span>) += <span class="number">1</span>;
}

<span class="macro">assert_eq!</span>(count.get(<span class="kw-2">&amp;</span><span class="string">&#39;s&#39;</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">8</span>));

<span class="macro">println!</span>(<span class="string">&quot;Number of occurrences of each character&quot;</span>);
<span class="kw">for </span>(char, count) <span class="kw">in </span><span class="kw-2">&amp;</span>count {
    <span class="macro">println!</span>(<span class="string">&quot;{char}: {count}&quot;</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::btree_map::BTreeMap;%0A%0Alet+mut+count+=+BTreeMap::new();%0Alet+message+=+%22she+sells+sea+shells+by+the+sea+shore%22;%0A%0Afor+c+in+message.chars()+%7B%0A++++*count.entry(c).or_insert(0)+%2B=+1;%0A%7D%0A%0Aassert_eq!(count.get(%26's'),+Some(%268));%0A%0Aprintln!(%22Number+of+occurrences+of+each+character%22);%0Afor+(char,+count)+in+%26count+%7B%0A++++println!(%22%7Bchar%7D:+%7Bcount%7D%22);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>当要对该值执行的逻辑比较复杂时，我们可以简单地使用 <code>entry</code> API 来确保该值已初始化，然后再执行该逻辑。</p>
<h5 id="跟踪酒吧顾客的醉酒情况"><a href="#跟踪酒吧顾客的醉酒情况">跟踪酒吧顾客的醉酒情况</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::btree_map::BTreeMap;

<span class="comment">// 酒吧客户端。他们有血液中的酒精含量。
</span><span class="kw">struct </span>Person { blood_alcohol: f32 }

<span class="comment">// 所有的订单都是按客户 ID 送到酒吧的。
</span><span class="kw">let </span>orders = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];

<span class="comment">// 我们的客户。
</span><span class="kw">let </span><span class="kw-2">mut </span>blood_alcohol = BTreeMap::new();

<span class="kw">for </span>id <span class="kw">in </span>orders {
    <span class="comment">// 如果这是我们第一次见到此客户，请在不使用酒精的情况下初始化他们。
    // 否则，只需检索它们。
    </span><span class="kw">let </span>person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: <span class="number">0.0 </span>});

    <span class="comment">// 降低他们的血液酒精含量。点餐和喝啤酒需要时间！
    </span>person.blood_alcohol <span class="kw-2">*</span>= <span class="number">0.9</span>;

    <span class="comment">// 检查他们是否足够清醒，可以再喝一杯啤酒。
    </span><span class="kw">if </span>person.blood_alcohol &gt; <span class="number">0.3 </span>{
        <span class="comment">// 太醉了... 现在。
        </span><span class="macro">println!</span>(<span class="string">&quot;Sorry {id}, I have to cut you off&quot;</span>);
    } <span class="kw">else </span>{
        <span class="comment">// 再来一杯！
        </span>person.blood_alcohol += <span class="number">0.1</span>;
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::btree_map::BTreeMap;%0A%0A//+%E9%85%92%E5%90%A7%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82%E4%BB%96%E4%BB%AC%E6%9C%89%E8%A1%80%E6%B6%B2%E4%B8%AD%E7%9A%84%E9%85%92%E7%B2%BE%E5%90%AB%E9%87%8F%E3%80%82%0Astruct+Person+%7B+blood_alcohol:+f32+%7D%0A%0A//+%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%A2%E5%8D%95%E9%83%BD%E6%98%AF%E6%8C%89%E5%AE%A2%E6%88%B7+ID+%E9%80%81%E5%88%B0%E9%85%92%E5%90%A7%E7%9A%84%E3%80%82%0Alet+orders+=+vec!%5B1,+2,+1,+2,+3,+4,+1,+2,+2,+3,+4,+1,+1,+1%5D;%0A%0A//+%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E3%80%82%0Alet+mut+blood_alcohol+=+BTreeMap::new();%0A%0Afor+id+in+orders+%7B%0A++++//+%E5%A6%82%E6%9E%9C%E8%BF%99%E6%98%AF%E6%88%91%E4%BB%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A7%81%E5%88%B0%E6%AD%A4%E5%AE%A2%E6%88%B7%EF%BC%8C%E8%AF%B7%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%85%92%E7%B2%BE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%96%E4%BB%AC%E3%80%82%0A++++//+%E5%90%A6%E5%88%99%EF%BC%8C%E5%8F%AA%E9%9C%80%E6%A3%80%E7%B4%A2%E5%AE%83%E4%BB%AC%E3%80%82%0A++++let+person+=+blood_alcohol.entry(id).or_insert(Person+%7B+blood_alcohol:+0.0+%7D);%0A%0A++++//+%E9%99%8D%E4%BD%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E8%A1%80%E6%B6%B2%E9%85%92%E7%B2%BE%E5%90%AB%E9%87%8F%E3%80%82%E7%82%B9%E9%A4%90%E5%92%8C%E5%96%9D%E5%95%A4%E9%85%92%E9%9C%80%E8%A6%81%E6%97%B6%E9%97%B4%EF%BC%81%0A++++person.blood_alcohol+*=+0.9;%0A%0A++++//+%E6%A3%80%E6%9F%A5%E4%BB%96%E4%BB%AC%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E6%B8%85%E9%86%92%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%96%9D%E4%B8%80%E6%9D%AF%E5%95%A4%E9%85%92%E3%80%82%0A++++if+person.blood_alcohol+%3E+0.3+%7B%0A++++++++//+%E5%A4%AA%E9%86%89%E4%BA%86...+%E7%8E%B0%E5%9C%A8%E3%80%82%0A++++++++println!(%22Sorry+%7Bid%7D,+I+have+to+cut+you+off%22);%0A++++%7D+else+%7B%0A++++++++//+%E5%86%8D%E6%9D%A5%E4%B8%80%E6%9D%AF%EF%BC%81%0A++++++++person.blood_alcohol+%2B=+0.1;%0A++++%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="插入复杂的键"><a href="#插入复杂的键">插入复杂的键</a></h2>
<p>如果我们拥有更复杂的键，则对 <code>insert</code> 的调用将不会更新键的值。例如：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cmp::Ordering;
<span class="kw">use </span>std::collections::BTreeMap;
<span class="kw">use </span>std::hash::{Hash, Hasher};

<span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>Foo {
    a: u32,
    b: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str,
}

<span class="comment">// 我们将仅通过它们的 `a` 值来比较 `Foo`。
</span><span class="kw">impl </span>PartialEq <span class="kw">for </span>Foo {
    <span class="kw">fn </span>eq(<span class="kw-2">&amp;</span><span class="self">self</span>, other: <span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; bool { <span class="self">self</span>.a == other.a }
}

<span class="kw">impl </span>Eq <span class="kw">for </span>Foo {}

<span class="comment">// 我们将仅通过 `a` 值对 Foo 进行哈希处理。
</span><span class="kw">impl </span>Hash <span class="kw">for </span>Foo {
    <span class="kw">fn </span>hash&lt;H: Hasher&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, h: <span class="kw-2">&amp;mut </span>H) { <span class="self">self</span>.a.hash(h); }
}

<span class="kw">impl </span>PartialOrd <span class="kw">for </span>Foo {
    <span class="kw">fn </span>partial_cmp(<span class="kw-2">&amp;</span><span class="self">self</span>, other: <span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Ordering&gt; { <span class="self">self</span>.a.partial_cmp(<span class="kw-2">&amp;</span>other.a) }
}

<span class="kw">impl </span>Ord <span class="kw">for </span>Foo {
    <span class="kw">fn </span>cmp(<span class="kw-2">&amp;</span><span class="self">self</span>, other: <span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; Ordering { <span class="self">self</span>.a.cmp(<span class="kw-2">&amp;</span>other.a) }
}

<span class="kw">let </span><span class="kw-2">mut </span>map = BTreeMap::new();
map.insert(Foo { a: <span class="number">1</span>, b: <span class="string">&quot;baz&quot; </span>}, <span class="number">99</span>);

<span class="comment">// 我们已经有一个 a 等于 1 的 Foo，因此这将更新该值。
</span>map.insert(Foo { a: <span class="number">1</span>, b: <span class="string">&quot;xyz&quot; </span>}, <span class="number">100</span>);

<span class="comment">// 该值已更新...
</span><span class="macro">assert_eq!</span>(map.values().next().unwrap(), <span class="kw-2">&amp;</span><span class="number">100</span>);

<span class="comment">// ...但关键没有改变。b 仍然是 &quot;baz&quot;，而不是 &quot;xyz&quot;。
</span><span class="macro">assert_eq!</span>(map.keys().next().unwrap().b, <span class="string">&quot;baz&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::cmp::Ordering;%0Ause+std::collections::BTreeMap;%0Ause+std::hash::%7BHash,+Hasher%7D;%0A%0A%23%5Bderive(Debug)%5D%0Astruct+Foo+%7B%0A++++a:+u32,%0A++++b:+%26'static+str,%0A%7D%0A%0A//+%E6%88%91%E4%BB%AC%E5%B0%86%E4%BB%85%E9%80%9A%E8%BF%87%E5%AE%83%E4%BB%AC%E7%9A%84+%60a%60+%E5%80%BC%E6%9D%A5%E6%AF%94%E8%BE%83+%60Foo%60%E3%80%82%0Aimpl+PartialEq+for+Foo+%7B%0A++++fn+eq(%26self,+other:+%26Self)+-%3E+bool+%7B+self.a+==+other.a+%7D%0A%7D%0A%0Aimpl+Eq+for+Foo+%7B%7D%0A%0A//+%E6%88%91%E4%BB%AC%E5%B0%86%E4%BB%85%E9%80%9A%E8%BF%87+%60a%60+%E5%80%BC%E5%AF%B9+Foo+%E8%BF%9B%E8%A1%8C%E5%93%88%E5%B8%8C%E5%A4%84%E7%90%86%E3%80%82%0Aimpl+Hash+for+Foo+%7B%0A++++fn+hash%3CH:+Hasher%3E(%26self,+h:+%26mut+H)+%7B+self.a.hash(h);+%7D%0A%7D%0A%0Aimpl+PartialOrd+for+Foo+%7B%0A++++fn+partial_cmp(%26self,+other:+%26Self)+-%3E+Option%3COrdering%3E+%7B+self.a.partial_cmp(%26other.a)+%7D%0A%7D%0A%0Aimpl+Ord+for+Foo+%7B%0A++++fn+cmp(%26self,+other:+%26Self)+-%3E+Ordering+%7B+self.a.cmp(%26other.a)+%7D%0A%7D%0A%0Alet+mut+map+=+BTreeMap::new();%0Amap.insert(Foo+%7B+a:+1,+b:+%22baz%22+%7D,+99);%0A%0A//+%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%B8%80%E4%B8%AA+a+%E7%AD%89%E4%BA%8E+1+%E7%9A%84+Foo%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%BF%99%E5%B0%86%E6%9B%B4%E6%96%B0%E8%AF%A5%E5%80%BC%E3%80%82%0Amap.insert(Foo+%7B+a:+1,+b:+%22xyz%22+%7D,+100);%0A%0A//+%E8%AF%A5%E5%80%BC%E5%B7%B2%E6%9B%B4%E6%96%B0...%0Aassert_eq!(map.values().next().unwrap(),+%26100);%0A%0A//+...%E4%BD%86%E5%85%B3%E9%94%AE%E6%B2%A1%E6%9C%89%E6%94%B9%E5%8F%98%E3%80%82b+%E4%BB%8D%E7%84%B6%E6%98%AF+%22baz%22%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF+%22xyz%22%E3%80%82%0Aassert_eq!(map.keys().next().unwrap().b,+%22baz%22);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="binary_heap/index.html" title="mod std::collections::binary_heap">binary_heap</a></div><div class="desc docblock-short">用二进制堆实现的优先级队列。</div></li><li><div class="item-name"><a class="mod" href="btree_map/index.html" title="mod std::collections::btree_map">btree_map</a></div><div class="desc docblock-short">基于 B 树的有序 map。</div></li><li><div class="item-name"><a class="mod" href="btree_set/index.html" title="mod std::collections::btree_set">btree_set</a></div><div class="desc docblock-short">基于 B 树的有序 set。</div></li><li><div class="item-name"><a class="mod" href="hash_map/index.html" title="mod std::collections::hash_map">hash_map</a></div><div class="desc docblock-short">通过二次探测和 SIMD 查找实现的哈希 map。</div></li><li><div class="item-name"><a class="mod" href="hash_set/index.html" title="mod std::collections::hash_set">hash_set</a></div><div class="desc docblock-short">实现为 <code>HashMap</code> 的哈希集，其中值为 <code>()</code>。</div></li><li><div class="item-name"><a class="mod" href="linked_list/index.html" title="mod std::collections::linked_list">linked_list</a></div><div class="desc docblock-short">具有所属节点的双向链表。</div></li><li><div class="item-name"><a class="mod" href="vec_deque/index.html" title="mod std::collections::vec_deque">vec_deque</a></div><div class="desc docblock-short">使用可增长的环形缓冲区实现的双端队列 (deque)。</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BTreeMap.html" title="struct std::collections::BTreeMap">BTreeMap</a></div><div class="desc docblock-short">基于 <a href="https://en.wikipedia.org/wiki/B-tree">B-Tree</a> 的有序 map。</div></li><li><div class="item-name"><a class="struct" href="struct.BTreeSet.html" title="struct std::collections::BTreeSet">BTreeSet</a></div><div class="desc docblock-short">基于 B 树的有序 set。</div></li><li><div class="item-name"><a class="struct" href="struct.BinaryHeap.html" title="struct std::collections::BinaryHeap">BinaryHeap</a></div><div class="desc docblock-short">用二进制堆实现的优先级队列。</div></li><li><div class="item-name"><a class="struct" href="struct.HashMap.html" title="struct std::collections::HashMap">HashMap</a></div><div class="desc docblock-short">通过二次探测和 SIMD 查找实现的 <a href="index.html#use-a-hashmap-when" title="mod std::collections">哈希表</a>。</div></li><li><div class="item-name"><a class="struct" href="struct.HashSet.html" title="struct std::collections::HashSet">HashSet</a></div><div class="desc docblock-short"><a href="index.html#use-the-set-variant-of-any-of-these-maps-when" title="mod std::collections">hash set</a>，实现为 <code>HashMap</code>，其中值为 <code>()</code>。</div></li><li><div class="item-name"><a class="struct" href="struct.LinkedList.html" title="struct std::collections::LinkedList">LinkedList</a></div><div class="desc docblock-short">具有所属节点的双向链表。</div></li><li><div class="item-name"><a class="struct" href="struct.TryReserveError.html" title="struct std::collections::TryReserveError">TryReserveError</a></div><div class="desc docblock-short"><code>try_reserve</code> 方法的错误类型。</div></li><li><div class="item-name"><a class="struct" href="struct.VecDeque.html" title="struct std::collections::VecDeque">VecDeque</a></div><div class="desc docblock-short">使用可增长的环形缓冲区实现的双端队列。</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.TryReserveErrorKind.html" title="enum std::collections::TryReserveErrorKind">TryReserveErrorKind</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">导致 <code>TryReserveError</code> 的分配的详细信息</div></li></ul></section></div></main></body></html>