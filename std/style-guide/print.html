<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Style Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">1.</strong> Module-level items</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">2.</strong> Statements</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">3.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li class="chapter-item expanded "><a href="advice.html"><strong aria-hidden="true">5.</strong> Non-formatting conventions</a></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">6.</strong> Cargo.toml conventions</a></li><li class="chapter-item expanded "><a href="principles.html"><strong aria-hidden="true">7.</strong> Principles used for deciding these guidelines</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Style Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/HEAD/src/doc/style-guide/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-style-guide"><a class="header" href="#rust-style-guide">Rust Style Guide</a></h1>
<h2 id="motivation---why-use-a-formatting-tool"><a class="header" href="#motivation---why-use-a-formatting-tool">Motivation - why use a formatting tool?</a></h2>
<p>Formatting code is a mostly mechanical task which takes both time and mental
effort. By using an automatic formatting tool, a programmer is relieved of
this task and can concentrate on more important things.</p>
<p>Furthermore, by sticking to an established style guide (such as this one),
programmers don't need to formulate ad hoc style rules, nor do they need to
debate with other programmers what style rules should be used, saving time,
communication overhead, and mental energy.</p>
<p>Humans comprehend information through pattern matching. By ensuring that all
Rust code has similar formatting, less mental effort is required to comprehend a
new project, lowering the barrier to entry for new developers.</p>
<p>Thus, there are productivity benefits to using a formatting tool (such as
rustfmt), and even larger benefits by using a community-consistent formatting,
typically by using a formatting tool's default settings.</p>
<h2 id="formatting-conventions"><a class="header" href="#formatting-conventions">Formatting conventions</a></h2>
<h3 id="indentation-and-line-width"><a class="header" href="#indentation-and-line-width">Indentation and line width</a></h3>
<ul>
<li>Use spaces, not tabs.</li>
<li>Each level of indentation must be four spaces (that is, all indentation
outside of string literals and comments must be a multiple of four).</li>
<li>The maximum width for a line is 100 characters.</li>
<li>A tool should be configurable for all three of these variables.</li>
</ul>
<h3 id="blank-lines"><a class="header" href="#blank-lines">Blank lines</a></h3>
<p>Separate items and statements by either zero or one blank lines (i.e., one or
two newlines). E.g,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = ...;

    let y = ...;
    let z = ...;
}

fn bar() {}
fn baz() {}
<span class="boring">}</span></code></pre></pre>
<p>Formatting tools should make the bounds on blank lines configurable: there
should be separate minimum and maximum numbers of newlines between both
statements and (top-level) items (i.e., four options). As described above, the
defaults for both statements and items should be minimum: 1, maximum: 2.</p>
<h3 id="module-level-items"><a class="header" href="#module-level-items"><a href="items.html">Module-level items</a></a></h3>
<h3 id="statements"><a class="header" href="#statements"><a href="statements.html">Statements</a></a></h3>
<h3 id="expressions"><a class="header" href="#expressions"><a href="expressions.html">Expressions</a></a></h3>
<h3 id="types"><a class="header" href="#types"><a href="types.html">Types</a></a></h3>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>The following guidelines for comments are recommendations only, a mechanical
formatter might skip formatting of comments.</p>
<p>Prefer line comments (<code>//</code>) to block comments (<code>/* ... */</code>).</p>
<p>When using line comments there should be a single space after the opening sigil.</p>
<p>When using single-line block comments there should be a single space after the
opening sigil and before the closing sigil. Multi-line block comments should
have a newline after the opening sigil and before the closing sigil.</p>
<p>Prefer to put a comment on its own line. Where a comment follows code, there
should be a single space before it. Where a block comment is inline, there
should be surrounding whitespace as if it were an identifier or keyword. There
should be no trailing whitespace after a comment or at the end of any line in a
multi-line comment. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment on an item.
struct Foo { ... }

fn foo() {} // A comment after an item.

pub fn foo(/* a comment before an argument */ x: T) {...}
<span class="boring">}</span></code></pre></pre>
<p>Comments should usually be complete sentences. Start with a capital letter, end
with a period (<code>.</code>). An inline block comment may be treated as a note without
punctuation.</p>
<p>Source lines which are entirely a comment should be limited to 80 characters
in length (including comment sigils, but excluding indentation) or the maximum
width of the line (including comment sigils and indentation), whichever is
smaller:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This comment goes up to the ................................. 80 char margin.

{
    // This comment is .............................................. 80 chars wide.
}

{
    {
        {
            {
                {
                    {
                        // This comment is limited by the ......................... 100 char margin.
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h4>
<p>Prefer line comments (<code>///</code>) to block comments (<code>/** ... */</code>).</p>
<p>Prefer outer doc comments (<code>///</code> or <code>/** ... */</code>), only use inner doc comments
(<code>//!</code> and <code>/*! ... */</code>) to write module-level or crate-level documentation.</p>
<p>Doc comments should come before attributes.</p>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Put each attribute on its own line, indented to the level of the item.
In the case of inner attributes (<code>#!</code>), indent it to the level of the inside of
the item. Prefer outer attributes, where possible.</p>
<p>For attributes with argument lists, format like functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
#[foo(foo, bar)]
struct CRepr {
    #![repr(C)]
    x: f32,
    y: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>For attributes with an equal sign, there should be a single space before and
after the <code>=</code>, e.g., <code>#[foo = 42]</code>.</p>
<p>There must only be a single <code>derive</code> attribute. Note for tool authors: if
combining multiple <code>derive</code> attributes into a single attribute, the ordering of
the derived names should be preserved. E.g., <code>#[derive(bar)] #[derive(foo)] struct Baz;</code> should be formatted to <code>#[derive(bar, foo)] struct Baz;</code>.</p>
<h3 id="small-items"><a class="header" href="#small-items"><em>small</em> items</a></h3>
<p>In many places in this guide we specify that a formatter may format an item
differently if it is <em>small</em>, for example struct literals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Normal formatting
Foo {
    f1: an_expression,
    f2: another_expression(),
}

// *small* formatting
Foo { f1, f2 }
<span class="boring">}</span></code></pre></pre>
<p>We leave it to individual tools to decide on exactly what <em>small</em> means. In
particular, tools are free to use different definitions in different
circumstances.</p>
<p>Some suitable heuristics are the size of the item (in characters) or the
complexity of an item (for example, that all components must be simple names,
not more complex sub-expressions). For more discussion on suitable heuristics,
see <a href="https://github.com/rust-lang-nursery/fmt-rfcs/issues/47">this issue</a>.</p>
<p>Tools should give the user an option to ignore such heuristics and always use
the normal formatting.</p>
<h2 id="non-formatting-conventions"><a class="header" href="#non-formatting-conventions"><a href="advice.html">Non-formatting conventions</a></a></h2>
<h2 id="cargotoml-conventions"><a class="header" href="#cargotoml-conventions"><a href="cargo.html">Cargo.toml conventions</a></a></h2>
<h2 id="principles-used-for-deciding-these-guidelines"><a class="header" href="#principles-used-for-deciding-these-guidelines"><a href="principles.html">Principles used for deciding these guidelines</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="items"><a class="header" href="#items">Items</a></h2>
<p><code>extern crate</code> statements must be first in a file. They must be ordered
alphabetically.</p>
<p><code>use</code> statements, and module <em>declarations</em> (<code>mod foo;</code>, not <code>mod { ... }</code>)
must come before other items. We recommend that imports come before module
declarations; if imports and modules are separated, then they should be ordered
alphabetically. When sorting, <code>self</code> and <code>super</code> must come before any other
names. Module declarations should not be moved if they are annotated with
<code>#[macro_use]</code>, since that may be semantics changing.</p>
<p>Tools should make the above ordering optional.</p>
<h3 id="function-definitions"><a class="header" href="#function-definitions">Function definitions</a></h3>
<p>In Rust, one finds functions by searching for <code>fn [function-name]</code>; It's
important that you style your code so that it's very searchable in this way.</p>
<p>The proper ordering and spacing is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[pub] [unsafe] [extern [&quot;ABI&quot;]] fn foo(arg1: i32, arg2: i32) -&gt; i32 {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Avoid comments within the signature itself.</p>
<p>If the function signature does not fit on one line, then break after the opening
parenthesis and before the closing parenthesis and put each argument on its own
block-indented line. For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(
    arg1: i32,
    arg2: i32,
) -&gt; i32 {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Note the trailing comma on the last argument.</p>
<h3 id="tuples-and-tuple-structs"><a class="header" href="#tuples-and-tuple-structs">Tuples and tuple structs</a></h3>
<p>Write the type list as you would a parameter list to a function.</p>
<p>Build a tuple or tuple struct as you would call a function.</p>
<h4 id="single-line"><a class="header" href="#single-line">Single-line</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar(Type1, Type2);

let x = Bar(11, 22);
let y = (11, 22, 33);
<span class="boring">}</span></code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>In the declaration, put each variant on its own line, block indented.</p>
<p>Format each variant accordingly as either a struct, tuple struct, or identifier,
which doesn't require special formatting (but without the <code>struct</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FooBar {
    First(u32),
    Second,
    Error {
        err: Box&lt;Error&gt;,
        line: u32,
    },
}
<span class="boring">}</span></code></pre></pre>
<p>If a struct variant is <a href="index.html#small-items"><em>small</em></a>, it may be formatted on
one line. In this case, do not use a trailing comma for the field list, but do
put spaces around each brace:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FooBar {
    Error { err: Box&lt;Error&gt;, line: u32 },
}
<span class="boring">}</span></code></pre></pre>
<p>In an enum with multiple struct variants, if any struct variant is written on
multiple lines, then the multi-line formatting should be used for all struct
variants. However, such a situation might be an indication that you should
factor out the fields of the variant into their own struct.</p>
<h3 id="structs-and-unions"><a class="header" href="#structs-and-unions">Structs and Unions</a></h3>
<p>Struct names follow on the same line as the <code>struct</code> keyword, with the opening
brace on the same line when it fits within the right margin. All struct fields
are indented once and end with a trailing comma. The closing brace is not
indented and appears on its own line.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: A,
    b: B,
}
<span class="boring">}</span></code></pre></pre>
<p>If and only if the type of a field does not fit within the right margin, it is
pulled down to its own line and indented again.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: A,
    long_name:
        LongType,
}
<span class="boring">}</span></code></pre></pre>
<p>Prefer using a unit struct (e.g., <code>struct Foo;</code>) to an empty struct (e.g.,
<code>struct Foo();</code> or <code>struct Foo {}</code>, these only exist to simplify code
generation), but if you must use an empty struct, keep it on one line with no
space between the braces: <code>struct Foo;</code> or <code>struct Foo {}</code>.</p>
<p>The same guidelines are used for untagged union declarations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union Foo {
    a: A,
    b: B,
    long_name:
        LongType,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h3>
<p>Put the whole struct on one line if possible. Types in the parentheses should be
separated by a comma and space with no trailing comma. No spaces around the
parentheses or semi-colon:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo(String, u8);
<span class="boring">}</span></code></pre></pre>
<p>Prefer unit structs to empty tuple structs (these only exist to simplify code
generation), e.g., <code>struct Foo;</code> rather than <code>struct Foo();</code>.</p>
<p>For more than a few fields, prefer a proper struct with named fields. Given
this, a tuple struct should always fit on one line. If it does not, block format
the fields with a field on each line and a trailing comma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo(
    String,
    u8,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<p>Trait items should be block-indented. If there are no items, the trait may be
formatted on a single line. Otherwise there should be line-breaks after the
opening brace and before the closing brace:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

pub trait Bar {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait has bounds, there should be a space after the colon but not before
and before and after each <code>+</code>, e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo: Debug + Bar {}
<span class="boring">}</span></code></pre></pre>
<p>Prefer not to line-break in the bounds if possible (consider using a <code>where</code>
clause). Prefer to break between bounds than to break any individual bound. If
you must break the bounds, put each bound (including the first) on its own
block-indented line, break before the <code>+</code> and put the opening brace on its own
line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IndexRanges:
    Index&lt;Range&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeTo&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeFrom&lt;usize&gt;, Output=Self&gt;
    + Index&lt;RangeFull, Output=Self&gt;
{
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="impls"><a class="header" href="#impls">Impls</a></h3>
<p>Impl items should be block indented. If there are no items, the impl may be
formatted on a single line. Otherwise there should be line-breaks after the
opening brace and before the closing brace:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Foo {}

impl Bar for Foo {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Avoid line-breaking in the signature if possible. If a line break is required in
a non-inherent impl, break immediately before <code>for</code>, block indent the concrete type
and put the opening brace on its own line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Bar
    for Foo
{
    ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="extern-crate"><a class="header" href="#extern-crate">Extern crate</a></h3>
<p><code>extern crate foo;</code></p>
<p>Use spaces around keywords, no spaces around the semi-colon.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo;
<span class="boring">}</span></code></pre></pre>
<p>Use spaces around keywords and before the opening brace, no spaces around the
semi-colon.</p>
<h3 id="macro_rules"><a class="header" href="#macro_rules">macro_rules!</a></h3>
<p>Use <code>{}</code> for the full definition of the macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
}
<span class="boring">}</span></code></pre></pre>
<h3 id="generics"><a class="header" href="#generics">Generics</a></h3>
<p>Prefer to put a generics clause on one line. Break other parts of an item
declaration rather than line-breaking a generics clause. If a generics clause is
large enough to require line-breaking, you should prefer to use a <code>where</code> clause
instead.</p>
<p>Do not put spaces before or after <code>&lt;</code> nor before <code>&gt;</code>. Only put a space after <code>&gt;</code>
if it is followed by a word or opening brace, not an opening parenthesis. There
should be a space after each comma and no trailing comma.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Display, U: Debug&gt;(x: Vec&lt;T&gt;, y: Vec&lt;U&gt;) ...

impl&lt;T: Display, U: Debug&gt; SomeType&lt;T, U&gt; { ...
<span class="boring">}</span></code></pre></pre>
<p>If the generics clause must be formatted across multiple lines, each parameter
should have its own block-indented line, there should be newlines after the
opening bracket and before the closing bracket, and the should be a trailing
comma.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;
    T: Display,
    U: Debug,
&gt;(x: Vec&lt;T&gt;, y: Vec&lt;U&gt;) ...
<span class="boring">}</span></code></pre></pre>
<p>If an associated type is bound in a generic type, then there should be spaces on
either side of the <code>=</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;T: Example&lt;Item = u32&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Prefer to use single-letter names for generic parameters.</p>
<h3 id="where-clauses"><a class="header" href="#where-clauses"><code>where</code> clauses</a></h3>
<p>These rules apply for <code>where</code> clauses on any item.</p>
<p>A <code>where</code> clause may immediately follow a closing bracket of any kind.
Otherwise, it must start a new line, with no indent. Each component of a <code>where</code>
clause must be on its own line and be block indented. There should be a trailing
comma, unless the clause is terminated with a semicolon. If the <code>where</code> clause
is followed by a block (or assignment), the block should be started on a new
line. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T, U&gt;(args)
where
    T: Bound,
    U: AnotherBound,
{
    body
}

fn foo&lt;T&gt;(
    args
) -&gt; ReturnType
where
    T: Bound,
{
    body
}

fn foo&lt;T, U&gt;(
    args,
) where
    T: Bound,
    U: AnotherBound,
{
    body
}

fn foo&lt;T, U&gt;(
    args
) -&gt; ReturnType
where
    T: Bound,
    U: AnotherBound;  // Note, no trailing comma.

// Note that where clauses on `type` aliases are not enforced and should not
// be used.
type Foo&lt;T&gt;
where
    T: Bound
= Bar&lt;T&gt;;
<span class="boring">}</span></code></pre></pre>
<p>If a <code>where</code> clause is very short, we recommend using an inline bound on the
type parameter.</p>
<p>If a component of a <code>where</code> clause is long, it may be broken before <code>+</code> and
further block indented. Each bound should go on its own line. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: ?Sized, Idx&gt; IndexRanges&lt;Idx&gt; for T
where
    T: Index&lt;Range&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeTo&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeFrom&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeInclusive&lt;Idx&gt;, Output = Self::Output&gt;
        + Index&lt;RangeToInclusive&lt;Idx&gt;, Output = Self::Output&gt; + Index&lt;RangeFull&gt;
<span class="boring">}</span></code></pre></pre>
<h4 id="option---where_single_line"><a class="header" href="#option---where_single_line">Option - <code>where_single_line</code></a></h4>
<p><code>where_single_line</code> is <code>false</code> by default. If <code>true</code>, then a where clause with
exactly one component may be formatted on a single line if the rest of the
item's signature is also kept on one line. In this case, there is no need for a
trailing comma and if followed by a block, no need for a newline before the
block. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// May be single-lined.
fn foo&lt;T&gt;(args) -&gt; ReturnType
where T: Bound {
    body
}

// Must be multi-lined.
fn foo&lt;T&gt;(
    args
) -&gt; ReturnType
where
    T: Bound,
{
    body
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h3>
<p>Type aliases should generally be kept on one line. If necessary to break the
line, do so after the <code>=</code>; the right-hand-side should be block indented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Foo = Bar&lt;T&gt;;

// If multi-line is required
type VeryLongType&lt;T, U: SomeBound&gt; =
    AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>Where possible avoid <code>where</code> clauses and keep type constraints inline. Where
that is not possible split the line before and after the <code>where</code> clause (and
split the <code>where</code> clause as normal), e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type VeryLongType&lt;T, U&gt;
where
    T: U::AnAssociatedType,
    U: SomeBound,
= AnEvenLongerType&lt;T, U, Foo&lt;T&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h3>
<p>Associated types should follow the guidelines above for type aliases. Where an
associated type has a bound, there should be a space after the colon but not
before:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Foo: Bar;
<span class="boring">}</span></code></pre></pre>
<h3 id="extern-items"><a class="header" href="#extern-items">extern items</a></h3>
<p>When writing extern items (such as <code>extern &quot;C&quot; fn</code>), always be explicit about
the ABI. For example, write <code>extern &quot;C&quot; fn foo ...</code>, not <code>extern fn foo ...</code>, or
<code>extern &quot;C&quot; { ... }</code>.</p>
<h3 id="imports-use-statements"><a class="header" href="#imports-use-statements">Imports (<code>use</code> statements)</a></h3>
<p>If an import can be formatted on one line, do so. There should be no spaces
around braces.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use a::b::c;
use a::b::d::*;
use a::b::{foo, bar, baz};
<span class="boring">}</span></code></pre></pre>
<h4 id="large-list-imports"><a class="header" href="#large-list-imports">Large list imports</a></h4>
<p>Prefer to use multiple imports rather than a multi-line import. However, tools
should not split imports by default (they may offer this as an option).</p>
<p>If an import does require multiple lines (either because a list of single names
does not fit within the max width, or because of the rules for nested imports
below), then break after the opening brace and before the closing brace, use a
trailing comma, and block indent the names.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prefer
foo::{long, list, of, imports};
foo::{more, imports};

// If necessary
foo::{
    long, list, of, imports, more,
    imports,  // Note trailing comma
};
<span class="boring">}</span></code></pre></pre>
<h4 id="ordering-of-imports"><a class="header" href="#ordering-of-imports">Ordering of imports</a></h4>
<p>A <em>group</em> of imports is a set of imports on the same or sequential lines. One or
more blank lines or other items (e.g., a function) separate groups of imports.</p>
<p>Within a group of imports, imports must be sorted ascii-betically. Groups of
imports must not be merged or re-ordered.</p>
<p>E.g., input:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use d;
use c;

use b;
use a;
<span class="boring">}</span></code></pre></pre>
<p>output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use c;
use d;

use a;
use b;
<span class="boring">}</span></code></pre></pre>
<p>Because of <code>macro_use</code>, attributes must also start a new group and prevent
re-ordering.</p>
<p>Note that tools which only have access to syntax (such as Rustfmt) cannot tell
which imports are from an external crate or the std lib, etc.</p>
<h4 id="ordering-list-import"><a class="header" href="#ordering-list-import">Ordering list import</a></h4>
<p>Names in a list import must be sorted ascii-betically, but with <code>self</code> and
<code>super</code> first, and groups and glob imports last. This applies recursively. For
example, <code>a::*</code> comes before <code>b::a</code> but <code>a::b</code> comes before <code>a::*</code>. E.g.,
<code>use foo::bar::{a, b::c, b::d, b::d::{x, y, z}, b::{self, r, s}};</code>.</p>
<h4 id="normalisation"><a class="header" href="#normalisation">Normalisation</a></h4>
<p>Tools must make the following normalisations:</p>
<ul>
<li><code>use a::self;</code> -&gt; <code>use a;</code></li>
<li><code>use a::{};</code> -&gt; (nothing)</li>
<li><code>use a::{b};</code> -&gt; <code>use a::b;</code></li>
</ul>
<p>And must apply these recursively.</p>
<p>Tools must not otherwise merge or un-merge import lists or adjust glob imports
(without an explicit option).</p>
<h4 id="nested-imports"><a class="header" href="#nested-imports">Nested imports</a></h4>
<p>If there are any nested imports in a list import, then use the multi-line form,
even if the import fits on one line. Each nested import must be on its own line,
but non-nested imports must be grouped on as few lines as possible.</p>
<p>For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use a::b::{
    x, y, z,
    u::{...},
    w::{...},
};
<span class="boring">}</span></code></pre></pre>
<h4 id="mergingun-merging-imports"><a class="header" href="#mergingun-merging-imports">Merging/un-merging imports</a></h4>
<p>An example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Un-merged
use a::b;
use a::c::d;

// Merged
use a::{b, c::d};
<span class="boring">}</span></code></pre></pre>
<p>Tools must not merge or un-merge imports by default. They may offer merging or
un-merging as an option.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="let-statements"><a class="header" href="#let-statements">Let statements</a></h3>
<p>There should be spaces after the <code>:</code> and on both sides of the <code>=</code> (if they are
present). No space before the semi-colon.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment.
let pattern: Type = expr;

let pattern;
let pattern: Type;
let pattern = expr;
<span class="boring">}</span></code></pre></pre>
<p>If possible the declaration should be formatted on a single line. If this is not
possible, then try splitting after the <code>=</code>, if the declaration can fit on two
lines. The expression should be block indented.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pattern: Type =
    expr;
<span class="boring">}</span></code></pre></pre>
<p>If the first line does not fit on a single line, then split after the colon,
using block indentation. If the type covers multiple lines, even after line-
breaking after the <code>:</code>, then the first line may be placed on the same line as
the <code>:</code>, subject to the <a href="https://github.com/rust-lang-nursery/fmt-rfcs/issues/61">combining rules</a> (WIP).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pattern:
    Type =
    expr;
<span class="boring">}</span></code></pre></pre>
<p>e.g,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; =
    Foo { f, g };

let (abcd,
    defg):
    Baz =
{ ... }
<span class="boring">}</span></code></pre></pre>
<p>If the expression covers multiple lines, if the first line of the expression
fits in the remaining space, it stays on the same line as the <code>=</code>, the rest of the
expression is not indented. If the first line does not fit, then it should start
on the next lines, and should be block indented. If the expression is a block
and the type or pattern cover multiple lines, then the opening brace should be
on a new line and not indented (this provides separation for the interior of the
block from the type), otherwise the opening brace follows the <code>=</code>.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Foo {
    f: abcd,
    g: qwer,
};

let foo =
    ALongName {
        f: abcd,
        g: qwer,
    };

let foo: Type = {
    an_expression();
    ...
};

let foo:
    ALongType =
{
    an_expression();
    ...
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; = Foo {
    f: blimblimblim,
    g: blamblamblam,
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo&lt;Bar&gt; = foo(
    blimblimblim,
    blamblamblam,
);
<span class="boring">}</span></code></pre></pre>
<h4 id="else-blocks-let-else-statements"><a class="header" href="#else-blocks-let-else-statements">else blocks (let-else statements)</a></h4>
<p>If a let statement contains an <code>else</code> component, also known as a let-else statement,
then the <code>else</code> component should be formatted according to the same rules as the <code>else</code> block
in <a href="./expressions.html#control-flow-expressions">control flow expressions (i.e. if-else, and if-let-else expressions)</a>.
Apply the same formatting rules to the components preceding
the <code>else</code> block (i.e. the <code>let pattern: Type = initializer_expr ...</code> portion)
as described <a href="statements.html#let-statements">above</a></p>
<p>Similarly to if-else expressions, if the initializer
expression is multi-lined, then the <code>else</code> keyword and opening brace of the block (i.e. <code>else {</code>)
should be put on the same line as the end of the initializer
expression with a preceding space if all the following are true:</p>
<ul>
<li>The initializer expression ends with one or more closing
parentheses, square brackets, and/or braces</li>
<li>There is nothing else on that line</li>
<li>That line is not indented beyond the indent of the first line containing the <code>let</code> keyword</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(x) = y.foo(
    &quot;abc&quot;,
    fairly_long_identifier,
    &quot;def&quot;,
    &quot;123456&quot;,
    &quot;string&quot;,
    &quot;cheese&quot;,
) else {
    bar()
}
<span class="boring">}</span></code></pre></pre>
<p>Otherwise, the <code>else</code> keyword and opening brace should be placed on the next line after the end of the initializer expression, and should not be indented (the <code>else</code> keyword should be aligned with the <code>let</code> keyword).</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let Some(x) = abcdef()
        .foo(
            &quot;abc&quot;,
            some_really_really_really_long_ident,
            &quot;ident&quot;,
            &quot;123456&quot;,
        )
        .bar()
        .baz()
        .qux(&quot;fffffffffffffffff&quot;)
    else {
        return
    };

    let Some(x) = some_really_really_really_really_really_really_really_really_really_long_name
    else {
        return;
    };

    let Some(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) =
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    else {
        return;
    };
}</code></pre></pre>
<h5 id="single-line-let-else-statements"><a class="header" href="#single-line-let-else-statements">Single line let-else statements</a></h5>
<p>The entire let-else statement may be formatted on a single line if all the following are true:</p>
<ul>
<li>the entire statement is <em>short</em></li>
<li>the <code>else</code> block contains a single-line expression and no statements</li>
<li>the <code>else</code> block contains no comments</li>
<li>the let statement components preceding the <code>else</code> block can be formatted on a single line</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Some(1) = opt else { return };

let Some(1) = opt else {
    return;
};

let Some(1) = opt else {
    // nope
    return
};
<span class="boring">}</span></code></pre></pre>
<p>Formatters may allow users to configure the value of the threshold
used to determine whether a let-else statement is <em>short</em>.</p>
<h3 id="macros-in-statement-position"><a class="header" href="#macros-in-statement-position">Macros in statement position</a></h3>
<p>A macro use in statement position should use parentheses or square brackets as
delimiters and should be terminated with a semi-colon. There should be no spaces
between the name, <code>!</code>, the delimiters, or the <code>;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A comment.
a_macro!(...);
<span class="boring">}</span></code></pre></pre>
<h3 id="expressions-in-statement-position"><a class="header" href="#expressions-in-statement-position">Expressions in statement position</a></h3>
<p>There should be no space between the expression and the semi-colon.</p>
<pre><code>&lt;expr&gt;;
</code></pre>
<p>All expressions in statement position should be terminated with a semi-colon,
unless they end with a block or are used as the value for a block.</p>
<p>E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    an_expression();
    expr_as_value()
}

return foo();

loop {
    break;
}
<span class="boring">}</span></code></pre></pre>
<p>Use a semi-colon where an expression has void type, even if it could be
propagated. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() { ... }

fn bar() {
    foo();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h2>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>A block expression should have a newline after the initial <code>{</code> and before the
terminal <code>}</code>. Any qualifier before the block (e.g., <code>unsafe</code>) should always be
on the same line as the opening brace, and separated with a single space. The
contents of the block should be block indented:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn block_as_stmt() {
    a_call();

    {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}

fn block_as_expr() {
    let foo = {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    };
}

fn unsafe_block_as_stmt() {
    a_call();

    unsafe {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If a block has an attribute, it should be on its own line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn block_as_stmt() {
    #[an_attribute]
    {
        #![an_inner_attribute]

        // a comment in a block
        the_value
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Avoid writing comments on the same line as the braces.</p>
<p>An empty block should be written as <code>{}</code>.</p>
<p>A block may be written on a single line if:</p>
<ul>
<li>it is either used in expression position (not statement position) or is an
unsafe block in statement position</li>
<li>contains a single-line expression and no statements</li>
<li>contains no comments</li>
</ul>
<p>A single line block should have spaces after the opening brace and before the
closing brace.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Single line
    let _ = { a_call() };
    let _ = unsafe { a_call() };

    // Not allowed on one line
    // Statement position.
    {
        a_call()
    }

    // Contains a statement
    let _ = {
        a_call();
    };
    unsafe {
        a_call();
    }

    // Contains a comment
    let _ = {
        // A comment
    };
    let _ = {
        // A comment
        a_call()
    };

    // Multiple lines
    let _ = {
        a_call();
        another_call()
    };
    let _ = {
        a_call(
            an_argument,
            another_arg,
        )
    };
}</code></pre></pre>
<h3 id="closures"><a class="header" href="#closures">Closures</a></h3>
<p>Don't put any extra spaces before the first <code>|</code> (unless the closure is prefixed
by <code>move</code>); put a space between the second <code>|</code> and the expression of the
closure. Between the <code>|</code>s, you should use function definition syntax, however,
elide types where possible.</p>
<p>Use closures without the enclosing <code>{}</code>, if possible. Add the <code>{}</code> when you have
a return type, when there are statements, there are comments in the body, or the
body expression spans multiple lines and is a control-flow expression. If using
braces, follow the rules above for blocks. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|arg1, arg2| expr

move |arg1: i32, arg2: i32| -&gt; i32 {
    expr1;
    expr2
}

|| Foo {
    field1,
    field2: 0,
}

|| {
    if true {
        blah
    } else {
        boo
    }
}

|x| unsafe {
    expr
}
<span class="boring">}</span></code></pre></pre>
<h3 id="struct-literals"><a class="header" href="#struct-literals">Struct literals</a></h3>
<p>If a struct literal is <em>small</em> it may be formatted on a single line. If not,
each field should be on it's own, block-indented line. There should be a
trailing comma in the multi-line form only. There should be a space after the
colon only.</p>
<p>There should be a space before the opening brace. In the single-line form there
should be spaces after the opening brace and before the closing brace.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo { field1, field2: 0 }
let f = Foo {
    field1,
    field2: an_expr,
};
<span class="boring">}</span></code></pre></pre>
<p>Functional record update syntax is treated like a field, but it must never have
a trailing comma. There should be no space after <code>..</code>.</p>
<p>let f = Foo {
field1,
..an_expr
};</p>
<h3 id="tuple-literals"><a class="header" href="#tuple-literals">Tuple literals</a></h3>
<p>Use a single-line form where possible. There should not be spaces around the
parentheses. Where a single-line form is not possible, each element of the tuple
should be on its own block-indented line and there should be a trailing comma.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(a, b, c)

let x = (
    a_long_expr,
    another_very_long_expr,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="tuple-struct-literals"><a class="header" href="#tuple-struct-literals">Tuple struct literals</a></h3>
<p>There should be no space between the identifier and the opening parenthesis.
Otherwise, follow the rules for tuple literals, e.g., <code>Foo(a, b)</code>.</p>
<h3 id="enum-literals"><a class="header" href="#enum-literals">Enum literals</a></h3>
<p>Follow the formatting rules for the various struct literals. Prefer using the
name of the enum as a qualifying name, unless the enum is in the prelude. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo::Bar(a, b)
Foo::Baz {
    field1,
    field2: 1001,
}
Ok(an_expr)
<span class="boring">}</span></code></pre></pre>
<h3 id="array-literals"><a class="header" href="#array-literals">Array literals</a></h3>
<p>For simple array literals, avoid line breaking, no spaces around square
brackets, contents of the array should be separated by commas and spaces. If
using the repeating initialiser, there should be a space after the semicolon
only. Apply the same rules if using the <code>vec!</code> or similar macros (always use
square brackets here). Examples:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    [1, 2, 3];
    vec![a, b, c, d];
    let a = [42; 10];
}</code></pre></pre>
<p>If a line must be broken, prefer breaking only after the <code>;</code>, if possible.
Otherwise, follow the rules below for function calls. In any case, the contents
of the initialiser should be block indented and there should be line breaks
after the opening bracket and before the closing bracket:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    [
        a_long_expression();
        1234567890
    ]
    let x = [
        an_expression,
        another_expression,
        a_third_expression,
    ];
}</code></pre></pre>
<h3 id="array-accesses-indexing-and-slicing"><a class="header" href="#array-accesses-indexing-and-slicing">Array accesses, indexing, and slicing.</a></h3>
<p>No spaces around the square brackets, avoid breaking lines if possible, never
break a line between the target expression and the opening bracket. If the
indexing expression covers multiple lines, then it should be block indented and
there should be newlines after the opening brackets and before the closing
bracket. However, this should be avoided where possible.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    foo[42];
    &amp;foo[..10];
    bar[0..100];
    foo[4 + 5 / bar];
    a_long_target[
        a_long_indexing_expression
    ];
}</code></pre></pre>
<h3 id="unary-operations"><a class="header" href="#unary-operations">Unary operations</a></h3>
<p>Do not include a space between a unary op and its operand (i.e., <code>!x</code>, not
<code>! x</code>). However, there must be a space after <code>&amp;mut</code>. Avoid line-breaking
between a unary operator and its operand.</p>
<h3 id="binary-operations"><a class="header" href="#binary-operations">Binary operations</a></h3>
<p>Do include spaces around binary ops (i.e., <code>x + 1</code>, not <code>x+1</code>) (including <code>=</code>
and other assignment operators such as <code>+=</code> or <code>*=</code>).</p>
<p>For comparison operators, because for <code>T op U</code>, <code>&amp;T op &amp;U</code> is also implemented:
if you have <code>t: &amp;T</code>, and <code>u: U</code>, prefer <code>*t op u</code> to <code>t op &amp;u</code>. In general,
within expressions, prefer dereferencing to taking references.</p>
<p>Use parentheses liberally, do not necessarily elide them due to precedence.
Tools should not automatically insert or remove parentheses. Do not use spaces
to indicate precedence.</p>
<p>If line-breaking, put the operator on a new line and block indent. Put each
sub-expression on its own line. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo_bar
    + bar
    + baz
    + qux
    + whatever
<span class="boring">}</span></code></pre></pre>
<p>Prefer line-breaking at an assignment operator (either <code>=</code> or <code>+=</code>, etc.) rather
than at other binary operators.</p>
<h3 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h3>
<p>Do not include extraneous parentheses for <code>if</code> and <code>while</code> expressions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if true {
}
<span class="boring">}</span></code></pre></pre>
<p>is better than</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (true) {
}
<span class="boring">}</span></code></pre></pre>
<p>Do include extraneous parentheses if it makes an arithmetic or logic expression
easier to understand (<code>(x * 15) + (y * 20)</code> is fine)</p>
<h3 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h3>
<p>Do not put a space between the function name, and the opening parenthesis.</p>
<p>Do not put a space between an argument, and the comma which follows.</p>
<p>Do put a space between an argument, and the comma which precedes it.</p>
<p>Prefer not to break a line in the callee expression.</p>
<h4 id="single-line-calls"><a class="header" href="#single-line-calls">Single-line calls</a></h4>
<p>Do not put a space between the function name and open paren, between the open
paren and the first argument, or between the last argument and the close paren.</p>
<p>Do not put a comma after the last argument.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(x, y, z)
<span class="boring">}</span></code></pre></pre>
<h4 id="multi-line-calls"><a class="header" href="#multi-line-calls">Multi-line calls</a></h4>
<p>If the function call is not <em>small</em>, it would otherwise over-run the max width,
or any argument or the callee is multi-line, then the call should be formatted
across multiple lines. In this case, each argument should be on it's own block-
indented line, there should be a newline after the opening parenthesis and
before the closing parenthesis, and there should be a trailing comma. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a_function_call(
    arg1,
    a_nested_call(a, b),
)
<span class="boring">}</span></code></pre></pre>
<h3 id="method-calls"><a class="header" href="#method-calls">Method calls</a></h3>
<p>Follow the function rules for calling.</p>
<p>Do not put any spaces around the <code>.</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.foo().bar().baz(x, y, z);
<span class="boring">}</span></code></pre></pre>
<h3 id="macro-uses"><a class="header" href="#macro-uses">Macro uses</a></h3>
<p>Macros which can be parsed like other constructs should be formatted like those
constructs. For example, a macro use <code>foo!(a, b, c)</code> can be parsed like a
function call (ignoring the <code>!</code>), therefore it should be formatted following the
rules for function calls.</p>
<h4 id="special-case-macros"><a class="header" href="#special-case-macros">Special case macros</a></h4>
<p>Macros which take a format string and where all other arguments are <em>small</em> may
be formatted with arguments before and after the format string on a single line
and the format string on its own line, rather than putting each argument on its
own line. For example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(
    &quot;Hello {} and {}&quot;,
    name1, name2,
);

assert_eq!(
    x, y,
    &quot;x and y were not equal, see {}&quot;,
    reason,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="casts-as"><a class="header" href="#casts-as">Casts (<code>as</code>)</a></h3>
<p>Put spaces before and after <code>as</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cstr = &quot;Hi\0&quot; as *const str as *const [u8] as *const std::os::raw::c_char;
<span class="boring">}</span></code></pre></pre>
<h3 id="chains-of-fields-and-method-calls"><a class="header" href="#chains-of-fields-and-method-calls">Chains of fields and method calls</a></h3>
<p>A chain is a sequence of field accesses and/or method calls. A chain may also
include the try operator ('?'). E.g., <code>a.b.c().d</code> or <code>foo?.bar().baz?</code>.</p>
<p>Prefer formatting on one line if possible, and the chain is <em>small</em>. If
formatting on multiple lines, each field access or method call in the chain
should be on its own line with the line-break before the <code>.</code> and after any <code>?</code>.
Each line should be block-indented. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = bar
    .baz?
    .qux();
<span class="boring">}</span></code></pre></pre>
<p>If the length of the last line of the first element plus its indentation is
less than or equal to the indentation of the second line (and there is space),
then combine the first and second lines, e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x.baz?
    .qux()

let foo = x
    .baz?
    .qux();

foo(
    expr1,
    expr2,
).baz?
    .qux();
<span class="boring">}</span></code></pre></pre>
<h4 id="multi-line-elements"><a class="header" href="#multi-line-elements">Multi-line elements</a></h4>
<p>If any element in a chain is formatted across multiple lines, then that element
and any later elements must be on their own line. Earlier elements may be kept
on a single line. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.b.c()?.d
    .foo(
        an_expr,
        another_expr,
    )
    .bar
    .baz
<span class="boring">}</span></code></pre></pre>
<p>Note there is block indent due to the chain and the function call in the above
example.</p>
<p>Prefer formatting the whole chain in multi-line style and each element on one
line, rather than putting some elements on multiple lines and some on a single
line, e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Better
self.pre_comment
    .as_ref()
    .map_or(false, |comment| comment.starts_with(&quot;//&quot;))

// Worse
self.pre_comment.as_ref().map_or(
    false,
    |comment| comment.starts_with(&quot;//&quot;),
)
<span class="boring">}</span></code></pre></pre>
<h3 id="control-flow-expressions"><a class="header" href="#control-flow-expressions">Control flow expressions</a></h3>
<p>This section covers <code>if</code>, <code>if let</code>, <code>loop</code>, <code>while</code>, <code>while let</code>, and <code>for</code>
expressions.</p>
<p>The keyword, any initial clauses, and the opening brace of the block should be
on a single line. The usual rules for <a href="expressions.html#blocks">block formatting</a> should be
applied to the block.</p>
<p>If there is an <code>else</code> component, then the closing brace, <code>else</code>, any following
clause, and the opening brace should all be on the same line. There should be a
single space before and after the <code>else</code> keyword. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ... {
    ...
} else {
    ...
}

if let ... {
    ...
} else if ... {
    ...
} else {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>If the control line needs to be broken, then prefer to break before the <code>=</code> in
<code>* let</code> expressions and before <code>in</code> in a <code>for</code> expression; the following line
should be block indented. If the control line is broken for any reason, then the
opening brace should be on its own line and not indented. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(foo)
    = a_long_expression
{
    ...
}

for foo
    in a_long_expression
{
    ...
}

if a_long_expression
    &amp;&amp; another_long_expression
    || a_third_long_expression
{
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Where the initial clause is multi-lined and ends with one or more closing
parentheses, square brackets, or braces, and there is nothing else on that line,
and that line is not indented beyond the indent on the first line of the control
flow expression, then the opening brace of the block should be put on the same
line with a preceding space. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !self.config.file_lines().intersects(
    &amp;self.codemap.lookup_line_range(
        stmt.span,
    ),
) {  // Opening brace on same line as initial clause.
    ...
}
<span class="boring">}</span></code></pre></pre>
<h4 id="single-line-if-else"><a class="header" href="#single-line-if-else">Single line <code>if else</code></a></h4>
<p>Formatters may place an <code>if else</code> or <code>if let else</code> on a single line if it occurs
in expression context (i.e., is not a standalone statement), it contains a
single <code>else</code> clause, and is <em>small</em>. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = if x { 0 } else { 1 };

// Examples that must be multi-line.
let y = if something_very_long {
    not_small
} else {
    also_not_small
};

if x {
    0
} else {
    1
}
<span class="boring">}</span></code></pre></pre>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<p>Prefer not to line-break inside the discriminant expression. There must always
be a line break after the opening brace and before the closing brace. The match
arms must be block indented once:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // arms
}

let x = match foo.bar.baz() {
    // arms
};
<span class="boring">}</span></code></pre></pre>
<p>Use a trailing comma for a match arm if and only if not using a block.</p>
<p>Never start a match arm pattern with <code>|</code>, e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // Don't do this.
    | foo =&gt; bar,
    // Or this.
    | a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern =&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Prefer</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    foo =&gt; bar,
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern =&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Avoid splitting the left-hand side (before the <code>=&gt;</code>) of a match arm where
possible. If the right-hand side of the match arm is kept on the same line,
never use a block (unless the block is empty).</p>
<p>If the right-hand side consists of multiple statements or has line comments or
the start of the line cannot be fit on the same line as the left-hand side, use
a block.</p>
<p>The body of a block arm should be block indented once.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    foo =&gt; bar,
    a_very_long_pattern | another_pattern if an_expression() =&gt; {
        no_room_for_this_expression()
    }
    foo =&gt; {
        // A comment.
        an_expression()
    }
    foo =&gt; {
        let a = statement();
        an_expression()
    }
    bar =&gt; {}
    // Trailing comma on last item.
    foo =&gt; bar,
}
<span class="boring">}</span></code></pre></pre>
<p>If the body is a single expression with no line comments and not a control flow
expression, then it may be started on the same line as the right-hand side. If
not, then it must be in a block. Example,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match foo {
    // A combinable expression.
    foo =&gt; a_function_call(another_call(
        argument1,
        argument2,
    )),
    // A non-combinable expression
    bar =&gt; {
        a_function_call(
            another_call(
                argument1,
                argument2,
            ),
            another_argument,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="line-breaking"><a class="header" href="#line-breaking">Line-breaking</a></h4>
<p>Where it is possible to use a block form on the right-hand side and avoid
breaking the left-hand side, do that. E.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Assuming the following line does done fit in the max width
    a_very_long_pattern | another_pattern =&gt; ALongStructName {
        ...
    },
    // Prefer this
    a_very_long_pattern | another_pattern =&gt; {
        ALongStructName {
            ...
        }
    }
    // To splitting the pattern.
<span class="boring">}</span></code></pre></pre>
<p>Never break after <code>=&gt;</code> without using the block form of the body.</p>
<p>If the left-hand side must be split and there is an <code>if</code> clause, break before
the <code>if</code> and block indent. In this case, always use a block body and start the
body on a new line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    a_very_long_pattern | another_pattern
        if expr =&gt;
    {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>If required to break the pattern, put each clause of the pattern on its own
line with no additional indent, breaking before the <code>|</code>. If there is an <code>if</code>
clause, then you must use the above form:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern =&gt; {
        ...
    }
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern
        if expr =&gt;
    {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>If the pattern is multi-line, and the last line is less wide than the indent, do
not put the <code>if</code> clause on a newline. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Token::Dimension {
         value,
         ref unit,
         ..
    } if num_context.is_ok(context.parsing_mode, value) =&gt; {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>If every clause in a pattern is <em>small</em>, but does not fit on one line, then the
pattern may be formatted across multiple lines with as many clauses per line as
possible. Again break before a <code>|</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    foo | bar | baz
    | qux =&gt; {
        ...
    }
<span class="boring">}</span></code></pre></pre>
<p>We define a pattern clause to be <em>small</em> if it matches the following grammar:</p>
<pre><code>[small, ntp]:
    - single token
    - `&amp;[single-line, ntp]`

[small]:
    - `[small, ntp]`
    - unary tuple constructor `([small, ntp])`
    - `&amp;[small]`
</code></pre>
<p>E.g., <code>&amp;&amp;Some(foo)</code> matches, <code>Foo(4, Bar)</code> does not.</p>
<h3 id="combinable-expressions"><a class="header" href="#combinable-expressions">Combinable expressions</a></h3>
<p>Where a function call has a single argument, and that argument is formatted
across multiple-lines, the outer call may be formatted as if it were a single-
line call. The same combining behaviour may be applied to any similar
expressions which have multi-line, block-indented lists of sub-expressions
delimited by parentheses (e.g., macros or tuple struct literals). E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(bar(
    an_expr,
    another_expr,
))

let x = foo(Bar {
    field: whatever,
});

foo(|param| {
    action();
    foo(param)
})
<span class="boring">}</span></code></pre></pre>
<p>Such behaviour should extend recursively, however, tools may choose to limit the
depth of nesting.</p>
<p>Only where the multi-line sub-expression is a closure with an explicit block,
this combining behaviour may be used where there are other arguments, as long as
all the arguments and the first line of the closure fit on the first line, the
closure is the last argument, and there is only one closure argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo(first_arg, x, |param| {
    action();
    foo(param)
})
<span class="boring">}</span></code></pre></pre>
<h3 id="ranges"><a class="header" href="#ranges">Ranges</a></h3>
<p>Do not put spaces in ranges, e.g., <code>0..10</code>, <code>x..=y</code>, <code>..x.len()</code>, <code>foo..</code>.</p>
<p>When writing a range with both upper and lower bounds, if the line must be
broken, break before the range operator and block indent the second line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a_long_expression
    ..another_long_expression
<span class="boring">}</span></code></pre></pre>
<p>For the sake of indicating precedence, we recommend that if either bound is a
compound expression, then use parentheses around it, e.g., <code>..(x + 1)</code>,
<code>(x.f)..(x.f.len())</code>, or <code>0..(x - 10)</code>.</p>
<h3 id="hexadecimal-literals"><a class="header" href="#hexadecimal-literals">Hexadecimal literals</a></h3>
<p>Hexadecimal literals may use upper- or lower-case letters, but they must not be
mixed within the same literal. Projects should use the same case for all
literals, but we do not make a recommendation for either lower- or upper-case.
Tools should have an option to convert mixed case literals to upper-case, and
may have an option to convert all literals to either lower- or upper-case.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>Patterns should be formatted like their corresponding expressions. See the
section on <code>match</code> for additional formatting for patterns in match arms.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="types-and-bounds"><a class="header" href="#types-and-bounds">Types and Bounds</a></h2>
<h3 id="single-line-formatting"><a class="header" href="#single-line-formatting">Single line formatting</a></h3>
<ul>
<li><code>[T]</code> no spaces</li>
<li><code>[T; expr]</code>, e.g., <code>[u32; 42]</code>, <code>[Vec&lt;Foo&gt;; 10 * 2 + foo()]</code> (space after colon, no spaces around square brackets)</li>
<li><code>*const T</code>, <code>*mut T</code> (no space after <code>*</code>, space before type)</li>
<li><code>&amp;'a T</code>, <code>&amp;T</code>, <code>&amp;'a mut T</code>, <code>&amp;mut T</code> (no space after <code>&amp;</code>, single spaces separating other words)</li>
<li><code>unsafe extern &quot;C&quot; fn&lt;'a, 'b, 'c&gt;(T, U, V) -&gt; W</code> or <code>fn()</code> (single spaces around keywords and sigils, and after commas, no trailing commas, no spaces around brackets)</li>
<li><code>!</code> should be treated like any other type name, <code>Name</code></li>
<li><code>(A, B, C, D)</code> (spaces after commas, no spaces around parens, no trailing comma unless it is a one-tuple)</li>
<li><code>&lt;Baz&lt;T&gt; as SomeTrait&gt;::Foo::Bar</code> or <code>Foo::Bar</code> or <code>::Foo::Bar</code> (no spaces around <code>::</code> or angle brackets, single spaces around <code>as</code>)</li>
<li><code>Foo::Bar&lt;T, U, V&gt;</code> (spaces after commas, no trailing comma, no spaces around angle brackets)</li>
<li><code>T + T + T</code> (single spaces between types, and <code>+</code>).</li>
<li><code>impl T + T + T</code> (single spaces between keyword, types, and <code>+</code>).</li>
</ul>
<p>Parentheses used in types should not be surrounded by whitespace, e.g., <code>(Foo)</code></p>
<h3 id="line-breaks"><a class="header" href="#line-breaks">Line breaks</a></h3>
<p>Avoid breaking lines in types where possible. Prefer breaking at outermost scope, e.g., prefer</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo&lt;
    Bar,
    Baz&lt;Type1, Type2&gt;,
&gt;
<span class="boring">}</span></code></pre></pre>
<p>to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Foo&lt;Bar, Baz&lt;
    Type1,
    Type2,
&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p><code>[T; expr]</code> may be broken after the <code>;</code> if necessary.</p>
<p>Function types may be broken following the rules for function declarations.</p>
<p>Generic types may be broken following the rules for generics.</p>
<p>Types with <code>+</code> may be broken after any <code>+</code> using block indent and breaking before the <code>+</code>. When breaking such a type, all <code>+</code>s should be line broken, e.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Clone
    + Copy
    + Debug

Box&lt;
    Clone
    + Copy
    + Debug
&gt;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-style-advice"><a class="header" href="#other-style-advice">Other style advice</a></h1>
<h2 id="expressions-2"><a class="header" href="#expressions-2">Expressions</a></h2>
<p>Prefer to use Rust's expression oriented nature where possible;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// use
let x = if y { 1 } else { 0 };
// not
let x;
if y {
    x = 1;
} else {
    x = 0;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<ul>
<li>Types shall be <code>UpperCamelCase</code>,</li>
<li>Enum variants shall be <code>UpperCamelCase</code>,</li>
<li>Struct fields shall be <code>snake_case</code>,</li>
<li>Function and method names shall be <code>snake_case</code>,</li>
<li>Local variables shall be <code>snake_case</code>,</li>
<li>Macro names shall be <code>snake_case</code>,</li>
<li>Constants (<code>const</code>s and immutable <code>static</code>s) shall be <code>SCREAMING_SNAKE_CASE</code>.</li>
<li>When a name is forbidden because it is a reserved word (e.g., <code>crate</code>), use a
trailing underscore to make the name legal (e.g., <code>crate_</code>), or use raw
identifiers if possible.</li>
</ul>
<h3 id="modules-1"><a class="header" href="#modules-1">Modules</a></h3>
<p>Avoid <code>#[path]</code> annotations where possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargotoml-conventions-1"><a class="header" href="#cargotoml-conventions-1">Cargo.toml conventions</a></h1>
<h2 id="formatting-conventions-1"><a class="header" href="#formatting-conventions-1">Formatting conventions</a></h2>
<p>Use the same line width and indentation as Rust code.</p>
<p>Put a blank line between the last key-value pair in a section and the header of
the next section. Do not place a blank line between section headers and the
key-value pairs in that section, or between key-value pairs in a section.</p>
<p>Sort key names alphabetically within each section, with the exception of the
<code>[package]</code> section. Put the <code>[package]</code> section at the top of the file; put
the <code>name</code> and <code>version</code> keys in that order at the top of that section,
followed by the remaining keys other than <code>description</code> in alphabetical order,
followed by the <code>description</code> at the end of that section.</p>
<p>Don't use quotes around any standard key names; use bare keys. Only use quoted
keys for non-standard keys whose names require them, and avoid introducing such
key names when possible.  See the <a href="https://toml.io/en/v1.0.0#keys">TOML
specification</a> for details.</p>
<p>Put a single space both before and after the <code>=</code> between a key and value. Do
not indent any key names; start all key names at the start of a line.</p>
<p>Use multi-line strings (rather than newline escape sequences) for any string
values that include multiple lines, such as the crate description.</p>
<p>For array values, such as a list of authors, put the entire list on the same
line as the key, if it fits. Otherwise, use block indentation: put a newline
after the opening square bracket, indent each item by one indentation level,
put a comma after each item (including the last), and put the closing square
bracket at the start of a line by itself after the last item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>authors = [
    &quot;A Uthor &lt;a.uthor@example.org&gt;&quot;,
    &quot;Another Author &lt;author@example.net&gt;&quot;,
]
<span class="boring">}</span></code></pre></pre>
<p>For table values, such as a crate dependency with a path, write the entire
table using curly braces and commas on the same line as the key if it fits. If
the entire table does not fit on the same line as the key, separate it out into
a separate section with key-value pairs:</p>
<pre><code class="language-toml">[dependencies]
crate1 = { path = &quot;crate1&quot;, version = &quot;1.2.3&quot; }

[dependencies.extremely_long_crate_name_goes_here]
path = &quot;extremely_long_path_name_goes_right_here&quot;
version = &quot;4.5.6&quot;
</code></pre>
<h2 id="metadata-conventions"><a class="header" href="#metadata-conventions">Metadata conventions</a></h2>
<p>The authors list should consist of strings that each contain an author name
followed by an email address in angle brackets: <code>Full Name &lt;email@address&gt;</code>.
It should not contain bare email addresses, or names without email addresses.
(The authors list may also include a mailing list address without an associated
name.)</p>
<p>The license field must contain a valid <a href="https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">SPDX
expression</a>,
using valid <a href="https://spdx.org/licenses/">SPDX license names</a>. (As an exception,
by widespread convention, the license field may use <code>/</code> in place of <code>OR</code>; for
example, <code>MIT/Apache-2.0</code>.)</p>
<p>The homepage field, if present, must consist of a single URL, including the
scheme (e.g. <code>https://example.org/</code>, not just <code>example.org</code>.)</p>
<p>Within the description field, wrap text at 80 columns. Don't start the
description field with the name of the crate (e.g. &quot;cratename is a ...&quot;); just
describe the crate itself. If providing a multi-sentence description, the first
sentence should go on a line by itself and summarize the crate, like the
subject of an email or commit message; subsequent sentences can then describe
the crate in more detail.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guiding-principles-and-rationale"><a class="header" href="#guiding-principles-and-rationale">Guiding principles and rationale</a></h1>
<p>When deciding on style guidelines, the style team tried to be guided by the
following principles (in rough priority order):</p>
<ul>
<li>
<p>readability</p>
<ul>
<li>scan-ability</li>
<li>avoiding misleading formatting</li>
<li>accessibility - readable and editable by users using the widest
variety of hardware, including non-visual accessibility interfaces</li>
<li>readability of code in contexts without syntax highlighting or IDE
assistance, such as rustc error messages, diffs, grep, and other
plain-text contexts</li>
</ul>
</li>
<li>
<p>aesthetics</p>
<ul>
<li>sense of 'beauty'</li>
<li>consistent with other languages/tools</li>
</ul>
</li>
<li>
<p>specifics</p>
<ul>
<li>compatibility with version control practices - preserving diffs,
merge-friendliness, etc.</li>
<li>preventing right-ward drift</li>
<li>minimising vertical space</li>
</ul>
</li>
<li>
<p>application</p>
<ul>
<li>ease of manual application</li>
<li>ease of implementation (in Rustfmt, and in other tools/editors/code generators)</li>
<li>internal consistency</li>
<li>simplicity of formatting rules</li>
</ul>
</li>
</ul>
<h2 id="overarching-guidelines"><a class="header" href="#overarching-guidelines">Overarching guidelines</a></h2>
<p>Prefer block indent over visual indent. E.g.,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Block indent
a_function_call(
    foo,
    bar,
);

// Visual indent
a_function_call(foo,
                bar);
<span class="boring">}</span></code></pre></pre>
<p>This makes for smaller diffs (e.g., if <code>a_function_call</code> is renamed in the above
example) and less rightward drift.</p>
<p>Lists should have a trailing comma when followed by a newline, see the block
indent example above. This choice makes moving code (e.g., by copy and paste)
easier and makes smaller diffs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
