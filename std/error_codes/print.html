<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error codes index</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Book listing all Rust error codes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="error-index.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="error-index.html">Rust error codes index</a></li><li class="chapter-item expanded affix "><a href="E0001.html">E0001</a></li><li class="chapter-item expanded affix "><a href="E0002.html">E0002</a></li><li class="chapter-item expanded affix "><a href="E0004.html">E0004</a></li><li class="chapter-item expanded affix "><a href="E0005.html">E0005</a></li><li class="chapter-item expanded affix "><a href="E0007.html">E0007</a></li><li class="chapter-item expanded affix "><a href="E0009.html">E0009</a></li><li class="chapter-item expanded affix "><a href="E0010.html">E0010</a></li><li class="chapter-item expanded affix "><a href="E0013.html">E0013</a></li><li class="chapter-item expanded affix "><a href="E0014.html">E0014</a></li><li class="chapter-item expanded affix "><a href="E0015.html">E0015</a></li><li class="chapter-item expanded affix "><a href="E0023.html">E0023</a></li><li class="chapter-item expanded affix "><a href="E0025.html">E0025</a></li><li class="chapter-item expanded affix "><a href="E0026.html">E0026</a></li><li class="chapter-item expanded affix "><a href="E0027.html">E0027</a></li><li class="chapter-item expanded affix "><a href="E0029.html">E0029</a></li><li class="chapter-item expanded affix "><a href="E0030.html">E0030</a></li><li class="chapter-item expanded affix "><a href="E0033.html">E0033</a></li><li class="chapter-item expanded affix "><a href="E0034.html">E0034</a></li><li class="chapter-item expanded affix "><a href="E0038.html">E0038</a></li><li class="chapter-item expanded affix "><a href="E0040.html">E0040</a></li><li class="chapter-item expanded affix "><a href="E0044.html">E0044</a></li><li class="chapter-item expanded affix "><a href="E0045.html">E0045</a></li><li class="chapter-item expanded affix "><a href="E0046.html">E0046</a></li><li class="chapter-item expanded affix "><a href="E0049.html">E0049</a></li><li class="chapter-item expanded affix "><a href="E0050.html">E0050</a></li><li class="chapter-item expanded affix "><a href="E0053.html">E0053</a></li><li class="chapter-item expanded affix "><a href="E0054.html">E0054</a></li><li class="chapter-item expanded affix "><a href="E0055.html">E0055</a></li><li class="chapter-item expanded affix "><a href="E0057.html">E0057</a></li><li class="chapter-item expanded affix "><a href="E0059.html">E0059</a></li><li class="chapter-item expanded affix "><a href="E0060.html">E0060</a></li><li class="chapter-item expanded affix "><a href="E0061.html">E0061</a></li><li class="chapter-item expanded affix "><a href="E0062.html">E0062</a></li><li class="chapter-item expanded affix "><a href="E0063.html">E0063</a></li><li class="chapter-item expanded affix "><a href="E0067.html">E0067</a></li><li class="chapter-item expanded affix "><a href="E0069.html">E0069</a></li><li class="chapter-item expanded affix "><a href="E0070.html">E0070</a></li><li class="chapter-item expanded affix "><a href="E0071.html">E0071</a></li><li class="chapter-item expanded affix "><a href="E0072.html">E0072</a></li><li class="chapter-item expanded affix "><a href="E0073.html">E0073</a></li><li class="chapter-item expanded affix "><a href="E0074.html">E0074</a></li><li class="chapter-item expanded affix "><a href="E0075.html">E0075</a></li><li class="chapter-item expanded affix "><a href="E0076.html">E0076</a></li><li class="chapter-item expanded affix "><a href="E0077.html">E0077</a></li><li class="chapter-item expanded affix "><a href="E0080.html">E0080</a></li><li class="chapter-item expanded affix "><a href="E0081.html">E0081</a></li><li class="chapter-item expanded affix "><a href="E0084.html">E0084</a></li><li class="chapter-item expanded affix "><a href="E0087.html">E0087</a></li><li class="chapter-item expanded affix "><a href="E0088.html">E0088</a></li><li class="chapter-item expanded affix "><a href="E0089.html">E0089</a></li><li class="chapter-item expanded affix "><a href="E0090.html">E0090</a></li><li class="chapter-item expanded affix "><a href="E0091.html">E0091</a></li><li class="chapter-item expanded affix "><a href="E0092.html">E0092</a></li><li class="chapter-item expanded affix "><a href="E0093.html">E0093</a></li><li class="chapter-item expanded affix "><a href="E0094.html">E0094</a></li><li class="chapter-item expanded affix "><a href="E0106.html">E0106</a></li><li class="chapter-item expanded affix "><a href="E0107.html">E0107</a></li><li class="chapter-item expanded affix "><a href="E0109.html">E0109</a></li><li class="chapter-item expanded affix "><a href="E0110.html">E0110</a></li><li class="chapter-item expanded affix "><a href="E0116.html">E0116</a></li><li class="chapter-item expanded affix "><a href="E0117.html">E0117</a></li><li class="chapter-item expanded affix "><a href="E0118.html">E0118</a></li><li class="chapter-item expanded affix "><a href="E0119.html">E0119</a></li><li class="chapter-item expanded affix "><a href="E0120.html">E0120</a></li><li class="chapter-item expanded affix "><a href="E0121.html">E0121</a></li><li class="chapter-item expanded affix "><a href="E0124.html">E0124</a></li><li class="chapter-item expanded affix "><a href="E0128.html">E0128</a></li><li class="chapter-item expanded affix "><a href="E0130.html">E0130</a></li><li class="chapter-item expanded affix "><a href="E0131.html">E0131</a></li><li class="chapter-item expanded affix "><a href="E0132.html">E0132</a></li><li class="chapter-item expanded affix "><a href="E0133.html">E0133</a></li><li class="chapter-item expanded affix "><a href="E0136.html">E0136</a></li><li class="chapter-item expanded affix "><a href="E0137.html">E0137</a></li><li class="chapter-item expanded affix "><a href="E0138.html">E0138</a></li><li class="chapter-item expanded affix "><a href="E0139.html">E0139</a></li><li class="chapter-item expanded affix "><a href="E0152.html">E0152</a></li><li class="chapter-item expanded affix "><a href="E0154.html">E0154</a></li><li class="chapter-item expanded affix "><a href="E0158.html">E0158</a></li><li class="chapter-item expanded affix "><a href="E0161.html">E0161</a></li><li class="chapter-item expanded affix "><a href="E0162.html">E0162</a></li><li class="chapter-item expanded affix "><a href="E0164.html">E0164</a></li><li class="chapter-item expanded affix "><a href="E0165.html">E0165</a></li><li class="chapter-item expanded affix "><a href="E0170.html">E0170</a></li><li class="chapter-item expanded affix "><a href="E0178.html">E0178</a></li><li class="chapter-item expanded affix "><a href="E0183.html">E0183</a></li><li class="chapter-item expanded affix "><a href="E0184.html">E0184</a></li><li class="chapter-item expanded affix "><a href="E0185.html">E0185</a></li><li class="chapter-item expanded affix "><a href="E0186.html">E0186</a></li><li class="chapter-item expanded affix "><a href="E0191.html">E0191</a></li><li class="chapter-item expanded affix "><a href="E0192.html">E0192</a></li><li class="chapter-item expanded affix "><a href="E0193.html">E0193</a></li><li class="chapter-item expanded affix "><a href="E0195.html">E0195</a></li><li class="chapter-item expanded affix "><a href="E0197.html">E0197</a></li><li class="chapter-item expanded affix "><a href="E0198.html">E0198</a></li><li class="chapter-item expanded affix "><a href="E0199.html">E0199</a></li><li class="chapter-item expanded affix "><a href="E0200.html">E0200</a></li><li class="chapter-item expanded affix "><a href="E0201.html">E0201</a></li><li class="chapter-item expanded affix "><a href="E0203.html">E0203</a></li><li class="chapter-item expanded affix "><a href="E0204.html">E0204</a></li><li class="chapter-item expanded affix "><a href="E0205.html">E0205</a></li><li class="chapter-item expanded affix "><a href="E0206.html">E0206</a></li><li class="chapter-item expanded affix "><a href="E0207.html">E0207</a></li><li class="chapter-item expanded affix "><a href="E0208.html">E0208</a></li><li class="chapter-item expanded affix "><a href="E0210.html">E0210</a></li><li class="chapter-item expanded affix "><a href="E0211.html">E0211</a></li><li class="chapter-item expanded affix "><a href="E0212.html">E0212</a></li><li class="chapter-item expanded affix "><a href="E0214.html">E0214</a></li><li class="chapter-item expanded affix "><a href="E0220.html">E0220</a></li><li class="chapter-item expanded affix "><a href="E0221.html">E0221</a></li><li class="chapter-item expanded affix "><a href="E0222.html">E0222</a></li><li class="chapter-item expanded affix "><a href="E0223.html">E0223</a></li><li class="chapter-item expanded affix "><a href="E0224.html">E0224</a></li><li class="chapter-item expanded affix "><a href="E0225.html">E0225</a></li><li class="chapter-item expanded affix "><a href="E0226.html">E0226</a></li><li class="chapter-item expanded affix "><a href="E0227.html">E0227</a></li><li class="chapter-item expanded affix "><a href="E0228.html">E0228</a></li><li class="chapter-item expanded affix "><a href="E0229.html">E0229</a></li><li class="chapter-item expanded affix "><a href="E0230.html">E0230</a></li><li class="chapter-item expanded affix "><a href="E0231.html">E0231</a></li><li class="chapter-item expanded affix "><a href="E0232.html">E0232</a></li><li class="chapter-item expanded affix "><a href="E0243.html">E0243</a></li><li class="chapter-item expanded affix "><a href="E0244.html">E0244</a></li><li class="chapter-item expanded affix "><a href="E0251.html">E0251</a></li><li class="chapter-item expanded affix "><a href="E0252.html">E0252</a></li><li class="chapter-item expanded affix "><a href="E0253.html">E0253</a></li><li class="chapter-item expanded affix "><a href="E0254.html">E0254</a></li><li class="chapter-item expanded affix "><a href="E0255.html">E0255</a></li><li class="chapter-item expanded affix "><a href="E0256.html">E0256</a></li><li class="chapter-item expanded affix "><a href="E0259.html">E0259</a></li><li class="chapter-item expanded affix "><a href="E0260.html">E0260</a></li><li class="chapter-item expanded affix "><a href="E0261.html">E0261</a></li><li class="chapter-item expanded affix "><a href="E0262.html">E0262</a></li><li class="chapter-item expanded affix "><a href="E0263.html">E0263</a></li><li class="chapter-item expanded affix "><a href="E0264.html">E0264</a></li><li class="chapter-item expanded affix "><a href="E0267.html">E0267</a></li><li class="chapter-item expanded affix "><a href="E0268.html">E0268</a></li><li class="chapter-item expanded affix "><a href="E0271.html">E0271</a></li><li class="chapter-item expanded affix "><a href="E0275.html">E0275</a></li><li class="chapter-item expanded affix "><a href="E0276.html">E0276</a></li><li class="chapter-item expanded affix "><a href="E0277.html">E0277</a></li><li class="chapter-item expanded affix "><a href="E0281.html">E0281</a></li><li class="chapter-item expanded affix "><a href="E0282.html">E0282</a></li><li class="chapter-item expanded affix "><a href="E0283.html">E0283</a></li><li class="chapter-item expanded affix "><a href="E0284.html">E0284</a></li><li class="chapter-item expanded affix "><a href="E0297.html">E0297</a></li><li class="chapter-item expanded affix "><a href="E0301.html">E0301</a></li><li class="chapter-item expanded affix "><a href="E0302.html">E0302</a></li><li class="chapter-item expanded affix "><a href="E0303.html">E0303</a></li><li class="chapter-item expanded affix "><a href="E0307.html">E0307</a></li><li class="chapter-item expanded affix "><a href="E0308.html">E0308</a></li><li class="chapter-item expanded affix "><a href="E0309.html">E0309</a></li><li class="chapter-item expanded affix "><a href="E0310.html">E0310</a></li><li class="chapter-item expanded affix "><a href="E0311.html">E0311</a></li><li class="chapter-item expanded affix "><a href="E0312.html">E0312</a></li><li class="chapter-item expanded affix "><a href="E0316.html">E0316</a></li><li class="chapter-item expanded affix "><a href="E0317.html">E0317</a></li><li class="chapter-item expanded affix "><a href="E0320.html">E0320</a></li><li class="chapter-item expanded affix "><a href="E0321.html">E0321</a></li><li class="chapter-item expanded affix "><a href="E0322.html">E0322</a></li><li class="chapter-item expanded affix "><a href="E0323.html">E0323</a></li><li class="chapter-item expanded affix "><a href="E0324.html">E0324</a></li><li class="chapter-item expanded affix "><a href="E0325.html">E0325</a></li><li class="chapter-item expanded affix "><a href="E0326.html">E0326</a></li><li class="chapter-item expanded affix "><a href="E0328.html">E0328</a></li><li class="chapter-item expanded affix "><a href="E0329.html">E0329</a></li><li class="chapter-item expanded affix "><a href="E0364.html">E0364</a></li><li class="chapter-item expanded affix "><a href="E0365.html">E0365</a></li><li class="chapter-item expanded affix "><a href="E0366.html">E0366</a></li><li class="chapter-item expanded affix "><a href="E0367.html">E0367</a></li><li class="chapter-item expanded affix "><a href="E0368.html">E0368</a></li><li class="chapter-item expanded affix "><a href="E0369.html">E0369</a></li><li class="chapter-item expanded affix "><a href="E0370.html">E0370</a></li><li class="chapter-item expanded affix "><a href="E0371.html">E0371</a></li><li class="chapter-item expanded affix "><a href="E0373.html">E0373</a></li><li class="chapter-item expanded affix "><a href="E0374.html">E0374</a></li><li class="chapter-item expanded affix "><a href="E0375.html">E0375</a></li><li class="chapter-item expanded affix "><a href="E0376.html">E0376</a></li><li class="chapter-item expanded affix "><a href="E0377.html">E0377</a></li><li class="chapter-item expanded affix "><a href="E0378.html">E0378</a></li><li class="chapter-item expanded affix "><a href="E0379.html">E0379</a></li><li class="chapter-item expanded affix "><a href="E0380.html">E0380</a></li><li class="chapter-item expanded affix "><a href="E0381.html">E0381</a></li><li class="chapter-item expanded affix "><a href="E0382.html">E0382</a></li><li class="chapter-item expanded affix "><a href="E0383.html">E0383</a></li><li class="chapter-item expanded affix "><a href="E0384.html">E0384</a></li><li class="chapter-item expanded affix "><a href="E0386.html">E0386</a></li><li class="chapter-item expanded affix "><a href="E0387.html">E0387</a></li><li class="chapter-item expanded affix "><a href="E0388.html">E0388</a></li><li class="chapter-item expanded affix "><a href="E0389.html">E0389</a></li><li class="chapter-item expanded affix "><a href="E0390.html">E0390</a></li><li class="chapter-item expanded affix "><a href="E0391.html">E0391</a></li><li class="chapter-item expanded affix "><a href="E0392.html">E0392</a></li><li class="chapter-item expanded affix "><a href="E0393.html">E0393</a></li><li class="chapter-item expanded affix "><a href="E0398.html">E0398</a></li><li class="chapter-item expanded affix "><a href="E0399.html">E0399</a></li><li class="chapter-item expanded affix "><a href="E0401.html">E0401</a></li><li class="chapter-item expanded affix "><a href="E0403.html">E0403</a></li><li class="chapter-item expanded affix "><a href="E0404.html">E0404</a></li><li class="chapter-item expanded affix "><a href="E0405.html">E0405</a></li><li class="chapter-item expanded affix "><a href="E0407.html">E0407</a></li><li class="chapter-item expanded affix "><a href="E0408.html">E0408</a></li><li class="chapter-item expanded affix "><a href="E0409.html">E0409</a></li><li class="chapter-item expanded affix "><a href="E0411.html">E0411</a></li><li class="chapter-item expanded affix "><a href="E0412.html">E0412</a></li><li class="chapter-item expanded affix "><a href="E0415.html">E0415</a></li><li class="chapter-item expanded affix "><a href="E0416.html">E0416</a></li><li class="chapter-item expanded affix "><a href="E0422.html">E0422</a></li><li class="chapter-item expanded affix "><a href="E0423.html">E0423</a></li><li class="chapter-item expanded affix "><a href="E0424.html">E0424</a></li><li class="chapter-item expanded affix "><a href="E0425.html">E0425</a></li><li class="chapter-item expanded affix "><a href="E0426.html">E0426</a></li><li class="chapter-item expanded affix "><a href="E0428.html">E0428</a></li><li class="chapter-item expanded affix "><a href="E0429.html">E0429</a></li><li class="chapter-item expanded affix "><a href="E0430.html">E0430</a></li><li class="chapter-item expanded affix "><a href="E0431.html">E0431</a></li><li class="chapter-item expanded affix "><a href="E0432.html">E0432</a></li><li class="chapter-item expanded affix "><a href="E0433.html">E0433</a></li><li class="chapter-item expanded affix "><a href="E0434.html">E0434</a></li><li class="chapter-item expanded affix "><a href="E0435.html">E0435</a></li><li class="chapter-item expanded affix "><a href="E0436.html">E0436</a></li><li class="chapter-item expanded affix "><a href="E0437.html">E0437</a></li><li class="chapter-item expanded affix "><a href="E0438.html">E0438</a></li><li class="chapter-item expanded affix "><a href="E0439.html">E0439</a></li><li class="chapter-item expanded affix "><a href="E0445.html">E0445</a></li><li class="chapter-item expanded affix "><a href="E0446.html">E0446</a></li><li class="chapter-item expanded affix "><a href="E0447.html">E0447</a></li><li class="chapter-item expanded affix "><a href="E0448.html">E0448</a></li><li class="chapter-item expanded affix "><a href="E0449.html">E0449</a></li><li class="chapter-item expanded affix "><a href="E0451.html">E0451</a></li><li class="chapter-item expanded affix "><a href="E0452.html">E0452</a></li><li class="chapter-item expanded affix "><a href="E0453.html">E0453</a></li><li class="chapter-item expanded affix "><a href="E0454.html">E0454</a></li><li class="chapter-item expanded affix "><a href="E0455.html">E0455</a></li><li class="chapter-item expanded affix "><a href="E0457.html">E0457</a></li><li class="chapter-item expanded affix "><a href="E0458.html">E0458</a></li><li class="chapter-item expanded affix "><a href="E0459.html">E0459</a></li><li class="chapter-item expanded affix "><a href="E0460.html">E0460</a></li><li class="chapter-item expanded affix "><a href="E0461.html">E0461</a></li><li class="chapter-item expanded affix "><a href="E0462.html">E0462</a></li><li class="chapter-item expanded affix "><a href="E0463.html">E0463</a></li><li class="chapter-item expanded affix "><a href="E0464.html">E0464</a></li><li class="chapter-item expanded affix "><a href="E0466.html">E0466</a></li><li class="chapter-item expanded affix "><a href="E0468.html">E0468</a></li><li class="chapter-item expanded affix "><a href="E0469.html">E0469</a></li><li class="chapter-item expanded affix "><a href="E0472.html">E0472</a></li><li class="chapter-item expanded affix "><a href="E0476.html">E0476</a></li><li class="chapter-item expanded affix "><a href="E0477.html">E0477</a></li><li class="chapter-item expanded affix "><a href="E0478.html">E0478</a></li><li class="chapter-item expanded affix "><a href="E0482.html">E0482</a></li><li class="chapter-item expanded affix "><a href="E0491.html">E0491</a></li><li class="chapter-item expanded affix "><a href="E0492.html">E0492</a></li><li class="chapter-item expanded affix "><a href="E0493.html">E0493</a></li><li class="chapter-item expanded affix "><a href="E0495.html">E0495</a></li><li class="chapter-item expanded affix "><a href="E0496.html">E0496</a></li><li class="chapter-item expanded affix "><a href="E0497.html">E0497</a></li><li class="chapter-item expanded affix "><a href="E0498.html">E0498</a></li><li class="chapter-item expanded affix "><a href="E0499.html">E0499</a></li><li class="chapter-item expanded affix "><a href="E0500.html">E0500</a></li><li class="chapter-item expanded affix "><a href="E0501.html">E0501</a></li><li class="chapter-item expanded affix "><a href="E0502.html">E0502</a></li><li class="chapter-item expanded affix "><a href="E0503.html">E0503</a></li><li class="chapter-item expanded affix "><a href="E0504.html">E0504</a></li><li class="chapter-item expanded affix "><a href="E0505.html">E0505</a></li><li class="chapter-item expanded affix "><a href="E0506.html">E0506</a></li><li class="chapter-item expanded affix "><a href="E0507.html">E0507</a></li><li class="chapter-item expanded affix "><a href="E0508.html">E0508</a></li><li class="chapter-item expanded affix "><a href="E0509.html">E0509</a></li><li class="chapter-item expanded affix "><a href="E0510.html">E0510</a></li><li class="chapter-item expanded affix "><a href="E0511.html">E0511</a></li><li class="chapter-item expanded affix "><a href="E0512.html">E0512</a></li><li class="chapter-item expanded affix "><a href="E0514.html">E0514</a></li><li class="chapter-item expanded affix "><a href="E0515.html">E0515</a></li><li class="chapter-item expanded affix "><a href="E0516.html">E0516</a></li><li class="chapter-item expanded affix "><a href="E0517.html">E0517</a></li><li class="chapter-item expanded affix "><a href="E0518.html">E0518</a></li><li class="chapter-item expanded affix "><a href="E0519.html">E0519</a></li><li class="chapter-item expanded affix "><a href="E0520.html">E0520</a></li><li class="chapter-item expanded affix "><a href="E0521.html">E0521</a></li><li class="chapter-item expanded affix "><a href="E0522.html">E0522</a></li><li class="chapter-item expanded affix "><a href="E0523.html">E0523</a></li><li class="chapter-item expanded affix "><a href="E0524.html">E0524</a></li><li class="chapter-item expanded affix "><a href="E0525.html">E0525</a></li><li class="chapter-item expanded affix "><a href="E0527.html">E0527</a></li><li class="chapter-item expanded affix "><a href="E0528.html">E0528</a></li><li class="chapter-item expanded affix "><a href="E0529.html">E0529</a></li><li class="chapter-item expanded affix "><a href="E0530.html">E0530</a></li><li class="chapter-item expanded affix "><a href="E0531.html">E0531</a></li><li class="chapter-item expanded affix "><a href="E0532.html">E0532</a></li><li class="chapter-item expanded affix "><a href="E0533.html">E0533</a></li><li class="chapter-item expanded affix "><a href="E0534.html">E0534</a></li><li class="chapter-item expanded affix "><a href="E0535.html">E0535</a></li><li class="chapter-item expanded affix "><a href="E0536.html">E0536</a></li><li class="chapter-item expanded affix "><a href="E0537.html">E0537</a></li><li class="chapter-item expanded affix "><a href="E0538.html">E0538</a></li><li class="chapter-item expanded affix "><a href="E0539.html">E0539</a></li><li class="chapter-item expanded affix "><a href="E0541.html">E0541</a></li><li class="chapter-item expanded affix "><a href="E0542.html">E0542</a></li><li class="chapter-item expanded affix "><a href="E0543.html">E0543</a></li><li class="chapter-item expanded affix "><a href="E0544.html">E0544</a></li><li class="chapter-item expanded affix "><a href="E0545.html">E0545</a></li><li class="chapter-item expanded affix "><a href="E0546.html">E0546</a></li><li class="chapter-item expanded affix "><a href="E0547.html">E0547</a></li><li class="chapter-item expanded affix "><a href="E0549.html">E0549</a></li><li class="chapter-item expanded affix "><a href="E0550.html">E0550</a></li><li class="chapter-item expanded affix "><a href="E0551.html">E0551</a></li><li class="chapter-item expanded affix "><a href="E0552.html">E0552</a></li><li class="chapter-item expanded affix "><a href="E0554.html">E0554</a></li><li class="chapter-item expanded affix "><a href="E0556.html">E0556</a></li><li class="chapter-item expanded affix "><a href="E0557.html">E0557</a></li><li class="chapter-item expanded affix "><a href="E0559.html">E0559</a></li><li class="chapter-item expanded affix "><a href="E0560.html">E0560</a></li><li class="chapter-item expanded affix "><a href="E0561.html">E0561</a></li><li class="chapter-item expanded affix "><a href="E0562.html">E0562</a></li><li class="chapter-item expanded affix "><a href="E0565.html">E0565</a></li><li class="chapter-item expanded affix "><a href="E0566.html">E0566</a></li><li class="chapter-item expanded affix "><a href="E0567.html">E0567</a></li><li class="chapter-item expanded affix "><a href="E0568.html">E0568</a></li><li class="chapter-item expanded affix "><a href="E0569.html">E0569</a></li><li class="chapter-item expanded affix "><a href="E0570.html">E0570</a></li><li class="chapter-item expanded affix "><a href="E0571.html">E0571</a></li><li class="chapter-item expanded affix "><a href="E0572.html">E0572</a></li><li class="chapter-item expanded affix "><a href="E0573.html">E0573</a></li><li class="chapter-item expanded affix "><a href="E0574.html">E0574</a></li><li class="chapter-item expanded affix "><a href="E0575.html">E0575</a></li><li class="chapter-item expanded affix "><a href="E0576.html">E0576</a></li><li class="chapter-item expanded affix "><a href="E0577.html">E0577</a></li><li class="chapter-item expanded affix "><a href="E0578.html">E0578</a></li><li class="chapter-item expanded affix "><a href="E0579.html">E0579</a></li><li class="chapter-item expanded affix "><a href="E0580.html">E0580</a></li><li class="chapter-item expanded affix "><a href="E0581.html">E0581</a></li><li class="chapter-item expanded affix "><a href="E0582.html">E0582</a></li><li class="chapter-item expanded affix "><a href="E0583.html">E0583</a></li><li class="chapter-item expanded affix "><a href="E0584.html">E0584</a></li><li class="chapter-item expanded affix "><a href="E0585.html">E0585</a></li><li class="chapter-item expanded affix "><a href="E0586.html">E0586</a></li><li class="chapter-item expanded affix "><a href="E0587.html">E0587</a></li><li class="chapter-item expanded affix "><a href="E0588.html">E0588</a></li><li class="chapter-item expanded affix "><a href="E0589.html">E0589</a></li><li class="chapter-item expanded affix "><a href="E0590.html">E0590</a></li><li class="chapter-item expanded affix "><a href="E0591.html">E0591</a></li><li class="chapter-item expanded affix "><a href="E0592.html">E0592</a></li><li class="chapter-item expanded affix "><a href="E0593.html">E0593</a></li><li class="chapter-item expanded affix "><a href="E0594.html">E0594</a></li><li class="chapter-item expanded affix "><a href="E0595.html">E0595</a></li><li class="chapter-item expanded affix "><a href="E0596.html">E0596</a></li><li class="chapter-item expanded affix "><a href="E0597.html">E0597</a></li><li class="chapter-item expanded affix "><a href="E0599.html">E0599</a></li><li class="chapter-item expanded affix "><a href="E0600.html">E0600</a></li><li class="chapter-item expanded affix "><a href="E0601.html">E0601</a></li><li class="chapter-item expanded affix "><a href="E0602.html">E0602</a></li><li class="chapter-item expanded affix "><a href="E0603.html">E0603</a></li><li class="chapter-item expanded affix "><a href="E0604.html">E0604</a></li><li class="chapter-item expanded affix "><a href="E0605.html">E0605</a></li><li class="chapter-item expanded affix "><a href="E0606.html">E0606</a></li><li class="chapter-item expanded affix "><a href="E0607.html">E0607</a></li><li class="chapter-item expanded affix "><a href="E0608.html">E0608</a></li><li class="chapter-item expanded affix "><a href="E0609.html">E0609</a></li><li class="chapter-item expanded affix "><a href="E0610.html">E0610</a></li><li class="chapter-item expanded affix "><a href="E0614.html">E0614</a></li><li class="chapter-item expanded affix "><a href="E0615.html">E0615</a></li><li class="chapter-item expanded affix "><a href="E0616.html">E0616</a></li><li class="chapter-item expanded affix "><a href="E0617.html">E0617</a></li><li class="chapter-item expanded affix "><a href="E0618.html">E0618</a></li><li class="chapter-item expanded affix "><a href="E0619.html">E0619</a></li><li class="chapter-item expanded affix "><a href="E0620.html">E0620</a></li><li class="chapter-item expanded affix "><a href="E0621.html">E0621</a></li><li class="chapter-item expanded affix "><a href="E0622.html">E0622</a></li><li class="chapter-item expanded affix "><a href="E0623.html">E0623</a></li><li class="chapter-item expanded affix "><a href="E0624.html">E0624</a></li><li class="chapter-item expanded affix "><a href="E0625.html">E0625</a></li><li class="chapter-item expanded affix "><a href="E0626.html">E0626</a></li><li class="chapter-item expanded affix "><a href="E0627.html">E0627</a></li><li class="chapter-item expanded affix "><a href="E0628.html">E0628</a></li><li class="chapter-item expanded affix "><a href="E0631.html">E0631</a></li><li class="chapter-item expanded affix "><a href="E0632.html">E0632</a></li><li class="chapter-item expanded affix "><a href="E0633.html">E0633</a></li><li class="chapter-item expanded affix "><a href="E0634.html">E0634</a></li><li class="chapter-item expanded affix "><a href="E0635.html">E0635</a></li><li class="chapter-item expanded affix "><a href="E0636.html">E0636</a></li><li class="chapter-item expanded affix "><a href="E0637.html">E0637</a></li><li class="chapter-item expanded affix "><a href="E0638.html">E0638</a></li><li class="chapter-item expanded affix "><a href="E0639.html">E0639</a></li><li class="chapter-item expanded affix "><a href="E0640.html">E0640</a></li><li class="chapter-item expanded affix "><a href="E0641.html">E0641</a></li><li class="chapter-item expanded affix "><a href="E0642.html">E0642</a></li><li class="chapter-item expanded affix "><a href="E0643.html">E0643</a></li><li class="chapter-item expanded affix "><a href="E0644.html">E0644</a></li><li class="chapter-item expanded affix "><a href="E0646.html">E0646</a></li><li class="chapter-item expanded affix "><a href="E0647.html">E0647</a></li><li class="chapter-item expanded affix "><a href="E0648.html">E0648</a></li><li class="chapter-item expanded affix "><a href="E0657.html">E0657</a></li><li class="chapter-item expanded affix "><a href="E0658.html">E0658</a></li><li class="chapter-item expanded affix "><a href="E0659.html">E0659</a></li><li class="chapter-item expanded affix "><a href="E0660.html">E0660</a></li><li class="chapter-item expanded affix "><a href="E0661.html">E0661</a></li><li class="chapter-item expanded affix "><a href="E0662.html">E0662</a></li><li class="chapter-item expanded affix "><a href="E0663.html">E0663</a></li><li class="chapter-item expanded affix "><a href="E0664.html">E0664</a></li><li class="chapter-item expanded affix "><a href="E0665.html">E0665</a></li><li class="chapter-item expanded affix "><a href="E0666.html">E0666</a></li><li class="chapter-item expanded affix "><a href="E0667.html">E0667</a></li><li class="chapter-item expanded affix "><a href="E0668.html">E0668</a></li><li class="chapter-item expanded affix "><a href="E0669.html">E0669</a></li><li class="chapter-item expanded affix "><a href="E0670.html">E0670</a></li><li class="chapter-item expanded affix "><a href="E0671.html">E0671</a></li><li class="chapter-item expanded affix "><a href="E0687.html">E0687</a></li><li class="chapter-item expanded affix "><a href="E0688.html">E0688</a></li><li class="chapter-item expanded affix "><a href="E0689.html">E0689</a></li><li class="chapter-item expanded affix "><a href="E0690.html">E0690</a></li><li class="chapter-item expanded affix "><a href="E0691.html">E0691</a></li><li class="chapter-item expanded affix "><a href="E0692.html">E0692</a></li><li class="chapter-item expanded affix "><a href="E0693.html">E0693</a></li><li class="chapter-item expanded affix "><a href="E0695.html">E0695</a></li><li class="chapter-item expanded affix "><a href="E0696.html">E0696</a></li><li class="chapter-item expanded affix "><a href="E0697.html">E0697</a></li><li class="chapter-item expanded affix "><a href="E0698.html">E0698</a></li><li class="chapter-item expanded affix "><a href="E0699.html">E0699</a></li><li class="chapter-item expanded affix "><a href="E0700.html">E0700</a></li><li class="chapter-item expanded affix "><a href="E0701.html">E0701</a></li><li class="chapter-item expanded affix "><a href="E0703.html">E0703</a></li><li class="chapter-item expanded affix "><a href="E0704.html">E0704</a></li><li class="chapter-item expanded affix "><a href="E0705.html">E0705</a></li><li class="chapter-item expanded affix "><a href="E0706.html">E0706</a></li><li class="chapter-item expanded affix "><a href="E0708.html">E0708</a></li><li class="chapter-item expanded affix "><a href="E0710.html">E0710</a></li><li class="chapter-item expanded affix "><a href="E0712.html">E0712</a></li><li class="chapter-item expanded affix "><a href="E0713.html">E0713</a></li><li class="chapter-item expanded affix "><a href="E0714.html">E0714</a></li><li class="chapter-item expanded affix "><a href="E0715.html">E0715</a></li><li class="chapter-item expanded affix "><a href="E0716.html">E0716</a></li><li class="chapter-item expanded affix "><a href="E0711.html">E0711</a></li><li class="chapter-item expanded affix "><a href="E0717.html">E0717</a></li><li class="chapter-item expanded affix "><a href="E0718.html">E0718</a></li><li class="chapter-item expanded affix "><a href="E0719.html">E0719</a></li><li class="chapter-item expanded affix "><a href="E0720.html">E0720</a></li><li class="chapter-item expanded affix "><a href="E0722.html">E0722</a></li><li class="chapter-item expanded affix "><a href="E0724.html">E0724</a></li><li class="chapter-item expanded affix "><a href="E0725.html">E0725</a></li><li class="chapter-item expanded affix "><a href="E0726.html">E0726</a></li><li class="chapter-item expanded affix "><a href="E0727.html">E0727</a></li><li class="chapter-item expanded affix "><a href="E0728.html">E0728</a></li><li class="chapter-item expanded affix "><a href="E0729.html">E0729</a></li><li class="chapter-item expanded affix "><a href="E0730.html">E0730</a></li><li class="chapter-item expanded affix "><a href="E0731.html">E0731</a></li><li class="chapter-item expanded affix "><a href="E0732.html">E0732</a></li><li class="chapter-item expanded affix "><a href="E0733.html">E0733</a></li><li class="chapter-item expanded affix "><a href="E0734.html">E0734</a></li><li class="chapter-item expanded affix "><a href="E0735.html">E0735</a></li><li class="chapter-item expanded affix "><a href="E0736.html">E0736</a></li><li class="chapter-item expanded affix "><a href="E0737.html">E0737</a></li><li class="chapter-item expanded affix "><a href="E0739.html">E0739</a></li><li class="chapter-item expanded affix "><a href="E0740.html">E0740</a></li><li class="chapter-item expanded affix "><a href="E0741.html">E0741</a></li><li class="chapter-item expanded affix "><a href="E0742.html">E0742</a></li><li class="chapter-item expanded affix "><a href="E0743.html">E0743</a></li><li class="chapter-item expanded affix "><a href="E0744.html">E0744</a></li><li class="chapter-item expanded affix "><a href="E0745.html">E0745</a></li><li class="chapter-item expanded affix "><a href="E0746.html">E0746</a></li><li class="chapter-item expanded affix "><a href="E0747.html">E0747</a></li><li class="chapter-item expanded affix "><a href="E0748.html">E0748</a></li><li class="chapter-item expanded affix "><a href="E0749.html">E0749</a></li><li class="chapter-item expanded affix "><a href="E0750.html">E0750</a></li><li class="chapter-item expanded affix "><a href="E0751.html">E0751</a></li><li class="chapter-item expanded affix "><a href="E0752.html">E0752</a></li><li class="chapter-item expanded affix "><a href="E0753.html">E0753</a></li><li class="chapter-item expanded affix "><a href="E0754.html">E0754</a></li><li class="chapter-item expanded affix "><a href="E0755.html">E0755</a></li><li class="chapter-item expanded affix "><a href="E0756.html">E0756</a></li><li class="chapter-item expanded affix "><a href="E0757.html">E0757</a></li><li class="chapter-item expanded affix "><a href="E0758.html">E0758</a></li><li class="chapter-item expanded affix "><a href="E0759.html">E0759</a></li><li class="chapter-item expanded affix "><a href="E0760.html">E0760</a></li><li class="chapter-item expanded affix "><a href="E0761.html">E0761</a></li><li class="chapter-item expanded affix "><a href="E0762.html">E0762</a></li><li class="chapter-item expanded affix "><a href="E0763.html">E0763</a></li><li class="chapter-item expanded affix "><a href="E0764.html">E0764</a></li><li class="chapter-item expanded affix "><a href="E0765.html">E0765</a></li><li class="chapter-item expanded affix "><a href="E0766.html">E0766</a></li><li class="chapter-item expanded affix "><a href="E0767.html">E0767</a></li><li class="chapter-item expanded affix "><a href="E0768.html">E0768</a></li><li class="chapter-item expanded affix "><a href="E0769.html">E0769</a></li><li class="chapter-item expanded affix "><a href="E0770.html">E0770</a></li><li class="chapter-item expanded affix "><a href="E0771.html">E0771</a></li><li class="chapter-item expanded affix "><a href="E0772.html">E0772</a></li><li class="chapter-item expanded affix "><a href="E0773.html">E0773</a></li><li class="chapter-item expanded affix "><a href="E0774.html">E0774</a></li><li class="chapter-item expanded affix "><a href="E0775.html">E0775</a></li><li class="chapter-item expanded affix "><a href="E0776.html">E0776</a></li><li class="chapter-item expanded affix "><a href="E0777.html">E0777</a></li><li class="chapter-item expanded affix "><a href="E0778.html">E0778</a></li><li class="chapter-item expanded affix "><a href="E0779.html">E0779</a></li><li class="chapter-item expanded affix "><a href="E0780.html">E0780</a></li><li class="chapter-item expanded affix "><a href="E0781.html">E0781</a></li><li class="chapter-item expanded affix "><a href="E0782.html">E0782</a></li><li class="chapter-item expanded affix "><a href="E0783.html">E0783</a></li><li class="chapter-item expanded affix "><a href="E0784.html">E0784</a></li><li class="chapter-item expanded affix "><a href="E0785.html">E0785</a></li><li class="chapter-item expanded affix "><a href="E0786.html">E0786</a></li><li class="chapter-item expanded affix "><a href="E0787.html">E0787</a></li><li class="chapter-item expanded affix "><a href="E0788.html">E0788</a></li><li class="chapter-item expanded affix "><a href="E0789.html">E0789</a></li><li class="chapter-item expanded affix "><a href="E0790.html">E0790</a></li><li class="chapter-item expanded affix "><a href="E0791.html">E0791</a></li><li class="chapter-item expanded affix "><a href="E0792.html">E0792</a></li><li class="chapter-item expanded affix "><a href="E0793.html">E0793</a></li><li class="chapter-item expanded affix "><a href="E0794.html">E0794</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Error codes index</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-error-codes-index"><a class="header" href="#rust-error-codes-index">Rust error codes index</a></h1>
<p>This page lists all the error codes emitted by the Rust compiler.</p>
<ul>
<li><a href="./E0001.html">E0001</a></li>
<li><a href="./E0002.html">E0002</a></li>
<li><a href="./E0004.html">E0004</a></li>
<li><a href="./E0005.html">E0005</a></li>
<li><a href="./E0007.html">E0007</a></li>
<li><a href="./E0009.html">E0009</a></li>
<li><a href="./E0010.html">E0010</a></li>
<li><a href="./E0013.html">E0013</a></li>
<li><a href="./E0014.html">E0014</a></li>
<li><a href="./E0015.html">E0015</a></li>
<li><a href="./E0023.html">E0023</a></li>
<li><a href="./E0025.html">E0025</a></li>
<li><a href="./E0026.html">E0026</a></li>
<li><a href="./E0027.html">E0027</a></li>
<li><a href="./E0029.html">E0029</a></li>
<li><a href="./E0030.html">E0030</a></li>
<li><a href="./E0033.html">E0033</a></li>
<li><a href="./E0034.html">E0034</a></li>
<li><a href="./E0038.html">E0038</a></li>
<li><a href="./E0040.html">E0040</a></li>
<li><a href="./E0044.html">E0044</a></li>
<li><a href="./E0045.html">E0045</a></li>
<li><a href="./E0046.html">E0046</a></li>
<li><a href="./E0049.html">E0049</a></li>
<li><a href="./E0050.html">E0050</a></li>
<li><a href="./E0053.html">E0053</a></li>
<li><a href="./E0054.html">E0054</a></li>
<li><a href="./E0055.html">E0055</a></li>
<li><a href="./E0057.html">E0057</a></li>
<li><a href="./E0059.html">E0059</a></li>
<li><a href="./E0060.html">E0060</a></li>
<li><a href="./E0061.html">E0061</a></li>
<li><a href="./E0062.html">E0062</a></li>
<li><a href="./E0063.html">E0063</a></li>
<li><a href="./E0067.html">E0067</a></li>
<li><a href="./E0069.html">E0069</a></li>
<li><a href="./E0070.html">E0070</a></li>
<li><a href="./E0071.html">E0071</a></li>
<li><a href="./E0072.html">E0072</a></li>
<li><a href="./E0073.html">E0073</a></li>
<li><a href="./E0074.html">E0074</a></li>
<li><a href="./E0075.html">E0075</a></li>
<li><a href="./E0076.html">E0076</a></li>
<li><a href="./E0077.html">E0077</a></li>
<li><a href="./E0080.html">E0080</a></li>
<li><a href="./E0081.html">E0081</a></li>
<li><a href="./E0084.html">E0084</a></li>
<li><a href="./E0087.html">E0087</a></li>
<li><a href="./E0088.html">E0088</a></li>
<li><a href="./E0089.html">E0089</a></li>
<li><a href="./E0090.html">E0090</a></li>
<li><a href="./E0091.html">E0091</a></li>
<li><a href="./E0092.html">E0092</a></li>
<li><a href="./E0093.html">E0093</a></li>
<li><a href="./E0094.html">E0094</a></li>
<li><a href="./E0106.html">E0106</a></li>
<li><a href="./E0107.html">E0107</a></li>
<li><a href="./E0109.html">E0109</a></li>
<li><a href="./E0110.html">E0110</a></li>
<li><a href="./E0116.html">E0116</a></li>
<li><a href="./E0117.html">E0117</a></li>
<li><a href="./E0118.html">E0118</a></li>
<li><a href="./E0119.html">E0119</a></li>
<li><a href="./E0120.html">E0120</a></li>
<li><a href="./E0121.html">E0121</a></li>
<li><a href="./E0124.html">E0124</a></li>
<li><a href="./E0128.html">E0128</a></li>
<li><a href="./E0130.html">E0130</a></li>
<li><a href="./E0131.html">E0131</a></li>
<li><a href="./E0132.html">E0132</a></li>
<li><a href="./E0133.html">E0133</a></li>
<li><a href="./E0136.html">E0136</a></li>
<li><a href="./E0137.html">E0137</a></li>
<li><a href="./E0138.html">E0138</a></li>
<li><a href="./E0139.html">E0139</a></li>
<li><a href="./E0152.html">E0152</a></li>
<li><a href="./E0154.html">E0154</a></li>
<li><a href="./E0158.html">E0158</a></li>
<li><a href="./E0161.html">E0161</a></li>
<li><a href="./E0162.html">E0162</a></li>
<li><a href="./E0164.html">E0164</a></li>
<li><a href="./E0165.html">E0165</a></li>
<li><a href="./E0170.html">E0170</a></li>
<li><a href="./E0178.html">E0178</a></li>
<li><a href="./E0183.html">E0183</a></li>
<li><a href="./E0184.html">E0184</a></li>
<li><a href="./E0185.html">E0185</a></li>
<li><a href="./E0186.html">E0186</a></li>
<li><a href="./E0191.html">E0191</a></li>
<li><a href="./E0192.html">E0192</a></li>
<li><a href="./E0193.html">E0193</a></li>
<li><a href="./E0195.html">E0195</a></li>
<li><a href="./E0197.html">E0197</a></li>
<li><a href="./E0198.html">E0198</a></li>
<li><a href="./E0199.html">E0199</a></li>
<li><a href="./E0200.html">E0200</a></li>
<li><a href="./E0201.html">E0201</a></li>
<li><a href="./E0203.html">E0203</a></li>
<li><a href="./E0204.html">E0204</a></li>
<li><a href="./E0205.html">E0205</a></li>
<li><a href="./E0206.html">E0206</a></li>
<li><a href="./E0207.html">E0207</a></li>
<li><a href="./E0208.html">E0208</a></li>
<li><a href="./E0210.html">E0210</a></li>
<li><a href="./E0211.html">E0211</a></li>
<li><a href="./E0212.html">E0212</a></li>
<li><a href="./E0214.html">E0214</a></li>
<li><a href="./E0220.html">E0220</a></li>
<li><a href="./E0221.html">E0221</a></li>
<li><a href="./E0222.html">E0222</a></li>
<li><a href="./E0223.html">E0223</a></li>
<li><a href="./E0224.html">E0224</a></li>
<li><a href="./E0225.html">E0225</a></li>
<li><a href="./E0226.html">E0226</a></li>
<li><a href="./E0227.html">E0227</a></li>
<li><a href="./E0228.html">E0228</a></li>
<li><a href="./E0229.html">E0229</a></li>
<li><a href="./E0230.html">E0230</a></li>
<li><a href="./E0231.html">E0231</a></li>
<li><a href="./E0232.html">E0232</a></li>
<li><a href="./E0243.html">E0243</a></li>
<li><a href="./E0244.html">E0244</a></li>
<li><a href="./E0251.html">E0251</a></li>
<li><a href="./E0252.html">E0252</a></li>
<li><a href="./E0253.html">E0253</a></li>
<li><a href="./E0254.html">E0254</a></li>
<li><a href="./E0255.html">E0255</a></li>
<li><a href="./E0256.html">E0256</a></li>
<li><a href="./E0259.html">E0259</a></li>
<li><a href="./E0260.html">E0260</a></li>
<li><a href="./E0261.html">E0261</a></li>
<li><a href="./E0262.html">E0262</a></li>
<li><a href="./E0263.html">E0263</a></li>
<li><a href="./E0264.html">E0264</a></li>
<li><a href="./E0267.html">E0267</a></li>
<li><a href="./E0268.html">E0268</a></li>
<li><a href="./E0271.html">E0271</a></li>
<li><a href="./E0275.html">E0275</a></li>
<li><a href="./E0276.html">E0276</a></li>
<li><a href="./E0277.html">E0277</a></li>
<li><a href="./E0281.html">E0281</a></li>
<li><a href="./E0282.html">E0282</a></li>
<li><a href="./E0283.html">E0283</a></li>
<li><a href="./E0284.html">E0284</a></li>
<li><a href="./E0297.html">E0297</a></li>
<li><a href="./E0301.html">E0301</a></li>
<li><a href="./E0302.html">E0302</a></li>
<li><a href="./E0303.html">E0303</a></li>
<li><a href="./E0307.html">E0307</a></li>
<li><a href="./E0308.html">E0308</a></li>
<li><a href="./E0309.html">E0309</a></li>
<li><a href="./E0310.html">E0310</a></li>
<li><a href="./E0311.html">E0311</a></li>
<li><a href="./E0312.html">E0312</a></li>
<li><a href="./E0316.html">E0316</a></li>
<li><a href="./E0317.html">E0317</a></li>
<li><a href="./E0320.html">E0320</a></li>
<li><a href="./E0321.html">E0321</a></li>
<li><a href="./E0322.html">E0322</a></li>
<li><a href="./E0323.html">E0323</a></li>
<li><a href="./E0324.html">E0324</a></li>
<li><a href="./E0325.html">E0325</a></li>
<li><a href="./E0326.html">E0326</a></li>
<li><a href="./E0328.html">E0328</a></li>
<li><a href="./E0329.html">E0329</a></li>
<li><a href="./E0364.html">E0364</a></li>
<li><a href="./E0365.html">E0365</a></li>
<li><a href="./E0366.html">E0366</a></li>
<li><a href="./E0367.html">E0367</a></li>
<li><a href="./E0368.html">E0368</a></li>
<li><a href="./E0369.html">E0369</a></li>
<li><a href="./E0370.html">E0370</a></li>
<li><a href="./E0371.html">E0371</a></li>
<li><a href="./E0373.html">E0373</a></li>
<li><a href="./E0374.html">E0374</a></li>
<li><a href="./E0375.html">E0375</a></li>
<li><a href="./E0376.html">E0376</a></li>
<li><a href="./E0377.html">E0377</a></li>
<li><a href="./E0378.html">E0378</a></li>
<li><a href="./E0379.html">E0379</a></li>
<li><a href="./E0380.html">E0380</a></li>
<li><a href="./E0381.html">E0381</a></li>
<li><a href="./E0382.html">E0382</a></li>
<li><a href="./E0383.html">E0383</a></li>
<li><a href="./E0384.html">E0384</a></li>
<li><a href="./E0386.html">E0386</a></li>
<li><a href="./E0387.html">E0387</a></li>
<li><a href="./E0388.html">E0388</a></li>
<li><a href="./E0389.html">E0389</a></li>
<li><a href="./E0390.html">E0390</a></li>
<li><a href="./E0391.html">E0391</a></li>
<li><a href="./E0392.html">E0392</a></li>
<li><a href="./E0393.html">E0393</a></li>
<li><a href="./E0398.html">E0398</a></li>
<li><a href="./E0399.html">E0399</a></li>
<li><a href="./E0401.html">E0401</a></li>
<li><a href="./E0403.html">E0403</a></li>
<li><a href="./E0404.html">E0404</a></li>
<li><a href="./E0405.html">E0405</a></li>
<li><a href="./E0407.html">E0407</a></li>
<li><a href="./E0408.html">E0408</a></li>
<li><a href="./E0409.html">E0409</a></li>
<li><a href="./E0411.html">E0411</a></li>
<li><a href="./E0412.html">E0412</a></li>
<li><a href="./E0415.html">E0415</a></li>
<li><a href="./E0416.html">E0416</a></li>
<li><a href="./E0422.html">E0422</a></li>
<li><a href="./E0423.html">E0423</a></li>
<li><a href="./E0424.html">E0424</a></li>
<li><a href="./E0425.html">E0425</a></li>
<li><a href="./E0426.html">E0426</a></li>
<li><a href="./E0428.html">E0428</a></li>
<li><a href="./E0429.html">E0429</a></li>
<li><a href="./E0430.html">E0430</a></li>
<li><a href="./E0431.html">E0431</a></li>
<li><a href="./E0432.html">E0432</a></li>
<li><a href="./E0433.html">E0433</a></li>
<li><a href="./E0434.html">E0434</a></li>
<li><a href="./E0435.html">E0435</a></li>
<li><a href="./E0436.html">E0436</a></li>
<li><a href="./E0437.html">E0437</a></li>
<li><a href="./E0438.html">E0438</a></li>
<li><a href="./E0439.html">E0439</a></li>
<li><a href="./E0445.html">E0445</a></li>
<li><a href="./E0446.html">E0446</a></li>
<li><a href="./E0447.html">E0447</a></li>
<li><a href="./E0448.html">E0448</a></li>
<li><a href="./E0449.html">E0449</a></li>
<li><a href="./E0451.html">E0451</a></li>
<li><a href="./E0452.html">E0452</a></li>
<li><a href="./E0453.html">E0453</a></li>
<li><a href="./E0454.html">E0454</a></li>
<li><a href="./E0455.html">E0455</a></li>
<li><a href="./E0457.html">E0457</a></li>
<li><a href="./E0458.html">E0458</a></li>
<li><a href="./E0459.html">E0459</a></li>
<li><a href="./E0460.html">E0460</a></li>
<li><a href="./E0461.html">E0461</a></li>
<li><a href="./E0462.html">E0462</a></li>
<li><a href="./E0463.html">E0463</a></li>
<li><a href="./E0464.html">E0464</a></li>
<li><a href="./E0466.html">E0466</a></li>
<li><a href="./E0468.html">E0468</a></li>
<li><a href="./E0469.html">E0469</a></li>
<li><a href="./E0472.html">E0472</a></li>
<li><a href="./E0476.html">E0476</a></li>
<li><a href="./E0477.html">E0477</a></li>
<li><a href="./E0478.html">E0478</a></li>
<li><a href="./E0482.html">E0482</a></li>
<li><a href="./E0491.html">E0491</a></li>
<li><a href="./E0492.html">E0492</a></li>
<li><a href="./E0493.html">E0493</a></li>
<li><a href="./E0495.html">E0495</a></li>
<li><a href="./E0496.html">E0496</a></li>
<li><a href="./E0497.html">E0497</a></li>
<li><a href="./E0498.html">E0498</a></li>
<li><a href="./E0499.html">E0499</a></li>
<li><a href="./E0500.html">E0500</a></li>
<li><a href="./E0501.html">E0501</a></li>
<li><a href="./E0502.html">E0502</a></li>
<li><a href="./E0503.html">E0503</a></li>
<li><a href="./E0504.html">E0504</a></li>
<li><a href="./E0505.html">E0505</a></li>
<li><a href="./E0506.html">E0506</a></li>
<li><a href="./E0507.html">E0507</a></li>
<li><a href="./E0508.html">E0508</a></li>
<li><a href="./E0509.html">E0509</a></li>
<li><a href="./E0510.html">E0510</a></li>
<li><a href="./E0511.html">E0511</a></li>
<li><a href="./E0512.html">E0512</a></li>
<li><a href="./E0514.html">E0514</a></li>
<li><a href="./E0515.html">E0515</a></li>
<li><a href="./E0516.html">E0516</a></li>
<li><a href="./E0517.html">E0517</a></li>
<li><a href="./E0518.html">E0518</a></li>
<li><a href="./E0519.html">E0519</a></li>
<li><a href="./E0520.html">E0520</a></li>
<li><a href="./E0521.html">E0521</a></li>
<li><a href="./E0522.html">E0522</a></li>
<li><a href="./E0523.html">E0523</a></li>
<li><a href="./E0524.html">E0524</a></li>
<li><a href="./E0525.html">E0525</a></li>
<li><a href="./E0527.html">E0527</a></li>
<li><a href="./E0528.html">E0528</a></li>
<li><a href="./E0529.html">E0529</a></li>
<li><a href="./E0530.html">E0530</a></li>
<li><a href="./E0531.html">E0531</a></li>
<li><a href="./E0532.html">E0532</a></li>
<li><a href="./E0533.html">E0533</a></li>
<li><a href="./E0534.html">E0534</a></li>
<li><a href="./E0535.html">E0535</a></li>
<li><a href="./E0536.html">E0536</a></li>
<li><a href="./E0537.html">E0537</a></li>
<li><a href="./E0538.html">E0538</a></li>
<li><a href="./E0539.html">E0539</a></li>
<li><a href="./E0541.html">E0541</a></li>
<li><a href="./E0542.html">E0542</a></li>
<li><a href="./E0543.html">E0543</a></li>
<li><a href="./E0544.html">E0544</a></li>
<li><a href="./E0545.html">E0545</a></li>
<li><a href="./E0546.html">E0546</a></li>
<li><a href="./E0547.html">E0547</a></li>
<li><a href="./E0549.html">E0549</a></li>
<li><a href="./E0550.html">E0550</a></li>
<li><a href="./E0551.html">E0551</a></li>
<li><a href="./E0552.html">E0552</a></li>
<li><a href="./E0554.html">E0554</a></li>
<li><a href="./E0556.html">E0556</a></li>
<li><a href="./E0557.html">E0557</a></li>
<li><a href="./E0559.html">E0559</a></li>
<li><a href="./E0560.html">E0560</a></li>
<li><a href="./E0561.html">E0561</a></li>
<li><a href="./E0562.html">E0562</a></li>
<li><a href="./E0565.html">E0565</a></li>
<li><a href="./E0566.html">E0566</a></li>
<li><a href="./E0567.html">E0567</a></li>
<li><a href="./E0568.html">E0568</a></li>
<li><a href="./E0569.html">E0569</a></li>
<li><a href="./E0570.html">E0570</a></li>
<li><a href="./E0571.html">E0571</a></li>
<li><a href="./E0572.html">E0572</a></li>
<li><a href="./E0573.html">E0573</a></li>
<li><a href="./E0574.html">E0574</a></li>
<li><a href="./E0575.html">E0575</a></li>
<li><a href="./E0576.html">E0576</a></li>
<li><a href="./E0577.html">E0577</a></li>
<li><a href="./E0578.html">E0578</a></li>
<li><a href="./E0579.html">E0579</a></li>
<li><a href="./E0580.html">E0580</a></li>
<li><a href="./E0581.html">E0581</a></li>
<li><a href="./E0582.html">E0582</a></li>
<li><a href="./E0583.html">E0583</a></li>
<li><a href="./E0584.html">E0584</a></li>
<li><a href="./E0585.html">E0585</a></li>
<li><a href="./E0586.html">E0586</a></li>
<li><a href="./E0587.html">E0587</a></li>
<li><a href="./E0588.html">E0588</a></li>
<li><a href="./E0589.html">E0589</a></li>
<li><a href="./E0590.html">E0590</a></li>
<li><a href="./E0591.html">E0591</a></li>
<li><a href="./E0592.html">E0592</a></li>
<li><a href="./E0593.html">E0593</a></li>
<li><a href="./E0594.html">E0594</a></li>
<li><a href="./E0595.html">E0595</a></li>
<li><a href="./E0596.html">E0596</a></li>
<li><a href="./E0597.html">E0597</a></li>
<li><a href="./E0599.html">E0599</a></li>
<li><a href="./E0600.html">E0600</a></li>
<li><a href="./E0601.html">E0601</a></li>
<li><a href="./E0602.html">E0602</a></li>
<li><a href="./E0603.html">E0603</a></li>
<li><a href="./E0604.html">E0604</a></li>
<li><a href="./E0605.html">E0605</a></li>
<li><a href="./E0606.html">E0606</a></li>
<li><a href="./E0607.html">E0607</a></li>
<li><a href="./E0608.html">E0608</a></li>
<li><a href="./E0609.html">E0609</a></li>
<li><a href="./E0610.html">E0610</a></li>
<li><a href="./E0614.html">E0614</a></li>
<li><a href="./E0615.html">E0615</a></li>
<li><a href="./E0616.html">E0616</a></li>
<li><a href="./E0617.html">E0617</a></li>
<li><a href="./E0618.html">E0618</a></li>
<li><a href="./E0619.html">E0619</a></li>
<li><a href="./E0620.html">E0620</a></li>
<li><a href="./E0621.html">E0621</a></li>
<li><a href="./E0622.html">E0622</a></li>
<li><a href="./E0623.html">E0623</a></li>
<li><a href="./E0624.html">E0624</a></li>
<li><a href="./E0625.html">E0625</a></li>
<li><a href="./E0626.html">E0626</a></li>
<li><a href="./E0627.html">E0627</a></li>
<li><a href="./E0628.html">E0628</a></li>
<li><a href="./E0631.html">E0631</a></li>
<li><a href="./E0632.html">E0632</a></li>
<li><a href="./E0633.html">E0633</a></li>
<li><a href="./E0634.html">E0634</a></li>
<li><a href="./E0635.html">E0635</a></li>
<li><a href="./E0636.html">E0636</a></li>
<li><a href="./E0637.html">E0637</a></li>
<li><a href="./E0638.html">E0638</a></li>
<li><a href="./E0639.html">E0639</a></li>
<li><a href="./E0640.html">E0640</a></li>
<li><a href="./E0641.html">E0641</a></li>
<li><a href="./E0642.html">E0642</a></li>
<li><a href="./E0643.html">E0643</a></li>
<li><a href="./E0644.html">E0644</a></li>
<li><a href="./E0646.html">E0646</a></li>
<li><a href="./E0647.html">E0647</a></li>
<li><a href="./E0648.html">E0648</a></li>
<li><a href="./E0657.html">E0657</a></li>
<li><a href="./E0658.html">E0658</a></li>
<li><a href="./E0659.html">E0659</a></li>
<li><a href="./E0660.html">E0660</a></li>
<li><a href="./E0661.html">E0661</a></li>
<li><a href="./E0662.html">E0662</a></li>
<li><a href="./E0663.html">E0663</a></li>
<li><a href="./E0664.html">E0664</a></li>
<li><a href="./E0665.html">E0665</a></li>
<li><a href="./E0666.html">E0666</a></li>
<li><a href="./E0667.html">E0667</a></li>
<li><a href="./E0668.html">E0668</a></li>
<li><a href="./E0669.html">E0669</a></li>
<li><a href="./E0670.html">E0670</a></li>
<li><a href="./E0671.html">E0671</a></li>
<li><a href="./E0687.html">E0687</a></li>
<li><a href="./E0688.html">E0688</a></li>
<li><a href="./E0689.html">E0689</a></li>
<li><a href="./E0690.html">E0690</a></li>
<li><a href="./E0691.html">E0691</a></li>
<li><a href="./E0692.html">E0692</a></li>
<li><a href="./E0693.html">E0693</a></li>
<li><a href="./E0695.html">E0695</a></li>
<li><a href="./E0696.html">E0696</a></li>
<li><a href="./E0697.html">E0697</a></li>
<li><a href="./E0698.html">E0698</a></li>
<li><a href="./E0699.html">E0699</a></li>
<li><a href="./E0700.html">E0700</a></li>
<li><a href="./E0701.html">E0701</a></li>
<li><a href="./E0703.html">E0703</a></li>
<li><a href="./E0704.html">E0704</a></li>
<li><a href="./E0705.html">E0705</a></li>
<li><a href="./E0706.html">E0706</a></li>
<li><a href="./E0708.html">E0708</a></li>
<li><a href="./E0710.html">E0710</a></li>
<li><a href="./E0712.html">E0712</a></li>
<li><a href="./E0713.html">E0713</a></li>
<li><a href="./E0714.html">E0714</a></li>
<li><a href="./E0715.html">E0715</a></li>
<li><a href="./E0716.html">E0716</a></li>
<li><a href="./E0711.html">E0711</a></li>
<li><a href="./E0717.html">E0717</a></li>
<li><a href="./E0718.html">E0718</a></li>
<li><a href="./E0719.html">E0719</a></li>
<li><a href="./E0720.html">E0720</a></li>
<li><a href="./E0722.html">E0722</a></li>
<li><a href="./E0724.html">E0724</a></li>
<li><a href="./E0725.html">E0725</a></li>
<li><a href="./E0726.html">E0726</a></li>
<li><a href="./E0727.html">E0727</a></li>
<li><a href="./E0728.html">E0728</a></li>
<li><a href="./E0729.html">E0729</a></li>
<li><a href="./E0730.html">E0730</a></li>
<li><a href="./E0731.html">E0731</a></li>
<li><a href="./E0732.html">E0732</a></li>
<li><a href="./E0733.html">E0733</a></li>
<li><a href="./E0734.html">E0734</a></li>
<li><a href="./E0735.html">E0735</a></li>
<li><a href="./E0736.html">E0736</a></li>
<li><a href="./E0737.html">E0737</a></li>
<li><a href="./E0739.html">E0739</a></li>
<li><a href="./E0740.html">E0740</a></li>
<li><a href="./E0741.html">E0741</a></li>
<li><a href="./E0742.html">E0742</a></li>
<li><a href="./E0743.html">E0743</a></li>
<li><a href="./E0744.html">E0744</a></li>
<li><a href="./E0745.html">E0745</a></li>
<li><a href="./E0746.html">E0746</a></li>
<li><a href="./E0747.html">E0747</a></li>
<li><a href="./E0748.html">E0748</a></li>
<li><a href="./E0749.html">E0749</a></li>
<li><a href="./E0750.html">E0750</a></li>
<li><a href="./E0751.html">E0751</a></li>
<li><a href="./E0752.html">E0752</a></li>
<li><a href="./E0753.html">E0753</a></li>
<li><a href="./E0754.html">E0754</a></li>
<li><a href="./E0755.html">E0755</a></li>
<li><a href="./E0756.html">E0756</a></li>
<li><a href="./E0757.html">E0757</a></li>
<li><a href="./E0758.html">E0758</a></li>
<li><a href="./E0759.html">E0759</a></li>
<li><a href="./E0760.html">E0760</a></li>
<li><a href="./E0761.html">E0761</a></li>
<li><a href="./E0762.html">E0762</a></li>
<li><a href="./E0763.html">E0763</a></li>
<li><a href="./E0764.html">E0764</a></li>
<li><a href="./E0765.html">E0765</a></li>
<li><a href="./E0766.html">E0766</a></li>
<li><a href="./E0767.html">E0767</a></li>
<li><a href="./E0768.html">E0768</a></li>
<li><a href="./E0769.html">E0769</a></li>
<li><a href="./E0770.html">E0770</a></li>
<li><a href="./E0771.html">E0771</a></li>
<li><a href="./E0772.html">E0772</a></li>
<li><a href="./E0773.html">E0773</a></li>
<li><a href="./E0774.html">E0774</a></li>
<li><a href="./E0775.html">E0775</a></li>
<li><a href="./E0776.html">E0776</a></li>
<li><a href="./E0777.html">E0777</a></li>
<li><a href="./E0778.html">E0778</a></li>
<li><a href="./E0779.html">E0779</a></li>
<li><a href="./E0780.html">E0780</a></li>
<li><a href="./E0781.html">E0781</a></li>
<li><a href="./E0782.html">E0782</a></li>
<li><a href="./E0783.html">E0783</a></li>
<li><a href="./E0784.html">E0784</a></li>
<li><a href="./E0785.html">E0785</a></li>
<li><a href="./E0786.html">E0786</a></li>
<li><a href="./E0787.html">E0787</a></li>
<li><a href="./E0788.html">E0788</a></li>
<li><a href="./E0789.html">E0789</a></li>
<li><a href="./E0790.html">E0790</a></li>
<li><a href="./E0791.html">E0791</a></li>
<li><a href="./E0792.html">E0792</a></li>
<li><a href="./E0793.html">E0793</a></li>
<li><a href="./E0794.html">E0794</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0001"><a class="header" href="#error-code-e0001">Error code E0001</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error suggests that the expression arm corresponding to the noted pattern
will never be reached as for all possible values of the expression being
matched, one of the preceding patterns will match.</p>
<p>This means that perhaps some of the preceding patterns are too general, this
one is too specific or the ordering is incorrect.</p>
<p>For example, the following <code>match</code> block has too many arms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(0) {
    Some(bar) =&gt; {/* ... */}
    x =&gt; {/* ... */} // This handles the `None` case
    _ =&gt; {/* ... */} // All possible cases have already been handled
}
<span class="boring">}</span></code></pre></pre>
<p><code>match</code> blocks have their patterns matched in order, so, for example, putting
a wildcard arm above a more specific arm will make the latter arm irrelevant.</p>
<p>Ensure the ordering of the match arm is correct and remove any superfluous
arms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0002"><a class="header" href="#error-code-e0002">Error code E0002</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-1"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-1">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that an empty match expression is invalid because the type
it is matching on is non-empty (there exist values of this type). In safe code
it is impossible to create an instance of an empty type, so empty match
expressions are almost never desired. This error is typically fixed by adding
one or more cases to the match expression.</p>
<p>An example of an empty type is <code>enum Empty { }</code>. So, the following will work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Empty {}

fn foo(x: Empty) {
    match x {
        // empty
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, this won't:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: Option&lt;String&gt;) {
    match x {
        // empty
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0004"><a class="header" href="#error-code-e0004">Error code E0004</a></h1>
<p>This error indicates that the compiler cannot guarantee a matching pattern for
one or more possible inputs to a match expression. Guaranteed matches are
required in order to assign values to match expressions, or alternatively,
determine the flow of execution.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0004"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered
    Terminator::TalkToMyHand =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>If you encounter this error you must alter your patterns so that every possible
value of the input type is matched. For types with a small number of variants
(like enums) you should probably cover all cases explicitly. Alternatively, the
underscore <code>_</code> wildcard pattern can be added after all other patterns to match
&quot;anything else&quot;. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Terminator {
    HastaLaVistaBaby,
    TalkToMyHand,
}

let x = Terminator::HastaLaVistaBaby;

match x {
    Terminator::TalkToMyHand =&gt; {}
    Terminator::HastaLaVistaBaby =&gt; {}
}

// or:

match x {
    Terminator::TalkToMyHand =&gt; {}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0005"><a class="header" href="#error-code-e0005">Error code E0005</a></h1>
<p>Patterns used to bind names must be irrefutable, that is, they must guarantee
that a name will be extracted in all cases.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0005"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);
let Some(y) = x;
// error: refutable pattern in local binding: `None` not covered
<span class="boring">}</span></code></pre></pre>
<p>If you encounter this error you probably need to use a <code>match</code> or <code>if let</code> to
deal with the possibility of failure. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);

match x {
    Some(y) =&gt; {
        // do something
    },
    None =&gt; {}
}

// or:

if let Some(y) = x {
    // do something
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0007"><a class="header" href="#error-code-e0007">Error code E0007</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-2"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-2">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that the bindings in a match arm would require a value to
be moved into more than one location, thus violating unique ownership. Code
like the following is invalid as it requires the entire <code>Option&lt;String&gt;</code> to be
moved into a variable called <code>op_string</code> while simultaneously requiring the
inner <code>String</code> to be moved into a variable called <code>s</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382"><span class="boring">#![allow(unused)]
</span>#![feature(bindings_after_at)]

<span class="boring">fn main() {
</span>let x = Some(&quot;s&quot;.to_string());

match x {
    op_string @ Some(s) =&gt; {}, // error: use of moved value
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>See also the error E0303.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0009"><a class="header" href="#error-code-e0009">Error code E0009</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-3"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-3">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In a pattern, all values that don't implement the <code>Copy</code> trait have to be bound
the same way. The goal here is to avoid binding simultaneously by-move and
by-ref.</p>
<p>This limitation may be removed in a future version of Rust.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(move_ref_pattern)]

<span class="boring">fn main() {
</span>struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {}, // error: cannot bind by-move and by-ref in the
                            //        same pattern
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<p>You have two solutions:</p>
<p>Solution #1: Bind the pattern's values the same way.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((ref y, ref z)) =&gt; {},
    // or Some((y, z)) =&gt; {}
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<p>Solution #2: Implement the <code>Copy</code> trait for the <code>X</code> structure.</p>
<p>However, please keep in mind that the first solution should be preferred.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct X { x: (), }

let x = Some((X { x: () }, X { x: () }));
match x {
    Some((y, ref z)) =&gt; {},
    None =&gt; panic!()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0010"><a class="header" href="#error-code-e0010">Error code E0010</a></h1>
<p>The value of statics and constants must be known at compile time, and they live
for the entire lifetime of a program. Creating a boxed value allocates memory on
the heap at runtime, and therefore cannot be done at compile time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0010"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CON : Vec&lt;i32&gt; = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0013"><a class="header" href="#error-code-e0013">Error code E0013</a></h1>
<p>Static and const variables can refer to other const variables. But a const
variable cannot refer to a static variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0013"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static X: i32 = 42;
const Y: i32 = X;
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>Y</code> cannot refer to <code>X</code>. To fix this, the value can be
extracted as a const and then used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const A: i32 = 42;
static X: i32 = A;
const Y: i32 = A;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0014"><a class="header" href="#error-code-e0014">Error code E0014</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-4"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-4">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Constants can only be initialized by a constant value or, in a future
version of Rust, a call to a const function. This error indicates the use
of a path (like a::b, or x) denoting something other than one of these
allowed items.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!
<span class="boring">}</span></code></pre></pre>
<p>To avoid it, you have to replace the non-constant value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: i32 = { const X : i32 = 0; X };
// or even:
const FOO2: i32 = { 0 }; // but brackets are useless here
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0015"><a class="header" href="#error-code-e0015">Error code E0015</a></h1>
<p>A non-<code>const</code> function was called in a <code>const</code> context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0015"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_some() -&gt; Option&lt;u8&gt; {
    Some(1)
}

// error: cannot call non-const fn `create_some` in constants
const FOO: Option&lt;u8&gt; = create_some();
<span class="boring">}</span></code></pre></pre>
<p>All functions used in a <code>const</code> context (constant or static expression) must
be marked <code>const</code>.</p>
<p>To fix this error, you can declare <code>create_some</code> as a constant function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// declared as a `const` function:
const fn create_some() -&gt; Option&lt;u8&gt; {
    Some(1)
}

const FOO: Option&lt;u8&gt; = create_some(); // no error!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0023"><a class="header" href="#error-code-e0023">Error code E0023</a></h1>
<p>A pattern attempted to extract an incorrect number of fields from a variant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0023"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

match x {
    Fruit::Apple(a) =&gt; {}, // error!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>A pattern used to match against an enum variant must provide a sub-pattern for
each field of the enum variant.</p>
<p>Here the <code>Apple</code> variant has two fields, and should be matched against like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Correct.
match x {
    Fruit::Apple(a, b) =&gt; {},
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>Matching with the wrong number of fields has no sensible interpretation:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0023"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Fruit {
    Apple(String, String),
    Pear(u32),
}

let x = Fruit::Apple(String::new(), String::new());

// Incorrect.
match x {
    Fruit::Apple(a) =&gt; {},
    Fruit::Apple(a, b, c) =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>Check how many fields the enum was declared with and ensure that your pattern
uses the same number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0025"><a class="header" href="#error-code-e0025">Error code E0025</a></h1>
<p>Each field of a struct can only be bound once in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0025">struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, a: y } = x;
    // error: field `a` bound multiple times in the pattern
}</code></pre></pre>
<p>Each occurrence of a field name binds the value of that field, so to fix this
error you will have to remove or alter the duplicate uses of the field name.
Perhaps you misspelled another field name? Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    a: u8,
    b: u8,
}

fn main(){
    let x = Foo { a:1, b:2 };

    let Foo { a: x, b: y } = x; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0026"><a class="header" href="#error-code-e0026">Error code E0026</a></h1>
<p>A struct pattern attempted to extract a nonexistent field from a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0026"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, z } =&gt; {} // error: `Thing::z` field doesn't exist
}
<span class="boring">}</span></code></pre></pre>
<p>If you are using shorthand field patterns but want to refer to the struct field
by a different name, you should rename it explicitly. Struct fields are
identified by the name used before the colon <code>:</code> so struct patterns should
resemble the declaration of the struct type being matched.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thing {
    x: u32,
    y: u32,
}

let thing = Thing { x: 0, y: 0 };

match thing {
    Thing { x, y: z } =&gt; {} // we renamed `y` to `z`
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0027"><a class="header" href="#error-code-e0027">Error code E0027</a></h1>
<p>A pattern for a struct fails to specify a sub-pattern for every one of the
struct's fields.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0027"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: &quot;Rusty&quot;.to_string(), age: 8 };

// This is incorrect.
match d {
    Dog { age: x } =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure that each field from the struct's definition is
mentioned in the pattern, or use <code>..</code> to ignore unwanted fields. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Dog {
    name: String,
    age: u32,
}

let d = Dog { name: &quot;Rusty&quot;.to_string(), age: 8 };

match d {
    Dog { name: ref n, age: x } =&gt; {}
}

// This is also correct (ignore unused fields).
match d {
    Dog { age: x, .. } =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0029"><a class="header" href="#error-code-e0029">Error code E0029</a></h1>
<p>Something other than numbers and characters has been used for a range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0029"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let string = &quot;salutations !&quot;;

// The ordering relation for strings cannot be evaluated at compile time,
// so this doesn't work:
match string {
    &quot;hello&quot; ..= &quot;world&quot; =&gt; {}
    _ =&gt; {}
}

// This is a more general version, using a guard:
match string {
    s if s &gt;= &quot;hello&quot; &amp;&amp; s &lt;= &quot;world&quot; =&gt; {}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In a match expression, only numbers and characters can be matched against a
range. This is because the compiler checks that the range is non-empty at
compile-time, and is unable to evaluate arbitrary comparison functions. If you
want to capture values of an orderable type between two end-points, you can use
a guard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0030"><a class="header" href="#error-code-e0030">Error code E0030</a></h1>
<p>When matching against a range, the compiler verifies that the range is
non-empty. Range patterns include both end-points, so this is equivalent to
requiring the start of the range to be less than or equal to the end of the
range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0030"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 5u32 {
    // This range is ok, albeit pointless.
    1 ..= 1 =&gt; {}
    // This range is empty, and the compiler can tell.
    1000 ..= 5 =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0033"><a class="header" href="#error-code-e0033">Error code E0033</a></h1>
<p>A trait type has been dereferenced.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0033"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait { fn method_one(&amp;self){} fn method_two(&amp;self){} }
</span><span class="boring">impl&lt;T&gt; SomeTrait for T {}
</span>let trait_obj: &amp;SomeTrait = &amp;&quot;some_value&quot;;

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();
<span class="boring">}</span></code></pre></pre>
<p>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every
trait defines a type, but because the size of trait implementers isn't fixed,
this type has no compile-time size. Therefore, all accesses to trait types must
be through pointers. If you encounter this error you should try to avoid
dereferencing the pointer.</p>
<p>You can read more about trait objects in the <a href="https://doc.rust-lang.org/reference/types.html#trait-objects">Trait Objects</a> section of the
Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0034"><a class="header" href="#error-code-e0034">Error code E0034</a></h1>
<p>The compiler doesn't know what method to call because more than one method
has the same prototype.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0034">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}</code></pre></pre>
<p>To avoid this error, you have to keep only one of them and remove the others.
So let's take our example and fix it:</p>
<pre><pre class="playground"><code class="language-rust">struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</code></pre></pre>
<p>However, a better solution would be using fully explicit naming of type and
trait:</p>
<pre><pre class="playground"><code class="language-rust">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</code></pre></pre>
<p>One last example:</p>
<pre><pre class="playground"><code class="language-rust">trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!(&quot;I am F&quot;); } }
impl G for X { fn m(&amp;self) { println!(&quot;I am G&quot;); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays &quot;I am F&quot;
    G::m(&amp;f); // it displays &quot;I am G&quot;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0038"><a class="header" href="#error-code-e0038">Error code E0038</a></h1>
<p>For any given trait <code>Trait</code> there may be a related <em>type</em> called the <em>trait
object type</em> which is typically written as <code>dyn Trait</code>. In earlier editions of
Rust, trait object types were written as plain <code>Trait</code> (just the name of the
trait, written in type positions) but this was a bit too confusing, so we now
write <code>dyn Trait</code>.</p>
<p>Some traits are not allowed to be used as trait object types. The traits that
are allowed to be used as trait object types are called &quot;object-safe&quot; traits.
Attempting to use a trait object type for a trait that is not object-safe will
trigger error E0038.</p>
<p>Two general aspects of trait object types give rise to the restrictions:</p>
<ol>
<li>
<p>Trait object types are dynamically sized types (DSTs), and trait objects of
these types can only be accessed through pointers, such as <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code>. The size of such a pointer is known, but the size of the
<code>dyn Trait</code> object pointed-to by the pointer is <em>opaque</em> to code working
with it, and different trait objects with the same trait object type may
have different sizes.</p>
</li>
<li>
<p>The pointer used to access a trait object is paired with an extra pointer
to a &quot;virtual method table&quot; or &quot;vtable&quot;, which is used to implement dynamic
dispatch to the object's implementations of the trait's methods. There is a
single such vtable for each trait implementation, but different trait
objects with the same trait object type may point to vtables from different
implementations.</p>
</li>
</ol>
<p>The specific conditions that violate object-safety follow, most of which relate
to missing size information and vtable polymorphism arising from these aspects.</p>
<h3 id="the-trait-requires-self-sized"><a class="header" href="#the-trait-requires-self-sized">The trait requires <code>Self: Sized</code></a></h3>
<p>Traits that are declared as <code>Trait: Sized</code> or which otherwise inherit a
constraint of <code>Self:Sized</code> are not object-safe.</p>
<p>The reasoning behind this is somewhat subtle. It derives from the fact that Rust
requires (and defines) that every trait object type <code>dyn Trait</code> automatically
implements <code>Trait</code>. Rust does this to simplify error reporting and ease
interoperation between static and dynamic polymorphism. For example, this code
works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
}

fn static_foo&lt;T:Trait + ?Sized&gt;(b: &amp;T) {
}

fn dynamic_bar(a: &amp;dyn Trait) {
    static_foo(a)
}
<span class="boring">}</span></code></pre></pre>
<p>This code works because <code>dyn Trait</code>, if it exists, always implements <code>Trait</code>.</p>
<p>However as we know, any <code>dyn Trait</code> is also unsized, and so it can never
implement a sized trait like <code>Trait:Sized</code>. So, rather than allow an exception
to the rule that <code>dyn Trait</code> always implements <code>Trait</code>, Rust chooses to prohibit
such a <code>dyn Trait</code> from existing at all.</p>
<p>Only unsized traits are considered object-safe.</p>
<p>Generally, <code>Self: Sized</code> is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.</p>
<h3 id="method-references-the-self-type-in-its-parameters-or-return-type"><a class="header" href="#method-references-the-self-type-in-its-parameters-or-return-type">Method references the <code>Self</code> type in its parameters or return type</a></h3>
<p>This happens when a trait has a method like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        &quot;hi&quot;.to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}
<span class="boring">}</span></code></pre></pre>
<p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which
cause this problem.)</p>
<p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a
situation like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;dyn Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>If only some methods aren't object-safe, you can add a <code>where Self: Sized</code> bound
on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
<code>Box&lt;dyn Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;dyn Trait&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any object-safe
methods. With such a bound, one can still call <code>foo()</code> on types implementing
that trait that aren't behind trait objects.</p>
<h3 id="method-has-generic-type-parameters"><a class="header" href="#method-has-generic-type-parameters">Method has generic type parameters</a></h3>
<p>As mentioned before, trait objects contain pointers to method tables. So, if we
have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>At compile time each implementation of <code>Trait</code> will produce a table containing
the various methods (and other items) related to the implementation, which will
be used as the virtual method table for a <code>dyn Trait</code> object derived from that
implementation.</p>
<p>This works fine, but when the method gains generic parameters, we can have a
problem.</p>
<p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any
other type substitution is different. Hence the compiler generates the
implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the
compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with unparameterized substitutions
(i.e., substitutions where none of the substituted types are themselves
parameterized).</p>
<p>However, with trait objects we have to make a table containing <em>every</em> object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.</p>
<p>For example, with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations
<span class="boring">}</span></code></pre></pre>
<p>Now, if we have the following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait { fn foo&lt;T&gt;(&amp;self, on: T); }
</span><span class="boring">impl Trait for String { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for u8 { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for bool { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">// etc.
</span>fn call_foo(thing: Box&lt;dyn Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo(&quot;hello&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>We don't just need to create a table of all implementations of all methods of
<code>Trait</code>, we need to create such a table, for each different type fed to
<code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3
types being fed to <code>foo()</code>) = 30 implementations!</p>
<p>With real world traits these numbers can grow drastically.</p>
<p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}
<span class="boring">}</span></code></pre></pre>
<p>If this is not an option, consider replacing the type parameter with another
trait object (e.g., if <code>T: OtherTrait</code>, use <code>on: Box&lt;dyn OtherTrait&gt;</code>). If the
number of types you intend to feed to this method is limited, consider manually
listing out the methods of different types.</p>
<h3 id="method-has-no-receiver"><a class="header" href="#method-has-no-receiver">Method has no receiver</a></h3>
<p>Methods that do not take a <code>self</code> parameter can't be called since there won't be
a way to get a pointer to the method table for them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8;
}
<span class="boring">}</span></code></pre></pre>
<p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick
an implementation.</p>
<p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-contains-associated-constants"><a class="header" href="#trait-contains-associated-constants">Trait contains associated constants</a></h3>
<p>Just like static functions, associated constants aren't stored on the method
table. If the trait or any subtrait contain an associated constant, they cannot
be made into an object.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const X: i32;
}

impl Foo {}
<span class="boring">}</span></code></pre></pre>
<p>A simple workaround is to use a helper method instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn x(&amp;self) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-uses-self-as-a-type-parameter-in-the-supertrait-listing"><a class="header" href="#trait-uses-self-as-a-type-parameter-in-the-supertrait-listing">Trait uses <code>Self</code> as a type parameter in the supertrait listing</a></h3>
<p>This is similar to the second sub-error, but subtler. It happens in situations
like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038">trait Super&lt;A: ?Sized&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}

fn main() {
    let x: Box&lt;dyn Trait&gt;;
}</code></pre></pre>
<p>Here, the supertrait might have methods as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Super&lt;A: ?Sized&gt; {
    fn get_a(&amp;self) -&gt; &amp;A; // note that this is object safe!
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait <code>Trait</code> was deriving from something like <code>Super&lt;String&gt;</code> or
<code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type
<code>get_a()</code> will definitely return an object of that type.</p>
<p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is object safe,
the method <code>get_a()</code> would return an object of unknown type when called on the
function. <code>Self</code> type parameters let us make object safe traits no longer safe,
so they are forbidden when specifying supertraits.</p>
<p>There's no easy fix for this. Generally, code will need to be refactored so that
you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0040"><a class="header" href="#error-code-e0040">Error code E0040</a></h1>
<p>It is not allowed to manually call destructors in Rust.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0040">struct Foo {
    x: i32,
}

impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;kaboom&quot;);
    }
}

fn main() {
    let mut x = Foo { x: -7 };
    x.drop(); // error: explicit use of destructor method
}</code></pre></pre>
<p>It is unnecessary to do this since <code>drop</code> is called automatically whenever a
value goes out of scope. However, if you really need to drop a value by hand,
you can use the <code>std::mem::drop</code> function:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) {
        println!(&quot;kaboom&quot;);
    }
}
fn main() {
    let mut x = Foo { x: -7 };
    drop(x); // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0044"><a class="header" href="#error-code-e0044">Error code E0044</a></h1>
<p>You cannot use type or const parameters on foreign items.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0044"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; { fn some_func&lt;T&gt;(x: T); }
<span class="boring">}</span></code></pre></pre>
<p>To fix this, replace the generic parameter with the specializations that you
need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; { fn some_func_i32(x: i32); }
extern &quot;C&quot; { fn some_func_i64(x: i64); }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0045"><a class="header" href="#error-code-e0045">Error code E0045</a></h1>
<p>Variadic parameters have been used on a non-C ABI function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0045"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;Rust&quot; {
    fn foo(x: u8, ...); // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Rust only supports variadic parameters for interoperability with C code in its
FFI. As such, variadic parameters can only be used with functions which are
using the C ABI. To fix such code, put them in an extern &quot;C&quot; block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo (x: u8, ...);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0046"><a class="header" href="#error-code-e0046">Error code E0046</a></h1>
<p>Items are missing in a trait implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0046"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {}
// error: not all trait items implemented, missing: `foo`
<span class="boring">}</span></code></pre></pre>
<p>When trying to make some type implement a trait <code>Foo</code>, you must, at minimum,
provide implementations for all of <code>Foo</code>'s required methods (meaning the
methods that do not have default implementations), as well as any required
trait items like associated types or constants. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0049"><a class="header" href="#error-code-e0049">Error code E0049</a></h1>
<p>An attempted implementation of a trait method has the wrong number of type or
const parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0049"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

// error: method `foo` has 0 type parameters but its trait declaration has 1
// type parameter
impl Foo for Bar {
    fn foo(x: bool) -&gt; Self { Bar }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, the <code>Foo</code> trait has a method <code>foo</code> with a type parameter <code>T</code>,
but the implementation of <code>foo</code> for the type <code>Bar</code> is missing this parameter.
To fix this error, they must have the same type parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self;
}

struct Bar;

impl Foo for Bar {
    fn foo&lt;T: Default&gt;(x: T) -&gt; Self { // ok!
        Bar
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0050"><a class="header" href="#error-code-e0050">Error code E0050</a></h1>
<p>An attempted implementation of a trait method has the wrong number of function
parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0050"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`
// has 2
impl Foo for Bar {
    fn foo(&amp;self) -&gt; bool { true }
}
<span class="boring">}</span></code></pre></pre>
<p>For example, the <code>Foo</code> trait has a method <code>foo</code> with two function parameters
(<code>&amp;self</code> and <code>u8</code>), but the implementation of <code>foo</code> for the type <code>Bar</code> omits
the <code>u8</code> parameter. To fix this error, they must have the same parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, x: u8) -&gt; bool;
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self, x: u8) -&gt; bool { // ok!
        true
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0053"><a class="header" href="#error-code-e0053">Error code E0053</a></h1>
<p>The parameters of any trait method must match between a trait implementation
and the trait definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0053"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(x: u16);
    fn bar(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, expected u16, found i16
    fn foo(x: i16) { }

    // error, types differ in mutability
    fn bar(&amp;mut self) { }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0054"><a class="header" href="#error-code-e0054">Error code E0054</a></h1>
<p>It is not allowed to cast to a bool.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0054"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

// Not allowed, won't compile
let x_is_nonzero = x as bool;
<span class="boring">}</span></code></pre></pre>
<p>If you are trying to cast a numeric type to a bool, you can compare it with
zero instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

// Ok
let x_is_nonzero = x != 0;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0055"><a class="header" href="#error-code-e0055">Error code E0055</a></h1>
<p>During a method call, a value is automatically dereferenced as many times as
needed to make the value's type match the method's receiver. The catch is that
the compiler will only attempt to dereference a number of times up to the
recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p>
<p>For a somewhat artificial example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0055">#![recursion_limit=&quot;4&quot;]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;&amp;&amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing `&amp;&amp;&amp;&amp;&amp;Foo`
    ref_foo.foo();
}</code></pre></pre>
<p>One fix may be to increase the recursion limit. Note that it is possible to
create an infinite recursion of dereferencing, in which case the only fix is to
somehow break the recursion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0057"><a class="header" href="#error-code-e0057">Error code E0057</a></h1>
<p>An invalid number of arguments was given when calling a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0057"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = |x| x * 3;
let a = f();        // invalid, too few parameters
let b = f(4);       // this works!
let c = f(2, 3);    // invalid, too many parameters
<span class="boring">}</span></code></pre></pre>
<p>When invoking closures or other implementations of the function traits <code>Fn</code>,
<code>FnMut</code> or <code>FnOnce</code> using call notation, the number of parameters passed to the
function must match its definition.</p>
<p>A generic function must be treated similarly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F: Fn()&gt;(f: F) {
    f(); // this is valid, but f(3) would not work
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0059"><a class="header" href="#error-code-e0059">Error code E0059</a></h1>
<p>The built-in function traits are generic over a tuple of the function arguments.
If one uses angle-bracket notation (<code>Fn&lt;(T,), Output=U&gt;</code>) instead of parentheses
(<code>Fn(T) -&gt; U</code>) to denote the function trait, the type parameter should be a
tuple. Otherwise function call notation cannot be used and the trait will not be
implemented by closures.</p>
<p>The most likely source of this error is using angle-bracket notation without
wrapping the function argument type into a tuple, for example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0059"><span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures)]

<span class="boring">fn main() {
</span>fn foo&lt;F: Fn&lt;i32&gt;&gt;(f: F) -&gt; F::Output { f(3) }
<span class="boring">}</span></code></pre></pre>
<p>It can be fixed by adjusting the trait bound like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(unboxed_closures)]

<span class="boring">fn main() {
</span>fn foo&lt;F: Fn&lt;(i32,)&gt;&gt;(f: F) -&gt; F::Output { f(3) }
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>(T,)</code> always denotes the type of a 1-tuple containing an element of
type <code>T</code>. The comma is necessary for syntactic disambiguation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0060"><a class="header" href="#error-code-e0060">Error code E0060</a></h1>
<p>External C functions are allowed to be variadic. However, a variadic function
takes a minimum number of arguments. For example, consider C's variadic <code>printf</code>
function:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0060"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::raw::{c_char, c_int};

extern &quot;C&quot; {
    fn printf(_: *const c_char, ...) -&gt; c_int;
}

unsafe { printf(); } // error!
<span class="boring">}</span></code></pre></pre>
<p>Using this declaration, it must be called with at least one argument, so
simply calling <code>printf()</code> is invalid. But the following uses are allowed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::os::raw::{c_char, c_int};
</span><span class="boring">#[cfg_attr(all(windows, target_env = &quot;msvc&quot;),
</span><span class="boring">           link(name = &quot;legacy_stdio_definitions&quot;,
</span><span class="boring">                kind = &quot;static&quot;, modifiers = &quot;-bundle&quot;))]
</span><span class="boring">extern &quot;C&quot; { fn printf(_: *const c_char, ...) -&gt; c_int; }
</span><span class="boring">fn main() {
</span>unsafe {
    use std::ffi::CString;

    let fmt = CString::new(&quot;test\n&quot;).unwrap();
    printf(fmt.as_ptr());

    let fmt = CString::new(&quot;number = %d\n&quot;).unwrap();
    printf(fmt.as_ptr(), 3);

    let fmt = CString::new(&quot;%d, %d\n&quot;).unwrap();
    printf(fmt.as_ptr(), 10, 5);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0061"><a class="header" href="#error-code-e0061">Error code E0061</a></h1>
<p>An invalid number of arguments was passed when calling a function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0061"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(u: i32) {}

f(); // error!
<span class="boring">}</span></code></pre></pre>
<p>The number of arguments passed to a function must match the number of arguments
specified in the function signature.</p>
<p>For example, a function like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(a: u16, b: &amp;str) {}
<span class="boring">}</span></code></pre></pre>
<p>Must always be called with exactly two arguments, e.g., <code>f(2, &quot;test&quot;)</code>.</p>
<p>Note that Rust does not have a notion of optional function arguments or
variadic functions (except for its C-FFI).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0062"><a class="header" href="#error-code-e0062">Error code E0062</a></h1>
<p>A struct's or struct-like enum variant's field was specified more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0062">struct Foo {
    x: i32,
}

fn main() {
    let x = Foo {
                x: 0,
                x: 0, // error: field `x` specified more than once
            };
}</code></pre></pre>
<p>This error indicates that during an attempt to build a struct or struct-like
enum variant, one of the fields was specified more than once. Each field should
be specified exactly one time. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
}

fn main() {
    let x = Foo { x: 0 }; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0063"><a class="header" href="#error-code-e0063">Error code E0063</a></h1>
<p>A struct's or struct-like enum variant's field was not provided.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0063">struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0 }; // error: missing field: `y`
}</code></pre></pre>
<p>Each field should be specified exactly once. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: i32,
    y: i32,
}

fn main() {
    let x = Foo { x: 0, y: 0 }; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0067"><a class="header" href="#error-code-e0067">Error code E0067</a></h1>
<p>An invalid left-hand side expression was used on an assignment operation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0067"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>12 += 1; // error!
<span class="boring">}</span></code></pre></pre>
<p>You need to have a place expression to be able to assign it something. For
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i8 = 12;
x += 1; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0069"><a class="header" href="#error-code-e0069">Error code E0069</a></h1>
<p>The compiler found a function whose body contains a <code>return;</code> statement but
whose return type is not <code>()</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0069"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error
fn foo() -&gt; u8 {
    return;
}
<span class="boring">}</span></code></pre></pre>
<p>Since <code>return;</code> is just like <code>return ();</code>, there is a mismatch between the
function's return type and the value being returned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0070"><a class="header" href="#error-code-e0070">Error code E0070</a></h1>
<p>An assignment operator was used on a non-place expression.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0070"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    x: i32,
    y: i32,
}

const SOME_CONST: i32 = 12;

fn some_other_func() {}

fn some_function() {
    SOME_CONST = 14; // error: a constant value cannot be changed!
    1 = 3; // error: 1 isn't a valid place!
    some_other_func() = 4; // error: we cannot assign value to a function!
    SomeStruct::x = 12; // error: SomeStruct a structure name but it is used
                        //        like a variable!
}
<span class="boring">}</span></code></pre></pre>
<p>The left-hand side of an assignment operator must be a place expression. A
place expression represents a memory location and can be a variable (with
optional namespacing), a dereference, an indexing expression or a field
reference.</p>
<p>More details can be found in the <a href="https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries">Expressions</a> section of the Reference.</p>
<p>And now let's give working examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    x: i32,
    y: i32,
}
let mut s = SomeStruct { x: 0, y: 0 };

s.x = 3; // that's good !

// ...

fn some_func(x: &amp;mut i32) {
    *x = 12; // that's good !
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0071"><a class="header" href="#error-code-e0071">Error code E0071</a></h1>
<p>A structure-literal syntax was used to create an item that is not a structure
or enum variant.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0071"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type U32 = u32;
let t = U32 { value: 4 }; // error: expected struct, variant or union type,
                          // found builtin type `u32`
<span class="boring">}</span></code></pre></pre>
<p>To fix this, ensure that the name was correctly spelled, and that the correct
form of initializer was used.</p>
<p>For example, the code above can be fixed to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type U32 = u32;
let t: U32 = 4;
<span class="boring">}</span></code></pre></pre>
<p>or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct U32 { value: u32 }
let t = U32 { value: 4 };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0072"><a class="header" href="#error-code-e0072">Error code E0072</a></h1>
<p>A recursive type has infinite size because it doesn't have an indirection.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0072"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;, // error: no indirection here so impossible to
                            //        compute the type's size
}
<span class="boring">}</span></code></pre></pre>
<p>When defining a recursive struct or enum, any use of the type being defined
from inside the definition must occur behind a pointer (like <code>Box</code>, <code>&amp;</code> or
<code>Rc</code>). This is because structs and enums must have a well-defined size, and
without the pointer, the size of the type would need to be unbounded.</p>
<p>In the example, the type cannot have a well-defined size, because it needs to be
arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth).
Specifically,</p>
<pre><code class="language-plain">size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</code></pre>
<p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This works because <code>Box</code> is a pointer, so its size is well-known.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0073"><a class="header" href="#error-code-e0073">Error code E0073</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-5"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-5">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You cannot define a struct (or enum) <code>Foo</code> that requires an instance of <code>Foo</code>
in order to make a new <code>Foo</code> value. This is because there would be no way a
first instance of <code>Foo</code> could be made to initialize another instance!</p>
<p>Here's an example of a struct that has this problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: Box&lt;Foo&gt; } // error
<span class="boring">}</span></code></pre></pre>
<p>One fix is to use <code>Option</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: Option&lt;Box&lt;Foo&gt;&gt; }
<span class="boring">}</span></code></pre></pre>
<p>Now it's possible to create at least one instance of <code>Foo</code>: <code>Foo { x: None }</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0074"><a class="header" href="#error-code-e0074">Error code E0074</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-6"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-6">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the components of the
tuple struct must all be of a concrete, nongeneric type so the compiler can
reason about how to use SIMD with them. This error will occur if the types
are generic.</p>
<p>This will cause an error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad&lt;T&gt;(T, T, T, T);
<span class="boring">}</span></code></pre></pre>
<p>This will not:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good(u32, u32, u32, u32);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0075"><a class="header" href="#error-code-e0075">Error code E0075</a></h1>
<p>A <code>#[simd]</code> attribute was applied to an empty tuple struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0075"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad; // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[simd]</code> attribute can only be applied to non empty tuple structs, because
it doesn't make sense to try to use SIMD operations when there are no values to
operate on.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good(u32); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0076"><a class="header" href="#error-code-e0076">Error code E0076</a></h1>
<p>All types in a tuple struct aren't the same when using the <code>#[simd]</code>
attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0076"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad(u16, u32, u32 u32); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using the <code>#[simd]</code> attribute to automatically use SIMD operations in tuple
struct, the types in the struct must all be of the same type, or the compiler
will trigger this error.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good(u32, u32, u32, u32); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0077"><a class="header" href="#error-code-e0077">Error code E0077</a></h1>
<p>A tuple struct's element isn't a machine type when using the <code>#[simd]</code>
attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0077"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Bad(String); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using the <code>#[simd]</code> attribute on a tuple struct, the elements in the tuple
must be machine types so SIMD operations can be applied to them.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]

<span class="boring">fn main() {
</span>#[repr(simd)]
struct Good(u32, u32, u32, u32); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0080"><a class="header" href="#error-code-e0080">Error code E0080</a></h1>
<p>A constant value failed to get evaluated.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0080"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    X = (1 &lt;&lt; 500),
    Y = (1 / 0),
}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the compiler was unable to sensibly evaluate a
constant expression that had to be evaluated. Attempting to divide by 0
or causing an integer overflow are two ways to induce this error.</p>
<p>Ensure that the expressions given can be evaluated as the desired integer type.</p>
<p>See the <a href="https://doc.rust-lang.org/reference/items/enumerations.html#discriminants">Discriminants</a> section of the Reference for more information about
setting custom integer types on enums using the
<a href="https://doc.rust-lang.org/reference/type-layout.html#representations"><code>repr</code> attribute</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0081"><a class="header" href="#error-code-e0081">Error code E0081</a></h1>
<p>A discriminant value is present more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0081"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    P = 3,
    X = 3, // error!
    Y = 5,
}
<span class="boring">}</span></code></pre></pre>
<p>Enum discriminants are used to differentiate enum variants stored in memory.
This error indicates that the same value was used for two or more variants,
making it impossible to distinguish them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    P,
    X = 3, // ok!
    Y = 5,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that variants without a manually specified discriminant are numbered from
top to bottom starting from 0, so clashes can occur with seemingly unrelated
variants.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0081"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Bad {
    X,
    Y = 0, // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Here <code>X</code> will have already been specified the discriminant 0 by the time <code>Y</code> is
encountered, so a conflict occurs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0084"><a class="header" href="#error-code-e0084">Error code E0084</a></h1>
<p>An unsupported representation was attempted on a zero-variant enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0084"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i32)]
enum NightsWatch {} // error: unsupported representation for zero-variant enum
<span class="boring">}</span></code></pre></pre>
<p>It is impossible to define an integer type to be used to represent zero-variant
enum values because there are no zero-variant enum values. There is no way to
construct an instance of the following type using only safe code. So you have
two solutions. Either you add variants in your enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i32)]
enum NightsWatch {
    JonSnow,
    Commander,
}
<span class="boring">}</span></code></pre></pre>
<p>or you remove the integer representation of your enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum NightsWatch {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0087"><a class="header" href="#error-code-e0087">Error code E0087</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-7"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-7">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Too many type arguments were supplied for a function. For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T&gt;() {}

fn main() {
    foo::&lt;f64, bool&gt;(); // error: wrong number of type arguments:
                        //        expected 1, found 2
}</code></pre></pre>
<p>The number of supplied arguments must exactly match the number of defined type
parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0088"><a class="header" href="#error-code-e0088">Error code E0088</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-8"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-8">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You gave too many lifetime arguments. Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn f() {}

fn main() {
    f::&lt;'static&gt;() // error: wrong number of lifetime arguments:
                   //        expected 0, found 1
}</code></pre></pre>
<p>Please check you give the right number of lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn f() {}

fn main() {
    f() // ok!
}</code></pre></pre>
<p>It's also important to note that the Rust compiler can generally
determine the lifetime by itself. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    value: String
}

impl Foo {
    // it can be written like this
    fn get_value&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str { &amp;self.value }
    // but the compiler works fine with this too:
    fn without_lifetime(&amp;self) -&gt; &amp;str { &amp;self.value }
}

fn main() {
    let f = Foo { value: &quot;hello&quot;.to_owned() };

    println!(&quot;{}&quot;, f.get_value());
    println!(&quot;{}&quot;, f.without_lifetime());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0089"><a class="header" href="#error-code-e0089">Error code E0089</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-9"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-9">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Too few type arguments were supplied for a function. For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T, U&gt;() {}

fn main() {
    foo::&lt;f64&gt;(); // error: wrong number of type arguments: expected 2, found 1
}</code></pre></pre>
<p>Note that if a function takes multiple type arguments but you want the compiler
to infer some of them, you can use type placeholders:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;T, U&gt;(x: T) {}

fn main() {
    let x: bool = true;
    foo::&lt;f64&gt;(x);    // error: wrong number of type arguments:
                      //        expected 2, found 1
    foo::&lt;_, f64&gt;(x); // same as `foo::&lt;bool, f64&gt;(x)`
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0090"><a class="header" href="#error-code-e0090">Error code E0090</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-10"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-10">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You gave too few lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static&gt;(); // error: wrong number of lifetime arguments:
                      //        expected 2, found 1
}</code></pre></pre>
<p>Please check you give the right number of lifetime arguments. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;'a: 'b, 'b: 'a&gt;() {}

fn main() {
    foo::&lt;'static, 'static&gt;();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0091"><a class="header" href="#error-code-e0091">Error code E0091</a></h1>
<p>An unnecessary type or const parameter was given in a type alias.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0091"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T&gt; = u32; // error: type parameter `T` is unused
// or:
type Foo&lt;A,B&gt; = Box&lt;A&gt;; // error: type parameter `B` is unused
<span class="boring">}</span></code></pre></pre>
<p>Please check you didn't write too many parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = u32; // ok!
type Foo2&lt;A&gt; = Box&lt;A&gt;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0092"><a class="header" href="#error-code-e0092">Error code E0092</a></h1>
<p>An undefined atomic operation function was declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0092"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;rust-intrinsic&quot; {
    fn atomic_foo(); // error: unrecognized atomic operation
                     //        function
}
<span class="boring">}</span></code></pre></pre>
<p>Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in <code>compiler/rustc_codegen_llvm/src/intrinsic.rs</code> and in
<code>library/core/src/intrinsics.rs</code> in the Rust source code. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;rust-intrinsic&quot; {
    fn atomic_fence_seqcst(); // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0093"><a class="header" href="#error-code-e0093">Error code E0093</a></h1>
<p>An unknown intrinsic function was declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0093">#![feature(intrinsics)]

extern &quot;rust-intrinsic&quot; {
    fn foo(); // error: unrecognized intrinsic function: `foo`
}

fn main() {
    unsafe {
        foo();
    }
}</code></pre></pre>
<p>Please check you didn't make a mistake in the function's name. All intrinsic
functions are defined in <code>compiler/rustc_codegen_llvm/src/intrinsic.rs</code> and in
<code>library/core/src/intrinsics.rs</code> in the Rust source code. Example:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(intrinsics)]

extern &quot;rust-intrinsic&quot; {
    fn atomic_fence_seqcst(); // ok!
}

fn main() {
    unsafe {
        atomic_fence_seqcst();
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0094"><a class="header" href="#error-code-e0094">Error code E0094</a></h1>
<p>An invalid number of generic parameters was passed to an intrinsic function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0094"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;rust-intrinsic&quot; {
    #[rustc_safe_intrinsic]
    fn size_of&lt;T, U&gt;() -&gt; usize; // error: intrinsic has wrong number
                                 //        of type parameters
}
<span class="boring">}</span></code></pre></pre>
<p>Please check that you provided the right number of type parameters
and verify with the function declaration in the Rust source code.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;rust-intrinsic&quot; {
    #[rustc_safe_intrinsic]
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0106"><a class="header" href="#error-code-e0106">Error code E0106</a></h1>
<p>This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0106"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo1 { x: &amp;bool }
              // ^ expected lifetime parameter
struct Foo2&lt;'a&gt; { x: &amp;'a bool } // correct

struct Bar1 { x: Foo2 }
              // ^^^^ expected lifetime parameter
struct Bar2&lt;'a&gt; { x: Foo2&lt;'a&gt; } // correct

enum Baz1 { A(u8), B(&amp;bool), }
                  // ^ expected lifetime parameter
enum Baz2&lt;'a&gt; { A(u8), B(&amp;'a bool), } // correct

type MyStr1 = &amp;str;
           // ^ expected lifetime parameter
type MyStr2&lt;'a&gt; = &amp;'a str; // correct
<span class="boring">}</span></code></pre></pre>
<p>Lifetime elision is a special, limited kind of inference for lifetimes in
function signatures which allows you to leave out lifetimes in certain cases.
For more background on lifetime elision see <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">the book</a>.</p>
<p>The lifetime elision rules require that any function signature with an elided
output lifetime must either have:</p>
<ul>
<li>exactly one input lifetime</li>
<li>or, multiple input lifetimes, but the function must also be a method with a
<code>&amp;self</code> or <code>&amp;mut self</code> receiver</li>
</ul>
<p>In the first case, the output lifetime is inferred to be the same as the unique
input lifetime. In the second case, the lifetime is instead inferred to be the
same as the lifetime on <code>&amp;self</code> or <code>&amp;mut self</code>.</p>
<p>Here are some examples of elision errors:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0106"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, no input lifetimes
fn foo() -&gt; &amp;str { }

// error, `x` and `y` have distinct lifetimes inferred
fn bar(x: &amp;str, y: &amp;str) -&gt; &amp;str { }

// error, `y`'s lifetime is inferred to be distinct from `x`'s
fn baz&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;str { }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0107"><a class="header" href="#error-code-e0107">Error code E0107</a></h1>
<p>An incorrect number of generic arguments was provided.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107">struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }             // error: wrong number of type arguments:
                                  //        expected 1, found 0
struct Baz&lt;S, T&gt; { x: Foo&lt;S, T&gt; } // error: wrong number of type arguments:
                                  //        expected 1, found 2

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool&gt;(x);                 // error: wrong number of type arguments:
                                    //        expected 2, found 1
    foo::&lt;bool, i32, i32&gt;(x, 2, 4); // error: wrong number of type arguments:
                                    //        expected 2, found 3
    f::&lt;'static&gt;();                 // error: wrong number of lifetime arguments
                                    //        expected 0, found 1
}</code></pre></pre>
<p>When using/declaring an item with generic arguments, you must provide the exact
same number:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;T&gt; { x: T }

struct Bar&lt;T&gt; { x: Foo&lt;T&gt; }               // ok!
struct Baz&lt;S, T&gt; { x: Foo&lt;S&gt;, y: Foo&lt;T&gt; } // ok!

fn foo&lt;T, U&gt;(x: T, y: U) {}
fn f() {}

fn main() {
    let x: bool = true;
    foo::&lt;bool, u32&gt;(x, 12);              // ok!
    f();                                  // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0109"><a class="header" href="#error-code-e0109">Error code E0109</a></h1>
<p>You tried to provide a generic argument to a type which doesn't need it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0109"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type X = u32&lt;i32&gt;; // error: type arguments are not allowed for this type
type Y = bool&lt;'static&gt;; // error: lifetime parameters are not allowed on
                        //        this type
<span class="boring">}</span></code></pre></pre>
<p>Check that you used the correct argument and that the definition is correct.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type X = u32; // ok!
type Y = bool; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Note that generic arguments for enum variant constructors go after the variant,
not after the enum. For example, you would write <code>Option::None::&lt;u32&gt;</code>,
rather than <code>Option::&lt;u32&gt;::None</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0110"><a class="header" href="#error-code-e0110">Error code E0110</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-11"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-11">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You tried to provide a lifetime to a type which doesn't need it.
See <code>E0109</code> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0116"><a class="header" href="#error-code-e0116">Error code E0116</a></h1>
<p>An inherent implementation was defined for a type outside the current crate.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0116"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Vec&lt;u8&gt; { } // error
<span class="boring">}</span></code></pre></pre>
<p>You can only define an inherent implementation for a type in the same crate
where the type was defined. For example, an <code>impl</code> block as above is not allowed
since <code>Vec</code> is defined in the standard library.</p>
<p>To fix this problem, you can either:</p>
<ul>
<li>define a trait that has the desired associated functions/types/constants and
implement the trait for the type in question</li>
<li>define a new type wrapping the type and define an implementation on the new
type</li>
</ul>
<p>Note that using the <code>type</code> keyword does not work here because <code>type</code> only
introduces a type alias:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0116"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Bytes = Vec&lt;u8&gt;;

impl Bytes { } // error, same as above
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0117"><a class="header" href="#error-code-e0117">Error code E0117</a></h1>
<p>Only traits defined in the current crate can be implemented for arbitrary types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0117"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for u32 {}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule prohibits any implementation of a foreign trait (a
trait defined in another crate) where</p>
<ul>
<li>the type that is implementing the trait is foreign</li>
<li>all of the parameters being passed to the trait (if there are any) are also
foreign.</li>
</ul>
<p>To avoid this kind of error, ensure that at least one local type is referenced
by the <code>impl</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Foo; // you define your type in your crate

impl Drop for Foo { // and you can implement the trait on it!
    // code of trait implementation here
<span class="boring">  fn drop(&amp;mut self) { }
</span>}

impl From&lt;Foo&gt; for i32 { // or you use a type from your crate as
                         // a type parameter
    fn from(i: Foo) -&gt; i32 {
        0
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, define a trait locally and implement that instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Bar {
    fn get(&amp;self) -&gt; usize;
}

impl Bar for u32 {
    fn get(&amp;self) -&gt; usize { 0 }
}
<span class="boring">}</span></code></pre></pre>
<p>For information on the design of the orphan rules, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0118"><a class="header" href="#error-code-e0118">Error code E0118</a></h1>
<p>An inherent implementation was defined for something which isn't a struct,
enum, union, or trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0118"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; T { // error: no nominal type found for inherent implementation
    fn get_state(&amp;self) -&gt; String {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please implement a trait on the type or wrap it in a struct.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// we create a trait here
trait LiveLongAndProsper {
    fn get_state(&amp;self) -&gt; String;
}

// and now you can implement it on T
impl&lt;T&gt; LiveLongAndProsper for T {
    fn get_state(&amp;self) -&gt; String {
        &quot;He's dead, Jim!&quot;.to_owned()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.
For example, <code>NewType</code> is a newtype over <code>Foo</code> in <code>struct NewType(Foo)</code>.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TypeWrapper&lt;T&gt;(T);

impl&lt;T&gt; TypeWrapper&lt;T&gt; {
    fn get_state(&amp;self) -&gt; String {
        &quot;Fascinating!&quot;.to_owned()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0119"><a class="header" href="#error-code-e0119">Error code E0119</a></h1>
<p>There are conflicting trait implementations for the same type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0119"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo {
    value: usize
}

impl MyTrait for Foo { // error: conflicting implementations of trait
                       //        `MyTrait` for type `Foo`
    fn get(&amp;self) -&gt; usize { self.value }
}
<span class="boring">}</span></code></pre></pre>
<p>When looking for the implementation for the trait, the compiler finds
both the <code>impl&lt;T&gt; MyTrait for T</code> where T is all types and the <code>impl MyTrait for Foo</code>. Since a trait cannot be implemented multiple times,
this is an error. So, when you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}
<span class="boring">}</span></code></pre></pre>
<p>This makes the trait implemented on all types in the scope. So if you
try to implement it on another one after that, the implementations will
conflict. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait {
    fn get(&amp;self) -&gt; usize;
}

impl&lt;T&gt; MyTrait for T {
    fn get(&amp;self) -&gt; usize { 0 }
}

struct Foo;

fn main() {
    let f = Foo;

    f.get(); // the trait is implemented so we can use it
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0120"><a class="header" href="#error-code-e0120">Error code E0120</a></h1>
<p>Drop was implemented on a trait, which is not allowed: only structs and
enums can implement Drop.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0120"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}

impl Drop for MyTrait {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>A workaround for this problem is to wrap the trait up in a struct, and implement
Drop on that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}
struct MyWrapper&lt;T: MyTrait&gt; { foo: T }

impl &lt;T: MyTrait&gt; Drop for MyWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}

<span class="boring">}</span></code></pre></pre>
<p>Alternatively, wrapping trait objects requires something:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}

//or Box&lt;MyTrait&gt;, if you wanted an owned trait object
struct MyWrapper&lt;'a&gt; { foo: &amp;'a MyTrait }

impl &lt;'a&gt; Drop for MyWrapper&lt;'a&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0121"><a class="header" href="#error-code-e0121">Error code E0121</a></h1>
<p>The type placeholder <code>_</code> was used within a type on an item's signature.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0121"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; _ { 5 } // error

static BAR: _ = &quot;test&quot;; // error
<span class="boring">}</span></code></pre></pre>
<p>In those cases, you need to provide the type explicitly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i32 { 5 } // ok!

static BAR: &amp;str = &quot;test&quot;; // ok!
<span class="boring">}</span></code></pre></pre>
<p>The type placeholder <code>_</code> can be used outside item's signature as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;a4a&quot;.split('4')
    .collect::&lt;Vec&lt;_&gt;&gt;(); // No need to precise the Vec's generic type.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0124"><a class="header" href="#error-code-e0124">Error code E0124</a></h1>
<p>A struct was declared with two fields having the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0124"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    field1: i32,
    field1: i32, // error: field is already declared
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the field names have been correctly spelled. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    field1: i32,
    field2: i32, // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0128"><a class="header" href="#error-code-e0128">Error code E0128</a></h1>
<p>A type parameter with default value is using forward declared identifier.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0128"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T = U, U = ()&gt; {
    field1: T,
    field2: U,
}
// error: generic parameters with a default cannot use forward declared
//        identifiers
<span class="boring">}</span></code></pre></pre>
<p>Type parameter defaults can only use parameters that occur before them. Since
type parameters are evaluated in-order, this issue could be fixed by doing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;U = (), T = U&gt; {
    field1: T,
    field2: U,
}
<span class="boring">}</span></code></pre></pre>
<p>Please also verify that this wasn't because of a name-clash and rename the type
parameter if so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0130"><a class="header" href="#error-code-e0130">Error code E0130</a></h1>
<p>A pattern was declared as an argument in a foreign function declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0130"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign
                                //        function declarations
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, replace the pattern argument with a regular one. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SomeStruct {
    a: u32,
    b: u32,
}

extern &quot;C&quot; {
    fn foo(s: SomeStruct); // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo(a: (u32, u32)); // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0131"><a class="header" href="#error-code-e0131">Error code E0131</a></h1>
<p>The <code>main</code> function was defined with generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0131">fn main&lt;T&gt;() { // error: main function is not allowed to have generic parameters
}</code></pre></pre>
<p>It is not possible to define the <code>main</code> function with generic parameters.
It must not take any arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0132"><a class="header" href="#error-code-e0132">Error code E0132</a></h1>
<p>A function with the <code>start</code> attribute was declared with type parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0132"><span class="boring">#![allow(unused)]
</span>#![feature(start)]

<span class="boring">fn main() {
</span>#[start]
fn f&lt;T&gt;() {}
<span class="boring">}</span></code></pre></pre>
<p>It is not possible to declare type parameters on a function that has the <code>start</code>
attribute. Such a function must have the following type signature (for more
information, view <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib">the unstable book</a>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let _:
</span>fn(isize, *const *const u8) -&gt; isize;
<span class="boring">}</span></code></pre></pre>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(start)]

<span class="boring">fn main() {
</span>#[start]
fn my_start(argc: isize, argv: *const *const u8) -&gt; isize {
    0
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0133"><a class="header" href="#error-code-e0133">Error code E0133</a></h1>
<p>Unsafe code was used outside of an unsafe function or block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0133">unsafe fn f() { return; } // This is the unsafe code

fn main() {
    f(); // error: call to unsafe function requires unsafe function or block
}</code></pre></pre>
<p>Using unsafe functionality is potentially dangerous and disallowed by safety
checks. Examples:</p>
<ul>
<li>Dereferencing raw pointers</li>
<li>Calling functions via FFI</li>
<li>Calling functions marked unsafe</li>
</ul>
<p>These safety checks can be relaxed for a section of the code by wrapping the
unsafe instructions with an <code>unsafe</code> block. For instance:</p>
<pre><pre class="playground"><code class="language-rust">unsafe fn f() { return; }

fn main() {
    unsafe { f(); } // ok!
}</code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">unsafe section</a> of the Book for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0136"><a class="header" href="#error-code-e0136">Error code E0136</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-12"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-12">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>More than one <code>main</code> function was found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    // ...
}

// ...

fn main() { // error!
    // ...
}</code></pre></pre>
<p>A binary can only have one entry point, and by default that entry point is the
<code>main()</code> function. If there are multiple instances of this function, please
rename one of them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0137"><a class="header" href="#error-code-e0137">Error code E0137</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-13"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-13">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>More than one function was declared with the <code>#[main]</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(main)]

<span class="boring">fn main() {
</span>#[main]
fn foo() {}

#[main]
fn f() {} // error: multiple functions with a `#[main]` attribute
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the compiler found multiple functions with the
<code>#[main]</code> attribute. This is an error because there must be a unique entry
point into a Rust program. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![feature(main)]

<span class="boring">fn main() {
</span>#[main]
fn f() {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0138"><a class="header" href="#error-code-e0138">Error code E0138</a></h1>
<p>More than one function was declared with the <code>#[start]</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0138"><span class="boring">#![allow(unused)]
</span>#![feature(start)]

<span class="boring">fn main() {
</span>#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize {}

#[start]
fn f(argc: isize, argv: *const *const u8) -&gt; isize {}
// error: multiple 'start' functions
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the compiler found multiple functions with the
<code>#[start]</code> attribute. This is an error because there must be a unique entry
point into a Rust program. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(start)]

<span class="boring">fn main() {
</span>#[start]
fn foo(argc: isize, argv: *const *const u8) -&gt; isize { 0 } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0139"><a class="header" href="#error-code-e0139">Error code E0139</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-14"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-14">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>There are various restrictions on transmuting between types in Rust; for example
types being transmuted must have the same size. To apply all these restrictions,
the compiler must know the exact types that may be transmuted. When type
parameters are involved, this cannot always be done.</p>
<p>So, for example, the following is not allowed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}
<span class="boring">}</span></code></pre></pre>
<p>In this specific case there's a good chance that the transmute is harmless (but
this is not guaranteed by Rust). However, when alignment and enum optimizations
come into the picture, it's quite likely that the sizes may or may not match
with different type parameter substitutions. It's not possible to check this for
<em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any
unsubstituted type parameters.</p>
<p>If you need this, there's a good chance you're doing something wrong. Keep in
mind that Rust doesn't guarantee much about the layout of different structs
(even two structs with identical declarations may have different layouts). If
there is a solution that avoids the transmute entirely, try it instead.</p>
<p>If it's possible, hand-monomorphize the code by writing the function for each
possible type substitution. It's possible to use traits to do this cleanly,
for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType: Sized {
    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {
        unsafe { transmute(x) }
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {
        unsafe { transmute(x) }
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}
<span class="boring">}</span></code></pre></pre>
<p>Each impl will be checked for a size match in the transmute as usual, and since
there are no unbound type parameters involved, this should compile unless there
is a size mismatch in one of the impls.</p>
<p>It is also possible to manually transmute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ptr;
</span><span class="boring">let v = Some(&quot;value&quot;);
</span><span class="boring">type SomeType = &amp;'static [u8];
</span>unsafe {
    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
}
<span class="boring">;
</span><span class="boring">}</span></code></pre></pre>
<p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a
call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0152"><a class="header" href="#error-code-e0152">Error code E0152</a></h1>
<p>A lang item was redefined.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0152"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>#[lang = &quot;owned_box&quot;]
struct Foo&lt;T&gt;(T); // error: duplicate lang item found: `owned_box`
<span class="boring">}</span></code></pre></pre>
<p>Lang items are already implemented in the standard library. Unless you are
writing a free-standing application (e.g., a kernel), you do not need to provide
them yourself.</p>
<p>You can build a free-standing crate by adding <code>#![no_std]</code> to the crate
attributes:</p>
<pre><code class="language-rust ignore (only-for-syntax-highlight)">#![no_std]</code></pre>
<p>See also the <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib">unstable book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0154"><a class="header" href="#error-code-e0154">Error code E0154</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-15"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-15">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Imports (<code>use</code> statements) are not allowed after non-item statements, such as
variable declarations and expression statements.</p>
<p>Here is an example that demonstrates the error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() {
    // Variable declaration before import
    let x = 0;
    use std::io::Read;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The solution is to declare the imports at the top of the block, function, or
file.</p>
<p>Here is the previous example again, with the correct order:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() {
    use std::io::Read;
    let x = 0;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/statements.html#declaration-statements">Declaration Statements</a> section of the
reference for more information about what constitutes an item declaration
and what does not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0158"><a class="header" href="#error-code-e0158">Error code E0158</a></h1>
<p>An associated <code>const</code>, <code>const</code> parameter or <code>static</code> has been referenced
in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0158"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    One,
    Two
}

trait Bar {
    const X: Foo;
}

fn test&lt;A: Bar&gt;(arg: Foo) {
    match arg {
        A::X =&gt; println!(&quot;A::X&quot;), // error: E0158: associated consts cannot be
                                  //        referenced in patterns
        Foo::Two =&gt; println!(&quot;Two&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Associated <code>const</code>s cannot be referenced in patterns because it is impossible
for the compiler to prove exhaustiveness (that some pattern will always match).
Take the above example, because Rust does type checking in the <em>generic</em>
method, not the <em>monomorphized</em> specific instance. So because <code>Bar</code> could have
theoretically infinite implementations, there's no way to always be sure that
<code>A::X</code> is <code>Foo::One</code>. So this code must be rejected. Even if code can be
proven exhaustive by a programmer, the compiler cannot currently prove this.</p>
<p>The same holds true of <code>const</code> parameters and <code>static</code>s.</p>
<p>If you want to match against an associated <code>const</code>, <code>const</code> parameter or
<code>static</code> consider using a guard instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    const X: char;
}

static FOO: char = 'j';

fn test&lt;A: Trait, const Y: char&gt;(arg: char) {
    match arg {
        c if c == A::X =&gt; println!(&quot;A::X&quot;),
        c if c == Y =&gt; println!(&quot;Y&quot;),
        c if c == FOO =&gt; println!(&quot;FOO&quot;),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0161"><a class="header" href="#error-code-e0161">Error code E0161</a></h1>
<p>A value was moved whose size was not known at compile time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0161">trait Bar {
    fn f(self);
}

impl Bar for i32 {
    fn f(self) {}
}

fn main() {
    let b: Box&lt;dyn Bar&gt; = Box::new(0i32);
    b.f();
    // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot
    //        be statically determined
}</code></pre></pre>
<p>In Rust, you can only move a value when its size is known at compile time.</p>
<p>To work around this restriction, consider &quot;hiding&quot; the value behind a reference:
either <code>&amp;x</code> or <code>&amp;mut x</code>. Since a reference has a fixed size, this lets you move
it around as usual. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait Bar {
    fn f(&amp;self);
}

impl Bar for i32 {
    fn f(&amp;self) {}
}

fn main() {
    let b: Box&lt;dyn Bar&gt; = Box::new(0i32);
    b.f();
    // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0162"><a class="header" href="#error-code-e0162">Error code E0162</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-16"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-16">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An <code>if let</code> pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding instead. For instance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
if let Irrefutable(x) = irr {
    // This body will always be executed.
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Try this instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Irrefutable(i32);
let irr = Irrefutable(0);

let Irrefutable(x) = irr;
println!(&quot;{}&quot;, x);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0164"><a class="header" href="#error-code-e0164">Error code E0164</a></h1>
<p>Something which is neither a tuple struct nor a tuple variant was used as a
pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0164"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::new() =&gt; (), // error!
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This error means that an attempt was made to match something which is neither a
tuple struct nor a tuple variant. Only these two elements are allowed as a
pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A {
    B,
    C,
}

impl A {
    fn new() {}
}

fn bar(foo: A) {
    match foo {
        A::B =&gt; (), // ok!
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0165"><a class="header" href="#error-code-e0165">Error code E0165</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-17"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-17">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A <code>while let</code> pattern attempts to match the pattern, and enters the body if the
match was successful. If the match is irrefutable (when it cannot fail to
match), use a regular <code>let</code>-binding inside a <code>loop</code> instead. For instance:</p>
<pre><code class="language-no_run">struct Irrefutable(i32);
let irr = Irrefutable(0);

// This fails to compile because the match is irrefutable.
while let Irrefutable(x) = irr {
    // ...
}
</code></pre>
<p>Try this instead:</p>
<pre><code class="language-no_run">struct Irrefutable(i32);
let irr = Irrefutable(0);

loop {
    let Irrefutable(x) = irr;
    // ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0170"><a class="header" href="#error-code-e0170">Error code E0170</a></h1>
<p>A pattern binding is using the same name as one of the variants of a type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0170"><span class="boring">#![deny(warnings)]
</span>enum Method {
    GET,
    POST,
}

fn is_empty(s: Method) -&gt; bool {
    match s {
        GET =&gt; true,
        _ =&gt; false
    }
}

fn main() {}</code></pre></pre>
<p>Enum variants are qualified by default. For example, given this type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Method {
    GET,
    POST,
}
<span class="boring">}</span></code></pre></pre>
<p>You would match it using:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Method {
    GET,
    POST,
}

let m = Method::GET;

match m {
    Method::GET =&gt; {},
    Method::POST =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and
&quot;POST&quot; instead. This behavior is likely not what you want, so <code>rustc</code> warns when
that happens.</p>
<p>Qualified names are good practice, and most code works well with them. But if
you prefer them unqualified, you can import the variants into scope:</p>
<pre><pre class="playground"><code class="language-rust">use Method::*;
enum Method { GET, POST }
<span class="boring">fn main() {}</span></code></pre></pre>
<p>If you want others to be able to import variants from your module directly, use
<code>pub use</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub use Method::*;
pub enum Method { GET, POST }
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0178"><a class="header" href="#error-code-e0178">Error code E0178</a></h1>
<p>The <code>+</code> type operator was used in an ambiguous context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0178"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a Foo + 'a,     // error!
    y: &amp;'a mut Foo + 'a, // error!
    z: fn() -&gt; Foo + 'a, // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In types, the <code>+</code> type operator has low precedence, so it is often necessary
to use parentheses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;'a&gt; {
    x: &amp;'a (Foo + 'a),     // ok!
    y: &amp;'a mut (Foo + 'a), // ok!
    z: fn() -&gt; (Foo + 'a), // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>More details can be found in <a href="https://github.com/rust-lang/rfcs/pull/438">RFC 438</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0183"><a class="header" href="#error-code-e0183">Error code E0183</a></h1>
<p>Manual implementation of a <code>Fn*</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0183"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyClosure {
    foo: i32
}

impl FnOnce&lt;()&gt; for MyClosure {  // error
    type Output = ();
    extern &quot;rust-call&quot; fn call_once(self, args: ()) -&gt; Self::Output {
        println!(&quot;{}&quot;, self.foo);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Manually implementing <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> is unstable
and requires <code>#![feature(fn_traits, unboxed_closures)]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(fn_traits, unboxed_closures)]

<span class="boring">fn main() {
</span>struct MyClosure {
    foo: i32
}

impl FnOnce&lt;()&gt; for MyClosure {  // ok!
    type Output = ();
    extern &quot;rust-call&quot; fn call_once(self, args: ()) -&gt; Self::Output {
        println!(&quot;{}&quot;, self.foo);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The arguments must be a tuple representing the argument list.
For more info, see the <a href="https://github.com/rust-lang/rust/issues/29625">tracking issue</a>:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0184"><a class="header" href="#error-code-e0184">Error code E0184</a></h1>
<p>The <code>Copy</code> trait was implemented on a type with a <code>Drop</code> implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0184"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo; // error!

impl Drop for Foo {
    fn drop(&amp;mut self) {
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Explicitly implementing both <code>Drop</code> and <code>Copy</code> trait on a type is currently
disallowed. This feature can make some sense in theory, but the current
implementation is incorrect and can lead to memory unsafety (see
<a href="https://github.com/rust-lang/rust/issues/20126">issue #20126</a>), so it has been disabled for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0185"><a class="header" href="#error-code-e0185">Error code E0185</a></h1>
<p>An associated function for a trait was defined to be static, but an
implementation of the trait declared the same function to be a method (i.e., to
take a <code>self</code> parameter).</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0185"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the impl, but not in
    // the trait
    fn foo(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>When a type implements a trait's associated function, it has to use the same
signature. So in this case, since <code>Foo::foo</code> does not take any argument and
does not return anything, its implementation on <code>Bar</code> should be the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo();
}

struct Bar;

impl Foo for Bar {
    fn foo() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0186"><a class="header" href="#error-code-e0186">Error code E0186</a></h1>
<p>An associated function for a trait was defined to be a method (i.e., to take a
<code>self</code> parameter), but an implementation of the trait declared the same function
to be static.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0186"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    // error, method `foo` has a `&amp;self` declaration in the trait, but not in
    // the impl
    fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<p>When a type implements a trait's associated function, it has to use the same
signature. So in this case, since <code>Foo::foo</code> takes <code>self</code> as argument and
does not return anything, its implementation on <code>Bar</code> should be the same:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self);
}

struct Bar;

impl Foo for Bar {
    fn foo(&amp;self) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0191"><a class="header" href="#error-code-e0191">Error code E0191</a></h1>
<p>An associated type wasn't specified for a trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0191"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Bar;
}

type Foo = Trait; // error: the value of the associated type `Bar` (from
                  //        the trait `Trait`) must be specified
<span class="boring">}</span></code></pre></pre>
<p>Trait objects need to have all associated types specified. Please verify that
all associated types of the trait were specified and the correct trait was used.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    type Bar;
}

type Foo = Trait&lt;Bar=i32&gt;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0192"><a class="header" href="#error-code-e0192">Error code E0192</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-18"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-18">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A negative impl was added on a trait implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">trait Trait {
    type Bar;
}

struct Foo;

impl !Trait for Foo { } //~ ERROR

fn main() {}</code></pre></pre>
<p>Negative impls are only allowed for auto traits. For more
information see the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0193"><a class="header" href="#error-code-e0193">Error code E0193</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-19"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-19">Note: this error code is no longer emitted by the compiler.</a></h4>
<p><code>where</code> clauses must use generic type parameters: it does not make sense to use
them otherwise. An example causing this error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}

impl Foo for Wrapper&lt;u32&gt; where Wrapper&lt;u32&gt;: Clone {
    fn bar(&amp;self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>This use of a <code>where</code> clause is strange - a more common usage would look
something like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self);
}

#[derive(Copy,Clone)]
struct Wrapper&lt;T&gt; {
    Wrapped: T
}
impl &lt;T&gt; Foo for Wrapper&lt;T&gt; where Wrapper&lt;T&gt;: Clone {
    fn bar(&amp;self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we're saying that the implementation exists on Wrapper only when the
wrapped type <code>T</code> implements <code>Clone</code>. The <code>where</code> clause is important because
some types will not implement <code>Clone</code>, and thus will not get this method.</p>
<p>In our erroneous example, however, we're referencing a single concrete type.
Since we know for certain that <code>Wrapper&lt;u32&gt;</code> implements <code>Clone</code>, there's no
reason to also specify it in a <code>where</code> clause.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0195"><a class="header" href="#error-code-e0195">Error code E0195</a></h1>
<p>The lifetime parameters of the method do not match the trait declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0195"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn bar&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn bar&lt;'a,'b&gt;(x: &amp;'a str, y: &amp;'b str) {
    // error: lifetime parameters or bounds on method `bar`
    // do not match the trait declaration
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The lifetime constraint <code>'b</code> for <code>bar()</code> implementation does not match the
trait declaration. Ensure lifetime declarations match exactly in both trait
declaration and implementation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str);
}

struct Foo;

impl Trait for Foo {
    fn t&lt;'a,'b:'a&gt;(x: &amp;'a str, y: &amp;'b str) { // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0197"><a class="header" href="#error-code-e0197">Error code E0197</a></h1>
<p>An inherent implementation was marked unsafe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0197"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe impl Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Inherent implementations (one that do not implement a trait but provide
methods associated with a type) are always safe because they are not
implementing an unsafe trait. Removing the <code>unsafe</code> keyword from the inherent
implementation will resolve this error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0198"><a class="header" href="#error-code-e0198">Error code E0198</a></h1>
<p>A negative implementation was marked as unsafe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0198"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe impl !Clone for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>A negative implementation is one that excludes a type from implementing a
particular trait. Not being able to use a trait is always a safe operation,
so negative implementations are always safe and never need to be marked as
unsafe.</p>
<p>This will compile:</p>
<pre><code class="language-rust ignore (ignore auto_trait future compatibility warning)">#![feature(auto_traits)]

struct Foo;

auto trait Enterprise {}

impl !Enterprise for Foo { }</code></pre>
<p>Please note that negative impls are only allowed for auto traits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0199"><a class="header" href="#error-code-e0199">Error code E0199</a></h1>
<p>A trait implementation was marked as unsafe while the trait is safe.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0199"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

trait Bar { }

unsafe impl Bar for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Safe traits should not have unsafe implementations, therefore marking an
implementation for a safe trait unsafe will cause a compiler error. Removing
the unsafe marker on the trait noted in the error will resolve this problem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

trait Bar { }

impl Bar for Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0200"><a class="header" href="#error-code-e0200">Error code E0200</a></h1>
<p>An unsafe trait was implemented without an unsafe implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0200"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe trait Bar { }

impl Bar for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Unsafe traits must have unsafe implementations. This error occurs when an
implementation for an unsafe trait isn't marked as unsafe. This may be resolved
by marking the unsafe implementation as unsafe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

unsafe trait Bar { }

unsafe impl Bar for Foo { } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0201"><a class="header" href="#error-code-e0201">Error code E0201</a></h1>
<p>Two associated items (like methods, associated types, associated functions,
etc.) were defined with the same identifier.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0201"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(u8);

impl Foo {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
    fn bar() {} // error: duplicate associated function
}

trait Baz {
    type Quux;
    fn baz(&amp;self) -&gt; bool;
}

impl Baz for Foo {
    type Quux = u32;

    fn baz(&amp;self) -&gt; bool { true }

    // error: duplicate method
    fn baz(&amp;self) -&gt; bool { self.0 &gt; 5 }

    // error: duplicate associated type
    type Quux = u32;
}
<span class="boring">}</span></code></pre></pre>
<p>Note, however, that items with the same name are allowed for inherent <code>impl</code>
blocks that don't overlap:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt;(T);

impl Foo&lt;u8&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 &gt; 5 }
}

impl Foo&lt;bool&gt; {
    fn bar(&amp;self) -&gt; bool { self.0 }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0203"><a class="header" href="#error-code-e0203">Error code E0203</a></h1>
<p>Having multiple relaxed default bounds is unsupported.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0203"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bad&lt;T: ?Sized + ?Send&gt;{
    inner: T
}
<span class="boring">}</span></code></pre></pre>
<p>Here the type <code>T</code> cannot have a relaxed bound for multiple default traits
(<code>Sized</code> and <code>Send</code>). This can be fixed by only using one relaxed bound.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Good&lt;T: ?Sized&gt;{
    inner: T
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0204"><a class="header" href="#error-code-e0204">Error code E0204</a></h1>
<p>The <code>Copy</code> trait was implemented on a type which contains a field that doesn't
implement the <code>Copy</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    foo: Vec&lt;u32&gt;,
}

impl Copy for Foo { } // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>Copy</code> trait is implemented by default only on primitive types. If your
type only contains primitive types, you'll be able to implement <code>Copy</code> on it.
Otherwise, it won't be possible.</p>
<p>Here's another example that will fail:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)] // error!
struct Foo&lt;'a&gt; {
    ty: &amp;'a mut bool,
}
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0205"><a class="header" href="#error-code-e0205">Error code E0205</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-20"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-20">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt to implement the <code>Copy</code> trait for an enum failed because one of the
variants does not implement <code>Copy</code>. To fix this, you must implement <code>Copy</code> for
the mentioned variant. Note that this may not be possible, as in the example of</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar(Vec&lt;u32&gt;),
    Baz,
}

impl Copy for Foo { }
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>Vec&lt;T&gt;</code> does not implement <code>Copy</code> for any <code>T</code>.</p>
<p>Here's another example that will fail:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0204"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
enum Foo&lt;'a&gt; {
    Bar(&amp;'a mut bool),
    Baz,
}
<span class="boring">}</span></code></pre></pre>
<p>This fails because <code>&amp;mut T</code> is not <code>Copy</code>, even when <code>T</code> is <code>Copy</code> (this
differs from the behavior for <code>&amp;T</code>, which is always <code>Copy</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0206"><a class="header" href="#error-code-e0206">Error code E0206</a></h1>
<p>The <code>Copy</code> trait was implemented on a type which is neither a struct, an
enum, nor a union.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0206"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct Bar;

impl Copy for &amp;'static mut Bar { } // error!
<span class="boring">}</span></code></pre></pre>
<p>You can only implement <code>Copy</code> for a struct, an enum, or a union.
The previous example will fail because <code>&amp;'static mut Bar</code>
is not a struct, an enum, or a union.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0207"><a class="header" href="#error-code-e0207">Error code E0207</a></h1>
<p>A type, const or lifetime parameter that is specified for <code>impl</code> is not
constrained.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Any type or const parameter of an <code>impl</code> must meet at least one of the
following criteria:</p>
<ul>
<li>it appears in the <em>implementing type</em> of the impl, e.g. <code>impl&lt;T&gt; Foo&lt;T&gt;</code></li>
<li>for a trait impl, it appears in the <em>implemented trait</em>, e.g.
<code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code></li>
<li>it is bound as an associated type, e.g. <code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code></li>
</ul>
<p>Any unconstrained lifetime parameter of an <code>impl</code> is not supported if the
lifetime parameter is used by an associated type.</p>
<h3 id="error-example-1"><a class="header" href="#error-example-1">Error example 1</a></h3>
<p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it.
The previous code example has a definition which leads to a compiler error:</p>
<p>The problem is that the parameter <code>T</code> does not appear in the implementing type
(<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type
parameter from the <code>impl</code> to the method <code>get</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-2"><a class="header" href="#error-example-2">Error example 2</a></h3>
<p>As another example, suppose we have a <code>Maker</code> trait and want to establish a
type <code>FooMaker</code> that makes <code>Foo</code>s:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This fails to compile because <code>T</code> does not appear in the trait or in the
implementing type.</p>
<p>One way to work around this is to introduce a phantom type parameter into
<code>FooMaker</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Another way is to do away with the associated type in <code>Maker</code> and use an input
type parameter instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-3"><a class="header" href="#error-example-3">Error example 3</a></h3>
<p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it.
The following code example has a definition which leads to a compiler error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl&lt;const T: i32&gt; Foo {
    // error: the const parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The problem is that the const parameter <code>T</code> does not appear in the implementing
type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type
parameter from the <code>impl</code> to the method <code>get</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

// Move the const parameter from the impl to the method
impl Foo {
    fn get&lt;const T: i32&gt;(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-example-4"><a class="header" href="#error-example-4">Error example 4</a></h3>
<p>Suppose we have a struct <code>Foo</code> and a struct <code>Bar</code> that uses lifetime <code>'a</code>. We
would like to implement trait <code>Contains</code> for <code>Foo</code>. The trait <code>Contains</code> have
the associated type <code>B</code>. The following code example has a definition which
leads to a compiler error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0207"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar&lt;'a&gt;;

trait Contains {
    type B;

    fn get(&amp;self) -&gt; i32;
}

impl&lt;'a&gt; Contains for Foo {
    type B = Bar&lt;'a&gt;;

    // error: the lifetime parameter `'a` is not constrained by the impl trait,
    // self type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Please note that unconstrained lifetime parameters are not supported if they are
being used by an associated type.</p>
<h3 id="additional-information"><a class="header" href="#additional-information">Additional information</a></h3>
<p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 447</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0208"><a class="header" href="#error-code-e0208">Error code E0208</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-21"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-21">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error code shows the variance of a type's generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: this feature is perma-unstable and should *only* be used for
//       testing purposes.
#![feature(rustc_attrs)]

#[rustc_variance]
struct Foo&lt;'a, T&gt; { // error: deliberate error to display type's variance
    t: &amp;'a mut T,
}
<span class="boring">}</span></code></pre></pre>
<p>which produces the following error:</p>
<pre><code class="language-text">error: [-, o]
 --&gt; &lt;anon&gt;:4:1
  |
4 | struct Foo&lt;'a, T&gt; {
  | ^^^^^^^^^^^^^^^^^
</code></pre>
<p><em>Note that while <code>#[rustc_variance]</code> still exists and is used within the</em>
<em>compiler, it no longer is marked as <code>E0208</code> and instead has no error code.</em></p>
<p>This error is deliberately triggered with the <code>#[rustc_variance]</code> attribute
(<code>#![feature(rustc_attrs)]</code> must be enabled) and helps to show you the variance
of the type's generic parameters. You can read more about variance and
subtyping in <a href="https://doc.rust-lang.org/nomicon/subtyping.html">this section of the Rustonomicon</a>. For a more in depth look at
variance (including a more complete list of common variances) see
<a href="https://doc.rust-lang.org/reference/subtyping.html#variance">this section of the Reference</a>. For information on how variance is implemented
in the compiler, see <a href="https://rustc-dev-guide.rust-lang.org/variance.html">this section of <code>rustc-dev-guide</code></a>.</p>
<p>This error can be easily fixed by removing the <code>#[rustc_variance]</code> attribute,
the compiler's suggestion to comment it out can be applied automatically with
<code>rustfix</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0210"><a class="header" href="#error-code-e0210">Error code E0210</a></h1>
<p>This error indicates a violation of one of Rust's orphan rules for trait
implementations. The rule concerns the use of type parameters in an
implementation of a foreign trait (a trait defined in another crate), and
states that type parameters must be &quot;covered&quot; by a local type.</p>
<p>When implementing a foreign trait for a foreign type,
the trait must have one or more type parameters.
A type local to your crate must appear before any use of any type parameters.</p>
<p>To understand what this means, it is perhaps easier to consider a few examples.</p>
<p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the
following trait <code>impl</code> is an error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0210"><span class="boring">#[cfg(for_demonstration_only)]
</span>extern crate foo;
<span class="boring">#[cfg(for_demonstration_only)]
</span>use foo::ForeignTrait;
<span class="boring">use std::panic::UnwindSafe as ForeignTrait;
</span>
impl&lt;T&gt; ForeignTrait for T { } // error
<span class="boring">fn main() {}</span></code></pre></pre>
<p>To work around this, it can be covered with a local type, <code>MyType</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::panic::UnwindSafe as ForeignTrait;
</span>struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok
<span class="boring">}</span></code></pre></pre>
<p>Please note that a type alias is not sufficient.</p>
<p>For another example of an error, suppose there's another trait defined in <code>foo</code>
named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results
in the same rule violation:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error</code></pre>
<p>The reason for this is that there are two appearances of type parameter <code>T</code> in
the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance
is uncovered, and so runs afoul of the orphan rule.</p>
<p>Consider one more example:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</code></pre>
<p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and
<code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em>
violate the orphan rule; it is permitted.</p>
<p>To see why that last example was allowed, you need to understand the general
rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p>
<pre><code class="language-rust ignore (only-for-syntax-highlight)">impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</code></pre>
<p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code>
are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another
orphan rule, see the explanation for E0117).</p>
<p>Both of the following must be true:</p>
<ol>
<li>At least one of the types <code>T0..=Tn</code> must be a local type.
Let <code>Ti</code> be the first such type.</li>
<li>No uncovered type parameters <code>P1..=Pm</code> may appear in <code>T0..Ti</code>
(excluding <code>Ti</code>).</li>
</ol>
<p>For information on the design of the orphan rules,
see <a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html">RFC 2451</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0211"><a class="header" href="#error-code-e0211">Error code E0211</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-22"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-22">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You used a function or type which doesn't fit the requirements for where it was
used. Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![feature(intrinsics)]

extern &quot;rust-intrinsic&quot; {
    #[rustc_safe_intrinsic]
    fn size_of&lt;T&gt;(); // error: intrinsic has wrong type
}

// or:

fn main() -&gt; i32 { 0 }
// error: main function expects type: `fn() {main}`: expected (), found i32

// or:

let x = 1u8;
match x {
    0u8..=3i8 =&gt; (),
    // error: mismatched types in range: expected u8, found i8
    _ =&gt; ()
}

// or:

use std::rc::Rc;
struct Foo;

impl Foo {
    fn x(self: Rc&lt;Foo&gt;) {}
    // error: mismatched self type: expected `Foo`: expected struct
    //        `Foo`, found struct `alloc::rc::Rc`
}</code></pre></pre>
<p>For the first code example, please check the function definition. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;rust-intrinsic&quot; {
    #[rustc_safe_intrinsic]
    fn size_of&lt;T&gt;() -&gt; usize; // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>The second case example is a bit particular: the main function must always
have this definition:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main();</code></pre></pre>
<p>They never take parameters and never return types.</p>
<p>For the third example, when you match, all patterns must have the same type
as the type you're matching on. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1u8;

match x {
    0u8..=3u8 =&gt; (), // ok!
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>And finally, for the last example, only <code>Box&lt;Self&gt;</code>, <code>&amp;Self</code>, <code>Self</code>,
or <code>&amp;mut Self</code> work as explicit self parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn x(self: Box&lt;Foo&gt;) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0212"><a class="header" href="#error-code-e0212">Error code E0212</a></h1>
<p>Cannot use the associated type of
a trait with uninferred generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0212"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo&lt;T&gt; {
    type A;

    fn get(&amp;self, t: T) -&gt; Self::A;
}

fn foo2&lt;I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    field: I::A) {} // error!
<span class="boring">}</span></code></pre></pre>
<p>In this example, we have to instantiate <code>'x</code>, and
we don't know what lifetime to instantiate it with.
To fix this, spell out the precise lifetimes involved.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo&lt;T&gt; {
    type A;

    fn get(&amp;self, t: T) -&gt; Self::A;
}

fn foo3&lt;I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    x: &lt;I as Foo&lt;&amp;isize&gt;&gt;::A) {} // ok!


fn foo4&lt;'a, I : for&lt;'x&gt; Foo&lt;&amp;'x isize&gt;&gt;(
    x: &lt;I as Foo&lt;&amp;'a isize&gt;&gt;::A) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0214"><a class="header" href="#error-code-e0214">Error code E0214</a></h1>
<p>A generic type was described using parentheses rather than angle brackets.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0214"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec(&amp;str) = vec![&quot;foo&quot;];
<span class="boring">}</span></code></pre></pre>
<p>This is not currently supported: <code>v</code> should be defined as <code>Vec&lt;&amp;str&gt;</code>.
Parentheses are currently only used with generic types when defining parameters
for <code>Fn</code>-family traits.</p>
<p>The previous code example fixed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;&amp;str&gt; = vec![&quot;foo&quot;];
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0220"><a class="header" href="#error-code-e0220">Error code E0220</a></h1>
<p>The associated type used was not defined in the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0220"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {
    type Bar;
}

type Foo = T1&lt;F=i32&gt;; // error: associated type `F` not found for `T1`

// or:

trait T2 {
    type Bar;

    // error: Baz is used but not declared
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<p>Make sure that you have defined the associated type in the trait body.
Also, verify that you used the right trait or you didn't misspell the
associated type name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {
    type Bar;
}

type Foo = T1&lt;Bar=i32&gt;; // ok!

// or:

trait T2 {
    type Bar;
    type Baz; // we declare `Baz` in our trait.

    // and now we can use it here:
    fn return_bool(&amp;self, _: &amp;Self::Bar, _: &amp;Self::Baz) -&gt; bool;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0221"><a class="header" href="#error-code-e0221">Error code E0221</a></h1>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0221"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: Self::A;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>Foo</code> defines an associated type <code>A</code>. <code>Bar</code> inherits that type
from <code>Foo</code>, and defines another associated type of the same name. As a result,
when we attempt to use <code>Self::A</code>, it's ambiguous whether we mean the <code>A</code> defined
by <code>Foo</code> or the one defined by <code>Bar</code>.</p>
<p>There are two options to work around this issue. The first is simply to rename
one of the types. Alternatively, one can specify the intended type using the
following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T1 {}
trait T2 {}

trait Foo {
    type A: T1;
}

trait Bar : Foo {
    type A: T2;
    fn do_something() {
        let _: &lt;Self as Bar&gt;::A;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0222"><a class="header" href="#error-code-e0222">Error code E0222</a></h1>
<p>An attempt was made to constrain an associated type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0222"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

fn dent_object&lt;COLOR&gt;(c: dyn BoxCar&lt;Color=COLOR&gt;) {} // Invalid constraint
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>BoxCar</code> has two supertraits: <code>Vehicle</code> and <code>Box</code>. Both of
these traits define an associated type <code>Color</code>. <code>BoxCar</code> inherits two types
with that name from both supertraits. Because of this, we need to use the
fully qualified path syntax to refer to the appropriate <code>Color</code> associated
type, either <code>&lt;BoxCar as Vehicle&gt;::Color</code> or <code>&lt;BoxCar as Box&gt;::Color</code>, but this
syntax is not allowed to be used in a function signature.</p>
<p>In order to encode this kind of constraint, a <code>where</code> clause and a new type
parameter are needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

// Introduce a new `CAR` type parameter
fn foo&lt;CAR, COLOR&gt;(
    c: CAR,
) where
    // Bind the type parameter `CAR` to the trait `BoxCar`
    CAR: BoxCar,
    // Further restrict `&lt;BoxCar as Vehicle&gt;::Color` to be the same as the
    // type parameter `COLOR`
    CAR: Vehicle&lt;Color = COLOR&gt;,
    // We can also simultaneously restrict the other trait's associated type
    CAR: Box&lt;Color = COLOR&gt;
{}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0223"><a class="header" href="#error-code-e0223">Error code E0223</a></h1>
<p>An attempt was made to retrieve an associated type, but the type was ambiguous.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0223">trait Trait { type X; }

fn main() {
    let foo: Trait::X;
}</code></pre></pre>
<p>The problem here is that we're attempting to take the associated type of <code>X</code>
from <code>Trait</code>. Unfortunately, the type of <code>X</code> is not defined, because it's only
made concrete in implementations of the trait. A working version of this code
might look like:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait { type X; }

struct Struct;
impl Trait for Struct {
    type X = u32;
}

fn main() {
    let foo: &lt;Struct as Trait&gt;::X;
}</code></pre></pre>
<p>This syntax specifies that we want the associated type <code>X</code> from <code>Struct</code>'s
implementation of <code>Trait</code>.</p>
<p>Due to internal limitations of the current compiler implementation we cannot
simply use <code>Struct::X</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0224"><a class="header" href="#error-code-e0224">Error code E0224</a></h1>
<p>A trait object was declared with no traits.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0224"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = dyn 'static +;
<span class="boring">}</span></code></pre></pre>
<p>Rust does not currently support this.</p>
<p>To solve, ensure that the trait object has at least one trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = dyn 'static + Copy;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0225"><a class="header" href="#error-code-e0225">Error code E0225</a></h1>
<p>Multiple types were used as bounds for a closure or trait object.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0225">fn main() {
    let _: Box&lt;dyn std::io::Read + std::io::Write&gt;;
}</code></pre></pre>
<p>Rust does not currently support this.</p>
<p>Auto traits such as Send and Sync are an exception to this rule:
It's possible to have bounds of one non-builtin trait, plus any number of
auto traits. For example, the following compiles correctly:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _: Box&lt;dyn std::io::Read + Send + Sync&gt;;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0226"><a class="header" href="#error-code-e0226">Error code E0226</a></h1>
<p>More than one explicit lifetime bound was used on a trait object.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0226"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

type T&lt;'a, 'b&gt; = dyn Foo + 'a + 'b; // error: Trait object `arg` has two
                                    //        lifetime bound, 'a and 'b.
<span class="boring">}</span></code></pre></pre>
<p>Here <code>T</code> is a trait object with two explicit lifetime bounds, 'a and 'b.</p>
<p>Only a single explicit lifetime bound is permitted on trait objects.
To fix this error, consider removing one of the lifetime bounds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

type T&lt;'a&gt; = dyn Foo + 'a;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0227"><a class="header" href="#error-code-e0227">Error code E0227</a></h1>
<p>This error indicates that the compiler is unable to determine whether there is
exactly one unique region in the set of derived region bounds.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0227"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;'foo&gt;: 'foo {}
trait Bar&lt;'bar&gt;: 'bar {}

trait FooBar&lt;'foo, 'bar&gt;: Foo&lt;'foo&gt; + Bar&lt;'bar&gt; {}

struct Baz&lt;'foo, 'bar&gt; {
    baz: dyn FooBar&lt;'foo, 'bar&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>baz</code> can have either <code>'foo</code> or <code>'bar</code> lifetimes.</p>
<p>To resolve this error, provide an explicit lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;'foo&gt;: 'foo {}
trait Bar&lt;'bar&gt;: 'bar {}

trait FooBar&lt;'foo, 'bar&gt;: Foo&lt;'foo&gt; + Bar&lt;'bar&gt; {}

struct Baz&lt;'foo, 'bar, 'baz&gt;
where
    'baz: 'foo + 'bar,
{
    obj: dyn FooBar&lt;'foo, 'bar&gt; + 'baz,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0228"><a class="header" href="#error-code-e0228">Error code E0228</a></h1>
<p>The lifetime bound for this object type cannot be deduced from context and must
be specified.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0228"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait&gt;;
<span class="boring">}</span></code></pre></pre>
<p>When a trait object is used as a type argument of a generic type, Rust will try
to infer its lifetime if unspecified. However, this isn't possible when the
containing type has more than one lifetime bound.</p>
<p>The above example can be resolved by either reducing the number of lifetime
bounds to one or by making the trait object lifetime explicit, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { }

struct TwoBounds&lt;'a, 'b, T: Sized + 'a + 'b&gt; {
    x: &amp;'a i32,
    y: &amp;'b i32,
    z: T,
}

type Foo&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Trait + 'b&gt;;
<span class="boring">}</span></code></pre></pre>
<p>For more information, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and its amendment <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0229"><a class="header" href="#error-code-e0229">Error code E0229</a></h1>
<p>An associated type binding was done outside of the type parameter declaration
and <code>where</code> clause.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0229"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Foo {
    type A;
    fn boo(&amp;self) -&gt; &lt;Self as Foo&gt;::A;
}

struct Bar;

impl Foo for isize {
    type A = usize;
    fn boo(&amp;self) -&gt; usize { 42 }
}

fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&lt;A=Bar&gt;&gt;::A) {}
// error: associated type bindings are not allowed here
<span class="boring">}</span></code></pre></pre>
<p>To solve this error, please move the type bindings in the type parameter
declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Bar;
</span><span class="boring">trait Foo { type A; }
</span>fn baz&lt;I: Foo&lt;A=Bar&gt;&gt;(x: &amp;&lt;I as Foo&gt;::A) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or in the <code>where</code> clause:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Bar;
</span><span class="boring">trait Foo { type A; }
</span>fn baz&lt;I&gt;(x: &amp;&lt;I as Foo&gt;::A) where I: Foo&lt;A=Bar&gt; {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0230"><a class="header" href="#error-code-e0230">Error code E0230</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0230"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented = &quot;error on `{Self}` with params `&lt;{A},{B}&gt;`&quot;] // error
trait BadAnnotation&lt;A&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>There will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>
<p>As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this
case, <code>bool</code>) that we tried to use.</p>
<p>This error appears when the curly braces contain an identifier which doesn't
match with any of the type parameters or the string <code>Self</code>. This might happen
if you misspelled a type parameter, or if you intended to use literal curly
braces. If it is the latter, escape the curly braces with a second curly brace
of the same type; e.g., a literal <code>{</code> is <code>{{</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0231"><a class="header" href="#error-code-e0231">Error code E0231</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0231"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented = &quot;error on `{Self}` with params `&lt;{A},{}&gt;`&quot;] // error!
trait BadAnnotation&lt;A&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>
<p>As you can see, you can specify type parameters in curly braces for
substitution with the actual types (using the regular format string syntax) in
a given situation. Furthermore, <code>{Self}</code> will substitute to the type (in this
case, <code>bool</code>) that we tried to use.</p>
<p>This error appears when the curly braces do not contain an identifier. Please
add one of the same name as a type parameter. If you intended to use literal
braces, use <code>{{</code> and <code>}}</code> to escape them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0232"><a class="header" href="#error-code-e0232">Error code E0232</a></h1>
<p>The <code>#[rustc_on_unimplemented]</code> attribute lets you specify a custom error
message for when a particular trait isn't implemented on a type placed in a
position that needs that trait. For example, when the following code is
compiled:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0232"><span class="boring">#![allow(unused)]
</span>#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_on_unimplemented(lorem=&quot;&quot;)] // error!
trait BadAnnotation {}
<span class="boring">}</span></code></pre></pre>
<p>there will be an error about <code>bool</code> not implementing <code>Index&lt;u8&gt;</code>, followed by a
note saying &quot;the type <code>bool</code> cannot be indexed by <code>u8</code>&quot;.</p>
<p>For this to work, some note must be specified. An empty attribute will not do
anything, please remove the attribute or add some helpful note for users of the
trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0243"><a class="header" href="#error-code-e0243">Error code E0243</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-23"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-23">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that not enough type parameters were found in a type or
trait.</p>
<p>For example, the <code>Foo</code> struct below is defined to be generic in <code>T</code>, but the
type parameter is missing in the definition of <code>Bar</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; { x: T }

struct Bar { x: Foo }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0244"><a class="header" href="#error-code-e0244">Error code E0244</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-24"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-24">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error indicates that too many type parameters were found in a type or
trait.</p>
<p>For example, the <code>Foo</code> struct below has no type parameters, but is supplied
with two in the definition of <code>Bar</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0107"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { x: bool }

struct Bar&lt;S, T&gt; { x: Foo&lt;S, T&gt; }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0251"><a class="header" href="#error-code-e0251">Error code E0251</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-25"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-25">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>
<p>An example of this error:</p>
<pre><pre class="playground"><code class="language-rust">use foo::baz;
use bar::*; // error, do `use foo::baz as quux` instead on the previous line

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0252"><a class="header" href="#error-code-e0252">Error code E0252</a></h1>
<p>Two items of the same name cannot be imported without rebinding one of the
items under a new local name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0252">use foo::baz;
use bar::baz; // error, do `use bar::baz as quux` instead

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<p>You can use aliases in order to fix this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">use foo::baz as foo_baz;
use bar::baz; // ok!

fn main() {}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<p>Or you can reference the item with its parent:</p>
<pre><pre class="playground"><code class="language-rust">use bar::baz;

fn main() {
    let x = foo::baz; // ok!
}

mod foo {
    pub struct baz;
}

mod bar {
    pub mod baz {}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0253"><a class="header" href="#error-code-e0253">Error code E0253</a></h1>
<p>Attempt was made to import an unimportable value. This can happen when trying
to import a method from a trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0253">mod foo {
    pub trait MyTrait {
        fn do_something();
    }
}

use foo::MyTrait::do_something;
// error: `do_something` is not directly importable

fn main() {}</code></pre></pre>
<p>It's invalid to directly import methods belonging to a trait or concrete type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0254"><a class="header" href="#error-code-e0254">Error code E0254</a></h1>
<p>Attempt was made to import an item whereas an extern crate with this name has
already been imported.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0254">extern crate core;

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;  // error: an extern crate named `core` has already
                //        been imported in this module

fn main() {}</code></pre></pre>
<p>To fix this issue, you have to rename at least one of the two imports.
Example:</p>
<pre><pre class="playground"><code class="language-rust">extern crate core as libcore; // ok!

mod foo {
    pub trait core {
        fn do_something();
    }
}

use foo::core;

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0255"><a class="header" href="#error-code-e0255">Error code E0255</a></h1>
<p>You can't import a value whose name is the same as another value defined in the
module.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0255">use bar::foo; // error: an item named `foo` is already in scope

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</code></pre></pre>
<p>You can use aliases in order to fix this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">use bar::foo as bar_foo; // ok!

fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {}</code></pre></pre>
<p>Or you can reference the item with its parent:</p>
<pre><pre class="playground"><code class="language-rust">fn foo() {}

mod bar {
     pub fn foo() {}
}

fn main() {
    bar::foo(); // we get the item by referring to its parent
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0256"><a class="header" href="#error-code-e0256">Error code E0256</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-26"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-26">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You can't import a type or module when the name of the item being imported is
the same as another type or submodule defined in the module.</p>
<p>An example of this error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use foo::Bar; // error

type Bar = u32;

mod foo {
    pub mod Bar { }
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0259"><a class="header" href="#error-code-e0259">Error code E0259</a></h1>
<p>The name chosen for an external crate conflicts with another external crate
that has been imported into the current module.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0259">extern crate core;
extern crate std as core;

fn main() {}</code></pre></pre>
<p>The solution is to choose a different name that doesn't conflict with any
external crate imported into the current module.</p>
<p>Correct example:</p>
<pre><pre class="playground"><code class="language-rust">extern crate core;
extern crate std as other_name;

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0260"><a class="header" href="#error-code-e0260">Error code E0260</a></h1>
<p>The name for an item declaration conflicts with an external crate's name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0260">extern crate core;

struct core;

fn main() {}</code></pre></pre>
<p>There are two possible solutions:</p>
<p>Solution #1: Rename the item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate core;

struct xyz;
<span class="boring">}</span></code></pre></pre>
<p>Solution #2: Import the crate with a different name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate core as xyz;

struct abc;
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/statements.html#declaration-statements">Declaration Statements</a> section of the
reference for more information about what constitutes an item declaration
and what does not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0261"><a class="header" href="#error-code-e0261">Error code E0261</a></h1>
<p>An undeclared lifetime was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0261"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, use of undeclared lifetime name `'a`
fn foo(x: &amp;'a str) { }

struct Foo {
    // error, use of undeclared lifetime name `'a`
    x: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<p>These can be fixed by declaring lifetime parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

fn foo&lt;'a&gt;(x: &amp;'a str) {}
<span class="boring">}</span></code></pre></pre>
<p>Impl blocks declare lifetime parameters separately. You need to add lifetime
parameters to an impl block if you're implementing a type that has a lifetime
parameter of its own.
For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0261"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// error,  use of undeclared lifetime name `'a`
impl Foo&lt;'a&gt; {
    fn foo&lt;'a&gt;(x: &amp;'a str) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This is fixed by declaring the impl block like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a str,
}

// correct
impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn foo(x: &amp;'a str) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0262"><a class="header" href="#error-code-e0262">Error code E0262</a></h1>
<p>An invalid name was used for a lifetime parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0262"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// error, invalid lifetime parameter name `'static`
fn foo&lt;'static&gt;(x: &amp;'static str) { }
<span class="boring">}</span></code></pre></pre>
<p>Declaring certain lifetime names in parameters is disallowed. For example,
because the <code>'static</code> lifetime is a special built-in lifetime name denoting
the lifetime of the entire program, this is an error:</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0263"><a class="header" href="#error-code-e0263">Error code E0263</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-27"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-27">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime was declared more than once in the same scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b, 'a&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'a str) { // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Two lifetimes cannot have the same name. To fix this example, change
the second <code>'a</code> lifetime into something else (<code>'c</code> for example):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b, 'c&gt;(x: &amp;'a str, y: &amp;'b str, z: &amp;'c str) { // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0264"><a class="header" href="#error-code-e0264">Error code E0264</a></h1>
<p>An unknown external lang item was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0264"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[lang = &quot;cake&quot;] // error: unknown external lang item: `cake`
    fn cake();
}
<span class="boring">}</span></code></pre></pre>
<p>A list of available external lang items is available in
<code>src/librustc_middle/middle/weak_lang_items.rs</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[lang = &quot;panic_impl&quot;] // ok!
    fn cake();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0267"><a class="header" href="#error-code-e0267">Error code E0267</a></h1>
<p>A loop keyword (<code>break</code> or <code>continue</code>) was used inside a closure but outside of
any loop.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0267"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = || { break; }; // error: `break` inside of a closure
<span class="boring">}</span></code></pre></pre>
<p><code>break</code> and <code>continue</code> keywords can be used as normal inside closures as long as
they are also contained within a loop. To halt the execution of a closure you
should instead use a return statement. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let w = || {
    for _ in 0..10 {
        break;
    }
};

w();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0268"><a class="header" href="#error-code-e0268">Error code E0268</a></h1>
<p>A loop keyword (<code>break</code> or <code>continue</code>) was used outside of a loop.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0268"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func() {
    break; // error: `break` outside of a loop
}
<span class="boring">}</span></code></pre></pre>
<p>Without a loop to break out of or continue in, no sensible action can be taken.
Please verify that you are using <code>break</code> and <code>continue</code> only in loops. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func() {
    for _ in 0..10 {
        break; // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0271"><a class="header" href="#error-code-e0271">Error code E0271</a></h1>
<p>A type mismatched an associated type of a trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0271"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType=u32&gt; {
//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~
//                        |            |
//         This says `foo` can         |
//           only be used with         |
//              some type that         |
//         implements `Trait`.         |
//                                     |
//                             This says not only must
//                             `T` be an impl of `Trait`
//                             but also that the impl
//                             must assign the type `u32`
//                             to the associated type.
    println!(&quot;in foo&quot;);
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }
//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//      |                             |
// `i8` does have                     |
// implementation                     |
// of `Trait`...                      |
//                     ... but it is an implementation
//                     that assigns `&amp;'static str` to
//                     the associated type.

foo(3_i8);
// Here, we invoke `foo` with an `i8`, which does not satisfy
// the constraint `&lt;i8 as Trait&gt;::AssociatedType=u32`, and
// therefore the type-checker complains with this error code.
<span class="boring">}</span></code></pre></pre>
<p>The issue can be resolved by changing the associated type:</p>
<ol>
<li>in the <code>foo</code> implementation:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = &amp;'static str&gt; {
    println!(&quot;in foo&quot;);
}

impl Trait for i8 { type AssociatedType = &amp;'static str; }

foo(3_i8);
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>in the <code>Trait</code> implementation for <code>i8</code>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { type AssociatedType; }

fn foo&lt;T&gt;(t: T) where T: Trait&lt;AssociatedType = u32&gt; {
    println!(&quot;in foo&quot;);
}

impl Trait for i8 { type AssociatedType = u32; }

foo(3_i8);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0275"><a class="header" href="#error-code-e0275">Error code E0275</a></h1>
<p>An evaluation of a trait requirement overflowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0275"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct Bar&lt;T&gt;(T);

impl&lt;T&gt; Foo for T where Bar&lt;T&gt;: Foo {}
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when there was a recursive trait requirement that overflowed
before it could be evaluated. This often means that there is an unbounded
recursion in resolving some type bounds.</p>
<p>To determine if a <code>T</code> is <code>Foo</code>, we need to check if <code>Bar&lt;T&gt;</code> is <code>Foo</code>. However,
to do this check, we need to determine that <code>Bar&lt;Bar&lt;T&gt;&gt;</code> is <code>Foo</code>. To
determine this, we check if <code>Bar&lt;Bar&lt;Bar&lt;T&gt;&gt;&gt;</code> is <code>Foo</code>, and so on. This is
clearly a recursive requirement that can't be resolved directly.</p>
<p>Consider changing your trait bounds so that they're less self-referential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0276"><a class="header" href="#error-code-e0276">Error code E0276</a></h1>
<p>A trait implementation has stricter requirements than the trait definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0276"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo&lt;T&gt;(x: T);
}

impl Foo for bool {
    fn foo&lt;T&gt;(x: T) where T: Copy {}
}
<span class="boring">}</span></code></pre></pre>
<p>Here, all types implementing <code>Foo</code> must have a method <code>foo&lt;T&gt;(x: T)</code> which can
take any type <code>T</code>. However, in the <code>impl</code> for <code>bool</code>, we have added an extra
bound that <code>T</code> is <code>Copy</code>, which isn't compatible with the original trait.</p>
<p>Consider removing the bound from the method or adding the bound to the original
method definition in the trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0277"><a class="header" href="#error-code-e0277">Error code E0277</a></h1>
<p>You tried to use a type which doesn't implement some trait in a place which
expected that trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277">// here we declare the Foo trait with a bar method
trait Foo {
    fn bar(&amp;self);
}

// we now declare a function which takes an object implementing the Foo trait
fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar();
}

fn main() {
    // we now call the method with the i32 type, which doesn't implement
    // the Foo trait
    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied
}</code></pre></pre>
<p>In order to fix this error, verify that the type you're using does implement
the trait. Example:</p>
<pre><pre class="playground"><code class="language-rust">trait Foo {
    fn bar(&amp;self);
}

// we implement the trait on the i32 type
impl Foo for i32 {
    fn bar(&amp;self) {}
}

fn some_func&lt;T: Foo&gt;(foo: T) {
    foo.bar(); // we can now use this method since i32 implements the
               // Foo trait
}

fn main() {
    some_func(5i32); // ok!
}</code></pre></pre>
<p>Or in a generic context, an erroneous code example would look like:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0277">fn some_func&lt;T&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); // error: the trait `core::fmt::Debug` is not
                           //        implemented for the type `T`
}

fn main() {
    // We now call the method with the i32 type,
    // which *does* implement the Debug trait.
    some_func(5i32);
}</code></pre></pre>
<p>Note that the error here is in the definition of the generic function. Although
we only call it with a parameter that does implement <code>Debug</code>, the compiler
still rejects the function. It must work with all possible input types. In
order to make this example compile, we need to restrict the generic type we're
accepting:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// Restrict the input type to types that implement Debug.
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo);
}

fn main() {
    // Calling the method is still fine, as i32 implements Debug.
    some_func(5i32);

    // This would fail to compile now:
    // struct WithoutDebug;
    // some_func(WithoutDebug);
}</code></pre></pre>
<p>Rust only looks at the signature of the called function, as such it must
already specify all requirements that will be used for every type parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0281"><a class="header" href="#error-code-e0281">Error code E0281</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-28"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-28">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>You tried to supply a type which doesn't implement some trait in a location
which expected that trait. This error typically occurs when working with
<code>Fn</code>-based types. Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn foo&lt;F: Fn(usize)&gt;(x: F) { }

fn main() {
    // type mismatch: ... implements the trait `core::ops::Fn&lt;(String,)&gt;`,
    // but the trait `core::ops::Fn&lt;(usize,)&gt;` is required
    // [E0281]
    foo(|y: String| { });
}</code></pre></pre>
<p>The issue in this case is that <code>foo</code> is defined as accepting a <code>Fn</code> with one
argument of type <code>String</code>, but the closure we attempted to pass to it requires
one arguments of type <code>usize</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0282"><a class="header" href="#error-code-e0282">Error code E0282</a></h1>
<p>The compiler could not infer a type and asked for a type annotation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0282"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;hello&quot;.chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that type inference did not result in one unique possible
type, and extra information is required. In most cases this can be provided
by adding a type annotation. Sometimes you need to specify a generic type
parameter manually.</p>
<p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type
parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is
implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet
that reverses the characters of a string:</p>
<p>In the first code example, the compiler cannot infer what the type of <code>x</code> should
be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type
to use, you can use a type annotation on <code>x</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;char&gt; = &quot;hello&quot;.chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>It is not necessary to annotate the full type. Once the ambiguity is resolved,
the compiler can infer the rest:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = &quot;hello&quot;.chars().rev().collect();
<span class="boring">}</span></code></pre></pre>
<p>Another way to provide the compiler with enough information, is to specify the
generic type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;hello&quot;.chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Again, you need not specify the full type if the compiler can infer it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;hello&quot;.chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Apart from a method or function with a generic type parameter, this error can
occur when a type parameter of a struct or trait cannot be inferred. In that
case it is not always possible to use a type annotation, because all candidates
have the same return type. For instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0282"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This will fail because the compiler does not know which instance of <code>Foo</code> to
call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0283"><a class="header" href="#error-code-e0283">Error code E0283</a></h1>
<p>An implementation cannot be chosen unambiguously because of lack of information.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0283"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = foo.into() * 1u32;
<span class="boring">}</span></code></pre></pre>
<p>This error can be solved by adding type annotations that provide the missing
information to the compiler. In this case, the solution is to specify the
trait's type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = Into::&lt;u32&gt;::into(foo) * 1u32;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0284"><a class="header" href="#error-code-e0284">Error code E0284</a></h1>
<p>This error occurs when the compiler is unable to unambiguously infer the
return type of a function or method which is generic on return type, such
as the <code>collect</code> method for <code>Iterator</code>s.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0284">fn main() {
    let n: u32 = 1;
    let mut d: u64 = 2;
    d = d + n.into();
}</code></pre></pre>
<p>Here we have an addition of <code>d</code> and <code>n.into()</code>. Hence, <code>n.into()</code> can return
any type <code>T</code> where <code>u64: Add&lt;T&gt;</code>. On the other hand, the <code>into</code> method can
return any type where <code>u32: Into&lt;T&gt;</code>.</p>
<p>The author of this code probably wants <code>into()</code> to return a <code>u64</code>, but the
compiler can't be sure that there isn't another type <code>T</code> where both
<code>u32: Into&lt;T&gt;</code> and <code>u64: Add&lt;T&gt;</code>.</p>
<p>To resolve this error, use a concrete type for the intermediate expression:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n: u32 = 1;
    let mut d: u64 = 2;
    let m: u64 = n.into();
    d = d + m;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0297"><a class="header" href="#error-code-e0297">Error code E0297</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-29"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-29">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Patterns used to bind names must be irrefutable. That is, they must guarantee
that a name will be extracted in all cases. Instead of pattern matching the
loop variable, consider using a <code>match</code> or <code>if let</code> inside the loop body. For
instance:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0005"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

// This fails because `None` is not covered.
for Some(x) in xs {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Match inside the loop instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    match item {
        Some(x) =&gt; {},
        None =&gt; {},
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or use <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs : Vec&lt;Option&lt;i32&gt;&gt; = vec![Some(1), None];

for item in xs {
    if let Some(x) = item {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0301"><a class="header" href="#error-code-e0301">Error code E0301</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-30"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-30">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Mutable borrows are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if mutable
borrows were allowed:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0596"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(()) {
    None =&gt; { },
    option if option.take().is_none() =&gt; {
        /* impossible, option is `Some` */
    },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0302"><a class="header" href="#error-code-e0302">Error code E0302</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-31"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-31">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Assignments are not allowed in pattern guards, because matching cannot have
side effects. Side effects could alter the matched object or the environment
on which the match depends in such a way, that the match would not be
exhaustive. For instance, the following would not match any arm if assignments
were allowed:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0594"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(()) {
    None =&gt; { },
    option if { option = None; false } =&gt; { },
    Some(_) =&gt; { } // When the previous match failed, the option became `None`.
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0303"><a class="header" href="#error-code-e0303">Error code E0303</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-32"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-32">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Sub-bindings, e.g. <code>ref x @ Some(ref y)</code> are now allowed under
<code>#![feature(bindings_after_at)]</code> and checked to make sure that
memory safety is upheld.</p>
<hr />
<p>In certain cases it is possible for sub-bindings to violate memory safety.
Updates to the borrow checker in a future version of Rust may remove this
restriction, but for now patterns must be rewritten without sub-bindings.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(&quot;hi&quot;.to_string()) {
    ref op_string_ref @ Some(s) =&gt; {},
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match Some(&quot;hi&quot;.to_string()) {
    Some(ref s) =&gt; {
        let op_string_ref = &amp;Some(s);
        // ...
    },
    None =&gt; {},
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>op_string_ref</code> binding has type <code>&amp;Option&lt;&amp;String&gt;</code> in both cases.</p>
<p>See also <a href="https://github.com/rust-lang/rust/issues/14587">Issue 14587</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0307"><a class="header" href="#error-code-e0307">Error code E0307</a></h1>
<p>The <code>self</code> parameter in a method has an invalid &quot;receiver type&quot;.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0307"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

trait Trait {
    fn foo(&amp;self);
}

impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
<span class="boring">}</span></code></pre></pre>
<p>Methods take a special first parameter, of which there are three variants:
<code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. These are syntactic sugar for
<code>self: Self</code>, <code>self: &amp;Self</code>, and <code>self: &amp;mut Self</code> respectively.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span>trait Trait {
    fn foo(&amp;self);
//         ^^^^^ `self` here is a reference to the receiver object
}

impl Trait for Foo {
    fn foo(&amp;self) {}
//         ^^^^^ the receiver type is `&amp;Foo`
}
<span class="boring">}</span></code></pre></pre>
<p>The type <code>Self</code> acts as an alias to the type of the current trait
implementer, or &quot;receiver type&quot;. Besides the already mentioned <code>Self</code>,
<code>&amp;Self</code> and <code>&amp;mut Self</code> valid receiver types, the following are also valid:
<code>self: Box&lt;Self&gt;</code>, <code>self: Rc&lt;Self&gt;</code>, <code>self: Arc&lt;Self&gt;</code>, and <code>self: Pin&lt;P&gt;</code>
(where P is one of the previous types except <code>Self</code>). Note that <code>Self</code> can
also be the underlying implementing type, like <code>Foo</code> in the following
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">trait Trait {
</span><span class="boring">    fn foo(&amp;self);
</span><span class="boring">}
</span>impl Trait for Foo {
    fn foo(self: &amp;Foo) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This error will be emitted by the compiler when using an invalid receiver type,
like in the following example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0307"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">trait Trait {
</span><span class="boring">    fn foo(&amp;self);
</span><span class="boring">}
</span>impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
<span class="boring">}</span></code></pre></pre>
<p>The nightly feature <a href="https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html">Arbitrary self types</a> extends the accepted
set of receiver types to also include any type that can dereference to
<code>Self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(arbitrary_self_types)]

<span class="boring">fn main() {
</span>struct Foo;
struct Bar;

// Because you can dereference `Bar` into `Foo`...
impl std::ops::Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;Foo
    }
}

impl Foo {
    fn foo(self: Bar) {}
//         ^^^^^^^^^ ...it can be used as the receiver type
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0308"><a class="header" href="#error-code-e0308">Error code E0308</a></h1>
<p>Expected type did not match the received type.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0308"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: i32) -&gt; i32 {
    x + 1
}

plus_one(&quot;Not a number&quot;);
//       ^^^^^^^^^^^^^^ expected `i32`, found `&amp;str`

if &quot;Not a bool&quot; {
// ^^^^^^^^^^^^ expected `bool`, found `&amp;str`
}

let x: f32 = &quot;Not a float&quot;;
//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&amp;str`
//     |
//     expected due to this
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an expression was used in a place where the compiler
expected an expression of a different type. It can occur in several cases, the
most common being when calling a function and passing an argument which has a
different type than the matching type in the function declaration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0309"><a class="header" href="#error-code-e0309">Error code E0309</a></h1>
<p>A parameter type is missing an explicit lifetime bound and may not live long
enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0309"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile because the applicable impl of
// `SomeTrait` (below) requires that `T: 'a`, but the struct does
// not have a matching where-clause.
struct Foo&lt;'a, T&gt; {
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output,
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
<span class="boring">}</span></code></pre></pre>
<p>The type definition contains some field whose type requires an outlives
annotation. Outlives annotations (e.g., <code>T: 'a</code>) are used to guarantee that all
the data in <code>T</code> is valid for at least the lifetime <code>'a</code>. This scenario most
commonly arises when the type contains an associated type reference like
<code>&lt;T as SomeTrait&lt;'a&gt;&gt;::Output</code>, as shown in the previous code.</p>
<p>There, the where clause <code>T: 'a</code> that appears on the impl is not known to be
satisfied on the struct. To make this example compile, you have to add a
where-clause like <code>T: 'a</code> to the struct definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt;
where
    T: 'a,
{
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0310"><a class="header" href="#error-code-e0310">Error code E0310</a></h1>
<p>A parameter type is missing a lifetime constraint or has a lifetime that
does not live long enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0310"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This won't compile because T is not constrained to the static lifetime
// the reference needs
struct Foo&lt;T&gt; {
    foo: &amp;'static T
}
<span class="boring">}</span></code></pre></pre>
<p>Type parameters in type definitions have lifetimes associated with them that
represent how long the data stored within them is guaranteed to live. This
lifetime must be as long as the data needs to be alive, and missing the
constraint that denotes this will cause this error.</p>
<p>This will compile, because it has the constraint on the type parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T: 'static&gt; {
    foo: &amp;'static T
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0311"><a class="header" href="#error-code-e0311">Error code E0311</a></h1>
<p>This error occurs when there is an unsatisfied outlives bound involving an
elided region and a generic type parameter or associated type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0311"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_restriction&lt;T&gt;(x: &amp;()) -&gt; &amp;() {
    with_restriction::&lt;T&gt;(x)
}

fn with_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    x
}
<span class="boring">}</span></code></pre></pre>
<p>Why doesn't this code compile? It helps to look at the lifetime bounds that are
automatically added by the compiler. For more details see the documentation for
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision</a>.</p>
<p>The compiler elides the lifetime of <code>x</code> and the return type to some arbitrary
lifetime <code>'anon</code> in <code>no_restriction()</code>. The only information available to the
compiler is that <code>'anon</code> is valid for the duration of the function. When
calling <code>with_restriction()</code>, the compiler requires the completely unrelated
type parameter <code>T</code> to outlive <code>'anon</code> because of the <code>T: 'a</code> bound in
<code>with_restriction()</code>. This causes an error because <code>T</code> is not required to
outlive <code>'anon</code> in <code>no_restriction()</code>.</p>
<p>If <code>no_restriction()</code> were to use <code>&amp;T</code> instead of <code>&amp;()</code> as an argument, the
compiler would have added an implied bound, causing this to compile.</p>
<p>This error can be resolved by explicitly naming the elided lifetime for <code>x</code> and
then explicitly requiring that the generic parameter <code>T</code> outlives that lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    with_restriction::&lt;T&gt;(x)
}

fn with_restriction&lt;'a, T: 'a&gt;(x: &amp;'a ()) -&gt; &amp;'a () {
    x
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0312"><a class="header" href="#error-code-e0312">Error code E0312</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-33"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-33">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Reference's lifetime of borrowed content doesn't match the expected lifetime.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'static str {
    if maybestr.is_none() {
        &quot;(none)&quot;
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Invalid lifetime!
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, either lessen the expected lifetime or find a way to not have
to use this reference outside of its current scope (by running the code directly
in the same block for example?):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In this case, we can fix the issue by switching from &quot;static&quot; lifetime to 'a
pub fn opt_str&lt;'a&gt;(maybestr: &amp;'a Option&lt;String&gt;) -&gt; &amp;'a str {
    if maybestr.is_none() {
        &quot;(none)&quot;
    } else {
        let s: &amp;'a str = maybestr.as_ref().unwrap();
        s  // Ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0316"><a class="header" href="#error-code-e0316">Error code E0316</a></h1>
<p>A <code>where</code> clause contains a nested quantification over lifetimes.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0316"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr&lt;'a, 'b&gt; {}

fn foo&lt;T&gt;(t: T)
where
    for&lt;'a&gt; &amp;'a T: for&lt;'b&gt; Tr&lt;'a, 'b&gt;, // error: nested quantification
{
}
<span class="boring">}</span></code></pre></pre>
<p>Rust syntax allows lifetime quantifications in two places within
<code>where</code> clauses: Quantifying over the trait bound only (as in
<code>Ty: for&lt;'l&gt; Trait&lt;'l&gt;</code>) and quantifying over the whole clause
(as in <code>for&lt;'l&gt; &amp;'l Ty: Trait&lt;'l&gt;</code>). Using both in the same clause
leads to a nested lifetime quantification, which is not supported.</p>
<p>The following example compiles, because the clause with the nested
quantification has been rewritten to use only one <code>for&lt;&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Tr&lt;'a, 'b&gt; {}

fn foo&lt;T&gt;(t: T)
where
    for&lt;'a, 'b&gt; &amp;'a T: Tr&lt;'a, 'b&gt;, // ok
{
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0317"><a class="header" href="#error-code-e0317">Error code E0317</a></h1>
<p>An <code>if</code> expression is missing an <code>else</code> block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0317"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let a = if x == 5 {
    1
};
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an <code>if</code> expression without an <code>else</code> block is used in a
context where a type other than <code>()</code> is expected. In the previous code example,
the <code>let</code> expression was expecting a value but since there was no <code>else</code>, no
value was returned.</p>
<p>An <code>if</code> expression without an <code>else</code> block has the type <code>()</code>, so this is a type
error. To resolve it, add an <code>else</code> block having the same type as the <code>if</code>
block.</p>
<p>So to fix the previous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let a = if x == 5 {
    1
} else {
    2
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0320"><a class="header" href="#error-code-e0320">Error code E0320</a></h1>
<p>Recursion limit reached while creating drop-check rules.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0320"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum A&lt;T&gt; {
    B,
    C(T, Box&lt;A&lt;(T, T)&gt;&gt;)
}

fn foo&lt;T&gt;() {
    A::&lt;T&gt;::B; // error: overflow while adding drop-check rules for A&lt;T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The Rust compiler must be able to reason about how a type is <a href="../std/ops/trait.Drop.html"><code>Drop</code></a>ped, and
by extension the types of its fields, to be able to generate the glue to
properly drop a value. The code example above shows a type where this inference
is impossible because it is recursive. Note that this is <em>not</em> the same as
<a href="E0072.html">E0072</a>, where a type has an infinite size; the type here has a
finite size but any attempt to <code>Drop</code> it would recurse infinitely. For more
information, read <a href="../std/ops/trait.Drop.html">the <code>Drop</code> docs</a>.</p>
<p>It is not possible to define a type with recursive drop-check rules. All such
recursion must be removed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0321"><a class="header" href="#error-code-e0321">Error code E0321</a></h1>
<p>A cross-crate opt-out trait was implemented on something which wasn't a struct
or enum type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0321"><span class="boring">#![allow(unused)]
</span>#![feature(auto_traits)]

<span class="boring">fn main() {
</span>struct Foo;

impl !Sync for Foo {}

unsafe impl Send for &amp;'static Foo {}
// error: cross-crate traits with a default impl, like `core::marker::Send`,
//        can only be implemented for a struct/enum type, not
//        `&amp;'static Foo`
<span class="boring">}</span></code></pre></pre>
<p>Only structs and enums are permitted to impl Send, Sync, and other opt-out
trait, and the struct or enum must be local to the current crate. So, for
example, <code>unsafe impl Send for Rc&lt;Foo&gt;</code> is not allowed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0322"><a class="header" href="#error-code-e0322">Error code E0322</a></h1>
<p>A built-in trait was implemented explicitly. All implementations of the trait
are provided automatically by the compiler.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0322"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Sized for Foo {} // error!
<span class="boring">}</span></code></pre></pre>
<p>The <code>Sized</code> trait is a special trait built-in to the compiler for types with a
constant size known at compile-time. This trait is automatically implemented
for types as needed by the compiler, and it is currently disallowed to
explicitly implement it for a type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0323"><a class="header" href="#error-code-e0323">Error code E0323</a></h1>
<p>An associated const was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0323"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type N;
}

struct Bar;

impl Foo for Bar {
    const N : u32 = 0;
    // error: item `N` is an associated const, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the associated const wasn't misspelled and the correct trait
was implemented. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0324"><a class="header" href="#error-code-e0324">Error code E0324</a></h1>
<p>A method was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0324"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    fn N() {}
    // error: item `N` is an associated method, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please verify that the method name wasn't misspelled and
verify that you are indeed implementing the correct trait items. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;

    fn M();
}

impl Foo for Bar {
    const N : u32 = 0;

    fn M() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0325"><a class="header" href="#error-code-e0325">Error code E0325</a></h1>
<p>An associated type was implemented when another trait item was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0325"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    type N = u32;
    // error: item `N` is an associated type, which doesn't match its
    //        trait `&lt;Bar as Foo&gt;`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the associated type name wasn't misspelled and your
implementation corresponds to the trait definition. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    type N;
}

impl Foo for Bar {
    type N = u32; // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    const N : u32;
}

impl Foo for Bar {
    const N : u32 = 0; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0326"><a class="header" href="#error-code-e0326">Error code E0326</a></h1>
<p>An implementation of a trait doesn't match the type constraint.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0326"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: bool;
}

struct Bar;

impl Foo for Bar {
    const BAR: u32 = 5; // error, expected bool, found u32
}
<span class="boring">}</span></code></pre></pre>
<p>The types of any associated constants in a trait implementation must match the
types in the trait definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0328"><a class="header" href="#error-code-e0328">Error code E0328</a></h1>
<p>The Unsize trait should not be implemented directly. All implementations of
Unsize are provided automatically by the compiler.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0328"><span class="boring">#![allow(unused)]
</span>#![feature(unsize)]

<span class="boring">fn main() {
</span>use std::marker::Unsize;

pub struct MyType;

impl&lt;T&gt; Unsize&lt;T&gt; for MyType {}
<span class="boring">}</span></code></pre></pre>
<p>If you are defining your own smart pointer type and would like to enable
conversion from a sized to an unsized type with the
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md">DST coercion system</a>, use <a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a> instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]

<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

pub struct MyType&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

impl&lt;T, U&gt; CoerceUnsized&lt;MyType&lt;U&gt;&gt; for MyType&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0329"><a class="header" href="#error-code-e0329">Error code E0329</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-34"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-34">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt was made to access an associated constant through either a generic
type parameter or <code>Self</code>. This is not supported yet. An example causing this
error is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_bad&lt;F: Foo&gt;(t: F) -&gt; f64 {
    F::BAR
}
<span class="boring">}</span></code></pre></pre>
<p>Currently, the value of <code>BAR</code> for a particular type can only be accessed
through a concrete type, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const BAR: f64;
}

struct MyStruct;

impl Foo for MyStruct {
    const BAR: f64 = 0f64;
}

fn get_bar_good() -&gt; f64 {
    &lt;MyStruct as Foo&gt;::BAR
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0364"><a class="header" href="#error-code-e0364">Error code E0364</a></h1>
<p>Private items cannot be publicly re-exported. This error indicates that you
attempted to <code>pub use</code> a type or value that was not itself public.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0364"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    fn foo() {}

    mod a {
        pub use super::foo; // error!
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The solution to this problem is to ensure that the items that you are
re-exporting are themselves marked with <code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod a {
    pub fn foo() {} // ok!

    mod a {
        pub use super::foo;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/items/use-declarations.html">Use Declarations</a> section of the reference for
more information on this topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0365"><a class="header" href="#error-code-e0365">Error code E0365</a></h1>
<p>Private modules cannot be publicly re-exported. This error indicates that you
attempted to <code>pub use</code> a module that was not itself public.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0365">mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</code></pre></pre>
<p>The solution to this problem is to ensure that the module that you are
re-exporting is itself marked with <code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub mod foo {
    pub const X: u32 = 1;
}

pub use foo as foo2;

fn main() {}</code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/reference/items/use-declarations.html">Use Declarations</a> section of the reference for
more information on this topic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0366"><a class="header" href="#error-code-e0366">Error code E0366</a></h1>
<p>An attempt was made to implement <code>Drop</code> on a concrete specialization of a
generic type. An example is shown below:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0366"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    t: T
}

impl Drop for Foo&lt;u32&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. One workaround for this is to wrap the
generic type, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T&gt; {
    t: T
}

struct Bar {
    t: Foo&lt;u32&gt;
}

impl Drop for Bar {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0367"><a class="header" href="#error-code-e0367">Error code E0367</a></h1>
<p>An attempt was made to implement <code>Drop</code> on a specialization of a generic type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0367"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

struct MyStruct&lt;T&gt; {
    t: T
}

impl&lt;T: Foo&gt; Drop for MyStruct&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>This code is not legal: it is not possible to specialize <code>Drop</code> to a subset of
implementations of a generic type. In order for this code to work, <code>MyStruct</code>
must also require that <code>T</code> implements <code>Foo</code>. Alternatively, another option is
to wrap the generic type in another that specializes appropriately:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo{}

struct MyStruct&lt;T&gt; {
    t: T
}

struct MyStructWrapper&lt;T: Foo&gt; {
    t: MyStruct&lt;T&gt;
}

impl &lt;T: Foo&gt; Drop for MyStructWrapper&lt;T&gt; {
    fn drop(&amp;mut self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0368"><a class="header" href="#error-code-e0368">Error code E0368</a></h1>
<p>A binary assignment operator like <code>+=</code> or <code>^=</code> was applied to a type that
doesn't support it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0368"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
                   //        type `f32`

x &lt;&lt;= 2;
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait

x &lt;&lt;= 2; // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is also possible to overload most operators for your own type by
implementing the <code>[OP]Assign</code> traits from <code>std::ops</code>.</p>
<p>Another problem you might be facing is this: suppose you've overloaded the <code>+</code>
operator for some type <code>Foo</code> by implementing the <code>std::ops::Add</code> trait for
<code>Foo</code>, but you find that using <code>+=</code> does not work, as in this example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0368">use std::ops::Add;

struct Foo(u32);

impl Add for Foo {
    type Output = Foo;

    fn add(self, rhs: Foo) -&gt; Foo {
        Foo(self.0 + rhs.0)
    }
}

fn main() {
    let mut x: Foo = Foo(5);
    x += Foo(7); // error, `+=` cannot be applied to the type `Foo`
}</code></pre></pre>
<p>This is because <code>AddAssign</code> is not automatically implemented, so you need to
manually implement it for your type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0369"><a class="header" href="#error-code-e0369">Error code E0369</a></h1>
<p>A binary operation was attempted on a type which doesn't support it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0369"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 12f32; // error: binary operation `&lt;&lt;` cannot be applied to
               //        type `f32`

x &lt;&lt; 2;
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please check that this type implements this binary
operation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 12u32; // the `u32` type does implement it:
               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html

x &lt;&lt; 2; // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is also possible to overload most operators for your own type by
implementing traits from <code>std::ops</code>.</p>
<p>String concatenation appends the string on the right to the string on the
left and may require reallocation. This requires ownership of the string
on the left. If something should be added to a string literal, move the
literal to the heap by allocating it with <code>to_owned()</code> like in
<code>&quot;Your text&quot;.to_owned()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0370"><a class="header" href="#error-code-e0370">Error code E0370</a></h1>
<p>The maximum value of an enum was reached, so it cannot be automatically
set in the next enum value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0370"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y, // error: enum discriminant overflowed on value after
       //        9223372036854775807: i64; set explicitly via
       //        Y = -9223372036854775808 if that is desired outcome
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this, please set manually the next enum value or put the enum variant
with the maximum value at the end of the enum. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    X = 0x7fffffffffffffff,
    Y = 0, // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(i64)]
enum Foo {
    Y = 0, // ok!
    X = 0x7fffffffffffffff,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0371"><a class="header" href="#error-code-e0371">Error code E0371</a></h1>
<p>A trait was implemented on another which already automatically implemented it.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0371"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo { fn foo(&amp;self) { } }
trait Bar: Foo { }
trait Baz: Bar { }

impl Bar for Baz { } // error, `Baz` implements `Bar` by definition
impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`
impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`
impl Baz for Bar { } // Note: This is OK
<span class="boring">}</span></code></pre></pre>
<p>When <code>Trait2</code> is a subtrait of <code>Trait1</code> (for example, when <code>Trait2</code> has a
definition like <code>trait Trait2: Trait1 { ... }</code>), it is not allowed to implement
<code>Trait1</code> for <code>Trait2</code>. This is because <code>Trait2</code> already implements <code>Trait1</code> by
definition, so it is not useful to do this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0373"><a class="header" href="#error-code-e0373">Error code E0373</a></h1>
<p>A captured variable in a closure may not live long enough.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}
<span class="boring">}</span></code></pre></pre>
<p>This error occurs when an attempt is made to use data captured by a closure,
when that data may no longer exist. It's most commonly seen when attempting to
return a closure as shown in the previous code example.</p>
<p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures
closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no
longer exists. An attempt to access <code>x</code> within the closure would thus be
unsafe.</p>
<p>Another situation where this might be encountered is when spawning threads:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}
<span class="boring">}</span></code></pre></pre>
<p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code>
may well have disappeared by the time we try to use them. Even if we call
<code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the
stack frame won't disappear), we will not succeed: the compiler cannot prove
that this behavior is safe, and so won't let us do it.</p>
<p>The solution to this problem is usually to switch to using a <code>move</code> closure.
This approach moves (or copies, where possible) data into the closure, rather
than taking references to it. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Box&lt;Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}
<span class="boring">}</span></code></pre></pre>
<p>Now that the closure has its own copy of the data, there's no need to worry
about safety.</p>
<p>This error may also be encountered while using <code>async</code> blocks:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0373 edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn f() {
    let v = vec![1, 2, 3i32];
    spawn(async { //~ ERROR E0373
        println!(&quot;{:?}&quot;, v)
    });
}

fn spawn&lt;F: Future + Send + 'static&gt;(future: F) {
    unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<p>Similarly to closures, <code>async</code> blocks are not executed immediately and may
capture closed-over data by reference. For more information, see
https://rust-lang.github.io/async-book/03_async_await/01_chapter.html.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0374"><a class="header" href="#error-code-e0374">Error code E0374</a></h1>
<p><code>CoerceUnsized</code> was implemented on a struct which does not contain a field with
an unsized type.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0374"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
}

// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>An <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type where the compiler does not know the length or
alignment of at compile time. Any struct containing an unsized type is also
unsized.</p>
<p><code>CoerceUnsized</code> is used to coerce one struct containing an unsized type
into another struct containing a different unsized type. If the struct
doesn't have any fields of unsized types then you don't need explicit
coercion to get the types you want. To fix this you can either
not try to implement <code>CoerceUnsized</code> or you can add a field that is
unsized to the struct.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

// We don't need to impl `CoerceUnsized` here.
struct Foo {
    a: i32,
}

// We add the unsized type field to the struct.
struct Bar&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

// The struct has an unsized field so we can implement
// `CoerceUnsized` for it.
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Bar&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>Note that <code>CoerceUnsized</code> is mainly used by smart pointers like <code>Box</code>, <code>Rc</code>
and <code>Arc</code> to be able to mark that they can coerce unsized types that they
are pointing at.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0375"><a class="header" href="#error-code-e0375">Error code E0375</a></h1>
<p><code>CoerceUnsized</code> was implemented on a struct which contains more than one field
with an unsized type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0375"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized, U: ?Sized&gt; {
    a: i32,
    b: T,
    c: U,
}

// error: Struct `Foo` has more than one unsized field.
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U, T&gt;&gt; for Foo&lt;T, U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>A struct with more than one field containing an unsized type cannot implement
<code>CoerceUnsized</code>. This only occurs when you are trying to coerce one of the
types in your struct to another type in the struct. In this case we try to
impl <code>CoerceUnsized</code> from <code>T</code> to <code>U</code> which are both types that the struct
takes. An <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">unsized type</a> is any type that the compiler doesn't know the
length or alignment of at compile time. Any struct containing an unsized type
is also unsized.</p>
<p><code>CoerceUnsized</code> only allows for coercion from a structure with a single
unsized type field to another struct with a single unsized type field.
In fact Rust only allows for a struct to have one unsized type in a struct
and that unsized type must be the last field in the struct. So having two
unsized types in a single struct is not allowed by the compiler. To fix this
use only one field containing an unsized type in the struct and then use
multiple structs to manage each unsized type field you need.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: i32,
    b: T,
}

impl &lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt;
    where T: CoerceUnsized&lt;U&gt; {}

fn coerce_foo&lt;T: CoerceUnsized&lt;U&gt;, U&gt;(t: T) -&gt; Foo&lt;U&gt; {
    Foo { a: 12i32, b: t } // we use coercion to get the `Foo&lt;U&gt;` type we need
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0376"><a class="header" href="#error-code-e0376">Error code E0376</a></h1>
<p><code>CoerceUnsized</code> was implemented on something that isn't a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0376"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T: ?Sized&gt; {
    a: T,
}

// error: The type `U` is not a struct
impl&lt;T, U&gt; CoerceUnsized&lt;U&gt; for Foo&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><code>CoerceUnsized</code> can only be implemented for a struct. Unsized types are
already able to be coerced without an implementation of <code>CoerceUnsized</code>
whereas a struct containing an unsized type needs to know the unsized type
field it's containing is able to be coerced. An <a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">unsized type</a>
is any type that the compiler doesn't know the length or alignment of at
compile time. Any struct containing an unsized type is also unsized.</p>
<p>The <code>CoerceUnsized</code> trait takes a struct type. Make sure the type you are
providing to <code>CoerceUnsized</code> is a struct with only the last field containing an
unsized type.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

struct Foo&lt;T&gt; {
    a: T,
}

// The `Foo&lt;U&gt;` is a struct so `CoerceUnsized` can be implemented
impl&lt;T, U&gt; CoerceUnsized&lt;Foo&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>Note that in Rust, structs can only contain an unsized type if the field
containing the unsized type is the last and only unsized type field in the
struct.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0377"><a class="header" href="#error-code-e0377">Error code E0377</a></h1>
<p>The trait <code>CoerceUnsized</code> may only be implemented for a coercion between
structures with the same definition.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0377"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
<span class="boring">fn main() {
</span>use std::ops::CoerceUnsized;

pub struct Foo&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

pub struct Bar&lt;T: ?Sized&gt; {
    field_with_unsized_type: T,
}

// error: the trait `CoerceUnsized` may only be implemented for a coercion
//        between structures with the same definition
impl&lt;T, U&gt; CoerceUnsized&lt;Bar&lt;U&gt;&gt; for Foo&lt;T&gt; where T: CoerceUnsized&lt;U&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>When attempting to implement <code>CoerceUnsized</code>, the <code>impl</code> signature must look
like: <code>impl CoerceUnsized&lt;Type&lt;U&gt;&gt; for Type&lt;T&gt; where T: CoerceUnsized&lt;U&gt;</code>;
the <em>implementer</em> and <em><code>CoerceUnsized</code> type parameter</em> must be the same
type. In this example, <code>Bar</code> and <code>Foo</code> (even though structurally identical)
are <em>not</em> the same type and are rejected. Learn more about the <code>CoerceUnsized</code>
trait and DST coercion in
<a href="../std/ops/trait.CoerceUnsized.html">the <code>CoerceUnsized</code> docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0378"><a class="header" href="#error-code-e0378">Error code E0378</a></h1>
<p>The <code>DispatchFromDyn</code> trait was implemented on something which is not a pointer
or a newtype wrapper around a pointer.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0378"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn)]
<span class="boring">fn main() {
</span>use std::ops::DispatchFromDyn;

struct WrapperExtraField&lt;T&gt; {
    ptr: T,
    extra_stuff: i32,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;WrapperExtraField&lt;U&gt;&gt; for WrapperExtraField&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<p>The <code>DispatchFromDyn</code> trait currently can only be implemented for
builtin pointer types and structs that are newtype wrappers around them
— that is, the struct must have only one field (except for<code>PhantomData</code>),
and that field must itself implement <code>DispatchFromDyn</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn, unsize)]
<span class="boring">fn main() {
</span>use std::{
    marker::Unsize,
    ops::DispatchFromDyn,
};

struct Ptr&lt;T: ?Sized&gt;(*const T);

impl&lt;T: ?Sized, U: ?Sized&gt; DispatchFromDyn&lt;Ptr&lt;U&gt;&gt; for Ptr&lt;T&gt;
where
    T: Unsize&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(dispatch_from_dyn)]
<span class="boring">fn main() {
</span>use std::{
    ops::DispatchFromDyn,
    marker::PhantomData,
};

struct Wrapper&lt;T&gt; {
    ptr: T,
    _phantom: PhantomData&lt;()&gt;,
}

impl&lt;T, U&gt; DispatchFromDyn&lt;Wrapper&lt;U&gt;&gt; for Wrapper&lt;T&gt;
where
    T: DispatchFromDyn&lt;U&gt;,
{}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0379"><a class="header" href="#error-code-e0379">Error code E0379</a></h1>
<p>A trait method was declared const.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0379"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const fn bar() -&gt; u32; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Trait methods cannot be declared <code>const</code> by design. For more information, see
<a href="https://github.com/rust-lang/rfcs/pull/911">RFC 911</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0380"><a class="header" href="#error-code-e0380">Error code E0380</a></h1>
<p>An auto trait was declared with a method or an associated item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0380"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe auto trait Trait {
    type Output; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Auto traits cannot have methods or associated items. For more information see
the <a href="https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md">opt-in builtin traits RFC</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0381"><a class="header" href="#error-code-e0381">Error code E0381</a></h1>
<p>It is not allowed to use or capture an uninitialized variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0381">fn main() {
    let x: i32;
    let y = x; // error, use of possibly-uninitialized variable
}</code></pre></pre>
<p>To fix this, ensure that any declared variables are initialized before being
used. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32 = 0;
    let y = x; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0382"><a class="header" href="#error-code-e0382">Error code E0382</a></h1>
<p>A variable was used after its contents have been moved elsewhere.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0382">struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!(&quot;{}&quot;, x.s);
}</code></pre></pre>
<p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out
of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside
of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p>
<p>Sometimes we don't need to move the value. Using a reference, we can let another
function borrow the value without changing its ownership. In the example below,
we don't actually have to move our string to <code>calculate_length</code>, we can give it
a reference to it with <code>&amp;</code> instead.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre></pre>
<p>A mutable reference can be created with <code>&amp;mut</code>.</p>
<p>Sometimes we don't want a reference, but a duplicate. All types marked <code>Clone</code>
can be duplicated by calling <code>.clone()</code>. Subsequent changes to a clone do not
affect the original variable.</p>
<p>Most types in the standard library are marked <code>Clone</code>. The example below
demonstrates using <code>clone()</code> on a string. <code>s1</code> is first set to &quot;many&quot;, and then
copied to <code>s2</code>. Then the first character of <code>s1</code> is removed, without affecting
<code>s2</code>. &quot;any many&quot; is printed to the console.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s1 = String::from(&quot;many&quot;);
    let s2 = s1.clone();
    s1.remove(0);
    println!(&quot;{} {}&quot;, s1, s2);
}</code></pre></pre>
<p>If we control the definition of a type, we can implement <code>Clone</code> on it ourselves
with <code>#[derive(Clone)]</code>.</p>
<p>Some types have no ownership semantics at all and are trivial to duplicate. An
example is <code>i32</code> and the other number types. We don't have to call <code>.clone()</code> to
clone them, because they are marked <code>Copy</code> in addition to <code>Clone</code>. Implicit
cloning is more convenient in this case. We can mark our own types <code>Copy</code> if
all their members also are marked <code>Copy</code>.</p>
<p>In the example below, we implement a <code>Point</code> type. Because it only stores two
integers, we opt-out of ownership semantics with <code>Copy</code>. Then we can
<code>let p2 = p1</code> without <code>p1</code> being moved.</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }

fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!(&quot;p1: {}, {}&quot;, p1.x, p1.y);
    println!(&quot;p2: {}, {}&quot;, p2.x, p2.y);
}</code></pre></pre>
<p>Alternatively, if we don't control the struct's definition, or mutable shared
ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!(&quot;{}&quot;, x.borrow().s);
}</code></pre></pre>
<p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference
count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring
that at most one writer or multiple readers can access the data at any one time.</p>
<p>If you wish to learn more about ownership in Rust, start with the
<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Understanding Ownership</a> chapter in the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0383"><a class="header" href="#error-code-e0383">Error code E0383</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-35"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-35">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to partially reinitialize a
structure that is currently uninitialized.</p>
<p>For example, this can happen when a drop has taken place:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x); // `x` is now uninitialized
x.a = 2; // error, partial reinitialization of uninitialized structure `t`
<span class="boring">}</span></code></pre></pre>
<p>This error can be fixed by fully reinitializing the structure in question:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u32,
}
impl Drop for Foo {
    fn drop(&amp;mut self) { /* ... */ }
}

let mut x = Foo { a: 1 };
drop(x);
x = Foo { a: 2 };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0384"><a class="header" href="#error-code-e0384">Error code E0384</a></h1>
<p>An immutable variable was reassigned.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0384">fn main() {
    let x = 3;
    x = 5; // error, reassignment of immutable variable
}</code></pre></pre>
<p>By default, variables in Rust are immutable. To fix this error, add the keyword
<code>mut</code> after the keyword <code>let</code> when declaring the variable. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 3;
    x = 5;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0386"><a class="header" href="#error-code-e0386">Error code E0386</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-36"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-36">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to mutate the target of a mutable
reference stored inside an immutable container.</p>
<p>For example, this can happen when storing a <code>&amp;mut</code> inside an immutable <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i64 = 1;
let y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2; // error, cannot assign to data in an immutable container
<span class="boring">}</span></code></pre></pre>
<p>This error can be fixed by making the container mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: i64 = 1;
let mut y: Box&lt;_&gt; = Box::new(&amp;mut x);
**y = 2;
<span class="boring">}</span></code></pre></pre>
<p>It can also be fixed by using a type with interior mutability, such as <code>Cell</code>
or <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

let x: i64 = 1;
let y: Box&lt;Cell&lt;_&gt;&gt; = Box::new(Cell::new(x));
y.set(2);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0387"><a class="header" href="#error-code-e0387">Error code E0387</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-37"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-37">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to mutate or mutably reference data
that a closure has captured immutably.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Accepts a function or a closure that captures its environment immutably.
// Closures passed to foo will not be able to mutate their closed-over state.
fn foo&lt;F: Fn()&gt;(f: F) { }

// Attempts to mutate closed-over data. Error message reads:
// `cannot assign to data in a captured outer variable...`
fn mutable() {
    let mut x = 0u32;
    foo(|| x = 2);
}

// Attempts to take a mutable reference to closed-over data. Error message
// reads: `cannot borrow data mutably in a captured outer variable...`
fn mut_addr() {
    let mut x = 0u32;
    foo(|| { let y = &amp;mut x; });
}
<span class="boring">}</span></code></pre></pre>
<p>The problem here is that foo is defined as accepting a parameter of type <code>Fn</code>.
Closures passed into foo will thus be inferred to be of type <code>Fn</code>, meaning that
they capture their context immutably.</p>
<p>If the definition of <code>foo</code> is under your control, the simplest solution is to
capture the data mutably. This can be done by defining <code>foo</code> to take FnMut
rather than Fn:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;F: FnMut()&gt;(f: F) { }
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, we can consider using the <code>Cell</code> and <code>RefCell</code> types to achieve
interior mutability through a shared reference. Our example's <code>mutable</code>
function could be redefined as below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

fn foo&lt;F: Fn()&gt;(f: F) { }

fn mutable() {
    let x = Cell::new(0u32);
    foo(|| x.set(2));
}
<span class="boring">}</span></code></pre></pre>
<p>You can read more in the API documentation for <a href="https://doc.rust-lang.org/std/cell/">Cell</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0388"><a class="header" href="#error-code-e0388">Error code E0388</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-38"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-38">Note: this error code is no longer emitted by the compiler.</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0389"><a class="header" href="#error-code-e0389">Error code E0389</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-39"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-39">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An attempt was made to mutate data using a non-mutable reference. This
commonly occurs when attempting to assign to a non-mutable reference of a
mutable reference (<code>&amp;(&amp;mut T)</code>).</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };
    let fancy_ref = &amp;(&amp;mut fancy);
    fancy_ref.num = 6; // error: cannot assign to data in a `&amp;` reference
    println!(&quot;{}&quot;, fancy_ref.num);
}</code></pre></pre>
<p>Here, <code>&amp;mut fancy</code> is mutable, but <code>&amp;(&amp;mut fancy)</code> is not. Creating an
immutable reference to a value borrows it immutably. There can be multiple
references of type <code>&amp;(&amp;mut T)</code> that point to the same value, so they must be
immutable to prevent multiple mutable references to the same value.</p>
<p>To fix this, either remove the outer reference:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut fancy;
    // `fancy_ref` is now &amp;mut FancyNum, rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!(&quot;{}&quot;, fancy_ref.num);
}</code></pre></pre>
<p>Or make the outer reference mutable:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8
}

fn main() {
    let mut fancy = FancyNum{ num: 5 };

    let fancy_ref = &amp;mut (&amp;mut fancy);
    // `fancy_ref` is now &amp;mut(&amp;mut FancyNum), rather than &amp;(&amp;mut FancyNum)

    fancy_ref.num = 6; // No error!

    println!(&quot;{}&quot;, fancy_ref.num);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0390"><a class="header" href="#error-code-e0390">Error code E0390</a></h1>
<p>A method or constant was implemented on a primitive type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0390"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: i32
}

impl *mut Foo {}
// error: cannot define inherent `impl` for primitive types
<span class="boring">}</span></code></pre></pre>
<p>This isn't allowed, but using a trait to implement a method or constant
is a good solution.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: i32
}

trait Bar {
    fn bar();
}

impl Bar for *mut Foo {
    fn bar() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Instead of defining an inherent implementation on a reference, you could also
move the reference inside the implementation:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0390"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl &amp;Foo { // error: no nominal type found for inherent implementation
    fn bar(self, other: Self) {}
}
<span class="boring">}</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar(&amp;self, other: &amp;Self) {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0391"><a class="header" href="#error-code-e0391">Error code E0391</a></h1>
<p>A type dependency cycle has been encountered.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0391"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait FirstTrait : SecondTrait {

}

trait SecondTrait : FirstTrait {

}
<span class="boring">}</span></code></pre></pre>
<p>The previous example contains a circular dependency between two traits:
<code>FirstTrait</code> depends on <code>SecondTrait</code> which itself depends on <code>FirstTrait</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0392"><a class="header" href="#error-code-e0392">Error code E0392</a></h1>
<p>A type or lifetime parameter has been declared but is not actually used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0392"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo&lt;T&gt; {
    Bar,
}
<span class="boring">}</span></code></pre></pre>
<p>If the type parameter was included by mistake, this error can be fixed
by simply removing the type parameter, as shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, if the type parameter was intentionally inserted, it must be
used. A simple fix is shown below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo&lt;T&gt; {
    Bar(T),
}
<span class="boring">}</span></code></pre></pre>
<p>This error may also commonly be found when working with unsafe code. For
example, when using raw pointers one may wish to specify the lifetime for
which the pointed-at data is valid. An initial attempt (below) causes this
error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0392"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt; {
    x: *const T,
}
<span class="boring">}</span></code></pre></pre>
<p>We want to express the constraint that Foo should not outlive <code>'a</code>, because
the data pointed to by <code>T</code> is only valid for that lifetime. The problem is
that there are no actual uses of <code>'a</code>. It's possible to work around this
by adding a PhantomData type to the struct, using it to tell the compiler
to act as if the struct contained a borrowed reference <code>&amp;'a T</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

struct Foo&lt;'a, T: 'a&gt; {
    x: *const T,
    phantom: PhantomData&lt;&amp;'a T&gt;
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">PhantomData</a> can also be used to express information about unused type
parameters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0393"><a class="header" href="#error-code-e0393">Error code E0393</a></h1>
<p>A type parameter which references <code>Self</code> in its default value was not specified.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0393"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A) {}
// error: the type parameter `T` must be explicitly specified in an
//        object type because its default value `Self` references the
//        type `Self`
<span class="boring">}</span></code></pre></pre>
<p>A trait object is defined over a single, fully-defined trait. With a regular
default parameter, this parameter can just be substituted in. However, if the
default parameter is <code>Self</code>, the trait changes for each concrete type; i.e.
<code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to
implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a
fully-defined trait; instead they share implementations of a trait with
different parameters substituted in for each implementation. This is
irreconcilable with what we need to make a trait object work, and is thus
disallowed. Making the trait concrete by explicitly specifying the value of the
defaulted parameter will fix this issue. Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait A&lt;T=Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;A&lt;i32&gt;) {} // Ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0398"><a class="header" href="#error-code-e0398">Error code E0398</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-40"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-40">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In Rust 1.3, the default object lifetime bounds are expected to change, as
described in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>. You are getting a warning because the compiler
thinks it is possible that this change will cause a compilation error in your
code. It is possible, though unlikely, that this is a false alarm.</p>
<p>The heart of the change is that where <code>&amp;'a Box&lt;SomeTrait&gt;</code> used to default to
<code>&amp;'a Box&lt;SomeTrait+'a&gt;</code>, it now defaults to <code>&amp;'a Box&lt;SomeTrait+'static&gt;</code> (here,
<code>SomeTrait</code> is the name of some trait type). Note that the only types which are
affected are references to boxes, like <code>&amp;Box&lt;SomeTrait&gt;</code> or
<code>&amp;[Box&lt;SomeTrait&gt;]</code>. More common types like <code>&amp;SomeTrait</code> or <code>Box&lt;SomeTrait&gt;</code>
are unaffected.</p>
<p>To silence this warning, edit your code to use an explicit bound. Most of the
time, this means that you will want to change the signature of a function that
you are calling. For example, if the error is reported on a call like <code>foo(x)</code>,
and <code>foo</code> is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait {}
</span>fn foo(arg: &amp;Box&lt;SomeTrait&gt;) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>You might change it to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait SomeTrait {}
</span>fn foo&lt;'a&gt;(arg: &amp;'a Box&lt;SomeTrait+'a&gt;) { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>This explicitly states that you expect the trait object <code>SomeTrait</code> to contain
references (with a maximum lifetime of <code>'a</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0399"><a class="header" href="#error-code-e0399">Error code E0399</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-41"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-41">Note: this error code is no longer emitted by the compiler</a></h4>
<p>You implemented a trait, overriding one or more of its associated types but did
not reimplement its default methods.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_defaults)]

<span class="boring">fn main() {
</span>pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    // error - the following trait items need to be reimplemented as
    //         `Assoc` was overridden: `bar`
    type Assoc = i32;
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this, add an implementation for each default method from the trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_defaults)]

<span class="boring">fn main() {
</span>pub trait Foo {
    type Assoc = u8;
    fn bar(&amp;self) {}
}

impl Foo for i32 {
    type Assoc = i32;
    fn bar(&amp;self) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0401"><a class="header" href="#error-code-e0401">Error code E0401</a></h1>
<p>Inner items do not inherit type or const parameters from the functions
they are embedded in.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the &quot;outer&quot; function
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<p>Nor will this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Or this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0401"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Items inside functions are basically just like top-level items, except
that they can only be used from the function they are in.</p>
<p>There are a couple of solutions for this.</p>
<p>If the item is a function, you may use a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<p>For a generic item, you can copy over the parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Be sure to copy over any bounds as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This may require additional type hints in the function body.</p>
<p>In case the item is a function inside an <code>impl</code>, defining a private helper
function might be easier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt;(T);
</span>impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For default impls in traits, the private helper solution won't work, however
closures or copying the parameters should still work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0403"><a class="header" href="#error-code-e0403">Error code E0403</a></h1>
<p>Some type parameters have the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T, T&gt;(s: T, u: T) {} // error: the name `T` is already used for a generic
                          //        parameter in this item's generic parameters
<span class="boring">}</span></code></pre></pre>
<p>Please verify that none of the type parameters are misspelled, and rename any
clashing parameters. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;T, Y&gt;(s: T, u: Y) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Type parameters in an associated item also cannot shadow parameters from the
containing item:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0403"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;T&gt; {
    fn do_something(&amp;self) -&gt; T;
    fn do_something_else&lt;T: Clone&gt;(&amp;self, bar: T);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0404"><a class="header" href="#error-code-e0404">Error code E0404</a></h1>
<p>A type that is not a trait was used in a trait position, such as a bound
or <code>impl</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0404"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;
struct Bar;

impl Foo for Bar {} // error: `Foo` is not a trait
fn baz&lt;T: Foo&gt;(t: T) {} // error: `Foo` is not a trait
<span class="boring">}</span></code></pre></pre>
<p>Another erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0404"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = Iterator&lt;Item=String&gt;;

fn bar&lt;T: Foo&gt;(t: T) {} // error: `Foo` is a type alias
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the trait's name was not misspelled or that the right
identifier was used. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    // some functions
}
struct Bar;

impl Foo for Bar { // ok!
    // functions implementation
}

fn baz&lt;T: Foo&gt;(t: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you could introduce a new trait with your desired restrictions
as a super trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo {}
</span><span class="boring">struct Bar;
</span><span class="boring">impl Foo for Bar {}
</span>trait Qux: Foo {} // Anything that implements Qux also needs to implement Foo
fn baz&lt;T: Qux&gt;(t: T) {} // also ok!
<span class="boring">}</span></code></pre></pre>
<p>Finally, if you are on nightly and want to use a trait alias
instead of a type alias, you should use <code>#![feature(trait_alias)]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(trait_alias)]
<span class="boring">fn main() {
</span>trait Foo = Iterator&lt;Item=String&gt;;

fn bar&lt;T: Foo&gt;(t: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0405"><a class="header" href="#error-code-e0405">Error code E0405</a></h1>
<p>The code refers to a trait that is not in scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0405"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the name of the trait wasn't misspelled and ensure that it
was imported. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(for_demonstration_only)]
</span>// solution 1:
use some_file::SomeTrait;

// solution 2:
trait SomeTrait {
    // some functions
}

struct Foo;

impl SomeTrait for Foo { // ok!
    // implements functions
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0407"><a class="header" href="#error-code-e0407">Error code E0407</a></h1>
<p>A definition of a method not in the implemented trait was given in a trait
implementation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0407"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // error: method `b` is not a member of trait `Foo`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the method name and you used the correct
trait. First example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
    fn b();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
    fn b() {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Second example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn a();
}

struct Bar;

impl Foo for Bar {
    fn a() {}
}

impl Bar {
    fn b() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0408"><a class="header" href="#error-code-e0408">Error code E0408</a></h1>
<p>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound
across patterns.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0408"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match x {
    Some(y) | None =&gt; { /* use y */ } // error: variable `y` from pattern #1 is
                                      //        not bound in pattern #2
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>y</code> is bound to the contents of the <code>Some</code> and can be used within the
block corresponding to the match arm. However, in case <code>x</code> is <code>None</code>, we have
not specified what <code>y</code> is, and the block will use a nonexistent variable.</p>
<p>To fix this error, either split into multiple match arms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Some(1);
match x {
    Some(y) =&gt; { /* use y */ }
    None =&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>or, bind the variable to a field of the same type in all sub-patterns of the
or pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, y) | (y, 0) =&gt; { /* use y */}
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, if <code>x</code> matches the pattern <code>(0, _)</code>, the second field is set
to <code>y</code>. If it matches <code>(_, 0)</code>, the first field is set to <code>y</code>; so in all
cases <code>y</code> is set to some value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0409"><a class="header" href="#error-code-e0409">Error code E0409</a></h1>
<p>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound
across patterns.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0409"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, ref y) | (y, 0) =&gt; { /* use y */} // error: variable `y` is bound with
                                          //        different mode in pattern #2
                                          //        than in pattern #1
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>y</code> is bound by-value in one case and by-reference in the other.</p>
<p>To fix this error, just use the same mode in both cases.
Generally using <code>ref</code> or <code>ref mut</code> where not already used will fix this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (0, ref y) | (ref y, 0) =&gt; { /* use y */}
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, split the pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (0, 2);
match x {
    (y, 0) =&gt; { /* use y */ }
    (0, ref y) =&gt; { /* use y */}
    _ =&gt; ()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0411"><a class="header" href="#error-code-e0411">Error code E0411</a></h1>
<p>The <code>Self</code> keyword was used outside an impl, trait, or type definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0411"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Self&gt;::foo; // error: use of `Self` outside of an impl, trait, or type
             // definition
<span class="boring">}</span></code></pre></pre>
<p>The <code>Self</code> keyword represents the current type, which explains why it can only
be used inside an impl, trait, or type definition. It gives access to the
associated items of a type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Baz : Foo {
    fn bar() -&gt; Self::Bar; // like this
}
<span class="boring">}</span></code></pre></pre>
<p>However, be careful when two types have a common associated type:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; Self::Bar;
    // error: ambiguous associated type `Bar` in bounds of `Self`
}
<span class="boring">}</span></code></pre></pre>
<p>This problem can be solved by specifying from which trait we want to use the
<code>Bar</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    type Bar;
}

trait Foo2 {
    type Bar;
}

trait Baz : Foo + Foo2 {
    fn bar() -&gt; &lt;Self as Foo&gt;::Bar; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0412"><a class="header" href="#error-code-e0412">Error code E0412</a></h1>
<p>A used type name is not in scope.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0412"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Something {} // error: type name `Something` is not in scope

// or:

trait Foo {
    fn bar(N); // error: type name `N` is not in scope
}

// or:

fn foo(x: T) {} // type name `T` is not in scope
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please verify you didn't misspell the type name, you did
declare it or imported it into the scope. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Something;

impl Something {} // ok!

// or:

trait Foo {
    type N;

    fn bar(_: Self::N); // ok!
}

// or:

fn foo&lt;T&gt;(x: T) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>Another case that causes this error is when a type is imported into a parent
module. To fix this, you can follow the suggestion and use File directly or
<code>use super::File;</code> which will import the types from the parent namespace. An
example that causes this error is below:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0412"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

mod foo {
    fn some_function(f: File) {}
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

mod foo {
    // either
    use super::File;
    // or
    // use std::fs::File;
    fn foo(f: File) {}
}
<span class="boring">fn main() {} // don't insert it for us; that'll break imports</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0415"><a class="header" href="#error-code-e0415">Error code E0415</a></h1>
<p>More than one function parameter have the same name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0415"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than
                          //        once in this parameter list
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell parameters' name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(f: i32, g: i32) {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0416"><a class="header" href="#error-code-e0416">Error code E0416</a></h1>
<p>An identifier is bound more than once in a pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0416"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (1, 2) {
    (x, x) =&gt; {} // error: identifier `x` is bound more than once in the
                 //        same pattern
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell identifiers' name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (1, 2) {
    (x, y) =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or maybe did you mean to unify? Consider using a guard:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let (A, B, C) = (1, 2, 3);
</span>match (A, B, C) {
    (x, x2, see) if x == x2 =&gt; { /* A and B are equal, do one thing */ }
    (y, z, see) =&gt; { /* A and B not equal; do another thing */ }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0422"><a class="header" href="#error-code-e0422">Error code E0422</a></h1>
<p>An identifier that is neither defined nor a struct was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0422">fn main () {
    let x = Foo { x: 1, y: 2 };
}</code></pre></pre>
<p>In this case, <code>Foo</code> is undefined, so it inherently isn't anything, and
definitely not a struct.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main () {
    let foo = 1;
    let x = foo { x: 1, y: 2 };
}</code></pre></pre>
<p>In this case, <code>foo</code> is defined, but is not a struct, so Rust can't use it as
one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0423"><a class="header" href="#error-code-e0423">Error code E0423</a></h1>
<p>An identifier was used like a function name or a value was expected and the
identifier exists but it belongs to a different namespace.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo { a: bool };

let f = Foo();
// error: expected function, tuple struct or tuple variant, found `Foo`
// `Foo` is a struct name, but this expression uses it like a function name
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the name of what you actually wanted to use
here. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Foo() -&gt; u32 { 0 }

let f = Foo(); // ok!
<span class="boring">}</span></code></pre></pre>
<p>It is common to forget the trailing <code>!</code> on macro invocations, which would also
yield this error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println(&quot;&quot;);
// error: expected function, tuple struct or tuple variant,
// found macro `println`
// did you mean `println!(...)`? (notice the trailing `!`)
<span class="boring">}</span></code></pre></pre>
<p>Another case where this error is emitted is when a value is expected, but
something else is found:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0423"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod a {
    pub const I: i32 = 1;
}

fn h1() -&gt; i32 {
    a.I
    //~^ ERROR expected value, found module `a`
    // did you mean `a::I`?
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0424"><a class="header" href="#error-code-e0424">Error code E0424</a></h1>
<p>The <code>self</code> keyword was used inside of an associated function without a &quot;<code>self</code>
receiver&quot; parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0424"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    // `bar` is a method, because it has a receiver parameter.
    fn bar(&amp;self) {}

    // `foo` is not a method, because it has no receiver parameter.
    fn foo() {
        self.bar(); // error: `self` value is a keyword only available in
                    //        methods with a `self` parameter
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>self</code> keyword can only be used inside methods, which are associated
functions (functions defined inside of a <code>trait</code> or <code>impl</code> block) that have a
<code>self</code> receiver as its first parameter, like <code>self</code>, <code>&amp;self</code>, <code>&amp;mut self</code> or
<code>self: &amp;mut Pin&lt;Self&gt;</code> (this last one is an example of an <a href="https://github.com/rust-lang/rust/issues/44874">&quot;arbitrary <code>self</code>
type&quot;</a>).</p>
<p>Check if the associated function's parameter list should have contained a <code>self</code>
receiver for it to be a method, and add it if so. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar(&amp;self) {}

    fn foo(self) { // `foo` is now a method.
        self.bar(); // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0425"><a class="header" href="#error-code-e0425">Error code E0425</a></h1>
<p>An unresolved name was used.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0425"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>something_that_doesnt_exist::foo;
// error: unresolved name `something_that_doesnt_exist::foo`

// or:

trait Foo {
    fn bar() {
        Self; // error: unresolved name `Self`
    }
}

// or:

let x = unknown_variable;  // error: unresolved name `unknown_variable`
<span class="boring">}</span></code></pre></pre>
<p>Please verify that the name wasn't misspelled and ensure that the
identifier being referred to is valid for the given situation. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum something_that_does_exist {
    Foo,
}
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod something_that_does_exist {
    pub static foo : i32 = 0i32;
}

something_that_does_exist::foo; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unknown_variable = 12u32;
let x = unknown_variable; // ok!
<span class="boring">}</span></code></pre></pre>
<p>If the item is not defined in the current module, it must be imported using a
<code>use</code> statement, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod foo { pub fn bar() {} }
</span><span class="boring">fn main() {
</span>use foo::bar;
bar();
<span class="boring">}</span></code></pre></pre>
<p>If the item you are importing is not defined in some super-module of the
current module, then it must also be declared as public (e.g., <code>pub fn</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0426"><a class="header" href="#error-code-e0426">Error code E0426</a></h1>
<p>An undeclared label was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0426"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    break 'a; // error: use of undeclared label `'a`
}
<span class="boring">}</span></code></pre></pre>
<p>Please verify you spelled or declared the label correctly. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    break 'a; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0428"><a class="header" href="#error-code-e0428">Error code E0428</a></h1>
<p>A type or module has been defined more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0428"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;
struct Bar; // error: duplicate definition of value `Bar`
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the type/module's name or remove/rename the
duplicated one. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;
struct Bar2; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0429"><a class="header" href="#error-code-e0429">Error code E0429</a></h1>
<p>The <code>self</code> keyword cannot appear alone as the last segment in a <code>use</code>
declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0429"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::self; // error: `self` imports are only allowed within a { } list
<span class="boring">}</span></code></pre></pre>
<p>To use a namespace itself in addition to some of its members, <code>self</code> may appear
as part of a brace-enclosed list of imports:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::{self, Debug};
<span class="boring">}</span></code></pre></pre>
<p>If you only want to import the namespace, do so directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0430"><a class="header" href="#error-code-e0430">Error code E0430</a></h1>
<p>The <code>self</code> import appears more than once in the list.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0430"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use something::{self, self}; // error: `self` import can only appear once in
                             //        the list
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the import name or remove the duplicated
<code>self</code> import. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod something {}
</span><span class="boring">fn main() {
</span>use something::{self}; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0431"><a class="header" href="#error-code-e0431">Error code E0431</a></h1>
<p>An invalid <code>self</code> import was made.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0431"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use {self}; // error: `self` import can only appear in an import list with a
            //        non-empty prefix
<span class="boring">}</span></code></pre></pre>
<p>You cannot import the current module into itself, please remove this import
or verify you didn't misspell it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0432"><a class="header" href="#error-code-e0432">Error code E0432</a></h1>
<p>An import was unresolved.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0432"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use something::Foo; // error: unresolved import `something::Foo`.
<span class="boring">}</span></code></pre></pre>
<p>In Rust 2015, paths in <code>use</code> statements are relative to the crate root. To
import items relative to the current and parent modules, use the <code>self::</code> and
<code>super::</code> prefixes, respectively.</p>
<p>In Rust 2018 or later, paths in <code>use</code> statements are relative to the current
module unless they begin with the name of a crate or a literal <code>crate::</code>, in
which case they start from the crate root. As in Rust 2015 code, the <code>self::</code>
and <code>super::</code> prefixes refer to the current and parent modules respectively.</p>
<p>Also verify that you didn't misspell the import name and that the import exists
in the module from where you tried to import it. Example:</p>
<pre><pre class="playground"><code class="language-rust">use self::something::Foo; // Ok.

mod something {
    pub struct Foo;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>If you tried to use a module from an external crate and are using Rust 2015,
you may have missed the <code>extern crate</code> declaration (which is usually placed in
the crate root):</p>
<pre><pre class="playground"><code class="language-rust edition2015">extern crate core; // Required to use the `core` crate in Rust 2015.

use core::any;
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Since Rust 2018 the <code>extern crate</code> declaration is not required and
you can instead just <code>use</code> it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use core::any; // No extern crate required in Rust 2018.
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0433"><a class="header" href="#error-code-e0433">Error code E0433</a></h1>
<p>An undeclared crate, module, or type was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0433"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = HashMap::new();
// error: failed to resolve: use of undeclared type `HashMap`
<span class="boring">}</span></code></pre></pre>
<p>Please verify you didn't misspell the type/module's name or that you didn't
forget to import it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap; // HashMap has been imported.
let map: HashMap&lt;u32, u32&gt; = HashMap::new(); // So it can be used!
<span class="boring">}</span></code></pre></pre>
<p>If you've expected to use a crate name:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ferris_wheel::BigO;
// error: failed to resolve: use of undeclared crate or module `ferris_wheel`
<span class="boring">}</span></code></pre></pre>
<p>Make sure the crate has been added as a dependency in <code>Cargo.toml</code>.</p>
<p>To use a module from your current crate, add the <code>crate::</code> prefix to the path.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0434"><a class="header" href="#error-code-e0434">Error code E0434</a></h1>
<p>A variable used inside an inner function comes from a dynamic environment.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0434"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let y = 5;
    fn bar() -&gt; u32 {
        y // error: can't capture dynamic environment in a fn item; use the
          //        || { ... } closure form instead.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Inner functions do not have access to their containing environment. To fix this
error, you can replace the function with a closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    let y = 5;
    let bar = || {
        y
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Or replace the captured variable with a constant or a static item:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    static mut X: u32 = 4;
    const Y: u32 = 5;
    fn bar() -&gt; u32 {
        unsafe {
            X = 3;
        }
        Y
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0435"><a class="header" href="#error-code-e0435">Error code E0435</a></h1>
<p>A non-constant value was used in a constant expression.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0435"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 42;
let a: [u8; foo]; // error: attempt to use a non-constant value in a constant
<span class="boring">}</span></code></pre></pre>
<p>'constant' means 'a compile-time value'.</p>
<p>More details can be found in the <a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants">Variables and Mutability</a> section of the book.</p>
<p>To fix this error, please replace the value with a constant. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [u8; 42]; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: usize = 42;
let a: [u8; FOO]; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0436"><a class="header" href="#error-code-e0436">Error code E0436</a></h1>
<p>The functional record update syntax was used on something other than a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0436"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        c @ PublicationFrequency::SemiMonthly{ .. } =&gt;
            PublicationFrequency::SemiMonthly {
                annual_special: true, ..c // error: functional record update
                                          //        syntax requires a struct
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The functional record update syntax is only allowed for structs (struct-like
enum variants don't qualify, for example). To fix the previous code, rewrite the
expression without functional record update syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PublicationFrequency {
    Weekly,
    SemiMonthly { days: (u8, u8), annual_special: bool },
}

fn one_up_competitor(competitor_frequency: PublicationFrequency)
                     -&gt; PublicationFrequency {
    match competitor_frequency {
        PublicationFrequency::Weekly =&gt; PublicationFrequency::SemiMonthly {
            days: (1, 15), annual_special: false
        },
        PublicationFrequency::SemiMonthly{ days, .. } =&gt;
            PublicationFrequency::SemiMonthly {
                days, annual_special: true // ok!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0437"><a class="header" href="#error-code-e0437">Error code E0437</a></h1>
<p>An associated type whose name does not match any of the associated types
in the trait was used when implementing the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0437"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {
    type Bar = bool;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait implementations can only implement associated types that are members of
the trait in question.</p>
<p>The solution to this problem is to remove the extraneous associated type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0438"><a class="header" href="#error-code-e0438">Error code E0438</a></h1>
<p>An associated constant whose name does not match any of the associated constants
in the trait was used when implementing the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0438"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {
    const BAR: bool = true;
}
<span class="boring">}</span></code></pre></pre>
<p>Trait implementations can only implement associated constants that are
members of the trait in question.</p>
<p>The solution to this problem is to remove the extraneous associated constant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}

impl Foo for i32 {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0439"><a class="header" href="#error-code-e0439">Error code E0439</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-42"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-42">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The length of the platform-intrinsic function <code>simd_shuffle</code> wasn't specified.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#![feature(platform_intrinsics)]

extern &quot;platform-intrinsic&quot; {
    fn simd_shuffle&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`
}</code></pre>
<p>The <code>simd_shuffle</code> function needs the length of the array passed as
last parameter in its name. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(platform_intrinsics)]

<span class="boring">fn main() {
</span>extern &quot;platform-intrinsic&quot; {
    fn simd_shuffle8&lt;A,B&gt;(a: A, b: A, c: [u32; 8]) -&gt; B;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0445"><a class="header" href="#error-code-e0445">Error code E0445</a></h1>
<p>A private trait was used on a public type parameter bound.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0445">#![deny(private_in_public)]

trait Foo {
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // error: private trait in public interface
pub struct Bar2&lt;T: Foo&gt;(pub T); // same error
pub fn foo&lt;T: Foo&gt; (t: T) {} // same error

fn main() {}</code></pre></pre>
<p>To solve this error, please ensure that the trait is also public. The trait
can be made inaccessible if necessary by placing it into a private inner
module, but it still has to be marked with <code>pub</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Foo { // we set the Foo trait public
    fn dummy(&amp;self) { }
}

pub trait Bar : Foo {} // ok!
pub struct Bar2&lt;T: Foo&gt;(pub T); // ok!
pub fn foo&lt;T: Foo&gt; (t: T) {} // ok!

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0446"><a class="header" href="#error-code-e0446">Error code E0446</a></h1>
<p>A private type was used in a public type signature.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0446">#![deny(private_in_public)]
struct Bar(u32);

mod foo {
    use crate::Bar;
    pub fn bar() -&gt; Bar { // error: private type in public interface
        Bar(0)
    }
}

fn main() {}</code></pre></pre>
<p>There are two ways to solve this error. The first is to make the public type
signature only public to a module that also has access to the private type.
This is done by using pub(crate) or pub(in crate::my_mod::etc)
Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Bar(u32);

mod foo {
    use crate::Bar;
    pub(crate) fn bar() -&gt; Bar { // only public to crate root
        Bar(0)
    }
}

fn main() {}</code></pre></pre>
<p>The other way to solve this error is to make the private type public.
Example:</p>
<pre><pre class="playground"><code class="language-rust">pub struct Bar(u32); // we set the Bar type public
mod foo {
    use crate::Bar;
    pub fn bar() -&gt; Bar { // ok!
        Bar(0)
    }
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0447"><a class="header" href="#error-code-e0447">Error code E0447</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-43"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-43">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>pub</code> keyword was used inside a function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    pub struct Bar; // error: visibility has no effect inside functions
}
<span class="boring">}</span></code></pre></pre>
<p>Since we cannot access items defined inside a function, the visibility of its
items does not impact outer code. So using the <code>pub</code> keyword in this context
is invalid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0448"><a class="header" href="#error-code-e0448">Error code E0448</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-44"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-44">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>pub</code> keyword was used inside a public enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo {
    pub Bar, // error: unnecessary `pub` visibility
}
<span class="boring">}</span></code></pre></pre>
<p>Since the enum is already public, adding <code>pub</code> on one its elements is
unnecessary. Example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    pub Bar, // not ok!
}
<span class="boring">}</span></code></pre></pre>
<p>This is the correct syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Foo {
    Bar, // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0449"><a class="header" href="#error-code-e0449">Error code E0449</a></h1>
<p>A visibility qualifier was used where one is not permitted. Visibility
qualifiers are not permitted on enum variants, trait items, impl blocks, and
extern blocks, as they already share the visibility of the parent item.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0449"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    fn foo();
}

enum Baz {
    pub Qux, // error: visibility qualifiers are not permitted here
}

pub impl Bar {} // error: visibility qualifiers are not permitted here

pub impl Foo for Bar { // error: visibility qualifiers are not permitted here
    pub fn foo() {} // error: visibility qualifiers are not permitted here
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, simply remove the visibility qualifier. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Bar;

trait Foo {
    fn foo();
}

enum Baz {
    // Enum variants share the visibility of the enum they are in, so
    // `pub` is not allowed here
    Qux,
}

// Directly implemented methods share the visibility of the type itself,
// so `pub` is not allowed here
impl Bar {}

// Trait methods share the visibility of the trait, so `pub` is not
// allowed in either case
impl Foo for Bar {
    fn foo() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0451"><a class="header" href="#error-code-e0451">Error code E0451</a></h1>
<p>A struct constructor with private fields was invoked.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0451"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        b: isize,
    }
}

let f = bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `bar::Foo`
                                //        is private
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, please ensure that all the fields of the struct are public,
or implement a function for easy instantiation. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        pub b: isize, // we set `b` field public
    }
}

let f = bar::Foo{ a: 0, b: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod bar {
    pub struct Foo {
        pub a: isize,
        b: isize, // still private
    }

    impl Foo {
        pub fn new() -&gt; Foo { // we create a method to instantiate `Foo`
            Foo { a: 0, b: 0 }
        }
    }
}

let f = bar::Foo::new(); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0452"><a class="header" href="#error-code-e0452">Error code E0452</a></h1>
<p>An invalid lint attribute has been given.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0452"><span class="boring">#![allow(unused)]
</span>#![allow(foo = &quot;&quot;)] // error: malformed lint attribute
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Lint attributes only accept a list of identifiers (where each identifier is a
lint name). Ensure the attribute is of this form:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(foo)] // ok!
<span class="boring">fn main() {
</span>// or:
#![allow(foo, foo2)] // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0453"><a class="header" href="#error-code-e0453">Error code E0453</a></h1>
<p>A lint check attribute was overruled by a <code>forbid</code> directive set as an
attribute on an enclosing scope, or on the command line with the <code>-F</code> option.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0453">#![forbid(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer
                      //        forbid(non_snake_case)
}</code></pre></pre>
<p>The <code>forbid</code> lint setting, like <code>deny</code>, turns the corresponding compiler
warning into a hard error. Unlike <code>deny</code>, <code>forbid</code> prevents itself from being
overridden by inner attributes.</p>
<p>If you're sure you want to override the lint check, you can change <code>forbid</code> to
<code>deny</code> (or use <code>-D</code> instead of <code>-F</code> if the <code>forbid</code> setting was given as a
command-line option) to allow the inner lint check attribute:</p>
<pre><pre class="playground"><code class="language-rust">#![deny(non_snake_case)]

#[allow(non_snake_case)]
fn main() {
    let MyNumber = 2; // ok!
}</code></pre></pre>
<p>Otherwise, edit the code to pass the lint check, and remove the overruled
attribute:</p>
<pre><pre class="playground"><code class="language-rust">#![forbid(non_snake_case)]

fn main() {
    let my_number = 2;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0454"><a class="header" href="#error-code-e0454">Error code E0454</a></h1>
<p>A link name was given with an empty name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0454"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;&quot;)] extern &quot;C&quot; {}
// error: `#[link(name = &quot;&quot;)]` given with empty name
<span class="boring">}</span></code></pre></pre>
<p>The rust compiler cannot link to an external library if you don't give it its
name. Example:</p>
<pre><code class="language-no_run">#[link(name = &quot;some_lib&quot;)] extern &quot;C&quot; {} // ok!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0455"><a class="header" href="#error-code-e0455">Error code E0455</a></h1>
<p>Some linking kinds are target-specific and not supported on all platforms.</p>
<p>Linking with <code>kind=framework</code> is only supported when targeting macOS,
as frameworks are specific to that operating system.</p>
<p>Similarly, <code>kind=raw-dylib</code> is only supported when targeting Windows-like
platforms.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)">#[link(name = &quot;FooCoreServices&quot;, kind = &quot;framework&quot;)] extern &quot;C&quot; {}
// OS used to compile is Linux for example</code></pre>
<p>To solve this error you can use conditional compilation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(target=&quot;macos&quot;, link(name = &quot;FooCoreServices&quot;, kind = &quot;framework&quot;))]
extern &quot;C&quot; {}
<span class="boring">}</span></code></pre></pre>
<p>Learn more in the <a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">Conditional Compilation</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0457"><a class="header" href="#error-code-e0457">Error code E0457</a></h1>
<p>Plugin <code>..</code> only found in rlib format, but must be available in dylib format.</p>
<p>Erroneous code example:</p>
<p><code>rlib-plugin.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_type = &quot;rlib&quot;]
#![feature(rustc_private)]

extern crate rustc_middle;
extern crate rustc_driver;

use rustc_driver::plugin::Registry;

#[no_mangle]
fn __rustc_plugin_registrar(_: &amp;mut Registry) {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![feature(plugin)]
#![plugin(rlib_plugin)] // error: plugin `rlib_plugin` only found in rlib
                        //        format, but must be available in dylib

fn main() {}</code></pre>
<p>The compiler exposes a plugin interface to allow altering the compile process
(adding lints, etc). Plugins must be defined in their own crates (similar to
<a href="../reference/procedural-macros.html">proc-macro</a> isolation) and then compiled
and linked to another crate. Plugin crates <em>must</em> be compiled to the
dynamically-linked dylib format, and not the statically-linked rlib format.
Learn more about different output types in
<a href="../reference/linkage.html">this section</a> of the Rust reference.</p>
<p>This error is easily fixed by recompiling the plugin crate in the dylib format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0458"><a class="header" href="#error-code-e0458">Error code E0458</a></h1>
<p>An unknown &quot;kind&quot; was specified for a link attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0458"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(kind = &quot;wonderful_unicorn&quot;)] extern &quot;C&quot; {}
// error: unknown kind: `wonderful_unicorn`
<span class="boring">}</span></code></pre></pre>
<p>Please specify a valid &quot;kind&quot; value, from one of the following:</p>
<ul>
<li>static</li>
<li>dylib</li>
<li>framework</li>
<li>raw-dylib</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0459"><a class="header" href="#error-code-e0459">Error code E0459</a></h1>
<p>A link was used without a name parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0459"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(kind = &quot;dylib&quot;)] extern &quot;C&quot; {}
// error: `#[link(...)]` specified without `name = &quot;foo&quot;`
<span class="boring">}</span></code></pre></pre>
<p>Please add the name parameter to allow the rust compiler to find the library
you want. Example:</p>
<pre><code class="language-no_run">#[link(kind = &quot;dylib&quot;, name = &quot;some_lib&quot;)] extern &quot;C&quot; {} // ok!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0460"><a class="header" href="#error-code-e0460">Error code E0460</a></h1>
<p>Found possibly newer version of crate <code>..</code> which <code>..</code> depends on.</p>
<p>Consider these erroneous files:</p>
<p><code>a1.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = &quot;a&quot;]

pub fn foo&lt;T&gt;() {}</code></pre>
<p><code>a2.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = &quot;a&quot;]

pub fn foo&lt;T&gt;() {
    println!(&quot;foo&lt;T&gt;()&quot;);
}</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">#![crate_name = &quot;b&quot;]

extern crate a; // linked with `a1.rs`

pub fn foo() {
    a::foo::&lt;isize&gt;();
}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (needs-linkage-with-other-tests)">extern crate a; // linked with `a2.rs`
extern crate b; // error: found possibly newer version of crate `a` which `b`
                //        depends on

fn main() {}</code></pre>
<p>The dependency graph of this program can be represented as follows:</p>
<pre><code class="language-text">    crate `main`
         |
         +-------------+
         |             |
         |             v
depends: |         crate `b`
 `a` v1  |             |
         |             | depends:
         |             |  `a` v2
         v             |
      crate `a` &lt;------+
</code></pre>
<p>Crate <code>main</code> depends on crate <code>a</code> (version 1) and crate <code>b</code> which in turn
depends on crate <code>a</code> (version 2); this discrepancy in versions cannot be
reconciled. This difference in versions typically occurs when one crate is
compiled and linked, then updated and linked to another crate. The crate
&quot;version&quot; is a SVH (Strict Version Hash) of the crate in an
implementation-specific way. Note that this error can <em>only</em> occur when
directly compiling and linking with <code>rustc</code>; <a href="../cargo/index.html">Cargo</a> automatically resolves
dependencies, without using the compiler's own dependency management that
causes this issue.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically fixing this issue.</li>
<li>Recompiling crate <code>a</code> so that both crate <code>b</code> and <code>main</code> have a uniform
version to depend on.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0461"><a class="header" href="#error-code-e0461">Error code E0461</a></h1>
<p>Couldn't find crate <code>..</code> with expected target triple <code>..</code>.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_type = &quot;lib&quot;]

fn foo() {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">extern crate a;

fn main() {
    a::foo();
}</code></pre>
<p><code>a.rs</code> is then compiled with <code>--target powerpc-unknown-linux-gnu</code> and <code>b.rs</code>
with <code>--target x86_64-unknown-linux-gnu</code>. <code>a.rs</code> is compiled into a binary
format incompatible with <code>b.rs</code>; PowerPC and x86 are totally different
architectures. This issue also extends to any difference in target triples, as
<code>std</code> is operating-system specific.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling either crate so that they target a consistent target triple.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0462"><a class="header" href="#error-code-e0462">Error code E0462</a></h1>
<p>Found <code>staticlib</code> <code>..</code> instead of <code>rlib</code> or <code>dylib</code>.</p>
<p>Consider the following two files:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_type = &quot;staticlib&quot;]

fn foo() {}</code></pre>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">extern crate a;

fn main() {
    a::foo();
}</code></pre>
<p>Crate <code>a</code> is compiled as a <code>staticlib</code>. A <code>staticlib</code> is a system-dependant
library only intended for linking with non-Rust applications (C programs). Note
that <code>staticlib</code>s include all upstream dependencies (<code>core</code>, <code>std</code>, other user
dependencies, etc) which makes them significantly larger than <code>dylib</code>s:
prefer <code>staticlib</code> for linking with C programs. Learn more about different
<code>crate_type</code>s in <a href="../reference/linkage.html">this section of the Reference</a>.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling the crate as a <code>rlib</code> or <code>dylib</code>; formats suitable for Rust
linking.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0463"><a class="header" href="#error-code-e0463">Error code E0463</a></h1>
<p>A plugin/crate was declared but cannot be found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0463"><span class="boring">#![allow(unused)]
</span>#![feature(plugin)]
#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`
<span class="boring">fn main() {
</span>extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`
<span class="boring">}</span></code></pre></pre>
<p>You need to link your code to the relevant crate in order to be able to use it
(through Cargo or the <code>-L</code> option of rustc example). Plugins are crates as
well, and you link to them the same way.</p>
<h2 id="common-causes"><a class="header" href="#common-causes">Common causes</a></h2>
<ul>
<li>The crate is not present at all. If using Cargo, add it to <code>[dependencies]</code>
in Cargo.toml.</li>
<li>The crate is present, but under a different name. If using Cargo, look for
<code>package = </code> under <code>[dependencies]</code> in Cargo.toml.</li>
</ul>
<h2 id="common-causes-for-missing-std-or-core"><a class="header" href="#common-causes-for-missing-std-or-core">Common causes for missing <code>std</code> or <code>core</code></a></h2>
<ul>
<li>You are cross-compiling for a target which doesn't have <code>std</code> prepackaged.
Consider one of the following:
<ul>
<li>Adding a pre-compiled version of std with <code>rustup target add</code></li>
<li>Building std from source with <code>cargo build -Z build-std</code></li>
<li>Using <code>#![no_std]</code> at the crate root, so you won't need <code>std</code> in the first
place.</li>
</ul>
</li>
<li>You are developing the compiler itself and haven't built libstd from source.
You can usually build it with <code>x.py build library/std</code>. More information
about x.py is available in the <a href="https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#building-the-compiler">rustc-dev-guide</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0464"><a class="header" href="#error-code-e0464">Error code E0464</a></h1>
<p>The compiler found multiple library files with the requested crate name.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// aux-build:crateresolve-1.rs
// aux-build:crateresolve-2.rs
// aux-build:crateresolve-3.rs

extern crate crateresolve;
//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found

fn main() {}</code></pre></pre>
<p>This error can occur in several different cases -- for example, when using
<code>extern crate</code> or passing <code>--extern</code> options without crate paths. It can also be
caused by caching issues with the build directory, in which case <code>cargo clean</code>
may help.</p>
<p>In the above example, there are three different library files, all of which
define the same crate name. Without providing a full path, there is no way for
the compiler to know which crate it should use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0466"><a class="header" href="#error-code-e0466">Error code E0466</a></h1>
<p>Macro import declaration was malformed.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0466"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use(a_macro(another_macro))] // error: invalid import declaration
extern crate core as some_crate;

#[macro_use(i_want = &quot;some_macros&quot;)] // error: invalid import declaration
extern crate core as another_crate;
<span class="boring">}</span></code></pre></pre>
<p>This is a syntax error at the level of attribute declarations. The proper
syntax for macro imports is the following:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">// In some_crate:
#[macro_export]
macro_rules! get_tacos {
    ...
}

#[macro_export]
macro_rules! get_pimientos {
    ...
}

// In your crate:
#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and
extern crate some_crate;               // `get_pimientos` macros from some_crate</code></pre>
<p>If you would like to import all exported macros, write <code>macro_use</code> with no
arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0468"><a class="header" href="#error-code-e0468">Error code E0468</a></h1>
<p>A non-root module tried to import macros from another crate.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0468"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    #[macro_use(debug_assert)]  // error: must be at crate root to import
    extern crate core;          //        macros from another crate
    fn run_macro() { debug_assert!(true); }
}
<span class="boring">}</span></code></pre></pre>
<p>Only <code>extern crate</code> imports at the crate root level are allowed to import
macros.</p>
<p>Either move the macro import to crate root or do without the foreign macros.
This will work:</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use(debug_assert)] // ok!
extern crate core;

mod foo {
    fn run_macro() { debug_assert!(true); }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0469"><a class="header" href="#error-code-e0469">Error code E0469</a></h1>
<p>A macro listed for import was not found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0469">#[macro_use(drink, be_merry)] // error: imported macro not found
extern crate alloc;

fn main() {
    // ...
}</code></pre></pre>
<p>Either the listed macro is not contained in the imported crate, or it is not
exported from the given crate.</p>
<p>This could be caused by a typo. Did you misspell the macro's name?</p>
<p>Double-check the names of the macros listed for import, and that the crate
in question exports them.</p>
<p>A working version would be:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">// In some_crate crate:
#[macro_export]
macro_rules! eat {
    ...
}

#[macro_export]
macro_rules! drink {
    ...
}

// In your crate:
#[macro_use(eat, drink)]
extern crate some_crate; //ok!</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0472"><a class="header" href="#error-code-e0472">Error code E0472</a></h1>
<p>Inline assembly (<code>asm!</code>) is not supported on this target.</p>
<p>Example of erroneous code:</p>
<pre><code class="language-rust ignore (cannot-change-target)">// compile-flags: --target sparc64-unknown-linux-gnu
#![no_std]

use core::arch::asm;

fn main() {
    unsafe {
        asm!(&quot;&quot;); // error: inline assembly is not supported on this target
    }
}</code></pre>
<p>The Rust compiler does not support inline assembly, with the <code>asm!</code> macro
(previously <code>llvm_asm!</code>), for all targets. All Tier 1 targets do support this
macro but support among Tier 2 and 3 targets is not guaranteed (even when they
have <code>std</code> support). Note that this error is related to
<code>error[E0658]: inline assembly is not stable yet on this architecture</code>, but
distinct in that with <code>E0472</code> support is not planned or in progress.</p>
<p>There is no way to easily fix this issue, however:</p>
<ul>
<li>Consider if you really need inline assembly, is there some other way to
achieve your goal (intrinsics, etc)?</li>
<li>Consider writing your assembly externally, linking with it and calling it
from Rust.</li>
<li>Consider contributing to <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a> and help
integrate support for your target!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0476"><a class="header" href="#error-code-e0476">Error code E0476</a></h1>
<p>The coerced type does not outlive the value being coerced to.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0476"><span class="boring">#![allow(unused)]
</span>#![feature(coerce_unsized)]
#![feature(unsize)]

<span class="boring">fn main() {
</span>use std::marker::Unsize;
use std::ops::CoerceUnsized;

// error: lifetime of the source pointer does not outlive lifetime bound of the
//        object type
impl&lt;'a, 'b, T, S&gt; CoerceUnsized&lt;&amp;'a T&gt; for &amp;'b S where S: Unsize&lt;T&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>During a coercion, the &quot;source pointer&quot; (the coerced type) did not outlive the
&quot;object type&quot; (value being coerced to). In the above example, <code>'b</code> is not a
subtype of <code>'a</code>. This error can currently only be encountered with the unstable
<code>CoerceUnsized</code> trait which allows custom coercions of unsized types behind a
smart pointer to be implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0477"><a class="header" href="#error-code-e0477">Error code E0477</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-45"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-45">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The type does not fulfill the required lifetime.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string&lt;'a&gt;(s: Mutex&lt;MyString&lt;'a&gt;&gt;) {

    i_want_static_closure(move || {     // error: this closure has lifetime 'a
                                        //        rather than 'static
        println!(&quot;{}&quot;, s.lock().unwrap().data);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the closure does not satisfy the <code>'static</code> lifetime constraint.
To fix this error, you need to double check the lifetime of the type. Here, we
can fix this problem by giving <code>s</code> a static lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyString&lt;'a&gt; {
    data: &amp;'a str,
}

fn i_want_static_closure&lt;F&gt;(a: F)
    where F: Fn() + 'static {}

fn print_string(s: Mutex&lt;MyString&lt;'static&gt;&gt;) {

    i_want_static_closure(move || {     // ok!
        println!(&quot;{}&quot;, s.lock().unwrap().data);
    });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0478"><a class="header" href="#error-code-e0478">Error code E0478</a></h1>
<p>A lifetime bound was not satisfied.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0478"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must
// outlive all the superbounds from the trait (`'kiss`, in this example).

trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite&gt; {
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;,
    // error: lifetime bound not satisfied
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, the <code>'SnowWhite</code> lifetime is supposed to outlive the <code>'kiss</code>
lifetime but the declaration of the <code>Prince</code> struct doesn't enforce it. To fix
this issue, you need to specify it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Wedding&lt;'t&gt;: 't { }

struct Prince&lt;'kiss, 'SnowWhite: 'kiss&gt; { // You say here that 'SnowWhite
                                          // must live longer than 'kiss.
    child: Box&lt;Wedding&lt;'kiss&gt; + 'SnowWhite&gt;, // And now it's all good!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0482"><a class="header" href="#error-code-e0482">Error code E0482</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-46"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-46">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime of a returned value does not outlive the function call.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0700"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; { // error!
    words.map(|v| format!(&quot;foo-{}&quot;, v))
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, make the lifetime of the returned value explicit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt; + 'a
) -&gt; impl Iterator&lt;Item = String&gt; + 'a { // ok!
    words.map(|v| format!(&quot;foo-{}&quot;, v))
}
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://doc.rust-lang.org/reference/types/impl-trait.html"><code>impl Trait</code></a> feature in this example uses an implicit <code>'static</code> lifetime
restriction in the returned type. However the type implementing the <code>Iterator</code>
passed to the function lives just as long as <code>'a</code>, which is not long enough.</p>
<p>The solution involves adding lifetime bound to both function argument and
the return value to make sure that the values inside the iterator
are not dropped when the function goes out of the scope.</p>
<p>An alternative solution would be to guarantee that the <code>Item</code> references
in the iterator are alive for the whole lifetime of the program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prefix(
    words: impl Iterator&lt;Item = &amp;'static str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; {  // ok!
    words.map(|v| format!(&quot;foo-{}&quot;, v))
}
<span class="boring">}</span></code></pre></pre>
<p>A similar lifetime problem might arise when returning closures:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0700"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(
    x: &amp;mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] { // error!
    |y| {
        y.append(x);
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Analogically, a solution here is to use explicit return lifetime
and move the ownership of the variable to the closure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(
    x: &amp;'a mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] + 'a { // ok!
    move |y| {
        y.append(x);
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To better understand the lifetime treatment in the <a href="https://doc.rust-lang.org/reference/types/impl-trait.html"><code>impl Trait</code></a>,
please see the <a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html">RFC 1951</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0491"><a class="header" href="#error-code-e0491">Error code E0491</a></h1>
<p>A reference has a longer lifetime than the data it references.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0491"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b&gt; Trait&lt;'a, 'b&gt; for usize {
    type Out = &amp;'a Foo&lt;'b&gt;; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the problem is that the compiler cannot be sure that the <code>'b</code> lifetime
will live longer than <code>'a</code>, which should be mandatory in order to be sure that
<code>Trait::Out</code> will always have a reference pointing to an existing type. So in
this case, we just need to tell the compiler than <code>'b</code> must outlive <code>'a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: fn(&amp;'a i32),
}

trait Trait&lt;'a, 'b&gt; {
    type Out;
}

impl&lt;'a, 'b: 'a&gt; Trait&lt;'a, 'b&gt; for usize { // we added the lifetime enforcement
    type Out = &amp;'a Foo&lt;'b&gt;; // it now works!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0492"><a class="header" href="#error-code-e0492">Error code E0492</a></h1>
<p>A borrow of a constant containing interior mutability was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0492"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::AtomicUsize;

const A: AtomicUsize = AtomicUsize::new(0);
const B: &amp;'static AtomicUsize = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead
<span class="boring">}</span></code></pre></pre>
<p>A <code>const</code> represents a constant value that should never change. If one takes
a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory
location containing the value. Normally this is perfectly fine: most values
can't be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow
it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is
explicitly a single memory location, which can be mutated at will.</p>
<p>So, in order to solve this error, use statics which are <code>Sync</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::AtomicUsize;

static A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A; // ok!
<span class="boring">}</span></code></pre></pre>
<p>You can also have this error while using a cell type:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0492"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

const A: Cell&lt;usize&gt; = Cell::new(1);
const B: &amp;Cell&lt;usize&gt; = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead

// or:
struct C { a: Cell&lt;usize&gt; }

const D: C = C { a: Cell::new(1) };
const E: &amp;Cell&lt;usize&gt; = &amp;D.a; // error

// or:
const F: &amp;C = &amp;D; // error
<span class="boring">}</span></code></pre></pre>
<p>This is because cell types do operations that are not thread-safe. Due to this,
they don't implement Sync and thus can't be placed in statics.</p>
<p>However, if you still wish to use these types, you can achieve this by an unsafe
wrapper:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

struct NotThreadSafe&lt;T&gt; {
    value: Cell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}

static A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };
static B: &amp;'static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!
<span class="boring">}</span></code></pre></pre>
<p>Remember this solution is unsafe! You will have to ensure that accesses to the
cell are synchronized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0493"><a class="header" href="#error-code-e0493">Error code E0493</a></h1>
<p>A value with a custom <code>Drop</code> implementation may be dropped during const-eval.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0493"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!
<span class="boring">}</span></code></pre></pre>
<p>The problem here is that if the given type or one of its fields implements the
<code>Drop</code> trait, this <code>Drop</code> implementation cannot be called within a const
context since it may run arbitrary, non-const-checked code. To prevent this
issue, ensure all values with a custom <code>Drop</code> implementation escape the
initializer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DropType {
    A,
}

impl Drop for DropType {
    fn drop(&amp;mut self) {}
}

struct Foo {
    field1: DropType,
}

static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields
                                               // by hand.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0495"><a class="header" href="#error-code-e0495">Error code E0495</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-47"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-47">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A lifetime cannot be determined in the given situation.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // error!
        ((u,),) =&gt; u,
    }
}

let y = Box::new((42,));
let x = transmute_lifetime(&amp;y);
<span class="boring">}</span></code></pre></pre>
<p>In this code, you have two ways to solve this issue:</p>
<ol>
<li>Enforce that <code>'a</code> lives at least as long as <code>'b</code>.</li>
<li>Use the same lifetime requirement for both input and output values.</li>
</ol>
<p>So for the first solution, you can do it by replacing <code>'a</code> with <code>'a: 'b</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a: 'b, 'b, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'b T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In the second you can do it by simply removing <code>'b</code> so they both use <code>'a</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transmute_lifetime&lt;'a, T&gt;(t: &amp;'a (T,)) -&gt; &amp;'a T {
    match (&amp;t,) { // ok!
        ((u,),) =&gt; u,
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0496"><a class="header" href="#error-code-e0496">Error code E0496</a></h1>
<p>A lifetime name is shadowing another lifetime name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0496"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'a&gt;(x: &amp;'a i32) { // error: lifetime name `'a` shadows a lifetime
                           //        name that is already in scope
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Please change the name of one of the lifetimes to remove this error. Example:</p>
<pre><pre class="playground"><code class="language-rust">struct Foo&lt;'a&gt; {
    a: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn f&lt;'b&gt;(x: &amp;'b i32) { // ok!
    }
}

fn main() {
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0497"><a class="header" href="#error-code-e0497">Error code E0497</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-48"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-48">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A stability attribute was used outside of the standard library.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable] // error: stability attributes may not be used outside of the
          //        standard library
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>It is not possible to use stability attributes outside of the standard library.
Also, for now, it is not possible to write deprecation messages either.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0498"><a class="header" href="#error-code-e0498">Error code E0498</a></h1>
<p>The <code>plugin</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0498"><span class="boring">#![allow(unused)]
</span>#![feature(plugin)]
#![plugin(foo(args))] // error: invalid argument
#![plugin(bar=&quot;test&quot;)] // error: invalid argument
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>#[plugin]</code> attribute should take a single argument: the name of the plugin.</p>
<p>For example, for the plugin <code>foo</code>:</p>
<pre><code class="language-rust ignore (requires external plugin crate)">#![feature(plugin)]
#![plugin(foo)] // ok!</code></pre>
<p>See the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/plugin.html"><code>plugin</code> feature</a> section of the Unstable book for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0499"><a class="header" href="#error-code-e0499">Error code E0499</a></h1>
<p>A variable was borrowed as mutable more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0499"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
let mut x = &amp;mut i;
let mut a = &amp;mut i;
x;
// error: cannot borrow `i` as mutable more than once at a time
<span class="boring">}</span></code></pre></pre>
<p>Please note that in Rust, you can either have many immutable references, or one
mutable reference. For more details you may want to read the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
let mut x = &amp;mut i; // ok!

// or:
let mut i = 0;
let a = &amp;i; // ok!
let b = &amp;i; // still ok!
let c = &amp;i; // still ok!
b;
a;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0500"><a class="header" href="#error-code-e0500">Error code E0500</a></h1>
<p>A borrowed variable was used by a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0500"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
    println!(&quot;{}&quot;, nights_watch);
}
<span class="boring">}</span></code></pre></pre>
<p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> reference, so it
cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue,
you can create the closure after the borrow has ended:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    println!(&quot;{}&quot;, nights_watch);
    let starks = || {
        *jon_snow = 3;
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Or, if the type implements the <code>Clone</code> trait, you can clone it between
closures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let starks = || {
        *jon_snow = 3;
    };
    println!(&quot;{}&quot;, jon_copy);
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0501"><a class="header" href="#error-code-e0501">Error code E0501</a></h1>
<p>A mutable variable is used but it is already captured by a closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0501"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn outside_closure(x: &amp;mut i32) {
    // Actions which require unique access
}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    outside_closure(a); // error: cannot borrow `*a` as mutable because previous
                        //        closure requires unique access.
    bar();
}
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that a mutable variable is used while it is still captured
by a closure. Because the closure has borrowed the variable, it is not available
until the closure goes out of scope.</p>
<p>Note that a capture will either move or borrow a variable, but in this
situation, the closure is borrowing the variable. Take a look at the chapter
on <a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures/capture.html">Capturing</a> in Rust By Example for more information.</p>
<p>To fix this error, you can finish using the closure before using the captured
variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = || {
        inside_closure(a)
    };
    bar();
    // borrow on `a` ends.
    outside_closure(a); // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>Or you can pass the variable as a parameter to the closure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    let mut bar = |s: &amp;mut i32| {
        inside_closure(s)
    };
    outside_closure(a);
    bar(a);
}
<span class="boring">}</span></code></pre></pre>
<p>It may be possible to define the closure later:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inside_closure(x: &amp;mut i32) {}
fn outside_closure(x: &amp;mut i32) {}

fn foo(a: &amp;mut i32) {
    outside_closure(a);
    let mut bar = || {
        inside_closure(a)
    };
    bar();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0502"><a class="header" href="#error-code-e0502">Error code E0502</a></h1>
<p>A variable already borrowed as immutable was borrowed as mutable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0502"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    let y = &amp;a; // a is borrowed as immutable.
    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed
            //        as immutable
    println!(&quot;{}&quot;, y);
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure that you don't have any other references to the
variable before trying to access it mutably:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bar(x: &amp;mut i32) {}
fn foo(a: &amp;mut i32) {
    bar(a);
    let y = &amp;a; // ok!
    println!(&quot;{}&quot;, y);
}
<span class="boring">}</span></code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0503"><a class="header" href="#error-code-e0503">Error code E0503</a></h1>
<p>A value was used after it was mutably borrowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0503">fn main() {
    let mut value = 3;
    // Create a mutable borrow of `value`.
    let borrow = &amp;mut value;
    let _sum = value + 1; // error: cannot use `value` because
                          //        it was mutably borrowed
    println!(&quot;{}&quot;, borrow);
}</code></pre></pre>
<p>In this example, <code>value</code> is mutably borrowed by <code>borrow</code> and cannot be
used to calculate <code>sum</code>. This is not possible because this would violate
Rust's mutability rules.</p>
<p>You can fix this error by finishing using the borrow before the next use of
the value:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut value = 3;
    let borrow = &amp;mut value;
    println!(&quot;{}&quot;, borrow);
    // The block has ended and with it the borrow.
    // You can now use `value` again.
    let _sum = value + 1;
}</code></pre></pre>
<p>Or by cloning <code>value</code> before borrowing it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut value = 3;
    // We clone `value`, creating a copy.
    let value_cloned = value.clone();
    // The mutable borrow is a reference to `value` and
    // not to `value_cloned`...
    let borrow = &amp;mut value;
    // ... which means we can still use `value_cloned`,
    let _sum = value_cloned + 1;
    // even though the borrow only ends here.
    println!(&quot;{}&quot;, borrow);
}</code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0504"><a class="header" href="#error-code-e0504">Error code E0504</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-49"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-49">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>This error occurs when an attempt is made to move a borrowed variable into a
closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        println!(&quot;child function: {}&quot;, fancy_num.num);
        // error: cannot move `fancy_num` into closure because it is borrowed
    };

    x();
    println!(&quot;main function: {}&quot;, fancy_ref.num);
}</code></pre></pre>
<p>Here, <code>fancy_num</code> is borrowed by <code>fancy_ref</code> and so cannot be moved into
the closure <code>x</code>. There is no way to move a value into a closure while it is
borrowed, as that would invalidate the borrow.</p>
<p>If the closure can't outlive the value being moved, try using a reference
rather than moving:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };
    let fancy_ref = &amp;fancy_num;

    let x = move || {
        // fancy_ref is usable here because it doesn't move `fancy_num`
        println!(&quot;child function: {}&quot;, fancy_ref.num);
    };

    x();

    println!(&quot;main function: {}&quot;, fancy_num.num);
}</code></pre></pre>
<p>If the value has to be borrowed and then moved, try limiting the lifetime of
the borrow using a scoped block:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_num = FancyNum { num: 5 };

    {
        let fancy_ref = &amp;fancy_num;
        println!(&quot;main function: {}&quot;, fancy_ref.num);
        // `fancy_ref` goes out of scope here
    }

    let x = move || {
        // `fancy_num` can be moved now (no more references exist)
        println!(&quot;child function: {}&quot;, fancy_num.num);
    };

    x();
}</code></pre></pre>
<p>If the lifetime of a reference isn't enough, such as in the case of threading,
consider using an <code>Arc</code> to create a reference-counted value:</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::thread;

struct FancyNum {
    num: u8,
}

fn main() {
    let fancy_ref1 = Arc::new(FancyNum { num: 5 });
    let fancy_ref2 = fancy_ref1.clone();

    let x = thread::spawn(move || {
        // `fancy_ref1` can be moved and has a `'static` lifetime
        println!(&quot;child thread: {}&quot;, fancy_ref1.num);
    });

    x.join().expect(&quot;child thread should finish&quot;);
    println!(&quot;main thread: {}&quot;, fancy_ref2.num);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0505"><a class="header" href="#error-code-e0505">Error code E0505</a></h1>
<p>A value was moved out while it was still borrowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0505">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let _ref_to_val: &amp;Value = &amp;x;
    eat(x);
    borrow(_ref_to_val);
}</code></pre></pre>
<p>Here, the function <code>eat</code> takes ownership of <code>x</code>. However,
<code>x</code> cannot be moved because the borrow to <code>_ref_to_val</code>
needs to last till the function <code>borrow</code>.
To fix that you can do a few different things:</p>
<ul>
<li>Try to avoid moving the variable.</li>
<li>Release borrow before move.</li>
<li>Implement the <code>Copy</code> trait on the type.</li>
</ul>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: &amp;Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    eat(&amp;x); // pass by reference, if it's possible
    borrow(ref_to_val);
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};

    let ref_to_val: &amp;Value = &amp;x;
    borrow(ref_to_val);
    // ref_to_val is no longer used.
    eat(x);
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // implement Copy trait
struct Value {}

fn borrow(val: &amp;Value) {}

fn eat(val: Value) {}

fn main() {
    let x = Value{};
    let ref_to_val: &amp;Value = &amp;x;
    eat(x); // it will be copied here.
    borrow(ref_to_val);
}</code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0506"><a class="header" href="#error-code-e0506">Error code E0506</a></h1>
<p>An attempt was made to assign to a borrowed value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0506"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let fancy_ref = &amp;fancy_num;
fancy_num = FancyNum { num: 6 };
// error: cannot assign to `fancy_num` because it is borrowed

println!(&quot;Num: {}, Ref: {}&quot;, fancy_num.num, fancy_ref.num);
<span class="boring">}</span></code></pre></pre>
<p>Because <code>fancy_ref</code> still holds a reference to <code>fancy_num</code>, <code>fancy_num</code> can't
be assigned to a new value as it would invalidate the reference.</p>
<p>Alternatively, we can move out of <code>fancy_num</code> into a second <code>fancy_num</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };
let moved_num = fancy_num;
fancy_num = FancyNum { num: 6 };

println!(&quot;Num: {}, Moved num: {}&quot;, fancy_num.num, moved_num.num);
<span class="boring">}</span></code></pre></pre>
<p>If the value has to be borrowed, try limiting the lifetime of the borrow using
a scoped block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

let mut fancy_num = FancyNum { num: 5 };

{
    let fancy_ref = &amp;fancy_num;
    println!(&quot;Ref: {}&quot;, fancy_ref.num);
}

// Works because `fancy_ref` is no longer in scope
fancy_num = FancyNum { num: 6 };
println!(&quot;Num: {}&quot;, fancy_num.num);
<span class="boring">}</span></code></pre></pre>
<p>Or by moving the reference into a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FancyNum {
    num: u8,
}

fn print_fancy_ref(fancy_ref: &amp;FancyNum){
    println!(&quot;Ref: {}&quot;, fancy_ref.num);
}

let mut fancy_num = FancyNum { num: 5 };

print_fancy_ref(&amp;fancy_num);

// Works because function borrow has ended
fancy_num = FancyNum { num: 6 };
println!(&quot;Num: {}&quot;, fancy_num.num);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0507"><a class="header" href="#error-code-e0507">Error code E0507</a></h1>
<p>A borrowed value was moved out.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0507">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}</code></pre></pre>
<p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However,
<code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>,
which is a borrow of the content owned by the <code>RefCell</code>. To fix this error,
you have three choices:</p>
<ul>
<li>Try to avoid moving the variable.</li>
<li>Somehow reclaim the ownership.</li>
<li>Implement the <code>Copy</code> trait on the type.</li>
</ul>
<p>This can also happen when using a type implementing <code>Fn</code> or <code>FnMut</code>, as neither
allows moving out of them (they usually represent closures which can be called
more than once). Much of the text following applies equally well to non-<code>FnOnce</code>
closure bodies.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</code></pre></pre>
<p>Moving a member out of a mutably borrowed struct will also cause E0507 error:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0507">struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
}</code></pre></pre>
<p>It is fine only if you put something back. <code>mem::replace</code> can be used for that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct TheDarkKnight;
</span><span class="boring">impl TheDarkKnight { fn nothing_is_true(self) {} }
</span><span class="boring">struct Batcave { knight: TheDarkKnight }
</span>use std::mem;

let mut cave = Batcave {
    knight: TheDarkKnight
};
let borrowed = &amp;mut cave;

mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
<span class="boring">}</span></code></pre></pre>
<p>For more information on Rust's ownership system, take a look at the
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">References &amp; Borrowing</a> section of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0508"><a class="header" href="#error-code-e0508">Error code E0508</a></h1>
<p>A value was moved out of a non-copy fixed-size array.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0508">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,
                           //        a non-copy fixed-size array
}</code></pre></pre>
<p>The first element was moved out of the array, but this is not
possible because <code>NonCopy</code> does not implement the <code>Copy</code> trait.</p>
<p>Consider borrowing the element instead of moving it:</p>
<pre><pre class="playground"><code class="language-rust">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    let _value = &amp;array[0]; // Borrowing is allowed, unlike moving.
}</code></pre></pre>
<p>Alternatively, if your type implements <code>Clone</code> and you need to own the value,
consider borrowing and then cloning:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone)]
struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Now you can clone the array element.
    let _value = array[0].clone();
}</code></pre></pre>
<p>If you really want to move the value out, you can use a destructuring array
pattern to move it:</p>
<pre><pre class="playground"><code class="language-rust">struct NonCopy;

fn main() {
    let array = [NonCopy; 1];
    // Destructuring the array
    let [_value] = array;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0509"><a class="header" href="#error-code-e0509">Error code E0509</a></h1>
<p>This error occurs when an attempt is made to move out of a value whose type
implements the <code>Drop</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0509">struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let fancy_field = drop_struct.fancy; // Error E0509
    println!(&quot;Fancy: {}&quot;, fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</code></pre></pre>
<p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which
implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or
more of its fields have been moved.</p>
<p>Structs implementing the <code>Drop</code> trait have an implicit destructor that gets
called when they go out of scope. This destructor may use the fields of the
struct, so moving out of the struct could make it impossible to run the
destructor. Therefore, we must think of all values whose type implements the
<code>Drop</code> trait as single units whose fields cannot be moved.</p>
<p>This error can be fixed by creating a reference to the fields of a struct,
enum, or tuple using the <code>ref</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: usize
}

struct DropStruct {
    fancy: FancyNum
}

impl Drop for DropStruct {
    fn drop(&amp;mut self) {
        // Destruct DropStruct, possibly using FancyNum
    }
}

fn main() {
    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};
    let ref fancy_field = drop_struct.fancy; // No more errors!
    println!(&quot;Fancy: {}&quot;, fancy_field.num);
    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope
}</code></pre></pre>
<p>Note that this technique can also be used in the arms of a match expression:</p>
<pre><pre class="playground"><code class="language-rust">struct FancyNum {
    num: usize
}

enum DropEnum {
    Fancy(FancyNum)
}

impl Drop for DropEnum {
    fn drop(&amp;mut self) {
        // Destruct DropEnum, possibly using FancyNum
    }
}

fn main() {
    // Creates and enum of type `DropEnum`, which implements `Drop`
    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});
    match drop_enum {
        // Creates a reference to the inside of `DropEnum::Fancy`
        DropEnum::Fancy(ref fancy_field) =&gt; // No error!
            println!(&quot;It was fancy-- {}!&quot;, fancy_field.num),
    }
    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0510"><a class="header" href="#error-code-e0510">Error code E0510</a></h1>
<p>The matched value was assigned in a match guard.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0510"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) if { x = None; false } =&gt; {} // error!
    Some(_) =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>When matching on a variable it cannot be mutated in the match guards, as this
could cause the match to be non-exhaustive.</p>
<p>Here executing <code>x = None</code> would modify the value being matched and require us
to go &quot;back in time&quot; to the <code>None</code> arm. To fix it, change the value in the match
arm:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Some(0);
match x {
    None =&gt; {}
    Some(_) =&gt; {
        x = None; // ok!
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0511"><a class="header" href="#error-code-e0511">Error code E0511</a></h1>
<p>Invalid monomorphization of an intrinsic function was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0511">#![feature(platform_intrinsics)]

extern &quot;platform-intrinsic&quot; {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

fn main() {
    unsafe { simd_add(0, 1); }
    // error: invalid monomorphization of `simd_add` intrinsic
}</code></pre></pre>
<p>The generic type has to be a SIMD type. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_simd)]
#![feature(platform_intrinsics)]

<span class="boring">fn main() {
</span>#[repr(simd)]
#[derive(Copy, Clone)]
struct i32x2(i32, i32);

extern &quot;platform-intrinsic&quot; {
    fn simd_add&lt;T&gt;(a: T, b: T) -&gt; T;
}

unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0512"><a class="header" href="#error-code-e0512">Error code E0512</a></h1>
<p>Transmute with two differently sized types was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0512">fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0u16)); }
    // error: cannot transmute between types of different sizes,
    //        or dependently-sized types
}</code></pre></pre>
<p>Please use types with same size or use the expected type directly. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn takes_u8(_: u8) {}

fn main() {
    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!
    // or:
    unsafe { takes_u8(0u8); } // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0514"><a class="header" href="#error-code-e0514">Error code E0514</a></h1>
<p>Dependency compiled with different version of <code>rustc</code>.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">// compiled with stable `rustc`

#[crate_type = &quot;lib&quot;]</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">// compiled with nightly `rustc`

#[crate_type = &quot;lib&quot;]

extern crate a; // error: found crate `a` compiled by an incompatible version
                //        of rustc</code></pre>
<p>This error is caused when the version of <code>rustc</code> used to compile a crate, as
stored in the binary's metadata, differs from the version of one of its
dependencies. Many parts of Rust binaries are considered unstable. For
instance, the Rust ABI is not stable between compiler versions. This means that
the compiler cannot be sure about <em>how</em> to call a function between compiler
versions, and therefore this error occurs.</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager and
<a href="https://rust-lang.github.io/rustup/">Rustup</a>, the Rust toolchain installer,
automatically fixing this issue.</li>
<li>Recompiling the crates with a uniform <code>rustc</code> version.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0515"><a class="header" href="#error-code-e0515">Error code E0515</a></h1>
<p>A reference to a local variable was returned.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0515"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_dangling_reference() -&gt; &amp;'static i32 {
    let x = 0;
    &amp;x
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0515"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice::Iter;
fn get_dangling_iterator&lt;'a&gt;() -&gt; Iter&lt;'a, i32&gt; {
    let v = vec![1, 2, 3];
    v.iter()
}
<span class="boring">}</span></code></pre></pre>
<p>Local variables, function parameters and temporaries are all dropped before the
end of the function body. So a reference to them cannot be returned.</p>
<p>Consider returning an owned value instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::vec::IntoIter;

fn get_integer() -&gt; i32 {
    let x = 0;
    x
}

fn get_owned_iterator() -&gt; IntoIter&lt;i32&gt; {
    let v = vec![1, 2, 3];
    v.into_iter()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0516"><a class="header" href="#error-code-e0516">Error code E0516</a></h1>
<p>The <code>typeof</code> keyword is currently reserved but unimplemented.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0516">fn main() {
    let x: typeof(92) = 92;
}</code></pre></pre>
<p>Try using type inference instead. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 92;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0517"><a class="header" href="#error-code-e0517">Error code E0517</a></h1>
<p>A <code>#[repr(..)]</code> attribute was placed on an unsupported item.</p>
<p>Examples of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0517"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
type Foo = u8;

#[repr(packed)]
enum Foo {Bar, Baz}

#[repr(u8)]
struct Foo {bar: bool, baz: bool}

#[repr(C)]
impl Foo {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>#[repr(C)]</code> attribute can only be placed on structs and enums.</li>
<li>The <code>#[repr(packed)]</code> and <code>#[repr(simd)]</code> attributes only work on structs.</li>
<li>The <code>#[repr(u8)]</code>, <code>#[repr(i16)]</code>, etc attributes only work on enums.</li>
</ul>
<p>These attributes do not work on typedefs, since typedefs are just aliases.</p>
<p>Representations like <code>#[repr(u8)]</code>, <code>#[repr(i64)]</code> are for selecting the
discriminant size for enums with no data fields on any of the variants, e.g.
<code>enum Color {Red, Blue, Green}</code>, effectively setting the size of the enum to
the size of the provided type. Such an enum can be cast to a value of the same
type as well. In short, <code>#[repr(u8)]</code> makes the enum behave like an integer
with a constrained set of allowed values.</p>
<p>Only field-less enums can be cast to numerical primitives, so this attribute
will not apply to structs.</p>
<p><code>#[repr(packed)]</code> reduces padding to make the struct size smaller. The
representation of enums isn't strictly defined in Rust, and this attribute
won't work on enums.</p>
<p><code>#[repr(simd)]</code> will give a struct consisting of a homogeneous series of machine
types (i.e., <code>u8</code>, <code>i32</code>, etc) a representation that permits vectorization via
SIMD. This doesn't make much sense for enums since they don't consist of a
single list of data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0518"><a class="header" href="#error-code-e0518">Error code E0518</a></h1>
<p>An <code>#[inline(..)]</code> attribute was incorrectly placed on something other than a
function or method.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0518"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
struct Foo;

#[inline(never)]
impl Foo {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><code>#[inline]</code> hints the compiler whether or not to attempt to inline a method or
function. By default, the compiler does a pretty good job of figuring this out
itself, but if you feel the need for annotations, <code>#[inline(always)]</code> and
<code>#[inline(never)]</code> can override or force the compiler's decision.</p>
<p>If you wish to apply this attribute to all methods in an impl, manually annotate
each method; it is not possible to annotate the entire impl with an <code>#[inline]</code>
attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0519"><a class="header" href="#error-code-e0519">Error code E0519</a></h1>
<p>The current crate is indistinguishable from one of its dependencies, in terms
of metadata.</p>
<p>Example of erroneous code:</p>
<p><code>a.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_name = &quot;a&quot;]
#![crate_type = &quot;lib&quot;]

pub fn foo() {}</code></pre>
<p><code>b.rs</code></p>
<pre><code class="language-rust ignore (cannot-link-with-other-tests)">#![crate_name = &quot;a&quot;]
#![crate_type = &quot;lib&quot;]

// error: the current crate is indistinguishable from one of its dependencies:
//        it has the same crate-name `a` and was compiled with the same
//        `-C metadata` arguments. This will result in symbol conflicts between
//        the two.
extern crate a;

pub fn foo() {}

fn bar() {
    a::foo(); // is this calling the local crate or the dependency?
}</code></pre>
<p>The above example compiles two crates with exactly the same name and
<code>crate_type</code> (plus any other metadata). This causes an error because it becomes
impossible for the compiler to distinguish between symbols (<code>pub</code> item names).</p>
<p>This error can be fixed by:</p>
<ul>
<li>Using <a href="../cargo/index.html">Cargo</a>, the Rust package manager, automatically
fixing this issue.</li>
<li>Recompiling the crate with different metadata (different name/
<code>crate_type</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0520"><a class="header" href="#error-code-e0520">Error code E0520</a></h1>
<p>A non-default implementation was already made on this type so it cannot be
specialized further.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0520"><span class="boring">#![allow(unused)]
</span>#![feature(specialization)]

<span class="boring">fn main() {
</span>trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {}
}

// non-default impl
// applies to all `Clone` T and overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    fn fly(&amp;self) {}
}

// since `i32` is clone, this conflicts with the previous implementation
impl SpaceLlama for i32 {
    default fn fly(&amp;self) {}
    // error: item `fly` is provided by an `impl` that specializes
    //        another, but the item in the parent `impl` is not marked
    //        `default` and so it cannot be specialized.
}
<span class="boring">}</span></code></pre></pre>
<p>Specialization only allows you to override <code>default</code> functions in
implementations.</p>
<p>To fix this error, you need to mark all the parent implementations as default.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(specialization)]

<span class="boring">fn main() {
</span>trait SpaceLlama {
    fn fly(&amp;self);
}

// applies to all T
impl&lt;T&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation.
}

// applies to all `Clone` T; overrides the previous impl
impl&lt;T: Clone&gt; SpaceLlama for T {
    default fn fly(&amp;self) {} // This is a parent implementation but was
                             // previously not a default one, causing the error
}

// applies to i32, overrides the previous two impls
impl SpaceLlama for i32 {
    fn fly(&amp;self) {} // And now that's ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0521"><a class="header" href="#error-code-e0521">Error code E0521</a></h1>
<p>Borrowed data escapes outside of closure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0521"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut list: Vec&lt;&amp;str&gt; = Vec::new();

let _add = |el: &amp;str| {
    list.push(el); // error: `el` escapes the closure body here
};
<span class="boring">}</span></code></pre></pre>
<p>A type annotation of a closure parameter implies a new lifetime declaration.
Consider to drop it, the compiler is reliably able to infer them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut list: Vec&lt;&amp;str&gt; = Vec::new();

let _add = |el| {
    list.push(el);
};
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closure-type-inference-and-annotation">Closure type inference and annotation</a> and
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision</a> sections of the Book for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0522"><a class="header" href="#error-code-e0522">Error code E0522</a></h1>
<p>The lang attribute was used in an invalid context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0522"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>#[lang = &quot;cookie&quot;]
fn cookie() -&gt; ! { // error: definition of an unknown language item: `cookie`
    loop {}
}
<span class="boring">}</span></code></pre></pre>
<p>The lang attribute is intended for marking special items that are built-in to
Rust itself. This includes special traits (like <code>Copy</code> and <code>Sized</code>) that affect
how the compiler behaves, as well as special functions that may be automatically
invoked (such as the handler for out-of-bounds accesses when indexing a slice).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0523"><a class="header" href="#error-code-e0523">Error code E0523</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-50"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-50">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The compiler found multiple library files with the requested crate name.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// aux-build:crateresolve-1.rs
// aux-build:crateresolve-2.rs
// aux-build:crateresolve-3.rs

extern crate crateresolve;
//~^ ERROR multiple candidates for `rlib` dependency `crateresolve` found

fn main() {}</code></pre></pre>
<p>This error can occur in several different cases -- for example, when using
<code>extern crate</code> or passing <code>--extern</code> options without crate paths. It can also be
caused by caching issues with the build directory, in which case <code>cargo clean</code>
may help.</p>
<p>In the above example, there are three different library files, all of which
define the same crate name. Without providing a full path, there is no way for
the compiler to know which crate it should use.</p>
<p><em>Note that E0523 has been merged into E0464.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0524"><a class="header" href="#error-code-e0524">Error code E0524</a></h1>
<p>A variable which requires unique access is being used in more than one closure
at the same time.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0524"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let mut c1 = || set(x);
    let mut c2 = || set(x); // error!

    c2();
    c1();
}
<span class="boring">}</span></code></pre></pre>
<p>To solve this issue, multiple solutions are available. First, is it required
for this variable to be used in more than one closure at a time? If it is the
case, use reference counted types such as <code>Rc</code> (or <code>Arc</code> if it runs
concurrently):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let x = Rc::new(RefCell::new(x));
    let y = Rc::clone(&amp;x);
    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&amp;mut x2); };
    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&amp;mut x2); }; // ok!

    c2();
    c1();
}
<span class="boring">}</span></code></pre></pre>
<p>If not, just run closures one at a time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    { // This block isn't necessary since non-lexical lifetimes, it's just to
      // make it more clear.
        let mut c1 = || set(&amp;mut *x);
        c1();
    } // `c1` has been dropped here so we're free to use `x` again!
    let mut c2 = || set(&amp;mut *x);
    c2();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0525"><a class="header" href="#error-code-e0525">Error code E0525</a></h1>
<p>A closure was used but didn't implement the expected trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0525">struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x); // error: expected a closure that implements
                              //        the `Fn` trait, but this closure only
                              //        implements `FnOnce`
    bar(closure);
}</code></pre></pre>
<p>In the example above, <code>closure</code> is an <code>FnOnce</code> closure whereas the <code>bar</code>
function expected an <code>Fn</code> closure. In this case, it's simple to fix the issue,
you just have to implement <code>Copy</code> and <code>Clone</code> traits on <code>struct X</code> and it'll
be ok:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.
struct X;

fn foo&lt;T&gt;(_: T) {}
fn bar&lt;T: Fn(u32)&gt;(_: T) {}

fn main() {
    let x = X;
    let closure = |_| foo(x);
    bar(closure); // ok!
}</code></pre></pre>
<p>To better understand how these work in Rust, read the <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a>
chapter of the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0527"><a class="header" href="#error-code-e0527">Error code E0527</a></h1>
<p>The number of elements in an array or slice pattern differed from the number of
elements in the array being matched.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0527"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b] =&gt; { // error: pattern requires 2 elements but array
                 //        has 4
        println!(&quot;a={}, b={}&quot;, a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the pattern is consistent with the size of the matched
array. Additional elements can be matched with <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4];
match r {
    &amp;[a, b, ..] =&gt; { // ok!
        println!(&quot;a={}, b={}&quot;, a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0528"><a class="header" href="#error-code-e0528">Error code E0528</a></h1>
<p>An array or slice pattern required more elements than were present in the
matched array.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0528"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // error: pattern requires at least 3
                               //        elements but array has 2
        println!(&quot;a={}, b={}, c={} rest={:?}&quot;, a, b, c, rest);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the matched array has at least as many elements as the pattern
requires. You can match an arbitrary number of remaining elements with <code>..</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = &amp;[1, 2, 3, 4, 5];
match r {
    &amp;[a, b, c, rest @ ..] =&gt; { // ok!
        // prints `a=1, b=2, c=3 rest=[4, 5]`
        println!(&quot;a={}, b={}, c={} rest={:?}&quot;, a, b, c, rest);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0529"><a class="header" href="#error-code-e0529">Error code E0529</a></h1>
<p>An array or slice pattern was matched against some other type.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0529"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r: f32 = 1.0;
match r {
    [a, b] =&gt; { // error: expected an array or slice, found `f32`
        println!(&quot;a={}, b={}&quot;, a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the pattern and the expression being matched on are of consistent
types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = [1.0, 2.0];
match r {
    [a, b] =&gt; { // ok!
        println!(&quot;a={}, b={}&quot;, a, b);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0530"><a class="header" href="#error-code-e0530">Error code E0530</a></h1>
<p>A binding shadowed something it shouldn't.</p>
<p>A match arm or a variable has a name that is already used by
something else, e.g.</p>
<ul>
<li>struct name</li>
<li>enum variant</li>
<li>static</li>
<li>associated constant</li>
</ul>
<p>This error may also happen when an enum variant <em>with fields</em> is used
in a pattern, but without its fields.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum {
    WithField(i32)
}

use Enum::*;
match WithField(1) {
    WithField =&gt; {} // error: missing (_)
}
<span class="boring">}</span></code></pre></pre>
<p>Match bindings cannot shadow statics:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0530"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TEST: i32 = 0;

let r = 123;
match r {
    TEST =&gt; {} // error: name of a static
}
<span class="boring">}</span></code></pre></pre>
<p>Fixed examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static TEST: i32 = 0;

let r = 123;
match r {
    some_value =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TEST: i32 = 0; // const, not static

let r = 123;
match r {
    TEST =&gt; {} // const is ok!
    other_values =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0531"><a class="header" href="#error-code-e0531">Error code E0531</a></h1>
<p>An unknown tuple struct/variant has been used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0531"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let Type(x) = Type(12); // error!
match Bar(12) {
    Bar(x) =&gt; {} // error!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In most cases, it's either a forgotten import or a typo. However, let's look at
how you can have such a type:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type(u32); // this is a tuple struct

enum Foo {
    Bar(u32), // this is a tuple variant
}

use Foo::*; // To use Foo's variant directly, we need to import them in
            // the scope.
<span class="boring">}</span></code></pre></pre>
<p>Either way, it should work fine with our previous code:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type(u32);

enum Foo {
    Bar(u32),
}
use Foo::*;

let Type(x) = Type(12); // ok!
match Type(12) {
    Type(x) =&gt; {} // ok!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0532"><a class="header" href="#error-code-e0532">Error code E0532</a></h1>
<p>Pattern arm did not match expected kind.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0532"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        // error: expected unit struct, unit variant or constant, found tuple
        //        variant `State::Failed`
        State::Failed =&gt; println!(&quot;Failed&quot;),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, ensure the match arm kind is the same as the expression
matched.</p>
<p>Fixed example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum State {
    Succeeded,
    Failed(String),
}

fn print_on_failure(state: &amp;State) {
    match *state {
        State::Failed(ref msg) =&gt; println!(&quot;Failed with {}&quot;, msg),
        _ =&gt; ()
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0533"><a class="header" href="#error-code-e0533">Error code E0533</a></h1>
<p>An item which isn't a unit struct, a variant, nor a constant has been used as a
match pattern.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0533"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    Tortoise::turtle =&gt; {} // Error!
    _ =&gt; {}
}
if let Tortoise::turtle = 0u32 {} // Same error!
<span class="boring">}</span></code></pre></pre>
<p>If you want to match against a value returned by a method, you need to bind the
value first:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tortoise;

impl Tortoise {
    fn turtle(&amp;self) -&gt; u32 { 0 }
}

match 0u32 {
    x if x == Tortoise.turtle() =&gt; {} // Bound into `x` then we compare it!
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0534"><a class="header" href="#error-code-e0534">Error code E0534</a></h1>
<p>The <code>inline</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0534">#[inline()] // error: expected one argument
pub fn something() {}

fn main() {}</code></pre></pre>
<p>The parenthesized <code>inline</code> attribute requires the parameter to be specified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, a paren-less version of the attribute may be used to hint the
compiler about inlining opportunity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>inline</code> attribute</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0535"><a class="header" href="#error-code-e0535">Error code E0535</a></h1>
<p>An unknown argument was given to the <code>inline</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0535">#[inline(unknown)] // error: invalid argument
pub fn something() {}

fn main() {}</code></pre></pre>
<p>The <code>inline</code> attribute only supports two arguments:</p>
<ul>
<li>always</li>
<li>never</li>
</ul>
<p>All other arguments given to the <code>inline</code> attribute will return this error.
Example:</p>
<pre><pre class="playground"><code class="language-rust">#[inline(never)] // ok!
pub fn something() {}

fn main() {}</code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>inline</code> Attribute</a> section
of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0536"><a class="header" href="#error-code-e0536">Error code E0536</a></h1>
<p>The <code>not</code> cfg-predicate was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0536">#[cfg(not())] // error: expected 1 cfg-pattern
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>The <code>not</code> predicate expects one cfg-pattern. Example:</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(not(target_os = &quot;linux&quot;))] // ok!
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>For more information about the <code>cfg</code> attribute, read the section on
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Conditional Compilation</a> in the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0537"><a class="header" href="#error-code-e0537">Error code E0537</a></h1>
<p>An unknown predicate was used inside the <code>cfg</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0537">#[cfg(unknown())] // error: invalid predicate `unknown`
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>The <code>cfg</code> attribute supports only three kinds of predicates:</p>
<ul>
<li>any</li>
<li>all</li>
<li>not</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(not(target_os = &quot;linux&quot;))] // ok!
pub fn something() {}

pub fn main() {}</code></pre></pre>
<p>For more information about the <code>cfg</code> attribute, read the section on
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">Conditional Compilation</a> in the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0538"><a class="header" href="#error-code-e0538">Error code E0538</a></h1>
<p>Attribute contains same meta item more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0538"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since=&quot;1.0.0&quot;,
    note=&quot;First deprecation note.&quot;,
    note=&quot;Second deprecation note.&quot; // error: multiple same meta item
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. Each key may only be
used once in each attribute.</p>
<p>To fix the problem, remove all but one of the meta items with the same key.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since=&quot;1.0.0&quot;,
    note=&quot;First deprecation note.&quot;
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0539"><a class="header" href="#error-code-e0539">Error code E0539</a></h1>
<p>An invalid meta-item was used inside an attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0539"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[deprecated(note)] // error!
#[unstable(feature = &quot;deprecated_fn&quot;, issue = &quot;123&quot;)]
fn deprecated() {}

#[unstable(feature = &quot;unstable_struct&quot;, issue)] // error!
struct Unstable;

#[rustc_const_unstable(feature)] // error!
const fn unstable_fn() {}

#[stable(feature = &quot;stable_struct&quot;, since)] // error!
struct Stable;

#[rustc_const_stable(feature)] // error!
const fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute.
To fix these issues you need to give required key-value pairs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[deprecated(since = &quot;1.39.0&quot;, note = &quot;reason&quot;)] // ok!
#[unstable(feature = &quot;deprecated_fn&quot;, issue = &quot;123&quot;)]
fn deprecated() {}

#[unstable(feature = &quot;unstable_struct&quot;, issue = &quot;123&quot;)] // ok!
struct Unstable;

#[rustc_const_unstable(feature = &quot;unstable_fn&quot;, issue = &quot;124&quot;)] // ok!
const fn unstable_fn() {}

#[stable(feature = &quot;stable_struct&quot;, since = &quot;1.39.0&quot;)] // ok!
struct Stable;

#[rustc_const_stable(feature = &quot;stable_fn&quot;, since = &quot;1.39.0&quot;)] // ok!
const fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0541"><a class="header" href="#error-code-e0541">Error code E0541</a></h1>
<p>An unknown meta item was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0541"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since=&quot;1.0.0&quot;,
    // error: unknown meta item
    reason=&quot;Example invalid meta item. Should be 'note'&quot;)
]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. The keys provided
must be one of the valid keys for the specified attribute.</p>
<p>To fix the problem, either remove the unknown meta item, or rename it if you
provided the wrong name.</p>
<p>In the erroneous code example above, the wrong name was provided, so changing
to a correct one it will fix the error. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since=&quot;1.0.0&quot;,
    note=&quot;This is a valid meta item for the deprecated attribute.&quot;
)]
fn deprecated_function() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0542"><a class="header" href="#error-code-e0542">Error code E0542</a></h1>
<p>The <code>since</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0542"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[stable(feature = &quot;_stable_fn&quot;)] // invalid
fn _stable_fn() {}

#[rustc_const_stable(feature = &quot;_stable_const_fn&quot;)] // invalid
const fn _stable_const_fn() {}

#[stable(feature = &quot;_deprecated_fn&quot;, since = &quot;0.1.0&quot;)]
#[deprecated(
    note = &quot;explanation for deprecation&quot;
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>since</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[stable(feature = &quot;_stable_fn&quot;, since = &quot;1.0.0&quot;)] // ok!
fn _stable_fn() {}

#[rustc_const_stable(feature = &quot;_stable_const_fn&quot;, since = &quot;1.0.0&quot;)] // ok!
const fn _stable_const_fn() {}

#[stable(feature = &quot;_deprecated_fn&quot;, since = &quot;0.1.0&quot;)]
#[deprecated(
    since = &quot;1.0.0&quot;,
    note = &quot;explanation for deprecation&quot;
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0543"><a class="header" href="#error-code-e0543">Error code E0543</a></h1>
<p>The <code>note</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0543"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[stable(since = &quot;0.1.0&quot;, feature = &quot;_deprecated_fn&quot;)]
#[deprecated(
    since = &quot;1.0.0&quot;
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>note</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[stable(since = &quot;0.1.0&quot;, feature = &quot;_deprecated_fn&quot;)]
#[deprecated(
    since = &quot;1.0.0&quot;,
    note = &quot;explanation for deprecation&quot;
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0544"><a class="header" href="#error-code-e0544">Error code E0544</a></h1>
<p>Multiple stability attributes were declared on the same item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0544"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;rust1&quot;)]

<span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
#[stable(feature = &quot;test&quot;, since = &quot;2.0.0&quot;)] // invalid
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, ensure that each item has at most one stability attribute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;rust1&quot;)]

<span class="boring">fn main() {
</span>#[stable(feature = &quot;test&quot;, since = &quot;2.0.0&quot;)] // ok!
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0545"><a class="header" href="#error-code-e0545">Error code E0545</a></h1>
<p>The <code>issue</code> value is incorrect in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0545"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(feature = &quot;_unstable_fn&quot;, issue = &quot;0&quot;)] // invalid
fn _unstable_fn() {}

#[rustc_const_unstable(feature = &quot;_unstable_const_fn&quot;, issue = &quot;0&quot;)] // invalid
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide a correct value in the <code>issue</code> field.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(feature = &quot;_unstable_fn&quot;, issue = &quot;none&quot;)] // ok!
fn _unstable_fn() {}

#[rustc_const_unstable(feature = &quot;_unstable_const_fn&quot;, issue = &quot;1&quot;)] // ok!
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0546"><a class="header" href="#error-code-e0546">Error code E0546</a></h1>
<p>The <code>feature</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0546"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(issue = &quot;none&quot;)] // invalid
fn unstable_fn() {}

#[stable(since = &quot;1.0.0&quot;)] // invalid
fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>feature</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(feature = &quot;unstable_fn&quot;, issue = &quot;none&quot;)] // ok!
fn unstable_fn() {}

#[stable(feature = &quot;stable_fn&quot;, since = &quot;1.0.0&quot;)] // ok!
fn stable_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0547"><a class="header" href="#error-code-e0547">Error code E0547</a></h1>
<p>The <code>issue</code> value is missing in a stability attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0547"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(feature = &quot;_unstable_fn&quot;)] // invalid
fn _unstable_fn() {}

#[rustc_const_unstable(feature = &quot;_unstable_const_fn&quot;)] // invalid
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to provide the <code>issue</code> field. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[unstable(feature = &quot;_unstable_fn&quot;, issue = &quot;none&quot;)] // ok!
fn _unstable_fn() {}

#[rustc_const_unstable(
    feature = &quot;_unstable_const_fn&quot;,
    issue = &quot;none&quot;
)] // ok!
const fn _unstable_const_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0549"><a class="header" href="#error-code-e0549">Error code E0549</a></h1>
<p>A <code>deprecated</code> attribute wasn't paired with a <code>stable</code>/<code>unstable</code> attribute with
<code>#![feature(staged_api)]</code> enabled.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0549"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[deprecated(
    since = &quot;1.0.1&quot;,
    note = &quot;explanation for deprecation&quot;
)] // invalid
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, you need to add also an attribute <code>stable</code> or <code>unstable</code>.
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]
#![stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]

<span class="boring">fn main() {
</span>#[stable(since = &quot;1.0.0&quot;, feature = &quot;test&quot;)]
#[deprecated(
    since = &quot;1.0.1&quot;,
    note = &quot;explanation for deprecation&quot;
)] // ok!
fn _deprecated_fn() {}
<span class="boring">}</span></code></pre></pre>
<p>See the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">How Rust is Made and “Nightly Rust”</a> appendix
of the Book and the <a href="https://rustc-dev-guide.rust-lang.org/stability.html">Stability attributes</a> section of the
Rustc Dev Guide for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0550"><a class="header" href="#error-code-e0550">Error code E0550</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-51"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-51">Note: this error code is no longer emitted by the compiler</a></h4>
<p>More than one <code>deprecated</code> attribute has been put on an item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = &quot;because why not?&quot;)]
#[deprecated(note = &quot;right?&quot;)] // error!
fn the_banished() {}
<span class="boring">}</span></code></pre></pre>
<p>The <code>deprecated</code> attribute can only be present <strong>once</strong> on an item.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = &quot;because why not, right?&quot;)]
fn the_banished() {} // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0551"><a class="header" href="#error-code-e0551">Error code E0551</a></h1>
<p>An invalid meta-item was used inside an attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0551"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note)] // error!
fn i_am_deprecated() {}
<span class="boring">}</span></code></pre></pre>
<p>Meta items are the key-value pairs inside of an attribute. To fix this issue,
you need to give a value to the <code>note</code> key. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated(note = &quot;because&quot;)] // ok!
fn i_am_deprecated() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0552"><a class="header" href="#error-code-e0552">Error code E0552</a></h1>
<p>A unrecognized representation attribute was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0552"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(D)] // error: unrecognized representation hint
struct MyStruct {
    my_field: usize
}
<span class="boring">}</span></code></pre></pre>
<p>You can use a <code>repr</code> attribute to tell the compiler how you want a struct or
enum to be laid out in memory.</p>
<p>Make sure you're using one of the supported options:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)] // ok!
struct MyStruct {
    my_field: usize
}
<span class="boring">}</span></code></pre></pre>
<p>For more information about specifying representations, see the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html">&quot;Alternative
Representations&quot; section</a> of the Rustonomicon.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0554"><a class="header" href="#error-code-e0554">Error code E0554</a></h1>
<p>Feature attributes are only allowed on the nightly release channel. Stable or
beta compilers will not comply.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (depends on release channel)">#![feature(lang_items)] // error: `#![feature]` may not be used on the
                        //        stable release channel</code></pre>
<p>If you need the feature, make sure to use a nightly release of the compiler
(but be warned that the feature may be removed or altered in the future).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0556"><a class="header" href="#error-code-e0556">Error code E0556</a></h1>
<p>The <code>feature</code> attribute was badly formed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0556"><span class="boring">#![allow(unused)]
</span>#![feature(foo_bar_baz, foo(bar), foo = &quot;baz&quot;, foo)] // error!
#![feature] // error!
#![feature = &quot;foo&quot;] // error!
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>feature</code> attribute only accept a &quot;feature flag&quot; and can only be used on
nightly. Example:</p>
<pre><code class="language-rust ignore (only works in nightly)">#![feature(flag)]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0557"><a class="header" href="#error-code-e0557">Error code E0557</a></h1>
<p>A feature attribute named a feature that has been removed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0557"><span class="boring">#![allow(unused)]
</span>#![feature(managed_boxes)] // error: feature has been removed
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>Delete the offending feature attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0559"><a class="header" href="#error-code-e0559">Error code E0559</a></h1>
<p>An unknown field was specified into an enum's structure variant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0559"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Fool { x: u32 },
}

let s = Field::Fool { joke: 0 };
// error: struct variant `Field::Fool` has no field named `joke`
<span class="boring">}</span></code></pre></pre>
<p>Verify you didn't misspell the field's name or that the field exists. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Fool { joke: u32 },
}

let s = Field::Fool { joke: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0560"><a class="header" href="#error-code-e0560">Error code E0560</a></h1>
<p>An unknown field was specified into a structure.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0560"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Simba {
    mother: u32,
}

let s = Simba { mother: 1, father: 0 };
// error: structure `Simba` has no field named `father`
<span class="boring">}</span></code></pre></pre>
<p>Verify you didn't misspell the field's name or that the field exists. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Simba {
    mother: u32,
    father: u32,
}

let s = Simba { mother: 1, father: 0 }; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0561"><a class="header" href="#error-code-e0561">Error code E0561</a></h1>
<p>A non-ident or non-wildcard pattern has been used as a parameter of a function
pointer type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0561"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A1 = fn(mut param: u8); // error!
type A2 = fn(&amp;param: u32); // error!
<span class="boring">}</span></code></pre></pre>
<p>When using an alias over a function type, you cannot e.g. denote a parameter as
being mutable.</p>
<p>To fix the issue, remove patterns (<code>_</code> is allowed though). Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A1 = fn(param: u8); // ok!
type A2 = fn(_: u32); // ok!
<span class="boring">}</span></code></pre></pre>
<p>You can also omit the parameter name:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type A3 = fn(i16); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0562"><a class="header" href="#error-code-e0562">Error code E0562</a></h1>
<p>Abstract return types (written <code>impl Trait</code> for some trait <code>Trait</code>) are only
allowed as function and inherent impl return types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0562">fn main() {
    let count_to_ten: impl Iterator&lt;Item=usize&gt; = 0..10;
    // error: `impl Trait` not allowed outside of function and inherent method
    //        return types
    for i in count_to_ten {
        println!(&quot;{}&quot;, i);
    }
}</code></pre></pre>
<p>Make sure <code>impl Trait</code> only appears in return-type position.</p>
<pre><pre class="playground"><code class="language-rust">fn count_to_n(n: usize) -&gt; impl Iterator&lt;Item=usize&gt; {
    0..n
}

fn main() {
    for i in count_to_n(10) {  // ok!
        println!(&quot;{}&quot;, i);
    }
}</code></pre></pre>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md">RFC 1522</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0565"><a class="header" href="#error-code-e0565">Error code E0565</a></h1>
<p>A literal was used in a built-in attribute that doesn't support literals.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0565">#[repr(&quot;C&quot;)] // error: meta item in `repr` must be an identifier
struct Repr {}

fn main() {}</code></pre></pre>
<p>Literals in attributes are new and largely unsupported in built-in attributes.
Work to support literals where appropriate is ongoing. Try using an unquoted
name instead:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)] // ok!
struct Repr {}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0566"><a class="header" href="#error-code-e0566">Error code E0566</a></h1>
<p>Conflicting representation hints have been used on a same item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0566"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32, u64)]
enum Repr { A }
<span class="boring">}</span></code></pre></pre>
<p>In most cases (if not all), using just one representation hint is more than
enough. If you want to have a representation hint depending on the current
architecture, use <code>cfg_attr</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(linux, repr(u32))]
#[cfg_attr(not(linux), repr(u64))]
enum Repr { A }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0567"><a class="header" href="#error-code-e0567">Error code E0567</a></h1>
<p>Generics have been used on an auto trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0567">#![feature(auto_traits)]

auto trait Generic&lt;T&gt; {} // error!
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Since an auto trait is implemented on all existing types, the
compiler would not be able to infer the types of the trait's generic
parameters.</p>
<p>To fix this issue, just remove the generics:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(auto_traits)]

auto trait Generic {} // ok!
<span class="boring">fn main() {}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0568"><a class="header" href="#error-code-e0568">Error code E0568</a></h1>
<p>A super trait has been added to an auto trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0568">#![feature(auto_traits)]

auto trait Bound : Copy {} // error!

fn main() {}</code></pre></pre>
<p>Since an auto trait is implemented on all existing types, adding a super trait
would filter out a lot of those types. In the current example, almost none of
all the existing types could implement <code>Bound</code> because very few of them have the
<code>Copy</code> trait.</p>
<p>To fix this issue, just remove the super trait:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(auto_traits)]

auto trait Bound {} // ok!

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0569"><a class="header" href="#error-code-e0569">Error code E0569</a></h1>
<p>If an impl has a generic parameter with the <code>#[may_dangle]</code> attribute, then
that impl must be declared as an <code>unsafe impl</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0569"><span class="boring">#![allow(unused)]
</span>#![feature(dropck_eyepatch)]

<span class="boring">fn main() {
</span>struct Foo&lt;X&gt;(X);
impl&lt;#[may_dangle] X&gt; Drop for Foo&lt;X&gt; {
    fn drop(&amp;mut self) { }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we are asserting that the destructor for <code>Foo</code> will not
access any data of type <code>X</code>, and require this assertion to be true for
overall safety in our program. The compiler does not currently attempt to
verify this assertion; therefore we must tag this <code>impl</code> as unsafe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0570"><a class="header" href="#error-code-e0570">Error code E0570</a></h1>
<p>The requested ABI is unsupported by the current target.</p>
<p>The rust compiler maintains for each target a list of unsupported ABIs on
that target. If an ABI is present in such a list this usually means that the
target / ABI combination is currently unsupported by llvm.</p>
<p>If necessary, you can circumvent this check using custom target specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0571"><a class="header" href="#error-code-e0571">Error code E0571</a></h1>
<p>A <code>break</code> statement with an argument appeared in a non-<code>loop</code> loop.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0571"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut i = 1;
</span><span class="boring">fn satisfied(n: usize) -&gt; bool { n % 23 == 0 }
</span>let result = while true {
    if satisfied(i) {
        break 2 * i; // error: `break` with value from a `while` loop
    }
    i += 1;
};
<span class="boring">}</span></code></pre></pre>
<p>The <code>break</code> statement can take an argument (which will be the value of the loop
expression if the <code>break</code> statement is executed) in <code>loop</code> loops, but not
<code>for</code>, <code>while</code>, or <code>while let</code> loops.</p>
<p>Make sure <code>break value;</code> statements only occur in <code>loop</code> loops:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut i = 1;
</span><span class="boring">fn satisfied(n: usize) -&gt; bool { n % 23 == 0 }
</span>let result = loop { // This is now a &quot;loop&quot; loop.
    if satisfied(i) {
        break 2 * i; // ok!
    }
    i += 1;
};
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0572"><a class="header" href="#error-code-e0572">Error code E0572</a></h1>
<p>A return statement was found outside of a function body.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0572">const FOO: u32 = return 0; // error: return statement outside of function body

fn main() {}</code></pre></pre>
<p>To fix this issue, just remove the return keyword or move the expression into a
function. Example:</p>
<pre><pre class="playground"><code class="language-rust">const FOO: u32 = 0;

fn some_fn() -&gt; u32 {
    return FOO;
}

fn main() {
    some_fn();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0573"><a class="header" href="#error-code-e0573">Error code E0573</a></h1>
<p>Something other than a type has been used when one was expected.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0573"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon::Born { // error!
    Dragon::Born
}

const HOBBIT: u32 = 2;
impl HOBBIT {} // error!

enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(_: Wizard::Saruman); // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In all these errors, a type was expected. For example, in the first error, if
we want to return the <code>Born</code> variant from the <code>Dragon</code> enum, we must set the
function to return the enum and not its variant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon { // ok!
    Dragon::Born
}
<span class="boring">}</span></code></pre></pre>
<p>In the second error, you can't implement something on an item, only on types.
We would need to create a new type if we wanted to do something similar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Hobbit(u32); // we create a new type

const HOBBIT: Hobbit = Hobbit(2);
impl Hobbit {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>In the third case, we tried to only expect one variant of the <code>Wizard</code> enum,
which is not possible. To make this work, we need to using pattern matching
over the <code>Wizard</code> enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(w: Wizard) { // ok!
        match w {
            Wizard::Saruman =&gt; {
                // do something
            }
            _ =&gt; {} // ignore everything else
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0574"><a class="header" href="#error-code-e0574">Error code E0574</a></h1>
<p>Something other than a struct, variant or union has been used when one was
expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0574"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mordor {}

let sauron = mordor { x: () }; // error!

enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak { i } =&gt; {} // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In all these errors, a type was expected. For example, in the first error,
we tried to instantiate the <code>mordor</code> module, which is impossible. If you want
to instantiate a type inside a module, you can do it as follow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod mordor {
    pub struct TheRing {
        pub x: usize,
    }
}

let sauron = mordor::TheRing { x: 1 }; // ok!
<span class="boring">}</span></code></pre></pre>
<p>In the second error, we tried to bind the <code>Jak</code> enum directly, which is not
possible: you can only bind one of its variants. To do so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Jak {
    Daxter { i: isize },
}

let eco = Jak::Daxter { i: 1 };
match eco {
    Jak::Daxter { i } =&gt; {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0575"><a class="header" href="#error-code-e0575">Error code E0575</a></h1>
<p>Something other than a type or an associated type was given.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0575"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Rick { Morty }

let _: &lt;u8 as Rick&gt;::Morty; // error!

trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Mythology; // error!
<span class="boring">}</span></code></pre></pre>
<p>In both cases, we're declaring a variable (called <code>_</code>) and we're giving it a
type. However, <code>&lt;u8 as Rick&gt;::Morty</code> and <code>&lt;u8 as Age&gt;::Mythology</code> aren't types,
therefore the compiler throws an error.</p>
<p><code>&lt;u8 as Rick&gt;::Morty</code> is an enum variant, you cannot use a variant as a type,
you have to use the enum directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Rick { Morty }

let _: Rick; // ok!
<span class="boring">}</span></code></pre></pre>
<p><code>&lt;u8 as Age&gt;::Mythology</code> is a trait method, which is definitely not a type.
However, the <code>Age</code> trait provides an associated type <code>Empire</code> which can be
used as a type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Age {
    type Empire;
    fn Mythology() {}
}

impl Age for u8 {
    type Empire = u16;
}

let _: &lt;u8 as Age&gt;::Empire; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0576"><a class="header" href="#error-code-e0576">Error code E0576</a></h1>
<p>An associated item wasn't found in the given type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0576"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::You; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we tried to use the nonexistent associated type <code>You</code> of the
<code>Hello</code> trait. To fix this error, use an existing associated type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Hello {
    type Who;

    fn hello() -&gt; &lt;Self as Hello&gt;::Who; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0577"><a class="header" href="#error-code-e0577">Error code E0577</a></h1>
<p>Something other than a module was found in visibility scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0577 edition2018">pub struct Sea;

pub (in crate::Sea) struct Shark; // error!

fn main() {}</code></pre></pre>
<p><code>Sea</code> is not a module, therefore it is invalid to use it in a visibility path.
To fix this error we need to ensure <code>sea</code> is a module.</p>
<p>Please note that the visibility scope can only be applied on ancestors!</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod sea {
    pub (in crate::sea) struct Shark; // ok!
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0578"><a class="header" href="#error-code-e0578">Error code E0578</a></h1>
<p>A module cannot be found and therefore, the visibility cannot be determined.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0578 edition2018">foo!();

pub (in ::Sea) struct Shark; // error!

fn main() {}</code></pre></pre>
<p>Because of the call to the <code>foo</code> macro, the compiler guesses that the missing
module could be inside it and fails because the macro definition cannot be
found.</p>
<p>To fix this error, please be sure that the module is in scope:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod Sea {
    pub (in crate::Sea) struct Shark;
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0579"><a class="header" href="#error-code-e0579">Error code E0579</a></h1>
<p>A lower range wasn't less than the upper range.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0579">#![feature(exclusive_range_pattern)]

fn main() {
    match 5u32 {
        // This range is ok, albeit pointless.
        1..2 =&gt; {}
        // This range is empty, and the compiler can tell.
        5..5 =&gt; {} // error!
    }
}</code></pre></pre>
<p>When matching against an exclusive range, the compiler verifies that the range
is non-empty. Exclusive range patterns include the start point but not the end
point, so this is equivalent to requiring the start of the range to be less
than the end of the range.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0580"><a class="header" href="#error-code-e0580">Error code E0580</a></h1>
<p>The <code>main</code> function was incorrectly declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0580">fn main(x: i32) { // error: main function has wrong type
    println!(&quot;{}&quot;, x);
}</code></pre></pre>
<p>The <code>main</code> function prototype should never take arguments.
Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // your code
}</code></pre></pre>
<p>If you want to get command-line arguments, use <code>std::env::args</code>. To exit with a
specified exit code, use <code>std::process::exit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0581"><a class="header" href="#error-code-e0581">Error code E0581</a></h1>
<p>In a <code>fn</code> type, a lifetime appears only in the return type
and not in the arguments types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0581">fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn() -&gt; &amp;'a i32;
}</code></pre></pre>
<p>The problem here is that the lifetime isn't constrained by any of the arguments,
making it impossible to determine how long it's supposed to live.</p>
<p>To fix this issue, either use the lifetime in the arguments, or use the
<code>'static</code> lifetime. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Here, `'a` appears only in the return type:
    let x: for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32;
    let y: fn() -&gt; &amp;'static i32;
}</code></pre></pre>
<p>Note: The examples above used to be (erroneously) accepted by the
compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685">issue #33685</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0582"><a class="header" href="#error-code-e0582">Error code E0582</a></h1>
<p>A lifetime is only present in an associated-type binding, and not in the input
types to the trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0582">fn bar&lt;F&gt;(t: F)
    // No type can satisfy this requirement, since `'a` does not
    // appear in any of the input types (here, `i32`):
    where F: for&lt;'a&gt; Fn(i32) -&gt; Option&lt;&amp;'a i32&gt;
{
}

fn main() { }</code></pre></pre>
<p>To fix this issue, either use the lifetime in the inputs, or use
<code>'static</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust">fn bar&lt;F, G&gt;(t: F, u: G)
    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; Option&lt;&amp;'a i32&gt;,
          G: Fn(i32) -&gt; Option&lt;&amp;'static i32&gt;,
{
}

fn main() { }</code></pre></pre>
<p>Note: The examples above used to be (erroneously) accepted by the
compiler, but this was since corrected. See <a href="https://github.com/rust-lang/rust/issues/33685">issue #33685</a> for more
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0583"><a class="header" href="#error-code-e0583">Error code E0583</a></h1>
<p>A file wasn't found for an out-of-line module.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0583">mod file_that_doesnt_exist; // error: file not found for module

fn main() {}</code></pre></pre>
<p>Please be sure that a file corresponding to the module exists. If you
want to use a module named <code>file_that_doesnt_exist</code>, you need to have a file
named <code>file_that_doesnt_exist.rs</code> or <code>file_that_doesnt_exist/mod.rs</code> in the
same directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0584"><a class="header" href="#error-code-e0584">Error code E0584</a></h1>
<p>A doc comment that is not attached to anything has been encountered.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0584"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Island {
    fn lost();

    /// I'm lost!
}
<span class="boring">}</span></code></pre></pre>
<p>A little reminder: a doc comment has to be placed before the item it's supposed
to document. So if you want to document the <code>Island</code> trait, you need to put a
doc comment before it, not inside it. Same goes for the <code>lost</code> method: the doc
comment needs to be before it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// I'm THE island!
trait Island {
    /// I'm lost!
    fn lost();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0585"><a class="header" href="#error-code-e0585">Error code E0585</a></h1>
<p>A documentation comment that doesn't document anything was found.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0585">fn main() {
    // The following doc comment will fail:
    /// This is a useless doc comment!
}</code></pre></pre>
<p>Documentation comments need to be followed by items, including functions,
types, modules, etc. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// I'm documenting the following struct:
struct Foo;

/// I'm documenting the following function:
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0586"><a class="header" href="#error-code-e0586">Error code E0586</a></h1>
<p>An inclusive range was used with no end.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0586">fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=]; // error: inclusive range was used with no end
}</code></pre></pre>
<p>An inclusive range needs an end in order to <em>include</em> it. If you just need a
start and no end, use a non-inclusive range (with <code>..</code>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..]; // ok!
}</code></pre></pre>
<p>Or put an end to your inclusive range:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];
    let x = &amp;tmp[1..=3]; // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0587"><a class="header" href="#error-code-e0587">Error code E0587</a></h1>
<p>A type has both <code>packed</code> and <code>align</code> representation hints.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0587"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed, align(8))] // error!
struct Umbrella(i32);
<span class="boring">}</span></code></pre></pre>
<p>You cannot use <code>packed</code> and <code>align</code> hints on a same type. If you want to pack a
type to a given size, you should provide a size to packed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed(8))] // ok!
struct Umbrella(i32);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0588"><a class="header" href="#error-code-e0588">Error code E0588</a></h1>
<p>A type with <code>packed</code> representation hint has a field with <code>align</code>
representation hint.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0588"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(16))]
struct Aligned(i32);

#[repr(packed)] // error!
struct Packed(Aligned);
<span class="boring">}</span></code></pre></pre>
<p>Just like you cannot have both <code>align</code> and <code>packed</code> representation hints on the
same type, a <code>packed</code> type cannot contain another type with the <code>align</code>
representation hint. However, you can do the opposite:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed(i32);

#[repr(align(16))] // ok!
struct Aligned(Packed);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0589"><a class="header" href="#error-code-e0589">Error code E0589</a></h1>
<p>The value of <code>N</code> that was specified for <code>repr(align(N))</code> was not a power
of two, or was greater than 2^29.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0589"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(15))] // error: invalid `repr(align)` attribute: not a power of two
enum Foo {
    Bar(u64),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0590"><a class="header" href="#error-code-e0590">Error code E0590</a></h1>
<p><code>break</code> or <code>continue</code> keywords were used in a condition of a <code>while</code> loop
without a label.</p>
<p>Erroneous code code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0590"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while break {}
<span class="boring">}</span></code></pre></pre>
<p><code>break</code> or <code>continue</code> must include a label when used in the condition of a
<code>while</code> loop.</p>
<p>To fix this, add a label specifying which loop is being broken out of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'foo: while break 'foo {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0591"><a class="header" href="#error-code-e0591">Error code E0591</a></h1>
<p>Per <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>, if you have a function declaration <code>foo</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S;

// For the purposes of this explanation, all of these
// different kinds of `fn` declarations are equivalent:

fn foo(x: S) { /* ... */ }
<span class="boring">#[cfg(for_demonstration_only)]
</span>extern &quot;C&quot; {
    fn foo(x: S);
}
<span class="boring">#[cfg(for_demonstration_only)]
</span>impl S {
    fn foo(self) { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<p>the type of <code>foo</code> is <strong>not</strong> <code>fn(S)</code>, as one might expect.
Rather, it is a unique, zero-sized marker type written here as <code>typeof(foo)</code>.
However, <code>typeof(foo)</code> can be <em>coerced</em> to a function pointer <code>fn(S)</code>,
so you rarely notice this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct S;
</span><span class="boring">fn foo(_: S) {}
</span>let x: fn(S) = foo; // OK, coerces
<span class="boring">}</span></code></pre></pre>
<p>The reason that this matter is that the type <code>fn(S)</code> is not specific to
any particular function: it's a function <em>pointer</em>. So calling <code>x()</code> results
in a virtual call, whereas <code>foo()</code> is statically dispatched, because the type
of <code>foo</code> tells us precisely what function is being called.</p>
<p>As noted above, coercions mean that most code doesn't have to be
concerned with this distinction. However, you can tell the difference
when using <strong>transmute</strong> to convert a fn item into a fn pointer.</p>
<p>This is sometimes done as part of an FFI:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0591"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn foo(userdata: Box&lt;i32&gt;) {
    /* ... */
}

<span class="boring">fn callback(_: extern &quot;C&quot; fn(*mut i32)) {}
</span><span class="boring">use std::mem::transmute;
</span>unsafe {
    let f: extern &quot;C&quot; fn(*mut i32) = transmute(foo);
    callback(f);
}
<span class="boring">}</span></code></pre></pre>
<p>Here, transmute is being used to convert the types of the fn arguments.
This pattern is incorrect because the type of <code>foo</code> is a function <strong>item</strong>
(<code>typeof(foo)</code>), which is zero-sized, and the target type (<code>fn()</code>)
is a function pointer, which is not zero-sized.
This pattern should be rewritten. There are a few possible ways to do this:</p>
<ul>
<li>
<p>change the original fn declaration to match the expected signature,
and do the cast in the fn body (the preferred option)</p>
</li>
<li>
<p>cast the fn item of a fn pointer before calling transmute, as shown here:</p>
<pre><code># extern &quot;C&quot; fn foo(_: Box&lt;i32&gt;) {}
# use std::mem::transmute;
# unsafe {
let f: extern &quot;C&quot; fn(*mut i32) = transmute(foo as extern &quot;C&quot; fn(_));
let f: extern &quot;C&quot; fn(*mut i32) = transmute(foo as usize); // works too
# }
</code></pre>
</li>
</ul>
<p>The same applies to transmutes to <code>*mut fn()</code>, which were observed in practice.
Note though that use of this type is generally incorrect.
The intention is typically to describe a function pointer, but just <code>fn()</code>
alone suffices for that. <code>*mut fn()</code> is a pointer to a fn pointer.
(Since these values are typically just passed to C code, however, this rarely
makes a difference in practice.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0592"><a class="header" href="#error-code-e0592">Error code E0592</a></h1>
<p>This error occurs when you defined methods or associated functions with same
name.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0592"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar() {} // previous definition here
}

impl Foo {
    fn bar() {} // duplicate definition here
}
<span class="boring">}</span></code></pre></pre>
<p>A similar error is E0201. The difference is whether there is one declaration
block or not. To avoid this error, you must give each <code>fn</code> a unique name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo;

impl Foo {
    fn bar() {}
}

impl Foo {
    fn baz() {} // define with different name
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0593"><a class="header" href="#error-code-e0593">Error code E0593</a></h1>
<p>You tried to supply an <code>Fn</code>-based type with an incorrect number of arguments
than what was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0593">fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    // [E0593] closure takes 1 argument but 0 arguments are required
    foo(|y| { });
}</code></pre></pre>
<p>You have to provide the same number of arguments as expected by the <code>Fn</code>-based
type. So to fix the previous example, we need to remove the <code>y</code> argument:</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;F: Fn()&gt;(x: F) { }

fn main() {
    foo(|| { }); // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0594"><a class="header" href="#error-code-e0594">Error code E0594</a></h1>
<p>A non-mutable value was assigned a value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0594"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SolarSystem {
    earth: i32,
}

let ss = SolarSystem { earth: 3 };
ss.earth = 2; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, declare <code>ss</code> as mutable by using the <code>mut</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SolarSystem {
    earth: i32,
}

let mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable
ss.earth = 2; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0595"><a class="header" href="#error-code-e0595">Error code E0595</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-52"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-52">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Closures cannot mutate immutable captured variables.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0594"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3; // error: closure cannot assign to immutable local variable `x`
let mut c = || { x += 1 };
<span class="boring">}</span></code></pre></pre>
<p>Make the variable binding mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3; // ok!
let mut c = || { x += 1 };
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0596"><a class="header" href="#error-code-e0596">Error code E0596</a></h1>
<p>This error occurs because you tried to mutably borrow a non-mutable variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0596"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
let y = &amp;mut x; // error: cannot borrow mutably
<span class="boring">}</span></code></pre></pre>
<p>In here, <code>x</code> isn't mutable, so when we try to mutably borrow it in <code>y</code>, it
fails. To fix this error, you need to make <code>x</code> mutable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 1;
let y = &amp;mut x; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0597"><a class="header" href="#error-code-e0597">Error code E0597</a></h1>
<p>This error occurs because a value was dropped while it was still borrowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };
{
    let y = 0;
    x.x = Some(&amp;y); // error: `y` does not live long enough
}
println!(&quot;{:?}&quot;, x.x);
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>y</code> is dropped at the end of the inner scope, but it is borrowed by
<code>x</code> until the <code>println</code>. To fix the previous example, just remove the scope
so that <code>y</code> isn't dropped until after the println</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: Option&lt;&amp;'a u32&gt;,
}

let mut x = Foo { x: None };

let y = 0;
x.x = Some(&amp;y);

println!(&quot;{:?}&quot;, x.x);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0599"><a class="header" href="#error-code-e0599">Error code E0599</a></h1>
<p>This error occurs when a method is used on a type which doesn't implement it:</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0599"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Mouth;

let x = Mouth;
x.chocolate(); // error: no method named `chocolate` found for type `Mouth`
               //        in the current scope
<span class="boring">}</span></code></pre></pre>
<p>In this case, you need to implement the <code>chocolate</code> method to fix the error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Mouth;

impl Mouth {
    fn chocolate(&amp;self) { // We implement the `chocolate` method here.
        println!(&quot;Hmmm! I love chocolate!&quot;);
    }
}

let x = Mouth;
x.chocolate(); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0600"><a class="header" href="#error-code-e0600">Error code E0600</a></h1>
<p>An unary operator was used on a type which doesn't implement it.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0600"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Question {
    Yes,
    No,
}

!Question::Yes; // error: cannot apply unary operator `!` to type `Question`
<span class="boring">}</span></code></pre></pre>
<p>In this case, <code>Question</code> would need to implement the <code>std::ops::Not</code> trait in
order to be able to use <code>!</code> on it. Let's implement it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Not;

enum Question {
    Yes,
    No,
}

// We implement the `Not` trait on the enum.
impl Not for Question {
    type Output = bool;

    fn not(self) -&gt; bool {
        match self {
            Question::Yes =&gt; false, // If the `Answer` is `Yes`, then it
                                    // returns false.
            Question::No =&gt; true, // And here we do the opposite.
        }
    }
}

assert_eq!(!Question::Yes, false);
assert_eq!(!Question::No, true);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0601"><a class="header" href="#error-code-e0601">Error code E0601</a></h1>
<p>No <code>main</code> function was found in a binary crate.</p>
<p>To fix this error, add a <code>main</code> function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // Your program will start here.
    println!(&quot;Hello world!&quot;);
}</code></pre></pre>
<p>If you don't know the basics of Rust, you can look at the
<a href="https://doc.rust-lang.org/book/">Rust Book</a> to get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0602"><a class="header" href="#error-code-e0602">Error code E0602</a></h1>
<p>An unknown or invalid lint was used on the command line.</p>
<p>Erroneous code example:</p>
<pre><code class="language-sh">rustc -D bogus rust_file.rs
</code></pre>
<p>Maybe you just misspelled the lint name or the lint doesn't exist anymore.
Either way, try to update/remove it in order to fix the error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0603"><a class="header" href="#error-code-e0603">Error code E0603</a></h1>
<p>A private item was used outside its scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0603"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we
                                            // can't use it outside of the
                                            // `foo` module.
}

println!(&quot;const value: {}&quot;, foo::PRIVATE); // error: constant `PRIVATE`
                                                  //        is private
<span class="boring">}</span></code></pre></pre>
<p>In order to fix this error, you need to make the item public by using the <code>pub</code>
keyword. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the
                                                // `pub` keyword.
}

println!(&quot;const value: {}&quot;, foo::PRIVATE); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0604"><a class="header" href="#error-code-e0604">Error code E0604</a></h1>
<p>A cast to <code>char</code> was attempted on a type other than <code>u8</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0604"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0u32 as char; // error: only `u8` can be cast as `char`, not `u32`
<span class="boring">}</span></code></pre></pre>
<p><code>char</code> is a Unicode Scalar Value, an integer value from 0 to 0xD7FF and
0xE000 to 0x10FFFF. (The gap is for surrogate pairs.) Only <code>u8</code> always fits in
those ranges so only <code>u8</code> may be cast to <code>char</code>.</p>
<p>To allow larger values, use <code>char::from_u32</code>, which checks the value is valid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(86u8 as char, 'V'); // ok!
assert_eq!(char::from_u32(0x3B1), Some('α')); // ok!
assert_eq!(char::from_u32(0xD800), None); // not a USV.
<span class="boring">}</span></code></pre></pre>
<p>For more information about casts, take a look at the Type cast section in
<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">The Reference Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0605"><a class="header" href="#error-code-e0605">Error code E0605</a></h1>
<p>An invalid cast was attempted.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0605"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0u8;
x as Vec&lt;u8&gt;; // error: non-primitive cast: `u8` as `std::vec::Vec&lt;u8&gt;`

// Another example

let v = core::ptr::null::&lt;u8&gt;(); // So here, `v` is a `*const u8`.
v as &amp;u8; // error: non-primitive cast: `*const u8` as `&amp;u8`
<span class="boring">}</span></code></pre></pre>
<p>Only primitive types can be cast into each other. Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0u8;
x as u32; // ok!

let v = core::ptr::null::&lt;u8&gt;();
v as *const i8; // ok!
<span class="boring">}</span></code></pre></pre>
<p>For more information about casts, take a look at the Type cast section in
<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">The Reference Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0606"><a class="header" href="#error-code-e0606">Error code E0606</a></h1>
<p>An incompatible cast was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0606"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;0u8; // Here, `x` is a `&amp;u8`.
let y: u32 = x as u32; // error: casting `&amp;u8` as `u32` is invalid
<span class="boring">}</span></code></pre></pre>
<p>When casting, keep in mind that only primitive types can be cast into each
other. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;0u8;
let y: u32 = *x as u32; // We dereference it first and then cast it.
<span class="boring">}</span></code></pre></pre>
<p>For more information about casts, take a look at the Type cast section in
<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">The Reference Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0607"><a class="header" href="#error-code-e0607">Error code E0607</a></h1>
<p>A cast between a thin and a fat pointer was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0607"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = core::ptr::null::&lt;u8&gt;();
v as *const [u8];
<span class="boring">}</span></code></pre></pre>
<p>First: what are thin and fat pointers?</p>
<p>Thin pointers are &quot;simple&quot; pointers: they are purely a reference to a memory
address.</p>
<p>Fat pointers are pointers referencing Dynamically Sized Types (also called
DSTs). DSTs don't have a statically known size, therefore they can only exist
behind some kind of pointer that contains additional information. For example,
slices and trait objects are DSTs. In the case of slices, the additional
information the fat pointer holds is their size.</p>
<p>To fix this error, don't try to cast directly between thin and fat pointers.</p>
<p>For more information about type casts, take a look at the section of the
<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">The Rust Reference</a> on type cast expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0608"><a class="header" href="#error-code-e0608">Error code E0608</a></h1>
<p>An attempt to use index on a type which doesn't implement the <code>std::ops::Index</code>
trait was performed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0608"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>0u8[2]; // error: cannot index into a value of type `u8`
<span class="boring">}</span></code></pre></pre>
<p>To be able to index into a type it needs to implement the <code>std::ops::Index</code>
trait. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u8&gt; = vec![0, 1, 2, 3];

// The `Vec` type implements the `Index` trait so you can do:
println!(&quot;{}&quot;, v[2]);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0609"><a class="header" href="#error-code-e0609">Error code E0609</a></h1>
<p>Attempted to access a nonexistent field in a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0609"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!(&quot;{}&quot;, s.foo); // error: no field `foo` on type `StructWithFields`
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, check that you didn't misspell the field's name or that the
field actually exists. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StructWithFields {
    x: u32,
}

let s = StructWithFields { x: 0 };
println!(&quot;{}&quot;, s.x); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0610"><a class="header" href="#error-code-e0610">Error code E0610</a></h1>
<p>Attempted to access a field on a primitive type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0610"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 0;
println!(&quot;{}&quot;, x.foo); // error: `{integer}` is a primitive type, therefore
                       //        doesn't have fields
<span class="boring">}</span></code></pre></pre>
<p>Primitive types are the most basic types available in Rust and don't have
fields. To access data via named fields, struct types are used. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We declare struct called `Foo` containing two fields:
struct Foo {
    x: u32,
    y: i64,
}

// We create an instance of this struct:
let variable = Foo { x: 0, y: -12 };
// And we can now access its fields:
println!(&quot;x: {}, y: {}&quot;, variable.x, variable.y);
<span class="boring">}</span></code></pre></pre>
<p>For more information about <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">primitives</a> and <a href="https://doc.rust-lang.org/book/ch05-00-structs.html">structs</a>, take a look at the Book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0614"><a class="header" href="#error-code-e0614">Error code E0614</a></h1>
<p>Attempted to dereference a variable which cannot be dereferenced.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0614"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = 0u32;
*y; // error: type `u32` cannot be dereferenced
<span class="boring">}</span></code></pre></pre>
<p>Only types implementing <code>std::ops::Deref</code> can be dereferenced (such as <code>&amp;T</code>).
Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = 0u32;
let x = &amp;y;
// So here, `x` is a `&amp;u32`, so we can dereference it:
*x; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0615"><a class="header" href="#error-code-e0615">Error code E0615</a></h1>
<p>Attempted to access a method like a field.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0615"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: u32,
}

impl Foo {
    fn method(&amp;self) {}
}

let f = Foo { x: 0 };
f.method; // error: attempted to take value of method `method` on type `Foo`
<span class="boring">}</span></code></pre></pre>
<p>If you want to use a method, add <code>()</code> after it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo { x: u32 }
</span><span class="boring">impl Foo { fn method(&amp;self) {} }
</span><span class="boring">let f = Foo { x: 0 };
</span>f.method();
<span class="boring">}</span></code></pre></pre>
<p>However, if you wanted to access a field of a struct check that the field name
is spelled correctly. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo { x: u32 }
</span><span class="boring">impl Foo { fn method(&amp;self) {} }
</span><span class="boring">let f = Foo { x: 0 };
</span>println!(&quot;{}&quot;, f.x);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0616"><a class="header" href="#error-code-e0616">Error code E0616</a></h1>
<p>Attempted to access a private field on a struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0616"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod some_module {
    pub struct Foo {
        x: u32, // So `x` is private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!(&quot;{}&quot;, f.x); // error: field `x` of struct `some_module::Foo` is private
<span class="boring">}</span></code></pre></pre>
<p>If you want to access this field, you have two options:</p>
<ol>
<li>Set the field public:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod some_module {
    pub struct Foo {
        pub x: u32, // `x` is now public.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }
    }
}

let f = some_module::Foo::new();
println!(&quot;{}&quot;, f.x); // ok!
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Add a getter function:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod some_module {
    pub struct Foo {
        x: u32, // So `x` is still private in here.
    }

    impl Foo {
        pub fn new() -&gt; Foo { Foo { x: 0 } }

        // We create the getter function here:
        pub fn get_x(&amp;self) -&gt; &amp;u32 { &amp;self.x }
    }
}

let f = some_module::Foo::new();
println!(&quot;{}&quot;, f.get_x()); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0617"><a class="header" href="#error-code-e0617">Error code E0617</a></h1>
<p>Attempted to pass an invalid type of variable into a variadic function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0617"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::os::raw::{c_char, c_int};
</span>extern &quot;C&quot; {
    fn printf(format: *const c_char, ...) -&gt; c_int;
}

unsafe {
    printf(&quot;%f\n\0&quot;.as_ptr() as _, 0f32);
    // error: cannot pass an `f32` to variadic function, cast to `c_double`
}
<span class="boring">}</span></code></pre></pre>
<p>Certain Rust types must be cast before passing them to a variadic function,
because of arcane ABI rules dictated by the C standard. To fix the error,
cast the value to the type specified by the error message (which you may need
to import from <code>std::os::raw</code>).</p>
<p>In this case, <code>c_double</code> has the same size as <code>f64</code> so we can use it directly:</p>
<pre><code class="language-no_run"># use std::os::raw::{c_char, c_int};
# extern &quot;C&quot; {
#     fn printf(format: *const c_char, ...) -&gt; c_int;
# }

unsafe {
    printf(&quot;%f\n\0&quot;.as_ptr() as _, 0f64); // ok!
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0618"><a class="header" href="#error-code-e0618">Error code E0618</a></h1>
<p>Attempted to call something which isn't a function nor a method.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0618"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum X {
    Entry,
}

X::Entry(); // error: expected function, tuple struct or tuple variant,
            // found `X::Entry`

// Or even simpler:
let x = 0i32;
x(); // error: expected function, tuple struct or tuple variant, found `i32`
<span class="boring">}</span></code></pre></pre>
<p>Only functions and methods can be called using <code>()</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We declare a function:
fn i_am_a_function() {}

// And we call it:
i_am_a_function();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0619"><a class="header" href="#error-code-e0619">Error code E0619</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-53"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-53">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The type-checker needed to know the type of an expression, but that type had not
yet been inferred.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = vec![];
match x.pop() {
    Some(v) =&gt; {
        // Here, the type of `v` is not (yet) known, so we
        // cannot resolve this method call:
        v.to_uppercase(); // error: the type of this value must be known in
                          //        this context
    }
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>Type inference typically proceeds from the top of the function to the bottom,
figuring out types as it goes. In some cases -- notably method calls and
overloadable operators like <code>*</code> -- the type checker may not have enough
information <em>yet</em> to make progress. This can be true even if the rest of the
function provides enough context (because the type-checker hasn't looked that
far ahead yet). In this case, type annotations can be used to help it along.</p>
<p>To fix this error, just specify the type of the variable. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x: Vec&lt;String&gt; = vec![]; // We precise the type of the vec elements.
match x.pop() {
    Some(v) =&gt; {
        v.to_uppercase(); // Since rustc now knows the type of the vec elements,
                          // we can use `v`'s methods.
    }
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0620"><a class="header" href="#error-code-e0620">Error code E0620</a></h1>
<p>A cast to an unsized type was attempted.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0620"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;[1_usize, 2] as [usize]; // error: cast to unsized type: `&amp;[usize; 2]`
                                  //        as `[usize]`
<span class="boring">}</span></code></pre></pre>
<p>In Rust, some types don't have a known size at compile-time. For example, in a
slice type like <code>[u32]</code>, the number of elements is not known at compile-time and
hence the overall size cannot be computed. As a result, such types can only be
manipulated through a reference (e.g., <code>&amp;T</code> or <code>&amp;mut T</code>) or other pointer-type
(e.g., <code>Box</code> or <code>Rc</code>). Try casting to a reference instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &amp;[1_usize, 2] as &amp;[usize]; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0621"><a class="header" href="#error-code-e0621">Error code E0621</a></h1>
<p>This error code indicates a mismatch between the lifetimes appearing in the
function signature (i.e., the parameter types and the return type) and the
data-flow found in the function body.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0621"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 { // error: explicit lifetime
                                             //        required in the type of
                                             //        `y`
    if x &gt; y { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<p>In the code above, the function is returning data borrowed from either <code>x</code> or
<code>y</code>, but the <code>'a</code> annotation indicates that it is returning data only from <code>x</code>.
To fix the error, the signature and the body must be made to match. Typically,
this is done by updating the function signature. So, in this case, we change
the type of <code>y</code> to <code>&amp;'a i32</code>, like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;'a i32) -&gt; &amp;'a i32 {
    if x &gt; y { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<p>Now the signature indicates that the function data borrowed from either <code>x</code> or
<code>y</code>. Alternatively, you could change the body to not return data from <code>y</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a i32, y: &amp;i32) -&gt; &amp;'a i32 {
    x
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0622"><a class="header" href="#error-code-e0622">Error code E0622</a></h1>
<p>An intrinsic was declared without being a function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0622">#![feature(intrinsics)]
extern &quot;rust-intrinsic&quot; {
    pub static breakpoint: fn(); // error: intrinsic must be a function
}

fn main() { unsafe { breakpoint(); } }</code></pre></pre>
<p>An intrinsic is a function available for use in a given programming language
whose implementation is handled specially by the compiler. In order to fix this
error, just declare a function. Example:</p>
<pre><code class="language-no_run">#![feature(intrinsics)]
extern &quot;rust-intrinsic&quot; {
    pub fn breakpoint(); // ok!
}

fn main() { unsafe { breakpoint(); } }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0623"><a class="header" href="#error-code-e0623">Error code E0623</a></h1>
<p>A lifetime didn't match what was expected.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0623"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, 'b, T&gt;(std::marker::PhantomData&lt;(&amp;'a (), &amp;'b (), T)&gt;)
where
    T: Convert&lt;'a, 'b&gt;;

trait Convert&lt;'a, 'b&gt;: Sized {
    fn cast(&amp;'a self) -&gt; &amp;'b Self;
}
impl&lt;'long: 'short, 'short, T&gt; Convert&lt;'long, 'short&gt; for T {
    fn cast(&amp;'long self) -&gt; &amp;'short T {
        self
    }
}
// error
fn badboi&lt;'in_, 'out, T&gt;(
    x: Foo&lt;'in_, 'out, T&gt;,
    sadness: &amp;'in_ T
) -&gt; &amp;'out T {
    sadness.cast()
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, we tried to set a value with an incompatible lifetime to
another one (<code>'in_</code> is unrelated to <code>'out</code>). We can solve this issue in
two different ways:</p>
<p>Either we make <code>'in_</code> live at least as long as <code>'out</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, 'b, T&gt;(std::marker::PhantomData&lt;(&amp;'a (), &amp;'b (), T)&gt;)
where
    T: Convert&lt;'a, 'b&gt;;

trait Convert&lt;'a, 'b&gt;: Sized {
    fn cast(&amp;'a self) -&gt; &amp;'b Self;
}
impl&lt;'long: 'short, 'short, T&gt; Convert&lt;'long, 'short&gt; for T {
    fn cast(&amp;'long self) -&gt; &amp;'short T {
        self
    }
}
fn badboi&lt;'in_: 'out, 'out, T&gt;(
    x: Foo&lt;'in_, 'out, T&gt;,
    sadness: &amp;'in_ T
) -&gt; &amp;'out T {
    sadness.cast()
}
<span class="boring">}</span></code></pre></pre>
<p>Or we use only one lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, 'b, T&gt;(std::marker::PhantomData&lt;(&amp;'a (), &amp;'b (), T)&gt;)
where
    T: Convert&lt;'a, 'b&gt;;

trait Convert&lt;'a, 'b&gt;: Sized {
    fn cast(&amp;'a self) -&gt; &amp;'b Self;
}
impl&lt;'long: 'short, 'short, T&gt; Convert&lt;'long, 'short&gt; for T {
    fn cast(&amp;'long self) -&gt; &amp;'short T {
        self
    }
}
fn badboi&lt;'out, T&gt;(x: Foo&lt;'out, 'out, T&gt;, sadness: &amp;'out T) -&gt; &amp;'out T {
    sadness.cast()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0624"><a class="header" href="#error-code-e0624">Error code E0624</a></h1>
<p>A private item was used outside of its scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0624"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }
}

let foo = inner::Foo;
foo.method(); // error: method `method` is private
<span class="boring">}</span></code></pre></pre>
<p>Two possibilities are available to solve this issue:</p>
<ol>
<li>Only use the item in the scope it has been defined:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod inner {
    pub struct Foo;

    impl Foo {
        fn method(&amp;self) {}
    }

    pub fn call_method(foo: &amp;Foo) { // We create a public function.
        foo.method(); // Which calls the item.
    }
}

let foo = inner::Foo;
inner::call_method(&amp;foo); // And since the function is public, we can call the
                          // method through it.
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Make the item public:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod inner {
    pub struct Foo;

    impl Foo {
        pub fn method(&amp;self) {} // It's now public.
    }
}

let foo = inner::Foo;
foo.method(); // Ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0625"><a class="header" href="#error-code-e0625">Error code E0625</a></h1>
<p>A compile-time const variable is referring to a thread-local static variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0625"><span class="boring">#![allow(unused)]
</span>#![feature(thread_local)]

<span class="boring">fn main() {
</span>#[thread_local]
static X: usize = 12;

const Y: usize = 2 * X;
<span class="boring">}</span></code></pre></pre>
<p>Static and const variables can refer to other const variables but a const
variable cannot refer to a thread-local static variable. In this example,
<code>Y</code> cannot refer to <code>X</code>. To fix this, the value can be extracted as a const
and then used:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(thread_local)]

<span class="boring">fn main() {
</span>const C: usize = 12;

#[thread_local]
static X: usize = C;

const Y: usize = 2 * C;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0626"><a class="header" href="#error-code-e0626">Error code E0626</a></h1>
<p>This error occurs because a borrow in a generator persists across a
yield point.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0626"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(generators, generator_trait, pin)]
</span><span class="boring">use std::ops::Generator;
</span><span class="boring">use std::pin::Pin;
</span>let mut b = || {
    let a = &amp;String::new(); // &lt;-- This borrow...
    yield (); // ...is still in scope here, when the yield occurs.
    println!(&quot;{}&quot;, a);
};
Pin::new(&amp;mut b).resume(());
<span class="boring">}</span></code></pre></pre>
<p>At present, it is not permitted to have a yield that occurs while a
borrow is still in scope. To resolve this error, the borrow must
either be &quot;contained&quot; to a smaller scope that does not overlap the
yield or else eliminated in another way. So, for example, we might
resolve the previous example by removing the borrow and just storing
the integer by value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(generators, generator_trait, pin)]
</span><span class="boring">use std::ops::Generator;
</span><span class="boring">use std::pin::Pin;
</span>let mut b = || {
    let a = 3;
    yield ();
    println!(&quot;{}&quot;, a);
};
Pin::new(&amp;mut b).resume(());
<span class="boring">}</span></code></pre></pre>
<p>This is a very simple case, of course. In more complex cases, we may
wish to have more than one reference to the value that was borrowed --
in those cases, something like the <code>Rc</code> or <code>Arc</code> types may be useful.</p>
<p>This error also frequently arises with iteration:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0626"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(generators, generator_trait, pin)]
</span><span class="boring">use std::ops::Generator;
</span><span class="boring">use std::pin::Pin;
</span>let mut b = || {
  let v = vec![1,2,3];
  for &amp;x in &amp;v { // &lt;-- borrow of `v` is still in scope...
    yield x; // ...when this yield occurs.
  }
};
Pin::new(&amp;mut b).resume(());
<span class="boring">}</span></code></pre></pre>
<p>Such cases can sometimes be resolved by iterating &quot;by value&quot; (or using
<code>into_iter()</code>) to avoid borrowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(generators, generator_trait, pin)]
</span><span class="boring">use std::ops::Generator;
</span><span class="boring">use std::pin::Pin;
</span>let mut b = || {
  let v = vec![1,2,3];
  for x in v { // &lt;-- Take ownership of the values instead!
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());
<span class="boring">}</span></code></pre></pre>
<p>If taking ownership is not an option, using indices can work too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(generators, generator_trait, pin)]
</span><span class="boring">use std::ops::Generator;
</span><span class="boring">use std::pin::Pin;
</span>let mut b = || {
  let v = vec![1,2,3];
  let len = v.len(); // (*)
  for i in 0..len {
    let x = v[i]; // (*)
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());

// (*) -- Unfortunately, these temporaries are currently required.
// See &lt;https://github.com/rust-lang/rust/issues/43122&gt;.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0627"><a class="header" href="#error-code-e0627">Error code E0627</a></h1>
<p>A yield expression was used outside of the generator literal.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0627">#![feature(generators, generator_trait)]

fn fake_generator() -&gt; &amp;'static str {
    yield 1;
    return &quot;foo&quot;
}

fn main() {
    let mut generator = fake_generator;
}</code></pre></pre>
<p>The error occurs because keyword <code>yield</code> can only be used inside the generator
literal. This can be fixed by constructing the generator correctly.</p>
<pre><pre class="playground"><code class="language-rust">#![feature(generators, generator_trait)]

fn main() {
    let mut generator = || {
        yield 1;
        return &quot;foo&quot;
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0628"><a class="header" href="#error-code-e0628">Error code E0628</a></h1>
<p>More than one parameter was used for a generator.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0628">#![feature(generators, generator_trait)]

fn main() {
    let generator = |a: i32, b: i32| {
        // error: too many parameters for a generator
        // Allowed only 0 or 1 parameter
        yield a;
    };
}</code></pre></pre>
<p>At present, it is not permitted to pass more than one explicit
parameter for a generator.This can be fixed by using
at most 1 parameter for the generator. For example, we might resolve
the previous example by passing only one parameter.</p>
<pre><pre class="playground"><code class="language-rust">#![feature(generators, generator_trait)]

fn main() {
    let generator = |a: i32| {
        yield a;
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0631"><a class="header" href="#error-code-e0631">Error code E0631</a></h1>
<p>This error indicates a type mismatch in closure arguments.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0631">fn foo&lt;F: Fn(i32)&gt;(f: F) {
}

fn main() {
    foo(|x: &amp;str| {});
}</code></pre></pre>
<p>The error occurs because <code>foo</code> accepts a closure that takes an <code>i32</code> argument,
but in <code>main</code>, it is passed a closure with a <code>&amp;str</code> argument.</p>
<p>This can be resolved by changing the type annotation or removing it entirely
if it can be inferred.</p>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;F: Fn(i32)&gt;(f: F) {
}

fn main() {
    foo(|x: i32| {});
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0632"><a class="header" href="#error-code-e0632">Error code E0632</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-54"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-54">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An explicit generic argument was provided when calling a function that
uses <code>impl Trait</code> in argument position.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer an error)">fn foo&lt;T: Copy&gt;(a: T, b: impl Clone) {}

foo::&lt;i32&gt;(0i32, &quot;abc&quot;.to_string());</code></pre>
<p>Either all generic arguments should be inferred at the call site, or
the function definition should use an explicit generic type parameter
instead of <code>impl Trait</code>. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(a: T, b: impl Clone) {}
fn bar&lt;T: Copy, U: Clone&gt;(a: T, b: U) {}

foo(0i32, &quot;abc&quot;.to_string());

bar::&lt;i32, String&gt;(0i32, &quot;abc&quot;.to_string());
bar::&lt;_, _&gt;(0i32, &quot;abc&quot;.to_string());
bar(0i32, &quot;abc&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0633"><a class="header" href="#error-code-e0633">Error code E0633</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-55"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-55">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>unwind</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![feature(unwind_attributes)]

#[unwind()] // error: expected one argument
pub extern &quot;C&quot; fn something() {}

fn main() {}</code></pre></pre>
<p>The <code>#[unwind]</code> attribute should be used as follows:</p>
<ul>
<li>
<p><code>#[unwind(aborts)]</code> -- specifies that if a non-Rust ABI function
should abort the process if it attempts to unwind. This is the safer
and preferred option.</p>
</li>
<li>
<p><code>#[unwind(allowed)]</code> -- specifies that a non-Rust ABI function
should be allowed to unwind. This can easily result in Undefined
Behavior (UB), so be careful.</p>
</li>
</ul>
<p>NB. The default behavior here is &quot;allowed&quot;, but this is unspecified
and likely to change in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0634"><a class="header" href="#error-code-e0634">Error code E0634</a></h1>
<p>A type has conflicting <code>packed</code> representation hints.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0634"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed, packed(2))] // error!
struct Company(i32);

#[repr(packed(2))] // error!
#[repr(packed)]
struct Company(i32);
<span class="boring">}</span></code></pre></pre>
<p>You cannot use conflicting <code>packed</code> hints on a same type. If you want to pack a
type to a given size, you should provide a size to packed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)] // ok!
struct Company(i32);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0635"><a class="header" href="#error-code-e0635">Error code E0635</a></h1>
<p>The <code>#![feature]</code> attribute specified an unknown feature.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0635"><span class="boring">#![allow(unused)]
</span>#![feature(nonexistent_rust_feature)] // error: unknown feature
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0636"><a class="header" href="#error-code-e0636">Error code E0636</a></h1>
<p>A <code>#![feature]</code> attribute was declared multiple times.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0636"><span class="boring">#![allow(unused)]
</span>#![allow(stable_features)]
#![feature(rust1)]
#![feature(rust1)] // error: the feature `rust1` has already been declared
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0637"><a class="header" href="#error-code-e0637">Error code E0637</a></h1>
<p><code>'_</code> lifetime name or <code>&amp;T</code> without an explicit lifetime name has been used
on illegal place.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0106 E0637"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn underscore_lifetime&lt;'_&gt;(str1: &amp;'_ str, str2: &amp;'_ str) -&gt; &amp;'_ str {
                     //^^ `'_` is a reserved lifetime name
    if str1.len() &gt; str2.len() {
        str1
    } else {
        str2
    }
}

fn and_without_explicit_lifetime&lt;T&gt;()
where
    T: Into&lt;&amp;u32&gt;,
          //^ `&amp;` without an explicit lifetime name
{
}
<span class="boring">}</span></code></pre></pre>
<p>First, <code>'_</code> cannot be used as a lifetime identifier in some places
because it is a reserved for the anonymous lifetime. Second, <code>&amp;T</code>
without an explicit lifetime name cannot also be used in some places.
To fix them, use a lowercase letter such as <code>'a</code>, or a series
of lowercase letters such as <code>'foo</code>. For more information about lifetime
identifier, see <a href="https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols">the book</a>. For more information on using
the anonymous lifetime in Rust 2018, see <a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#more-lifetime-elision-rules">the Rust 2018 blog post</a>.</p>
<p>Corrected example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn underscore_lifetime&lt;'a&gt;(str1: &amp;'a str, str2: &amp;'a str) -&gt; &amp;'a str {
    if str1.len() &gt; str2.len() {
        str1
    } else {
        str2
    }
}

fn and_without_explicit_lifetime&lt;'foo, T&gt;()
where
    T: Into&lt;&amp;'foo u32&gt;,
{
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0638"><a class="header" href="#error-code-e0638">Error code E0638</a></h1>
<p>This error indicates that the struct, enum or enum variant must be matched
non-exhaustively as it has been marked as <code>non_exhaustive</code>.</p>
<p>When applied within a crate, downstream users of the crate will need to use the
<code>_</code> pattern when matching enums and use the <code>..</code> pattern when matching structs.
Downstream crates cannot match against non-exhaustive enum variants.</p>
<p>For example, in the below example, since the enum is marked as
<code>non_exhaustive</code>, it is required that downstream crates match non-exhaustively
on it.</p>
<pre><code class="language-rust ignore (pseudo-Rust)">#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

impl Display for Error {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // This will not error, despite being marked as non_exhaustive, as this
        // enum is defined within the current crate, it can be matched
        // exhaustively.
        let display = match self {
            Message(s) =&gt; s,
            Other =&gt; &quot;other or unknown error&quot;,
        };
        formatter.write_str(display)
    }
}</code></pre>
<p>An example of matching non-exhaustively on the above enum is provided below:</p>
<pre><code class="language-rust ignore (pseudo-Rust)">use mycrate::Error;

// This will not error as the non_exhaustive Error enum has been matched with a
// wildcard.
match error {
    Message(s) =&gt; ...,
    Other =&gt; ...,
    _ =&gt; ...,
}</code></pre>
<p>Similarly, for structs, match with <code>..</code> to avoid this error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0639"><a class="header" href="#error-code-e0639">Error code E0639</a></h1>
<p>This error indicates that the struct, enum or enum variant cannot be
instantiated from outside of the defining crate as it has been marked
as <code>non_exhaustive</code> and as such more fields/variants may be added in
future that could cause adverse side effects for this code.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (it only works cross-crate)">#[non_exhaustive]
pub struct NormalStruct {
    pub first_field: u16,
    pub second_field: u16,
}

let ns = NormalStruct { first_field: 640, second_field: 480 }; // error!</code></pre>
<p>It is recommended that you look for a <code>new</code> function or equivalent in the
crate's documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0640"><a class="header" href="#error-code-e0640">Error code E0640</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-1"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-1">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0641"><a class="header" href="#error-code-e0641">Error code E0641</a></h1>
<p>Attempted to cast to/from a pointer with an unknown kind.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0641"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = 0 as *const _; // error
<span class="boring">}</span></code></pre></pre>
<p>Type information must be provided if a pointer type being cast from/into another
type which cannot be inferred:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Creating a pointer from reference: type can be inferred
let a = &amp;(String::from(&quot;Hello world!&quot;)) as *const _; // ok!

let b = 0 as *const i32; // ok!

let c: *const i32 = 0 as *const _; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0642"><a class="header" href="#error-code-e0642">Error code E0642</a></h1>
<p>Trait methods currently cannot take patterns as arguments.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0642"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed
                                //        in trait methods
}
<span class="boring">}</span></code></pre></pre>
<p>You can instead use a single name for the argument:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(x_and_y: (i32, i32)); // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0643"><a class="header" href="#error-code-e0643">Error code E0643</a></h1>
<p>This error indicates that there is a mismatch between generic parameters and
impl Trait parameters in a trait declaration versus its impl.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0643"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, _: &amp;impl Iterator);
}
impl Foo for () {
    fn foo&lt;U: Iterator&gt;(&amp;self, _: &amp;U) { } // error method `foo` has incompatible
                                          // signature for trait
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0644"><a class="header" href="#error-code-e0644">Error code E0644</a></h1>
<p>A closure or generator was constructed that references its own type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0644">fn fix&lt;F&gt;(f: &amp;F)
  where F: Fn(&amp;F)
{
    f(&amp;f);
}

fn main() {
    fix(&amp;|y| {
        // Here, when `x` is called, the parameter `y` is equal to `x`.
    });
}</code></pre></pre>
<p>Rust does not permit a closure to directly reference its own type,
either through an argument (as in the example above) or by capturing
itself through its environment. This restriction helps keep closure
inference tractable.</p>
<p>The easiest fix is to rewrite your closure into a top-level function,
or into a method. In some cases, you may also be able to have your
closure call itself by capturing a <code>&amp;Fn()</code> object or <code>fn()</code> pointer
that refers to itself. That is permitting, since the closure would be
invoking itself via a virtual call, and hence does not directly
reference its own <em>type</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0646"><a class="header" href="#error-code-e0646">Error code E0646</a></h1>
<p>It is not possible to define <code>main</code> with a where clause.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0646">fn main() where i32: Copy { // error: main function is not allowed to have
                            // a where clause
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0647"><a class="header" href="#error-code-e0647">Error code E0647</a></h1>
<p>The <code>start</code> function was defined with a where clause.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0647"><span class="boring">#![allow(unused)]
</span>#![feature(start)]

<span class="boring">fn main() {
</span>#[start]
fn start(_: isize, _: *const *const u8) -&gt; isize where (): Copy {
    //^ error: start function is not allowed to have a where clause
    0
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0648"><a class="header" href="#error-code-e0648">Error code E0648</a></h1>
<p>An <code>export_name</code> attribute contains null characters (<code>\0</code>).</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0648"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name=&quot;\0foo&quot;] // error: `export_name` may not contain null characters
pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, remove the null characters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name=&quot;foo&quot;] // ok!
pub fn bar() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0657"><a class="header" href="#error-code-e0657">Error code E0657</a></h1>
<p>A lifetime bound on a trait implementation was captured at an incorrect place.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0657"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Id&lt;T&gt; {}
trait Lt&lt;'a&gt; {}

impl&lt;'a&gt; Lt&lt;'a&gt; for () {}
impl&lt;T&gt; Id&lt;T&gt; for T {}

fn free_fn_capture_hrtb_in_impl_trait()
    -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'a&gt;&gt;&gt; // error!
{
    Box::new(())
}

struct Foo;
impl Foo {
    fn impl_fn_capture_hrtb_in_impl_trait()
        -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'a&gt;&gt;&gt; // error!
    {
        Box::new(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, you have used the inappropriate lifetime in the <code>impl Trait</code>,
The <code>impl Trait</code> can only capture lifetimes bound at the fn or impl
level.</p>
<p>To fix this we have to define the lifetime at the function or impl
level and use that lifetime in the <code>impl Trait</code>. For example you can
define the lifetime at the function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Id&lt;T&gt; {}
trait Lt&lt;'a&gt; {}

impl&lt;'a&gt; Lt&lt;'a&gt; for () {}
impl&lt;T&gt; Id&lt;T&gt; for T {}

fn free_fn_capture_hrtb_in_impl_trait&lt;'b&gt;()
    -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'b&gt;&gt;&gt; // ok!
{
    Box::new(())
}

struct Foo;
impl Foo {
    fn impl_fn_capture_hrtb_in_impl_trait&lt;'b&gt;()
        -&gt; Box&lt;for&lt;'a&gt; Id&lt;impl Lt&lt;'b&gt;&gt;&gt; // ok!
    {
        Box::new(())
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0658"><a class="header" href="#error-code-e0658">Error code E0658</a></h1>
<p>An unstable feature was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0658"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u128)] // error: use of unstable library feature 'repr128'
enum Foo {
    Bar(u64),
}
<span class="boring">}</span></code></pre></pre>
<p>If you're using a stable or a beta version of rustc, you won't be able to use
any unstable features. In order to do so, please switch to a nightly version of
rustc (by using <a href="https://rust-lang.github.io/rustup/concepts/channels.html">rustup</a>).</p>
<p>If you're using a nightly version of rustc, just add the corresponding feature
to be able to use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr128)]

<span class="boring">fn main() {
</span>#[repr(u128)] // ok!
enum Foo {
    Bar(u64),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0659"><a class="header" href="#error-code-e0659">Error code E0659</a></h1>
<p>An item usage is ambiguous.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018 E0659">pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use crate::moon::*;
    pub use crate::earth::*;
}

fn main() {
    crate::collider::foo(); // ERROR: `foo` is ambiguous
}</code></pre></pre>
<p>This error generally appears when two items with the same name are imported into
a module. Here, the <code>foo</code> functions are imported and reexported from the
<code>collider</code> module and therefore, when we're using <code>collider::foo()</code>, both
functions collide.</p>
<p>To solve this error, the best solution is generally to keep the path before the
item when using it. Example:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod moon {
    pub fn foo() {}
}

pub mod earth {
    pub fn foo() {}
}

mod collider {
    pub use crate::moon;
    pub use crate::earth;
}

fn main() {
    crate::collider::moon::foo(); // ok!
    crate::collider::earth::foo(); // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0660"><a class="header" href="#error-code-e0660">Error code E0660</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-56"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-56">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The argument to the <code>llvm_asm</code> macro is not well-formed.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">llvm_asm!(&quot;nop&quot; &quot;nop&quot;);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0661"><a class="header" href="#error-code-e0661">Error code E0661</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-57"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-57">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An invalid syntax was passed to the second argument of an <code>llvm_asm</code> macro line.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">let a;
llvm_asm!(&quot;nop&quot; : &quot;r&quot;(a));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0662"><a class="header" href="#error-code-e0662">Error code E0662</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-58"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-58">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An invalid input operand constraint was passed to the <code>llvm_asm</code> macro
(third line).</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">llvm_asm!(&quot;xor %eax, %eax&quot;
          :
          : &quot;=test&quot;(&quot;a&quot;)
         );</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0663"><a class="header" href="#error-code-e0663">Error code E0663</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-59"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-59">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>An invalid input operand constraint was passed to the <code>llvm_asm</code> macro
(third line).</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">llvm_asm!(&quot;xor %eax, %eax&quot;
          :
          : &quot;+test&quot;(&quot;a&quot;)
         );</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0664"><a class="header" href="#error-code-e0664">Error code E0664</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-60"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-60">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A clobber was surrounded by braces in the <code>llvm_asm</code> macro.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">llvm_asm!(&quot;mov $$0x200, %eax&quot;
          :
          :
          : &quot;{eax}&quot;
         );</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0665"><a class="header" href="#error-code-e0665">Error code E0665</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-61"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-61">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>The <code>Default</code> trait was derived on an enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
enum Food {
    Sweet,
    Salty,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Default</code> cannot be derived on an enum for the simple reason that the
compiler doesn't know which value to pick by default whereas it can for a
struct as long as all its fields implement the <code>Default</code> trait as well.</p>
<p>If you still want to implement <code>Default</code> on your enum, you'll have to do it &quot;by
hand&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Food {
    Sweet,
    Salty,
}

impl Default for Food {
    fn default() -&gt; Food {
        Food::Sweet
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0666"><a class="header" href="#error-code-e0666">Error code E0666</a></h1>
<p><code>impl Trait</code> types cannot appear nested in the generic arguments of other
<code>impl Trait</code> types.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0666"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyGenericTrait&lt;T&gt; {}
trait MyInnerTrait {}

fn foo(
    bar: impl MyGenericTrait&lt;impl MyInnerTrait&gt;, // error!
) {}
<span class="boring">}</span></code></pre></pre>
<p>Type parameters for <code>impl Trait</code> types must be explicitly defined as named
generic parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyGenericTrait&lt;T&gt; {}
trait MyInnerTrait {}

fn foo&lt;T: MyInnerTrait&gt;(
    bar: impl MyGenericTrait&lt;T&gt;, // ok!
) {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0667"><a class="header" href="#error-code-e0667">Error code E0667</a></h1>
<p><code>impl Trait</code> is not allowed in path parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0667"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_fn(mut x: impl Iterator) -&gt; &lt;impl Iterator&gt;::Item { // error!
    x.next().unwrap()
}
<span class="boring">}</span></code></pre></pre>
<p>You cannot use <code>impl Trait</code> in path parameters. If you want something
equivalent, you can do this instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_fn&lt;T: Iterator&gt;(mut x: T) -&gt; T::Item { // ok!
    x.next().unwrap()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0668"><a class="header" href="#error-code-e0668">Error code E0668</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-62"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-62">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Malformed inline assembly rejected by LLVM.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#![feature(llvm_asm)]

fn main() {
    let rax: u64;
    unsafe {
        llvm_asm!(&quot;&quot; :&quot;={rax&quot;(rax));
        println!(&quot;Accumulator is: {}&quot;, rax);
    }
}</code></pre>
<p>LLVM checks the validity of the constraints and the assembly string passed to
it. This error implies that LLVM seems something wrong with the inline
assembly call.</p>
<p>In particular, it can happen if you forgot the closing bracket of a register
constraint (see issue #51430), like in the previous code example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0669"><a class="header" href="#error-code-e0669">Error code E0669</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-63"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-63">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Cannot convert inline assembly operand to a single LLVM value.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (no longer emitted)">#![feature(llvm_asm)]

fn main() {
    unsafe {
        llvm_asm!(&quot;&quot; :: &quot;r&quot;(&quot;&quot;)); // error!
    }
}</code></pre>
<p>This error usually happens when trying to pass in a value to an input inline
assembly operand that is actually a pair of values. In particular, this can
happen when trying to pass in a slice, for instance a <code>&amp;str</code>. In Rust, these
values are represented internally as a pair of values, the pointer and its
length. When passed as an input operand, this pair of values can not be
coerced into a register and thus we must fail with an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0670"><a class="header" href="#error-code-e0670">Error code E0670</a></h1>
<p>Rust 2015 does not permit the use of <code>async fn</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0670"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>Switch to the Rust 2018 edition to use <code>async fn</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0671"><a class="header" href="#error-code-e0671">Error code E0671</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-64"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-64">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Const parameters cannot depend on type parameters.
The following is therefore invalid:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0770"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn const_id&lt;T, const N: T&gt;() -&gt; T { // error
    N
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0687"><a class="header" href="#error-code-e0687">Error code E0687</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-65"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-65">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In-band lifetimes cannot be used in <code>fn</code>/<code>Fn</code> syntax.</p>
<p>Erroneous code examples:</p>
<pre><code class="language-rust ignore (feature got removed)">#![feature(in_band_lifetimes)]

fn foo(x: fn(&amp;'a u32)) {} // error!

fn bar(x: &amp;Fn(&amp;'a u32)) {} // error!

fn baz(x: fn(&amp;'a u32), y: &amp;'a u32) {} // error!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl Foo&lt;'a&gt; {
    fn bar(&amp;self, x: fn(&amp;'a u32)) {} // error!
}</code></pre>
<p>Lifetimes used in <code>fn</code> or <code>Fn</code> syntax must be explicitly
declared using <code>&lt;...&gt;</code> binders. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: fn(&amp;'a u32)) {} // ok!

fn bar&lt;'a&gt;(x: &amp;Fn(&amp;'a u32)) {} // ok!

fn baz&lt;'a&gt;(x: fn(&amp;'a u32), y: &amp;'a u32) {} // ok!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn bar(&amp;self, x: fn(&amp;'a u32)) {} // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0688"><a class="header" href="#error-code-e0688">Error code E0688</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-66"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-66">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>In-band lifetimes were mixed with explicit lifetime binders.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (feature got removed)">#![feature(in_band_lifetimes)]

fn foo&lt;'a&gt;(x: &amp;'a u32, y: &amp;'b u32) {}   // error!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl Foo&lt;'a&gt; {
    fn bar&lt;'b&gt;(x: &amp;'a u32, y: &amp;'b u32, z: &amp;'c u32) {}   // error!
}

impl&lt;'b&gt; Foo&lt;'a&gt; {  // error!
    fn baz() {}
}</code></pre>
<p>In-band lifetimes cannot be mixed with explicit lifetime binders.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) {}   // ok!

struct Foo&lt;'a&gt; { x: &amp;'a u32 }

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn bar&lt;'b,'c&gt;(x: &amp;'a u32, y: &amp;'b u32, z: &amp;'c u32) {}    // ok!
}

impl&lt;'a&gt; Foo&lt;'a&gt; {  // ok!
    fn baz() {}
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0689"><a class="header" href="#error-code-e0689">Error code E0689</a></h1>
<p>A method was called on an ambiguous numeric type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0689"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>2.0.neg(); // error!
<span class="boring">}</span></code></pre></pre>
<p>This error indicates that the numeric value for the method being passed exists
but the type of the numeric value or binding could not be identified.</p>
<p>The error happens on numeric literals and on numeric bindings without an
identified concrete type:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0689"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2.0;
x.neg();  // same error as above
<span class="boring">}</span></code></pre></pre>
<p>Because of this, you must give the numeric literal or binding a type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Neg;

let _ = 2.0_f32.neg(); // ok!
let x: f32 = 2.0;
let _ = x.neg(); // ok!
let _ = (2.0 as f32).neg(); // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0690"><a class="header" href="#error-code-e0690">Error code E0690</a></h1>
<p>A struct with the representation hint <code>repr(transparent)</code> had two or more fields
that were not guaranteed to be zero-sized.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0690"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; { // error: transparent struct needs at most one
    value: f32,            //        non-zero-sized field, but has 2
    unit: U,
}
<span class="boring">}</span></code></pre></pre>
<p>Because transparent structs are represented exactly like one of their fields at
run time, said field must be uniquely determined. If there are multiple fields,
it is not clear how the struct should be represented.
Note that fields of zero-sized types (e.g., <code>PhantomData</code>) can also exist
alongside the field that contains the actual data, they do not count for this
error. When generic types are involved (as in the above example), an error is
reported because the type parameter could be non-zero-sized.</p>
<p>To combine <code>repr(transparent)</code> with type parameters, <code>PhantomData</code> may be
useful:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;

#[repr(transparent)]
struct LengthWithUnit&lt;U&gt; {
    value: f32,
    unit: PhantomData&lt;U&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0691"><a class="header" href="#error-code-e0691">Error code E0691</a></h1>
<p>A struct, enum, or union with the <code>repr(transparent)</code> representation hint
contains a zero-sized field that requires non-trivial alignment.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0691"><span class="boring">#![allow(unused)]
</span>#![feature(repr_align)]

<span class="boring">fn main() {
</span>#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent
                                   //        struct has alignment larger than 1
<span class="boring">}</span></code></pre></pre>
<p>A transparent struct, enum, or union is supposed to be represented exactly like
the piece of data it contains. Zero-sized fields with different alignment
requirements potentially conflict with this property. In the example above,
<code>Wrapper</code> would have to be aligned to 32 bytes even though <code>f32</code> has a smaller
alignment requirement.</p>
<p>Consider removing the over-aligned zero-sized field:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
struct Wrapper(f32);
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, <code>PhantomData&lt;T&gt;</code> has alignment 1 for all <code>T</code>, so you can use it
if you need to keep the field for some reason:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(repr_align)]

<span class="boring">fn main() {
</span>use std::marker::PhantomData;

#[repr(align(32))]
struct ForceAlign32;

#[repr(transparent)]
struct Wrapper(f32, PhantomData&lt;ForceAlign32&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Note that empty arrays <code>[T; 0]</code> have the same alignment requirement as the
element type <code>T</code>. Also note that the error is conservatively reported even when
the alignment of the zero-sized type is less than or equal to the data field's
alignment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0692"><a class="header" href="#error-code-e0692">Error code E0692</a></h1>
<p>A <code>repr(transparent)</code> type was also annotated with other, incompatible
representation hints.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0692"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent, C)] // error: incompatible representation hints
struct Grams(f32);
<span class="boring">}</span></code></pre></pre>
<p>A type annotated as <code>repr(transparent)</code> delegates all representation concerns to
another type, so adding more representation hints is contradictory. Remove
either the <code>transparent</code> hint or the other hints, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
struct Grams(f32);
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, move the other attributes to the contained type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Foo {
    x: i32,
    // ...
}

#[repr(transparent)]
struct FooWrapper(Foo);
<span class="boring">}</span></code></pre></pre>
<p>Note that introducing another <code>struct</code> just to have a place for the other
attributes may have unintended side effects on the representation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
struct Grams(f32);

#[repr(C)]
struct Float(f32);

#[repr(transparent)]
struct Grams2(Float); // this is not equivalent to `Grams` above
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>Grams2</code> is a not equivalent to <code>Grams</code> -- the former transparently wraps
a (non-transparent) struct containing a single float, while <code>Grams</code> is a
transparent wrapper around a float. This can make a difference for the ABI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0693"><a class="header" href="#error-code-e0693">Error code E0693</a></h1>
<p><code>align</code> representation hint was incorrectly declared.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0693"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align=8)] // error!
struct Align8(i8);

#[repr(align=&quot;8&quot;)] // error!
struct Align8(i8);
<span class="boring">}</span></code></pre></pre>
<p>This is a syntax error at the level of attribute declarations. The proper
syntax for <code>align</code> representation hint is the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(align(8))] // ok!
struct Align8(i8);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0695"><a class="header" href="#error-code-e0695">Error code E0695</a></h1>
<p>A <code>break</code> statement without a label appeared inside a labeled block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0695"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    'a: {
        break;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Make sure to always label the <code>break</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'l: loop {
    'a: {
        break 'l;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or if you want to <code>break</code> the labeled block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    'a: {
        break 'a;
    }
    break;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0696"><a class="header" href="#error-code-e0696">Error code E0696</a></h1>
<p>A function is using <code>continue</code> keyword incorrectly.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0696"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn continue_simple() {
    'b: {
        continue; // error!
    }
}
fn continue_labeled() {
    'b: {
        continue 'b; // error!
    }
}
fn continue_crossing() {
    loop {
        'b: {
            continue; // error!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we have used the <code>continue</code> keyword incorrectly. As we
have seen above that <code>continue</code> pointing to a labeled block.</p>
<p>To fix this we have to use the labeled block properly.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn continue_simple() {
    'b: loop {
        continue ; // ok!
    }
}
fn continue_labeled() {
    'b: loop {
        continue 'b; // ok!
    }
}
fn continue_crossing() {
    loop {
        'b: loop {
            continue; // ok!
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0697"><a class="header" href="#error-code-e0697">Error code E0697</a></h1>
<p>A closure has been used as <code>static</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0697">fn main() {
    static || {}; // used as `static`
}</code></pre></pre>
<p>Closures cannot be used as <code>static</code>. They &quot;save&quot; the environment,
and as such a static closure would save only a static environment
which would consist only of variables with a static lifetime. Given
this it would be better to use a proper function. The easiest fix
is to remove the <code>static</code> keyword.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0698"><a class="header" href="#error-code-e0698">Error code E0698</a></h1>
<p>When using generators (or async) all type variables must be bound so a
generator can be constructed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust edition2018 compile_fail E0698"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
    bar().await; // error: cannot infer type for `T`
}
<span class="boring">}</span></code></pre></pre>
<p>In the above example <code>T</code> is unknowable by the compiler.
To fix this you must bind <code>T</code> to a concrete type such as <code>String</code>
so that a generator can then be constructed:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn bar&lt;T&gt;() -&gt; () {}

async fn foo() {
    bar::&lt;String&gt;().await;
    //   ^^^^^^^^ specify type explicitly
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0699"><a class="header" href="#error-code-e0699">Error code E0699</a></h1>
<p>A method was called on a raw pointer whose inner type wasn't completely known.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018 E0699"><span class="boring">#![deny(warnings)]
</span><span class="boring">fn main() {
</span>let foo = &amp;1;
let bar = foo as *const _;
if bar.is_null() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the type of <code>bar</code> isn't known; it could be a pointer to anything. Instead,
specify a type for the pointer (preferably something that makes sense for the
thing you're pointing to):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = &amp;1;
let bar = foo as *const i32;
if bar.is_null() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Even though <code>is_null()</code> exists as a method on any raw pointer, Rust shows this
error because  Rust allows for <code>self</code> to have arbitrary types (behind the
arbitrary_self_types feature flag).</p>
<p>This means that someone can specify such a function:</p>
<pre><code class="language-rust ignore (cannot-doctest-feature-doesnt-exist-yet)">impl Foo {
    fn is_null(self: *const Self) -&gt; bool {
        // do something else
    }
}</code></pre>
<p>and now when you call <code>.is_null()</code> on a raw pointer to <code>Foo</code>, there's ambiguity.</p>
<p>Given that we don't know what type the pointer is, and there's potential
ambiguity for some types, we disallow calling methods on raw pointers when
the type is unknown.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0700"><a class="header" href="#error-code-e0700">Error code E0700</a></h1>
<p>The <code>impl Trait</code> return type captures lifetime parameters that do not
appear within the <code>impl Trait</code> itself.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0700"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a, 'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt;
where 'x: 'y
{
    x
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the function <code>foo</code> returns a value of type <code>Cell&lt;&amp;'x u32&gt;</code>,
which references the lifetime <code>'x</code>. However, the return type is
declared as <code>impl Trait&lt;'y&gt;</code> -- this indicates that <code>foo</code> returns
&quot;some type that implements <code>Trait&lt;'y&gt;</code>&quot;, but it also indicates that
the return type <strong>only captures data referencing the lifetime <code>'y</code></strong>.
In this case, though, we are referencing data with lifetime <code>'x</code>, so
this function is in error.</p>
<p>To fix this, you must reference the lifetime <code>'x</code> from the return
type. For example, changing the return type to <code>impl Trait&lt;'y&gt; + 'x</code>
would work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

trait Trait&lt;'a&gt; { }

impl&lt;'a,'b&gt; Trait&lt;'b&gt; for Cell&lt;&amp;'a u32&gt; { }

fn foo&lt;'x, 'y&gt;(x: Cell&lt;&amp;'x u32&gt;) -&gt; impl Trait&lt;'y&gt; + 'x
where 'x: 'y
{
    x
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0701"><a class="header" href="#error-code-e0701">Error code E0701</a></h1>
<p>This error indicates that a <code>#[non_exhaustive]</code> attribute was incorrectly placed
on something other than a struct or enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0701"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
trait Foo { }
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0703"><a class="header" href="#error-code-e0703">Error code E0703</a></h1>
<p>Invalid ABI (Application Binary Interface) used in the code.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0703">extern &quot;invalid&quot; fn foo() {} // error!
<span class="boring">fn main() {}</span></code></pre></pre>
<p>At present few predefined ABI's (like Rust, C, system, etc.) can be
used in Rust. Verify that the ABI is predefined. For example you can
replace the given ABI from 'Rust'.</p>
<pre><pre class="playground"><code class="language-rust">extern &quot;Rust&quot; fn foo() {} // ok!
<span class="boring">fn main() { }</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0704"><a class="header" href="#error-code-e0704">Error code E0704</a></h1>
<p>An incorrect visibility restriction was specified.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0704"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod foo {
    pub(foo) struct Bar {
        x: i32
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To make struct <code>Bar</code> only visible in module <code>foo</code> the <code>in</code> keyword should be
used:</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    pub(in crate::foo) struct Bar {
        x: i32
    }
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>For more information see the Rust Reference on <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">Visibility</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0705"><a class="header" href="#error-code-e0705">Error code E0705</a></h1>
<p>A <code>#![feature]</code> attribute was declared for a feature that is stable in the
current edition, but not in all editions.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust2018 compile_fail E0705"><span class="boring">#![allow(unused)]
</span>#![feature(rust_2018_preview)]
#![feature(test_2018_feature)] // error: the feature
<span class="boring">fn main() {
</span>                               // `test_2018_feature` is
                               // included in the Rust 2018 edition
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0706"><a class="header" href="#error-code-e0706">Error code E0706</a></h1>
<p><code>async fn</code>s are not yet supported in traits in Rust.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    // Neither case is currently supported.
    async fn foo() {}
    async fn bar(&amp;self) {}
}
<span class="boring">}</span></code></pre></pre>
<p><code>async fn</code>s return an <code>impl Future</code>, making the following two examples
equivalent:</p>
<pre><code class="language-rust edition2018 ignore (example-of-desugaring-equivalence)">async fn foo() -&gt; User {
    unimplemented!()
}
// The async fn above gets desugared as follows:
fn foo(&amp;self) -&gt; impl Future&lt;Output = User&gt; + '_ {
    unimplemented!()
}</code></pre>
<p>But when it comes to supporting this in traits, there are <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">a few implementation
issues</a>. One of them is returning <code>impl Trait</code> in traits is not
supported, as it would require <a href="https://github.com/rust-lang/rust/issues/44265">Generic Associated Types</a> to be supported:</p>
<pre><code class="language-rust edition2018 ignore (example-of-desugaring-equivalence)">impl MyDatabase {
    async fn get_user(&amp;self) -&gt; User {
        unimplemented!()
    }
}

impl MyDatabase {
    fn get_user(&amp;self) -&gt; impl Future&lt;Output = User&gt; + '_ {
        unimplemented!()
    }
}</code></pre>
<p>Until these issues are resolved, you can use the <a href="https://crates.io/crates/async-trait"><code>async-trait</code> crate</a>, allowing
you to use <code>async fn</code> in traits by desugaring to &quot;boxed futures&quot;
(<code>Pin&lt;Box&lt;dyn Future + Send + 'async&gt;&gt;</code>).</p>
<p>Note that using these trait methods will result in a heap allocation
per-function-call. This is not a significant cost for the vast majority of
applications, but should be considered when deciding whether to use this
functionality in the public API of a low-level function that is expected to be
called millions of times a second.</p>
<p>You might be interested in visiting the <a href="https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html">async book</a> for further information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0708"><a class="header" href="#error-code-e0708">Error code E0708</a></h1>
<p><code>async</code> non-<code>move</code> closures with parameters are currently not supported.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018 E0708">#![feature(async_closure)]

fn main() {
    let add_one = async |num: u8| { // error!
        num + 1
    };
}</code></pre></pre>
<p><code>async</code> with non-move is currently not supported with the current
version, you can use successfully by using move:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![feature(async_closure)]

fn main() {
    let add_one = async move |num: u8| { // ok!
        num + 1
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0710"><a class="header" href="#error-code-e0710">Error code E0710</a></h1>
<p>An unknown tool name was found in a scoped lint.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0710">#[allow(clipp::filter_map)] // error!
fn main() {
    // business logic
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust compile_fail E0710">#[warn(clipp::filter_map)] // error!
fn main() {
    // business logic
}</code></pre></pre>
<p>Please verify you didn't misspell the tool's name or that you didn't
forget to import it in you project:</p>
<pre><pre class="playground"><code class="language-rust">#[allow(clippy::filter_map)] // ok!
fn main() {
    // business logic
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[warn(clippy::filter_map)] // ok!
fn main() {
    // business logic
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0712"><a class="header" href="#error-code-e0712">Error code E0712</a></h1>
<p>A borrow of a thread-local variable was made inside a function which outlived
the lifetime of the function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0712">#![feature(thread_local)]

#[thread_local]
static FOO: u8 = 3;

fn main() {
    let a = &amp;FOO; // error: thread-local variable borrowed past end of function

    std::thread::spawn(move || {
        println!(&quot;{}&quot;, a);
    });
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0713"><a class="header" href="#error-code-e0713">Error code E0713</a></h1>
<p>This error occurs when an attempt is made to borrow state past the end of the
lifetime of a type that implements the <code>Drop</code> trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0713"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str(&quot;being dropped&quot;); }
}

fn demo&lt;'a&gt;(s: S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *s.data; p }
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>demo</code> tries to borrow the string data held within its
argument <code>s</code> and then return that borrow. However, <code>S</code> is
declared as implementing <code>Drop</code>.</p>
<p>Structs implementing the <code>Drop</code> trait have an implicit destructor that
gets called when they go out of scope. This destructor gets exclusive
access to the fields of the struct when it runs.</p>
<p>This means that when <code>s</code> reaches the end of <code>demo</code>, its destructor
gets exclusive access to its <code>&amp;mut</code>-borrowed string data. allowing
another borrow of that string data (<code>p</code>), to exist across the drop of
<code>s</code> would be a violation of the principle that <code>&amp;mut</code>-borrows have
exclusive, unaliased access to their referenced data.</p>
<p>This error can be fixed by changing <code>demo</code> so that the destructor does
not run while the string-data is borrowed; for example by taking <code>S</code>
by reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S&lt;'a&gt; { data: &amp;'a mut String }

impl&lt;'a&gt; Drop for S&lt;'a&gt; {
    fn drop(&amp;mut self) { self.data.push_str(&quot;being dropped&quot;); }
}

fn demo&lt;'a&gt;(s: &amp;'a mut S&lt;'a&gt;) -&gt; &amp;'a mut String { let p = &amp;mut *(*s).data; p }
<span class="boring">}</span></code></pre></pre>
<p>Note that this approach needs a reference to S with lifetime <code>'a</code>.
Nothing shorter than <code>'a</code> will suffice: a shorter lifetime would imply
that after <code>demo</code> finishes executing, something else (such as the
destructor!) could access <code>s.data</code> after the end of that shorter
lifetime, which would again violate the <code>&amp;mut</code>-borrow's exclusive
access.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0714"><a class="header" href="#error-code-e0714">Error code E0714</a></h1>
<p>A <code>#[marker]</code> trait contained an associated item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0714">#![feature(marker_trait_attr)]
#![feature(associated_type_defaults)]

#[marker]
trait MarkerConst {
    const N: usize; // error!
}

fn main() {}</code></pre></pre>
<p>The items of marker traits cannot be overridden, so there's no need to have them
when they cannot be changed per-type anyway. If you wanted them for ergonomic
reasons, consider making an extension trait instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0715"><a class="header" href="#error-code-e0715">Error code E0715</a></h1>
<p>An <code>impl</code> for a <code>#[marker]</code> trait tried to override an associated item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0715">#![feature(marker_trait_attr)]

#[marker]
trait Marker {
    const N: usize = 0;
    fn do_something() {}
}

struct OverrideConst;
impl Marker for OverrideConst { // error!
    const N: usize = 1;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Because marker traits are allowed to have multiple implementations for the same
type, it's not allowed to override anything in those implementations, as it
would be ambiguous which override should actually be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0716"><a class="header" href="#error-code-e0716">Error code E0716</a></h1>
<p>A temporary value is being dropped while a borrow is still in active use.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0716"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let p = bar(&amp;foo());
         // ------ creates a temporary
let q = *p;
<span class="boring">}</span></code></pre></pre>
<p>Here, the expression <code>&amp;foo()</code> is borrowing the expression <code>foo()</code>. As <code>foo()</code> is
a call to a function, and not the name of a variable, this creates a
<strong>temporary</strong> -- that temporary stores the return value from <code>foo()</code> so that it
can be borrowed. You could imagine that <code>let p = bar(&amp;foo());</code> is equivalent to
the following, which uses an explicit temporary variable.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo() -&gt; i32 { 22 }
</span><span class="boring">fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
</span>let p = {
  let tmp = foo(); // the temporary
  bar(&amp;tmp) // error: `tmp` does not live long enough
}; // &lt;-- tmp is freed as we exit this block
let q = p;
<span class="boring">}</span></code></pre></pre>
<p>Whenever a temporary is created, it is automatically dropped (freed) according
to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing
statement -- in this case, after the <code>let</code>. This is illustrated in the example
above by showing that <code>tmp</code> would be freed as we exit the block.</p>
<p>To fix this problem, you need to create a local variable to store the value in
rather than relying on a temporary. For example, you might change the original
program to the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = foo(); // dropped at the end of the enclosing block
let p = bar(&amp;value);
let q = *p;
<span class="boring">}</span></code></pre></pre>
<p>By introducing the explicit <code>let value</code>, we allocate storage that will last
until the end of the enclosing block (when <code>value</code> goes out of scope). When we
borrow <code>&amp;value</code>, we are borrowing a local variable that already exists, and
hence no temporary is created.</p>
<p>Temporaries are not always dropped at the end of the enclosing statement. In
simple cases where the <code>&amp;</code> expression is immediately stored into a variable, the
compiler will automatically extend the lifetime of the temporary until the end
of the enclosing block. Therefore, an alternative way to fix the original
program is to write <code>let tmp = &amp;foo()</code> and not <code>let tmp = foo()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = &amp;foo();
let p = bar(value);
let q = *p;
<span class="boring">}</span></code></pre></pre>
<p>Here, we are still borrowing <code>foo()</code>, but as the borrow is assigned directly
into a variable, the temporary will not be dropped until the end of the
enclosing block. Similar rules apply when temporaries are stored into aggregate
structures like a tuple or struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Here, two temporaries are created, but
// as they are stored directly into `value`,
// they are not dropped until the end of the
// enclosing block.
fn foo() -&gt; i32 { 22 }
let value = (&amp;foo(), &amp;foo());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0711"><a class="header" href="#error-code-e0711">Error code E0711</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-2"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-2">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<p>Feature declared with conflicting stability requirements.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0711"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: this attribute is perma-unstable and should *never* be used outside of
//       stdlib and the compiler.
#![feature(staged_api)]

#![stable(feature = &quot;...&quot;, since = &quot;1.0.0&quot;)]

#[stable(feature = &quot;foo&quot;, since = &quot;1.0.0&quot;)]
fn foo_stable_1_0_0() {}

// error: feature `foo` is declared stable since 1.29.0
#[stable(feature = &quot;foo&quot;, since = &quot;1.29.0&quot;)]
fn foo_stable_1_29_0() {}

// error: feature `foo` is declared unstable
#[unstable(feature = &quot;foo&quot;, issue = &quot;none&quot;)]
fn foo_unstable() {}
<span class="boring">}</span></code></pre></pre>
<p>In the above example, the <code>foo</code> feature is first defined to be stable since
1.0.0, but is then re-declared stable since 1.29.0. This discrepancy in
versions causes an error. Furthermore, <code>foo</code> is then re-declared as unstable,
again the conflict causes an error.</p>
<p>This error can be fixed by splitting the feature, this allows any
stability requirements and removes any possibility of conflict.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0717"><a class="header" href="#error-code-e0717">Error code E0717</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-3"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-3">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0718"><a class="header" href="#error-code-e0718">Error code E0718</a></h1>
<p>A <code>#[lang = &quot;..&quot;]</code> attribute was placed on the wrong item type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0718"><span class="boring">#![allow(unused)]
</span>#![feature(lang_items)]

<span class="boring">fn main() {
</span>#[lang = &quot;owned_box&quot;]
static X: u32 = 42;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0719"><a class="header" href="#error-code-e0719">Error code E0719</a></h1>
<p>An associated type value was specified more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0719"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_bounds)]

<span class="boring">fn main() {
</span>trait FooTrait {}
trait BarTrait {}

// error: associated type `Item` in trait `Iterator` is specified twice
struct Foo&lt;T: Iterator&lt;Item: FooTrait, Item: BarTrait&gt;&gt; { f: T }
<span class="boring">}</span></code></pre></pre>
<p><code>Item</code> in trait <code>Iterator</code> cannot be specified multiple times for struct <code>Foo</code>.
To fix this, create a new trait that is a combination of the desired traits and
specify the associated type with the new trait.</p>
<p>Corrected example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(associated_type_bounds)]

<span class="boring">fn main() {
</span>trait FooTrait {}
trait BarTrait {}
trait FooBarTrait: FooTrait + BarTrait {}

struct Foo&lt;T: Iterator&lt;Item: FooBarTrait&gt;&gt; { f: T } // ok!
<span class="boring">}</span></code></pre></pre>
<p>For more information about associated types, see <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">the book</a>. For more
information on associated type bounds, see <a href="https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html">RFC 2289</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0720"><a class="header" href="#error-code-e0720">Error code E0720</a></h1>
<p>An <code>impl Trait</code> type expands to a recursive type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0720"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_recursive_type() -&gt; impl Sized {
    [make_recursive_type(), make_recursive_type()]
}
<span class="boring">}</span></code></pre></pre>
<p>An <code>impl Trait</code> type must be expandable to a concrete type that contains no
<code>impl Trait</code> types. For example the previous example tries to create an
<code>impl Trait</code> type <code>T</code> that is equal to <code>[T, T]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0722"><a class="header" href="#error-code-e0722">Error code E0722</a></h1>
<p>The <code>optimize</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0722"><span class="boring">#![allow(unused)]
</span>#![feature(optimize_attribute)]

<span class="boring">fn main() {
</span>#[optimize(something)] // error: invalid argument
pub fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>The <code>#[optimize]</code> attribute should be used as follows:</p>
<ul>
<li>
<p><code>#[optimize(size)]</code> -- instructs the optimization pipeline to generate code
that's smaller rather than faster</p>
</li>
<li>
<p><code>#[optimize(speed)]</code> -- instructs the optimization pipeline to generate code
that's faster rather than smaller</p>
</li>
</ul>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(optimize_attribute)]

<span class="boring">fn main() {
</span>#[optimize(size)]
pub fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="https://rust-lang.github.io/rfcs/2412-optimize-attr.html">RFC 2412</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0724"><a class="header" href="#error-code-e0724">Error code E0724</a></h1>
<p><code>#[ffi_returns_twice]</code> was used on something other than a foreign function
declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0724"><span class="boring">#![allow(unused)]
</span>#![feature(ffi_returns_twice)]
#![crate_type = &quot;lib&quot;]

<span class="boring">fn main() {
</span>#[ffi_returns_twice] // error!
pub fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p><code>#[ffi_returns_twice]</code> can only be used on foreign function declarations.
For example, we might correct the previous example by declaring
the function inside of an <code>extern</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(ffi_returns_twice)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
   #[ffi_returns_twice] // ok!
   pub fn foo();
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0725"><a class="header" href="#error-code-e0725">Error code E0725</a></h1>
<p>A feature attribute named a feature that was disallowed in the compiler
command line flags.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (can't specify compiler flags from doctests)">#![feature(never_type)] // error: the feature `never_type` is not in
                        // the list of allowed features</code></pre>
<p>Delete the offending feature attribute, or add it to the list of allowed
features in the <code>-Z allow_features</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0726"><a class="header" href="#error-code-e0726">Error code E0726</a></h1>
<p>An argument lifetime was elided in an async function.</p>
<p>Erroneous code example:</p>
<p>When a struct or a type is bound/declared with a lifetime it is important for
the Rust compiler to know, on usage, the lifespan of the type. When the
lifetime is not explicitly mentioned and the Rust Compiler cannot determine
the lifetime of your type, the following error occurs.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0726"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::executor::block_on;
struct Content&lt;'a&gt; {
    title: &amp;'a str,
    body: &amp;'a str,
}
async fn create(content: Content) { // error: implicit elided
                                    // lifetime not allowed here
    println!(&quot;title: {}&quot;, content.title);
    println!(&quot;body: {}&quot;, content.body);
}
let content = Content { title: &quot;Rust&quot;, body: &quot;is great!&quot; };
let future = create(content);
block_on(future);
<span class="boring">}</span></code></pre></pre>
<p>Specify desired lifetime of parameter <code>content</code> or indicate the anonymous
lifetime like <code>content: Content&lt;'_&gt;</code>. The anonymous lifetime tells the Rust
compiler that <code>content</code> is only needed until the <code>create</code> function is done with
its execution.</p>
<p>The <code>implicit elision</code> meaning the omission of suggested lifetime that is
<code>pub async fn create&lt;'a&gt;(content: Content&lt;'a&gt;) {}</code> is not allowed here as
lifetime of the <code>content</code> can differ from current context:</p>
<pre><code class="language-rust ignore (needs futures dependency)">async fn create(content: Content&lt;'_&gt;) { // ok!
    println!(&quot;title: {}&quot;, content.title);
    println!(&quot;body: {}&quot;, content.body);
}</code></pre>
<p>Know more about lifetime elision in this <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">chapter</a> and a
chapter on lifetimes can be found <a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0727"><a class="header" href="#error-code-e0727">Error code E0727</a></h1>
<p>A <code>yield</code> clause was used in an <code>async</code> context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0727 edition2018">#![feature(generators)]

fn main() {
    let generator = || {
        async {
            yield;
        }
    };
}</code></pre></pre>
<p>Here, the <code>yield</code> keyword is used in an <code>async</code> block,
which is not yet supported.</p>
<p>To fix this error, you have to move <code>yield</code> out of the <code>async</code> block:</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![feature(generators)]

fn main() {
    let generator = || {
        yield;
    };
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0728"><a class="header" href="#error-code-e0728">Error code E0728</a></h1>
<p><a href="https://doc.rust-lang.org/std/keyword.await.html"><code>await</code></a> has been used outside <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> function or <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> block.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust edition2018 compile_fail E0728"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::future::Future;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">struct WakeOnceThenComplete(bool);
</span><span class="boring">
</span><span class="boring">fn wake_and_yield_once() -&gt; WakeOnceThenComplete {
</span><span class="boring">    WakeOnceThenComplete(false)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for WakeOnceThenComplete {
</span><span class="boring">    type Output = ();
</span><span class="boring">    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
</span><span class="boring">        if self.0 {
</span><span class="boring">            Poll::Ready(())
</span><span class="boring">        } else {
</span><span class="boring">            cx.waker().wake_by_ref();
</span><span class="boring">            self.0 = true;
</span><span class="boring">            Poll::Pending
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn foo() {
    wake_and_yield_once().await // `await` is used outside `async` context
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/keyword.await.html"><code>await</code></a> is used to suspend the current computation until the given
future is ready to produce a value. So it is legal only within
an <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> context, like an <code>async</code> function or an <code>async</code> block.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::future::Future;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">struct WakeOnceThenComplete(bool);
</span><span class="boring">
</span><span class="boring">fn wake_and_yield_once() -&gt; WakeOnceThenComplete {
</span><span class="boring">    WakeOnceThenComplete(false)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for WakeOnceThenComplete {
</span><span class="boring">    type Output = ();
</span><span class="boring">    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
</span><span class="boring">        if self.0 {
</span><span class="boring">            Poll::Ready(())
</span><span class="boring">        } else {
</span><span class="boring">            cx.waker().wake_by_ref();
</span><span class="boring">            self.0 = true;
</span><span class="boring">            Poll::Pending
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>async fn foo() {
    wake_and_yield_once().await // `await` is used within `async` function
}

fn bar(x: u8) -&gt; impl Future&lt;Output = u8&gt; {
    async move {
        wake_and_yield_once().await; // `await` is used within `async` block
        x
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0729"><a class="header" href="#error-code-e0729">Error code E0729</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-67"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-67">Note: this error code is no longer emitted by the compiler</a></h4>
<p>Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler
since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow
checker for NLL uncovered some bugs in the old borrow checker, which in some
cases allowed unsound code to compile, resulting in memory safety issues.</p>
<h3 id="what-do-i-do"><a class="header" href="#what-do-i-do">What do I do?</a></h3>
<p>Change your code so the warning does no longer trigger. For backwards
compatibility, this unsound code may still compile (with a warning) right now.
However, at some point in the future, the compiler will no longer accept this
code and will throw a hard error.</p>
<h3 id="shouldnt-you-fix-the-old-borrow-checker"><a class="header" href="#shouldnt-you-fix-the-old-borrow-checker">Shouldn't you fix the old borrow checker?</a></h3>
<p>The old borrow checker has known soundness issues that are basically impossible
to fix. The new NLL-based borrow checker is the fix.</p>
<h3 id="can-i-turn-these-warnings-into-errors-by-denying-a-lint"><a class="header" href="#can-i-turn-these-warnings-into-errors-by-denying-a-lint">Can I turn these warnings into errors by denying a lint?</a></h3>
<p>No.</p>
<h3 id="when-are-these-warnings-going-to-turn-into-errors"><a class="header" href="#when-are-these-warnings-going-to-turn-into-errors">When are these warnings going to turn into errors?</a></h3>
<p>No formal timeline for turning the warnings into errors has been set. See
<a href="https://github.com/rust-lang/rust/issues/58781">GitHub issue 58781</a> for more
information.</p>
<h3 id="why-do-i-get-this-message-with-code-that-doesnt-involve-borrowing"><a class="header" href="#why-do-i-get-this-message-with-code-that-doesnt-involve-borrowing">Why do I get this message with code that doesn't involve borrowing?</a></h3>
<p>There are some known bugs that trigger this message.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0730"><a class="header" href="#error-code-e0730">Error code E0730</a></h1>
<p>An array without a fixed length was pattern-matched.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0730"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_123&lt;const N: usize&gt;(x: [u32; N]) -&gt; bool {
    match x {
        [1, 2, ..] =&gt; true, // error: cannot pattern-match on an
                            //        array without a fixed length
        _ =&gt; false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, you have two solutions:</p>
<ol>
<li>Use an array with a fixed length.</li>
<li>Use a slice.</li>
</ol>
<p>Example with an array with a fixed length:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_123(x: [u32; 3]) -&gt; bool { // We use an array with a fixed size
    match x {
        [1, 2, ..] =&gt; true, // ok!
        _ =&gt; false
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Example with a slice:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_123(x: &amp;[u32]) -&gt; bool { // We use a slice
    match x {
        [1, 2, ..] =&gt; true, // ok!
        _ =&gt; false
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0731"><a class="header" href="#error-code-e0731">Error code E0731</a></h1>
<p>An enum with the representation hint <code>repr(transparent)</code> had zero or more than
one variants.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0731"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(transparent)]
enum Status { // error: transparent enum needs exactly one variant, but has 2
    Errno(u32),
    Ok,
}
<span class="boring">}</span></code></pre></pre>
<p>Because transparent enums are represented exactly like one of their variants at
run time, said variant must be uniquely determined. If there is no variant, or
if there are multiple variants, it is not clear how the enum should be
represented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0732"><a class="header" href="#error-code-e0732">Error code E0732</a></h1>
<p>An <code>enum</code> with a discriminant must specify a <code>#[repr(inttype)]</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0732">enum Enum { // error!
    Unit = 1,
    Tuple() = 2,
    Struct{} = 3,
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>A <code>#[repr(inttype)]</code> must be provided on an <code>enum</code> if it has a non-unit
variant with a discriminant, or where there are both unit variants with
discriminants and non-unit variants. This restriction ensures that there
is a well-defined way to extract a variant's discriminant from a value;
for instance:</p>
<pre><pre class="playground"><code class="language-rust">#[repr(u8)]
enum Enum {
    Unit = 3,
    Tuple(u16) = 2,
    Struct {
        a: u8,
        b: u16,
    } = 1,
}

fn discriminant(v : &amp;Enum) -&gt; u8 {
    unsafe { *(v as *const Enum as *const u8) }
}

fn main() {
    assert_eq!(3, discriminant(&amp;Enum::Unit));
    assert_eq!(2, discriminant(&amp;Enum::Tuple(5)));
    assert_eq!(1, discriminant(&amp;Enum::Struct{a: 7, b: 11}));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0733"><a class="header" href="#error-code-e0733">Error code E0733</a></h1>
<p>An <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> function used recursion without boxing.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust edition2018 compile_fail E0733"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo(n: usize) {
    if n &gt; 0 {
        foo(n - 1).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To perform async recursion, the <code>async fn</code> needs to be desugared such that the
<code>Future</code> is explicit in the return type:</p>
<pre><pre class="playground"><code class="language-rust edition2018 compile_fail E0720"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
fn foo_desugared(n: usize) -&gt; impl Future&lt;Output = ()&gt; {
    async move {
        if n &gt; 0 {
            foo_desugared(n - 1).await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, the future is wrapped in a pinned box:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::pin::Pin;
fn foo_recursive(n: usize) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; {
    Box::pin(async move {
        if n &gt; 0 {
            foo_recursive(n - 1).await;
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Box&lt;...&gt;</code> ensures that the result is of known size, and the pin is
required to keep it in the same place in memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0734"><a class="header" href="#error-code-e0734">Error code E0734</a></h1>
<p>A stability attribute has been used outside of the standard library.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0734"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;a&quot;, since = &quot;b&quot;)] // invalid
#[unstable(feature = &quot;b&quot;, issue = &quot;none&quot;)] // invalid
fn foo(){}
<span class="boring">}</span></code></pre></pre>
<p>These attributes are meant to only be used by the standard library and are
rejected in your own crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0735"><a class="header" href="#error-code-e0735">Error code E0735</a></h1>
<p>Type parameter defaults cannot use <code>Self</code> on structs, enums, or unions.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0735"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;X = Box&lt;Self&gt;&gt; {
    field1: Option&lt;X&gt;,
    field2: Option&lt;X&gt;,
}
// error: type parameters cannot use `Self` in their defaults.
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0736"><a class="header" href="#error-code-e0736">Error code E0736</a></h1>
<p><code>#[track_caller]</code> and <code>#[naked]</code> cannot both be applied to the same function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0736"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[naked]
#[track_caller]
fn foo() {}
<span class="boring">}</span></code></pre></pre>
<p>This is primarily due to ABI incompatibilities between the two attributes.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md">RFC 2091</a> for details on this and other limitations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0737"><a class="header" href="#error-code-e0737">Error code E0737</a></h1>
<p><code>#[track_caller]</code> requires functions to have the <code>&quot;Rust&quot;</code> ABI for implicitly
receiving caller location. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md">RFC 2091</a> for details on this and other
restrictions.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0737"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[track_caller]
extern &quot;C&quot; fn foo() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0739"><a class="header" href="#error-code-e0739">Error code E0739</a></h1>
<p><code>#[track_caller]</code> can not be applied on struct.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0739"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[track_caller]
struct Bar {
    a: u8,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0740"><a class="header" href="#error-code-e0740">Error code E0740</a></h1>
<p>A <code>union</code> was declared with fields with destructors.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0740"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union Test {
    a: A, // error!
}

#[derive(Debug)]
struct A(i32);

impl Drop for A {
    fn drop(&amp;mut self) { println!(&quot;A&quot;); }
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>union</code> cannot have fields with destructors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0741"><a class="header" href="#error-code-e0741">Error code E0741</a></h1>
<p>A non-structural-match type was used as the type of a const generic parameter.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0741"><span class="boring">#![allow(unused)]
</span>#![feature(adt_const_params)]

<span class="boring">fn main() {
</span>struct A;

struct B&lt;const X: A&gt;; // error!
<span class="boring">}</span></code></pre></pre>
<p>Only structural-match types (that is, types that derive <code>PartialEq</code> and <code>Eq</code>)
may be used as the types of const generic parameters.</p>
<p>To fix the previous code example, we derive <code>PartialEq</code> and <code>Eq</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(adt_const_params)]

<span class="boring">fn main() {
</span>#[derive(PartialEq, Eq)] // We derive both traits here.
struct A;

struct B&lt;const X: A&gt;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0742"><a class="header" href="#error-code-e0742">Error code E0742</a></h1>
<p>Visibility is restricted to a module which isn't an ancestor of the current
item.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0742 edition2018">pub mod sea {}

pub (in crate::sea) struct Shark; // error!

fn main() {}</code></pre></pre>
<p>To fix this error, we need to move the <code>Shark</code> struct inside the <code>sea</code> module:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod sea {
    pub (in crate::sea) struct Shark; // ok!
}

fn main() {}</code></pre></pre>
<p>Of course, you can do it as long as the module you're referring to is an
ancestor:</p>
<pre><pre class="playground"><code class="language-rust edition2018">pub mod earth {
    pub mod sea {
        pub (in crate::earth) struct Shark; // ok!
    }
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0743"><a class="header" href="#error-code-e0743">Error code E0743</a></h1>
<p>The C-variadic type <code>...</code> has been nested inside another type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0743"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo2(x: u8, y: &amp;...) {} // error!
<span class="boring">}</span></code></pre></pre>
<p>Only foreign functions can use the C-variadic type (<code>...</code>). In such functions,
<code>...</code> may only occur non-nested. That is, <code>y: &amp;'a ...</code> is not allowed.</p>
<p>A C-variadic type is used to give an undefined number of parameters to a given
function (like <code>printf</code> in C). The equivalent in Rust would be to use macros
directly (like <code>println!</code> for example).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0744"><a class="header" href="#error-code-e0744">Error code E0744</a></h1>
<p>An unsupported expression was used inside a const context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018 E0744"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _: i32 = {
    async { 0 }.await
};
<span class="boring">}</span></code></pre></pre>
<p>At the moment, <code>.await</code> is forbidden inside a <code>const</code>, <code>static</code>, or <code>const fn</code>.</p>
<p>This may be allowed at some point in the future, but the implementation is not
yet complete. See the tracking issue for <a href="https://github.com/rust-lang/rust/issues/69431"><code>async</code></a> in <code>const fn</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0745"><a class="header" href="#error-code-e0745">Error code E0745</a></h1>
<p>The address of temporary value was taken.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0745"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(raw_ref_op)]
</span>fn temp_address() {
    let ptr = &amp;raw const 2; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>2</code> is destroyed right after the assignment, which means that
<code>ptr</code> now points to an unavailable location.</p>
<p>To avoid this error, first bind the temporary to a named local variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(raw_ref_op)]
</span>fn temp_address() {
    let val = 2;
    let ptr = &amp;raw const val; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0746"><a class="header" href="#error-code-e0746">Error code E0746</a></h1>
<p>An unboxed trait object was used as a return value.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0746"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}

// Having the trait `T` as return type is invalid because
// unboxed trait objects do not have a statically known size:
fn foo() -&gt; dyn T { // error!
    S(42)
}
<span class="boring">}</span></code></pre></pre>
<p>Return types cannot be <code>dyn Trait</code>s as they must be <code>Sized</code>.</p>
<p>To avoid the error there are a couple of options.</p>
<p>If there is a single type involved, you can use <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits"><code>impl Trait</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {
</span><span class="boring">    fn bar(&amp;self);
</span><span class="boring">}
</span><span class="boring">struct S(usize);
</span><span class="boring">impl T for S {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span>// The compiler will select `S(usize)` as the materialized return type of this
// function, but callers will only know that the return type implements `T`.
fn foo() -&gt; impl T { // ok!
    S(42)
}
<span class="boring">}</span></code></pre></pre>
<p>If there are multiple types involved, the only way you care to interact with
them is through the trait's interface, and having to rely on dynamic dispatch
is acceptable, then you can use <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a> with <code>Box</code>, or other container
types like <code>Rc</code> or <code>Arc</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {
</span><span class="boring">    fn bar(&amp;self);
</span><span class="boring">}
</span><span class="boring">struct S(usize);
</span><span class="boring">impl T for S {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span>struct O(&amp;'static str);
impl T for O {
    fn bar(&amp;self) {}
}

// This now returns a &quot;trait object&quot; and callers are only be able to access
// associated items from `T`.
fn foo(x: bool) -&gt; Box&lt;dyn T&gt; { // ok!
    if x {
        Box::new(S(42))
    } else {
        Box::new(O(&quot;val&quot;))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, if you wish to still be able to access the original type, you can
create a new <code>enum</code> with a variant for each type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {
</span><span class="boring">    fn bar(&amp;self);
</span><span class="boring">}
</span><span class="boring">struct S(usize);
</span><span class="boring">impl T for S {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">struct O(&amp;'static str);
</span><span class="boring">impl T for O {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span>enum E {
    S(S),
    O(O),
}

// The caller can access the original types directly, but it needs to match on
// the returned `enum E`.
fn foo(x: bool) -&gt; E {
    if x {
        E::S(S(42))
    } else {
        E::O(O(&quot;val&quot;))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can even implement the <code>trait</code> on the returned <code>enum</code> so the callers
<em>don't</em> have to match on the returned value to invoke the associated items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {
</span><span class="boring">    fn bar(&amp;self);
</span><span class="boring">}
</span><span class="boring">struct S(usize);
</span><span class="boring">impl T for S {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">struct O(&amp;'static str);
</span><span class="boring">impl T for O {
</span><span class="boring">    fn bar(&amp;self) {}
</span><span class="boring">}
</span><span class="boring">enum E {
</span><span class="boring">    S(S),
</span><span class="boring">    O(O),
</span><span class="boring">}
</span>impl T for E {
    fn bar(&amp;self) {
        match self {
            E::S(s) =&gt; s.bar(),
            E::O(o) =&gt; o.bar(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If you decide to use trait objects, be aware that these rely on
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">dynamic dispatch</a>, which has performance implications, as the compiler needs
to emit code that will figure out which method to call <em>at runtime</em> instead of
during compilation. Using trait objects we are trading flexibility for
performance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0747"><a class="header" href="#error-code-e0747">Error code E0747</a></h1>
<p>Generic arguments were not provided in the same order as the corresponding
generic parameters are declared.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0747"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt;(&amp;'a T);

type X = S&lt;(), 'static&gt;; // error: the type argument is provided before the
                         // lifetime argument
<span class="boring">}</span></code></pre></pre>
<p>The argument order should be changed to match the parameter declaration
order, as in the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a, T&gt;(&amp;'a T);

type X = S&lt;'static, ()&gt;; // ok
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0748"><a class="header" href="#error-code-e0748">Error code E0748</a></h1>
<p>A raw string isn't correctly terminated because the trailing <code>#</code> count doesn't
match its leading <code>#</code> count.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0748"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dolphins = r##&quot;Dolphins!&quot;#; // error!
<span class="boring">}</span></code></pre></pre>
<p>To terminate a raw string, you have to have the same number of <code>#</code> at the end
as at the beginning. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dolphins = r#&quot;Dolphins!&quot;#; // One `#` at the beginning, one at the end so
                               // all good!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0749"><a class="header" href="#error-code-e0749">Error code E0749</a></h1>
<p>An item was added on a negative impl.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0749"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span>trait MyTrait {
    type Foo;
}

impl !MyTrait for u32 {
    type Foo = i32; // error!
}
<span class="boring">}</span></code></pre></pre>
<p>Negative impls are not allowed to have any items. Negative impls declare that a
trait is <strong>not</strong> implemented (and never will be) and hence there is no need to
specify the values for trait methods or other items.</p>
<p>One way to fix this is to remove the items in negative impls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(negative_impls)]
</span>trait MyTrait {
    type Foo;
}

impl !MyTrait for u32 {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0750"><a class="header" href="#error-code-e0750">Error code E0750</a></h1>
<p>A negative impl was made default impl.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0750"><span class="boring">#![feature(negative_impls)]
</span><span class="boring">#![feature(specialization)]
</span>trait MyTrait {
    type Foo;
}

default impl !MyTrait for u32 {} // error!
<span class="boring">fn main() {}</span></code></pre></pre>
<p>Negative impls cannot be default impls. A default impl supplies default values
for the items within to be used by other impls, whereas a negative impl declares
that there are no other impls. Combining it does not make sense.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0751"><a class="header" href="#error-code-e0751">Error code E0751</a></h1>
<p>There are both a positive and negative trait implementation for the same type.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0751"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}
impl MyTrait for i32 { }
impl !MyTrait for i32 { } // error!
<span class="boring">}</span></code></pre></pre>
<p>Negative implementations are a promise that the trait will never be implemented
for the given types. Therefore, both cannot exists at the same time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0752"><a class="header" href="#error-code-e0752">Error code E0752</a></h1>
<p>The entry point of the program was marked as <code>async</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0752">async fn main() -&gt; Result&lt;(), ()&gt; { // error!
    Ok(())
}</code></pre></pre>
<p><code>fn main()</code> or the specified start function is not allowed to be <code>async</code>. Not
having a correct async runtime library setup may cause this error. To fix it,
declare the entry point without <code>async</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), ()&gt; { // ok!
    Ok(())
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0753"><a class="header" href="#error-code-e0753">Error code E0753</a></h1>
<p>An inner doc comment was used in an invalid context.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0753">fn foo() {}
//! foo
// ^ error!
fn main() {}</code></pre></pre>
<p>Inner document can only be used before items. For example:</p>
<pre><pre class="playground"><code class="language-rust">//! A working comment applied to the module!
fn foo() {
    //! Another working comment!
}
fn main() {}</code></pre></pre>
<p>In case you want to document the item following the doc comment, you might want
to use outer doc comment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// I am an outer doc comment
#[doc = &quot;I am also an outer doc comment!&quot;]
fn foo() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0754"><a class="header" href="#error-code-e0754">Error code E0754</a></h1>
<p>A non-ASCII identifier was used in an invalid context.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0754">
mod řųśť; // error!

#[no_mangle]
fn řųśť() {} // error!

fn main() {}</code></pre></pre>
<p>Non-ASCII can be used as module names if it is inlined or if a <code>#[path]</code>
attribute is specified. For example:</p>
<pre><pre class="playground"><code class="language-rust">mod řųśť { // ok!
    const IS_GREAT: bool = true;
}

fn main() {}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0755"><a class="header" href="#error-code-e0755">Error code E0755</a></h1>
<p>The <code>ffi_pure</code> attribute was used on a non-foreign function.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0755">#![feature(ffi_pure)]

#[ffi_pure] // error!
pub fn foo() {}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <code>ffi_pure</code> attribute can only be used on foreign functions which do not have
side effects or infinite loops:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(ffi_pure)]

extern &quot;C&quot; {
    #[ffi_pure] // ok!
    pub fn strlen(s: *const i8) -&gt; isize;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>You can find more information about it in the <a href="https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html">unstable Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0756"><a class="header" href="#error-code-e0756">Error code E0756</a></h1>
<p>The <code>ffi_const</code> attribute was used on something other than a foreign function
declaration.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0756">#![feature(ffi_const)]

#[ffi_const] // error!
pub fn foo() {}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>The <code>ffi_const</code> attribute can only be used on foreign function declarations
which have no side effects except for their return value:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(ffi_const)]

extern &quot;C&quot; {
    #[ffi_const] // ok!
    pub fn strlen(s: *const i8) -&gt; i32;
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>You can get more information about it in the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html">unstable Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0757"><a class="header" href="#error-code-e0757">Error code E0757</a></h1>
<p>A function was given both the <code>ffi_const</code> and <code>ffi_pure</code> attributes.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0757"><span class="boring">#![allow(unused)]
</span>#![feature(ffi_const, ffi_pure)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[ffi_const]
    #[ffi_pure] // error: `#[ffi_const]` function cannot be `#[ffi_pure]`
    pub fn square(num: i32) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<p>As <code>ffi_const</code> provides stronger guarantees than <code>ffi_pure</code>, remove the
<code>ffi_pure</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(ffi_const)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[ffi_const]
    pub fn square(num: i32) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<p>You can get more information about <code>const</code> and <code>pure</code> in the <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html">GCC documentation
on Common Function Attributes</a>. The unstable Rust Book has more information
about <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html"><code>ffi_const</code></a> and <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-pure.html"><code>ffi_pure</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0758"><a class="header" href="#error-code-e0758">Error code E0758</a></h1>
<p>A multi-line (doc-)comment is unterminated.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0758"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* I am not terminated!
<span class="boring">}</span></code></pre></pre>
<p>The same goes for doc comments:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0758"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*! I am not terminated!
<span class="boring">}</span></code></pre></pre>
<p>You need to end your multi-line comment with <code>*/</code> in order to fix this error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/* I am terminated! */
/*! I am also terminated! */
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0759"><a class="header" href="#error-code-e0759">Error code E0759</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-68"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-68">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>Return type involving a trait did not require <code>'static</code> lifetime.</p>
<p>Erroneous code examples:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo(x: &amp;i32) -&gt; impl Debug { // error!
    x
}

fn bar(x: &amp;i32) -&gt; Box&lt;dyn Debug&gt; { // error!
    Box::new(x)
}
<span class="boring">}</span></code></pre></pre>
<p>Add <code>'static</code> requirement to fix them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo(x: &amp;'static i32) -&gt; impl Debug + 'static { // ok!
    x
}

fn bar(x: &amp;'static i32) -&gt; Box&lt;dyn Debug + 'static&gt; { // ok!
    Box::new(x)
}
<span class="boring">}</span></code></pre></pre>
<p>Both <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types"><code>dyn Trait</code></a> and <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits"><code>impl Trait</code></a> in return types have an implicit
<code>'static</code> requirement, meaning that the value implementing them that is being
returned has to be either a <code>'static</code> borrow or an owned value.</p>
<p>In order to change the requirement from <code>'static</code> to be a lifetime derived from
its arguments, you can add an explicit bound, either to an anonymous lifetime
<code>'_</code> or some appropriate named lifetime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo(x: &amp;i32) -&gt; impl Debug + '_ {
    x
}
fn bar(x: &amp;i32) -&gt; Box&lt;dyn Debug + '_&gt; {
    Box::new(x)
}
<span class="boring">}</span></code></pre></pre>
<p>These are equivalent to the following explicit lifetime annotations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; impl Debug + 'a {
    x
}
fn bar&lt;'a&gt;(x: &amp;'a i32) -&gt; Box&lt;dyn Debug + 'a&gt; {
    Box::new(x)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0760"><a class="header" href="#error-code-e0760">Error code E0760</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-69"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-69">Note: this error code is no longer emitted by the compiler.</a></h4>
<p><code>async fn</code>/<code>impl trait</code> return type cannot contain a projection
or <code>Self</code> that references lifetimes from a parent scope.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; S&lt;'a&gt; {
    async fn new(i: &amp;'a i32) -&gt; Self {
        S(&amp;22)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error we need to spell out <code>Self</code> to <code>S&lt;'a&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; S&lt;'a&gt; {
    async fn new(i: &amp;'a i32) -&gt; S&lt;'a&gt; {
        S(&amp;22)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This will be allowed at some point in the future,
but the implementation is not yet complete.
See the <a href="https://github.com/rust-lang/rust/issues/61949">issue-61949</a> for this limitation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0761"><a class="header" href="#error-code-e0761">Error code E0761</a></h1>
<p>Multiple candidate files were found for an out-of-line module.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (Multiple source files are required for compile_fail.)">// file: ambiguous_module/mod.rs

fn foo() {}

// file: ambiguous_module.rs

fn foo() {}

// file: lib.rs

mod ambiguous_module; // error: file for module `ambiguous_module`
                      // found at both ambiguous_module.rs and
                      // ambiguous_module.rs/mod.rs</code></pre>
<p>Please remove this ambiguity by deleting/renaming one of the candidate files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0762"><a class="header" href="#error-code-e0762">Error code E0762</a></h1>
<p>A character literal wasn't ended with a quote.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0762"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static C: char = '●; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, add the missing quote:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static C: char = '●'; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0763"><a class="header" href="#error-code-e0763">Error code E0763</a></h1>
<p>A byte constant wasn't correctly ended.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0763"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = b'a; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, add the missing quote:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = b'a'; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0764"><a class="header" href="#error-code-e0764">Error code E0764</a></h1>
<p>A mutable reference was used in a constant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0764">#![feature(const_mut_refs)]

fn main() {
    const OH_NO: &amp;'static mut usize = &amp;mut 1; // error!
}</code></pre></pre>
<p>Mutable references (<code>&amp;mut</code>) can only be used in constant functions, not statics
or constants. This limitation exists to prevent the creation of constants that
have a mutable reference in their final value. If you had a constant of
<code>&amp;mut i32</code> type, you could modify the value through that reference, making the
constant essentially mutable.</p>
<p>While there could be a more fine-grained scheme in the future that allows
mutable references if they are not &quot;leaked&quot; to the final value, a more
conservative approach was chosen for now. <code>const fn</code> do not have this problem,
as the borrow checker will prevent the <code>const fn</code> from returning new mutable
references.</p>
<p>Remember: you cannot use a function call inside a constant or static. However,
you can totally use it in constant functions:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(const_mut_refs)]

const fn foo(x: usize) -&gt; usize {
    let mut y = 1;
    let z = &amp;mut y;
    *z += x;
    y
}

fn main() {
    const FOO: usize = foo(10); // ok!
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0765"><a class="header" href="#error-code-e0765">Error code E0765</a></h1>
<p>A double quote string (<code>&quot;</code>) was not terminated.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0765"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, add the missing double quote at the end of the string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;&quot;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0766"><a class="header" href="#error-code-e0766">Error code E0766</a></h1>
<p>A double quote byte string (<code>b&quot;</code>) was not terminated.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0766"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = b&quot;; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, add the missing double quote at the end of the string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = b&quot;&quot;; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0767"><a class="header" href="#error-code-e0767">Error code E0767</a></h1>
<p>An unreachable label was used.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0767"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    || {
        loop { break 'a } // error: use of unreachable label `'a`
    };
}
<span class="boring">}</span></code></pre></pre>
<p>Ensure that the label is within scope. Labels are not reachable through
functions, closures, async blocks or modules. Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'a: loop {
    break 'a; // ok!
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0768"><a class="header" href="#error-code-e0768">Error code E0768</a></h1>
<p>A number in a non-decimal base has no digits.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0768"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: i32 = 0b; // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, add the missing digits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: i32 = 0b1; // ok!
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0769"><a class="header" href="#error-code-e0769">Error code E0769</a></h1>
<p>A tuple struct or tuple variant was used in a pattern as if it were a struct or
struct variant.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0769"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    A(i32),
}

let e = E::A(42);

match e {
    E::A { number } =&gt; { // error!
        println!(&quot;{}&quot;, number);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, you can use the tuple pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum E {
</span><span class="boring">    A(i32),
</span><span class="boring">}
</span><span class="boring">let e = E::A(42);
</span>match e {
    E::A(number) =&gt; { // ok!
        println!(&quot;{}&quot;, number);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, you can also use the struct pattern by using the correct field
names and binding them to new identifiers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum E {
</span><span class="boring">    A(i32),
</span><span class="boring">}
</span><span class="boring">let e = E::A(42);
</span>match e {
    E::A { 0: number } =&gt; { // ok!
        println!(&quot;{}&quot;, number);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0770"><a class="header" href="#error-code-e0770">Error code E0770</a></h1>
<p>The type of a const parameter references other generic parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0770"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T, const N: T&gt;() {} // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, use a concrete type for the const parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T, const N: usize&gt;() {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0771"><a class="header" href="#error-code-e0771">Error code E0771</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-70"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-70">Note: this error code is no longer emitted by the compiler</a></h4>
<p>A non-<code>'static</code> lifetime was used in a const generic. This is currently not
allowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0770"><span class="boring">#![allow(unused)]
</span>#![feature(adt_const_params)]

<span class="boring">fn main() {
</span>fn function_with_str&lt;'a, const STRING: &amp;'a str&gt;() {} // error!
<span class="boring">}</span></code></pre></pre>
<p>To fix this issue, the lifetime in the const generic need to be changed to
<code>'static</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(adt_const_params)]

<span class="boring">fn main() {
</span>fn function_with_str&lt;const STRING: &amp;'static str&gt;() {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>For more information, see <a href="https://github.com/rust-lang/rust/issues/74052">GitHub issue #74052</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0772"><a class="header" href="#error-code-e0772">Error code E0772</a></h1>
<h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler-71"><a class="header" href="#note-this-error-code-is-no-longer-emitted-by-the-compiler-71">Note: this error code is no longer emitted by the compiler.</a></h4>
<p>A trait object has some specific lifetime <code>'1</code>, but it was used in a way that
requires it to have a <code>'static</code> lifetime.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait BooleanLike {}
trait Person {}

impl BooleanLike for bool {}

impl dyn Person {
    fn is_cool(&amp;self) -&gt; bool {
        // hey you, you're pretty cool
        true
    }
}

fn get_is_cool&lt;'p&gt;(person: &amp;'p dyn Person) -&gt; impl BooleanLike {
    // error: `person` has an anonymous lifetime `'p` but calling
    //        `print_cool_fn` introduces an implicit `'static` lifetime
    //        requirement
    person.is_cool()
}
<span class="boring">}</span></code></pre></pre>
<p>The trait object <code>person</code> in the function <code>get_is_cool</code>, while already being
behind a reference with lifetime <code>'p</code>, also has it's own implicit lifetime,
<code>'2</code>.</p>
<p>Lifetime <code>'2</code> represents the data the trait object might hold inside, for
example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {}

struct MyStruct&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; MyTrait for MyStruct&lt;'a&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>With this scenario, if a trait object of <code>dyn MyTrait + '2</code> was made from
<code>MyStruct&lt;'a&gt;</code>, <code>'a</code> must live as long, if not longer than <code>'2</code>. This allows the
trait object's internal data to be accessed safely from any trait methods. This
rule also goes for any lifetime any struct made into a trait object may have.</p>
<p>In the implementation for <code>dyn Person</code>, the <code>'2</code> lifetime representing the
internal data was omitted, meaning that the compiler inferred the lifetime
<code>'static</code>. As a result, the implementation's <code>is_cool</code> is inferred by the
compiler to look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Person {}
</span><span class="boring">
</span><span class="boring">impl dyn Person {
</span>fn is_cool&lt;'a&gt;(self: &amp;'a (dyn Person + 'static)) -&gt; bool {unimplemented!()}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>While the <code>get_is_cool</code> function is inferred to look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Person {}
</span><span class="boring">trait BooleanLike {}
</span><span class="boring">
</span>fn get_is_cool&lt;'p, R: BooleanLike&gt;(person: &amp;'p (dyn Person + 'p)) -&gt; R {
    unimplemented!()
}
<span class="boring">}</span></code></pre></pre>
<p>Which brings us to the core of the problem; the assignment of type
<code>&amp;'_ (dyn Person + '_)</code> to type <code>&amp;'_ (dyn Person + 'static)</code> is impossible.</p>
<p>Fixing it is as simple as being generic over lifetime <code>'2</code>, as to prevent the
compiler from inferring it as <code>'static</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Person {}
</span><span class="boring">
</span>impl&lt;'d&gt; dyn Person + 'd {/* ... */}

// This works too, and is more elegant:
//impl dyn Person + '_ {/* ... */}
<span class="boring">}</span></code></pre></pre>
<p>See the [Rust Reference on Trait Object Lifetime Bounds][trait-objects] for
more information on trait object lifetimes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0773"><a class="header" href="#error-code-e0773">Error code E0773</a></h1>
<p>A builtin-macro was defined more than once.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0773"><span class="boring">#![allow(unused)]
</span>#![feature(decl_macro)]
#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_builtin_macro]
pub macro test($item:item) {
    /* compiler built-in */
}

mod inner {
    #[rustc_builtin_macro]
    pub macro test($item:item) {
        /* compiler built-in */
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To fix the issue, remove the duplicate declaration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(decl_macro)]
#![feature(rustc_attrs)]

<span class="boring">fn main() {
</span>#[rustc_builtin_macro]
pub macro test($item:item) {
    /* compiler built-in */
}
<span class="boring">}</span></code></pre></pre>
<p>In very rare edge cases, this may happen when loading <code>core</code> or <code>std</code> twice,
once with <code>check</code> metadata and once with <code>build</code> metadata.
For more information, see <a href="https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468">#75176</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0774"><a class="header" href="#error-code-e0774">Error code E0774</a></h1>
<p><code>derive</code> was applied on something which is not a struct, a union or an enum.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0774"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    #[derive(Clone)] // error!
    type Bar;
}
<span class="boring">}</span></code></pre></pre>
<p>As said above, the <code>derive</code> attribute is only allowed on structs, unions or
enums:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)] // ok!
struct Bar {
    field: u32,
}
<span class="boring">}</span></code></pre></pre>
<p>You can find more information about <code>derive</code> in the <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Rust Book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0775"><a class="header" href="#error-code-e0775">Error code E0775</a></h1>
<p><code>#[cmse_nonsecure_entry]</code> is only valid for targets with the TrustZone-M
extension.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0775"><span class="boring">#![allow(unused)]
</span>#![feature(cmse_nonsecure_entry)]

<span class="boring">fn main() {
</span>#[cmse_nonsecure_entry]
pub extern &quot;C&quot; fn entry_function() {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, compile your code for a Rust target that supports the
TrustZone-M extension. The current possible targets are:</p>
<ul>
<li><code>thumbv8m.main-none-eabi</code></li>
<li><code>thumbv8m.main-none-eabihf</code></li>
<li><code>thumbv8m.base-none-eabi</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0776"><a class="header" href="#error-code-e0776">Error code E0776</a></h1>
<p><code>#[cmse_nonsecure_entry]</code> functions require a C ABI</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0776"><span class="boring">#![allow(unused)]
</span>#![feature(cmse_nonsecure_entry)]

<span class="boring">fn main() {
</span>#[no_mangle]
#[cmse_nonsecure_entry]
pub fn entry_function(input: Vec&lt;u32&gt;) {}
<span class="boring">}</span></code></pre></pre>
<p>To fix this error, declare your entry function with a C ABI, using <code>extern &quot;C&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0777"><a class="header" href="#error-code-e0777">Error code E0777</a></h1>
<p>A literal value was used inside <code>#[derive]</code>.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0777"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(&quot;Clone&quot;)] // error!
struct Foo;
<span class="boring">}</span></code></pre></pre>
<p>Only paths to traits are allowed as argument inside <code>#[derive]</code>. You can find
more information about the <code>#[derive]</code> attribute in the <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Rust Book</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)] // ok!
struct Foo;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0778"><a class="header" href="#error-code-e0778">Error code E0778</a></h1>
<p>The <code>instruction_set</code> attribute was malformed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0778">#![feature(isa_attribute)]

#[instruction_set()] // error: expected one argument
pub fn something() {}
fn main() {}</code></pre></pre>
<p>The parenthesized <code>instruction_set</code> attribute requires the parameter to be
specified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(isa_attribute)]

<span class="boring">fn main() {
</span>#[cfg_attr(target_arch=&quot;arm&quot;, instruction_set(arm::a32))]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>or:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(isa_attribute)]

<span class="boring">fn main() {
</span>#[cfg_attr(target_arch=&quot;arm&quot;, instruction_set(arm::t32))]
fn something() {}
<span class="boring">}</span></code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html"><code>instruction_set</code> attribute</a>
section of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0779"><a class="header" href="#error-code-e0779">Error code E0779</a></h1>
<p>An unknown argument was given to the <code>instruction_set</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0779">#![feature(isa_attribute)]

#[instruction_set(intel::x64)] // error: invalid argument
pub fn something() {}
fn main() {}</code></pre></pre>
<p>The <code>instruction_set</code> attribute only supports two arguments currently:</p>
<ul>
<li>arm::a32</li>
<li>arm::t32</li>
</ul>
<p>All other arguments given to the <code>instruction_set</code> attribute will return this
error. Example:</p>
<pre><pre class="playground"><code class="language-rust">#![feature(isa_attribute)]

#[cfg_attr(target_arch=&quot;arm&quot;, instruction_set(arm::a32))] // ok!
pub fn something() {}
fn main() {}</code></pre></pre>
<p>For more information see the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html"><code>instruction_set</code> attribute</a>
section of the Reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0780"><a class="header" href="#error-code-e0780">Error code E0780</a></h1>
<p>Cannot use <code>doc(inline)</code> with anonymous imports</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">
#[doc(inline)] // error: invalid doc argument
pub use foo::Foo as _;</code></pre>
<p>Anonymous imports are always rendered with <code>#[doc(no_inline)]</code>. To fix this
error, remove the <code>#[doc(inline)]</code> attribute.</p>
<p>Example:</p>
<pre><code class="language-rust ignore (cannot-doctest-multicrate-project)">
pub use foo::Foo as _;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0781"><a class="header" href="#error-code-e0781">Error code E0781</a></h1>
<p>The <code>C-cmse-nonsecure-call</code> ABI can only be used with function pointers.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0781"><span class="boring">#![allow(unused)]
</span>#![feature(abi_c_cmse_nonsecure_call)]

<span class="boring">fn main() {
</span>pub extern &quot;C-cmse-nonsecure-call&quot; fn test() {}
<span class="boring">}</span></code></pre></pre>
<p>The <code>C-cmse-nonsecure-call</code> ABI should be used by casting function pointers to
specific addresses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0782"><a class="header" href="#error-code-e0782">Error code E0782</a></h1>
<p>Trait objects must include the <code>dyn</code> keyword.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust edition2021 compile_fail E0782"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}
fn test(arg: Box&lt;Foo&gt;) {} // error!
<span class="boring">}</span></code></pre></pre>
<p>Trait objects are a way to call methods on types that are not known until
runtime but conform to some trait.</p>
<p>Trait objects should be formed with <code>Box&lt;dyn Foo&gt;</code>, but in the code above
<code>dyn</code> is left off.</p>
<p>This makes it harder to see that <code>arg</code> is a trait object and not a
simply a heap allocated type called <code>Foo</code>.</p>
<p>To fix this issue, add <code>dyn</code> before the trait name.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {}
fn test(arg: Box&lt;dyn Foo&gt;) {} // ok!
<span class="boring">}</span></code></pre></pre>
<p>This used to be allowed before edition 2021, but is now an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0783"><a class="header" href="#error-code-e0783">Error code E0783</a></h1>
<p>The range pattern <code>...</code> is no longer allowed.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust edition2021 compile_fail E0783"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 2u8 {
    0...9 =&gt; println!(&quot;Got a number less than 10&quot;), // error!
    _ =&gt; println!(&quot;Got a number 10 or more&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>Older Rust code using previous editions allowed <code>...</code> to stand for exclusive
ranges which are now signified using <code>..=</code>.</p>
<p>To make this code compile replace the <code>...</code> with <code>..=</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match 2u8 {
    0..=9 =&gt; println!(&quot;Got a number less than 10&quot;), // ok!
    _ =&gt; println!(&quot;Got a number 10 or more&quot;),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0784"><a class="header" href="#error-code-e0784">Error code E0784</a></h1>
<p>A union expression does not have exactly one field.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0784"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union Bird {
    pigeon: u8,
    turtledove: u16,
}

let bird = Bird {}; // error
let bird = Bird { pigeon: 0, turtledove: 1 }; // error
<span class="boring">}</span></code></pre></pre>
<p>The key property of unions is that all fields of a union share common storage.
As a result, writes to one field of a union can overwrite its other fields, and
size of a union is determined by the size of its largest field.</p>
<p>You can find more information about the union types in the <a href="https://doc.rust-lang.org/reference/items/unions.html">Rust reference</a>.</p>
<p>Working example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union Bird {
    pigeon: u8,
    turtledove: u16,
}

let bird = Bird { pigeon: 0 }; // OK
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0785"><a class="header" href="#error-code-e0785">Error code E0785</a></h1>
<p>An inherent <code>impl</code> was written on a dyn auto trait.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0785"><span class="boring">#![allow(unused)]
</span>#![feature(auto_traits)]

<span class="boring">fn main() {
</span>auto trait AutoTrait {}

impl dyn AutoTrait {}
<span class="boring">}</span></code></pre></pre>
<p>Dyn objects allow any number of auto traits, plus at most one non-auto trait.
The non-auto trait becomes the &quot;principal trait&quot;.</p>
<p>When checking if an impl on a dyn trait is coherent, the principal trait is
normally the only one considered. Since the erroneous code has no principal
trait, it cannot be implemented at all.</p>
<p>Working example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(auto_traits)]

<span class="boring">fn main() {
</span>trait PrincipalTrait {}

auto trait AutoTrait {}

impl dyn PrincipalTrait + AutoTrait + Send {}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0786"><a class="header" href="#error-code-e0786">Error code E0786</a></h1>
<p>A metadata file was invalid.</p>
<p>Erroneous code example:</p>
<pre><code class="language-rust ignore (needs extern files)">use ::foo; // error: found invalid metadata files for crate `foo`</code></pre>
<p>When loading crates, each crate must have a valid metadata file.
Invalid files could be caused by filesystem corruption,
an IO error while reading the file, or (rarely) a bug in the compiler itself.</p>
<p>Consider deleting the file and recreating it,
or reporting a bug against the compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0787"><a class="header" href="#error-code-e0787">Error code E0787</a></h1>
<p>An unsupported naked function definition.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0787"><span class="boring">#![allow(unused)]
</span>#![feature(naked_functions)]

<span class="boring">fn main() {
</span>#[naked]
pub extern &quot;C&quot; fn f() -&gt; u32 {
    42
}
<span class="boring">}</span></code></pre></pre>
<p>The naked functions must be defined using a single inline assembly
block.</p>
<p>The execution must never fall through past the end of the assembly
code so the block must use <code>noreturn</code> option. The asm block can also
use <code>att_syntax</code> and <code>raw</code> options, but others options are not allowed.</p>
<p>The asm block must not contain any operands other than <code>const</code> and
<code>sym</code>.</p>
<h3 id="additional-information-1"><a class="header" href="#additional-information-1">Additional information</a></h3>
<p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2972-constrained-naked.md">RFC 2972</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0788"><a class="header" href="#error-code-e0788">Error code E0788</a></h1>
<p>A <code>#[no_coverage]</code> attribute was applied to something which does not show up
in code coverage, or is too granular to be excluded from the coverage report.</p>
<p>For now, this attribute can only be applied to function, method, and closure
definitions. In the future, it may be added to statements, blocks, and
expressions, and for the time being, using this attribute in those places
will just emit an <code>unused_attributes</code> lint instead of this error.</p>
<p>Example of erroneous code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0788"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_coverage]
struct Foo;

#[no_coverage]
const FOO: Foo = Foo;
<span class="boring">}</span></code></pre></pre>
<p><code>#[no_coverage]</code> tells the compiler to not generate coverage instrumentation for
a piece of code when the <code>-C instrument-coverage</code> flag is passed. Things like
structs and consts are not coverable code, and thus cannot do anything with this
attribute.</p>
<p>If you wish to apply this attribute to all methods in an impl or module,
manually annotate each method; it is not possible to annotate the entire impl
with a <code>#[no_coverage]</code> attribute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0789"><a class="header" href="#error-code-e0789">Error code E0789</a></h1>
<h4 id="this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-4"><a class="header" href="#this-error-code-is-internal-to-the-compiler-and-will-not-be-emitted-with-normal-rust-code-4">This error code is internal to the compiler and will not be emitted with normal Rust code.</a></h4>
<p>The internal <code>rustc_allowed_through_unstable_modules</code> attribute must be used
on an item with a <code>stable</code> attribute.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0789"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOTE: both of these attributes are perma-unstable and should *never* be
//       used outside of the compiler and standard library.
#![feature(rustc_attrs)]
#![feature(staged_api)]

#![unstable(feature = &quot;foo_module&quot;, reason = &quot;...&quot;, issue = &quot;123&quot;)]

#[rustc_allowed_through_unstable_modules]
// #[stable(feature = &quot;foo&quot;, since = &quot;1.0&quot;)]
struct Foo;
// ^^^ error: `rustc_allowed_through_unstable_modules` attribute must be
//            paired with a `stable` attribute
<span class="boring">}</span></code></pre></pre>
<p>Typically when an item is marked with a <code>stable</code> attribute, the modules that
enclose the item must also be marked with <code>stable</code> attributes, otherwise the
item becomes <em>de facto</em> unstable. <code>#[rustc_allowed_through_unstable_modules]</code>
is a workaround which allows an item to &quot;escape&quot; its unstable parent modules.
This error occurs when an item is marked with
<code>#[rustc_allowed_through_unstable_modules]</code> but no supplementary <code>stable</code>
attribute exists. See <a href="https://github.com/rust-lang/rust/pull/99288">#99288</a>
for an example of <code>#[rustc_allowed_through_unstable_modules]</code> in use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0790"><a class="header" href="#error-code-e0790">Error code E0790</a></h1>
<p>You need to specify a specific implementation of the trait in order to call the
method.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0790"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Generator {
    fn create() -&gt; u32;
}

struct Impl;

impl Generator for Impl {
    fn create() -&gt; u32 { 1 }
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

let cont: u32 = Generator::create();
// error, impossible to choose one of Generator trait implementation
// Should it be Impl or AnotherImpl, maybe something else?
<span class="boring">}</span></code></pre></pre>
<p>This error can be solved by adding type annotations that provide the missing
information to the compiler. In this case, the solution is to use a concrete
type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Generator {
    fn create() -&gt; u32;
}

struct AnotherImpl;

impl Generator for AnotherImpl {
    fn create() -&gt; u32 { 2 }
}

let gen1 = AnotherImpl::create();

// if there are multiple methods with same name (different traits)
let gen2 = &lt;AnotherImpl as Generator&gt;::create();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0791"><a class="header" href="#error-code-e0791">Error code E0791</a></h1>
<p>Static variables with the <code>#[linkage]</code> attribute within external blocks
must have one of the following types, which are equivalent to a nullable
pointer in C:</p>
<ul>
<li>
<p><code>*mut T</code> or <code>*const T</code>, where <code>T</code> may be any type.</p>
</li>
<li>
<p>An enumerator type with no <code>#[repr]</code> attribute and with two variants, where
one of the variants has no fields, and the other has a single field of one of
the following non-nullable types:</p>
<ul>
<li>Reference type</li>
<li>Function pointer type</li>
</ul>
<p>The variants can appear in either order.</p>
</li>
</ul>
<p>For example, the following declaration is invalid:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0791"><span class="boring">#![allow(unused)]
</span>#![feature(linkage)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[linkage = &quot;extern_weak&quot;]
    static foo: i8;
}
<span class="boring">}</span></code></pre></pre>
<p>The following declarations are valid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(linkage)]

<span class="boring">fn main() {
</span>extern &quot;C&quot; {
    #[linkage = &quot;extern_weak&quot;]
    static foo: Option&lt;unsafe extern &quot;C&quot; fn()&gt;;

    #[linkage = &quot;extern_weak&quot;]
    static bar: Option&lt;&amp;'static i8&gt;;

    #[linkage = &quot;extern_weak&quot;]
    static baz: *mut i8;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0792"><a class="header" href="#error-code-e0792">Error code E0792</a></h1>
<p>A type alias impl trait can only have its hidden type assigned
when used fully generically (and within their defining scope).
This means</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0792"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]

<span class="boring">fn main() {
</span>type Foo&lt;T&gt; = impl std::fmt::Debug;

fn foo() -&gt; Foo&lt;u32&gt; {
    5u32
}
<span class="boring">}</span></code></pre></pre>
<p>is not accepted. If it were accepted, one could create unsound situations like</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0792">#![feature(type_alias_impl_trait)]

type Foo&lt;T&gt; = impl Default;

fn foo() -&gt; Foo&lt;u32&gt; {
    5u32
}

fn main() {
    let x = Foo::&lt;&amp;'static mut String&gt;::default();
}</code></pre></pre>
<p>Instead you need to make the function generic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]

<span class="boring">fn main() {
</span>type Foo&lt;T&gt; = impl std::fmt::Debug;

fn foo&lt;U&gt;() -&gt; Foo&lt;U&gt; {
    5u32
}
<span class="boring">}</span></code></pre></pre>
<p>This means that no matter the generic parameter to <code>foo</code>,
the hidden type will always be <code>u32</code>.
If you want to link the generic parameter to the hidden type,
you can do that, too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(type_alias_impl_trait)]

<span class="boring">fn main() {
</span>use std::fmt::Debug;

type Foo&lt;T: Debug&gt; = impl Debug;

fn foo&lt;U: Debug&gt;() -&gt; Foo&lt;U&gt; {
    Vec::&lt;U&gt;::new()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0793"><a class="header" href="#error-code-e0793">Error code E0793</a></h1>
<p>An unaligned references to a field of a <a href="https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers">packed</a> struct got created.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0793"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

unsafe {
    let foo = Foo { field1: 0, field2: 0 };
    // Accessing the field directly is fine.
    let val = foo.field1;
    // A reference to a packed field causes a error.
    let val = &amp;foo.field1; // ERROR
    // An implicit `&amp;` is added in format strings, causing the same error.
    println!(&quot;{}&quot;, foo.field1); // ERROR
}
<span class="boring">}</span></code></pre></pre>
<p>Creating a reference to an insufficiently aligned packed field is
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a> and therefore disallowed. Using an <code>unsafe</code> block does not
change anything about this. Instead, the code should do a copy of the data in
the packed field or use raw pointers and unaligned accesses.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

unsafe {
    let foo = Foo { field1: 0, field2: 0 };

    // Instead of a reference, we can create a raw pointer...
    let ptr = std::ptr::addr_of!(foo.field1);
    // ... and then (crucially!) access it in an explicitly unaligned way.
    let val = unsafe { ptr.read_unaligned() };
    // This would *NOT* be correct:
    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!

    // For formatting, we can create a copy to avoid the direct reference.
    let copy = foo.field1;
    println!(&quot;{}&quot;, copy);
    // Creating a copy can be written in a single line with curly braces.
    // (This is equivalent to the two lines above.)
    println!(&quot;{}&quot;, { foo.field1 });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-information-2"><a class="header" href="#additional-information-2">Additional information</a></h3>
<p>Note that this error is specifically about <em>references</em> to packed fields.
Direct by-value access of those fields is fine, since then the compiler has
enough information to generate the correct kind of access.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/82523">issue #82523</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-code-e0794"><a class="header" href="#error-code-e0794">Error code E0794</a></h1>
<p>A lifetime parameter of a function definition is called <em>late-bound</em> if it both:</p>
<ol>
<li>appears in an argument type</li>
<li>does not appear in a generic type constraint</li>
</ol>
<p>You cannot specify lifetime arguments for late-bound lifetime parameters.</p>
<p>Erroneous code example:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0794"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str { x }
let _ = foo::&lt;'static&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The type of a concrete instance of a generic function is universally quantified
over late-bound lifetime parameters. This is because we want the function to
work for any lifetime substituted for the late-bound lifetime parameter, no
matter where the function is called. Consequently, it doesn't make sense to
specify arguments for late-bound lifetime parameters, since they are not
resolved until the function's call site(s).</p>
<p>To fix the issue, remove the specified lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str { x }
let _ = foo;
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-information-3"><a class="header" href="#additional-information-3">Additional information</a></h3>
<p>Lifetime parameters that are not late-bound are called <em>early-bound</em>.
Confusion may arise from the fact that late-bound and early-bound
lifetime parameters are declared the same way in function definitions.
When referring to a function pointer type, universal quantification over
late-bound lifetime parameters can be made explicit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait BarTrait&lt;'a&gt; {}

struct Bar&lt;'a&gt; {
    s: &amp;'a str
}

impl&lt;'a&gt; BarTrait&lt;'a&gt; for Bar&lt;'a&gt; {}

fn bar&lt;'a, 'b, T&gt;(x: &amp;'a str, _t: T) -&gt; &amp;'a str
where T: BarTrait&lt;'b&gt;
{
    x
}

let bar_fn: for&lt;'a&gt; fn(&amp;'a str, Bar&lt;'static&gt;) -&gt; &amp;'a str = bar; // OK
let bar_fn2 = bar::&lt;'static, Bar&gt;; // Not allowed
let bar_fn3 = bar::&lt;Bar&gt;; // OK
<span class="boring">}</span></code></pre></pre>
<p>In the definition of <code>bar</code>, the lifetime parameter <code>'a</code> is late-bound, while
<code>'b</code> is early-bound. This is reflected in the type annotation for <code>bar_fn</code>,
where <code>'a</code> is universally quantified and <code>'b</code> is substituted by a specific
lifetime. It is not allowed to explicitly specify early-bound lifetime
arguments when late-bound lifetime parameters are present (as for <code>bar_fn2</code>,
see <a href="https://github.com/rust-lang/rust/issues/42868">issue #42868</a>), although
the types that are constrained by early-bound parameters can be specified (as
for <code>bar_fn3</code>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="error-index.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
