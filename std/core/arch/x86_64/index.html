<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="特定于平台的用于 `x86_64` 平台的内部函数。"><title>core::arch::x86_64 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../core/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module x86_64</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">core</a>::<wbr><a href="../index.html">arch</a>::<wbr><a class="mod" href="#">x86_64</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span> · <a class="srclink" href="../../../src/core/stdarch/crates/core_arch/src/mod.rs.html#34">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><span class="item-info"><div class="stab portability">Available on <strong>x86-64</strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>特定于平台的用于 <code>x86_64</code> 平台的内部函数。</p>
<p>有关更多详细信息，请参见 <a href="../index.html">模块级文档</a>。</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.__m128bh.html" title="struct core::arch::x86_64::__m128bh">__m128bh</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">128 位宽的一组 8 个 <code>u16</code> 类型，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m256bh.html" title="struct core::arch::x86_64::__m256bh">__m256bh</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">256 位宽的 16 种 <code>u16</code> 类型集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m512.html" title="struct core::arch::x86_64::__m512">__m512</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">512 位宽的十六种 <code>f32</code> 类型集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m512bh.html" title="struct core::arch::x86_64::__m512bh">__m512bh</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">512 位宽的 32 种 <code>u16</code> 类型集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m512d.html" title="struct core::arch::x86_64::__m512d">__m512d</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">八种 <code>f64</code> 类型的 512 位宽集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m512i.html" title="struct core::arch::x86_64::__m512i">__m512i</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">512 位宽的整数 vector 类型，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.CpuidResult.html" title="struct core::arch::x86_64::CpuidResult">CpuidResult</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>cpuid</code> 指令的结果。</div></li><li><div class="item-name"><a class="struct" href="struct.__m128.html" title="struct core::arch::x86_64::__m128">__m128</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">四种 <code>f32</code> 类型的 128 位宽集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m128d.html" title="struct core::arch::x86_64::__m128d">__m128d</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">两种 <code>f64</code> 类型的 128 位宽集，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m128i.html" title="struct core::arch::x86_64::__m128i">__m128i</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">128 位宽的整数 vector 类型，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m256.html" title="struct core::arch::x86_64::__m256">__m256</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">256 位宽的八种 <code>f32</code> 类型的集合，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m256d.html" title="struct core::arch::x86_64::__m256d">__m256d</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">256 位宽的四种 <code>f64</code> 类型的集合，特定于 x86</div></li><li><div class="item-name"><a class="struct" href="struct.__m256i.html" title="struct core::arch::x86_64::__m256i">__m256i</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">256 位宽的整数 vector 类型，特定于 x86</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_EQ.html" title="constant core::arch::x86_64::_MM_CMPINT_EQ">_MM_CMPINT_EQ</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">Equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_FALSE.html" title="constant core::arch::x86_64::_MM_CMPINT_FALSE">_MM_CMPINT_FALSE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">False</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_LE.html" title="constant core::arch::x86_64::_MM_CMPINT_LE">_MM_CMPINT_LE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">Less-than-or-equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_LT.html" title="constant core::arch::x86_64::_MM_CMPINT_LT">_MM_CMPINT_LT</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">Less-than</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NE.html" title="constant core::arch::x86_64::_MM_CMPINT_NE">_MM_CMPINT_NE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">Not-equal</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NLE.html" title="constant core::arch::x86_64::_MM_CMPINT_NLE">_MM_CMPINT_NLE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不小于等于</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_NLT.html" title="constant core::arch::x86_64::_MM_CMPINT_NLT">_MM_CMPINT_NLT</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不小于</div></li><li><div class="item-name"><a class="constant" href="constant._MM_CMPINT_TRUE.html" title="constant core::arch::x86_64::_MM_CMPINT_TRUE">_MM_CMPINT_TRUE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">True</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_1_2.html" title="constant core::arch::x86_64::_MM_MANT_NORM_1_2">_MM_MANT_NORM_1_2</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">区间 [1, 2)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P5_1.html" title="constant core::arch::x86_64::_MM_MANT_NORM_P5_1">_MM_MANT_NORM_P5_1</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">区间 [0.5, 1)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P5_2.html" title="constant core::arch::x86_64::_MM_MANT_NORM_P5_2">_MM_MANT_NORM_P5_2</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">区间 [0.5, 2)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_NORM_P75_1P5.html" title="constant core::arch::x86_64::_MM_MANT_NORM_P75_1P5">_MM_MANT_NORM_P75_1P5</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">间隔 [0.75，1.5)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_NAN.html" title="constant core::arch::x86_64::_MM_MANT_SIGN_NAN">_MM_MANT_SIGN_NAN</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">如果 sign(SRC) =1，则 DEST=NaN</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_SRC.html" title="constant core::arch::x86_64::_MM_MANT_SIGN_SRC">_MM_MANT_SIGN_SRC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">sign = sign(SRC)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MANT_SIGN_ZERO.html" title="constant core::arch::x86_64::_MM_MANT_SIGN_ZERO">_MM_MANT_SIGN_ZERO</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">sign = 0</div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAA.html" title="constant core::arch::x86_64::_MM_PERM_AAAA">_MM_PERM_AAAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAB.html" title="constant core::arch::x86_64::_MM_PERM_AAAB">_MM_PERM_AAAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAC.html" title="constant core::arch::x86_64::_MM_PERM_AAAC">_MM_PERM_AAAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AAAD.html" title="constant core::arch::x86_64::_MM_PERM_AAAD">_MM_PERM_AAAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABA.html" title="constant core::arch::x86_64::_MM_PERM_AABA">_MM_PERM_AABA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABB.html" title="constant core::arch::x86_64::_MM_PERM_AABB">_MM_PERM_AABB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABC.html" title="constant core::arch::x86_64::_MM_PERM_AABC">_MM_PERM_AABC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AABD.html" title="constant core::arch::x86_64::_MM_PERM_AABD">_MM_PERM_AABD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACA.html" title="constant core::arch::x86_64::_MM_PERM_AACA">_MM_PERM_AACA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACB.html" title="constant core::arch::x86_64::_MM_PERM_AACB">_MM_PERM_AACB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACC.html" title="constant core::arch::x86_64::_MM_PERM_AACC">_MM_PERM_AACC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AACD.html" title="constant core::arch::x86_64::_MM_PERM_AACD">_MM_PERM_AACD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADA.html" title="constant core::arch::x86_64::_MM_PERM_AADA">_MM_PERM_AADA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADB.html" title="constant core::arch::x86_64::_MM_PERM_AADB">_MM_PERM_AADB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADC.html" title="constant core::arch::x86_64::_MM_PERM_AADC">_MM_PERM_AADC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_AADD.html" title="constant core::arch::x86_64::_MM_PERM_AADD">_MM_PERM_AADD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAA.html" title="constant core::arch::x86_64::_MM_PERM_ABAA">_MM_PERM_ABAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAB.html" title="constant core::arch::x86_64::_MM_PERM_ABAB">_MM_PERM_ABAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAC.html" title="constant core::arch::x86_64::_MM_PERM_ABAC">_MM_PERM_ABAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABAD.html" title="constant core::arch::x86_64::_MM_PERM_ABAD">_MM_PERM_ABAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBA.html" title="constant core::arch::x86_64::_MM_PERM_ABBA">_MM_PERM_ABBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBB.html" title="constant core::arch::x86_64::_MM_PERM_ABBB">_MM_PERM_ABBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBC.html" title="constant core::arch::x86_64::_MM_PERM_ABBC">_MM_PERM_ABBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABBD.html" title="constant core::arch::x86_64::_MM_PERM_ABBD">_MM_PERM_ABBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCA.html" title="constant core::arch::x86_64::_MM_PERM_ABCA">_MM_PERM_ABCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCB.html" title="constant core::arch::x86_64::_MM_PERM_ABCB">_MM_PERM_ABCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCC.html" title="constant core::arch::x86_64::_MM_PERM_ABCC">_MM_PERM_ABCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABCD.html" title="constant core::arch::x86_64::_MM_PERM_ABCD">_MM_PERM_ABCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDA.html" title="constant core::arch::x86_64::_MM_PERM_ABDA">_MM_PERM_ABDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDB.html" title="constant core::arch::x86_64::_MM_PERM_ABDB">_MM_PERM_ABDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDC.html" title="constant core::arch::x86_64::_MM_PERM_ABDC">_MM_PERM_ABDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ABDD.html" title="constant core::arch::x86_64::_MM_PERM_ABDD">_MM_PERM_ABDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAA.html" title="constant core::arch::x86_64::_MM_PERM_ACAA">_MM_PERM_ACAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAB.html" title="constant core::arch::x86_64::_MM_PERM_ACAB">_MM_PERM_ACAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAC.html" title="constant core::arch::x86_64::_MM_PERM_ACAC">_MM_PERM_ACAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACAD.html" title="constant core::arch::x86_64::_MM_PERM_ACAD">_MM_PERM_ACAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBA.html" title="constant core::arch::x86_64::_MM_PERM_ACBA">_MM_PERM_ACBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBB.html" title="constant core::arch::x86_64::_MM_PERM_ACBB">_MM_PERM_ACBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBC.html" title="constant core::arch::x86_64::_MM_PERM_ACBC">_MM_PERM_ACBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACBD.html" title="constant core::arch::x86_64::_MM_PERM_ACBD">_MM_PERM_ACBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCA.html" title="constant core::arch::x86_64::_MM_PERM_ACCA">_MM_PERM_ACCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCB.html" title="constant core::arch::x86_64::_MM_PERM_ACCB">_MM_PERM_ACCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCC.html" title="constant core::arch::x86_64::_MM_PERM_ACCC">_MM_PERM_ACCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACCD.html" title="constant core::arch::x86_64::_MM_PERM_ACCD">_MM_PERM_ACCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDA.html" title="constant core::arch::x86_64::_MM_PERM_ACDA">_MM_PERM_ACDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDB.html" title="constant core::arch::x86_64::_MM_PERM_ACDB">_MM_PERM_ACDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDC.html" title="constant core::arch::x86_64::_MM_PERM_ACDC">_MM_PERM_ACDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ACDD.html" title="constant core::arch::x86_64::_MM_PERM_ACDD">_MM_PERM_ACDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAA.html" title="constant core::arch::x86_64::_MM_PERM_ADAA">_MM_PERM_ADAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAB.html" title="constant core::arch::x86_64::_MM_PERM_ADAB">_MM_PERM_ADAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAC.html" title="constant core::arch::x86_64::_MM_PERM_ADAC">_MM_PERM_ADAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADAD.html" title="constant core::arch::x86_64::_MM_PERM_ADAD">_MM_PERM_ADAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBA.html" title="constant core::arch::x86_64::_MM_PERM_ADBA">_MM_PERM_ADBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBB.html" title="constant core::arch::x86_64::_MM_PERM_ADBB">_MM_PERM_ADBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBC.html" title="constant core::arch::x86_64::_MM_PERM_ADBC">_MM_PERM_ADBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADBD.html" title="constant core::arch::x86_64::_MM_PERM_ADBD">_MM_PERM_ADBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCA.html" title="constant core::arch::x86_64::_MM_PERM_ADCA">_MM_PERM_ADCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCB.html" title="constant core::arch::x86_64::_MM_PERM_ADCB">_MM_PERM_ADCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCC.html" title="constant core::arch::x86_64::_MM_PERM_ADCC">_MM_PERM_ADCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADCD.html" title="constant core::arch::x86_64::_MM_PERM_ADCD">_MM_PERM_ADCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDA.html" title="constant core::arch::x86_64::_MM_PERM_ADDA">_MM_PERM_ADDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDB.html" title="constant core::arch::x86_64::_MM_PERM_ADDB">_MM_PERM_ADDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDC.html" title="constant core::arch::x86_64::_MM_PERM_ADDC">_MM_PERM_ADDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_ADDD.html" title="constant core::arch::x86_64::_MM_PERM_ADDD">_MM_PERM_ADDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAA.html" title="constant core::arch::x86_64::_MM_PERM_BAAA">_MM_PERM_BAAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAB.html" title="constant core::arch::x86_64::_MM_PERM_BAAB">_MM_PERM_BAAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAC.html" title="constant core::arch::x86_64::_MM_PERM_BAAC">_MM_PERM_BAAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BAAD.html" title="constant core::arch::x86_64::_MM_PERM_BAAD">_MM_PERM_BAAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABA.html" title="constant core::arch::x86_64::_MM_PERM_BABA">_MM_PERM_BABA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABB.html" title="constant core::arch::x86_64::_MM_PERM_BABB">_MM_PERM_BABB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABC.html" title="constant core::arch::x86_64::_MM_PERM_BABC">_MM_PERM_BABC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BABD.html" title="constant core::arch::x86_64::_MM_PERM_BABD">_MM_PERM_BABD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACA.html" title="constant core::arch::x86_64::_MM_PERM_BACA">_MM_PERM_BACA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACB.html" title="constant core::arch::x86_64::_MM_PERM_BACB">_MM_PERM_BACB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACC.html" title="constant core::arch::x86_64::_MM_PERM_BACC">_MM_PERM_BACC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BACD.html" title="constant core::arch::x86_64::_MM_PERM_BACD">_MM_PERM_BACD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADA.html" title="constant core::arch::x86_64::_MM_PERM_BADA">_MM_PERM_BADA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADB.html" title="constant core::arch::x86_64::_MM_PERM_BADB">_MM_PERM_BADB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADC.html" title="constant core::arch::x86_64::_MM_PERM_BADC">_MM_PERM_BADC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BADD.html" title="constant core::arch::x86_64::_MM_PERM_BADD">_MM_PERM_BADD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAA.html" title="constant core::arch::x86_64::_MM_PERM_BBAA">_MM_PERM_BBAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAB.html" title="constant core::arch::x86_64::_MM_PERM_BBAB">_MM_PERM_BBAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAC.html" title="constant core::arch::x86_64::_MM_PERM_BBAC">_MM_PERM_BBAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBAD.html" title="constant core::arch::x86_64::_MM_PERM_BBAD">_MM_PERM_BBAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBA.html" title="constant core::arch::x86_64::_MM_PERM_BBBA">_MM_PERM_BBBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBB.html" title="constant core::arch::x86_64::_MM_PERM_BBBB">_MM_PERM_BBBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBC.html" title="constant core::arch::x86_64::_MM_PERM_BBBC">_MM_PERM_BBBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBBD.html" title="constant core::arch::x86_64::_MM_PERM_BBBD">_MM_PERM_BBBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCA.html" title="constant core::arch::x86_64::_MM_PERM_BBCA">_MM_PERM_BBCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCB.html" title="constant core::arch::x86_64::_MM_PERM_BBCB">_MM_PERM_BBCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCC.html" title="constant core::arch::x86_64::_MM_PERM_BBCC">_MM_PERM_BBCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBCD.html" title="constant core::arch::x86_64::_MM_PERM_BBCD">_MM_PERM_BBCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDA.html" title="constant core::arch::x86_64::_MM_PERM_BBDA">_MM_PERM_BBDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDB.html" title="constant core::arch::x86_64::_MM_PERM_BBDB">_MM_PERM_BBDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDC.html" title="constant core::arch::x86_64::_MM_PERM_BBDC">_MM_PERM_BBDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BBDD.html" title="constant core::arch::x86_64::_MM_PERM_BBDD">_MM_PERM_BBDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAA.html" title="constant core::arch::x86_64::_MM_PERM_BCAA">_MM_PERM_BCAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAB.html" title="constant core::arch::x86_64::_MM_PERM_BCAB">_MM_PERM_BCAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAC.html" title="constant core::arch::x86_64::_MM_PERM_BCAC">_MM_PERM_BCAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCAD.html" title="constant core::arch::x86_64::_MM_PERM_BCAD">_MM_PERM_BCAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBA.html" title="constant core::arch::x86_64::_MM_PERM_BCBA">_MM_PERM_BCBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBB.html" title="constant core::arch::x86_64::_MM_PERM_BCBB">_MM_PERM_BCBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBC.html" title="constant core::arch::x86_64::_MM_PERM_BCBC">_MM_PERM_BCBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCBD.html" title="constant core::arch::x86_64::_MM_PERM_BCBD">_MM_PERM_BCBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCA.html" title="constant core::arch::x86_64::_MM_PERM_BCCA">_MM_PERM_BCCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCB.html" title="constant core::arch::x86_64::_MM_PERM_BCCB">_MM_PERM_BCCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCC.html" title="constant core::arch::x86_64::_MM_PERM_BCCC">_MM_PERM_BCCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCCD.html" title="constant core::arch::x86_64::_MM_PERM_BCCD">_MM_PERM_BCCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDA.html" title="constant core::arch::x86_64::_MM_PERM_BCDA">_MM_PERM_BCDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDB.html" title="constant core::arch::x86_64::_MM_PERM_BCDB">_MM_PERM_BCDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDC.html" title="constant core::arch::x86_64::_MM_PERM_BCDC">_MM_PERM_BCDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BCDD.html" title="constant core::arch::x86_64::_MM_PERM_BCDD">_MM_PERM_BCDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAA.html" title="constant core::arch::x86_64::_MM_PERM_BDAA">_MM_PERM_BDAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAB.html" title="constant core::arch::x86_64::_MM_PERM_BDAB">_MM_PERM_BDAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAC.html" title="constant core::arch::x86_64::_MM_PERM_BDAC">_MM_PERM_BDAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDAD.html" title="constant core::arch::x86_64::_MM_PERM_BDAD">_MM_PERM_BDAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBA.html" title="constant core::arch::x86_64::_MM_PERM_BDBA">_MM_PERM_BDBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBB.html" title="constant core::arch::x86_64::_MM_PERM_BDBB">_MM_PERM_BDBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBC.html" title="constant core::arch::x86_64::_MM_PERM_BDBC">_MM_PERM_BDBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDBD.html" title="constant core::arch::x86_64::_MM_PERM_BDBD">_MM_PERM_BDBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCA.html" title="constant core::arch::x86_64::_MM_PERM_BDCA">_MM_PERM_BDCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCB.html" title="constant core::arch::x86_64::_MM_PERM_BDCB">_MM_PERM_BDCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCC.html" title="constant core::arch::x86_64::_MM_PERM_BDCC">_MM_PERM_BDCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDCD.html" title="constant core::arch::x86_64::_MM_PERM_BDCD">_MM_PERM_BDCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDA.html" title="constant core::arch::x86_64::_MM_PERM_BDDA">_MM_PERM_BDDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDB.html" title="constant core::arch::x86_64::_MM_PERM_BDDB">_MM_PERM_BDDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDC.html" title="constant core::arch::x86_64::_MM_PERM_BDDC">_MM_PERM_BDDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_BDDD.html" title="constant core::arch::x86_64::_MM_PERM_BDDD">_MM_PERM_BDDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAA.html" title="constant core::arch::x86_64::_MM_PERM_CAAA">_MM_PERM_CAAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAB.html" title="constant core::arch::x86_64::_MM_PERM_CAAB">_MM_PERM_CAAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAC.html" title="constant core::arch::x86_64::_MM_PERM_CAAC">_MM_PERM_CAAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CAAD.html" title="constant core::arch::x86_64::_MM_PERM_CAAD">_MM_PERM_CAAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABA.html" title="constant core::arch::x86_64::_MM_PERM_CABA">_MM_PERM_CABA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABB.html" title="constant core::arch::x86_64::_MM_PERM_CABB">_MM_PERM_CABB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABC.html" title="constant core::arch::x86_64::_MM_PERM_CABC">_MM_PERM_CABC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CABD.html" title="constant core::arch::x86_64::_MM_PERM_CABD">_MM_PERM_CABD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACA.html" title="constant core::arch::x86_64::_MM_PERM_CACA">_MM_PERM_CACA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACB.html" title="constant core::arch::x86_64::_MM_PERM_CACB">_MM_PERM_CACB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACC.html" title="constant core::arch::x86_64::_MM_PERM_CACC">_MM_PERM_CACC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CACD.html" title="constant core::arch::x86_64::_MM_PERM_CACD">_MM_PERM_CACD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADA.html" title="constant core::arch::x86_64::_MM_PERM_CADA">_MM_PERM_CADA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADB.html" title="constant core::arch::x86_64::_MM_PERM_CADB">_MM_PERM_CADB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADC.html" title="constant core::arch::x86_64::_MM_PERM_CADC">_MM_PERM_CADC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CADD.html" title="constant core::arch::x86_64::_MM_PERM_CADD">_MM_PERM_CADD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAA.html" title="constant core::arch::x86_64::_MM_PERM_CBAA">_MM_PERM_CBAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAB.html" title="constant core::arch::x86_64::_MM_PERM_CBAB">_MM_PERM_CBAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAC.html" title="constant core::arch::x86_64::_MM_PERM_CBAC">_MM_PERM_CBAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBAD.html" title="constant core::arch::x86_64::_MM_PERM_CBAD">_MM_PERM_CBAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBA.html" title="constant core::arch::x86_64::_MM_PERM_CBBA">_MM_PERM_CBBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBB.html" title="constant core::arch::x86_64::_MM_PERM_CBBB">_MM_PERM_CBBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBC.html" title="constant core::arch::x86_64::_MM_PERM_CBBC">_MM_PERM_CBBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBBD.html" title="constant core::arch::x86_64::_MM_PERM_CBBD">_MM_PERM_CBBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCA.html" title="constant core::arch::x86_64::_MM_PERM_CBCA">_MM_PERM_CBCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCB.html" title="constant core::arch::x86_64::_MM_PERM_CBCB">_MM_PERM_CBCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCC.html" title="constant core::arch::x86_64::_MM_PERM_CBCC">_MM_PERM_CBCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBCD.html" title="constant core::arch::x86_64::_MM_PERM_CBCD">_MM_PERM_CBCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDA.html" title="constant core::arch::x86_64::_MM_PERM_CBDA">_MM_PERM_CBDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDB.html" title="constant core::arch::x86_64::_MM_PERM_CBDB">_MM_PERM_CBDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDC.html" title="constant core::arch::x86_64::_MM_PERM_CBDC">_MM_PERM_CBDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CBDD.html" title="constant core::arch::x86_64::_MM_PERM_CBDD">_MM_PERM_CBDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAA.html" title="constant core::arch::x86_64::_MM_PERM_CCAA">_MM_PERM_CCAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAB.html" title="constant core::arch::x86_64::_MM_PERM_CCAB">_MM_PERM_CCAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAC.html" title="constant core::arch::x86_64::_MM_PERM_CCAC">_MM_PERM_CCAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCAD.html" title="constant core::arch::x86_64::_MM_PERM_CCAD">_MM_PERM_CCAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBA.html" title="constant core::arch::x86_64::_MM_PERM_CCBA">_MM_PERM_CCBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBB.html" title="constant core::arch::x86_64::_MM_PERM_CCBB">_MM_PERM_CCBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBC.html" title="constant core::arch::x86_64::_MM_PERM_CCBC">_MM_PERM_CCBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCBD.html" title="constant core::arch::x86_64::_MM_PERM_CCBD">_MM_PERM_CCBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCA.html" title="constant core::arch::x86_64::_MM_PERM_CCCA">_MM_PERM_CCCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCB.html" title="constant core::arch::x86_64::_MM_PERM_CCCB">_MM_PERM_CCCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCC.html" title="constant core::arch::x86_64::_MM_PERM_CCCC">_MM_PERM_CCCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCCD.html" title="constant core::arch::x86_64::_MM_PERM_CCCD">_MM_PERM_CCCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDA.html" title="constant core::arch::x86_64::_MM_PERM_CCDA">_MM_PERM_CCDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDB.html" title="constant core::arch::x86_64::_MM_PERM_CCDB">_MM_PERM_CCDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDC.html" title="constant core::arch::x86_64::_MM_PERM_CCDC">_MM_PERM_CCDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CCDD.html" title="constant core::arch::x86_64::_MM_PERM_CCDD">_MM_PERM_CCDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAA.html" title="constant core::arch::x86_64::_MM_PERM_CDAA">_MM_PERM_CDAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAB.html" title="constant core::arch::x86_64::_MM_PERM_CDAB">_MM_PERM_CDAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAC.html" title="constant core::arch::x86_64::_MM_PERM_CDAC">_MM_PERM_CDAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDAD.html" title="constant core::arch::x86_64::_MM_PERM_CDAD">_MM_PERM_CDAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBA.html" title="constant core::arch::x86_64::_MM_PERM_CDBA">_MM_PERM_CDBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBB.html" title="constant core::arch::x86_64::_MM_PERM_CDBB">_MM_PERM_CDBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBC.html" title="constant core::arch::x86_64::_MM_PERM_CDBC">_MM_PERM_CDBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDBD.html" title="constant core::arch::x86_64::_MM_PERM_CDBD">_MM_PERM_CDBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCA.html" title="constant core::arch::x86_64::_MM_PERM_CDCA">_MM_PERM_CDCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCB.html" title="constant core::arch::x86_64::_MM_PERM_CDCB">_MM_PERM_CDCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCC.html" title="constant core::arch::x86_64::_MM_PERM_CDCC">_MM_PERM_CDCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDCD.html" title="constant core::arch::x86_64::_MM_PERM_CDCD">_MM_PERM_CDCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDA.html" title="constant core::arch::x86_64::_MM_PERM_CDDA">_MM_PERM_CDDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDB.html" title="constant core::arch::x86_64::_MM_PERM_CDDB">_MM_PERM_CDDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDC.html" title="constant core::arch::x86_64::_MM_PERM_CDDC">_MM_PERM_CDDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_CDDD.html" title="constant core::arch::x86_64::_MM_PERM_CDDD">_MM_PERM_CDDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAA.html" title="constant core::arch::x86_64::_MM_PERM_DAAA">_MM_PERM_DAAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAB.html" title="constant core::arch::x86_64::_MM_PERM_DAAB">_MM_PERM_DAAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAC.html" title="constant core::arch::x86_64::_MM_PERM_DAAC">_MM_PERM_DAAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DAAD.html" title="constant core::arch::x86_64::_MM_PERM_DAAD">_MM_PERM_DAAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABA.html" title="constant core::arch::x86_64::_MM_PERM_DABA">_MM_PERM_DABA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABB.html" title="constant core::arch::x86_64::_MM_PERM_DABB">_MM_PERM_DABB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABC.html" title="constant core::arch::x86_64::_MM_PERM_DABC">_MM_PERM_DABC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DABD.html" title="constant core::arch::x86_64::_MM_PERM_DABD">_MM_PERM_DABD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACA.html" title="constant core::arch::x86_64::_MM_PERM_DACA">_MM_PERM_DACA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACB.html" title="constant core::arch::x86_64::_MM_PERM_DACB">_MM_PERM_DACB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACC.html" title="constant core::arch::x86_64::_MM_PERM_DACC">_MM_PERM_DACC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DACD.html" title="constant core::arch::x86_64::_MM_PERM_DACD">_MM_PERM_DACD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADA.html" title="constant core::arch::x86_64::_MM_PERM_DADA">_MM_PERM_DADA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADB.html" title="constant core::arch::x86_64::_MM_PERM_DADB">_MM_PERM_DADB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADC.html" title="constant core::arch::x86_64::_MM_PERM_DADC">_MM_PERM_DADC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DADD.html" title="constant core::arch::x86_64::_MM_PERM_DADD">_MM_PERM_DADD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAA.html" title="constant core::arch::x86_64::_MM_PERM_DBAA">_MM_PERM_DBAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAB.html" title="constant core::arch::x86_64::_MM_PERM_DBAB">_MM_PERM_DBAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAC.html" title="constant core::arch::x86_64::_MM_PERM_DBAC">_MM_PERM_DBAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBAD.html" title="constant core::arch::x86_64::_MM_PERM_DBAD">_MM_PERM_DBAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBA.html" title="constant core::arch::x86_64::_MM_PERM_DBBA">_MM_PERM_DBBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBB.html" title="constant core::arch::x86_64::_MM_PERM_DBBB">_MM_PERM_DBBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBC.html" title="constant core::arch::x86_64::_MM_PERM_DBBC">_MM_PERM_DBBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBBD.html" title="constant core::arch::x86_64::_MM_PERM_DBBD">_MM_PERM_DBBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCA.html" title="constant core::arch::x86_64::_MM_PERM_DBCA">_MM_PERM_DBCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCB.html" title="constant core::arch::x86_64::_MM_PERM_DBCB">_MM_PERM_DBCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCC.html" title="constant core::arch::x86_64::_MM_PERM_DBCC">_MM_PERM_DBCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBCD.html" title="constant core::arch::x86_64::_MM_PERM_DBCD">_MM_PERM_DBCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDA.html" title="constant core::arch::x86_64::_MM_PERM_DBDA">_MM_PERM_DBDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDB.html" title="constant core::arch::x86_64::_MM_PERM_DBDB">_MM_PERM_DBDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDC.html" title="constant core::arch::x86_64::_MM_PERM_DBDC">_MM_PERM_DBDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DBDD.html" title="constant core::arch::x86_64::_MM_PERM_DBDD">_MM_PERM_DBDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAA.html" title="constant core::arch::x86_64::_MM_PERM_DCAA">_MM_PERM_DCAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAB.html" title="constant core::arch::x86_64::_MM_PERM_DCAB">_MM_PERM_DCAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAC.html" title="constant core::arch::x86_64::_MM_PERM_DCAC">_MM_PERM_DCAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCAD.html" title="constant core::arch::x86_64::_MM_PERM_DCAD">_MM_PERM_DCAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBA.html" title="constant core::arch::x86_64::_MM_PERM_DCBA">_MM_PERM_DCBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBB.html" title="constant core::arch::x86_64::_MM_PERM_DCBB">_MM_PERM_DCBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBC.html" title="constant core::arch::x86_64::_MM_PERM_DCBC">_MM_PERM_DCBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCBD.html" title="constant core::arch::x86_64::_MM_PERM_DCBD">_MM_PERM_DCBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCA.html" title="constant core::arch::x86_64::_MM_PERM_DCCA">_MM_PERM_DCCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCB.html" title="constant core::arch::x86_64::_MM_PERM_DCCB">_MM_PERM_DCCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCC.html" title="constant core::arch::x86_64::_MM_PERM_DCCC">_MM_PERM_DCCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCCD.html" title="constant core::arch::x86_64::_MM_PERM_DCCD">_MM_PERM_DCCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDA.html" title="constant core::arch::x86_64::_MM_PERM_DCDA">_MM_PERM_DCDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDB.html" title="constant core::arch::x86_64::_MM_PERM_DCDB">_MM_PERM_DCDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDC.html" title="constant core::arch::x86_64::_MM_PERM_DCDC">_MM_PERM_DCDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DCDD.html" title="constant core::arch::x86_64::_MM_PERM_DCDD">_MM_PERM_DCDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAA.html" title="constant core::arch::x86_64::_MM_PERM_DDAA">_MM_PERM_DDAA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAB.html" title="constant core::arch::x86_64::_MM_PERM_DDAB">_MM_PERM_DDAB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAC.html" title="constant core::arch::x86_64::_MM_PERM_DDAC">_MM_PERM_DDAC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDAD.html" title="constant core::arch::x86_64::_MM_PERM_DDAD">_MM_PERM_DDAD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBA.html" title="constant core::arch::x86_64::_MM_PERM_DDBA">_MM_PERM_DDBA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBB.html" title="constant core::arch::x86_64::_MM_PERM_DDBB">_MM_PERM_DDBB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBC.html" title="constant core::arch::x86_64::_MM_PERM_DDBC">_MM_PERM_DDBC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDBD.html" title="constant core::arch::x86_64::_MM_PERM_DDBD">_MM_PERM_DDBD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCA.html" title="constant core::arch::x86_64::_MM_PERM_DDCA">_MM_PERM_DDCA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCB.html" title="constant core::arch::x86_64::_MM_PERM_DDCB">_MM_PERM_DDCB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCC.html" title="constant core::arch::x86_64::_MM_PERM_DDCC">_MM_PERM_DDCC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDCD.html" title="constant core::arch::x86_64::_MM_PERM_DDCD">_MM_PERM_DDCD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDA.html" title="constant core::arch::x86_64::_MM_PERM_DDDA">_MM_PERM_DDDA</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDB.html" title="constant core::arch::x86_64::_MM_PERM_DDDB">_MM_PERM_DDDB</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDC.html" title="constant core::arch::x86_64::_MM_PERM_DDDC">_MM_PERM_DDDC</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._MM_PERM_DDDD.html" title="constant core::arch::x86_64::_MM_PERM_DDDD">_MM_PERM_DDDD</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_CAPACITY.html" title="constant core::arch::x86_64::_XABORT_CAPACITY">_XABORT_CAPACITY</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">事务中止，因为事务使用了过多的内存。</div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_CONFLICT.html" title="constant core::arch::x86_64::_XABORT_CONFLICT">_XABORT_CONFLICT</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">由于与另一个线程发生内存冲突而导致事务中止。</div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_DEBUG.html" title="constant core::arch::x86_64::_XABORT_DEBUG">_XABORT_DEBUG</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">事务由于调试陷阱而中止。</div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_EXPLICIT.html" title="constant core::arch::x86_64::_XABORT_EXPLICIT">_XABORT_EXPLICIT</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">使用 xabort 显式中止了事务。
传递给 xabort 的参数可用于 <code>_xabort_code(status)</code>。</div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_NESTED.html" title="constant core::arch::x86_64::_XABORT_NESTED">_XABORT_NESTED</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">内部嵌套事务中的事务中止。</div></li><li><div class="item-name"><a class="constant" href="constant._XABORT_RETRY.html" title="constant core::arch::x86_64::_XABORT_RETRY">_XABORT_RETRY</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">事务重试是可能的。</div></li><li><div class="item-name"><a class="constant" href="constant._XBEGIN_STARTED.html" title="constant core::arch::x86_64::_XBEGIN_STARTED">_XBEGIN_STARTED</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">事务成功开始。</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_EQ_OQ.html" title="constant core::arch::x86_64::_CMP_EQ_OQ">_CMP_EQ_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">相等 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_EQ_OS.html" title="constant core::arch::x86_64::_CMP_EQ_OS">_CMP_EQ_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">相等 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_EQ_UQ.html" title="constant core::arch::x86_64::_CMP_EQ_UQ">_CMP_EQ_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">相等 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_EQ_US.html" title="constant core::arch::x86_64::_CMP_EQ_US">_CMP_EQ_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">相等 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_FALSE_OQ.html" title="constant core::arch::x86_64::_CMP_FALSE_OQ">_CMP_FALSE_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">错误 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_FALSE_OS.html" title="constant core::arch::x86_64::_CMP_FALSE_OS">_CMP_FALSE_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">错误 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_GE_OQ.html" title="constant core::arch::x86_64::_CMP_GE_OQ">_CMP_GE_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">大于或等于 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_GE_OS.html" title="constant core::arch::x86_64::_CMP_GE_OS">_CMP_GE_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">大于或等于 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_GT_OQ.html" title="constant core::arch::x86_64::_CMP_GT_OQ">_CMP_GT_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">大于 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_GT_OS.html" title="constant core::arch::x86_64::_CMP_GT_OS">_CMP_GT_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">大于 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_LE_OQ.html" title="constant core::arch::x86_64::_CMP_LE_OQ">_CMP_LE_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">小于或等于 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_LE_OS.html" title="constant core::arch::x86_64::_CMP_LE_OS">_CMP_LE_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">小于或等于 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_LT_OQ.html" title="constant core::arch::x86_64::_CMP_LT_OQ">_CMP_LT_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">小于 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_LT_OS.html" title="constant core::arch::x86_64::_CMP_LT_OS">_CMP_LT_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">小于 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NEQ_OQ.html" title="constant core::arch::x86_64::_CMP_NEQ_OQ">_CMP_NEQ_OQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不相等 (有序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NEQ_OS.html" title="constant core::arch::x86_64::_CMP_NEQ_OS">_CMP_NEQ_OS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不相等 (有序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NEQ_UQ.html" title="constant core::arch::x86_64::_CMP_NEQ_UQ">_CMP_NEQ_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不相等 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NEQ_US.html" title="constant core::arch::x86_64::_CMP_NEQ_US">_CMP_NEQ_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不相等 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NGE_UQ.html" title="constant core::arch::x86_64::_CMP_NGE_UQ">_CMP_NGE_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不大于等于 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NGE_US.html" title="constant core::arch::x86_64::_CMP_NGE_US">_CMP_NGE_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不大于等于 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NGT_UQ.html" title="constant core::arch::x86_64::_CMP_NGT_UQ">_CMP_NGT_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不大于 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NGT_US.html" title="constant core::arch::x86_64::_CMP_NGT_US">_CMP_NGT_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不大于 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NLE_UQ.html" title="constant core::arch::x86_64::_CMP_NLE_UQ">_CMP_NLE_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不小于等于 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NLE_US.html" title="constant core::arch::x86_64::_CMP_NLE_US">_CMP_NLE_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不小于等于 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NLT_UQ.html" title="constant core::arch::x86_64::_CMP_NLT_UQ">_CMP_NLT_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不少于 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_NLT_US.html" title="constant core::arch::x86_64::_CMP_NLT_US">_CMP_NLT_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不少于 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_ORD_Q.html" title="constant core::arch::x86_64::_CMP_ORD_Q">_CMP_ORD_Q</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">订购 (无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_ORD_S.html" title="constant core::arch::x86_64::_CMP_ORD_S">_CMP_ORD_S</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">订购 (发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_TRUE_UQ.html" title="constant core::arch::x86_64::_CMP_TRUE_UQ">_CMP_TRUE_UQ</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">真 (无序，无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_TRUE_US.html" title="constant core::arch::x86_64::_CMP_TRUE_US">_CMP_TRUE_US</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">真 (无序，发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_UNORD_Q.html" title="constant core::arch::x86_64::_CMP_UNORD_Q">_CMP_UNORD_Q</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">无序 (无信号)</div></li><li><div class="item-name"><a class="constant" href="constant._CMP_UNORD_S.html" title="constant core::arch::x86_64::_CMP_UNORD_S">_CMP_UNORD_S</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">无序 (发信号)</div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_DENORM.html" title="constant core::arch::x86_64::_MM_EXCEPT_DENORM">_MM_EXCEPT_DENORM</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_DIV_ZERO.html" title="constant core::arch::x86_64::_MM_EXCEPT_DIV_ZERO">_MM_EXCEPT_DIV_ZERO</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_INEXACT.html" title="constant core::arch::x86_64::_MM_EXCEPT_INEXACT">_MM_EXCEPT_INEXACT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_INVALID.html" title="constant core::arch::x86_64::_MM_EXCEPT_INVALID">_MM_EXCEPT_INVALID</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_MASK.html" title="constant core::arch::x86_64::_MM_EXCEPT_MASK">_MM_EXCEPT_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._MM_GET_EXCEPTION_STATE.html"><code>_MM_GET_EXCEPTION_STATE</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_OVERFLOW.html" title="constant core::arch::x86_64::_MM_EXCEPT_OVERFLOW">_MM_EXCEPT_OVERFLOW</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_EXCEPT_UNDERFLOW.html" title="constant core::arch::x86_64::_MM_EXCEPT_UNDERFLOW">_MM_EXCEPT_UNDERFLOW</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FLUSH_ZERO_MASK.html" title="constant core::arch::x86_64::_MM_FLUSH_ZERO_MASK">_MM_FLUSH_ZERO_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._MM_GET_FLUSH_ZERO_MODE.html"><code>_MM_GET_FLUSH_ZERO_MODE</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FLUSH_ZERO_OFF.html" title="constant core::arch::x86_64::_MM_FLUSH_ZERO_OFF">_MM_FLUSH_ZERO_OFF</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FLUSH_ZERO_ON.html" title="constant core::arch::x86_64::_MM_FLUSH_ZERO_ON">_MM_FLUSH_ZERO_ON</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_CEIL.html" title="constant core::arch::x86_64::_MM_FROUND_CEIL">_MM_FROUND_CEIL</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">向上舍入并且不抑制异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_CUR_DIRECTION.html" title="constant core::arch::x86_64::_MM_FROUND_CUR_DIRECTION">_MM_FROUND_CUR_DIRECTION</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">使用 MXCSR.RC； 请参见 <code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_FLOOR.html" title="constant core::arch::x86_64::_MM_FROUND_FLOOR">_MM_FROUND_FLOOR</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">四舍五入，不抑制异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_NEARBYINT.html" title="constant core::arch::x86_64::_MM_FROUND_NEARBYINT">_MM_FROUND_NEARBYINT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">使用 MXCSR.RC 并抑制异常； 请参见 <code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_NINT.html" title="constant core::arch::x86_64::_MM_FROUND_NINT">_MM_FROUND_NINT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">四舍五入到最接近，不排除异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_NO_EXC.html" title="constant core::arch::x86_64::_MM_FROUND_NO_EXC">_MM_FROUND_NO_EXC</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">抑制异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_RAISE_EXC.html" title="constant core::arch::x86_64::_MM_FROUND_RAISE_EXC">_MM_FROUND_RAISE_EXC</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不要抑制异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_RINT.html" title="constant core::arch::x86_64::_MM_FROUND_RINT">_MM_FROUND_RINT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">使用 MXCSR.RC 且不抑制异常； 请参见 <code>vendor::_MM_SET_ROUNDING_MODE</code></div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_TO_NEAREST_INT.html" title="constant core::arch::x86_64::_MM_FROUND_TO_NEAREST_INT">_MM_FROUND_TO_NEAREST_INT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">四舍五入到最接近的</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_TO_NEG_INF.html" title="constant core::arch::x86_64::_MM_FROUND_TO_NEG_INF">_MM_FROUND_TO_NEG_INF</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">四舍五入</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_TO_POS_INF.html" title="constant core::arch::x86_64::_MM_FROUND_TO_POS_INF">_MM_FROUND_TO_POS_INF</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">围捕</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_TO_ZERO.html" title="constant core::arch::x86_64::_MM_FROUND_TO_ZERO">_MM_FROUND_TO_ZERO</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">truncate</div></li><li><div class="item-name"><a class="constant" href="constant._MM_FROUND_TRUNC.html" title="constant core::arch::x86_64::_MM_FROUND_TRUNC">_MM_FROUND_TRUNC</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">截断并且不抑制异常</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_ET0.html" title="constant core::arch::x86_64::_MM_HINT_ET0">_MM_HINT_ET0</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_ET1.html" title="constant core::arch::x86_64::_MM_HINT_ET1">_MM_HINT_ET1</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_NTA.html" title="constant core::arch::x86_64::_MM_HINT_NTA">_MM_HINT_NTA</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_T0.html" title="constant core::arch::x86_64::_MM_HINT_T0">_MM_HINT_T0</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_T1.html" title="constant core::arch::x86_64::_MM_HINT_T1">_MM_HINT_T1</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_HINT_T2.html" title="constant core::arch::x86_64::_MM_HINT_T2">_MM_HINT_T2</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_DENORM.html" title="constant core::arch::x86_64::_MM_MASK_DENORM">_MM_MASK_DENORM</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_DIV_ZERO.html" title="constant core::arch::x86_64::_MM_MASK_DIV_ZERO">_MM_MASK_DIV_ZERO</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_INEXACT.html" title="constant core::arch::x86_64::_MM_MASK_INEXACT">_MM_MASK_INEXACT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_INVALID.html" title="constant core::arch::x86_64::_MM_MASK_INVALID">_MM_MASK_INVALID</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_MASK.html" title="constant core::arch::x86_64::_MM_MASK_MASK">_MM_MASK_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._MM_GET_EXCEPTION_MASK.html"><code>_MM_GET_EXCEPTION_MASK</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_OVERFLOW.html" title="constant core::arch::x86_64::_MM_MASK_OVERFLOW">_MM_MASK_OVERFLOW</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_MASK_UNDERFLOW.html" title="constant core::arch::x86_64::_MM_MASK_UNDERFLOW">_MM_MASK_UNDERFLOW</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_ROUND_DOWN.html" title="constant core::arch::x86_64::_MM_ROUND_DOWN">_MM_ROUND_DOWN</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_ROUND_MASK.html" title="constant core::arch::x86_64::_MM_ROUND_MASK">_MM_ROUND_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._MM_GET_ROUNDING_MODE.html"><code>_MM_GET_ROUNDING_MODE</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_ROUND_NEAREST.html" title="constant core::arch::x86_64::_MM_ROUND_NEAREST">_MM_ROUND_NEAREST</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_ROUND_TOWARD_ZERO.html" title="constant core::arch::x86_64::_MM_ROUND_TOWARD_ZERO">_MM_ROUND_TOWARD_ZERO</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._MM_ROUND_UP.html" title="constant core::arch::x86_64::_MM_ROUND_UP">_MM_ROUND_UP</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_BIT_MASK.html" title="constant core::arch::x86_64::_SIDD_BIT_MASK">_SIDD_BIT_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><strong>仅掩码</strong>: 返回位掩码</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_CMP_EQUAL_ANY.html" title="constant core::arch::x86_64::_SIDD_CMP_EQUAL_ANY">_SIDD_CMP_EQUAL_ANY</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">对于 <code>a</code> 中的每个字符，查找它是否在 <code>b</code> 中 <em>(默认)</em></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_CMP_EQUAL_EACH.html" title="constant core::arch::x86_64::_SIDD_CMP_EQUAL_EACH">_SIDD_CMP_EQUAL_EACH</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 定义的字符串相等</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_CMP_EQUAL_ORDERED.html" title="constant core::arch::x86_64::_SIDD_CMP_EQUAL_ORDERED">_SIDD_CMP_EQUAL_ORDERED</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">在目标中搜索定义的子字符串</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_CMP_RANGES.html" title="constant core::arch::x86_64::_SIDD_CMP_RANGES">_SIDD_CMP_RANGES</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">对于 <code>a</code> 中的每个字符，确定 <code>b[0] &lt;= c &lt;= b[1] or b[1] &lt;= c &lt;= b[2]...</code></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_LEAST_SIGNIFICANT.html" title="constant core::arch::x86_64::_SIDD_LEAST_SIGNIFICANT">_SIDD_LEAST_SIGNIFICANT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><strong>仅索引</strong>: 返回最低有效位 <em>(默认)</em></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_MASKED_NEGATIVE_POLARITY.html" title="constant core::arch::x86_64::_SIDD_MASKED_NEGATIVE_POLARITY">_SIDD_MASKED_NEGATIVE_POLARITY</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">仅在字符串结尾之前取反结果</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_MASKED_POSITIVE_POLARITY.html" title="constant core::arch::x86_64::_SIDD_MASKED_POSITIVE_POLARITY">_SIDD_MASKED_POSITIVE_POLARITY</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不要在字符串结尾之前取反结果</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_MOST_SIGNIFICANT.html" title="constant core::arch::x86_64::_SIDD_MOST_SIGNIFICANT">_SIDD_MOST_SIGNIFICANT</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><strong>仅索引</strong>: 返回最高有效位</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_NEGATIVE_POLARITY.html" title="constant core::arch::x86_64::_SIDD_NEGATIVE_POLARITY">_SIDD_NEGATIVE_POLARITY</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">取反结果</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_POSITIVE_POLARITY.html" title="constant core::arch::x86_64::_SIDD_POSITIVE_POLARITY">_SIDD_POSITIVE_POLARITY</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">不取消结果 <em>(默认)</em></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_SBYTE_OPS.html" title="constant core::arch::x86_64::_SIDD_SBYTE_OPS">_SIDD_SBYTE_OPS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">字符串包含带符号的 8 位字符</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_SWORD_OPS.html" title="constant core::arch::x86_64::_SIDD_SWORD_OPS">_SIDD_SWORD_OPS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">字符串包含无符号的 16 位字符</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_UBYTE_OPS.html" title="constant core::arch::x86_64::_SIDD_UBYTE_OPS">_SIDD_UBYTE_OPS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">字符串包含无符号的 8 位字符 <em>(默认)</em></div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_UNIT_MASK.html" title="constant core::arch::x86_64::_SIDD_UNIT_MASK">_SIDD_UNIT_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><strong>仅掩码</strong>: 返回字节掩码</div></li><li><div class="item-name"><a class="constant" href="constant._SIDD_UWORD_OPS.html" title="constant core::arch::x86_64::_SIDD_UWORD_OPS">_SIDD_UWORD_OPS</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">字符串包含无符号的 16 位字符</div></li><li><div class="item-name"><a class="constant" href="constant._XCR_XFEATURE_ENABLED_MASK.html" title="constant core::arch::x86_64::_XCR_XFEATURE_ENABLED_MASK">_XCR_XFEATURE_ENABLED_MASK</a><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>XFEATURE_ENABLED_MASK</code> 为 <code>XCR</code></div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn._MM_SHUFFLE.html" title="fn core::arch::x86_64::_MM_SHUFFLE">_MM_SHUFFLE</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">一个实用程序函数，用于创建与 Intel 重排和置换内部函数一起使用的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._kadd_mask32.html" title="fn core::arch::x86_64::_kadd_mask32">_kadd_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位掩码相加，结果存入 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kadd_mask64.html" title="fn core::arch::x86_64::_kadd_mask64">_kadd_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的 64 位掩码相加，结果存入 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kand_mask16.html" title="fn core::arch::x86_64::_kand_mask16">_kand_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kand_mask32.html" title="fn core::arch::x86_64::_kand_mask32">_kand_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 和 b 的按位与，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kand_mask64.html" title="fn core::arch::x86_64::_kand_mask64">_kand_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 和 b 的按位与，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kandn_mask16.html" title="fn core::arch::x86_64::_kandn_mask16">_kandn_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 的按位非运算，然后与 b 进行与运算，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kandn_mask32.html" title="fn core::arch::x86_64::_kandn_mask32">_kandn_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 的按位非运算，然后与 b 进行与运算，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kandn_mask64.html" title="fn core::arch::x86_64::_kandn_mask64">_kandn_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 的按位非运算，然后与 b 进行与运算，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._knot_mask16.html" title="fn core::arch::x86_64::_knot_mask16">_knot_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 的按位非，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._knot_mask32.html" title="fn core::arch::x86_64::_knot_mask32">_knot_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 的按位非，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._knot_mask64.html" title="fn core::arch::x86_64::_knot_mask64">_knot_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 的按位非，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kor_mask16.html" title="fn core::arch::x86_64::_kor_mask16">_kor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kor_mask32.html" title="fn core::arch::x86_64::_kor_mask32">_kor_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 和 b 的按位或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kor_mask64.html" title="fn core::arch::x86_64::_kor_mask64">_kor_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 和 b 的按位或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxnor_mask16.html" title="fn core::arch::x86_64::_kxnor_mask16">_kxnor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxnor_mask32.html" title="fn core::arch::x86_64::_kxnor_mask32">_kxnor_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxnor_mask64.html" title="fn core::arch::x86_64::_kxnor_mask64">_kxnor_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxor_mask16.html" title="fn core::arch::x86_64::_kxor_mask16">_kxor_mask16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位异或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxor_mask32.html" title="fn core::arch::x86_64::_kxor_mask32">_kxor_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 32 位掩码 a 和 b 的按位异或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._kxor_mask64.html" title="fn core::arch::x86_64::_kxor_mask64">_kxor_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 64 位掩码 a 和 b 的按位异或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._load_mask32.html" title="fn core::arch::x86_64::_load_mask32">_load_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从内存中加载 32 位掩码到 k.</div></li><li><div class="item-name"><a class="fn" href="fn._load_mask64.html" title="fn core::arch::x86_64::_load_mask64">_load_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将内存中的 64 位掩码加载到 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_abs_epi64.html" title="fn core::arch::x86_64::_mm256_abs_epi64">_mm256_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_aesdec_epi128.html" title="fn core::arch::x86_64::_mm256_aesdec_epi128">_mm256_aesdec_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes` only">(x86 or x86-64) and <code>vaes</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 解密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_aesdeclast_epi128.html" title="fn core::arch::x86_64::_mm256_aesdeclast_epi128">_mm256_aesdeclast_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes` only">(x86 or x86-64) and <code>vaes</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_aesenc_epi128.html" title="fn core::arch::x86_64::_mm256_aesenc_epi128">_mm256_aesenc_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes` only">(x86 or x86-64) and <code>vaes</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_aesenclast_epi128.html" title="fn core::arch::x86_64::_mm256_aesenclast_epi128">_mm256_aesenclast_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes` only">(x86 or x86-64) and <code>vaes</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_alignr_epi32.html" title="fn core::arch::x86_64::_mm256_alignr_epi32">_mm256_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 32 字节 (8 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_alignr_epi64.html" title="fn core::arch::x86_64::_mm256_alignr_epi64">_mm256_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 32 字节 (4 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm256_bitshuffle_epi64_mask">_mm256_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm256_broadcast_f32x4">_mm256_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm256_broadcast_i32x4">_mm256_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastmb_epi64.html" title="fn core::arch::x86_64::_mm256_broadcastmb_epi64">_mm256_broadcastmb_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastmw_epi32.html" title="fn core::arch::x86_64::_mm256_broadcastmw_epi32">_mm256_broadcastmw_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_clmulepi64_epi128.html" title="fn core::arch::x86_64::_mm256_clmulepi64_epi128">_mm256_clmulepi64_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vpclmulqdq` only">(x86 or x86-64) and <code>vpclmulqdq</code></span></div><div class="desc docblock-short">在 2 个 128 位 lanes 中的每个 lanes 中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epi8_mask">_mm256_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epi16_mask">_mm256_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epi32_mask">_mm256_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epi64_mask">_mm256_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epu8_mask">_mm256_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epu16_mask">_mm256_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epu32_mask">_mm256_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmp_epu64_mask">_mm256_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm256_cmp_pd_mask">_mm256_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数，比较 a 和 b 中的双精度 (64-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm256_cmp_ps_mask">_mm256_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的单精度 (32-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi8_mask">_mm256_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi16_mask">_mm256_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi32_mask">_mm256_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi64_mask">_mm256_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epu8_mask">_mm256_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epu16_mask">_mm256_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epu32_mask">_mm256_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmpeq_epu64_mask">_mm256_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epi8_mask">_mm256_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epi16_mask">_mm256_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epi32_mask">_mm256_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epi64_mask">_mm256_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epu8_mask">_mm256_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epu16_mask">_mm256_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epu32_mask">_mm256_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmpge_epu64_mask">_mm256_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi8_mask">_mm256_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi16_mask">_mm256_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi32_mask">_mm256_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi64_mask">_mm256_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epu8_mask">_mm256_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epu16_mask">_mm256_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epu32_mask">_mm256_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmpgt_epu64_mask">_mm256_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epi8_mask">_mm256_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epi16_mask">_mm256_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epi32_mask">_mm256_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epi64_mask">_mm256_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epu8_mask">_mm256_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epu16_mask">_mm256_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epu32_mask">_mm256_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmple_epu64_mask">_mm256_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epi8_mask">_mm256_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epi16_mask">_mm256_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epi32_mask">_mm256_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epi64_mask">_mm256_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epu8_mask">_mm256_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epu16_mask">_mm256_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epu32_mask">_mm256_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmplt_epu64_mask">_mm256_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epi8_mask">_mm256_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epi16_mask">_mm256_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epi32_mask">_mm256_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epi64_mask">_mm256_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epu8_mask">_mm256_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epu16_mask">_mm256_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epu32_mask">_mm256_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm256_cmpneq_epu64_mask">_mm256_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_conflict_epi32.html" title="fn core::arch::x86_64::_mm256_conflict_epi32">_mm256_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_conflict_epi64.html" title="fn core::arch::x86_64::_mm256_conflict_epi64">_mm256_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm256_cvtepi16_epi8">_mm256_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm256_cvtepi32_epi8">_mm256_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm256_cvtepi32_epi16">_mm256_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm256_cvtepi64_epi8">_mm256_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm256_cvtepi64_epi16">_mm256_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm256_cvtepi64_epi32">_mm256_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm256_cvtepu32_pd">_mm256_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm256_cvtne2ps_pbh">_mm256_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将两个 256 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm256_cvtneps_pbh">_mm256_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtneps_pbh">Intel’s documentation</a></div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm256_cvtpd_epu32">_mm256_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtps_epu32.html" title="fn core::arch::x86_64::_mm256_cvtps_epu32">_mm256_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm256_cvtsepi16_epi8">_mm256_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm256_cvtsepi32_epi8">_mm256_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm256_cvtsepi32_epi16">_mm256_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm256_cvtsepi64_epi8">_mm256_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm256_cvtsepi64_epi16">_mm256_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm256_cvtsepi64_epi32">_mm256_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm256_cvttpd_epu32">_mm256_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttps_epu32.html" title="fn core::arch::x86_64::_mm256_cvttps_epu32">_mm256_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm256_cvtusepi16_epi8">_mm256_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm256_cvtusepi32_epi8">_mm256_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm256_cvtusepi32_epi16">_mm256_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm256_cvtusepi64_epi8">_mm256_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm256_cvtusepi64_epi16">_mm256_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm256_cvtusepi64_epi32">_mm256_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dbsad_epu8.html" title="fn core::arch::x86_64::_mm256_dbsad_epu8">_mm256_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dpbf16_ps.html" title="fn core::arch::x86_64::_mm256_dpbf16_ps">_mm256_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm256_dpbusd_epi32">_mm256_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm256_dpbusds_epi32">_mm256_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm256_dpwssd_epi32">_mm256_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm256_dpwssds_epi32">_mm256_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm256_extractf32x4_ps">_mm256_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm256_extracti32x4_epi32">_mm256_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fixupimm_pd.html" title="fn core::arch::x86_64::_mm256_fixupimm_pd">_mm256_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fixupimm_ps.html" title="fn core::arch::x86_64::_mm256_fixupimm_ps">_mm256_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getexp_pd.html" title="fn core::arch::x86_64::_mm256_getexp_pd">_mm256_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getexp_ps.html" title="fn core::arch::x86_64::_mm256_getexp_ps">_mm256_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getmant_pd.html" title="fn core::arch::x86_64::_mm256_getmant_pd">_mm256_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_getmant_ps.html" title="fn core::arch::x86_64::_mm256_getmant_ps">_mm256_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_gf2p8affine_epi64_epi8">_mm256_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx` only">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_gf2p8affineinv_epi64_epi8">_mm256_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx` only">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm256_gf2p8mul_epi8">_mm256_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx` only">(x86 or x86-64) and <code>gfni,avx</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32scatter_epi64.html" title="fn core::arch::x86_64::_mm256_i32scatter_epi64">_mm256_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insertf32x4.html" title="fn core::arch::x86_64::_mm256_insertf32x4">_mm256_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 dst 中 imm8 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_inserti32x4.html" title="fn core::arch::x86_64::_mm256_inserti32x4">_mm256_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后将 b 中的 128 位 (由 4 个压缩的 32 位整数组成) 插入到 dst 中 imm8 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_epi32.html" title="fn core::arch::x86_64::_mm256_load_epi32">_mm256_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_epi64.html" title="fn core::arch::x86_64::_mm256_load_epi64">_mm256_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi8.html" title="fn core::arch::x86_64::_mm256_loadu_epi8">_mm256_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 32 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi16.html" title="fn core::arch::x86_64::_mm256_loadu_epi16">_mm256_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 16 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi32.html" title="fn core::arch::x86_64::_mm256_loadu_epi32">_mm256_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_epi64.html" title="fn core::arch::x86_64::_mm256_loadu_epi64">_mm256_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm256_lzcnt_epi32">_mm256_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm256_lzcnt_epi64">_mm256_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_madd52hi_epu64.html" title="fn core::arch::x86_64::_mm256_madd52hi_epu64">_mm256_madd52hi_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_madd52lo_epu64.html" title="fn core::arch::x86_64::_mm256_madd52lo_epu64">_mm256_madd52lo_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_epi8">_mm256_mask2_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_epi16">_mm256_mask2_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_epi32">_mm256_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_epi64">_mm256_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_pd.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_pd">_mm256_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask2_permutex2var_ps.html" title="fn core::arch::x86_64::_mm256_mask2_permutex2var_ps">_mm256_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的对应选择器和索引在 a 和 b 中的 lanes 中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmadd_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fmadd_pd">_mm256_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmadd_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fmadd_ps">_mm256_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fmaddsub_pd">_mm256_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fmaddsub_ps">_mm256_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsub_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fmsub_pd">_mm256_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsub_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fmsub_ps">_mm256_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fmsubadd_pd">_mm256_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fmsubadd_ps">_mm256_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmadd_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fnmadd_pd">_mm256_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmadd_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fnmadd_ps">_mm256_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmsub_pd.html" title="fn core::arch::x86_64::_mm256_mask3_fnmsub_pd">_mm256_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask3_fnmsub_ps.html" title="fn core::arch::x86_64::_mm256_mask3_fnmsub_ps">_mm256_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi8.html" title="fn core::arch::x86_64::_mm256_mask_abs_epi8">_mm256_mask_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi16.html" title="fn core::arch::x86_64::_mm256_mask_abs_epi16">_mm256_mask_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi32.html" title="fn core::arch::x86_64::_mm256_mask_abs_epi32">_mm256_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_abs_epi64.html" title="fn core::arch::x86_64::_mm256_mask_abs_epi64">_mm256_mask_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi8.html" title="fn core::arch::x86_64::_mm256_mask_add_epi8">_mm256_mask_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi16.html" title="fn core::arch::x86_64::_mm256_mask_add_epi16">_mm256_mask_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi32.html" title="fn core::arch::x86_64::_mm256_mask_add_epi32">_mm256_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_epi64.html" title="fn core::arch::x86_64::_mm256_mask_add_epi64">_mm256_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_pd.html" title="fn core::arch::x86_64::_mm256_mask_add_pd">_mm256_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_add_ps.html" title="fn core::arch::x86_64::_mm256_mask_add_ps">_mm256_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_adds_epi8.html" title="fn core::arch::x86_64::_mm256_mask_adds_epi8">_mm256_mask_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_adds_epi16.html" title="fn core::arch::x86_64::_mm256_mask_adds_epi16">_mm256_mask_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_adds_epu8.html" title="fn core::arch::x86_64::_mm256_mask_adds_epu8">_mm256_mask_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_adds_epu16.html" title="fn core::arch::x86_64::_mm256_mask_adds_epu16">_mm256_mask_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_alignr_epi8.html" title="fn core::arch::x86_64::_mm256_mask_alignr_epi8">_mm256_mask_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的屏蔽位未置位时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_alignr_epi32.html" title="fn core::arch::x86_64::_mm256_mask_alignr_epi32">_mm256_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_alignr_epi64.html" title="fn core::arch::x86_64::_mm256_mask_alignr_epi64">_mm256_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_and_epi32.html" title="fn core::arch::x86_64::_mm256_mask_and_epi32">_mm256_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_and_epi64.html" title="fn core::arch::x86_64::_mm256_mask_and_epi64">_mm256_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_andnot_epi32.html" title="fn core::arch::x86_64::_mm256_mask_andnot_epi32">_mm256_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_andnot_epi64.html" title="fn core::arch::x86_64::_mm256_mask_andnot_epi64">_mm256_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_avg_epu8.html" title="fn core::arch::x86_64::_mm256_mask_avg_epu8">_mm256_mask_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_avg_epu16.html" title="fn core::arch::x86_64::_mm256_mask_avg_epu16">_mm256_mask_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_bitshuffle_epi64_mask">_mm256_mask_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi8.html" title="fn core::arch::x86_64::_mm256_mask_blend_epi8">_mm256_mask_blend_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi16.html" title="fn core::arch::x86_64::_mm256_mask_blend_epi16">_mm256_mask_blend_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi32.html" title="fn core::arch::x86_64::_mm256_mask_blend_epi32">_mm256_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_epi64.html" title="fn core::arch::x86_64::_mm256_mask_blend_epi64">_mm256_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_pd.html" title="fn core::arch::x86_64::_mm256_mask_blend_pd">_mm256_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_blend_ps.html" title="fn core::arch::x86_64::_mm256_mask_blend_ps">_mm256_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm256_mask_broadcast_f32x4">_mm256_mask_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm256_mask_broadcast_i32x4">_mm256_mask_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm256_mask_broadcastb_epi8">_mm256_mask_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm256_mask_broadcastd_epi32">_mm256_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm256_mask_broadcastq_epi64">_mm256_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm256_mask_broadcastsd_pd">_mm256_mask_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastss_ps.html" title="fn core::arch::x86_64::_mm256_mask_broadcastss_ps">_mm256_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm256_mask_broadcastw_epi16">_mm256_mask_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epi8_mask">_mm256_mask_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epi16_mask">_mm256_mask_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epi32_mask">_mm256_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epi64_mask">_mm256_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epu8_mask">_mm256_mask_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epu16_mask">_mm256_mask_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epu32_mask">_mm256_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_epu64_mask">_mm256_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_pd_mask">_mm256_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmp_ps_mask">_mm256_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epi8_mask">_mm256_mask_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epi16_mask">_mm256_mask_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epi32_mask">_mm256_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epi64_mask">_mm256_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epu8_mask">_mm256_mask_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epu16_mask">_mm256_mask_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epu32_mask">_mm256_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpeq_epu64_mask">_mm256_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epi8_mask">_mm256_mask_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epi16_mask">_mm256_mask_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epi32_mask">_mm256_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epi64_mask">_mm256_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epu8_mask">_mm256_mask_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epu16_mask">_mm256_mask_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epu32_mask">_mm256_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpge_epu64_mask">_mm256_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epi8_mask">_mm256_mask_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epi16_mask">_mm256_mask_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epi32_mask">_mm256_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epi64_mask">_mm256_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epu8_mask">_mm256_mask_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epu16_mask">_mm256_mask_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epu32_mask">_mm256_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpgt_epu64_mask">_mm256_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epi8_mask">_mm256_mask_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epi16_mask">_mm256_mask_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epi32_mask">_mm256_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epi64_mask">_mm256_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epu8_mask">_mm256_mask_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epu16_mask">_mm256_mask_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epu32_mask">_mm256_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmple_epu64_mask">_mm256_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epi8_mask">_mm256_mask_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epi16_mask">_mm256_mask_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epi32_mask">_mm256_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epi64_mask">_mm256_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epu8_mask">_mm256_mask_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epu16_mask">_mm256_mask_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epu32_mask">_mm256_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmplt_epu64_mask">_mm256_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epi8_mask">_mm256_mask_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epi16_mask">_mm256_mask_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epi32_mask">_mm256_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epi64_mask">_mm256_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epu8_mask">_mm256_mask_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epu16_mask">_mm256_mask_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epu32_mask">_mm256_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm256_mask_cmpneq_epu64_mask">_mm256_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi8.html" title="fn core::arch::x86_64::_mm256_mask_compress_epi8">_mm256_mask_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi16.html" title="fn core::arch::x86_64::_mm256_mask_compress_epi16">_mm256_mask_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi32.html" title="fn core::arch::x86_64::_mm256_mask_compress_epi32">_mm256_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_epi64.html" title="fn core::arch::x86_64::_mm256_mask_compress_epi64">_mm256_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_pd.html" title="fn core::arch::x86_64::_mm256_mask_compress_pd">_mm256_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compress_ps.html" title="fn core::arch::x86_64::_mm256_mask_compress_ps">_mm256_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_epi8">_mm256_mask_compressstoreu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (其各自的位在 writemask k 中设置) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_epi16">_mm256_mask_compressstoreu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (其各自的位在 writemask k 中设置的那些) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_epi32">_mm256_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的 32 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_epi64.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_epi64">_mm256_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的 64 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_pd.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_pd">_mm256_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的双精度 (64 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_compressstoreu_ps.html" title="fn core::arch::x86_64::_mm256_mask_compressstoreu_ps">_mm256_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的单精度 (32 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_conflict_epi32.html" title="fn core::arch::x86_64::_mm256_mask_conflict_epi32">_mm256_mask_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k (当未设置相应的掩码位时，将从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_conflict_epi64.html" title="fn core::arch::x86_64::_mm256_mask_conflict_epi64">_mm256_mask_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，将从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm256_mask_cvt_roundps_ph">_mm256_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi8_epi16">_mm256_mask_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi8_epi32">_mm256_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi8_epi64">_mm256_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi16_epi8">_mm256_mask_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi16_epi32">_mm256_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi16_epi64">_mm256_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi16_storeu_epi8">_mm256_mask_cvtepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_epi8">_mm256_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_epi16">_mm256_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_epi64">_mm256_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_pd">_mm256_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_ps">_mm256_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_storeu_epi8">_mm256_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi32_storeu_epi16">_mm256_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_epi8">_mm256_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_epi16">_mm256_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_epi32">_mm256_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi8">_mm256_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi16">_mm256_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepi64_storeu_epi32">_mm256_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu8_epi16">_mm256_mask_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu8_epi32">_mm256_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 8 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu8_epi64">_mm256_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu16_epi32">_mm256_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu16_epi64">_mm256_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu32_epi64">_mm256_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm256_mask_cvtepu32_pd">_mm256_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm256_mask_cvtne2ps_pbh">_mm256_mask_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素在两个 vector a 和 b 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当相应的掩码位不存在时，元素从 src 复制放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm256_mask_cvtneps_pbh">_mm256_mask_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtpd_epi32">_mm256_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm256_mask_cvtpd_epu32">_mm256_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtpd_ps.html" title="fn core::arch::x86_64::_mm256_mask_cvtpd_ps">_mm256_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtph_ps.html" title="fn core::arch::x86_64::_mm256_mask_cvtph_ps">_mm256_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtps_epi32">_mm256_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_epu32.html" title="fn core::arch::x86_64::_mm256_mask_cvtps_epu32">_mm256_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtps_ph.html" title="fn core::arch::x86_64::_mm256_mask_cvtps_ph">_mm256_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi16_epi8">_mm256_mask_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi16_storeu_epi8">_mm256_mask_cvtsepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi32_epi8">_mm256_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi32_epi16">_mm256_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi32_storeu_epi8">_mm256_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi32_storeu_epi16">_mm256_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_epi8">_mm256_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_epi16">_mm256_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_epi32">_mm256_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi8">_mm256_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi16">_mm256_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtsepi64_storeu_epi32">_mm256_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvttpd_epi32">_mm256_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm256_mask_cvttpd_epu32">_mm256_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttps_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvttps_epi32">_mm256_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvttps_epu32.html" title="fn core::arch::x86_64::_mm256_mask_cvttps_epu32">_mm256_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi16_epi8">_mm256_mask_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi16_storeu_epi8">_mm256_mask_cvtusepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi32_epi8">_mm256_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi32_epi16">_mm256_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi32_storeu_epi8">_mm256_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi32_storeu_epi16">_mm256_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_epi8">_mm256_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_epi16">_mm256_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_epi32">_mm256_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi8">_mm256_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi16">_mm256_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_cvtusepi64_storeu_epi32">_mm256_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dbsad_epu8.html" title="fn core::arch::x86_64::_mm256_mask_dbsad_epu8">_mm256_mask_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_div_pd.html" title="fn core::arch::x86_64::_mm256_mask_div_pd">_mm256_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_div_ps.html" title="fn core::arch::x86_64::_mm256_mask_div_ps">_mm256_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dpbf16_ps.html" title="fn core::arch::x86_64::_mm256_mask_dpbf16_ps">_mm256_mask_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm256_mask_dpbusd_epi32">_mm256_mask_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm256_mask_dpbusds_epi32">_mm256_mask_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm256_mask_dpwssd_epi32">_mm256_mask_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm256_mask_dpwssds_epi32">_mm256_mask_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi8.html" title="fn core::arch::x86_64::_mm256_mask_expand_epi8">_mm256_mask_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi16.html" title="fn core::arch::x86_64::_mm256_mask_expand_epi16">_mm256_mask_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi32.html" title="fn core::arch::x86_64::_mm256_mask_expand_epi32">_mm256_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_epi64.html" title="fn core::arch::x86_64::_mm256_mask_expand_epi64">_mm256_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_pd.html" title="fn core::arch::x86_64::_mm256_mask_expand_pd">_mm256_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expand_ps.html" title="fn core::arch::x86_64::_mm256_mask_expand_ps">_mm256_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_epi8">_mm256_mask_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_epi16">_mm256_mask_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_epi32">_mm256_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从未对齐内存中的 mem_addr 加载连续的活动 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_epi64">_mm256_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_pd.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_pd">_mm256_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_expandloadu_ps.html" title="fn core::arch::x86_64::_mm256_mask_expandloadu_ps">_mm256_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm256_mask_extractf32x4_ps">_mm256_mask_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm256_mask_extracti32x4_epi32">_mm256_mask_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fixupimm_pd.html" title="fn core::arch::x86_64::_mm256_mask_fixupimm_pd">_mm256_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fixupimm_ps.html" title="fn core::arch::x86_64::_mm256_mask_fixupimm_ps">_mm256_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmadd_pd.html" title="fn core::arch::x86_64::_mm256_mask_fmadd_pd">_mm256_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmadd_ps.html" title="fn core::arch::x86_64::_mm256_mask_fmadd_ps">_mm256_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm256_mask_fmaddsub_pd">_mm256_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm256_mask_fmaddsub_ps">_mm256_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsub_pd.html" title="fn core::arch::x86_64::_mm256_mask_fmsub_pd">_mm256_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsub_ps.html" title="fn core::arch::x86_64::_mm256_mask_fmsub_ps">_mm256_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm256_mask_fmsubadd_pd">_mm256_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm256_mask_fmsubadd_ps">_mm256_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmadd_pd.html" title="fn core::arch::x86_64::_mm256_mask_fnmadd_pd">_mm256_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmadd_ps.html" title="fn core::arch::x86_64::_mm256_mask_fnmadd_ps">_mm256_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmsub_pd.html" title="fn core::arch::x86_64::_mm256_mask_fnmsub_pd">_mm256_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_fnmsub_ps.html" title="fn core::arch::x86_64::_mm256_mask_fnmsub_ps">_mm256_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getexp_pd.html" title="fn core::arch::x86_64::_mm256_mask_getexp_pd">_mm256_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getexp_ps.html" title="fn core::arch::x86_64::_mm256_mask_getexp_ps">_mm256_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getmant_pd.html" title="fn core::arch::x86_64::_mm256_mask_getmant_pd">_mm256_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_getmant_ps.html" title="fn core::arch::x86_64::_mm256_mask_getmant_ps">_mm256_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_gf2p8affine_epi64_epi8">_mm256_mask_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_gf2p8affineinv_epi64_epi8">_mm256_mask_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm256_mask_gf2p8mul_epi8">_mm256_mask_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_insertf32x4.html" title="fn core::arch::x86_64::_mm256_mask_insertf32x4">_mm256_mask_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_inserti32x4.html" title="fn core::arch::x86_64::_mm256_mask_inserti32x4">_mm256_mask_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_epi32.html" title="fn core::arch::x86_64::_mm256_mask_load_epi32">_mm256_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_epi64.html" title="fn core::arch::x86_64::_mm256_mask_load_epi64">_mm256_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_pd.html" title="fn core::arch::x86_64::_mm256_mask_load_pd">_mm256_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_load_ps.html" title="fn core::arch::x86_64::_mm256_mask_load_ps">_mm256_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_loadu_epi8">_mm256_mask_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_loadu_epi16">_mm256_mask_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_loadu_epi32">_mm256_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_epi64.html" title="fn core::arch::x86_64::_mm256_mask_loadu_epi64">_mm256_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_pd.html" title="fn core::arch::x86_64::_mm256_mask_loadu_pd">_mm256_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_loadu_ps.html" title="fn core::arch::x86_64::_mm256_mask_loadu_ps">_mm256_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm256_mask_lzcnt_epi32">_mm256_mask_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm256_mask_lzcnt_epi64">_mm256_mask_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_madd_epi16.html" title="fn core::arch::x86_64::_mm256_mask_madd_epi16">_mm256_mask_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_maddubs_epi16.html" title="fn core::arch::x86_64::_mm256_mask_maddubs_epi16">_mm256_mask_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi8.html" title="fn core::arch::x86_64::_mm256_mask_max_epi8">_mm256_mask_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi16.html" title="fn core::arch::x86_64::_mm256_mask_max_epi16">_mm256_mask_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi32.html" title="fn core::arch::x86_64::_mm256_mask_max_epi32">_mm256_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epi64.html" title="fn core::arch::x86_64::_mm256_mask_max_epi64">_mm256_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu8.html" title="fn core::arch::x86_64::_mm256_mask_max_epu8">_mm256_mask_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu16.html" title="fn core::arch::x86_64::_mm256_mask_max_epu16">_mm256_mask_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu32.html" title="fn core::arch::x86_64::_mm256_mask_max_epu32">_mm256_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_epu64.html" title="fn core::arch::x86_64::_mm256_mask_max_epu64">_mm256_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_pd.html" title="fn core::arch::x86_64::_mm256_mask_max_pd">_mm256_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_max_ps.html" title="fn core::arch::x86_64::_mm256_mask_max_ps">_mm256_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi8.html" title="fn core::arch::x86_64::_mm256_mask_min_epi8">_mm256_mask_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi16.html" title="fn core::arch::x86_64::_mm256_mask_min_epi16">_mm256_mask_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi32.html" title="fn core::arch::x86_64::_mm256_mask_min_epi32">_mm256_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epi64.html" title="fn core::arch::x86_64::_mm256_mask_min_epi64">_mm256_mask_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu8.html" title="fn core::arch::x86_64::_mm256_mask_min_epu8">_mm256_mask_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu16.html" title="fn core::arch::x86_64::_mm256_mask_min_epu16">_mm256_mask_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu32.html" title="fn core::arch::x86_64::_mm256_mask_min_epu32">_mm256_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_epu64.html" title="fn core::arch::x86_64::_mm256_mask_min_epu64">_mm256_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_pd.html" title="fn core::arch::x86_64::_mm256_mask_min_pd">_mm256_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_min_ps.html" title="fn core::arch::x86_64::_mm256_mask_min_ps">_mm256_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi8.html" title="fn core::arch::x86_64::_mm256_mask_mov_epi8">_mm256_mask_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi16.html" title="fn core::arch::x86_64::_mm256_mask_mov_epi16">_mm256_mask_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi32.html" title="fn core::arch::x86_64::_mm256_mask_mov_epi32">_mm256_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_epi64.html" title="fn core::arch::x86_64::_mm256_mask_mov_epi64">_mm256_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_pd.html" title="fn core::arch::x86_64::_mm256_mask_mov_pd">_mm256_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mov_ps.html" title="fn core::arch::x86_64::_mm256_mask_mov_ps">_mm256_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_movedup_pd.html" title="fn core::arch::x86_64::_mm256_mask_movedup_pd">_mm256_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_movehdup_ps.html" title="fn core::arch::x86_64::_mm256_mask_movehdup_ps">_mm256_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_moveldup_ps.html" title="fn core::arch::x86_64::_mm256_mask_moveldup_ps">_mm256_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_epi32.html" title="fn core::arch::x86_64::_mm256_mask_mul_epi32">_mm256_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_epu32.html" title="fn core::arch::x86_64::_mm256_mask_mul_epu32">_mm256_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_pd.html" title="fn core::arch::x86_64::_mm256_mask_mul_pd">_mm256_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mul_ps.html" title="fn core::arch::x86_64::_mm256_mask_mul_ps">_mm256_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mulhi_epi16.html" title="fn core::arch::x86_64::_mm256_mask_mulhi_epi16">_mm256_mask_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mulhi_epu16.html" title="fn core::arch::x86_64::_mm256_mask_mulhi_epu16">_mm256_mask_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm256_mask_mulhrs_epi16">_mm256_mask_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mullo_epi16.html" title="fn core::arch::x86_64::_mm256_mask_mullo_epi16">_mm256_mask_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_mullo_epi32.html" title="fn core::arch::x86_64::_mm256_mask_mullo_epi32">_mm256_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_mask_multishift_epi64_epi8">_mm256_mask_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_or_epi32.html" title="fn core::arch::x86_64::_mm256_mask_or_epi32">_mm256_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_or_epi64.html" title="fn core::arch::x86_64::_mm256_mask_or_epi64">_mm256_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_packs_epi16.html" title="fn core::arch::x86_64::_mm256_mask_packs_epi16">_mm256_mask_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_packs_epi32.html" title="fn core::arch::x86_64::_mm256_mask_packs_epi32">_mm256_mask_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_packus_epi16.html" title="fn core::arch::x86_64::_mm256_mask_packus_epi16">_mm256_mask_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_packus_epi32.html" title="fn core::arch::x86_64::_mm256_mask_packus_epi32">_mm256_mask_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permute_pd.html" title="fn core::arch::x86_64::_mm256_mask_permute_pd">_mm256_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permute_ps.html" title="fn core::arch::x86_64::_mm256_mask_permute_ps">_mm256_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutevar_pd.html" title="fn core::arch::x86_64::_mm256_mask_permutevar_pd">_mm256_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutevar_ps.html" title="fn core::arch::x86_64::_mm256_mask_permutevar_ps">_mm256_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_epi8">_mm256_mask_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_epi16">_mm256_mask_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_epi32">_mm256_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_epi64">_mm256_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_pd.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_pd">_mm256_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex2var_ps.html" title="fn core::arch::x86_64::_mm256_mask_permutex2var_ps">_mm256_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 a 和 b 中的 lanes 上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex_epi64.html" title="fn core::arch::x86_64::_mm256_mask_permutex_epi64">_mm256_mask_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutex_pd.html" title="fn core::arch::x86_64::_mm256_mask_permutex_pd">_mm256_mask_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_epi8">_mm256_mask_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_epi16">_mm256_mask_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_epi32">_mm256_mask_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_epi64">_mm256_mask_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_pd.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_pd">_mm256_mask_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_permutexvar_ps.html" title="fn core::arch::x86_64::_mm256_mask_permutexvar_ps">_mm256_mask_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_popcnt_epi8.html" title="fn core::arch::x86_64::_mm256_mask_popcnt_epi8">_mm256_mask_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_popcnt_epi16.html" title="fn core::arch::x86_64::_mm256_mask_popcnt_epi16">_mm256_mask_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_popcnt_epi32.html" title="fn core::arch::x86_64::_mm256_mask_popcnt_epi32">_mm256_mask_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_popcnt_epi64.html" title="fn core::arch::x86_64::_mm256_mask_popcnt_epi64">_mm256_mask_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rcp14_pd.html" title="fn core::arch::x86_64::_mm256_mask_rcp14_pd">_mm256_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rcp14_ps.html" title="fn core::arch::x86_64::_mm256_mask_rcp14_ps">_mm256_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rol_epi32.html" title="fn core::arch::x86_64::_mm256_mask_rol_epi32">_mm256_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rol_epi64.html" title="fn core::arch::x86_64::_mm256_mask_rol_epi64">_mm256_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rolv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_rolv_epi32">_mm256_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rolv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_rolv_epi64">_mm256_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ror_epi32.html" title="fn core::arch::x86_64::_mm256_mask_ror_epi32">_mm256_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ror_epi64.html" title="fn core::arch::x86_64::_mm256_mask_ror_epi64">_mm256_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rorv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_rorv_epi32">_mm256_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rorv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_rorv_epi64">_mm256_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_roundscale_pd.html" title="fn core::arch::x86_64::_mm256_mask_roundscale_pd">_mm256_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_roundscale_ps.html" title="fn core::arch::x86_64::_mm256_mask_roundscale_ps">_mm256_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm256_mask_rsqrt14_pd">_mm256_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm256_mask_rsqrt14_ps">_mm256_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_scalef_pd.html" title="fn core::arch::x86_64::_mm256_mask_scalef_pd">_mm256_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_scalef_ps.html" title="fn core::arch::x86_64::_mm256_mask_scalef_ps">_mm256_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi8.html" title="fn core::arch::x86_64::_mm256_mask_set1_epi8">_mm256_mask_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi16.html" title="fn core::arch::x86_64::_mm256_mask_set1_epi16">_mm256_mask_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi32.html" title="fn core::arch::x86_64::_mm256_mask_set1_epi32">_mm256_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_set1_epi64.html" title="fn core::arch::x86_64::_mm256_mask_set1_epi64">_mm256_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldi_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shldi_epi16">_mm256_mask_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldi_epi32.html" title="fn core::arch::x86_64::_mm256_mask_shldi_epi32">_mm256_mask_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldi_epi64.html" title="fn core::arch::x86_64::_mm256_mask_shldi_epi64">_mm256_mask_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldv_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shldv_epi16">_mm256_mask_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_shldv_epi32">_mm256_mask_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shldv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_shldv_epi64">_mm256_mask_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdi_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shrdi_epi16">_mm256_mask_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdi_epi32.html" title="fn core::arch::x86_64::_mm256_mask_shrdi_epi32">_mm256_mask_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdi_epi64.html" title="fn core::arch::x86_64::_mm256_mask_shrdi_epi64">_mm256_mask_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdv_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shrdv_epi16">_mm256_mask_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_shrdv_epi32">_mm256_mask_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shrdv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_shrdv_epi64">_mm256_mask_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_epi8.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_epi8">_mm256_mask_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中相应的 8 位元素中的控件在 128 位 lane 内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_epi32.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_epi32">_mm256_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件将 128 位 lane 中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_f32x4">_mm256_mask_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_f64x2">_mm256_mask_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_i32x4">_mm256_mask_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_i64x2">_mm256_mask_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_pd.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_pd">_mm256_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shuffle_ps.html" title="fn core::arch::x86_64::_mm256_mask_shuffle_ps">_mm256_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shufflehi_epi16">_mm256_mask_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 writemask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm256_mask_shufflelo_epi16">_mm256_mask_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 writemask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sll_epi16.html" title="fn core::arch::x86_64::_mm256_mask_sll_epi16">_mm256_mask_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sll_epi32.html" title="fn core::arch::x86_64::_mm256_mask_sll_epi32">_mm256_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sll_epi64.html" title="fn core::arch::x86_64::_mm256_mask_sll_epi64">_mm256_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_slli_epi16.html" title="fn core::arch::x86_64::_mm256_mask_slli_epi16">_mm256_mask_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_slli_epi32.html" title="fn core::arch::x86_64::_mm256_mask_slli_epi32">_mm256_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_slli_epi64.html" title="fn core::arch::x86_64::_mm256_mask_slli_epi64">_mm256_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sllv_epi16.html" title="fn core::arch::x86_64::_mm256_mask_sllv_epi16">_mm256_mask_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sllv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_sllv_epi32">_mm256_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sllv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_sllv_epi64">_mm256_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sqrt_pd.html" title="fn core::arch::x86_64::_mm256_mask_sqrt_pd">_mm256_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sqrt_ps.html" title="fn core::arch::x86_64::_mm256_mask_sqrt_ps">_mm256_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sra_epi16.html" title="fn core::arch::x86_64::_mm256_mask_sra_epi16">_mm256_mask_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sra_epi32.html" title="fn core::arch::x86_64::_mm256_mask_sra_epi32">_mm256_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sra_epi64.html" title="fn core::arch::x86_64::_mm256_mask_sra_epi64">_mm256_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srai_epi16.html" title="fn core::arch::x86_64::_mm256_mask_srai_epi16">_mm256_mask_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srai_epi32.html" title="fn core::arch::x86_64::_mm256_mask_srai_epi32">_mm256_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srai_epi64.html" title="fn core::arch::x86_64::_mm256_mask_srai_epi64">_mm256_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srav_epi16.html" title="fn core::arch::x86_64::_mm256_mask_srav_epi16">_mm256_mask_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srav_epi32.html" title="fn core::arch::x86_64::_mm256_mask_srav_epi32">_mm256_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srav_epi64.html" title="fn core::arch::x86_64::_mm256_mask_srav_epi64">_mm256_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srl_epi16.html" title="fn core::arch::x86_64::_mm256_mask_srl_epi16">_mm256_mask_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srl_epi32.html" title="fn core::arch::x86_64::_mm256_mask_srl_epi32">_mm256_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srl_epi64.html" title="fn core::arch::x86_64::_mm256_mask_srl_epi64">_mm256_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srli_epi16.html" title="fn core::arch::x86_64::_mm256_mask_srli_epi16">_mm256_mask_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srli_epi32.html" title="fn core::arch::x86_64::_mm256_mask_srli_epi32">_mm256_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srli_epi64.html" title="fn core::arch::x86_64::_mm256_mask_srli_epi64">_mm256_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srlv_epi16.html" title="fn core::arch::x86_64::_mm256_mask_srlv_epi16">_mm256_mask_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srlv_epi32.html" title="fn core::arch::x86_64::_mm256_mask_srlv_epi32">_mm256_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_srlv_epi64.html" title="fn core::arch::x86_64::_mm256_mask_srlv_epi64">_mm256_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_epi32.html" title="fn core::arch::x86_64::_mm256_mask_store_epi32">_mm256_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_epi64.html" title="fn core::arch::x86_64::_mm256_mask_store_epi64">_mm256_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_pd.html" title="fn core::arch::x86_64::_mm256_mask_store_pd">_mm256_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_store_ps.html" title="fn core::arch::x86_64::_mm256_mask_store_ps">_mm256_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_mask_storeu_epi8">_mm256_mask_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 8 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_mask_storeu_epi16">_mm256_mask_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 16 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi32.html" title="fn core::arch::x86_64::_mm256_mask_storeu_epi32">_mm256_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_epi64.html" title="fn core::arch::x86_64::_mm256_mask_storeu_epi64">_mm256_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_pd.html" title="fn core::arch::x86_64::_mm256_mask_storeu_pd">_mm256_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_storeu_ps.html" title="fn core::arch::x86_64::_mm256_mask_storeu_ps">_mm256_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi8.html" title="fn core::arch::x86_64::_mm256_mask_sub_epi8">_mm256_mask_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi16.html" title="fn core::arch::x86_64::_mm256_mask_sub_epi16">_mm256_mask_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi32.html" title="fn core::arch::x86_64::_mm256_mask_sub_epi32">_mm256_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_epi64.html" title="fn core::arch::x86_64::_mm256_mask_sub_epi64">_mm256_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_pd.html" title="fn core::arch::x86_64::_mm256_mask_sub_pd">_mm256_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_sub_ps.html" title="fn core::arch::x86_64::_mm256_mask_sub_ps">_mm256_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_subs_epi8.html" title="fn core::arch::x86_64::_mm256_mask_subs_epi8">_mm256_mask_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_subs_epi16.html" title="fn core::arch::x86_64::_mm256_mask_subs_epi16">_mm256_mask_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_subs_epu8.html" title="fn core::arch::x86_64::_mm256_mask_subs_epu8">_mm256_mask_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_subs_epu16.html" title="fn core::arch::x86_64::_mm256_mask_subs_epu16">_mm256_mask_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm256_mask_ternarylogic_epi32">_mm256_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm256_mask_ternarylogic_epi64">_mm256_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_test_epi8_mask">_mm256_mask_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_test_epi16_mask">_mm256_mask_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_test_epi32_mask">_mm256_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_test_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_test_epi64_mask">_mm256_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm256_mask_testn_epi8_mask">_mm256_mask_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm256_mask_testn_epi16_mask">_mm256_mask_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm256_mask_testn_epi32_mask">_mm256_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm256_mask_testn_epi64_mask">_mm256_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_epi8">_mm256_mask_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_epi16">_mm256_mask_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_epi32">_mm256_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_epi64">_mm256_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_pd.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_pd">_mm256_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpackhi_ps.html" title="fn core::arch::x86_64::_mm256_mask_unpackhi_ps">_mm256_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_epi8">_mm256_mask_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_epi16">_mm256_mask_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_epi32">_mm256_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_epi64">_mm256_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_pd.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_pd">_mm256_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_unpacklo_ps.html" title="fn core::arch::x86_64::_mm256_mask_unpacklo_ps">_mm256_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_xor_epi32.html" title="fn core::arch::x86_64::_mm256_mask_xor_epi32">_mm256_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_xor_epi64.html" title="fn core::arch::x86_64::_mm256_mask_xor_epi64">_mm256_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_abs_epi8">_mm256_maskz_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_abs_epi16">_mm256_maskz_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_abs_epi32">_mm256_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_abs_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_abs_epi64">_mm256_maskz_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_add_epi8">_mm256_maskz_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_add_epi16">_mm256_maskz_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_add_epi32">_mm256_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_add_epi64">_mm256_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_pd.html" title="fn core::arch::x86_64::_mm256_maskz_add_pd">_mm256_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_add_ps.html" title="fn core::arch::x86_64::_mm256_maskz_add_ps">_mm256_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_adds_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_adds_epi8">_mm256_maskz_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_adds_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_adds_epi16">_mm256_maskz_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_adds_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_adds_epu8">_mm256_maskz_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_adds_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_adds_epu16">_mm256_maskz_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_alignr_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_alignr_epi8">_mm256_maskz_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未设置相应的掩码位时，元素将被清零))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_alignr_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_alignr_epi32">_mm256_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_alignr_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_alignr_epi64">_mm256_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_and_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_and_epi32">_mm256_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_and_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_and_epi64">_mm256_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_andnot_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_andnot_epi32">_mm256_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_andnot_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_andnot_epi64">_mm256_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_avg_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_avg_epu8">_mm256_maskz_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_avg_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_avg_epu16">_mm256_maskz_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm256_maskz_broadcast_f32x4">_mm256_maskz_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm256_maskz_broadcast_i32x4">_mm256_maskz_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastb_epi8">_mm256_maskz_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastd_epi32">_mm256_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastq_epi64">_mm256_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastsd_pd">_mm256_maskz_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastss_ps.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastss_ps">_mm256_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_broadcastw_epi16">_mm256_maskz_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_compress_epi8">_mm256_maskz_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_compress_epi16">_mm256_maskz_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_compress_epi32">_mm256_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_compress_epi64">_mm256_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_pd.html" title="fn core::arch::x86_64::_mm256_maskz_compress_pd">_mm256_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_compress_ps.html" title="fn core::arch::x86_64::_mm256_maskz_compress_ps">_mm256_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_conflict_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_conflict_epi32">_mm256_maskz_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_conflict_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_conflict_epi64">_mm256_maskz_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm256_maskz_cvt_roundps_ph">_mm256_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi8_epi16">_mm256_maskz_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi8_epi32">_mm256_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi8_epi64">_mm256_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi16_epi8">_mm256_maskz_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi16_epi32">_mm256_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi16_epi64">_mm256_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi32_epi8">_mm256_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi32_epi16">_mm256_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi32_epi64">_mm256_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi32_pd">_mm256_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi32_ps">_mm256_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi64_epi8">_mm256_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi64_epi16">_mm256_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepi64_epi32">_mm256_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu8_epi16">_mm256_maskz_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu8_epi32">_mm256_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数 a 的低 8 字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu8_epi64">_mm256_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu16_epi32">_mm256_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu16_epi64">_mm256_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu32_epi64">_mm256_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm256_maskz_cvtepu32_pd">_mm256_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm256_maskz_cvtne2ps_pbh">_mm256_maskz_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm256_maskz_cvtneps_pbh">_mm256_maskz_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtpd_epi32">_mm256_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtpd_epu32">_mm256_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtpd_ps.html" title="fn core::arch::x86_64::_mm256_maskz_cvtpd_ps">_mm256_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtph_ps.html" title="fn core::arch::x86_64::_mm256_maskz_cvtph_ps">_mm256_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtps_epi32">_mm256_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtps_epu32">_mm256_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtps_ph.html" title="fn core::arch::x86_64::_mm256_maskz_cvtps_ph">_mm256_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi16_epi8">_mm256_maskz_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi32_epi8">_mm256_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi32_epi16">_mm256_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi64_epi8">_mm256_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi64_epi16">_mm256_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtsepi64_epi32">_mm256_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvttpd_epi32">_mm256_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_cvttpd_epu32">_mm256_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttps_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvttps_epi32">_mm256_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvttps_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_cvttps_epu32">_mm256_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi16_epi8">_mm256_maskz_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi32_epi8">_mm256_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi32_epi16">_mm256_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi64_epi8">_mm256_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi64_epi16">_mm256_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_cvtusepi64_epi32">_mm256_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dbsad_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_dbsad_epu8">_mm256_maskz_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_div_pd.html" title="fn core::arch::x86_64::_mm256_maskz_div_pd">_mm256_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_div_ps.html" title="fn core::arch::x86_64::_mm256_maskz_div_ps">_mm256_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dpbf16_ps.html" title="fn core::arch::x86_64::_mm256_maskz_dpbf16_ps">_mm256_maskz_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_dpbusd_epi32">_mm256_maskz_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_dpbusds_epi32">_mm256_maskz_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_dpwssd_epi32">_mm256_maskz_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_dpwssds_epi32">_mm256_maskz_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_expand_epi8">_mm256_maskz_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_expand_epi16">_mm256_maskz_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_expand_epi32">_mm256_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_expand_epi64">_mm256_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_pd.html" title="fn core::arch::x86_64::_mm256_maskz_expand_pd">_mm256_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expand_ps.html" title="fn core::arch::x86_64::_mm256_maskz_expand_ps">_mm256_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_epi8">_mm256_maskz_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_epi16">_mm256_maskz_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_epi32">_mm256_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 32 位整数 (在掩码 k 中设置了相应位的那些)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_epi64">_mm256_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_pd.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_pd">_mm256_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_expandloadu_ps.html" title="fn core::arch::x86_64::_mm256_maskz_expandloadu_ps">_mm256_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm256_maskz_extractf32x4_ps">_mm256_maskz_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_extracti32x4_epi32">_mm256_maskz_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fixupimm_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fixupimm_pd">_mm256_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fixupimm_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fixupimm_ps">_mm256_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmadd_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fmadd_pd">_mm256_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmadd_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fmadd_ps">_mm256_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fmaddsub_pd">_mm256_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fmaddsub_ps">_mm256_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsub_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fmsub_pd">_mm256_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsub_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fmsub_ps">_mm256_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fmsubadd_pd">_mm256_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fmsubadd_ps">_mm256_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmadd_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fnmadd_pd">_mm256_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmadd_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fnmadd_ps">_mm256_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmsub_pd.html" title="fn core::arch::x86_64::_mm256_maskz_fnmsub_pd">_mm256_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_fnmsub_ps.html" title="fn core::arch::x86_64::_mm256_maskz_fnmsub_ps">_mm256_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getexp_pd.html" title="fn core::arch::x86_64::_mm256_maskz_getexp_pd">_mm256_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getexp_ps.html" title="fn core::arch::x86_64::_mm256_maskz_getexp_ps">_mm256_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getmant_pd.html" title="fn core::arch::x86_64::_mm256_maskz_getmant_pd">_mm256_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_getmant_ps.html" title="fn core::arch::x86_64::_mm256_maskz_getmant_ps">_mm256_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_gf2p8affine_epi64_epi8">_mm256_maskz_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_gf2p8affineinv_epi64_epi8">_mm256_maskz_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_gf2p8mul_epi8">_mm256_maskz_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_insertf32x4.html" title="fn core::arch::x86_64::_mm256_maskz_insertf32x4">_mm256_maskz_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_inserti32x4.html" title="fn core::arch::x86_64::_mm256_maskz_inserti32x4">_mm256_maskz_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_load_epi32">_mm256_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_load_epi64">_mm256_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_pd.html" title="fn core::arch::x86_64::_mm256_maskz_load_pd">_mm256_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_load_ps.html" title="fn core::arch::x86_64::_mm256_maskz_load_ps">_mm256_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_epi8">_mm256_maskz_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_epi16">_mm256_maskz_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_epi32">_mm256_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_epi64">_mm256_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_pd.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_pd">_mm256_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_loadu_ps.html" title="fn core::arch::x86_64::_mm256_maskz_loadu_ps">_mm256_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_lzcnt_epi32">_mm256_maskz_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_lzcnt_epi64">_mm256_maskz_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_madd_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_madd_epi16">_mm256_maskz_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_maddubs_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_maddubs_epi16">_mm256_maskz_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的一对中间有符号 16 位整数，并使用 zeromask k 将饱和结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_max_epi8">_mm256_maskz_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_max_epi16">_mm256_maskz_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_max_epi32">_mm256_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_max_epi64">_mm256_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_max_epu8">_mm256_maskz_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_max_epu16">_mm256_maskz_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_max_epu32">_mm256_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_epu64.html" title="fn core::arch::x86_64::_mm256_maskz_max_epu64">_mm256_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_pd.html" title="fn core::arch::x86_64::_mm256_maskz_max_pd">_mm256_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_max_ps.html" title="fn core::arch::x86_64::_mm256_maskz_max_ps">_mm256_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_min_epi8">_mm256_maskz_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_min_epi16">_mm256_maskz_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_min_epi32">_mm256_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_min_epi64">_mm256_maskz_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_min_epu8">_mm256_maskz_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_min_epu16">_mm256_maskz_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_min_epu32">_mm256_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_epu64.html" title="fn core::arch::x86_64::_mm256_maskz_min_epu64">_mm256_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_pd.html" title="fn core::arch::x86_64::_mm256_maskz_min_pd">_mm256_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_min_ps.html" title="fn core::arch::x86_64::_mm256_maskz_min_ps">_mm256_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_mov_epi8">_mm256_maskz_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_mov_epi16">_mm256_maskz_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_mov_epi32">_mm256_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 32 位整数从 a 移至 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_mov_epi64">_mm256_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 64 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_pd.html" title="fn core::arch::x86_64::_mm256_maskz_mov_pd">_mm256_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mov_ps.html" title="fn core::arch::x86_64::_mm256_maskz_mov_ps">_mm256_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_movedup_pd.html" title="fn core::arch::x86_64::_mm256_maskz_movedup_pd">_mm256_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_movehdup_ps.html" title="fn core::arch::x86_64::_mm256_maskz_movehdup_ps">_mm256_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_moveldup_ps.html" title="fn core::arch::x86_64::_mm256_maskz_moveldup_ps">_mm256_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_mul_epi32">_mm256_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_epu32.html" title="fn core::arch::x86_64::_mm256_maskz_mul_epu32">_mm256_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_pd.html" title="fn core::arch::x86_64::_mm256_maskz_mul_pd">_mm256_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mul_ps.html" title="fn core::arch::x86_64::_mm256_maskz_mul_ps">_mm256_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mulhi_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_mulhi_epi16">_mm256_maskz_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mulhi_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_mulhi_epu16">_mm256_maskz_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_mulhrs_epi16">_mm256_maskz_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mullo_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_mullo_epi16">_mm256_maskz_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_mullo_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_mullo_epi32">_mm256_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_multishift_epi64_epi8">_mm256_maskz_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_or_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_or_epi32">_mm256_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_or_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_or_epi64">_mm256_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_packs_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_packs_epi16">_mm256_maskz_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_packs_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_packs_epi32">_mm256_maskz_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_packus_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_packus_epi16">_mm256_maskz_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_packus_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_packus_epi32">_mm256_maskz_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permute_pd.html" title="fn core::arch::x86_64::_mm256_maskz_permute_pd">_mm256_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permute_ps.html" title="fn core::arch::x86_64::_mm256_maskz_permute_ps">_mm256_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutevar_pd.html" title="fn core::arch::x86_64::_mm256_maskz_permutevar_pd">_mm256_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutevar_ps.html" title="fn core::arch::x86_64::_mm256_maskz_permutevar_ps">_mm256_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_epi8">_mm256_maskz_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_epi16">_mm256_maskz_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_epi32">_mm256_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_epi64">_mm256_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_pd.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_pd">_mm256_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引将 a 和 b 中的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex2var_ps.html" title="fn core::arch::x86_64::_mm256_maskz_permutex2var_ps">_mm256_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_permutex_epi64">_mm256_maskz_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutex_pd.html" title="fn core::arch::x86_64::_mm256_maskz_permutex_pd">_mm256_maskz_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_epi8">_mm256_maskz_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_epi16">_mm256_maskz_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_epi32">_mm256_maskz_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_epi64">_mm256_maskz_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_pd.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_pd">_mm256_maskz_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_permutexvar_ps.html" title="fn core::arch::x86_64::_mm256_maskz_permutexvar_ps">_mm256_maskz_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_popcnt_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_popcnt_epi8">_mm256_maskz_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_popcnt_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_popcnt_epi16">_mm256_maskz_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_popcnt_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_popcnt_epi32">_mm256_maskz_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_popcnt_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_popcnt_epi64">_mm256_maskz_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rcp14_pd.html" title="fn core::arch::x86_64::_mm256_maskz_rcp14_pd">_mm256_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rcp14_ps.html" title="fn core::arch::x86_64::_mm256_maskz_rcp14_ps">_mm256_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rol_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_rol_epi32">_mm256_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rol_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_rol_epi64">_mm256_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rolv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_rolv_epi32">_mm256_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rolv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_rolv_epi64">_mm256_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ror_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_ror_epi32">_mm256_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ror_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_ror_epi64">_mm256_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rorv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_rorv_epi32">_mm256_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rorv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_rorv_epi64">_mm256_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_roundscale_pd.html" title="fn core::arch::x86_64::_mm256_maskz_roundscale_pd">_mm256_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_roundscale_ps.html" title="fn core::arch::x86_64::_mm256_maskz_roundscale_ps">_mm256_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm256_maskz_rsqrt14_pd">_mm256_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm256_maskz_rsqrt14_ps">_mm256_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_scalef_pd.html" title="fn core::arch::x86_64::_mm256_maskz_scalef_pd">_mm256_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_scalef_ps.html" title="fn core::arch::x86_64::_mm256_maskz_scalef_ps">_mm256_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_set1_epi8">_mm256_maskz_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_set1_epi16">_mm256_maskz_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_set1_epi32">_mm256_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_set1_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_set1_epi64">_mm256_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldi_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shldi_epi16">_mm256_maskz_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldi_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_shldi_epi32">_mm256_maskz_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldi_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_shldi_epi64">_mm256_maskz_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldv_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shldv_epi16">_mm256_maskz_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_shldv_epi32">_mm256_maskz_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shldv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_shldv_epi64">_mm256_maskz_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdi_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shrdi_epi16">_mm256_maskz_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdi_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_shrdi_epi32">_mm256_maskz_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdi_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_shrdi_epi64">_mm256_maskz_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdv_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shrdv_epi16">_mm256_maskz_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_shrdv_epi32">_mm256_maskz_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shrdv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_shrdv_epi64">_mm256_maskz_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_epi8">_mm256_maskz_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_epi32">_mm256_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_f32x4">_mm256_maskz_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_f64x2">_mm256_maskz_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_i32x4">_mm256_maskz_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_i64x2">_mm256_maskz_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_pd.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_pd">_mm256_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shuffle_ps.html" title="fn core::arch::x86_64::_mm256_maskz_shuffle_ps">_mm256_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shufflehi_epi16">_mm256_maskz_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 zeromask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，元素被清零) .</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_shufflelo_epi16">_mm256_maskz_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 writemask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sll_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_sll_epi16">_mm256_maskz_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sll_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_sll_epi32">_mm256_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sll_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_sll_epi64">_mm256_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_slli_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_slli_epi16">_mm256_maskz_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_slli_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_slli_epi32">_mm256_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_slli_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_slli_epi64">_mm256_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sllv_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_sllv_epi16">_mm256_maskz_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sllv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_sllv_epi32">_mm256_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sllv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_sllv_epi64">_mm256_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sqrt_pd.html" title="fn core::arch::x86_64::_mm256_maskz_sqrt_pd">_mm256_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sqrt_ps.html" title="fn core::arch::x86_64::_mm256_maskz_sqrt_ps">_mm256_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sra_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_sra_epi16">_mm256_maskz_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sra_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_sra_epi32">_mm256_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sra_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_sra_epi64">_mm256_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srai_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_srai_epi16">_mm256_maskz_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srai_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_srai_epi32">_mm256_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srai_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_srai_epi64">_mm256_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srav_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_srav_epi16">_mm256_maskz_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srav_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_srav_epi32">_mm256_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srav_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_srav_epi64">_mm256_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srl_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_srl_epi16">_mm256_maskz_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srl_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_srl_epi32">_mm256_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srl_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_srl_epi64">_mm256_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srli_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_srli_epi16">_mm256_maskz_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srli_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_srli_epi32">_mm256_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srli_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_srli_epi64">_mm256_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srlv_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_srlv_epi16">_mm256_maskz_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srlv_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_srlv_epi32">_mm256_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_srlv_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_srlv_epi64">_mm256_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_sub_epi8">_mm256_maskz_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_sub_epi16">_mm256_maskz_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_sub_epi32">_mm256_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_sub_epi64">_mm256_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_pd.html" title="fn core::arch::x86_64::_mm256_maskz_sub_pd">_mm256_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_sub_ps.html" title="fn core::arch::x86_64::_mm256_maskz_sub_ps">_mm256_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_subs_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_subs_epi8">_mm256_maskz_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_subs_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_subs_epi16">_mm256_maskz_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_subs_epu8.html" title="fn core::arch::x86_64::_mm256_maskz_subs_epu8">_mm256_maskz_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_subs_epu16.html" title="fn core::arch::x86_64::_mm256_maskz_subs_epu16">_mm256_maskz_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_ternarylogic_epi32">_mm256_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 32 位粒度的 zeromask k (当未设置相应的掩码位时，32 位元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_ternarylogic_epi64">_mm256_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 64 位粒度的 zeromask k (当未设置相应的掩码位时，64 位元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_epi8">_mm256_maskz_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_epi16">_mm256_maskz_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_epi32">_mm256_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_epi64">_mm256_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_pd.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_pd">_mm256_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpackhi_ps.html" title="fn core::arch::x86_64::_mm256_maskz_unpackhi_ps">_mm256_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_epi8">_mm256_maskz_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_epi16">_mm256_maskz_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_epi32">_mm256_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_epi64">_mm256_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_pd.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_pd">_mm256_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_unpacklo_ps.html" title="fn core::arch::x86_64::_mm256_maskz_unpacklo_ps">_mm256_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_xor_epi32.html" title="fn core::arch::x86_64::_mm256_maskz_xor_epi32">_mm256_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskz_xor_epi64.html" title="fn core::arch::x86_64::_mm256_maskz_xor_epi64">_mm256_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epi64.html" title="fn core::arch::x86_64::_mm256_max_epi64">_mm256_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epu64.html" title="fn core::arch::x86_64::_mm256_max_epu64">_mm256_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epi64.html" title="fn core::arch::x86_64::_mm256_min_epi64">_mm256_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epu64.html" title="fn core::arch::x86_64::_mm256_min_epu64">_mm256_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movepi8_mask.html" title="fn core::arch::x86_64::_mm256_movepi8_mask">_mm256_movepi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据相应封装的 8 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movepi16_mask.html" title="fn core::arch::x86_64::_mm256_movepi16_mask">_mm256_movepi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据相应封装的 16 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movm_epi8.html" title="fn core::arch::x86_64::_mm256_movm_epi8">_mm256_movm_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 8 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movm_epi16.html" title="fn core::arch::x86_64::_mm256_movm_epi16">_mm256_movm_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 16 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm256_multishift_epi64_epi8">_mm256_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_epi32.html" title="fn core::arch::x86_64::_mm256_or_epi32">_mm256_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_epi64.html" title="fn core::arch::x86_64::_mm256_or_epi64">_mm256_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm256_permutex2var_epi8">_mm256_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm256_permutex2var_epi16">_mm256_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm256_permutex2var_epi32">_mm256_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm256_permutex2var_epi64">_mm256_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_pd.html" title="fn core::arch::x86_64::_mm256_permutex2var_pd">_mm256_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex2var_ps.html" title="fn core::arch::x86_64::_mm256_permutex2var_ps">_mm256_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex_epi64.html" title="fn core::arch::x86_64::_mm256_permutex_epi64">_mm256_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutex_pd.html" title="fn core::arch::x86_64::_mm256_permutex_pd">_mm256_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm256_permutexvar_epi8">_mm256_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引将 a 中的 8 位整数打乱到 lanes 中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm256_permutexvar_epi16">_mm256_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm256_permutexvar_epi32">_mm256_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm256_permutexvar_epi64">_mm256_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_pd.html" title="fn core::arch::x86_64::_mm256_permutexvar_pd">_mm256_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutexvar_ps.html" title="fn core::arch::x86_64::_mm256_permutexvar_ps">_mm256_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的单精度 (32-bit) 浮点元素进行打乱。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_popcnt_epi8.html" title="fn core::arch::x86_64::_mm256_popcnt_epi8">_mm256_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_popcnt_epi16.html" title="fn core::arch::x86_64::_mm256_popcnt_epi16">_mm256_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_popcnt_epi32.html" title="fn core::arch::x86_64::_mm256_popcnt_epi32">_mm256_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_popcnt_epi64.html" title="fn core::arch::x86_64::_mm256_popcnt_epi64">_mm256_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rcp14_pd.html" title="fn core::arch::x86_64::_mm256_rcp14_pd">_mm256_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rcp14_ps.html" title="fn core::arch::x86_64::_mm256_rcp14_ps">_mm256_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rol_epi32.html" title="fn core::arch::x86_64::_mm256_rol_epi32">_mm256_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rol_epi64.html" title="fn core::arch::x86_64::_mm256_rol_epi64">_mm256_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rolv_epi32.html" title="fn core::arch::x86_64::_mm256_rolv_epi32">_mm256_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rolv_epi64.html" title="fn core::arch::x86_64::_mm256_rolv_epi64">_mm256_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ror_epi32.html" title="fn core::arch::x86_64::_mm256_ror_epi32">_mm256_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ror_epi64.html" title="fn core::arch::x86_64::_mm256_ror_epi64">_mm256_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rorv_epi32.html" title="fn core::arch::x86_64::_mm256_rorv_epi32">_mm256_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rorv_epi64.html" title="fn core::arch::x86_64::_mm256_rorv_epi64">_mm256_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_roundscale_pd.html" title="fn core::arch::x86_64::_mm256_roundscale_pd">_mm256_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_roundscale_ps.html" title="fn core::arch::x86_64::_mm256_roundscale_ps">_mm256_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_scalef_pd.html" title="fn core::arch::x86_64::_mm256_scalef_pd">_mm256_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_scalef_ps.html" title="fn core::arch::x86_64::_mm256_scalef_ps">_mm256_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldi_epi16.html" title="fn core::arch::x86_64::_mm256_shldi_epi16">_mm256_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldi_epi32.html" title="fn core::arch::x86_64::_mm256_shldi_epi32">_mm256_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldi_epi64.html" title="fn core::arch::x86_64::_mm256_shldi_epi64">_mm256_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldv_epi16.html" title="fn core::arch::x86_64::_mm256_shldv_epi16">_mm256_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldv_epi32.html" title="fn core::arch::x86_64::_mm256_shldv_epi32">_mm256_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shldv_epi64.html" title="fn core::arch::x86_64::_mm256_shldv_epi64">_mm256_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdi_epi16.html" title="fn core::arch::x86_64::_mm256_shrdi_epi16">_mm256_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdi_epi32.html" title="fn core::arch::x86_64::_mm256_shrdi_epi32">_mm256_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdi_epi64.html" title="fn core::arch::x86_64::_mm256_shrdi_epi64">_mm256_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdv_epi16.html" title="fn core::arch::x86_64::_mm256_shrdv_epi16">_mm256_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdv_epi32.html" title="fn core::arch::x86_64::_mm256_shrdv_epi32">_mm256_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shrdv_epi64.html" title="fn core::arch::x86_64::_mm256_shrdv_epi64">_mm256_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm256_shuffle_f32x4">_mm256_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm256_shuffle_f64x2">_mm256_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm256_shuffle_i32x4">_mm256_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm256_shuffle_i64x2">_mm256_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sllv_epi16.html" title="fn core::arch::x86_64::_mm256_sllv_epi16">_mm256_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sra_epi64.html" title="fn core::arch::x86_64::_mm256_sra_epi64">_mm256_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srai_epi64.html" title="fn core::arch::x86_64::_mm256_srai_epi64">_mm256_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srav_epi16.html" title="fn core::arch::x86_64::_mm256_srav_epi16">_mm256_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srav_epi64.html" title="fn core::arch::x86_64::_mm256_srav_epi64">_mm256_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srlv_epi16.html" title="fn core::arch::x86_64::_mm256_srlv_epi16">_mm256_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_epi32.html" title="fn core::arch::x86_64::_mm256_store_epi32">_mm256_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_epi64.html" title="fn core::arch::x86_64::_mm256_store_epi64">_mm256_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi8.html" title="fn core::arch::x86_64::_mm256_storeu_epi8">_mm256_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 32 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi16.html" title="fn core::arch::x86_64::_mm256_storeu_epi16">_mm256_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 16 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi32.html" title="fn core::arch::x86_64::_mm256_storeu_epi32">_mm256_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_epi64.html" title="fn core::arch::x86_64::_mm256_storeu_epi64">_mm256_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm256_ternarylogic_epi32">_mm256_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm256_ternarylogic_epi64">_mm256_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的对应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi8_mask.html" title="fn core::arch::x86_64::_mm256_test_epi8_mask">_mm256_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi16_mask.html" title="fn core::arch::x86_64::_mm256_test_epi16_mask">_mm256_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi32_mask.html" title="fn core::arch::x86_64::_mm256_test_epi32_mask">_mm256_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_test_epi64_mask.html" title="fn core::arch::x86_64::_mm256_test_epi64_mask">_mm256_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm256_testn_epi8_mask">_mm256_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm256_testn_epi16_mask">_mm256_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm256_testn_epi32_mask">_mm256_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm256_testn_epi64_mask">_mm256_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_epi32.html" title="fn core::arch::x86_64::_mm256_xor_epi32">_mm256_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_epi64.html" title="fn core::arch::x86_64::_mm256_xor_epi64">_mm256_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi8.html" title="fn core::arch::x86_64::_mm512_abs_epi8">_mm512_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并将无符号的结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi16.html" title="fn core::arch::x86_64::_mm512_abs_epi16">_mm512_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并将无符号的结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi32.html" title="fn core::arch::x86_64::_mm512_abs_epi32">_mm512_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 32 位整数的绝对值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_epi64.html" title="fn core::arch::x86_64::_mm512_abs_epi64">_mm512_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_pd.html" title="fn core::arch::x86_64::_mm512_abs_pd">_mm512_abs_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_abs_ps.html" title="fn core::arch::x86_64::_mm512_abs_ps">_mm512_abs_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi8.html" title="fn core::arch::x86_64::_mm512_add_epi8">_mm512_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 8 位整数添加到 a 和 b 中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi16.html" title="fn core::arch::x86_64::_mm512_add_epi16">_mm512_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数添加到 a 和 b 中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi32.html" title="fn core::arch::x86_64::_mm512_add_epi32">_mm512_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_epi64.html" title="fn core::arch::x86_64::_mm512_add_epi64">_mm512_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_pd.html" title="fn core::arch::x86_64::_mm512_add_pd">_mm512_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_ps.html" title="fn core::arch::x86_64::_mm512_add_ps">_mm512_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_round_pd.html" title="fn core::arch::x86_64::_mm512_add_round_pd">_mm512_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_add_round_ps.html" title="fn core::arch::x86_64::_mm512_add_round_ps">_mm512_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_adds_epi8.html" title="fn core::arch::x86_64::_mm512_adds_epi8">_mm512_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_adds_epi16.html" title="fn core::arch::x86_64::_mm512_adds_epi16">_mm512_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_adds_epu8.html" title="fn core::arch::x86_64::_mm512_adds_epu8">_mm512_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_adds_epu16.html" title="fn core::arch::x86_64::_mm512_adds_epu16">_mm512_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_aesdec_epi128.html" title="fn core::arch::x86_64::_mm512_aesdec_epi128">_mm512_aesdec_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes,avx512f` only">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 解密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_aesdeclast_epi128.html" title="fn core::arch::x86_64::_mm512_aesdeclast_epi128">_mm512_aesdeclast_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes,avx512f` only">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_aesenc_epi128.html" title="fn core::arch::x86_64::_mm512_aesenc_epi128">_mm512_aesenc_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes,avx512f` only">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_aesenclast_epi128.html" title="fn core::arch::x86_64::_mm512_aesenclast_epi128">_mm512_aesenclast_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vaes,avx512f` only">(x86 or x86-64) and <code>vaes,avx512f</code></span></div><div class="desc docblock-short">使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_alignr_epi8.html" title="fn core::arch::x86_64::_mm512_alignr_epi8">_mm512_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并将低 16 字节存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_alignr_epi32.html" title="fn core::arch::x86_64::_mm512_alignr_epi32">_mm512_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并将低 64 字节 (16 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_alignr_epi64.html" title="fn core::arch::x86_64::_mm512_alignr_epi64">_mm512_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并将低 64 字节 (8 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_epi32.html" title="fn core::arch::x86_64::_mm512_and_epi32">_mm512_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_epi64.html" title="fn core::arch::x86_64::_mm512_and_epi64">_mm512_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 512 位 (由包装的 64 位整数组成) 的按位与，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_and_si512.html" title="fn core::arch::x86_64::_mm512_and_si512">_mm512_and_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 512 位 (代表整数数据) 的按位与，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_epi32.html" title="fn core::arch::x86_64::_mm512_andnot_epi32">_mm512_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_epi64.html" title="fn core::arch::x86_64::_mm512_andnot_epi64">_mm512_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中的 512 位 (由包装的 64 位整数组成) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_andnot_si512.html" title="fn core::arch::x86_64::_mm512_andnot_si512">_mm512_andnot_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中的 512 位 (代表整数数据) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_avg_epu8.html" title="fn core::arch::x86_64::_mm512_avg_epu8">_mm512_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数平均，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_avg_epu16.html" title="fn core::arch::x86_64::_mm512_avg_epu16">_mm512_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装无符号 16 位整数进行平均，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm512_bitshuffle_epi64_mask">_mm512_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm512_broadcast_f32x4">_mm512_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_f64x4.html" title="fn core::arch::x86_64::_mm512_broadcast_f64x4">_mm512_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 广播 4 个包装的双精度 (64-bit) 浮点元素到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm512_broadcast_i32x4">_mm512_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcast_i64x4.html" title="fn core::arch::x86_64::_mm512_broadcast_i64x4">_mm512_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm512_broadcastb_epi8">_mm512_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将低包装的 8 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm512_broadcastd_epi32">_mm512_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将低包装的 32 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastmb_epi64.html" title="fn core::arch::x86_64::_mm512_broadcastmb_epi64">_mm512_broadcastmb_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastmw_epi32.html" title="fn core::arch::x86_64::_mm512_broadcastmw_epi32">_mm512_broadcastmw_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm512_broadcastq_epi64">_mm512_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将低包装的 64 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm512_broadcastsd_pd">_mm512_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 广播低双精度 (64-bit) 浮点元素到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastss_ps.html" title="fn core::arch::x86_64::_mm512_broadcastss_ps">_mm512_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将低单精度 (32-bit) 浮点元素从 A 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm512_broadcastw_epi16">_mm512_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将低包装的 16 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_bslli_epi128.html" title="fn core::arch::x86_64::_mm512_bslli_epi128">_mm512_bslli_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">向左移动 128 位 lane imm8 字节，同时向零移动，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_bsrli_epi128.html" title="fn core::arch::x86_64::_mm512_bsrli_epi128">_mm512_bsrli_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">向右移动 128 位 lane  imm8 字节，同时向零移动，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd128_pd512.html" title="fn core::arch::x86_64::_mm512_castpd128_pd512">_mm512_castpd128_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m128d 的 vector 强制转换为 __m512d 类型； 结果的高 384 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd256_pd512.html" title="fn core::arch::x86_64::_mm512_castpd256_pd512">_mm512_castpd256_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m256d 的 vector 强制转换为 __m512d 类型； 结果的高 256 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd512_pd128.html" title="fn core::arch::x86_64::_mm512_castpd512_pd128">_mm512_castpd512_pd128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512d 的 vector 强制转换为类型为 __m128d 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd512_pd256.html" title="fn core::arch::x86_64::_mm512_castpd512_pd256">_mm512_castpd512_pd256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512d 的 vector 强制转换为类型为 __m256d 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd_ps.html" title="fn core::arch::x86_64::_mm512_castpd_ps">_mm512_castpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512d 的 vector 强制转换为类型 __m512。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castpd_si512.html" title="fn core::arch::x86_64::_mm512_castpd_si512">_mm512_castpd_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512d 的 vector 强制转换为类型为 __m512i 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps128_ps512.html" title="fn core::arch::x86_64::_mm512_castps128_ps512">_mm512_castps128_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m128 的 vector 转换为 __m512 类型； 结果的高 384 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps256_ps512.html" title="fn core::arch::x86_64::_mm512_castps256_ps512">_mm512_castps256_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m256 的 vector 强制转换为类型 __m512； 结果的高 256 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps512_ps128.html" title="fn core::arch::x86_64::_mm512_castps512_ps128">_mm512_castps512_ps128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512 的 vector 强制转换为类型为 __m128 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps512_ps256.html" title="fn core::arch::x86_64::_mm512_castps512_ps256">_mm512_castps512_ps256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512 的 vector 强制转换为类型 __m256。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps_pd.html" title="fn core::arch::x86_64::_mm512_castps_pd">_mm512_castps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512 的 vector 强制转换为类型为 __m512d 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castps_si512.html" title="fn core::arch::x86_64::_mm512_castps_si512">_mm512_castps_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512 的 vector 强制转换为类型 __m512i。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi128_si512.html" title="fn core::arch::x86_64::_mm512_castsi128_si512">_mm512_castsi128_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m128i 的 vector 强制转换为类型 __m512i； 结果的高 384 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi256_si512.html" title="fn core::arch::x86_64::_mm512_castsi256_si512">_mm512_castsi256_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m256i 的 vector 强制转换为类型 __m512i； 结果的高 256 位未定义。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_pd.html" title="fn core::arch::x86_64::_mm512_castsi512_pd">_mm512_castsi512_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512i 的 vector 强制转换为类型为 __m512d 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_ps.html" title="fn core::arch::x86_64::_mm512_castsi512_ps">_mm512_castsi512_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512i 的 vector 强制转换为类型 __m512。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_si128.html" title="fn core::arch::x86_64::_mm512_castsi512_si128">_mm512_castsi512_si128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512i 的 vector 强制转换为类型为 __m128i 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_castsi512_si256.html" title="fn core::arch::x86_64::_mm512_castsi512_si256">_mm512_castsi512_si256</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m512i 的 vector 强制转换为类型为 __m256i 的 vector。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_clmulepi64_epi128.html" title="fn core::arch::x86_64::_mm512_clmulepi64_epi128">_mm512_clmulepi64_epi128</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `vpclmulqdq,avx512f` only">(x86 or x86-64) and <code>vpclmulqdq,avx512f</code></span></div><div class="desc docblock-short">在 4 个 128 位 lanes 中的每一个中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epi8_mask">_mm512_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epi16_mask">_mm512_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epi32_mask">_mm512_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epi64_mask">_mm512_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epu8_mask">_mm512_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epu16_mask">_mm512_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 <code>IMM8</code> 指定的比较操作数比较 a 和 b 中的无符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epu32_mask">_mm512_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmp_epu64_mask">_mm512_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmp_pd_mask">_mm512_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数，比较 a 和 b 中的双精度 (64-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmp_ps_mask">_mm512_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的单精度 (32-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_round_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmp_round_pd_mask">_mm512_cmp_round_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数，比较 a 和 b 中的双精度 (64-bit) 浮点元素，结果存入 mask vector k.<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmp_round_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmp_round_ps_mask">_mm512_cmp_round_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的单精度 (32-bit) 浮点元素，结果存入 mask vector k.<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epi8_mask">_mm512_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epi16_mask">_mm512_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epi32_mask">_mm512_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epi64_mask">_mm512_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epu8_mask">_mm512_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epu16_mask">_mm512_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epu32_mask">_mm512_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_epu64_mask">_mm512_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_pd_mask">_mm512_cmpeq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否相等，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpeq_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpeq_ps_mask">_mm512_cmpeq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否相等，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epi8_mask">_mm512_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epi16_mask">_mm512_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epi32_mask">_mm512_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epi64_mask">_mm512_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epu8_mask">_mm512_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epu16_mask">_mm512_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epu32_mask">_mm512_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmpge_epu64_mask">_mm512_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epi8_mask">_mm512_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epi16_mask">_mm512_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epi32_mask">_mm512_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epi64_mask">_mm512_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epu8_mask">_mm512_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epu16_mask">_mm512_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epu32_mask">_mm512_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmpgt_epu64_mask">_mm512_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epi8_mask">_mm512_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epi16_mask">_mm512_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epi32_mask">_mm512_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epi64_mask">_mm512_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epu8_mask">_mm512_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epu16_mask">_mm512_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epu32_mask">_mm512_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmple_epu64_mask">_mm512_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmple_pd_mask">_mm512_cmple_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包的双精度 (64-bit) 中 a 和 b 中的浮点元素是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmple_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmple_ps_mask">_mm512_cmple_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否小于等于，并将结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epi8_mask">_mm512_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epi16_mask">_mm512_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epi32_mask">_mm512_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epi64_mask">_mm512_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epu8_mask">_mm512_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epu16_mask">_mm512_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epu32_mask">_mm512_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_epu64_mask">_mm512_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_pd_mask">_mm512_cmplt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否小于，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmplt_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmplt_ps_mask">_mm512_cmplt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否小于，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epi8_mask">_mm512_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epi16_mask">_mm512_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epi32_mask">_mm512_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epi64_mask">_mm512_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epu8_mask">_mm512_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epu16_mask">_mm512_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epu32_mask">_mm512_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_epu64_mask">_mm512_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_pd_mask">_mm512_cmpneq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否不相等，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpneq_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpneq_ps_mask">_mm512_cmpneq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否不相等，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnle_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpnle_pd_mask">_mm512_cmpnle_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 中 a 和 b 中的浮点元素是否不小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnle_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpnle_ps_mask">_mm512_cmpnle_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 中 a 和 b 中的浮点元素是否不小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnlt_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpnlt_pd_mask">_mm512_cmpnlt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否不小于，并将结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpnlt_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpnlt_ps_mask">_mm512_cmpnlt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否不小于，并将结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpord_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpord_pd_mask">_mm512_cmpord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否都不是 NaN，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpord_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpord_ps_mask">_mm512_cmpord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否都不是 NaN，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpunord_pd_mask.html" title="fn core::arch::x86_64::_mm512_cmpunord_pd_mask">_mm512_cmpunord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的双精度 (64-bit) 浮点数 a 和 b 中的元素是否为 NaN，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cmpunord_ps_mask.html" title="fn core::arch::x86_64::_mm512_cmpunord_ps_mask">_mm512_cmpunord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较包装的单精度 (32-bit) 浮点数 a 和 b 中的元素是否为 NaN，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_conflict_epi32.html" title="fn core::arch::x86_64::_mm512_conflict_epi32">_mm512_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_conflict_epi64.html" title="fn core::arch::x86_64::_mm512_conflict_epi64">_mm512_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundepi32_ps.html" title="fn core::arch::x86_64::_mm512_cvt_roundepi32_ps">_mm512_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundepu32_ps.html" title="fn core::arch::x86_64::_mm512_cvt_roundepu32_ps">_mm512_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_cvt_roundpd_epi32">_mm512_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_cvt_roundpd_epu32">_mm512_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundpd_ps.html" title="fn core::arch::x86_64::_mm512_cvt_roundpd_ps">_mm512_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundph_ps.html" title="fn core::arch::x86_64::_mm512_cvt_roundph_ps">_mm512_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_cvt_roundps_epi32">_mm512_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_cvt_roundps_epu32">_mm512_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_pd.html" title="fn core::arch::x86_64::_mm512_cvt_roundps_pd">_mm512_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm512_cvt_roundps_ph">_mm512_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm512_cvtepi8_epi16">_mm512_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展到包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm512_cvtepi8_epi32">_mm512_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展到包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepi8_epi64">_mm512_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm512_cvtepi16_epi8">_mm512_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm512_cvtepi16_epi32">_mm512_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepi16_epi64">_mm512_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm512_cvtepi32_epi8">_mm512_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm512_cvtepi32_epi16">_mm512_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepi32_epi64">_mm512_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm512_cvtepi32_pd">_mm512_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装后的带符号的 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm512_cvtepi32_ps">_mm512_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi32lo_pd.html" title="fn core::arch::x86_64::_mm512_cvtepi32lo_pd">_mm512_cvtepi32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将元素进行逐元素转换，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm512_cvtepi64_epi8">_mm512_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm512_cvtepi64_epi16">_mm512_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm512_cvtepi64_epi32">_mm512_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm512_cvtepu8_epi16">_mm512_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm512_cvtepu8_epi32">_mm512_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepu8_epi64">_mm512_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将低 8 字节 sof 中的包装无符号 8 位整数零扩展到包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm512_cvtepu16_epi32">_mm512_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepu16_epi64">_mm512_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm512_cvtepu32_epi64">_mm512_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm512_cvtepu32_pd">_mm512_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32_ps.html" title="fn core::arch::x86_64::_mm512_cvtepu32_ps">_mm512_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtepu32lo_pd.html" title="fn core::arch::x86_64::_mm512_cvtepu32lo_pd">_mm512_cvtepu32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中包装的 32 位无符号整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将每个元素进行逐元素转换，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm512_cvtne2ps_pbh">_mm512_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将两个 512 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm512_cvtneps_pbh">_mm512_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtneps_pbh">Intel’s documentation</a></div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm512_cvtpd_epi32">_mm512_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm512_cvtpd_epu32">_mm512_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_ps.html" title="fn core::arch::x86_64::_mm512_cvtpd_ps">_mm512_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpd_pslo.html" title="fn core::arch::x86_64::_mm512_cvtpd_pslo">_mm512_cvtpd_pslo</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中的包装的双精度 (64-bit) 浮点元素执行逐元素转换为单精度 (32-bit) 浮点元素并将其存储在 dst 中。元素存储在结果 vector 的下半部分，而其余的上半部分位置设置为 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtph_ps.html" title="fn core::arch::x86_64::_mm512_cvtph_ps">_mm512_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_epi32.html" title="fn core::arch::x86_64::_mm512_cvtps_epi32">_mm512_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_epu32.html" title="fn core::arch::x86_64::_mm512_cvtps_epu32">_mm512_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_pd.html" title="fn core::arch::x86_64::_mm512_cvtps_pd">_mm512_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtps_ph.html" title="fn core::arch::x86_64::_mm512_cvtps_ph">_mm512_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtpslo_pd.html" title="fn core::arch::x86_64::_mm512_cvtpslo_pd">_mm512_cvtpslo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">对 v2 中包装的单精度 (32-bit) 浮点元素的下半部分到包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm512_cvtsepi16_epi8">_mm512_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm512_cvtsepi32_epi8">_mm512_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm512_cvtsepi32_epi16">_mm512_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm512_cvtsepi64_epi8">_mm512_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm512_cvtsepi64_epi16">_mm512_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm512_cvtsepi64_epi32">_mm512_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtsi512_si32.html" title="fn core::arch::x86_64::_mm512_cvtsi512_si32">_mm512_cvtsi512_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低 32 位整数复制到 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_cvtt_roundpd_epi32">_mm512_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_cvtt_roundpd_epu32">_mm512_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_cvtt_roundps_epi32">_mm512_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_cvtt_roundps_epu32">_mm512_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm512_cvttpd_epi32">_mm512_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm512_cvttpd_epu32">_mm512_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttps_epi32.html" title="fn core::arch::x86_64::_mm512_cvttps_epi32">_mm512_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvttps_epu32.html" title="fn core::arch::x86_64::_mm512_cvttps_epu32">_mm512_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm512_cvtusepi16_epi8">_mm512_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm512_cvtusepi32_epi8">_mm512_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm512_cvtusepi32_epi16">_mm512_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm512_cvtusepi64_epi8">_mm512_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm512_cvtusepi64_epi16">_mm512_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm512_cvtusepi64_epi32">_mm512_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dbsad_epu8.html" title="fn core::arch::x86_64::_mm512_dbsad_epu8">_mm512_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_pd.html" title="fn core::arch::x86_64::_mm512_div_pd">_mm512_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_ps.html" title="fn core::arch::x86_64::_mm512_div_ps">_mm512_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_round_pd.html" title="fn core::arch::x86_64::_mm512_div_round_pd">_mm512_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_div_round_ps.html" title="fn core::arch::x86_64::_mm512_div_round_ps">_mm512_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dpbf16_ps.html" title="fn core::arch::x86_64::_mm512_dpbf16_ps">_mm512_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素累加，结果存储在 BF16 (16-bit) 浮点对的 dst.Compute 点积中 b、将中间的单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm512_dpbusd_epi32">_mm512_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm512_dpbusds_epi32">_mm512_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm512_dpwssd_epi32">_mm512_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm512_dpwssds_epi32">_mm512_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm512_extractf32x4_ps">_mm512_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extractf64x4_pd.html" title="fn core::arch::x86_64::_mm512_extractf64x4_pd">_mm512_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm512_extracti32x4_epi32">_mm512_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_extracti64x4_epi64.html" title="fn core::arch::x86_64::_mm512_extracti64x4_epi64">_mm512_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_pd.html" title="fn core::arch::x86_64::_mm512_fixupimm_pd">_mm512_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_ps.html" title="fn core::arch::x86_64::_mm512_fixupimm_ps">_mm512_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_round_pd.html" title="fn core::arch::x86_64::_mm512_fixupimm_round_pd">_mm512_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fixupimm_round_ps.html" title="fn core::arch::x86_64::_mm512_fixupimm_round_ps">_mm512_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_pd.html" title="fn core::arch::x86_64::_mm512_fmadd_pd">_mm512_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_ps.html" title="fn core::arch::x86_64::_mm512_fmadd_ps">_mm512_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_fmadd_round_pd">_mm512_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_fmadd_round_ps">_mm512_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm512_fmaddsub_pd">_mm512_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm512_fmaddsub_ps">_mm512_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_round_pd.html" title="fn core::arch::x86_64::_mm512_fmaddsub_round_pd">_mm512_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmaddsub_round_ps.html" title="fn core::arch::x86_64::_mm512_fmaddsub_round_ps">_mm512_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_pd.html" title="fn core::arch::x86_64::_mm512_fmsub_pd">_mm512_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_ps.html" title="fn core::arch::x86_64::_mm512_fmsub_ps">_mm512_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_fmsub_round_pd">_mm512_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_fmsub_round_ps">_mm512_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm512_fmsubadd_pd">_mm512_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm512_fmsubadd_ps">_mm512_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_round_pd.html" title="fn core::arch::x86_64::_mm512_fmsubadd_round_pd">_mm512_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fmsubadd_round_ps.html" title="fn core::arch::x86_64::_mm512_fmsubadd_round_ps">_mm512_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_pd.html" title="fn core::arch::x86_64::_mm512_fnmadd_pd">_mm512_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_ps.html" title="fn core::arch::x86_64::_mm512_fnmadd_ps">_mm512_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_fnmadd_round_pd">_mm512_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_fnmadd_round_ps">_mm512_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_pd.html" title="fn core::arch::x86_64::_mm512_fnmsub_pd">_mm512_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_ps.html" title="fn core::arch::x86_64::_mm512_fnmsub_ps">_mm512_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_fnmsub_round_pd">_mm512_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_fnmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_fnmsub_round_ps">_mm512_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_pd.html" title="fn core::arch::x86_64::_mm512_getexp_pd">_mm512_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_ps.html" title="fn core::arch::x86_64::_mm512_getexp_ps">_mm512_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_round_pd.html" title="fn core::arch::x86_64::_mm512_getexp_round_pd">_mm512_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getexp_round_ps.html" title="fn core::arch::x86_64::_mm512_getexp_round_ps">_mm512_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_pd.html" title="fn core::arch::x86_64::_mm512_getmant_pd">_mm512_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_ps.html" title="fn core::arch::x86_64::_mm512_getmant_ps">_mm512_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_round_pd.html" title="fn core::arch::x86_64::_mm512_getmant_round_pd">_mm512_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_getmant_round_ps.html" title="fn core::arch::x86_64::_mm512_getmant_round_ps">_mm512_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_gf2p8affine_epi64_epi8">_mm512_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_gf2p8affineinv_epi64_epi8">_mm512_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm512_gf2p8mul_epi8">_mm512_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_epi32.html" title="fn core::arch::x86_64::_mm512_i32gather_epi32">_mm512_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_epi64.html" title="fn core::arch::x86_64::_mm512_i32gather_epi64">_mm512_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_pd.html" title="fn core::arch::x86_64::_mm512_i32gather_pd">_mm512_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32gather_ps.html" title="fn core::arch::x86_64::_mm512_i32gather_ps">_mm512_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_epi32.html" title="fn core::arch::x86_64::_mm512_i32scatter_epi32">_mm512_i32scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_epi64.html" title="fn core::arch::x86_64::_mm512_i32scatter_epi64">_mm512_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_pd.html" title="fn core::arch::x86_64::_mm512_i32scatter_pd">_mm512_i32scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i32scatter_ps.html" title="fn core::arch::x86_64::_mm512_i32scatter_ps">_mm512_i32scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_epi32.html" title="fn core::arch::x86_64::_mm512_i64gather_epi32">_mm512_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_epi64.html" title="fn core::arch::x86_64::_mm512_i64gather_epi64">_mm512_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_pd.html" title="fn core::arch::x86_64::_mm512_i64gather_pd">_mm512_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64gather_ps.html" title="fn core::arch::x86_64::_mm512_i64gather_ps">_mm512_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。收集的元素将合并到 dst 中。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_epi32.html" title="fn core::arch::x86_64::_mm512_i64scatter_epi32">_mm512_i64scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_epi64.html" title="fn core::arch::x86_64::_mm512_i64scatter_epi64">_mm512_i64scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_pd.html" title="fn core::arch::x86_64::_mm512_i64scatter_pd">_mm512_i64scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_i64scatter_ps.html" title="fn core::arch::x86_64::_mm512_i64scatter_ps">_mm512_i64scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_insertf32x4.html" title="fn core::arch::x86_64::_mm512_insertf32x4">_mm512_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 dst 中 imm8 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_insertf64x4.html" title="fn core::arch::x86_64::_mm512_insertf64x4">_mm512_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后将 b 中的 256 位 (由 4 个压缩双精度 (64 位) 浮点元素组成) 插入到 dst 中 imm8 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_inserti32x4.html" title="fn core::arch::x86_64::_mm512_inserti32x4">_mm512_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后将 b 中的 128 位 (由 4 个压缩的 32 位整数组成) 插入到 dst 中 imm8 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_inserti64x4.html" title="fn core::arch::x86_64::_mm512_inserti64x4">_mm512_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 dst，然后在 imm8 指定的位置将 256 位 (由 4 个包装的 64 位整数组成) 插入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_int2mask.html" title="fn core::arch::x86_64::_mm512_int2mask">_mm512_int2mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将整数掩码转换为位掩码，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kand.html" title="fn core::arch::x86_64::_mm512_kand">_mm512_kand</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kandn.html" title="fn core::arch::x86_64::_mm512_kandn">_mm512_kandn</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 的按位非运算，然后与 b 进行与运算，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kmov.html" title="fn core::arch::x86_64::_mm512_kmov">_mm512_kmov</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 16 位掩码 a 复制到 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_knot.html" title="fn core::arch::x86_64::_mm512_knot">_mm512_knot</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 的按位非，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kor.html" title="fn core::arch::x86_64::_mm512_kor">_mm512_kor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kortestc.html" title="fn core::arch::x86_64::_mm512_kortestc">_mm512_kortestc</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 k1 和 k2 之间执行按位或运算，将结果存储在 dst 中。如果 dst 全为 1，则设置 CF 标志。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kunpackb.html" title="fn core::arch::x86_64::_mm512_kunpackb">_mm512_kunpackb</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">解包并交织掩码 a 和 b 的 8 位，并将 16 位结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kxnor.html" title="fn core::arch::x86_64::_mm512_kxnor">_mm512_kxnor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_kxor.html" title="fn core::arch::x86_64::_mm512_kxor">_mm512_kxor</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 16 位掩码 a 和 b 的按位异或，并将结果存储在 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_epi32.html" title="fn core::arch::x86_64::_mm512_load_epi32">_mm512_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_epi64.html" title="fn core::arch::x86_64::_mm512_load_epi64">_mm512_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_pd.html" title="fn core::arch::x86_64::_mm512_load_pd">_mm512_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_ps.html" title="fn core::arch::x86_64::_mm512_load_ps">_mm512_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_load_si512.html" title="fn core::arch::x86_64::_mm512_load_si512">_mm512_load_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位整数数据从内存加载到 dst 中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi8.html" title="fn core::arch::x86_64::_mm512_loadu_epi8">_mm512_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 512 位 (由 64 个包装的 8 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi16.html" title="fn core::arch::x86_64::_mm512_loadu_epi16">_mm512_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 512 位 (由 32 个包装的 16 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi32.html" title="fn core::arch::x86_64::_mm512_loadu_epi32">_mm512_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_epi64.html" title="fn core::arch::x86_64::_mm512_loadu_epi64">_mm512_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_pd.html" title="fn core::arch::x86_64::_mm512_loadu_pd">_mm512_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从内存中加载 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_ps.html" title="fn core::arch::x86_64::_mm512_loadu_ps">_mm512_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从内存中将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_loadu_si512.html" title="fn core::arch::x86_64::_mm512_loadu_si512">_mm512_loadu_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 512 位整数数据从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm512_lzcnt_epi32">_mm512_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm512_lzcnt_epi64">_mm512_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_madd52hi_epu64.html" title="fn core::arch::x86_64::_mm512_madd52hi_epu64">_mm512_madd52hi_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma` only">(x86 or x86-64) and <code>avx512ifma</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_madd52lo_epu64.html" title="fn core::arch::x86_64::_mm512_madd52lo_epu64">_mm512_madd52lo_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma` only">(x86 or x86-64) and <code>avx512ifma</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_madd_epi16.html" title="fn core::arch::x86_64::_mm512_madd_epi16">_mm512_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将相邻的 32 位中间整数对水平相加，并将结果打包到 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maddubs_epi16.html" title="fn core::arch::x86_64::_mm512_maddubs_epi16">_mm512_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的每个无符号 8 位整数与 b 中对应的有符号 8 位整数垂直相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并将饱和结果包装到 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_epi8">_mm512_mask2_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_epi16">_mm512_mask2_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_epi32">_mm512_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_epi64">_mm512_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_pd.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_pd">_mm512_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2_permutex2var_ps.html" title="fn core::arch::x86_64::_mm512_mask2_permutex2var_ps">_mm512_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的对应选择器和索引在 a 和 b 中的 lanes 中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask2int.html" title="fn core::arch::x86_64::_mm512_mask2int">_mm512_mask2int</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将位掩码 k1 转换为整数值，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmadd_pd">_mm512_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmadd_ps">_mm512_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmadd_round_pd">_mm512_mask3_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmadd_round_ps">_mm512_mask3_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmaddsub_pd">_mm512_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmaddsub_ps">_mm512_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmaddsub_round_pd">_mm512_mask3_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmaddsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmaddsub_round_ps">_mm512_mask3_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmsub_pd">_mm512_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmsub_ps">_mm512_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmsub_round_pd">_mm512_mask3_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmsub_round_ps">_mm512_mask3_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmsubadd_pd">_mm512_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmsubadd_ps">_mm512_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fmsubadd_round_pd">_mm512_mask3_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fmsubadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fmsubadd_round_ps">_mm512_mask3_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fnmadd_pd">_mm512_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fnmadd_ps">_mm512_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fnmadd_round_pd">_mm512_mask3_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fnmadd_round_ps">_mm512_mask3_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fnmsub_pd">_mm512_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fnmsub_ps">_mm512_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask3_fnmsub_round_pd">_mm512_mask3_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask3_fnmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask3_fnmsub_round_ps">_mm512_mask3_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi8.html" title="fn core::arch::x86_64::_mm512_mask_abs_epi8">_mm512_mask_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi16.html" title="fn core::arch::x86_64::_mm512_mask_abs_epi16">_mm512_mask_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi32.html" title="fn core::arch::x86_64::_mm512_mask_abs_epi32">_mm512_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 32 位整数的绝对值，并使用写掩码 <code>k</code> 将无符号结果存储在 <code>dst</code> 中 (如果未设置相应的掩码位，则从 <code>src</code> 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_epi64.html" title="fn core::arch::x86_64::_mm512_mask_abs_epi64">_mm512_mask_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_pd.html" title="fn core::arch::x86_64::_mm512_mask_abs_pd">_mm512_mask_abs_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_abs_ps.html" title="fn core::arch::x86_64::_mm512_mask_abs_ps">_mm512_mask_abs_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi8.html" title="fn core::arch::x86_64::_mm512_mask_add_epi8">_mm512_mask_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi16.html" title="fn core::arch::x86_64::_mm512_mask_add_epi16">_mm512_mask_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi32.html" title="fn core::arch::x86_64::_mm512_mask_add_epi32">_mm512_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_epi64.html" title="fn core::arch::x86_64::_mm512_mask_add_epi64">_mm512_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_pd.html" title="fn core::arch::x86_64::_mm512_mask_add_pd">_mm512_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_ps.html" title="fn core::arch::x86_64::_mm512_mask_add_ps">_mm512_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_add_round_pd">_mm512_mask_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_add_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_add_round_ps">_mm512_mask_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_adds_epi8.html" title="fn core::arch::x86_64::_mm512_mask_adds_epi8">_mm512_mask_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_adds_epi16.html" title="fn core::arch::x86_64::_mm512_mask_adds_epi16">_mm512_mask_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_adds_epu8.html" title="fn core::arch::x86_64::_mm512_mask_adds_epu8">_mm512_mask_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_adds_epu16.html" title="fn core::arch::x86_64::_mm512_mask_adds_epu16">_mm512_mask_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_alignr_epi8.html" title="fn core::arch::x86_64::_mm512_mask_alignr_epi8">_mm512_mask_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的屏蔽位未置位时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_alignr_epi32.html" title="fn core::arch::x86_64::_mm512_mask_alignr_epi32">_mm512_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用写掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_alignr_epi64.html" title="fn core::arch::x86_64::_mm512_mask_alignr_epi64">_mm512_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用写掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_and_epi32.html" title="fn core::arch::x86_64::_mm512_mask_and_epi32">_mm512_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_and_epi64.html" title="fn core::arch::x86_64::_mm512_mask_and_epi64">_mm512_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_andnot_epi32.html" title="fn core::arch::x86_64::_mm512_mask_andnot_epi32">_mm512_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_andnot_epi64.html" title="fn core::arch::x86_64::_mm512_mask_andnot_epi64">_mm512_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_avg_epu8.html" title="fn core::arch::x86_64::_mm512_mask_avg_epu8">_mm512_mask_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_avg_epu16.html" title="fn core::arch::x86_64::_mm512_mask_avg_epu16">_mm512_mask_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_bitshuffle_epi64_mask">_mm512_mask_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi8.html" title="fn core::arch::x86_64::_mm512_mask_blend_epi8">_mm512_mask_blend_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi16.html" title="fn core::arch::x86_64::_mm512_mask_blend_epi16">_mm512_mask_blend_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi32.html" title="fn core::arch::x86_64::_mm512_mask_blend_epi32">_mm512_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_epi64.html" title="fn core::arch::x86_64::_mm512_mask_blend_epi64">_mm512_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_pd.html" title="fn core::arch::x86_64::_mm512_mask_blend_pd">_mm512_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_blend_ps.html" title="fn core::arch::x86_64::_mm512_mask_blend_ps">_mm512_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm512_mask_broadcast_f32x4">_mm512_mask_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_f64x4.html" title="fn core::arch::x86_64::_mm512_mask_broadcast_f64x4">_mm512_mask_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm512_mask_broadcast_i32x4">_mm512_mask_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcast_i64x4.html" title="fn core::arch::x86_64::_mm512_mask_broadcast_i64x4">_mm512_mask_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 a 的 4 个包装的 64 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm512_mask_broadcastb_epi8">_mm512_mask_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_broadcastd_epi32">_mm512_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm512_mask_broadcastq_epi64">_mm512_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm512_mask_broadcastsd_pd">_mm512_mask_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastss_ps.html" title="fn core::arch::x86_64::_mm512_mask_broadcastss_ps">_mm512_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm512_mask_broadcastw_epi16">_mm512_mask_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epi8_mask">_mm512_mask_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epi16_mask">_mm512_mask_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epi32_mask">_mm512_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epi64_mask">_mm512_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epu8_mask">_mm512_mask_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epu16_mask">_mm512_mask_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epu32_mask">_mm512_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_epu64_mask">_mm512_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_pd_mask">_mm512_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_ps_mask">_mm512_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_round_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_round_pd_mask">_mm512_mask_cmp_round_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmp_round_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmp_round_ps_mask">_mm512_mask_cmp_round_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epi8_mask">_mm512_mask_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epi16_mask">_mm512_mask_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epi32_mask">_mm512_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epi64_mask">_mm512_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epu8_mask">_mm512_mask_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epu16_mask">_mm512_mask_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epu32_mask">_mm512_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_epu64_mask">_mm512_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_pd_mask">_mm512_mask_cmpeq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpeq_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpeq_ps_mask">_mm512_mask_cmpeq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epi8_mask">_mm512_mask_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epi16_mask">_mm512_mask_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epi32_mask">_mm512_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epi64_mask">_mm512_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epu8_mask">_mm512_mask_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epu16_mask">_mm512_mask_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epu32_mask">_mm512_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpge_epu64_mask">_mm512_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epi8_mask">_mm512_mask_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epi16_mask">_mm512_mask_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epi32_mask">_mm512_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epi64_mask">_mm512_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epu8_mask">_mm512_mask_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epu16_mask">_mm512_mask_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epu32_mask">_mm512_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpgt_epu64_mask">_mm512_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epi8_mask">_mm512_mask_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epi16_mask">_mm512_mask_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epi32_mask">_mm512_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epi64_mask">_mm512_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epu8_mask">_mm512_mask_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epu16_mask">_mm512_mask_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epu32_mask">_mm512_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_epu64_mask">_mm512_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_pd_mask">_mm512_mask_cmple_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmple_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmple_ps_mask">_mm512_mask_cmple_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epi8_mask">_mm512_mask_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epi16_mask">_mm512_mask_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epi32_mask">_mm512_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epi64_mask">_mm512_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epu8_mask">_mm512_mask_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epu16_mask">_mm512_mask_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epu32_mask">_mm512_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_epu64_mask">_mm512_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_pd_mask">_mm512_mask_cmplt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素的小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmplt_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmplt_ps_mask">_mm512_mask_cmplt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epi8_mask">_mm512_mask_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epi16_mask">_mm512_mask_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epi32_mask">_mm512_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epi64_mask">_mm512_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epu8_mask">_mm512_mask_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epu16_mask">_mm512_mask_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epu32_mask">_mm512_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_epu64_mask">_mm512_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_pd_mask">_mm512_mask_cmpneq_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpneq_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpneq_ps_mask">_mm512_mask_cmpneq_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnle_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpnle_pd_mask">_mm512_mask_cmpnle_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnle_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpnle_ps_mask">_mm512_mask_cmpnle_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnlt_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpnlt_pd_mask">_mm512_mask_cmpnlt_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpnlt_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpnlt_ps_mask">_mm512_mask_cmpnlt_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpord_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpord_pd_mask">_mm512_mask_cmpord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpord_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpord_ps_mask">_mm512_mask_cmpord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpunord_pd_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpunord_pd_mask">_mm512_mask_cmpunord_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素以查看是否为 NaN，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cmpunord_ps_mask.html" title="fn core::arch::x86_64::_mm512_mask_cmpunord_ps_mask">_mm512_mask_cmpunord_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否为 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi8.html" title="fn core::arch::x86_64::_mm512_mask_compress_epi8">_mm512_mask_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi16.html" title="fn core::arch::x86_64::_mm512_mask_compress_epi16">_mm512_mask_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi32.html" title="fn core::arch::x86_64::_mm512_mask_compress_epi32">_mm512_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_epi64.html" title="fn core::arch::x86_64::_mm512_mask_compress_epi64">_mm512_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_pd.html" title="fn core::arch::x86_64::_mm512_mask_compress_pd">_mm512_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compress_ps.html" title="fn core::arch::x86_64::_mm512_mask_compress_ps">_mm512_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_epi8">_mm512_mask_compressstoreu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (其各自的位在 writemask k 中设置) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_epi16">_mm512_mask_compressstoreu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (其各自的位在 writemask k 中设置的那些) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_epi32">_mm512_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活动的 32 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_epi64.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_epi64">_mm512_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活动的 64 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_pd.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_pd">_mm512_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活动的双精度 (64 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_compressstoreu_ps.html" title="fn core::arch::x86_64::_mm512_mask_compressstoreu_ps">_mm512_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活动的单精度 (32 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_conflict_epi32.html" title="fn core::arch::x86_64::_mm512_mask_conflict_epi32">_mm512_mask_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">使用写掩码 k (当未设置相应的掩码位时，将从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_conflict_epi64.html" title="fn core::arch::x86_64::_mm512_mask_conflict_epi64">_mm512_mask_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，将从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundepi32_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundepi32_ps">_mm512_mask_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundepu32_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundepu32_ps">_mm512_mask_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundpd_epi32">_mm512_mask_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundpd_epu32">_mm512_mask_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundpd_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundpd_ps">_mm512_mask_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundph_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundph_ps">_mm512_mask_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundps_epi32">_mm512_mask_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundps_epu32">_mm512_mask_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundps_pd">_mm512_mask_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm512_mask_cvt_roundps_ph">_mm512_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi8_epi16">_mm512_mask_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi8_epi32">_mm512_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi8_epi64">_mm512_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi16_epi8">_mm512_mask_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi16_epi32">_mm512_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi16_epi64">_mm512_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi16_storeu_epi8">_mm512_mask_cvtepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_epi8">_mm512_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_epi16">_mm512_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_epi64">_mm512_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_pd">_mm512_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_ps">_mm512_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_storeu_epi8">_mm512_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32_storeu_epi16">_mm512_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi32lo_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi32lo_pd">_mm512_mask_cvtepi32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，进行逐元素转换，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_epi8">_mm512_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_epi16">_mm512_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_epi32">_mm512_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi8">_mm512_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi16">_mm512_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepi64_storeu_epi32">_mm512_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu8_epi16">_mm512_mask_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu8_epi32">_mm512_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu8_epi64">_mm512_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu16_epi32">_mm512_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu16_epi64">_mm512_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu32_epi64">_mm512_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu32_pd">_mm512_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu32_ps">_mm512_mask_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtepu32lo_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtepu32lo_pd">_mm512_mask_cvtepu32lo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中 32 位无符号整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中，使用 writemask k (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm512_mask_cvtne2ps_pbh">_mm512_mask_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm512_mask_cvtneps_pbh">_mm512_mask_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtpd_epi32">_mm512_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvtpd_epu32">_mm512_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvtpd_ps">_mm512_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpd_pslo.html" title="fn core::arch::x86_64::_mm512_mask_cvtpd_pslo">_mm512_mask_cvtpd_pslo</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中的包装的双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将其逐个元素转换，并使用 writemask k 将它们存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。元素存储在结果 vector 的下半部分，而其余的上半部分位置设置为 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtph_ps.html" title="fn core::arch::x86_64::_mm512_mask_cvtph_ps">_mm512_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtps_epi32">_mm512_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvtps_epu32">_mm512_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtps_pd">_mm512_mask_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtps_ph.html" title="fn core::arch::x86_64::_mm512_mask_cvtps_ph">_mm512_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtpslo_pd.html" title="fn core::arch::x86_64::_mm512_mask_cvtpslo_pd">_mm512_mask_cvtpslo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 v2 中包装的单精度 (32-bit) 浮点元素的下半部分转换为包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi16_epi8">_mm512_mask_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi16_storeu_epi8">_mm512_mask_cvtsepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi32_epi8">_mm512_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi32_epi16">_mm512_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi32_storeu_epi8">_mm512_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi32_storeu_epi16">_mm512_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_epi8">_mm512_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_epi16">_mm512_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_epi32">_mm512_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi8">_mm512_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi16">_mm512_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtsepi64_storeu_epi32">_mm512_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtt_roundpd_epi32">_mm512_mask_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvtt_roundpd_epu32">_mm512_mask_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtt_roundps_epi32">_mm512_mask_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvtt_roundps_epu32">_mm512_mask_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvttpd_epi32">_mm512_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvttpd_epu32">_mm512_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttps_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvttps_epi32">_mm512_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvttps_epu32.html" title="fn core::arch::x86_64::_mm512_mask_cvttps_epu32">_mm512_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi16_epi8">_mm512_mask_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi16_storeu_epi8">_mm512_mask_cvtusepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi32_epi8">_mm512_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi32_epi16">_mm512_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi32_storeu_epi8">_mm512_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi32_storeu_epi16">_mm512_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_epi8">_mm512_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_epi16">_mm512_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_epi32">_mm512_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi8">_mm512_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi16">_mm512_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_cvtusepi64_storeu_epi32">_mm512_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dbsad_epu8.html" title="fn core::arch::x86_64::_mm512_mask_dbsad_epu8">_mm512_mask_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_pd.html" title="fn core::arch::x86_64::_mm512_mask_div_pd">_mm512_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_ps.html" title="fn core::arch::x86_64::_mm512_mask_div_ps">_mm512_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_div_round_pd">_mm512_mask_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_div_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_div_round_ps">_mm512_mask_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dpbf16_ps.html" title="fn core::arch::x86_64::_mm512_mask_dpbf16_ps">_mm512_mask_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_dpbusd_epi32">_mm512_mask_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm512_mask_dpbusds_epi32">_mm512_mask_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm512_mask_dpwssd_epi32">_mm512_mask_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm512_mask_dpwssds_epi32">_mm512_mask_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi8.html" title="fn core::arch::x86_64::_mm512_mask_expand_epi8">_mm512_mask_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi16.html" title="fn core::arch::x86_64::_mm512_mask_expand_epi16">_mm512_mask_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi32.html" title="fn core::arch::x86_64::_mm512_mask_expand_epi32">_mm512_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_epi64.html" title="fn core::arch::x86_64::_mm512_mask_expand_epi64">_mm512_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_pd.html" title="fn core::arch::x86_64::_mm512_mask_expand_pd">_mm512_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expand_ps.html" title="fn core::arch::x86_64::_mm512_mask_expand_ps">_mm512_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_epi8">_mm512_mask_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_epi16">_mm512_mask_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_epi32">_mm512_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从未对齐内存中的 mem_addr 加载连续的活动 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_epi64">_mm512_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_pd.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_pd">_mm512_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_expandloadu_ps.html" title="fn core::arch::x86_64::_mm512_mask_expandloadu_ps">_mm512_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm512_mask_extractf32x4_ps">_mm512_mask_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extractf64x4_pd.html" title="fn core::arch::x86_64::_mm512_mask_extractf64x4_pd">_mm512_mask_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm512_mask_extracti32x4_epi32">_mm512_mask_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，用 writemask k 将结果存入 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_extracti64x4_epi64.html" title="fn core::arch::x86_64::_mm512_mask_extracti64x4_epi64">_mm512_mask_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_pd.html" title="fn core::arch::x86_64::_mm512_mask_fixupimm_pd">_mm512_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_ps.html" title="fn core::arch::x86_64::_mm512_mask_fixupimm_ps">_mm512_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fixupimm_round_pd">_mm512_mask_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fixupimm_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fixupimm_round_ps">_mm512_mask_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmadd_pd">_mm512_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmadd_ps">_mm512_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmadd_round_pd">_mm512_mask_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmadd_round_ps">_mm512_mask_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmaddsub_pd">_mm512_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmaddsub_ps">_mm512_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmaddsub_round_pd">_mm512_mask_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmaddsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmaddsub_round_ps">_mm512_mask_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmsub_pd">_mm512_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmsub_ps">_mm512_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmsub_round_pd">_mm512_mask_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmsub_round_ps">_mm512_mask_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmsubadd_pd">_mm512_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmsubadd_ps">_mm512_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fmsubadd_round_pd">_mm512_mask_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fmsubadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fmsubadd_round_ps">_mm512_mask_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_pd.html" title="fn core::arch::x86_64::_mm512_mask_fnmadd_pd">_mm512_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_ps.html" title="fn core::arch::x86_64::_mm512_mask_fnmadd_ps">_mm512_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fnmadd_round_pd">_mm512_mask_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fnmadd_round_ps">_mm512_mask_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_pd.html" title="fn core::arch::x86_64::_mm512_mask_fnmsub_pd">_mm512_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_ps.html" title="fn core::arch::x86_64::_mm512_mask_fnmsub_ps">_mm512_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_fnmsub_round_pd">_mm512_mask_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_fnmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_fnmsub_round_ps">_mm512_mask_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_pd.html" title="fn core::arch::x86_64::_mm512_mask_getexp_pd">_mm512_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_ps.html" title="fn core::arch::x86_64::_mm512_mask_getexp_ps">_mm512_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_getexp_round_pd">_mm512_mask_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getexp_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_getexp_round_ps">_mm512_mask_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_pd.html" title="fn core::arch::x86_64::_mm512_mask_getmant_pd">_mm512_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_ps.html" title="fn core::arch::x86_64::_mm512_mask_getmant_ps">_mm512_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_getmant_round_pd">_mm512_mask_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_getmant_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_getmant_round_ps">_mm512_mask_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_gf2p8affine_epi64_epi8">_mm512_mask_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_gf2p8affineinv_epi64_epi8">_mm512_mask_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm512_mask_gf2p8mul_epi8">_mm512_mask_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_epi32.html" title="fn core::arch::x86_64::_mm512_mask_i32gather_epi32">_mm512_mask_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_epi64.html" title="fn core::arch::x86_64::_mm512_mask_i32gather_epi64">_mm512_mask_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_pd.html" title="fn core::arch::x86_64::_mm512_mask_i32gather_pd">_mm512_mask_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32gather_ps.html" title="fn core::arch::x86_64::_mm512_mask_i32gather_ps">_mm512_mask_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_epi32.html" title="fn core::arch::x86_64::_mm512_mask_i32scatter_epi32">_mm512_mask_i32scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (未设置相应掩码位时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_epi64.html" title="fn core::arch::x86_64::_mm512_mask_i32scatter_epi64">_mm512_mask_i32scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (未设置相应掩码位时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_pd.html" title="fn core::arch::x86_64::_mm512_mask_i32scatter_pd">_mm512_mask_i32scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (未设置相应掩码位时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i32scatter_ps.html" title="fn core::arch::x86_64::_mm512_mask_i32scatter_ps">_mm512_mask_i32scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (未设置相应掩码位时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_epi32.html" title="fn core::arch::x86_64::_mm512_mask_i64gather_epi32">_mm512_mask_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_epi64.html" title="fn core::arch::x86_64::_mm512_mask_i64gather_epi64">_mm512_mask_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_pd.html" title="fn core::arch::x86_64::_mm512_mask_i64gather_pd">_mm512_mask_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64gather_ps.html" title="fn core::arch::x86_64::_mm512_mask_i64gather_ps">_mm512_mask_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)。使用 writemask k 将收集的元素合并到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_epi32.html" title="fn core::arch::x86_64::_mm512_mask_i64scatter_epi32">_mm512_mask_i64scatter_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_epi64.html" title="fn core::arch::x86_64::_mm512_mask_i64scatter_epi64">_mm512_mask_i64scatter_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (当相应掩码位未设置时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_pd.html" title="fn core::arch::x86_64::_mm512_mask_i64scatter_pd">_mm512_mask_i64scatter_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例中的因子进行缩放) 受掩码 k 的约束 (当相应掩码位未设置时，不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_i64scatter_ps.html" title="fn core::arch::x86_64::_mm512_mask_i64scatter_ps">_mm512_mask_i64scatter_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引都按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。scale 应该是 1, 2, 4 或者 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_insertf32x4.html" title="fn core::arch::x86_64::_mm512_mask_insertf32x4">_mm512_mask_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_insertf64x4.html" title="fn core::arch::x86_64::_mm512_mask_insertf64x4">_mm512_mask_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 256 位 (由 4 个压缩双精度 (64 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_inserti32x4.html" title="fn core::arch::x86_64::_mm512_mask_inserti32x4">_mm512_mask_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_inserti64x4.html" title="fn core::arch::x86_64::_mm512_mask_inserti64x4">_mm512_mask_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_epi32.html" title="fn core::arch::x86_64::_mm512_mask_load_epi32">_mm512_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_epi64.html" title="fn core::arch::x86_64::_mm512_mask_load_epi64">_mm512_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_pd.html" title="fn core::arch::x86_64::_mm512_mask_load_pd">_mm512_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_load_ps.html" title="fn core::arch::x86_64::_mm512_mask_load_ps">_mm512_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_loadu_epi8">_mm512_mask_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_loadu_epi16">_mm512_mask_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_loadu_epi32">_mm512_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_epi64.html" title="fn core::arch::x86_64::_mm512_mask_loadu_epi64">_mm512_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_pd.html" title="fn core::arch::x86_64::_mm512_mask_loadu_pd">_mm512_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_loadu_ps.html" title="fn core::arch::x86_64::_mm512_mask_loadu_ps">_mm512_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm512_mask_lzcnt_epi32">_mm512_mask_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm512_mask_lzcnt_epi64">_mm512_mask_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_madd_epi16.html" title="fn core::arch::x86_64::_mm512_mask_madd_epi16">_mm512_mask_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_maddubs_epi16.html" title="fn core::arch::x86_64::_mm512_mask_maddubs_epi16">_mm512_mask_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi8.html" title="fn core::arch::x86_64::_mm512_mask_max_epi8">_mm512_mask_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi16.html" title="fn core::arch::x86_64::_mm512_mask_max_epi16">_mm512_mask_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi32.html" title="fn core::arch::x86_64::_mm512_mask_max_epi32">_mm512_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epi64.html" title="fn core::arch::x86_64::_mm512_mask_max_epi64">_mm512_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu8.html" title="fn core::arch::x86_64::_mm512_mask_max_epu8">_mm512_mask_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu16.html" title="fn core::arch::x86_64::_mm512_mask_max_epu16">_mm512_mask_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu32.html" title="fn core::arch::x86_64::_mm512_mask_max_epu32">_mm512_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_epu64.html" title="fn core::arch::x86_64::_mm512_mask_max_epu64">_mm512_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_pd.html" title="fn core::arch::x86_64::_mm512_mask_max_pd">_mm512_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_ps.html" title="fn core::arch::x86_64::_mm512_mask_max_ps">_mm512_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_max_round_pd">_mm512_mask_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_max_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_max_round_ps">_mm512_mask_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi8.html" title="fn core::arch::x86_64::_mm512_mask_min_epi8">_mm512_mask_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi16.html" title="fn core::arch::x86_64::_mm512_mask_min_epi16">_mm512_mask_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi32.html" title="fn core::arch::x86_64::_mm512_mask_min_epi32">_mm512_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epi64.html" title="fn core::arch::x86_64::_mm512_mask_min_epi64">_mm512_mask_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu8.html" title="fn core::arch::x86_64::_mm512_mask_min_epu8">_mm512_mask_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu16.html" title="fn core::arch::x86_64::_mm512_mask_min_epu16">_mm512_mask_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu32.html" title="fn core::arch::x86_64::_mm512_mask_min_epu32">_mm512_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_epu64.html" title="fn core::arch::x86_64::_mm512_mask_min_epu64">_mm512_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_pd.html" title="fn core::arch::x86_64::_mm512_mask_min_pd">_mm512_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_ps.html" title="fn core::arch::x86_64::_mm512_mask_min_ps">_mm512_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_min_round_pd">_mm512_mask_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_min_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_min_round_ps">_mm512_mask_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi8.html" title="fn core::arch::x86_64::_mm512_mask_mov_epi8">_mm512_mask_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi16.html" title="fn core::arch::x86_64::_mm512_mask_mov_epi16">_mm512_mask_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi32.html" title="fn core::arch::x86_64::_mm512_mask_mov_epi32">_mm512_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_epi64.html" title="fn core::arch::x86_64::_mm512_mask_mov_epi64">_mm512_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_pd.html" title="fn core::arch::x86_64::_mm512_mask_mov_pd">_mm512_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mov_ps.html" title="fn core::arch::x86_64::_mm512_mask_mov_ps">_mm512_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_movedup_pd.html" title="fn core::arch::x86_64::_mm512_mask_movedup_pd">_mm512_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_movehdup_ps.html" title="fn core::arch::x86_64::_mm512_mask_movehdup_ps">_mm512_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_moveldup_ps.html" title="fn core::arch::x86_64::_mm512_mask_moveldup_ps">_mm512_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_epi32.html" title="fn core::arch::x86_64::_mm512_mask_mul_epi32">_mm512_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_epu32.html" title="fn core::arch::x86_64::_mm512_mask_mul_epu32">_mm512_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_pd.html" title="fn core::arch::x86_64::_mm512_mask_mul_pd">_mm512_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_ps.html" title="fn core::arch::x86_64::_mm512_mask_mul_ps">_mm512_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_mul_round_pd">_mm512_mask_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mul_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_mul_round_ps">_mm512_mask_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mulhi_epi16.html" title="fn core::arch::x86_64::_mm512_mask_mulhi_epi16">_mm512_mask_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mulhi_epu16.html" title="fn core::arch::x86_64::_mm512_mask_mulhi_epu16">_mm512_mask_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm512_mask_mulhrs_epi16">_mm512_mask_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mullo_epi16.html" title="fn core::arch::x86_64::_mm512_mask_mullo_epi16">_mm512_mask_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mullo_epi32.html" title="fn core::arch::x86_64::_mm512_mask_mullo_epi32">_mm512_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_mullox_epi64.html" title="fn core::arch::x86_64::_mm512_mask_mullox_epi64">_mm512_mask_mullox_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数 vectors a 和 b 中的元素相乘，使用写掩码 k 将结果的低 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_mask_multishift_epi64_epi8">_mm512_mask_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_or_epi32.html" title="fn core::arch::x86_64::_mm512_mask_or_epi32">_mm512_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_or_epi64.html" title="fn core::arch::x86_64::_mm512_mask_or_epi64">_mm512_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_packs_epi16.html" title="fn core::arch::x86_64::_mm512_mask_packs_epi16">_mm512_mask_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_packs_epi32.html" title="fn core::arch::x86_64::_mm512_mask_packs_epi32">_mm512_mask_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_packus_epi16.html" title="fn core::arch::x86_64::_mm512_mask_packus_epi16">_mm512_mask_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_packus_epi32.html" title="fn core::arch::x86_64::_mm512_mask_packus_epi32">_mm512_mask_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permute_pd.html" title="fn core::arch::x86_64::_mm512_mask_permute_pd">_mm512_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permute_ps.html" title="fn core::arch::x86_64::_mm512_mask_permute_ps">_mm512_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_epi32.html" title="fn core::arch::x86_64::_mm512_mask_permutevar_epi32">_mm512_mask_permutevar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。请注意，与过去使用 permutevar 名称的内部函数不同，该内部函数在 128 位 lane 上进行了重排。这个内部函数和 _mm512_mask_permutexvar_epi32 是一样的，建议您用那个内部函数名。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_pd.html" title="fn core::arch::x86_64::_mm512_mask_permutevar_pd">_mm512_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutevar_ps.html" title="fn core::arch::x86_64::_mm512_mask_permutevar_ps">_mm512_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_epi8">_mm512_mask_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_epi16">_mm512_mask_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_epi32">_mm512_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_epi64">_mm512_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_pd.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_pd">_mm512_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex2var_ps.html" title="fn core::arch::x86_64::_mm512_mask_permutex2var_ps">_mm512_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 a 和 b 中的 lanes 上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex_epi64.html" title="fn core::arch::x86_64::_mm512_mask_permutex_epi64">_mm512_mask_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutex_pd.html" title="fn core::arch::x86_64::_mm512_mask_permutex_pd">_mm512_mask_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_epi8">_mm512_mask_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_epi16">_mm512_mask_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_epi32">_mm512_mask_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_epi64">_mm512_mask_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_pd.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_pd">_mm512_mask_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_permutexvar_ps.html" title="fn core::arch::x86_64::_mm512_mask_permutexvar_ps">_mm512_mask_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_popcnt_epi8.html" title="fn core::arch::x86_64::_mm512_mask_popcnt_epi8">_mm512_mask_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_popcnt_epi16.html" title="fn core::arch::x86_64::_mm512_mask_popcnt_epi16">_mm512_mask_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_popcnt_epi32.html" title="fn core::arch::x86_64::_mm512_mask_popcnt_epi32">_mm512_mask_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_popcnt_epi64.html" title="fn core::arch::x86_64::_mm512_mask_popcnt_epi64">_mm512_mask_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rcp14_pd.html" title="fn core::arch::x86_64::_mm512_mask_rcp14_pd">_mm512_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rcp14_ps.html" title="fn core::arch::x86_64::_mm512_mask_rcp14_ps">_mm512_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_add_epi32">_mm512_mask_reduce_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过加法来减少 a 中包装的 32 位整数。返回所有活动元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_add_epi64">_mm512_mask_reduce_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回所有活动元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_pd.html" title="fn core::arch::x86_64::_mm512_mask_reduce_add_pd">_mm512_mask_reduce_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过使用掩膜 k 加法来减少包装的双精度 (64-bit) 浮点元素。返回所有活动元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_add_ps.html" title="fn core::arch::x86_64::_mm512_mask_reduce_add_ps">_mm512_mask_reduce_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过使用掩码 k 加法来减少包装的单精度 (32-bit) 浮点元素。返回所有活动元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_and_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_and_epi32">_mm512_mask_reduce_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 按位与减少包装的 32 位整数。返回中所有活动元素的按位与 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_and_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_and_epi64">_mm512_mask_reduce_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回所有活动元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_epi32">_mm512_mask_reduce_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_epi64">_mm512_mask_reduce_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的带符号的 64 位整数。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epu32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_epu32">_mm512_mask_reduce_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的无符号 32 位整数。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_epu64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_epu64">_mm512_mask_reduce_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的无符号 64 位整数。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_pd.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_pd">_mm512_mask_reduce_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_max_ps.html" title="fn core::arch::x86_64::_mm512_mask_reduce_max_ps">_mm512_mask_reduce_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回中所有活动元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_epi32">_mm512_mask_reduce_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_epi64">_mm512_mask_reduce_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的带符号的 64 位整数。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epu32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_epu32">_mm512_mask_reduce_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的无符号 32 位整数。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_epu64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_epu64">_mm512_mask_reduce_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最大减少包装的带符号的 64 位整数。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_pd.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_pd">_mm512_mask_reduce_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_min_ps.html" title="fn core::arch::x86_64::_mm512_mask_reduce_min_ps">_mm512_mask_reduce_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回中所有活动元素的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_mul_epi32">_mm512_mask_reduce_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过乘以减少 a 中包装的 32 位整数。返回中所有活动元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_mul_epi64">_mm512_mask_reduce_mul_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过乘以减少 a 中包装的 64 位整数。返回中所有活动元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_pd.html" title="fn core::arch::x86_64::_mm512_mask_reduce_mul_pd">_mm512_mask_reduce_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过乘以减少 a 中包装的双精度 (64-bit) 浮点元素。返回中所有活动元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_mul_ps.html" title="fn core::arch::x86_64::_mm512_mask_reduce_mul_ps">_mm512_mask_reduce_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 通过乘以减少 a 中包装的单精度 (32-bit) 浮点元素。返回中所有活动元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_or_epi32.html" title="fn core::arch::x86_64::_mm512_mask_reduce_or_epi32">_mm512_mask_reduce_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 按位或减少包装的 32 位整数。返回中所有活动元素的按位或 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_reduce_or_epi64.html" title="fn core::arch::x86_64::_mm512_mask_reduce_or_epi64">_mm512_mask_reduce_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用掩码 k 按位或减少包装的 64 位整数。返回中所有活动元素的按位或 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rol_epi32.html" title="fn core::arch::x86_64::_mm512_mask_rol_epi32">_mm512_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rol_epi64.html" title="fn core::arch::x86_64::_mm512_mask_rol_epi64">_mm512_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rolv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_rolv_epi32">_mm512_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rolv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_rolv_epi64">_mm512_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ror_epi32.html" title="fn core::arch::x86_64::_mm512_mask_ror_epi32">_mm512_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ror_epi64.html" title="fn core::arch::x86_64::_mm512_mask_ror_epi64">_mm512_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rorv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_rorv_epi32">_mm512_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rorv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_rorv_epi64">_mm512_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_pd.html" title="fn core::arch::x86_64::_mm512_mask_roundscale_pd">_mm512_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_ps.html" title="fn core::arch::x86_64::_mm512_mask_roundscale_ps">_mm512_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_roundscale_round_pd">_mm512_mask_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_roundscale_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_roundscale_round_ps">_mm512_mask_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm512_mask_rsqrt14_pd">_mm512_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm512_mask_rsqrt14_ps">_mm512_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_pd.html" title="fn core::arch::x86_64::_mm512_mask_scalef_pd">_mm512_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_ps.html" title="fn core::arch::x86_64::_mm512_mask_scalef_ps">_mm512_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_scalef_round_pd">_mm512_mask_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_scalef_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_scalef_round_ps">_mm512_mask_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi8.html" title="fn core::arch::x86_64::_mm512_mask_set1_epi8">_mm512_mask_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi16.html" title="fn core::arch::x86_64::_mm512_mask_set1_epi16">_mm512_mask_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi32.html" title="fn core::arch::x86_64::_mm512_mask_set1_epi32">_mm512_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_set1_epi64.html" title="fn core::arch::x86_64::_mm512_mask_set1_epi64">_mm512_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldi_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shldi_epi16">_mm512_mask_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldi_epi32.html" title="fn core::arch::x86_64::_mm512_mask_shldi_epi32">_mm512_mask_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldi_epi64.html" title="fn core::arch::x86_64::_mm512_mask_shldi_epi64">_mm512_mask_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldv_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shldv_epi16">_mm512_mask_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_shldv_epi32">_mm512_mask_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shldv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_shldv_epi64">_mm512_mask_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdi_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shrdi_epi16">_mm512_mask_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdi_epi32.html" title="fn core::arch::x86_64::_mm512_mask_shrdi_epi32">_mm512_mask_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdi_epi64.html" title="fn core::arch::x86_64::_mm512_mask_shrdi_epi64">_mm512_mask_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdv_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shrdv_epi16">_mm512_mask_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_shrdv_epi32">_mm512_mask_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shrdv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_shrdv_epi64">_mm512_mask_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_epi8.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_epi8">_mm512_mask_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 b 中相应的 8 位元素中的控件在 128 位 lane 内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_epi32.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_epi32">_mm512_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件将 128 位 lane 中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_f32x4">_mm512_mask_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_f64x2">_mm512_mask_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_i32x4">_mm512_mask_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_i64x2">_mm512_mask_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_pd.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_pd">_mm512_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shuffle_ps.html" title="fn core::arch::x86_64::_mm512_mask_shuffle_ps">_mm512_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shufflehi_epi16">_mm512_mask_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 writemask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm512_mask_shufflelo_epi16">_mm512_mask_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 writemask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sll_epi16.html" title="fn core::arch::x86_64::_mm512_mask_sll_epi16">_mm512_mask_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sll_epi32.html" title="fn core::arch::x86_64::_mm512_mask_sll_epi32">_mm512_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sll_epi64.html" title="fn core::arch::x86_64::_mm512_mask_sll_epi64">_mm512_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_slli_epi16.html" title="fn core::arch::x86_64::_mm512_mask_slli_epi16">_mm512_mask_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_slli_epi32.html" title="fn core::arch::x86_64::_mm512_mask_slli_epi32">_mm512_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_slli_epi64.html" title="fn core::arch::x86_64::_mm512_mask_slli_epi64">_mm512_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sllv_epi16.html" title="fn core::arch::x86_64::_mm512_mask_sllv_epi16">_mm512_mask_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sllv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_sllv_epi32">_mm512_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sllv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_sllv_epi64">_mm512_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_pd.html" title="fn core::arch::x86_64::_mm512_mask_sqrt_pd">_mm512_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_ps.html" title="fn core::arch::x86_64::_mm512_mask_sqrt_ps">_mm512_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_sqrt_round_pd">_mm512_mask_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sqrt_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_sqrt_round_ps">_mm512_mask_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sra_epi16.html" title="fn core::arch::x86_64::_mm512_mask_sra_epi16">_mm512_mask_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sra_epi32.html" title="fn core::arch::x86_64::_mm512_mask_sra_epi32">_mm512_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sra_epi64.html" title="fn core::arch::x86_64::_mm512_mask_sra_epi64">_mm512_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srai_epi16.html" title="fn core::arch::x86_64::_mm512_mask_srai_epi16">_mm512_mask_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srai_epi32.html" title="fn core::arch::x86_64::_mm512_mask_srai_epi32">_mm512_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srai_epi64.html" title="fn core::arch::x86_64::_mm512_mask_srai_epi64">_mm512_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srav_epi16.html" title="fn core::arch::x86_64::_mm512_mask_srav_epi16">_mm512_mask_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srav_epi32.html" title="fn core::arch::x86_64::_mm512_mask_srav_epi32">_mm512_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srav_epi64.html" title="fn core::arch::x86_64::_mm512_mask_srav_epi64">_mm512_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srl_epi16.html" title="fn core::arch::x86_64::_mm512_mask_srl_epi16">_mm512_mask_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srl_epi32.html" title="fn core::arch::x86_64::_mm512_mask_srl_epi32">_mm512_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srl_epi64.html" title="fn core::arch::x86_64::_mm512_mask_srl_epi64">_mm512_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srli_epi16.html" title="fn core::arch::x86_64::_mm512_mask_srli_epi16">_mm512_mask_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srli_epi32.html" title="fn core::arch::x86_64::_mm512_mask_srli_epi32">_mm512_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srli_epi64.html" title="fn core::arch::x86_64::_mm512_mask_srli_epi64">_mm512_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srlv_epi16.html" title="fn core::arch::x86_64::_mm512_mask_srlv_epi16">_mm512_mask_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srlv_epi32.html" title="fn core::arch::x86_64::_mm512_mask_srlv_epi32">_mm512_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_srlv_epi64.html" title="fn core::arch::x86_64::_mm512_mask_srlv_epi64">_mm512_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_epi32.html" title="fn core::arch::x86_64::_mm512_mask_store_epi32">_mm512_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_epi64.html" title="fn core::arch::x86_64::_mm512_mask_store_epi64">_mm512_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_pd.html" title="fn core::arch::x86_64::_mm512_mask_store_pd">_mm512_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_store_ps.html" title="fn core::arch::x86_64::_mm512_mask_store_ps">_mm512_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_mask_storeu_epi8">_mm512_mask_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 8 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_mask_storeu_epi16">_mm512_mask_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 16 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi32.html" title="fn core::arch::x86_64::_mm512_mask_storeu_epi32">_mm512_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_epi64.html" title="fn core::arch::x86_64::_mm512_mask_storeu_epi64">_mm512_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_pd.html" title="fn core::arch::x86_64::_mm512_mask_storeu_pd">_mm512_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_storeu_ps.html" title="fn core::arch::x86_64::_mm512_mask_storeu_ps">_mm512_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi8.html" title="fn core::arch::x86_64::_mm512_mask_sub_epi8">_mm512_mask_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi16.html" title="fn core::arch::x86_64::_mm512_mask_sub_epi16">_mm512_mask_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi32.html" title="fn core::arch::x86_64::_mm512_mask_sub_epi32">_mm512_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_epi64.html" title="fn core::arch::x86_64::_mm512_mask_sub_epi64">_mm512_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_pd.html" title="fn core::arch::x86_64::_mm512_mask_sub_pd">_mm512_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_ps.html" title="fn core::arch::x86_64::_mm512_mask_sub_ps">_mm512_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_round_pd.html" title="fn core::arch::x86_64::_mm512_mask_sub_round_pd">_mm512_mask_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_sub_round_ps.html" title="fn core::arch::x86_64::_mm512_mask_sub_round_ps">_mm512_mask_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_subs_epi8.html" title="fn core::arch::x86_64::_mm512_mask_subs_epi8">_mm512_mask_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_subs_epi16.html" title="fn core::arch::x86_64::_mm512_mask_subs_epi16">_mm512_mask_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_subs_epu8.html" title="fn core::arch::x86_64::_mm512_mask_subs_epu8">_mm512_mask_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_subs_epu16.html" title="fn core::arch::x86_64::_mm512_mask_subs_epu16">_mm512_mask_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm512_mask_ternarylogic_epi32">_mm512_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm512_mask_ternarylogic_epi64">_mm512_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_test_epi8_mask">_mm512_mask_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_test_epi16_mask">_mm512_mask_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_test_epi32_mask">_mm512_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_test_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_test_epi64_mask">_mm512_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm512_mask_testn_epi8_mask">_mm512_mask_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm512_mask_testn_epi16_mask">_mm512_mask_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm512_mask_testn_epi32_mask">_mm512_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm512_mask_testn_epi64_mask">_mm512_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_epi8">_mm512_mask_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_epi16">_mm512_mask_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_epi32">_mm512_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_epi64">_mm512_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_pd.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_pd">_mm512_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpackhi_ps.html" title="fn core::arch::x86_64::_mm512_mask_unpackhi_ps">_mm512_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_epi8">_mm512_mask_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_epi16">_mm512_mask_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_epi32">_mm512_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_epi64">_mm512_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_pd.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_pd">_mm512_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_unpacklo_ps.html" title="fn core::arch::x86_64::_mm512_mask_unpacklo_ps">_mm512_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_xor_epi32.html" title="fn core::arch::x86_64::_mm512_mask_xor_epi32">_mm512_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mask_xor_epi64.html" title="fn core::arch::x86_64::_mm512_mask_xor_epi64">_mm512_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_abs_epi8">_mm512_maskz_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_abs_epi16">_mm512_maskz_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_abs_epi32">_mm512_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 32 位整数的绝对值，并使用零掩码 <code>k</code> 将无符号结果存储在 <code>dst</code> 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_abs_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_abs_epi64">_mm512_maskz_abs_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_add_epi8">_mm512_maskz_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_add_epi16">_mm512_maskz_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_add_epi32">_mm512_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_add_epi64">_mm512_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_pd.html" title="fn core::arch::x86_64::_mm512_maskz_add_pd">_mm512_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_ps.html" title="fn core::arch::x86_64::_mm512_maskz_add_ps">_mm512_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_add_round_pd">_mm512_maskz_add_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_add_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_add_round_ps">_mm512_maskz_add_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_adds_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_adds_epi8">_mm512_maskz_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_adds_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_adds_epi16">_mm512_maskz_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_adds_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_adds_epu8">_mm512_maskz_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_adds_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_adds_epu16">_mm512_maskz_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_alignr_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_alignr_epi8">_mm512_maskz_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未设置相应的掩码位时，元素将被清零))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_alignr_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_alignr_epi32">_mm512_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用零掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_alignr_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_alignr_epi64">_mm512_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用零掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_and_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_and_epi32">_mm512_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_and_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_and_epi64">_mm512_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_andnot_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_andnot_epi32">_mm512_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_andnot_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_andnot_epi64">_mm512_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_avg_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_avg_epu8">_mm512_maskz_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_avg_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_avg_epu16">_mm512_maskz_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_f32x4.html" title="fn core::arch::x86_64::_mm512_maskz_broadcast_f32x4">_mm512_maskz_broadcast_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_f64x4.html" title="fn core::arch::x86_64::_mm512_maskz_broadcast_f64x4">_mm512_maskz_broadcast_f64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_i32x4.html" title="fn core::arch::x86_64::_mm512_maskz_broadcast_i32x4">_mm512_maskz_broadcast_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcast_i64x4.html" title="fn core::arch::x86_64::_mm512_maskz_broadcast_i64x4">_mm512_maskz_broadcast_i64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastb_epi8">_mm512_maskz_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastd_epi32">_mm512_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastq_epi64">_mm512_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastsd_pd">_mm512_maskz_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastss_ps.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastss_ps">_mm512_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_broadcastw_epi16">_mm512_maskz_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_compress_epi8">_mm512_maskz_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_compress_epi16">_mm512_maskz_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_compress_epi32">_mm512_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_compress_epi64">_mm512_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_pd.html" title="fn core::arch::x86_64::_mm512_maskz_compress_pd">_mm512_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_compress_ps.html" title="fn core::arch::x86_64::_mm512_maskz_compress_ps">_mm512_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_conflict_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_conflict_epi32">_mm512_maskz_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_conflict_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_conflict_epi64">_mm512_maskz_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundepi32_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundepi32_ps">_mm512_maskz_cvt_roundepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundepu32_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundepu32_ps">_mm512_maskz_cvt_roundepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundpd_epi32">_mm512_maskz_cvt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundpd_epu32">_mm512_maskz_cvt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundpd_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundpd_ps">_mm512_maskz_cvt_roundpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundph_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundph_ps">_mm512_maskz_cvt_roundph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundps_epi32">_mm512_maskz_cvt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundps_epu32">_mm512_maskz_cvt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_pd.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundps_pd">_mm512_maskz_cvt_roundps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm512_maskz_cvt_roundps_ph">_mm512_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi8_epi16">_mm512_maskz_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi8_epi32">_mm512_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi8_epi64">_mm512_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi16_epi8">_mm512_maskz_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi16_epi32">_mm512_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi16_epi64">_mm512_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi32_epi8">_mm512_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi32_epi16">_mm512_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi32_epi64">_mm512_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi32_pd">_mm512_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi32_ps">_mm512_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi64_epi8">_mm512_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi64_epi16">_mm512_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepi64_epi32">_mm512_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu8_epi16">_mm512_maskz_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu8_epi32">_mm512_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu8_epi64">_mm512_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu16_epi32">_mm512_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu16_epi64">_mm512_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu32_epi64">_mm512_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu32_pd">_mm512_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtepu32_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvtepu32_ps">_mm512_maskz_cvtepu32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm512_maskz_cvtne2ps_pbh">_mm512_maskz_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtneps_pbh.html" title="fn core::arch::x86_64::_mm512_maskz_cvtneps_pbh">_mm512_maskz_cvtneps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtpd_epi32">_mm512_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtpd_epu32">_mm512_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtpd_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvtpd_ps">_mm512_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtph_ps.html" title="fn core::arch::x86_64::_mm512_maskz_cvtph_ps">_mm512_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtps_epi32">_mm512_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtps_epu32">_mm512_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_pd.html" title="fn core::arch::x86_64::_mm512_maskz_cvtps_pd">_mm512_maskz_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtps_ph.html" title="fn core::arch::x86_64::_mm512_maskz_cvtps_ph">_mm512_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi16_epi8">_mm512_maskz_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi32_epi8">_mm512_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi32_epi16">_mm512_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi64_epi8">_mm512_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi64_epi16">_mm512_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtsepi64_epi32">_mm512_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtt_roundpd_epi32">_mm512_maskz_cvtt_roundpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtt_roundpd_epu32">_mm512_maskz_cvtt_roundpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtt_roundps_epi32">_mm512_maskz_cvtt_roundps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtt_roundps_epu32">_mm512_maskz_cvtt_roundps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为带有截断的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvttpd_epi32">_mm512_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvttpd_epu32">_mm512_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttps_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvttps_epi32">_mm512_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvttps_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_cvttps_epu32">_mm512_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi16_epi8">_mm512_maskz_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi32_epi8">_mm512_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi32_epi16">_mm512_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi64_epi8">_mm512_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi64_epi16">_mm512_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_cvtusepi64_epi32">_mm512_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dbsad_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_dbsad_epu8">_mm512_maskz_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_pd.html" title="fn core::arch::x86_64::_mm512_maskz_div_pd">_mm512_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_ps.html" title="fn core::arch::x86_64::_mm512_maskz_div_ps">_mm512_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_div_round_pd">_mm512_maskz_div_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_div_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_div_round_ps">_mm512_maskz_div_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dpbf16_ps.html" title="fn core::arch::x86_64::_mm512_maskz_dpbf16_ps">_mm512_maskz_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512f` only">(x86 or x86-64) and <code>avx512bf16,avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_dpbusd_epi32">_mm512_maskz_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_dpbusds_epi32">_mm512_maskz_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_dpwssd_epi32">_mm512_maskz_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_dpwssds_epi32">_mm512_maskz_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni` only">(x86 or x86-64) and <code>avx512vnni</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_expand_epi8">_mm512_maskz_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_expand_epi16">_mm512_maskz_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_expand_epi32">_mm512_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_expand_epi64">_mm512_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_pd.html" title="fn core::arch::x86_64::_mm512_maskz_expand_pd">_mm512_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expand_ps.html" title="fn core::arch::x86_64::_mm512_maskz_expand_ps">_mm512_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_epi8">_mm512_maskz_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_epi16">_mm512_maskz_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vbmi2` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vbmi2</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_epi32">_mm512_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 32 位整数 (在掩码 k 中设置了相应位的那些)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_epi64">_mm512_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_pd.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_pd">_mm512_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_expandloadu_ps.html" title="fn core::arch::x86_64::_mm512_maskz_expandloadu_ps">_mm512_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extractf32x4_ps.html" title="fn core::arch::x86_64::_mm512_maskz_extractf32x4_ps">_mm512_maskz_extractf32x4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extractf64x4_pd.html" title="fn core::arch::x86_64::_mm512_maskz_extractf64x4_pd">_mm512_maskz_extractf64x4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extracti32x4_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_extracti32x4_epi32">_mm512_maskz_extracti32x4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选择，结果用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_extracti64x4_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_extracti64x4_epi64">_mm512_maskz_extracti64x4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fixupimm_pd">_mm512_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fixupimm_ps">_mm512_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fixupimm_round_pd">_mm512_maskz_fixupimm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fixupimm_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fixupimm_round_ps">_mm512_maskz_fixupimm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmadd_pd">_mm512_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmadd_ps">_mm512_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmadd_round_pd">_mm512_maskz_fmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmadd_round_ps">_mm512_maskz_fmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在使用零掩码 k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmaddsub_pd">_mm512_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmaddsub_ps">_mm512_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmaddsub_round_pd">_mm512_maskz_fmaddsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmaddsub_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmaddsub_round_ps">_mm512_maskz_fmaddsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmsub_pd">_mm512_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmsub_ps">_mm512_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmsub_round_pd">_mm512_maskz_fmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmsub_round_ps">_mm512_maskz_fmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmsubadd_pd">_mm512_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmsubadd_ps">_mm512_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fmsubadd_round_pd">_mm512_maskz_fmsubadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fmsubadd_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fmsubadd_round_ps">_mm512_maskz_fmsubadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fnmadd_pd">_mm512_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fnmadd_ps">_mm512_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fnmadd_round_pd">_mm512_maskz_fnmadd_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmadd_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fnmadd_round_ps">_mm512_maskz_fnmadd_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fnmsub_pd">_mm512_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fnmsub_ps">_mm512_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_fnmsub_round_pd">_mm512_maskz_fnmsub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_fnmsub_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_fnmsub_round_ps">_mm512_maskz_fnmsub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_pd.html" title="fn core::arch::x86_64::_mm512_maskz_getexp_pd">_mm512_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_ps.html" title="fn core::arch::x86_64::_mm512_maskz_getexp_ps">_mm512_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_getexp_round_pd">_mm512_maskz_getexp_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getexp_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_getexp_round_ps">_mm512_maskz_getexp_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_pd.html" title="fn core::arch::x86_64::_mm512_maskz_getmant_pd">_mm512_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_ps.html" title="fn core::arch::x86_64::_mm512_maskz_getmant_ps">_mm512_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_getmant_round_pd">_mm512_maskz_getmant_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_getmant_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_getmant_round_ps">_mm512_maskz_getmant_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_gf2p8affine_epi64_epi8">_mm512_maskz_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_gf2p8affineinv_epi64_epi8">_mm512_maskz_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_gf2p8mul_epi8">_mm512_maskz_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512f` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512f</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_insertf32x4.html" title="fn core::arch::x86_64::_mm512_maskz_insertf32x4">_mm512_maskz_insertf32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 128 位 (由 4 个压缩单精度 (32 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_insertf64x4.html" title="fn core::arch::x86_64::_mm512_maskz_insertf64x4">_mm512_maskz_insertf64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后将 b 中的 256 位 (由 4 个压缩双精度 (64 位) 浮点元素组成) 插入到 tmp 中 imm8 指定的位置。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_inserti32x4.html" title="fn core::arch::x86_64::_mm512_maskz_inserti32x4">_mm512_maskz_inserti32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_inserti64x4.html" title="fn core::arch::x86_64::_mm512_maskz_inserti64x4">_mm512_maskz_inserti64x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_load_epi32">_mm512_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_load_epi64">_mm512_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_pd.html" title="fn core::arch::x86_64::_mm512_maskz_load_pd">_mm512_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_load_ps.html" title="fn core::arch::x86_64::_mm512_maskz_load_ps">_mm512_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_epi8">_mm512_maskz_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_epi16">_mm512_maskz_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw` only">(x86 or x86-64) and <code>avx512f,avx512bw</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_epi32">_mm512_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_epi64">_mm512_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_pd.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_pd">_mm512_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_loadu_ps.html" title="fn core::arch::x86_64::_mm512_maskz_loadu_ps">_mm512_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_lzcnt_epi32">_mm512_maskz_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_lzcnt_epi64">_mm512_maskz_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd` only">(x86 or x86-64) and <code>avx512cd</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_madd_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_madd_epi16">_mm512_maskz_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_maddubs_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_maddubs_epi16">_mm512_maskz_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的一对中间有符号 16 位整数，并使用 zeromask k 将饱和结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_max_epi8">_mm512_maskz_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_max_epi16">_mm512_maskz_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_max_epi32">_mm512_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_max_epi64">_mm512_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_max_epu8">_mm512_maskz_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_max_epu16">_mm512_maskz_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_max_epu32">_mm512_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_epu64.html" title="fn core::arch::x86_64::_mm512_maskz_max_epu64">_mm512_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_pd.html" title="fn core::arch::x86_64::_mm512_maskz_max_pd">_mm512_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_ps.html" title="fn core::arch::x86_64::_mm512_maskz_max_ps">_mm512_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_max_round_pd">_mm512_maskz_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_max_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_max_round_ps">_mm512_maskz_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_min_epi8">_mm512_maskz_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_min_epi16">_mm512_maskz_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_min_epi32">_mm512_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_min_epi64">_mm512_maskz_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_min_epu8">_mm512_maskz_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_min_epu16">_mm512_maskz_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_min_epu32">_mm512_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_epu64.html" title="fn core::arch::x86_64::_mm512_maskz_min_epu64">_mm512_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_pd.html" title="fn core::arch::x86_64::_mm512_maskz_min_pd">_mm512_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_ps.html" title="fn core::arch::x86_64::_mm512_maskz_min_ps">_mm512_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_min_round_pd">_mm512_maskz_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_min_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_min_round_ps">_mm512_maskz_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_mov_epi8">_mm512_maskz_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_mov_epi16">_mm512_maskz_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_mov_epi32">_mm512_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 32 位整数从 a 移至 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_mov_epi64">_mm512_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 64 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_pd.html" title="fn core::arch::x86_64::_mm512_maskz_mov_pd">_mm512_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mov_ps.html" title="fn core::arch::x86_64::_mm512_maskz_mov_ps">_mm512_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_movedup_pd.html" title="fn core::arch::x86_64::_mm512_maskz_movedup_pd">_mm512_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_movehdup_ps.html" title="fn core::arch::x86_64::_mm512_maskz_movehdup_ps">_mm512_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_moveldup_ps.html" title="fn core::arch::x86_64::_mm512_maskz_moveldup_ps">_mm512_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_mul_epi32">_mm512_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_epu32.html" title="fn core::arch::x86_64::_mm512_maskz_mul_epu32">_mm512_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_pd.html" title="fn core::arch::x86_64::_mm512_maskz_mul_pd">_mm512_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_ps.html" title="fn core::arch::x86_64::_mm512_maskz_mul_ps">_mm512_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_mul_round_pd">_mm512_maskz_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mul_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_mul_round_ps">_mm512_maskz_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mulhi_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_mulhi_epi16">_mm512_maskz_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mulhi_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_mulhi_epu16">_mm512_maskz_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_mulhrs_epi16">_mm512_maskz_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mullo_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_mullo_epi16">_mm512_maskz_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_mullo_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_mullo_epi32">_mm512_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_multishift_epi64_epi8">_mm512_maskz_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_or_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_or_epi32">_mm512_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_or_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_or_epi64">_mm512_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_packs_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_packs_epi16">_mm512_maskz_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_packs_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_packs_epi32">_mm512_maskz_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_packus_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_packus_epi16">_mm512_maskz_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_packus_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_packus_epi32">_mm512_maskz_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permute_pd.html" title="fn core::arch::x86_64::_mm512_maskz_permute_pd">_mm512_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permute_ps.html" title="fn core::arch::x86_64::_mm512_maskz_permute_ps">_mm512_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutevar_pd.html" title="fn core::arch::x86_64::_mm512_maskz_permutevar_pd">_mm512_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutevar_ps.html" title="fn core::arch::x86_64::_mm512_maskz_permutevar_ps">_mm512_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_epi8">_mm512_maskz_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_epi16">_mm512_maskz_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_epi32">_mm512_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_epi64">_mm512_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_pd.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_pd">_mm512_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引将 a 和 b 中的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex2var_ps.html" title="fn core::arch::x86_64::_mm512_maskz_permutex2var_ps">_mm512_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_permutex_epi64">_mm512_maskz_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutex_pd.html" title="fn core::arch::x86_64::_mm512_maskz_permutex_pd">_mm512_maskz_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_epi8">_mm512_maskz_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_epi16">_mm512_maskz_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_epi32">_mm512_maskz_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_epi64">_mm512_maskz_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_pd.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_pd">_mm512_maskz_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_permutexvar_ps.html" title="fn core::arch::x86_64::_mm512_maskz_permutexvar_ps">_mm512_maskz_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_popcnt_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_popcnt_epi8">_mm512_maskz_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_popcnt_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_popcnt_epi16">_mm512_maskz_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_popcnt_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_popcnt_epi32">_mm512_maskz_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_popcnt_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_popcnt_epi64">_mm512_maskz_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rcp14_pd.html" title="fn core::arch::x86_64::_mm512_maskz_rcp14_pd">_mm512_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rcp14_ps.html" title="fn core::arch::x86_64::_mm512_maskz_rcp14_ps">_mm512_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rol_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_rol_epi32">_mm512_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rol_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_rol_epi64">_mm512_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rolv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_rolv_epi32">_mm512_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rolv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_rolv_epi64">_mm512_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ror_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_ror_epi32">_mm512_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ror_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_ror_epi64">_mm512_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rorv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_rorv_epi32">_mm512_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rorv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_rorv_epi64">_mm512_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_pd.html" title="fn core::arch::x86_64::_mm512_maskz_roundscale_pd">_mm512_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_ps.html" title="fn core::arch::x86_64::_mm512_maskz_roundscale_ps">_mm512_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_roundscale_round_pd">_mm512_maskz_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_roundscale_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_roundscale_round_ps">_mm512_maskz_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm512_maskz_rsqrt14_pd">_mm512_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm512_maskz_rsqrt14_ps">_mm512_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_pd.html" title="fn core::arch::x86_64::_mm512_maskz_scalef_pd">_mm512_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_ps.html" title="fn core::arch::x86_64::_mm512_maskz_scalef_ps">_mm512_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_scalef_round_pd">_mm512_maskz_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_scalef_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_scalef_round_ps">_mm512_maskz_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_set1_epi8">_mm512_maskz_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_set1_epi16">_mm512_maskz_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_set1_epi32">_mm512_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_set1_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_set1_epi64">_mm512_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldi_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shldi_epi16">_mm512_maskz_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldi_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_shldi_epi32">_mm512_maskz_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldi_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_shldi_epi64">_mm512_maskz_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldv_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shldv_epi16">_mm512_maskz_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_shldv_epi32">_mm512_maskz_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shldv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_shldv_epi64">_mm512_maskz_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdi_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shrdi_epi16">_mm512_maskz_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdi_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_shrdi_epi32">_mm512_maskz_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdi_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_shrdi_epi64">_mm512_maskz_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdv_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shrdv_epi16">_mm512_maskz_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_shrdv_epi32">_mm512_maskz_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shrdv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_shrdv_epi64">_mm512_maskz_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_epi8">_mm512_maskz_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_epi32">_mm512_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_f32x4">_mm512_maskz_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_f64x2">_mm512_maskz_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_i32x4">_mm512_maskz_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_i64x2">_mm512_maskz_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_pd.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_pd">_mm512_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shuffle_ps.html" title="fn core::arch::x86_64::_mm512_maskz_shuffle_ps">_mm512_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shufflehi_epi16">_mm512_maskz_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 zeromask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，元素被清零) .</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_shufflelo_epi16">_mm512_maskz_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 zeromask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，元素被清零) .</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sll_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_sll_epi16">_mm512_maskz_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sll_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_sll_epi32">_mm512_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sll_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_sll_epi64">_mm512_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_slli_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_slli_epi16">_mm512_maskz_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_slli_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_slli_epi32">_mm512_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_slli_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_slli_epi64">_mm512_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sllv_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_sllv_epi16">_mm512_maskz_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sllv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_sllv_epi32">_mm512_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sllv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_sllv_epi64">_mm512_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_pd.html" title="fn core::arch::x86_64::_mm512_maskz_sqrt_pd">_mm512_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_ps.html" title="fn core::arch::x86_64::_mm512_maskz_sqrt_ps">_mm512_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_sqrt_round_pd">_mm512_maskz_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sqrt_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_sqrt_round_ps">_mm512_maskz_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sra_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_sra_epi16">_mm512_maskz_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sra_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_sra_epi32">_mm512_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sra_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_sra_epi64">_mm512_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srai_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_srai_epi16">_mm512_maskz_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srai_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_srai_epi32">_mm512_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srai_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_srai_epi64">_mm512_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srav_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_srav_epi16">_mm512_maskz_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srav_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_srav_epi32">_mm512_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srav_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_srav_epi64">_mm512_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srl_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_srl_epi16">_mm512_maskz_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srl_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_srl_epi32">_mm512_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srl_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_srl_epi64">_mm512_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srli_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_srli_epi16">_mm512_maskz_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srli_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_srli_epi32">_mm512_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srli_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_srli_epi64">_mm512_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srlv_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_srlv_epi16">_mm512_maskz_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srlv_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_srlv_epi32">_mm512_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_srlv_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_srlv_epi64">_mm512_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_sub_epi8">_mm512_maskz_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_sub_epi16">_mm512_maskz_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_sub_epi32">_mm512_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_sub_epi64">_mm512_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_pd.html" title="fn core::arch::x86_64::_mm512_maskz_sub_pd">_mm512_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_ps.html" title="fn core::arch::x86_64::_mm512_maskz_sub_ps">_mm512_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_round_pd.html" title="fn core::arch::x86_64::_mm512_maskz_sub_round_pd">_mm512_maskz_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_sub_round_ps.html" title="fn core::arch::x86_64::_mm512_maskz_sub_round_ps">_mm512_maskz_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_subs_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_subs_epi8">_mm512_maskz_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_subs_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_subs_epi16">_mm512_maskz_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_subs_epu8.html" title="fn core::arch::x86_64::_mm512_maskz_subs_epu8">_mm512_maskz_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_subs_epu16.html" title="fn core::arch::x86_64::_mm512_maskz_subs_epu16">_mm512_maskz_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_ternarylogic_epi32">_mm512_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 32 位粒度的 zeromask k (当未设置相应的掩码位时，32 位元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_ternarylogic_epi64">_mm512_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 64 位粒度的 zeromask k (当未设置相应的掩码位时，64 位元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_epi8">_mm512_maskz_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_epi16">_mm512_maskz_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_epi32">_mm512_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_epi64">_mm512_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_pd.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_pd">_mm512_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpackhi_ps.html" title="fn core::arch::x86_64::_mm512_maskz_unpackhi_ps">_mm512_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_epi8">_mm512_maskz_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_epi16">_mm512_maskz_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_epi32">_mm512_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_epi64">_mm512_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_pd.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_pd">_mm512_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_unpacklo_ps.html" title="fn core::arch::x86_64::_mm512_maskz_unpacklo_ps">_mm512_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_xor_epi32.html" title="fn core::arch::x86_64::_mm512_maskz_xor_epi32">_mm512_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_maskz_xor_epi64.html" title="fn core::arch::x86_64::_mm512_maskz_xor_epi64">_mm512_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi8.html" title="fn core::arch::x86_64::_mm512_max_epi8">_mm512_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi16.html" title="fn core::arch::x86_64::_mm512_max_epi16">_mm512_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi32.html" title="fn core::arch::x86_64::_mm512_max_epi32">_mm512_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 32 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epi64.html" title="fn core::arch::x86_64::_mm512_max_epi64">_mm512_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu8.html" title="fn core::arch::x86_64::_mm512_max_epu8">_mm512_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu16.html" title="fn core::arch::x86_64::_mm512_max_epu16">_mm512_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu32.html" title="fn core::arch::x86_64::_mm512_max_epu32">_mm512_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_epu64.html" title="fn core::arch::x86_64::_mm512_max_epu64">_mm512_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_pd.html" title="fn core::arch::x86_64::_mm512_max_pd">_mm512_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_ps.html" title="fn core::arch::x86_64::_mm512_max_ps">_mm512_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_round_pd.html" title="fn core::arch::x86_64::_mm512_max_round_pd">_mm512_max_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_max_round_ps.html" title="fn core::arch::x86_64::_mm512_max_round_ps">_mm512_max_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi8.html" title="fn core::arch::x86_64::_mm512_min_epi8">_mm512_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi16.html" title="fn core::arch::x86_64::_mm512_min_epi16">_mm512_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi32.html" title="fn core::arch::x86_64::_mm512_min_epi32">_mm512_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 32 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epi64.html" title="fn core::arch::x86_64::_mm512_min_epi64">_mm512_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu8.html" title="fn core::arch::x86_64::_mm512_min_epu8">_mm512_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu16.html" title="fn core::arch::x86_64::_mm512_min_epu16">_mm512_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu32.html" title="fn core::arch::x86_64::_mm512_min_epu32">_mm512_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_epu64.html" title="fn core::arch::x86_64::_mm512_min_epu64">_mm512_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_pd.html" title="fn core::arch::x86_64::_mm512_min_pd">_mm512_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。
比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_ps.html" title="fn core::arch::x86_64::_mm512_min_ps">_mm512_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_round_pd.html" title="fn core::arch::x86_64::_mm512_min_round_pd">_mm512_min_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_min_round_ps.html" title="fn core::arch::x86_64::_mm512_min_round_ps">_mm512_min_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movedup_pd.html" title="fn core::arch::x86_64::_mm512_movedup_pd">_mm512_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movehdup_ps.html" title="fn core::arch::x86_64::_mm512_movehdup_ps">_mm512_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_moveldup_ps.html" title="fn core::arch::x86_64::_mm512_moveldup_ps">_mm512_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movepi8_mask.html" title="fn core::arch::x86_64::_mm512_movepi8_mask">_mm512_movepi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据相应封装的 8 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movepi16_mask.html" title="fn core::arch::x86_64::_mm512_movepi16_mask">_mm512_movepi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据相应封装的 16 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movm_epi8.html" title="fn core::arch::x86_64::_mm512_movm_epi8">_mm512_movm_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 8 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_movm_epi16.html" title="fn core::arch::x86_64::_mm512_movm_epi16">_mm512_movm_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 16 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_epi32.html" title="fn core::arch::x86_64::_mm512_mul_epi32">_mm512_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并将带符号的 64 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_epu32.html" title="fn core::arch::x86_64::_mm512_mul_epu32">_mm512_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并将无符号 64 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_pd.html" title="fn core::arch::x86_64::_mm512_mul_pd">_mm512_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_ps.html" title="fn core::arch::x86_64::_mm512_mul_ps">_mm512_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_round_pd.html" title="fn core::arch::x86_64::_mm512_mul_round_pd">_mm512_mul_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mul_round_ps.html" title="fn core::arch::x86_64::_mm512_mul_round_ps">_mm512_mul_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mulhi_epi16.html" title="fn core::arch::x86_64::_mm512_mulhi_epi16">_mm512_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的带符号的 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mulhi_epu16.html" title="fn core::arch::x86_64::_mm512_mulhi_epu16">_mm512_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的无符号 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm512_mulhrs_epi16">_mm512_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，加 1 舍入，然后将 [16: 1] 位存储到 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mullo_epi16.html" title="fn core::arch::x86_64::_mm512_mullo_epi16">_mm512_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并将中间整数的低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mullo_epi32.html" title="fn core::arch::x86_64::_mm512_mullo_epi32">_mm512_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并将中间整数的低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_mullox_epi64.html" title="fn core::arch::x86_64::_mm512_mullox_epi64">_mm512_mullox_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数 vectors a 和 b 中的元素相乘，将结果的低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm512_multishift_epi64_epi8">_mm512_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_epi32.html" title="fn core::arch::x86_64::_mm512_or_epi32">_mm512_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_epi64.html" title="fn core::arch::x86_64::_mm512_or_epi64">_mm512_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_or_si512.html" title="fn core::arch::x86_64::_mm512_or_si512">_mm512_or_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 512 位 (代表整数数据) 的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_packs_epi16.html" title="fn core::arch::x86_64::_mm512_packs_epi16">_mm512_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_packs_epi32.html" title="fn core::arch::x86_64::_mm512_packs_epi32">_mm512_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_packus_epi16.html" title="fn core::arch::x86_64::_mm512_packus_epi16">_mm512_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_packus_epi32.html" title="fn core::arch::x86_64::_mm512_packus_epi32">_mm512_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permute_pd.html" title="fn core::arch::x86_64::_mm512_permute_pd">_mm512_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permute_ps.html" title="fn core::arch::x86_64::_mm512_permute_ps">_mm512_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_epi32.html" title="fn core::arch::x86_64::_mm512_permutevar_epi32">_mm512_permutevar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 32 位整数，并将结果存储在 dst 中。请注意，与过去使用 permutevar 名称的内部函数不同，该内部函数在 128 位 lane 上进行了重排。此内部函数与 _mm512_permutexvar_epi32 相同，建议您使用该内部函数名称。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_pd.html" title="fn core::arch::x86_64::_mm512_permutevar_pd">_mm512_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutevar_ps.html" title="fn core::arch::x86_64::_mm512_permutevar_ps">_mm512_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm512_permutex2var_epi8">_mm512_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm512_permutex2var_epi16">_mm512_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm512_permutex2var_epi32">_mm512_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm512_permutex2var_epi64">_mm512_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_pd.html" title="fn core::arch::x86_64::_mm512_permutex2var_pd">_mm512_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex2var_ps.html" title="fn core::arch::x86_64::_mm512_permutex2var_ps">_mm512_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex_epi64.html" title="fn core::arch::x86_64::_mm512_permutex_epi64">_mm512_permutex_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutex_pd.html" title="fn core::arch::x86_64::_mm512_permutex_pd">_mm512_permutex_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 256 位 lanes 内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm512_permutexvar_epi8">_mm512_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi` only">(x86 or x86-64) and <code>avx512vbmi</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引将 a 中的 8 位整数打乱到 lanes 中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm512_permutexvar_epi16">_mm512_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi32.html" title="fn core::arch::x86_64::_mm512_permutexvar_epi32">_mm512_permutexvar_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_epi64.html" title="fn core::arch::x86_64::_mm512_permutexvar_epi64">_mm512_permutexvar_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_pd.html" title="fn core::arch::x86_64::_mm512_permutexvar_pd">_mm512_permutexvar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_permutexvar_ps.html" title="fn core::arch::x86_64::_mm512_permutexvar_ps">_mm512_permutexvar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引对跨 lanes 中的单精度 (32-bit) 浮点元素进行打乱。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_popcnt_epi8.html" title="fn core::arch::x86_64::_mm512_popcnt_epi8">_mm512_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_popcnt_epi16.html" title="fn core::arch::x86_64::_mm512_popcnt_epi16">_mm512_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg` only">(x86 or x86-64) and <code>avx512bitalg</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_popcnt_epi32.html" title="fn core::arch::x86_64::_mm512_popcnt_epi32">_mm512_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_popcnt_epi64.html" title="fn core::arch::x86_64::_mm512_popcnt_epi64">_mm512_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq` only">(x86 or x86-64) and <code>avx512vpopcntdq</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rcp14_pd.html" title="fn core::arch::x86_64::_mm512_rcp14_pd">_mm512_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rcp14_ps.html" title="fn core::arch::x86_64::_mm512_rcp14_ps">_mm512_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_add_epi32">_mm512_reduce_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过加法减少包装的 32 位整数。返回所有元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_add_epi64">_mm512_reduce_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过加法减少包装的 64 位整数。返回所有元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_pd.html" title="fn core::arch::x86_64::_mm512_reduce_add_pd">_mm512_reduce_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">另外，还减少了包装的双精度 (64-bit) 浮点元素。返回所有元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_add_ps.html" title="fn core::arch::x86_64::_mm512_reduce_add_ps">_mm512_reduce_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">此外，还减少了包装的单精度 (32-bit) 浮点元素。返回所有元素的总和 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_and_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_and_epi32">_mm512_reduce_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过按位 AND 减少包装的 32 位整数。返回中所有元素的按位与 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_and_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_and_epi64">_mm512_reduce_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过按位 AND 减少包装的 64 位整数。返回中所有元素的按位与 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_max_epi32">_mm512_reduce_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最多减少包装的带符号 32 位整数。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_max_epi64">_mm512_reduce_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最大减少包装的带符号的 64 位整数。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epu32.html" title="fn core::arch::x86_64::_mm512_reduce_max_epu32">_mm512_reduce_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最多减少包装的无符号 32 位整数。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_epu64.html" title="fn core::arch::x86_64::_mm512_reduce_max_epu64">_mm512_reduce_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最多减少包装的无符号 64 位整数。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_pd.html" title="fn core::arch::x86_64::_mm512_reduce_max_pd">_mm512_reduce_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最大减少包装的双精度 (64-bit) 浮点元素。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_max_ps.html" title="fn core::arch::x86_64::_mm512_reduce_max_ps">_mm512_reduce_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">最大减少包装的单精度 (32-bit) 浮点元素。返回中所有元素的最大值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_min_epi32">_mm512_reduce_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的有符号的 32 位整数减少到最小值。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_min_epi64">_mm512_reduce_min_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将一个包装的有符号 64 位整数减少到最小值。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epu32.html" title="fn core::arch::x86_64::_mm512_reduce_min_epu32">_mm512_reduce_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将一个包装的无符号 32 位整数减少到最小值。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_epu64.html" title="fn core::arch::x86_64::_mm512_reduce_min_epu64">_mm512_reduce_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将一个包装的无符号 64 位整数减少到最小。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_pd.html" title="fn core::arch::x86_64::_mm512_reduce_min_pd">_mm512_reduce_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将一个包装的双精度 (64 位) 浮点元素减少到最小。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_min_ps.html" title="fn core::arch::x86_64::_mm512_reduce_min_ps">_mm512_reduce_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将一个包装的单精度 (32 位) 浮点元素减少到最小。返回所有元素中的最小值 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_mul_epi32">_mm512_reduce_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过乘法减少包装的 32 位整数。返回所有元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_mul_epi64">_mm512_reduce_mul_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过乘法减少包装的 64 位整数。返回所有元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_pd.html" title="fn core::arch::x86_64::_mm512_reduce_mul_pd">_mm512_reduce_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过乘法减少包装的双精度 (64-bit) 浮点元素。返回所有元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_mul_ps.html" title="fn core::arch::x86_64::_mm512_reduce_mul_ps">_mm512_reduce_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过乘法减少包装的单精度 (32-bit) 浮点元素。返回所有元素的乘积 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_or_epi32.html" title="fn core::arch::x86_64::_mm512_reduce_or_epi32">_mm512_reduce_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过按位 OR 减少包装的 32 位整数。返回中所有元素的按位或 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_reduce_or_epi64.html" title="fn core::arch::x86_64::_mm512_reduce_or_epi64">_mm512_reduce_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">通过按位 OR 减少包装的 64 位整数。返回中所有元素的按位或 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rol_epi32.html" title="fn core::arch::x86_64::_mm512_rol_epi32">_mm512_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rol_epi64.html" title="fn core::arch::x86_64::_mm512_rol_epi64">_mm512_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rolv_epi32.html" title="fn core::arch::x86_64::_mm512_rolv_epi32">_mm512_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rolv_epi64.html" title="fn core::arch::x86_64::_mm512_rolv_epi64">_mm512_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ror_epi32.html" title="fn core::arch::x86_64::_mm512_ror_epi32">_mm512_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ror_epi64.html" title="fn core::arch::x86_64::_mm512_ror_epi64">_mm512_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rorv_epi32.html" title="fn core::arch::x86_64::_mm512_rorv_epi32">_mm512_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rorv_epi64.html" title="fn core::arch::x86_64::_mm512_rorv_epi64">_mm512_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_pd.html" title="fn core::arch::x86_64::_mm512_roundscale_pd">_mm512_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_ps.html" title="fn core::arch::x86_64::_mm512_roundscale_ps">_mm512_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_round_pd.html" title="fn core::arch::x86_64::_mm512_roundscale_round_pd">_mm512_roundscale_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_roundscale_round_ps.html" title="fn core::arch::x86_64::_mm512_roundscale_round_ps">_mm512_roundscale_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm512_rsqrt14_pd">_mm512_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm512_rsqrt14_ps">_mm512_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sad_epu8.html" title="fn core::arch::x86_64::_mm512_sad_epu8">_mm512_sad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平地求和以生成八个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位元素的低 16 位中在 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_pd.html" title="fn core::arch::x86_64::_mm512_scalef_pd">_mm512_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_ps.html" title="fn core::arch::x86_64::_mm512_scalef_ps">_mm512_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_round_pd.html" title="fn core::arch::x86_64::_mm512_scalef_round_pd">_mm512_scalef_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_scalef_round_ps.html" title="fn core::arch::x86_64::_mm512_scalef_round_ps">_mm512_scalef_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi8.html" title="fn core::arch::x86_64::_mm512_set1_epi8">_mm512_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向 dst 的所有元素广播 8 位整数 a。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi16.html" title="fn core::arch::x86_64::_mm512_set1_epi16">_mm512_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将低包装的 16 位整数从 a 广播到 dst 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi32.html" title="fn core::arch::x86_64::_mm512_set1_epi32">_mm512_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向 <code>dst</code> 的所有元素广播 32 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_epi64.html" title="fn core::arch::x86_64::_mm512_set1_epi64">_mm512_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向 <code>dst</code> 的所有元素广播 64 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_pd.html" title="fn core::arch::x86_64::_mm512_set1_pd">_mm512_set1_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向 <code>dst</code> 的所有元素广播 64 位浮点数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set1_ps.html" title="fn core::arch::x86_64::_mm512_set1_ps">_mm512_set1_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向 <code>dst</code> 的所有元素广播 32 位浮点数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_epi32.html" title="fn core::arch::x86_64::_mm512_set4_epi32">_mm512_set4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用重复的 4 个元素序列在 dst 中设置包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_epi64.html" title="fn core::arch::x86_64::_mm512_set4_epi64">_mm512_set4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用重复的 4 个元素序列在 dst 中设置包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_pd.html" title="fn core::arch::x86_64::_mm512_set4_pd">_mm512_set4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用重复的 4 个元素序列在 dst 中设置包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set4_ps.html" title="fn core::arch::x86_64::_mm512_set4_ps">_mm512_set4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用重复的 4 个元素序列在 dst 中设置包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi8.html" title="fn core::arch::x86_64::_mm512_set_epi8">_mm512_set_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 dst 中设置包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi16.html" title="fn core::arch::x86_64::_mm512_set_epi16">_mm512_set_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 dst 中设置包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi32.html" title="fn core::arch::x86_64::_mm512_set_epi32">_mm512_set_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 <code>dst</code> 中设置包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_epi64.html" title="fn core::arch::x86_64::_mm512_set_epi64">_mm512_set_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 dst 中设置包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_pd.html" title="fn core::arch::x86_64::_mm512_set_pd">_mm512_set_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 dst 中设置包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_set_ps.html" title="fn core::arch::x86_64::_mm512_set_ps">_mm512_set_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用提供的值在 <code>dst</code> 中设置包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_epi32.html" title="fn core::arch::x86_64::_mm512_setr4_epi32">_mm512_setr4_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的 32 位整数，并以相反的顺序重复 4 个元素序列。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_epi64.html" title="fn core::arch::x86_64::_mm512_setr4_epi64">_mm512_setr4_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的 64 位整数，并以相反的顺序重复 4 个元素序列。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_pd.html" title="fn core::arch::x86_64::_mm512_setr4_pd">_mm512_setr4_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序重复 4 个元素序列。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr4_ps.html" title="fn core::arch::x86_64::_mm512_setr4_ps">_mm512_setr4_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的单精度 (32-bit) 浮点元素，并以相反的顺序重复 4 个元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_epi32.html" title="fn core::arch::x86_64::_mm512_setr_epi32">_mm512_setr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 <code>dst</code> 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_epi64.html" title="fn core::arch::x86_64::_mm512_setr_epi64">_mm512_setr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的 64 位整数，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_pd.html" title="fn core::arch::x86_64::_mm512_setr_pd">_mm512_setr_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setr_ps.html" title="fn core::arch::x86_64::_mm512_setr_ps">_mm512_setr_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 <code>dst</code> 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero.html" title="fn core::arch::x86_64::_mm512_setzero">_mm512_setzero</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回 __m512 类型的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_epi32.html" title="fn core::arch::x86_64::_mm512_setzero_epi32">_mm512_setzero_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回类型为 __m512i 的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_pd.html" title="fn core::arch::x86_64::_mm512_setzero_pd">_mm512_setzero_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回 <code>__m512d</code> 类型的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_ps.html" title="fn core::arch::x86_64::_mm512_setzero_ps">_mm512_setzero_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回 <code>__m512d</code> 类型的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_setzero_si512.html" title="fn core::arch::x86_64::_mm512_setzero_si512">_mm512_setzero_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回 <code>__m512i</code> 类型的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldi_epi16.html" title="fn core::arch::x86_64::_mm512_shldi_epi16">_mm512_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldi_epi32.html" title="fn core::arch::x86_64::_mm512_shldi_epi32">_mm512_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldi_epi64.html" title="fn core::arch::x86_64::_mm512_shldi_epi64">_mm512_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldv_epi16.html" title="fn core::arch::x86_64::_mm512_shldv_epi16">_mm512_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldv_epi32.html" title="fn core::arch::x86_64::_mm512_shldv_epi32">_mm512_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shldv_epi64.html" title="fn core::arch::x86_64::_mm512_shldv_epi64">_mm512_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdi_epi16.html" title="fn core::arch::x86_64::_mm512_shrdi_epi16">_mm512_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdi_epi32.html" title="fn core::arch::x86_64::_mm512_shrdi_epi32">_mm512_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdi_epi64.html" title="fn core::arch::x86_64::_mm512_shrdi_epi64">_mm512_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdv_epi16.html" title="fn core::arch::x86_64::_mm512_shrdv_epi16">_mm512_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdv_epi32.html" title="fn core::arch::x86_64::_mm512_shrdv_epi32">_mm512_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shrdv_epi64.html" title="fn core::arch::x86_64::_mm512_shrdv_epi64">_mm512_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2` only">(x86 or x86-64) and <code>avx512vbmi2</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_epi8.html" title="fn core::arch::x86_64::_mm512_shuffle_epi8">_mm512_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">根据 b 的对应 8 位元素中的打乱控制掩码，将 a 中的包装 8 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_epi32.html" title="fn core::arch::x86_64::_mm512_shuffle_epi32">_mm512_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_f32x4.html" title="fn core::arch::x86_64::_mm512_shuffle_f32x4">_mm512_shuffle_f32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_f64x2.html" title="fn core::arch::x86_64::_mm512_shuffle_f64x2">_mm512_shuffle_f64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_i32x4.html" title="fn core::arch::x86_64::_mm512_shuffle_i32x4">_mm512_shuffle_i32x4</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_i64x2.html" title="fn core::arch::x86_64::_mm512_shuffle_i64x2">_mm512_shuffle_i64x2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_pd.html" title="fn core::arch::x86_64::_mm512_shuffle_pd">_mm512_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 中的双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shuffle_ps.html" title="fn core::arch::x86_64::_mm512_shuffle_ps">_mm512_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm512_shufflehi_epi16">_mm512_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，将 128 位 lanes 的低 64 位从 a 复制到 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm512_shufflelo_epi16">_mm512_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，将 128 位 lanes 的高 64 位从 a 复制到 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sll_epi16.html" title="fn core::arch::x86_64::_mm512_sll_epi16">_mm512_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sll_epi32.html" title="fn core::arch::x86_64::_mm512_sll_epi32">_mm512_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sll_epi64.html" title="fn core::arch::x86_64::_mm512_sll_epi64">_mm512_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 64 位整数左移计数，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_slli_epi16.html" title="fn core::arch::x86_64::_mm512_slli_epi16">_mm512_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_slli_epi32.html" title="fn core::arch::x86_64::_mm512_slli_epi32">_mm512_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_slli_epi64.html" title="fn core::arch::x86_64::_mm512_slli_epi64">_mm512_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sllv_epi16.html" title="fn core::arch::x86_64::_mm512_sllv_epi16">_mm512_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sllv_epi32.html" title="fn core::arch::x86_64::_mm512_sllv_epi32">_mm512_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 32 位整数向左移动 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sllv_epi64.html" title="fn core::arch::x86_64::_mm512_sllv_epi64">_mm512_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将填充的 64 位整数向左移动由 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_pd.html" title="fn core::arch::x86_64::_mm512_sqrt_pd">_mm512_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_ps.html" title="fn core::arch::x86_64::_mm512_sqrt_ps">_mm512_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_round_pd.html" title="fn core::arch::x86_64::_mm512_sqrt_round_pd">_mm512_sqrt_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sqrt_round_ps.html" title="fn core::arch::x86_64::_mm512_sqrt_round_ps">_mm512_sqrt_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sra_epi16.html" title="fn core::arch::x86_64::_mm512_sra_epi16">_mm512_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sra_epi32.html" title="fn core::arch::x86_64::_mm512_sra_epi32">_mm512_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移入符号位的同时按计数右移包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sra_epi64.html" title="fn core::arch::x86_64::_mm512_sra_epi64">_mm512_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srai_epi16.html" title="fn core::arch::x86_64::_mm512_srai_epi16">_mm512_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srai_epi32.html" title="fn core::arch::x86_64::_mm512_srai_epi32">_mm512_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srai_epi64.html" title="fn core::arch::x86_64::_mm512_srai_epi64">_mm512_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srav_epi16.html" title="fn core::arch::x86_64::_mm512_srav_epi16">_mm512_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srav_epi32.html" title="fn core::arch::x86_64::_mm512_srav_epi32">_mm512_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数右移由 count 中相应元素指定的数量，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srav_epi64.html" title="fn core::arch::x86_64::_mm512_srav_epi64">_mm512_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srl_epi16.html" title="fn core::arch::x86_64::_mm512_srl_epi16">_mm512_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srl_epi32.html" title="fn core::arch::x86_64::_mm512_srl_epi32">_mm512_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将计数包装的 32 位整数右移，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srl_epi64.html" title="fn core::arch::x86_64::_mm512_srl_epi64">_mm512_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">按计数右移包装的 64 位整数，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srli_epi16.html" title="fn core::arch::x86_64::_mm512_srli_epi16">_mm512_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srli_epi32.html" title="fn core::arch::x86_64::_mm512_srli_epi32">_mm512_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srli_epi64.html" title="fn core::arch::x86_64::_mm512_srli_epi64">_mm512_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srlv_epi16.html" title="fn core::arch::x86_64::_mm512_srlv_epi16">_mm512_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srlv_epi32.html" title="fn core::arch::x86_64::_mm512_srlv_epi32">_mm512_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移动已包装的 32 位整数，偏移量为计数中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_srlv_epi64.html" title="fn core::arch::x86_64::_mm512_srlv_epi64">_mm512_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数 (由 count 中相应元素指定的数量)，同时向零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_epi32.html" title="fn core::arch::x86_64::_mm512_store_epi32">_mm512_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_epi64.html" title="fn core::arch::x86_64::_mm512_store_epi64">_mm512_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_pd.html" title="fn core::arch::x86_64::_mm512_store_pd">_mm512_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_ps.html" title="fn core::arch::x86_64::_mm512_store_ps">_mm512_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_store_si512.html" title="fn core::arch::x86_64::_mm512_store_si512">_mm512_store_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi8.html" title="fn core::arch::x86_64::_mm512_storeu_epi8">_mm512_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 64 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi16.html" title="fn core::arch::x86_64::_mm512_storeu_epi16">_mm512_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 32 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi32.html" title="fn core::arch::x86_64::_mm512_storeu_epi32">_mm512_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_epi64.html" title="fn core::arch::x86_64::_mm512_storeu_epi64">_mm512_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_pd.html" title="fn core::arch::x86_64::_mm512_storeu_pd">_mm512_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_si512.html" title="fn core::arch::x86_64::_mm512_storeu_si512">_mm512_storeu_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的 512 位整数数据存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_pd.html" title="fn core::arch::x86_64::_mm512_stream_pd">_mm512_stream_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用非临时内存提示将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_ps.html" title="fn core::arch::x86_64::_mm512_stream_ps">_mm512_stream_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用非临时内存提示将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_stream_si512.html" title="fn core::arch::x86_64::_mm512_stream_si512">_mm512_stream_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用非临时内存提示将 512 位整数数据从 a 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi8.html" title="fn core::arch::x86_64::_mm512_sub_epi8">_mm512_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi16.html" title="fn core::arch::x86_64::_mm512_sub_epi16">_mm512_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi32.html" title="fn core::arch::x86_64::_mm512_sub_epi32">_mm512_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_epi64.html" title="fn core::arch::x86_64::_mm512_sub_epi64">_mm512_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_pd.html" title="fn core::arch::x86_64::_mm512_sub_pd">_mm512_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_ps.html" title="fn core::arch::x86_64::_mm512_sub_ps">_mm512_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_round_pd.html" title="fn core::arch::x86_64::_mm512_sub_round_pd">_mm512_sub_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_sub_round_ps.html" title="fn core::arch::x86_64::_mm512_sub_round_ps">_mm512_sub_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_subs_epi8.html" title="fn core::arch::x86_64::_mm512_subs_epi8">_mm512_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度从包装的 8 位整数中减去 b 中的包装有符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_subs_epi16.html" title="fn core::arch::x86_64::_mm512_subs_epi16">_mm512_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度从 a 中的包装的 16 位整数减去 b 中的包装的有符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_subs_epu8.html" title="fn core::arch::x86_64::_mm512_subs_epu8">_mm512_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_subs_epu16.html" title="fn core::arch::x86_64::_mm512_subs_epu16">_mm512_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm512_ternarylogic_epi32">_mm512_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm512_ternarylogic_epi64">_mm512_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的对应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi8_mask.html" title="fn core::arch::x86_64::_mm512_test_epi8_mask">_mm512_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi16_mask.html" title="fn core::arch::x86_64::_mm512_test_epi16_mask">_mm512_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi32_mask.html" title="fn core::arch::x86_64::_mm512_test_epi32_mask">_mm512_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_test_epi64_mask.html" title="fn core::arch::x86_64::_mm512_test_epi64_mask">_mm512_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm512_testn_epi8_mask">_mm512_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm512_testn_epi16_mask">_mm512_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm512_testn_epi32_mask">_mm512_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm512_testn_epi64_mask">_mm512_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined.html" title="fn core::arch::x86_64::_mm512_undefined">_mm512_undefined</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m512 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_epi32.html" title="fn core::arch::x86_64::_mm512_undefined_epi32">_mm512_undefined_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m512i 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_pd.html" title="fn core::arch::x86_64::_mm512_undefined_pd">_mm512_undefined_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回具有不确定元素的 <code>__m512d</code> 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_undefined_ps.html" title="fn core::arch::x86_64::_mm512_undefined_ps">_mm512_undefined_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">返回具有不确定元素的 <code>__m512</code> 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm512_unpackhi_epi8">_mm512_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm512_unpackhi_epi16">_mm512_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm512_unpackhi_epi32">_mm512_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm512_unpackhi_epi64">_mm512_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_pd.html" title="fn core::arch::x86_64::_mm512_unpackhi_pd">_mm512_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpackhi_ps.html" title="fn core::arch::x86_64::_mm512_unpackhi_ps">_mm512_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm512_unpacklo_epi8">_mm512_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包并交织 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm512_unpacklo_epi16">_mm512_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包并交织 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm512_unpacklo_epi32">_mm512_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm512_unpacklo_epi64">_mm512_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_pd.html" title="fn core::arch::x86_64::_mm512_unpacklo_pd">_mm512_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_unpacklo_ps.html" title="fn core::arch::x86_64::_mm512_unpacklo_ps">_mm512_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解压包并交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_epi32.html" title="fn core::arch::x86_64::_mm512_xor_epi32">_mm512_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_epi64.html" title="fn core::arch::x86_64::_mm512_xor_epi64">_mm512_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_xor_si512.html" title="fn core::arch::x86_64::_mm512_xor_si512">_mm512_xor_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 a 和 b 中 512 位 (代表整数数据) 的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextpd128_pd512.html" title="fn core::arch::x86_64::_mm512_zextpd128_pd512">_mm512_zextpd128_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m128d 的 vector 强制转换为 __m512d 类型； 结果的高 384 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextpd256_pd512.html" title="fn core::arch::x86_64::_mm512_zextpd256_pd512">_mm512_zextpd256_pd512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m256d 的 vector 强制转换为 __m512d 类型； 结果的高 256 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextps128_ps512.html" title="fn core::arch::x86_64::_mm512_zextps128_ps512">_mm512_zextps128_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型 __m128 的 vector 转换为 __m512 类型； 结果的高 384 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextps256_ps512.html" title="fn core::arch::x86_64::_mm512_zextps256_ps512">_mm512_zextps256_ps512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m256 的 vector 强制转换为类型 __m512； 结果的高 256 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextsi128_si512.html" title="fn core::arch::x86_64::_mm512_zextsi128_si512">_mm512_zextsi128_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m128i 的 vector 强制转换为类型 __m512i； 结果的高 384 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_zextsi256_si512.html" title="fn core::arch::x86_64::_mm512_zextsi256_si512">_mm512_zextsi256_si512</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将类型为 __m256i 的 vector 强制转换为类型 __m512i； 结果的高 256 位被清零。此内部函数仅用于编译，不会生成任何指令，因此具有零延迟。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_round_sd.html" title="fn core::arch::x86_64::_mm_add_round_sd">_mm_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_round_ss.html" title="fn core::arch::x86_64::_mm_add_round_ss">_mm_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_alignr_epi32.html" title="fn core::arch::x86_64::_mm_alignr_epi32">_mm_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 16 字节 (4 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_alignr_epi64.html" title="fn core::arch::x86_64::_mm_alignr_epi64">_mm_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 16 字节 (2 个元素) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm_bitshuffle_epi64_mask">_mm_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastmb_epi64.html" title="fn core::arch::x86_64::_mm_broadcastmb_epi64">_mm_broadcastmb_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastmw_epi32.html" title="fn core::arch::x86_64::_mm_broadcastmw_epi32">_mm_broadcastmw_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmp_epi8_mask">_mm_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmp_epi16_mask">_mm_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmp_epi32_mask">_mm_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmp_epi64_mask">_mm_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的有符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmp_epu8_mask">_mm_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 8 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmp_epu16_mask">_mm_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 16 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmp_epu32_mask">_mm_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 32 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmp_epu64_mask">_mm_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的无符号 64 位整数，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm_cmp_pd_mask">_mm_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数，比较 a 和 b 中的双精度 (64-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm_cmp_ps_mask">_mm_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的单精度 (32-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_round_sd_mask.html" title="fn core::arch::x86_64::_mm_cmp_round_sd_mask">_mm_cmp_round_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中低位双精度 (64-bit) 浮点元素，结果存入 mask vector k.<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_round_ss_mask.html" title="fn core::arch::x86_64::_mm_cmp_round_ss_mask">_mm_cmp_round_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中低位单精度 (32-bit) 浮点元素，结果存入 mask vector k.<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_sd_mask.html" title="fn core::arch::x86_64::_mm_cmp_sd_mask">_mm_cmp_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中低位双精度 (64-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ss_mask.html" title="fn core::arch::x86_64::_mm_cmp_ss_mask">_mm_cmp_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中低位单精度 (32-bit) 浮点元素，结果存入 mask vector k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epi8_mask">_mm_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epi16_mask">_mm_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epi32_mask">_mm_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epi64_mask">_mm_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epu8_mask">_mm_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epu16_mask">_mm_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epu32_mask">_mm_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmpeq_epu64_mask">_mm_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epi8_mask">_mm_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epi16_mask">_mm_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epi32_mask">_mm_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epi64_mask">_mm_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epu8_mask">_mm_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epu16_mask">_mm_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epu32_mask">_mm_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmpge_epu64_mask">_mm_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epi8_mask">_mm_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epi16_mask">_mm_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epi32_mask">_mm_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epi64_mask">_mm_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epu8_mask">_mm_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epu16_mask">_mm_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epu32_mask">_mm_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmpgt_epu64_mask">_mm_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否大于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmple_epi8_mask">_mm_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmple_epi16_mask">_mm_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmple_epi32_mask">_mm_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmple_epi64_mask">_mm_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmple_epu8_mask">_mm_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmple_epu16_mask">_mm_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmple_epu32_mask">_mm_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmple_epu64_mask">_mm_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于或等于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epi8_mask">_mm_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epi16_mask">_mm_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epi32_mask">_mm_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epi64_mask">_mm_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epu8_mask">_mm_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epu16_mask">_mm_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epu32_mask">_mm_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmplt_epu64_mask">_mm_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否小于，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epi8_mask">_mm_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epi16_mask">_mm_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epi32_mask">_mm_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epi64_mask">_mm_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的有符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epu8_mask">_mm_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 8 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epu16_mask">_mm_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 16 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epu32_mask">_mm_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 32 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm_cmpneq_epu64_mask">_mm_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的无符号 64 位整数是否不相等，并将结果存储在掩码 vector 中 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comi_round_sd.html" title="fn core::arch::x86_64::_mm_comi_round_sd">_mm_comi_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并返回布尔结果 (0 或 1)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comi_round_ss.html" title="fn core::arch::x86_64::_mm_comi_round_ss">_mm_comi_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并返回布尔结果 (0 或 1)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_conflict_epi32.html" title="fn core::arch::x86_64::_mm_conflict_epi32">_mm_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_conflict_epi64.html" title="fn core::arch::x86_64::_mm_conflict_epi64">_mm_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundi32_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundi32_ss">_mm_cvt_roundi32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundi64_sd.html" title="fn core::arch::x86_64::_mm_cvt_roundi64_sd">_mm_cvt_roundi64_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高位元素复制到 dst 的高位元素。
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundi64_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundi64_ss">_mm_cvt_roundi64_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高 3 个包装元素从 a 复制到 dst 的高位元素。
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_i32.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_i32">_mm_cvt_roundsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_i64.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_i64">_mm_cvt_roundsd_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_si32.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_si32">_mm_cvt_roundsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_si64.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_si64">_mm_cvt_roundsd_si64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_ss">_mm_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_u32.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_u32">_mm_cvt_roundsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsd_u64.html" title="fn core::arch::x86_64::_mm_cvt_roundsd_u64">_mm_cvt_roundsd_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsi32_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundsi32_ss">_mm_cvt_roundsi32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsi64_sd.html" title="fn core::arch::x86_64::_mm_cvt_roundsi64_sd">_mm_cvt_roundsi64_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高位元素复制到 dst 的高位元素。
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundsi64_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundsi64_ss">_mm_cvt_roundsi64_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高 3 个包装元素从 a 复制到 dst 的高位元素。
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_i32.html" title="fn core::arch::x86_64::_mm_cvt_roundss_i32">_mm_cvt_roundss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_i64.html" title="fn core::arch::x86_64::_mm_cvt_roundss_i64">_mm_cvt_roundss_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_sd.html" title="fn core::arch::x86_64::_mm_cvt_roundss_sd">_mm_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将上部的元素从 a 复制到 dst 的上部元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_si32.html" title="fn core::arch::x86_64::_mm_cvt_roundss_si32">_mm_cvt_roundss_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_si64.html" title="fn core::arch::x86_64::_mm_cvt_roundss_si64">_mm_cvt_roundss_si64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_u32.html" title="fn core::arch::x86_64::_mm_cvt_roundss_u32">_mm_cvt_roundss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundss_u64.html" title="fn core::arch::x86_64::_mm_cvt_roundss_u64">_mm_cvt_roundss_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundu32_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundu32_ss">_mm_cvt_roundu32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundu64_sd.html" title="fn core::arch::x86_64::_mm_cvt_roundu64_sd">_mm_cvt_roundu64_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_roundu64_ss.html" title="fn core::arch::x86_64::_mm_cvt_roundu64_ss">_mm_cvt_roundu64_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm_cvtepi16_epi8">_mm_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm_cvtepi32_epi8">_mm_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm_cvtepi32_epi16">_mm_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm_cvtepi64_epi8">_mm_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm_cvtepi64_epi16">_mm_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm_cvtepi64_epi32">_mm_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm_cvtepu32_pd">_mm_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti32_sd.html" title="fn core::arch::x86_64::_mm_cvti32_sd">_mm_cvti32_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti32_ss.html" title="fn core::arch::x86_64::_mm_cvti32_ss">_mm_cvti32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti64_sd.html" title="fn core::arch::x86_64::_mm_cvti64_sd">_mm_cvti64_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高位元素复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvti64_ss.html" title="fn core::arch::x86_64::_mm_cvti64_ss">_mm_cvti64_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将有符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存入 dst 的低位元素，将 a 的高 3 个包装元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm_cvtne2ps_pbh">_mm_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将两个 128 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm_cvtpd_epu32">_mm_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtps_epu32.html" title="fn core::arch::x86_64::_mm_cvtps_epu32">_mm_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_i32.html" title="fn core::arch::x86_64::_mm_cvtsd_i32">_mm_cvtsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_i64.html" title="fn core::arch::x86_64::_mm_cvtsd_i64">_mm_cvtsd_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_u32.html" title="fn core::arch::x86_64::_mm_cvtsd_u32">_mm_cvtsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_u64.html" title="fn core::arch::x86_64::_mm_cvtsd_u64">_mm_cvtsd_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm_cvtsepi16_epi8">_mm_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm_cvtsepi32_epi8">_mm_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm_cvtsepi32_epi16">_mm_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm_cvtsepi64_epi8">_mm_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm_cvtsepi64_epi16">_mm_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm_cvtsepi64_epi32">_mm_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_i32.html" title="fn core::arch::x86_64::_mm_cvtss_i32">_mm_cvtss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_i64.html" title="fn core::arch::x86_64::_mm_cvtss_i64">_mm_cvtss_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_u32.html" title="fn core::arch::x86_64::_mm_cvtss_u32">_mm_cvtss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_u64.html" title="fn core::arch::x86_64::_mm_cvtss_u64">_mm_cvtss_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为无符号 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_i32.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_i32">_mm_cvtt_roundsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_i64.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_i64">_mm_cvtt_roundsd_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_si32.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_si32">_mm_cvtt_roundsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_si64.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_si64">_mm_cvtt_roundsd_si64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_u32.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_u32">_mm_cvtt_roundsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundsd_u64.html" title="fn core::arch::x86_64::_mm_cvtt_roundsd_u64">_mm_cvtt_roundsd_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_i32.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_i32">_mm_cvtt_roundss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_i64.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_i64">_mm_cvtt_roundss_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_si32.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_si32">_mm_cvtt_roundss_si32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_si64.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_si64">_mm_cvtt_roundss_si64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_u32.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_u32">_mm_cvtt_roundss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_roundss_u64.html" title="fn core::arch::x86_64::_mm_cvtt_roundss_u64">_mm_cvtt_roundss_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm_cvttpd_epu32">_mm_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttps_epu32.html" title="fn core::arch::x86_64::_mm_cvttps_epu32">_mm_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_i32.html" title="fn core::arch::x86_64::_mm_cvttsd_i32">_mm_cvttsd_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_i64.html" title="fn core::arch::x86_64::_mm_cvttsd_i64">_mm_cvttsd_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_u32.html" title="fn core::arch::x86_64::_mm_cvttsd_u32">_mm_cvttsd_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_u64.html" title="fn core::arch::x86_64::_mm_cvttsd_u64">_mm_cvttsd_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位双精度 (64-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_i32.html" title="fn core::arch::x86_64::_mm_cvttss_i32">_mm_cvttss_i32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_i64.html" title="fn core::arch::x86_64::_mm_cvttss_i64">_mm_cvttss_i64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为带有截断的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_u32.html" title="fn core::arch::x86_64::_mm_cvttss_u32">_mm_cvttss_u32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_u64.html" title="fn core::arch::x86_64::_mm_cvttss_u64">_mm_cvttss_u64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的低位单精度 (32-bit) 浮点元素转换为带截断的无符号 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu32_sd.html" title="fn core::arch::x86_64::_mm_cvtu32_sd">_mm_cvtu32_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的低位元素中，然后将 a 的高位元素复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu32_ss.html" title="fn core::arch::x86_64::_mm_cvtu32_ss">_mm_cvtu32_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu64_sd.html" title="fn core::arch::x86_64::_mm_cvtu64_sd">_mm_cvtu64_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 64 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtu64_ss.html" title="fn core::arch::x86_64::_mm_cvtu64_ss">_mm_cvtu64_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available with target feature `avx512f` only"><code>avx512f</code></span></div><div class="desc docblock-short">将无符号的 64 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm_cvtusepi16_epi8">_mm_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm_cvtusepi32_epi8">_mm_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm_cvtusepi32_epi16">_mm_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm_cvtusepi64_epi8">_mm_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm_cvtusepi64_epi16">_mm_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm_cvtusepi64_epi32">_mm_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dbsad_epu8.html" title="fn core::arch::x86_64::_mm_dbsad_epu8">_mm_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_round_sd.html" title="fn core::arch::x86_64::_mm_div_round_sd">_mm_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部双精度 (64-bit) 浮点元素除以 b 中的下部双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_round_ss.html" title="fn core::arch::x86_64::_mm_div_round_ss">_mm_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dpbf16_ps.html" title="fn core::arch::x86_64::_mm_dpbf16_ps">_mm_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm_dpbusd_epi32">_mm_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm_dpbusds_epi32">_mm_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm_dpwssd_epi32">_mm_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm_dpwssds_epi32">_mm_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_pd.html" title="fn core::arch::x86_64::_mm_fixupimm_pd">_mm_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_ps.html" title="fn core::arch::x86_64::_mm_fixupimm_ps">_mm_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_round_sd.html" title="fn core::arch::x86_64::_mm_fixupimm_round_sd">_mm_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_round_ss.html" title="fn core::arch::x86_64::_mm_fixupimm_round_ss">_mm_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_sd.html" title="fn core::arch::x86_64::_mm_fixupimm_sd">_mm_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fixupimm_ss.html" title="fn core::arch::x86_64::_mm_fixupimm_ss">_mm_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_round_sd.html" title="fn core::arch::x86_64::_mm_fmadd_round_sd">_mm_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_round_ss.html" title="fn core::arch::x86_64::_mm_fmadd_round_ss">_mm_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_round_sd.html" title="fn core::arch::x86_64::_mm_fmsub_round_sd">_mm_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存入 dst 的下层元素，将 a 的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_round_ss.html" title="fn core::arch::x86_64::_mm_fmsub_round_ss">_mm_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_round_sd.html" title="fn core::arch::x86_64::_mm_fnmadd_round_sd">_mm_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后将求和的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_round_ss.html" title="fn core::arch::x86_64::_mm_fnmadd_round_ss">_mm_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后将取反的中间结果与较低元素 in c. Store 相加，将结果与 dst 的较低元素相乘，然后将较高的 3 个包装的元素从 a 复制到 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_round_sd.html" title="fn core::arch::x86_64::_mm_fnmsub_round_sd">_mm_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。将结果存入 dst 的下层元素，将 a 的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_round_ss.html" title="fn core::arch::x86_64::_mm_fnmsub_round_ss">_mm_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的下部元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到上部 dst 的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_pd.html" title="fn core::arch::x86_64::_mm_getexp_pd">_mm_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_ps.html" title="fn core::arch::x86_64::_mm_getexp_ps">_mm_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_round_sd.html" title="fn core::arch::x86_64::_mm_getexp_round_sd">_mm_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_round_ss.html" title="fn core::arch::x86_64::_mm_getexp_round_ss">_mm_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_sd.html" title="fn core::arch::x86_64::_mm_getexp_sd">_mm_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getexp_ss.html" title="fn core::arch::x86_64::_mm_getexp_ss">_mm_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_pd.html" title="fn core::arch::x86_64::_mm_getmant_pd">_mm_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_ps.html" title="fn core::arch::x86_64::_mm_getmant_ps">_mm_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_round_sd.html" title="fn core::arch::x86_64::_mm_getmant_round_sd">_mm_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_round_ss.html" title="fn core::arch::x86_64::_mm_getmant_round_ss">_mm_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_sd.html" title="fn core::arch::x86_64::_mm_getmant_sd">_mm_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getmant_ss.html" title="fn core::arch::x86_64::_mm_getmant_ss">_mm_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm_gf2p8affine_epi64_epi8">_mm_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni` only">(x86 or x86-64) and <code>gfni</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm_gf2p8affineinv_epi64_epi8">_mm_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni` only">(x86 or x86-64) and <code>gfni</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm_gf2p8mul_epi8">_mm_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni` only">(x86 or x86-64) and <code>gfni</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_epi32.html" title="fn core::arch::x86_64::_mm_load_epi32">_mm_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_epi64.html" title="fn core::arch::x86_64::_mm_load_epi64">_mm_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi8.html" title="fn core::arch::x86_64::_mm_loadu_epi8">_mm_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 16 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi16.html" title="fn core::arch::x86_64::_mm_loadu_epi16">_mm_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 8 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi32.html" title="fn core::arch::x86_64::_mm_loadu_epi32">_mm_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_epi64.html" title="fn core::arch::x86_64::_mm_loadu_epi64">_mm_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm_lzcnt_epi32">_mm_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm_lzcnt_epi64">_mm_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_madd52hi_epu64.html" title="fn core::arch::x86_64::_mm_madd52hi_epu64">_mm_madd52hi_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_madd52lo_epu64.html" title="fn core::arch::x86_64::_mm_madd52lo_epu64">_mm_madd52lo_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512ifma,avx512vl` only">(x86 or x86-64) and <code>avx512ifma,avx512vl</code></span></div><div class="desc docblock-short">将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_epi8">_mm_mask2_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_epi16">_mm_mask2_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_epi32">_mm_mask2_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_epi64">_mm_mask2_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_pd.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_pd">_mm_mask2_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask2_permutex2var_ps.html" title="fn core::arch::x86_64::_mm_mask2_permutex2var_ps">_mm_mask2_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的对应选择器和索引在 a 和 b 中的 lanes 中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 idx 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_pd.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_pd">_mm_mask3_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_ps.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_ps">_mm_mask3_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_round_sd.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_round_sd">_mm_mask3_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_round_ss.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_round_ss">_mm_mask3_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_sd.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_sd">_mm_mask3_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmadd_ss.html" title="fn core::arch::x86_64::_mm_mask3_fmadd_ss">_mm_mask3_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm_mask3_fmaddsub_pd">_mm_mask3_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm_mask3_fmaddsub_ps">_mm_mask3_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_pd.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_pd">_mm_mask3_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_ps.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_ps">_mm_mask3_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_round_sd.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_round_sd">_mm_mask3_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_round_ss.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_round_ss">_mm_mask3_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_sd.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_sd">_mm_mask3_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsub_ss.html" title="fn core::arch::x86_64::_mm_mask3_fmsub_ss">_mm_mask3_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm_mask3_fmsubadd_pd">_mm_mask3_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm_mask3_fmsubadd_ps">_mm_mask3_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_pd.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_pd">_mm_mask3_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_ps.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_ps">_mm_mask3_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_round_sd.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_round_sd">_mm_mask3_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_round_ss.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_round_ss">_mm_mask3_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_sd.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_sd">_mm_mask3_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmadd_ss.html" title="fn core::arch::x86_64::_mm_mask3_fnmadd_ss">_mm_mask3_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_pd.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_pd">_mm_mask3_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_ps.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_ps">_mm_mask3_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 c 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_round_sd.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_round_sd">_mm_mask3_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_round_ss.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_round_ss">_mm_mask3_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_sd.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_sd">_mm_mask3_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask3_fnmsub_ss.html" title="fn core::arch::x86_64::_mm_mask3_fnmsub_ss">_mm_mask3_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_abs_epi8.html" title="fn core::arch::x86_64::_mm_mask_abs_epi8">_mm_mask_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_abs_epi16.html" title="fn core::arch::x86_64::_mm_mask_abs_epi16">_mm_mask_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_abs_epi32.html" title="fn core::arch::x86_64::_mm_mask_abs_epi32">_mm_mask_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi8.html" title="fn core::arch::x86_64::_mm_mask_add_epi8">_mm_mask_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi16.html" title="fn core::arch::x86_64::_mm_mask_add_epi16">_mm_mask_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi32.html" title="fn core::arch::x86_64::_mm_mask_add_epi32">_mm_mask_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_epi64.html" title="fn core::arch::x86_64::_mm_mask_add_epi64">_mm_mask_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_pd.html" title="fn core::arch::x86_64::_mm_mask_add_pd">_mm_mask_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_ps.html" title="fn core::arch::x86_64::_mm_mask_add_ps">_mm_mask_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_round_sd.html" title="fn core::arch::x86_64::_mm_mask_add_round_sd">_mm_mask_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_round_ss.html" title="fn core::arch::x86_64::_mm_mask_add_round_ss">_mm_mask_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_sd.html" title="fn core::arch::x86_64::_mm_mask_add_sd">_mm_mask_add_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_add_ss.html" title="fn core::arch::x86_64::_mm_mask_add_ss">_mm_mask_add_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_adds_epi8.html" title="fn core::arch::x86_64::_mm_mask_adds_epi8">_mm_mask_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_adds_epi16.html" title="fn core::arch::x86_64::_mm_mask_adds_epi16">_mm_mask_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_adds_epu8.html" title="fn core::arch::x86_64::_mm_mask_adds_epu8">_mm_mask_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_adds_epu16.html" title="fn core::arch::x86_64::_mm_mask_adds_epu16">_mm_mask_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_alignr_epi8.html" title="fn core::arch::x86_64::_mm_mask_alignr_epi8">_mm_mask_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的屏蔽位未置位时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_alignr_epi32.html" title="fn core::arch::x86_64::_mm_mask_alignr_epi32">_mm_mask_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_alignr_epi64.html" title="fn core::arch::x86_64::_mm_mask_alignr_epi64">_mm_mask_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_and_epi32.html" title="fn core::arch::x86_64::_mm_mask_and_epi32">_mm_mask_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_and_epi64.html" title="fn core::arch::x86_64::_mm_mask_and_epi64">_mm_mask_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_andnot_epi32.html" title="fn core::arch::x86_64::_mm_mask_andnot_epi32">_mm_mask_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_andnot_epi64.html" title="fn core::arch::x86_64::_mm_mask_andnot_epi64">_mm_mask_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_avg_epu8.html" title="fn core::arch::x86_64::_mm_mask_avg_epu8">_mm_mask_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_avg_epu16.html" title="fn core::arch::x86_64::_mm_mask_avg_epu16">_mm_mask_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_bitshuffle_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_bitshuffle_epi64_mask">_mm_mask_bitshuffle_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将 <code>c</code> 中的 8 个 8 位值作为索引分组到相应 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi8.html" title="fn core::arch::x86_64::_mm_mask_blend_epi8">_mm_mask_blend_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi16.html" title="fn core::arch::x86_64::_mm_mask_blend_epi16">_mm_mask_blend_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi32.html" title="fn core::arch::x86_64::_mm_mask_blend_epi32">_mm_mask_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_epi64.html" title="fn core::arch::x86_64::_mm_mask_blend_epi64">_mm_mask_blend_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_pd.html" title="fn core::arch::x86_64::_mm_mask_blend_pd">_mm_mask_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_blend_ps.html" title="fn core::arch::x86_64::_mm_mask_blend_ps">_mm_mask_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm_mask_broadcastb_epi8">_mm_mask_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm_mask_broadcastd_epi32">_mm_mask_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm_mask_broadcastq_epi64">_mm_mask_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastss_ps.html" title="fn core::arch::x86_64::_mm_mask_broadcastss_ps">_mm_mask_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm_mask_broadcastw_epi16">_mm_mask_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epi8_mask">_mm_mask_cmp_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epi16_mask">_mm_mask_cmp_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epi32_mask">_mm_mask_cmp_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epi64_mask">_mm_mask_cmp_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epu8_mask">_mm_mask_cmp_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epu16_mask">_mm_mask_cmp_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epu32_mask">_mm_mask_cmp_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_epu64_mask">_mm_mask_cmp_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_pd_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_pd_mask">_mm_mask_cmp_pd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_ps_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_ps_mask">_mm_mask_cmp_ps_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_round_sd_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_round_sd_mask">_mm_mask_cmp_round_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_round_ss_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_round_ss_mask">_mm_mask_cmp_round_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_sd_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_sd_mask">_mm_mask_cmp_sd_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmp_ss_mask.html" title="fn core::arch::x86_64::_mm_mask_cmp_ss_mask">_mm_mask_cmp_ss_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epi8_mask">_mm_mask_cmpeq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epi16_mask">_mm_mask_cmpeq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epi32_mask">_mm_mask_cmpeq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epi64_mask">_mm_mask_cmpeq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epu8_mask">_mm_mask_cmpeq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epu16_mask">_mm_mask_cmpeq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epu32_mask">_mm_mask_cmpeq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpeq_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpeq_epu64_mask">_mm_mask_cmpeq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epi8_mask">_mm_mask_cmpge_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epi16_mask">_mm_mask_cmpge_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epi32_mask">_mm_mask_cmpge_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epi64_mask">_mm_mask_cmpge_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epu8_mask">_mm_mask_cmpge_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epu16_mask">_mm_mask_cmpge_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epu32_mask">_mm_mask_cmpge_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpge_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpge_epu64_mask">_mm_mask_cmpge_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epi8_mask">_mm_mask_cmpgt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epi16_mask">_mm_mask_cmpgt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epi32_mask">_mm_mask_cmpgt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epi64_mask">_mm_mask_cmpgt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epu8_mask">_mm_mask_cmpgt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epu16_mask">_mm_mask_cmpgt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epu32_mask">_mm_mask_cmpgt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpgt_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpgt_epu64_mask">_mm_mask_cmpgt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epi8_mask">_mm_mask_cmple_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epi16_mask">_mm_mask_cmple_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epi32_mask">_mm_mask_cmple_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epi64_mask">_mm_mask_cmple_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epu8_mask">_mm_mask_cmple_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epu16_mask">_mm_mask_cmple_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epu32_mask">_mm_mask_cmple_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmple_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmple_epu64_mask">_mm_mask_cmple_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epi8_mask">_mm_mask_cmplt_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epi16_mask">_mm_mask_cmplt_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epi32_mask">_mm_mask_cmplt_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epi64_mask">_mm_mask_cmplt_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epu8_mask">_mm_mask_cmplt_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epu16_mask">_mm_mask_cmplt_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epu32_mask">_mm_mask_cmplt_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmplt_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmplt_epu64_mask">_mm_mask_cmplt_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epi8_mask">_mm_mask_cmpneq_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epi16_mask">_mm_mask_cmpneq_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epi32_mask">_mm_mask_cmpneq_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epi64_mask">_mm_mask_cmpneq_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu8_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epu8_mask">_mm_mask_cmpneq_epu8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu16_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epu16_mask">_mm_mask_cmpneq_epu16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu32_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epu32_mask">_mm_mask_cmpneq_epu32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cmpneq_epu64_mask.html" title="fn core::arch::x86_64::_mm_mask_cmpneq_epu64_mask">_mm_mask_cmpneq_epu64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi8.html" title="fn core::arch::x86_64::_mm_mask_compress_epi8">_mm_mask_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi16.html" title="fn core::arch::x86_64::_mm_mask_compress_epi16">_mm_mask_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi32.html" title="fn core::arch::x86_64::_mm_mask_compress_epi32">_mm_mask_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_epi64.html" title="fn core::arch::x86_64::_mm_mask_compress_epi64">_mm_mask_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_pd.html" title="fn core::arch::x86_64::_mm_mask_compress_pd">_mm_mask_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compress_ps.html" title="fn core::arch::x86_64::_mm_mask_compress_ps">_mm_mask_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi8.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_epi8">_mm_mask_compressstoreu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (其各自的位在 writemask k 中设置) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi16.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_epi16">_mm_mask_compressstoreu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (其各自的位在 writemask k 中设置的那些) 连续存储到 base_addr 处的未对齐内存。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi32.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_epi32">_mm_mask_compressstoreu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的 32 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_epi64.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_epi64">_mm_mask_compressstoreu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的 64 位整数连续存储 (在 writemask k 中设置了相应位的那些) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_pd.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_pd">_mm_mask_compressstoreu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的双精度 (64 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_compressstoreu_ps.html" title="fn core::arch::x86_64::_mm_mask_compressstoreu_ps">_mm_mask_compressstoreu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活动的单精度 (32 位) 浮点元素连续存储 (在 writemask k 中设置了相应位的元素) 到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_conflict_epi32.html" title="fn core::arch::x86_64::_mm_mask_conflict_epi32">_mm_mask_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k (当未设置相应的掩码位时，将从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_conflict_epi64.html" title="fn core::arch::x86_64::_mm_mask_conflict_epi64">_mm_mask_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，将从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm_mask_cvt_roundps_ph">_mm_mask_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundsd_ss.html" title="fn core::arch::x86_64::_mm_mask_cvt_roundsd_ss">_mm_mask_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvt_roundss_sd.html" title="fn core::arch::x86_64::_mm_mask_cvt_roundss_sd">_mm_mask_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepi8_epi16">_mm_mask_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepi8_epi32">_mm_mask_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepi8_epi64">_mm_mask_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存入 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi16_epi8">_mm_mask_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepi16_epi32">_mm_mask_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepi16_epi64">_mm_mask_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi16_storeu_epi8">_mm_mask_cvtepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_epi8">_mm_mask_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_epi16">_mm_mask_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_epi64">_mm_mask_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_pd">_mm_mask_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_ps">_mm_mask_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_storeu_epi8">_mm_mask_cvtepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepi32_storeu_epi16">_mm_mask_cvtepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_epi8">_mm_mask_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_epi16">_mm_mask_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_epi32">_mm_mask_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_storeu_epi8">_mm_mask_cvtepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_storeu_epi16">_mm_mask_cvtepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepi64_storeu_epi32">_mm_mask_cvtepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtepu8_epi16">_mm_mask_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepu8_epi32">_mm_mask_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepu8_epi64">_mm_mask_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtepu16_epi32">_mm_mask_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepu16_epi64">_mm_mask_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 16 位整数 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm_mask_cvtepu32_epi64">_mm_mask_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm_mask_cvtepu32_pd">_mm_mask_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm_mask_cvtne2ps_pbh">_mm_mask_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtpd_epi32">_mm_mask_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm_mask_cvtpd_epu32">_mm_mask_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtpd_ps.html" title="fn core::arch::x86_64::_mm_mask_cvtpd_ps">_mm_mask_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtph_ps.html" title="fn core::arch::x86_64::_mm_mask_cvtph_ps">_mm_mask_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtps_epi32">_mm_mask_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_epu32.html" title="fn core::arch::x86_64::_mm_mask_cvtps_epu32">_mm_mask_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtps_ph.html" title="fn core::arch::x86_64::_mm_mask_cvtps_ph">_mm_mask_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsd_ss.html" title="fn core::arch::x86_64::_mm_mask_cvtsd_ss">_mm_mask_cvtsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi16_epi8">_mm_mask_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi16_storeu_epi8">_mm_mask_cvtsepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi32_epi8">_mm_mask_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi32_epi16">_mm_mask_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi32_storeu_epi8">_mm_mask_cvtsepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi32_storeu_epi16">_mm_mask_cvtsepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_epi8">_mm_mask_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_epi16">_mm_mask_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_epi32">_mm_mask_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi8">_mm_mask_cvtsepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi16">_mm_mask_cvtsepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtsepi64_storeu_epi32">_mm_mask_cvtsepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtss_sd.html" title="fn core::arch::x86_64::_mm_mask_cvtss_sd">_mm_mask_cvtss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvttpd_epi32">_mm_mask_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm_mask_cvttpd_epu32">_mm_mask_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttps_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvttps_epi32">_mm_mask_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvttps_epu32.html" title="fn core::arch::x86_64::_mm_mask_cvttps_epu32">_mm_mask_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi16_epi8">_mm_mask_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi16_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi16_storeu_epi8">_mm_mask_cvtusepi16_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi32_epi8">_mm_mask_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi32_epi16">_mm_mask_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi32_storeu_epi8">_mm_mask_cvtusepi32_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi32_storeu_epi16">_mm_mask_cvtusepi32_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_epi8">_mm_mask_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_epi16">_mm_mask_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_epi32">_mm_mask_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi8">_mm_mask_cvtusepi64_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi16">_mm_mask_cvtusepi64_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi32.html" title="fn core::arch::x86_64::_mm_mask_cvtusepi64_storeu_epi32">_mm_mask_cvtusepi64_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dbsad_epu8.html" title="fn core::arch::x86_64::_mm_mask_dbsad_epu8">_mm_mask_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_pd.html" title="fn core::arch::x86_64::_mm_mask_div_pd">_mm_mask_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_ps.html" title="fn core::arch::x86_64::_mm_mask_div_ps">_mm_mask_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_round_sd.html" title="fn core::arch::x86_64::_mm_mask_div_round_sd">_mm_mask_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_round_ss.html" title="fn core::arch::x86_64::_mm_mask_div_round_ss">_mm_mask_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_sd.html" title="fn core::arch::x86_64::_mm_mask_div_sd">_mm_mask_div_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_div_ss.html" title="fn core::arch::x86_64::_mm_mask_div_ss">_mm_mask_div_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dpbf16_ps.html" title="fn core::arch::x86_64::_mm_mask_dpbf16_ps">_mm_mask_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm_mask_dpbusd_epi32">_mm_mask_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm_mask_dpbusds_epi32">_mm_mask_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm_mask_dpwssd_epi32">_mm_mask_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm_mask_dpwssds_epi32">_mm_mask_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi8.html" title="fn core::arch::x86_64::_mm_mask_expand_epi8">_mm_mask_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi16.html" title="fn core::arch::x86_64::_mm_mask_expand_epi16">_mm_mask_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi32.html" title="fn core::arch::x86_64::_mm_mask_expand_epi32">_mm_mask_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_epi64.html" title="fn core::arch::x86_64::_mm_mask_expand_epi64">_mm_mask_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_pd.html" title="fn core::arch::x86_64::_mm_mask_expand_pd">_mm_mask_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expand_ps.html" title="fn core::arch::x86_64::_mm_mask_expand_ps">_mm_mask_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_epi8">_mm_mask_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_epi16">_mm_mask_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 中复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_epi32">_mm_mask_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从未对齐内存中的 mem_addr 加载连续的活动 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_epi64">_mm_mask_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_pd.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_pd">_mm_mask_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_expandloadu_ps.html" title="fn core::arch::x86_64::_mm_mask_expandloadu_ps">_mm_mask_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位不存在时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_pd.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_pd">_mm_mask_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_ps.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_ps">_mm_mask_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 a 复制元素)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_round_sd.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_round_sd">_mm_mask_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_round_ss.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_round_ss">_mm_mask_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_sd.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_sd">_mm_mask_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fixupimm_ss.html" title="fn core::arch::x86_64::_mm_mask_fixupimm_ss">_mm_mask_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_pd.html" title="fn core::arch::x86_64::_mm_mask_fmadd_pd">_mm_mask_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_ps.html" title="fn core::arch::x86_64::_mm_mask_fmadd_ps">_mm_mask_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_round_sd.html" title="fn core::arch::x86_64::_mm_mask_fmadd_round_sd">_mm_mask_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_round_ss.html" title="fn core::arch::x86_64::_mm_mask_fmadd_round_ss">_mm_mask_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_sd.html" title="fn core::arch::x86_64::_mm_mask_fmadd_sd">_mm_mask_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmadd_ss.html" title="fn core::arch::x86_64::_mm_mask_fmadd_ss">_mm_mask_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm_mask_fmaddsub_pd">_mm_mask_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm_mask_fmaddsub_ps">_mm_mask_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_pd.html" title="fn core::arch::x86_64::_mm_mask_fmsub_pd">_mm_mask_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_ps.html" title="fn core::arch::x86_64::_mm_mask_fmsub_ps">_mm_mask_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_round_sd.html" title="fn core::arch::x86_64::_mm_mask_fmsub_round_sd">_mm_mask_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_round_ss.html" title="fn core::arch::x86_64::_mm_mask_fmsub_round_ss">_mm_mask_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 a 复制该元素)，并将 a 上的 3 个包装的元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_sd.html" title="fn core::arch::x86_64::_mm_mask_fmsub_sd">_mm_mask_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsub_ss.html" title="fn core::arch::x86_64::_mm_mask_fmsub_ss">_mm_mask_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm_mask_fmsubadd_pd">_mm_mask_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm_mask_fmsubadd_ps">_mm_mask_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_pd.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_pd">_mm_mask_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_ps.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_ps">_mm_mask_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_round_sd.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_round_sd">_mm_mask_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_round_ss.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_round_ss">_mm_mask_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_sd.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_sd">_mm_mask_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmadd_ss.html" title="fn core::arch::x86_64::_mm_mask_fnmadd_ss">_mm_mask_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_pd.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_pd">_mm_mask_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_ps.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_ps">_mm_mask_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当当未设置相应的掩码位时，将从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_round_sd.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_round_sd">_mm_mask_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_round_ss.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_round_ss">_mm_mask_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_sd.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_sd">_mm_mask_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_fnmsub_ss.html" title="fn core::arch::x86_64::_mm_mask_fnmsub_ss">_mm_mask_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_pd.html" title="fn core::arch::x86_64::_mm_mask_getexp_pd">_mm_mask_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_ps.html" title="fn core::arch::x86_64::_mm_mask_getexp_ps">_mm_mask_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_round_sd.html" title="fn core::arch::x86_64::_mm_mask_getexp_round_sd">_mm_mask_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_round_ss.html" title="fn core::arch::x86_64::_mm_mask_getexp_round_ss">_mm_mask_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_sd.html" title="fn core::arch::x86_64::_mm_mask_getexp_sd">_mm_mask_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getexp_ss.html" title="fn core::arch::x86_64::_mm_mask_getexp_ss">_mm_mask_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_pd.html" title="fn core::arch::x86_64::_mm_mask_getmant_pd">_mm_mask_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_ps.html" title="fn core::arch::x86_64::_mm_mask_getmant_ps">_mm_mask_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_round_sd.html" title="fn core::arch::x86_64::_mm_mask_getmant_round_sd">_mm_mask_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_round_ss.html" title="fn core::arch::x86_64::_mm_mask_getmant_round_ss">_mm_mask_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_sd.html" title="fn core::arch::x86_64::_mm_mask_getmant_sd">_mm_mask_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_getmant_ss.html" title="fn core::arch::x86_64::_mm_mask_getmant_ss">_mm_mask_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_gf2p8affine_epi64_epi8">_mm_mask_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_gf2p8affineinv_epi64_epi8">_mm_mask_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm_mask_gf2p8mul_epi8">_mm_mask_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_epi32.html" title="fn core::arch::x86_64::_mm_mask_load_epi32">_mm_mask_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_epi64.html" title="fn core::arch::x86_64::_mm_mask_load_epi64">_mm_mask_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_pd.html" title="fn core::arch::x86_64::_mm_mask_load_pd">_mm_mask_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_load_ps.html" title="fn core::arch::x86_64::_mm_mask_load_ps">_mm_mask_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi8.html" title="fn core::arch::x86_64::_mm_mask_loadu_epi8">_mm_mask_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi16.html" title="fn core::arch::x86_64::_mm_mask_loadu_epi16">_mm_mask_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi32.html" title="fn core::arch::x86_64::_mm_mask_loadu_epi32">_mm_mask_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_epi64.html" title="fn core::arch::x86_64::_mm_mask_loadu_epi64">_mm_mask_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_pd.html" title="fn core::arch::x86_64::_mm_mask_loadu_pd">_mm_mask_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_loadu_ps.html" title="fn core::arch::x86_64::_mm_mask_loadu_ps">_mm_mask_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm_mask_lzcnt_epi32">_mm_mask_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm_mask_lzcnt_epi64">_mm_mask_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_madd_epi16.html" title="fn core::arch::x86_64::_mm_mask_madd_epi16">_mm_mask_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_maddubs_epi16.html" title="fn core::arch::x86_64::_mm_mask_maddubs_epi16">_mm_mask_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi8.html" title="fn core::arch::x86_64::_mm_mask_max_epi8">_mm_mask_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi16.html" title="fn core::arch::x86_64::_mm_mask_max_epi16">_mm_mask_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi32.html" title="fn core::arch::x86_64::_mm_mask_max_epi32">_mm_mask_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epi64.html" title="fn core::arch::x86_64::_mm_mask_max_epi64">_mm_mask_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu8.html" title="fn core::arch::x86_64::_mm_mask_max_epu8">_mm_mask_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu16.html" title="fn core::arch::x86_64::_mm_mask_max_epu16">_mm_mask_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu32.html" title="fn core::arch::x86_64::_mm_mask_max_epu32">_mm_mask_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_epu64.html" title="fn core::arch::x86_64::_mm_mask_max_epu64">_mm_mask_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_pd.html" title="fn core::arch::x86_64::_mm_mask_max_pd">_mm_mask_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_ps.html" title="fn core::arch::x86_64::_mm_mask_max_ps">_mm_mask_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_round_sd.html" title="fn core::arch::x86_64::_mm_mask_max_round_sd">_mm_mask_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_round_ss.html" title="fn core::arch::x86_64::_mm_mask_max_round_ss">_mm_mask_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_sd.html" title="fn core::arch::x86_64::_mm_mask_max_sd">_mm_mask_max_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_max_ss.html" title="fn core::arch::x86_64::_mm_mask_max_ss">_mm_mask_max_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epi8.html" title="fn core::arch::x86_64::_mm_mask_min_epi8">_mm_mask_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epi16.html" title="fn core::arch::x86_64::_mm_mask_min_epi16">_mm_mask_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epi32.html" title="fn core::arch::x86_64::_mm_mask_min_epi32">_mm_mask_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu8.html" title="fn core::arch::x86_64::_mm_mask_min_epu8">_mm_mask_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu16.html" title="fn core::arch::x86_64::_mm_mask_min_epu16">_mm_mask_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu32.html" title="fn core::arch::x86_64::_mm_mask_min_epu32">_mm_mask_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_epu64.html" title="fn core::arch::x86_64::_mm_mask_min_epu64">_mm_mask_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_pd.html" title="fn core::arch::x86_64::_mm_mask_min_pd">_mm_mask_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_ps.html" title="fn core::arch::x86_64::_mm_mask_min_ps">_mm_mask_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_round_sd.html" title="fn core::arch::x86_64::_mm_mask_min_round_sd">_mm_mask_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_round_ss.html" title="fn core::arch::x86_64::_mm_mask_min_round_ss">_mm_mask_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_sd.html" title="fn core::arch::x86_64::_mm_mask_min_sd">_mm_mask_min_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_min_ss.html" title="fn core::arch::x86_64::_mm_mask_min_ss">_mm_mask_min_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi8.html" title="fn core::arch::x86_64::_mm_mask_mov_epi8">_mm_mask_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi16.html" title="fn core::arch::x86_64::_mm_mask_mov_epi16">_mm_mask_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi32.html" title="fn core::arch::x86_64::_mm_mask_mov_epi32">_mm_mask_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_epi64.html" title="fn core::arch::x86_64::_mm_mask_mov_epi64">_mm_mask_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_pd.html" title="fn core::arch::x86_64::_mm_mask_mov_pd">_mm_mask_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mov_ps.html" title="fn core::arch::x86_64::_mm_mask_mov_ps">_mm_mask_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_move_sd.html" title="fn core::arch::x86_64::_mm_mask_move_sd">_mm_mask_move_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低位双精度 (64-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高位元素从 a 复制到 a 的高位元素 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_move_ss.html" title="fn core::arch::x86_64::_mm_mask_move_ss">_mm_mask_move_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用写掩码 k 将低位单精度 (32-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高 3 个包装的元素从 a 复制到高位 dst 的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_movedup_pd.html" title="fn core::arch::x86_64::_mm_mask_movedup_pd">_mm_mask_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_movehdup_ps.html" title="fn core::arch::x86_64::_mm_mask_movehdup_ps">_mm_mask_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_moveldup_ps.html" title="fn core::arch::x86_64::_mm_mask_moveldup_ps">_mm_mask_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_epi32.html" title="fn core::arch::x86_64::_mm_mask_mul_epi32">_mm_mask_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_epu32.html" title="fn core::arch::x86_64::_mm_mask_mul_epu32">_mm_mask_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_pd.html" title="fn core::arch::x86_64::_mm_mask_mul_pd">_mm_mask_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_ps.html" title="fn core::arch::x86_64::_mm_mask_mul_ps">_mm_mask_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_round_sd.html" title="fn core::arch::x86_64::_mm_mask_mul_round_sd">_mm_mask_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_round_ss.html" title="fn core::arch::x86_64::_mm_mask_mul_round_ss">_mm_mask_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_sd.html" title="fn core::arch::x86_64::_mm_mask_mul_sd">_mm_mask_mul_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mul_ss.html" title="fn core::arch::x86_64::_mm_mask_mul_ss">_mm_mask_mul_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mulhi_epi16.html" title="fn core::arch::x86_64::_mm_mask_mulhi_epi16">_mm_mask_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mulhi_epu16.html" title="fn core::arch::x86_64::_mm_mask_mulhi_epu16">_mm_mask_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm_mask_mulhrs_epi16">_mm_mask_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mullo_epi16.html" title="fn core::arch::x86_64::_mm_mask_mullo_epi16">_mm_mask_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_mullo_epi32.html" title="fn core::arch::x86_64::_mm_mask_mullo_epi32">_mm_mask_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm_mask_multishift_epi64_epi8">_mm_mask_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_or_epi32.html" title="fn core::arch::x86_64::_mm_mask_or_epi32">_mm_mask_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_or_epi64.html" title="fn core::arch::x86_64::_mm_mask_or_epi64">_mm_mask_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_packs_epi16.html" title="fn core::arch::x86_64::_mm_mask_packs_epi16">_mm_mask_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_packs_epi32.html" title="fn core::arch::x86_64::_mm_mask_packs_epi32">_mm_mask_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_packus_epi16.html" title="fn core::arch::x86_64::_mm_mask_packus_epi16">_mm_mask_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_packus_epi32.html" title="fn core::arch::x86_64::_mm_mask_packus_epi32">_mm_mask_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permute_pd.html" title="fn core::arch::x86_64::_mm_mask_permute_pd">_mm_mask_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permute_ps.html" title="fn core::arch::x86_64::_mm_mask_permute_ps">_mm_mask_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutevar_pd.html" title="fn core::arch::x86_64::_mm_mask_permutevar_pd">_mm_mask_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutevar_ps.html" title="fn core::arch::x86_64::_mm_mask_permutevar_ps">_mm_mask_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_epi8">_mm_mask_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_epi16">_mm_mask_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_epi32">_mm_mask_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_epi64">_mm_mask_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_pd.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_pd">_mm_mask_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutex2var_ps.html" title="fn core::arch::x86_64::_mm_mask_permutex2var_ps">_mm_mask_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 a 和 b 中的 lanes 上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm_mask_permutexvar_epi8">_mm_mask_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm_mask_permutexvar_epi16">_mm_mask_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_popcnt_epi8.html" title="fn core::arch::x86_64::_mm_mask_popcnt_epi8">_mm_mask_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_popcnt_epi16.html" title="fn core::arch::x86_64::_mm_mask_popcnt_epi16">_mm_mask_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_popcnt_epi32.html" title="fn core::arch::x86_64::_mm_mask_popcnt_epi32">_mm_mask_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_popcnt_epi64.html" title="fn core::arch::x86_64::_mm_mask_popcnt_epi64">_mm_mask_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_pd.html" title="fn core::arch::x86_64::_mm_mask_rcp14_pd">_mm_mask_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_ps.html" title="fn core::arch::x86_64::_mm_mask_rcp14_ps">_mm_mask_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_sd.html" title="fn core::arch::x86_64::_mm_mask_rcp14_sd">_mm_mask_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 x 元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rcp14_ss.html" title="fn core::arch::x86_64::_mm_mask_rcp14_ss">_mm_mask_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部单精度 (32-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rol_epi32.html" title="fn core::arch::x86_64::_mm_mask_rol_epi32">_mm_mask_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rol_epi64.html" title="fn core::arch::x86_64::_mm_mask_rol_epi64">_mm_mask_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rolv_epi32.html" title="fn core::arch::x86_64::_mm_mask_rolv_epi32">_mm_mask_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rolv_epi64.html" title="fn core::arch::x86_64::_mm_mask_rolv_epi64">_mm_mask_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ror_epi32.html" title="fn core::arch::x86_64::_mm_mask_ror_epi32">_mm_mask_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ror_epi64.html" title="fn core::arch::x86_64::_mm_mask_ror_epi64">_mm_mask_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rorv_epi32.html" title="fn core::arch::x86_64::_mm_mask_rorv_epi32">_mm_mask_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rorv_epi64.html" title="fn core::arch::x86_64::_mm_mask_rorv_epi64">_mm_mask_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_pd.html" title="fn core::arch::x86_64::_mm_mask_roundscale_pd">_mm_mask_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_ps.html" title="fn core::arch::x86_64::_mm_mask_roundscale_ps">_mm_mask_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_round_sd.html" title="fn core::arch::x86_64::_mm_mask_roundscale_round_sd">_mm_mask_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_round_ss.html" title="fn core::arch::x86_64::_mm_mask_roundscale_round_ss">_mm_mask_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_sd.html" title="fn core::arch::x86_64::_mm_mask_roundscale_sd">_mm_mask_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_roundscale_ss.html" title="fn core::arch::x86_64::_mm_mask_roundscale_ss">_mm_mask_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm_mask_rsqrt14_pd">_mm_mask_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm_mask_rsqrt14_ps">_mm_mask_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_sd.html" title="fn core::arch::x86_64::_mm_mask_rsqrt14_sd">_mm_mask_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_rsqrt14_ss.html" title="fn core::arch::x86_64::_mm_mask_rsqrt14_ss">_mm_mask_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的高位元素的前 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_pd.html" title="fn core::arch::x86_64::_mm_mask_scalef_pd">_mm_mask_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_ps.html" title="fn core::arch::x86_64::_mm_mask_scalef_ps">_mm_mask_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_round_sd.html" title="fn core::arch::x86_64::_mm_mask_scalef_round_sd">_mm_mask_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_round_ss.html" title="fn core::arch::x86_64::_mm_mask_scalef_round_ss">_mm_mask_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_sd.html" title="fn core::arch::x86_64::_mm_mask_scalef_sd">_mm_mask_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_scalef_ss.html" title="fn core::arch::x86_64::_mm_mask_scalef_ss">_mm_mask_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi8.html" title="fn core::arch::x86_64::_mm_mask_set1_epi8">_mm_mask_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi16.html" title="fn core::arch::x86_64::_mm_mask_set1_epi16">_mm_mask_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi32.html" title="fn core::arch::x86_64::_mm_mask_set1_epi32">_mm_mask_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_set1_epi64.html" title="fn core::arch::x86_64::_mm_mask_set1_epi64">_mm_mask_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldi_epi16.html" title="fn core::arch::x86_64::_mm_mask_shldi_epi16">_mm_mask_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldi_epi32.html" title="fn core::arch::x86_64::_mm_mask_shldi_epi32">_mm_mask_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldi_epi64.html" title="fn core::arch::x86_64::_mm_mask_shldi_epi64">_mm_mask_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldv_epi16.html" title="fn core::arch::x86_64::_mm_mask_shldv_epi16">_mm_mask_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldv_epi32.html" title="fn core::arch::x86_64::_mm_mask_shldv_epi32">_mm_mask_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shldv_epi64.html" title="fn core::arch::x86_64::_mm_mask_shldv_epi64">_mm_mask_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdi_epi16.html" title="fn core::arch::x86_64::_mm_mask_shrdi_epi16">_mm_mask_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdi_epi32.html" title="fn core::arch::x86_64::_mm_mask_shrdi_epi32">_mm_mask_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdi_epi64.html" title="fn core::arch::x86_64::_mm_mask_shrdi_epi64">_mm_mask_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdv_epi16.html" title="fn core::arch::x86_64::_mm_mask_shrdv_epi16">_mm_mask_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdv_epi32.html" title="fn core::arch::x86_64::_mm_mask_shrdv_epi32">_mm_mask_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shrdv_epi64.html" title="fn core::arch::x86_64::_mm_mask_shrdv_epi64">_mm_mask_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_epi8.html" title="fn core::arch::x86_64::_mm_mask_shuffle_epi8">_mm_mask_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中相应的 8 位元素中的控件在 128 位 lane 内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_epi32.html" title="fn core::arch::x86_64::_mm_mask_shuffle_epi32">_mm_mask_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件将 128 位 lane 中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_pd.html" title="fn core::arch::x86_64::_mm_mask_shuffle_pd">_mm_mask_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shuffle_ps.html" title="fn core::arch::x86_64::_mm_mask_shuffle_ps">_mm_mask_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件 shuffle a 中的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm_mask_shufflehi_epi16">_mm_mask_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 writemask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm_mask_shufflelo_epi16">_mm_mask_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 writemask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sll_epi16.html" title="fn core::arch::x86_64::_mm_mask_sll_epi16">_mm_mask_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sll_epi32.html" title="fn core::arch::x86_64::_mm_mask_sll_epi32">_mm_mask_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sll_epi64.html" title="fn core::arch::x86_64::_mm_mask_sll_epi64">_mm_mask_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_slli_epi16.html" title="fn core::arch::x86_64::_mm_mask_slli_epi16">_mm_mask_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_slli_epi32.html" title="fn core::arch::x86_64::_mm_mask_slli_epi32">_mm_mask_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_slli_epi64.html" title="fn core::arch::x86_64::_mm_mask_slli_epi64">_mm_mask_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sllv_epi16.html" title="fn core::arch::x86_64::_mm_mask_sllv_epi16">_mm_mask_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sllv_epi32.html" title="fn core::arch::x86_64::_mm_mask_sllv_epi32">_mm_mask_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sllv_epi64.html" title="fn core::arch::x86_64::_mm_mask_sllv_epi64">_mm_mask_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_pd.html" title="fn core::arch::x86_64::_mm_mask_sqrt_pd">_mm_mask_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_ps.html" title="fn core::arch::x86_64::_mm_mask_sqrt_ps">_mm_mask_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_round_sd.html" title="fn core::arch::x86_64::_mm_mask_sqrt_round_sd">_mm_mask_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_round_ss.html" title="fn core::arch::x86_64::_mm_mask_sqrt_round_ss">_mm_mask_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_sd.html" title="fn core::arch::x86_64::_mm_mask_sqrt_sd">_mm_mask_sqrt_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sqrt_ss.html" title="fn core::arch::x86_64::_mm_mask_sqrt_ss">_mm_mask_sqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sra_epi16.html" title="fn core::arch::x86_64::_mm_mask_sra_epi16">_mm_mask_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sra_epi32.html" title="fn core::arch::x86_64::_mm_mask_sra_epi32">_mm_mask_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sra_epi64.html" title="fn core::arch::x86_64::_mm_mask_sra_epi64">_mm_mask_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srai_epi16.html" title="fn core::arch::x86_64::_mm_mask_srai_epi16">_mm_mask_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srai_epi32.html" title="fn core::arch::x86_64::_mm_mask_srai_epi32">_mm_mask_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srai_epi64.html" title="fn core::arch::x86_64::_mm_mask_srai_epi64">_mm_mask_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srav_epi16.html" title="fn core::arch::x86_64::_mm_mask_srav_epi16">_mm_mask_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srav_epi32.html" title="fn core::arch::x86_64::_mm_mask_srav_epi32">_mm_mask_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srav_epi64.html" title="fn core::arch::x86_64::_mm_mask_srav_epi64">_mm_mask_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srl_epi16.html" title="fn core::arch::x86_64::_mm_mask_srl_epi16">_mm_mask_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srl_epi32.html" title="fn core::arch::x86_64::_mm_mask_srl_epi32">_mm_mask_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srl_epi64.html" title="fn core::arch::x86_64::_mm_mask_srl_epi64">_mm_mask_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srli_epi16.html" title="fn core::arch::x86_64::_mm_mask_srli_epi16">_mm_mask_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srli_epi32.html" title="fn core::arch::x86_64::_mm_mask_srli_epi32">_mm_mask_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srli_epi64.html" title="fn core::arch::x86_64::_mm_mask_srli_epi64">_mm_mask_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srlv_epi16.html" title="fn core::arch::x86_64::_mm_mask_srlv_epi16">_mm_mask_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srlv_epi32.html" title="fn core::arch::x86_64::_mm_mask_srlv_epi32">_mm_mask_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_srlv_epi64.html" title="fn core::arch::x86_64::_mm_mask_srlv_epi64">_mm_mask_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_epi32.html" title="fn core::arch::x86_64::_mm_mask_store_epi32">_mm_mask_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_epi64.html" title="fn core::arch::x86_64::_mm_mask_store_epi64">_mm_mask_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_pd.html" title="fn core::arch::x86_64::_mm_mask_store_pd">_mm_mask_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_store_ps.html" title="fn core::arch::x86_64::_mm_mask_store_ps">_mm_mask_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi8.html" title="fn core::arch::x86_64::_mm_mask_storeu_epi8">_mm_mask_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 8 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi16.html" title="fn core::arch::x86_64::_mm_mask_storeu_epi16">_mm_mask_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 16 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi32.html" title="fn core::arch::x86_64::_mm_mask_storeu_epi32">_mm_mask_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 32 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_epi64.html" title="fn core::arch::x86_64::_mm_mask_storeu_epi64">_mm_mask_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将 a 中的 64 位整数存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_pd.html" title="fn core::arch::x86_64::_mm_mask_storeu_pd">_mm_mask_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将封装的双精度 (64-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_storeu_ps.html" title="fn core::arch::x86_64::_mm_mask_storeu_ps">_mm_mask_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 writemask 将封装的单精度 (32-bit) 浮点元素从 a 存储到内存中 k.
mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi8.html" title="fn core::arch::x86_64::_mm_mask_sub_epi8">_mm_mask_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi16.html" title="fn core::arch::x86_64::_mm_mask_sub_epi16">_mm_mask_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi32.html" title="fn core::arch::x86_64::_mm_mask_sub_epi32">_mm_mask_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_epi64.html" title="fn core::arch::x86_64::_mm_mask_sub_epi64">_mm_mask_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_pd.html" title="fn core::arch::x86_64::_mm_mask_sub_pd">_mm_mask_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_ps.html" title="fn core::arch::x86_64::_mm_mask_sub_ps">_mm_mask_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_round_sd.html" title="fn core::arch::x86_64::_mm_mask_sub_round_sd">_mm_mask_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_round_ss.html" title="fn core::arch::x86_64::_mm_mask_sub_round_ss">_mm_mask_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_sd.html" title="fn core::arch::x86_64::_mm_mask_sub_sd">_mm_mask_sub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_sub_ss.html" title="fn core::arch::x86_64::_mm_mask_sub_ss">_mm_mask_sub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_subs_epi8.html" title="fn core::arch::x86_64::_mm_mask_subs_epi8">_mm_mask_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_subs_epi16.html" title="fn core::arch::x86_64::_mm_mask_subs_epi16">_mm_mask_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_subs_epu8.html" title="fn core::arch::x86_64::_mm_mask_subs_epu8">_mm_mask_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_subs_epu16.html" title="fn core::arch::x86_64::_mm_mask_subs_epu16">_mm_mask_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm_mask_ternarylogic_epi32">_mm_mask_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm_mask_ternarylogic_epi64">_mm_mask_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 src、a、b 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 writemask k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_test_epi8_mask">_mm_mask_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_test_epi16_mask">_mm_mask_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_test_epi32_mask">_mm_mask_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_test_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_test_epi64_mask">_mm_mask_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm_mask_testn_epi8_mask">_mm_mask_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm_mask_testn_epi16_mask">_mm_mask_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm_mask_testn_epi32_mask">_mm_mask_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm_mask_testn_epi64_mask">_mm_mask_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_epi8">_mm_mask_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_epi16">_mm_mask_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_epi32">_mm_mask_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_epi64">_mm_mask_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_pd.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_pd">_mm_mask_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpackhi_ps.html" title="fn core::arch::x86_64::_mm_mask_unpackhi_ps">_mm_mask_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_epi8">_mm_mask_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_epi16">_mm_mask_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_epi32">_mm_mask_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_epi64">_mm_mask_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_pd.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_pd">_mm_mask_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_unpacklo_ps.html" title="fn core::arch::x86_64::_mm_mask_unpacklo_ps">_mm_mask_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_xor_epi32.html" title="fn core::arch::x86_64::_mm_mask_xor_epi32">_mm_mask_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_xor_epi64.html" title="fn core::arch::x86_64::_mm_mask_xor_epi64">_mm_mask_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，将从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_abs_epi8.html" title="fn core::arch::x86_64::_mm_maskz_abs_epi8">_mm_maskz_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_abs_epi16.html" title="fn core::arch::x86_64::_mm_maskz_abs_epi16">_mm_maskz_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_abs_epi32.html" title="fn core::arch::x86_64::_mm_maskz_abs_epi32">_mm_maskz_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi8.html" title="fn core::arch::x86_64::_mm_maskz_add_epi8">_mm_maskz_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi16.html" title="fn core::arch::x86_64::_mm_maskz_add_epi16">_mm_maskz_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi32.html" title="fn core::arch::x86_64::_mm_maskz_add_epi32">_mm_maskz_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_epi64.html" title="fn core::arch::x86_64::_mm_maskz_add_epi64">_mm_maskz_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_pd.html" title="fn core::arch::x86_64::_mm_maskz_add_pd">_mm_maskz_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_ps.html" title="fn core::arch::x86_64::_mm_maskz_add_ps">_mm_maskz_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_add_round_sd">_mm_maskz_add_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_add_round_ss">_mm_maskz_add_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_sd.html" title="fn core::arch::x86_64::_mm_maskz_add_sd">_mm_maskz_add_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_add_ss.html" title="fn core::arch::x86_64::_mm_maskz_add_ss">_mm_maskz_add_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_adds_epi8.html" title="fn core::arch::x86_64::_mm_maskz_adds_epi8">_mm_maskz_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_adds_epi16.html" title="fn core::arch::x86_64::_mm_maskz_adds_epi16">_mm_maskz_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_adds_epu8.html" title="fn core::arch::x86_64::_mm_maskz_adds_epu8">_mm_maskz_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_adds_epu16.html" title="fn core::arch::x86_64::_mm_maskz_adds_epu16">_mm_maskz_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_alignr_epi8.html" title="fn core::arch::x86_64::_mm_maskz_alignr_epi8">_mm_maskz_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未设置相应的掩码位时，元素将被清零))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_alignr_epi32.html" title="fn core::arch::x86_64::_mm_maskz_alignr_epi32">_mm_maskz_alignr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_alignr_epi64.html" title="fn core::arch::x86_64::_mm_maskz_alignr_epi64">_mm_maskz_alignr_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_and_epi32.html" title="fn core::arch::x86_64::_mm_maskz_and_epi32">_mm_maskz_and_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_and_epi64.html" title="fn core::arch::x86_64::_mm_maskz_and_epi64">_mm_maskz_and_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_andnot_epi32.html" title="fn core::arch::x86_64::_mm_maskz_andnot_epi32">_mm_maskz_andnot_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_andnot_epi64.html" title="fn core::arch::x86_64::_mm_maskz_andnot_epi64">_mm_maskz_andnot_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_avg_epu8.html" title="fn core::arch::x86_64::_mm_maskz_avg_epu8">_mm_maskz_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_avg_epu16.html" title="fn core::arch::x86_64::_mm_maskz_avg_epu16">_mm_maskz_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm_maskz_broadcastb_epi8">_mm_maskz_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm_maskz_broadcastd_epi32">_mm_maskz_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm_maskz_broadcastq_epi64">_mm_maskz_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastss_ps.html" title="fn core::arch::x86_64::_mm_maskz_broadcastss_ps">_mm_maskz_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm_maskz_broadcastw_epi16">_mm_maskz_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi8.html" title="fn core::arch::x86_64::_mm_maskz_compress_epi8">_mm_maskz_compress_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi16.html" title="fn core::arch::x86_64::_mm_maskz_compress_epi16">_mm_maskz_compress_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi32.html" title="fn core::arch::x86_64::_mm_maskz_compress_epi32">_mm_maskz_compress_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_epi64.html" title="fn core::arch::x86_64::_mm_maskz_compress_epi64">_mm_maskz_compress_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_pd.html" title="fn core::arch::x86_64::_mm_maskz_compress_pd">_mm_maskz_compress_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_compress_ps.html" title="fn core::arch::x86_64::_mm_maskz_compress_ps">_mm_maskz_compress_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将活跃的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_conflict_epi32.html" title="fn core::arch::x86_64::_mm_maskz_conflict_epi32">_mm_maskz_conflict_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_conflict_epi64.html" title="fn core::arch::x86_64::_mm_maskz_conflict_epi64">_mm_maskz_conflict_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k (当未设置相应的掩码位时，元素将被清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundps_ph.html" title="fn core::arch::x86_64::_mm_maskz_cvt_roundps_ph">_mm_maskz_cvt_roundps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundsd_ss.html" title="fn core::arch::x86_64::_mm_maskz_cvt_roundsd_ss">_mm_maskz_cvt_roundsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一：<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvt_roundss_sd.html" title="fn core::arch::x86_64::_mm_maskz_cvt_roundss_sd">_mm_maskz_cvt_roundss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi8_epi16">_mm_maskz_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi8_epi32">_mm_maskz_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi8_epi64">_mm_maskz_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi16_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi16_epi8">_mm_maskz_cvtepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi16_epi32">_mm_maskz_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi16_epi64">_mm_maskz_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi32_epi8">_mm_maskz_cvtepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi32_epi16">_mm_maskz_cvtepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi32_epi64">_mm_maskz_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi32_pd">_mm_maskz_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi32_ps">_mm_maskz_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi64_epi8">_mm_maskz_cvtepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi64_epi16">_mm_maskz_cvtepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepi64_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtepi64_epi32">_mm_maskz_cvtepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu8_epi16">_mm_maskz_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu8_epi32">_mm_maskz_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数 a 的后 4 个字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu8_epi64">_mm_maskz_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu16_epi32">_mm_maskz_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu16_epi64">_mm_maskz_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">零扩展包装的无符号 16 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu32_epi64">_mm_maskz_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtepu32_pd.html" title="fn core::arch::x86_64::_mm_maskz_cvtepu32_pd">_mm_maskz_cvtepu32_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtne2ps_pbh.html" title="fn core::arch::x86_64::_mm_maskz_cvtne2ps_pbh">_mm_maskz_cvtne2ps_pbh</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtpd_epi32">_mm_maskz_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_epu32.html" title="fn core::arch::x86_64::_mm_maskz_cvtpd_epu32">_mm_maskz_cvtpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtpd_ps.html" title="fn core::arch::x86_64::_mm_maskz_cvtpd_ps">_mm_maskz_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtph_ps.html" title="fn core::arch::x86_64::_mm_maskz_cvtph_ps">_mm_maskz_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtps_epi32">_mm_maskz_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_epu32.html" title="fn core::arch::x86_64::_mm_maskz_cvtps_epu32">_mm_maskz_cvtps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtps_ph.html" title="fn core::arch::x86_64::_mm_maskz_cvtps_ph">_mm_maskz_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsd_ss.html" title="fn core::arch::x86_64::_mm_maskz_cvtsd_ss">_mm_maskz_cvtsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi16_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi16_epi8">_mm_maskz_cvtsepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi32_epi8">_mm_maskz_cvtsepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi32_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi32_epi16">_mm_maskz_cvtsepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi64_epi8">_mm_maskz_cvtsepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi64_epi16">_mm_maskz_cvtsepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtsepi64_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtsepi64_epi32">_mm_maskz_cvtsepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtss_sd.html" title="fn core::arch::x86_64::_mm_maskz_cvtss_sd">_mm_maskz_cvtss_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvttpd_epi32">_mm_maskz_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttpd_epu32.html" title="fn core::arch::x86_64::_mm_maskz_cvttpd_epu32">_mm_maskz_cvttpd_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttps_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvttps_epi32">_mm_maskz_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvttps_epu32.html" title="fn core::arch::x86_64::_mm_maskz_cvttps_epu32">_mm_maskz_cvttps_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi16_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi16_epi8">_mm_maskz_cvtusepi16_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi32_epi8">_mm_maskz_cvtusepi32_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi32_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi32_epi16">_mm_maskz_cvtusepi32_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi64_epi8">_mm_maskz_cvtusepi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi16.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi64_epi16">_mm_maskz_cvtusepi64_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_cvtusepi64_epi32.html" title="fn core::arch::x86_64::_mm_maskz_cvtusepi64_epi32">_mm_maskz_cvtusepi64_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dbsad_epu8.html" title="fn core::arch::x86_64::_mm_maskz_dbsad_epu8">_mm_maskz_dbsad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。对于每个 64 位 lane，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中 lane 的低 8 位四元组，而后两个 SAD 使用 a 中 lane 的较高 8 位四元组。根据 imm8 中的控件，从 128 位 lane 中选择 b 中的四元组，并且每个 64 位 lanes 中的每个 SAD 使用 8 位偏移量的选定四元组。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_pd.html" title="fn core::arch::x86_64::_mm_maskz_div_pd">_mm_maskz_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_ps.html" title="fn core::arch::x86_64::_mm_maskz_div_ps">_mm_maskz_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_div_round_sd">_mm_maskz_div_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_div_round_ss">_mm_maskz_div_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_sd.html" title="fn core::arch::x86_64::_mm_maskz_div_sd">_mm_maskz_div_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_div_ss.html" title="fn core::arch::x86_64::_mm_maskz_div_ss">_mm_maskz_div_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dpbf16_ps.html" title="fn core::arch::x86_64::_mm_maskz_dpbf16_ps">_mm_maskz_dpbf16_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bf16,avx512vl` only">(x86 or x86-64) and <code>avx512bf16,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dpbusd_epi32.html" title="fn core::arch::x86_64::_mm_maskz_dpbusd_epi32">_mm_maskz_dpbusd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dpbusds_epi32.html" title="fn core::arch::x86_64::_mm_maskz_dpbusds_epi32">_mm_maskz_dpbusds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dpwssd_epi32.html" title="fn core::arch::x86_64::_mm_maskz_dpwssd_epi32">_mm_maskz_dpwssd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_dpwssds_epi32.html" title="fn core::arch::x86_64::_mm_maskz_dpwssds_epi32">_mm_maskz_dpwssds_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vnni,avx512vl` only">(x86 or x86-64) and <code>avx512vnni,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi8.html" title="fn core::arch::x86_64::_mm_maskz_expand_epi8">_mm_maskz_expand_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi16.html" title="fn core::arch::x86_64::_mm_maskz_expand_epi16">_mm_maskz_expand_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi32.html" title="fn core::arch::x86_64::_mm_maskz_expand_epi32">_mm_maskz_expand_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 32 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_epi64.html" title="fn core::arch::x86_64::_mm_maskz_expand_epi64">_mm_maskz_expand_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的有效 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_pd.html" title="fn core::arch::x86_64::_mm_maskz_expand_pd">_mm_maskz_expand_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expand_ps.html" title="fn core::arch::x86_64::_mm_maskz_expand_ps">_mm_maskz_expand_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi8.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_epi8">_mm_maskz_expandloadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi16.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_epi16">_mm_maskz_expandloadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vbmi2,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vbmi2,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 16 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi32.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_epi32">_mm_maskz_expandloadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 32 位整数 (在掩码 k 中设置了相应位的那些)，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_epi64.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_epi64">_mm_maskz_expandloadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动 64 位整数 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_pd.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_pd">_mm_maskz_expandloadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (64-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_expandloadu_ps.html" title="fn core::arch::x86_64::_mm_maskz_expandloadu_ps">_mm_maskz_expandloadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">从 mem_addr 的未对齐内存中加载连续的活动单精度 (32-bit) 浮点元素 (它们各自的位被设置在掩码 k 中)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_pd.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_pd">_mm_maskz_fixupimm_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_ps.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_ps">_mm_maskz_fixupimm_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_round_sd">_mm_maskz_fixupimm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_round_ss">_mm_maskz_fixupimm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_sd.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_sd">_mm_maskz_fixupimm_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fixupimm_ss.html" title="fn core::arch::x86_64::_mm_maskz_fixupimm_ss">_mm_maskz_fixupimm_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_pd.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_pd">_mm_maskz_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_ps.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_ps">_mm_maskz_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_round_sd">_mm_maskz_fmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_round_ss">_mm_maskz_fmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_sd.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_sd">_mm_maskz_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmadd_ss.html" title="fn core::arch::x86_64::_mm_maskz_fmadd_ss">_mm_maskz_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm_maskz_fmaddsub_pd">_mm_maskz_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm_maskz_fmaddsub_ps">_mm_maskz_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_pd.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_pd">_mm_maskz_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_ps.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_ps">_mm_maskz_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_round_sd">_mm_maskz_fmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_round_ss">_mm_maskz_fmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，元素被清零)，并将上层 3 个包装的元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_sd.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_sd">_mm_maskz_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsub_ss.html" title="fn core::arch::x86_64::_mm_maskz_fmsub_ss">_mm_maskz_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，元素被清零)，并将上层 3 个包装的元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm_maskz_fmsubadd_pd">_mm_maskz_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm_maskz_fmsubadd_ps">_mm_maskz_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_pd.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_pd">_mm_maskz_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_ps.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_ps">_mm_maskz_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_round_sd">_mm_maskz_fnmadd_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_round_ss">_mm_maskz_fnmadd_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_sd.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_sd">_mm_maskz_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmadd_ss.html" title="fn core::arch::x86_64::_mm_maskz_fnmadd_ss">_mm_maskz_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_pd.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_pd">_mm_maskz_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_ps.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_ps">_mm_maskz_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_round_sd">_mm_maskz_fnmsub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_round_ss">_mm_maskz_fnmsub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，元素被清零)，并将上层 3 个包装的元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_sd.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_sd">_mm_maskz_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_fnmsub_ss.html" title="fn core::arch::x86_64::_mm_maskz_fnmsub_ss">_mm_maskz_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，元素被清零)，并将上层 3 个包装的元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_pd.html" title="fn core::arch::x86_64::_mm_maskz_getexp_pd">_mm_maskz_getexp_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_ps.html" title="fn core::arch::x86_64::_mm_maskz_getexp_ps">_mm_maskz_getexp_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。本质上，此内部函数为每个元素计算 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_getexp_round_sd">_mm_maskz_getexp_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_getexp_round_ss">_mm_maskz_getexp_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内部函数计算下层元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_sd.html" title="fn core::arch::x86_64::_mm_maskz_getexp_sd">_mm_maskz_getexp_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getexp_ss.html" title="fn core::arch::x86_64::_mm_maskz_getexp_ss">_mm_maskz_getexp_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内部函数计算下层元素的 floor(log2(x))。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_pd.html" title="fn core::arch::x86_64::_mm_maskz_getmant_pd">_mm_maskz_getmant_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_ps.html" title="fn core::arch::x86_64::_mm_maskz_getmant_ps">_mm_maskz_getmant_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_getmant_round_sd">_mm_maskz_getmant_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_getmant_round_ss">_mm_maskz_getmant_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_sd.html" title="fn core::arch::x86_64::_mm_maskz_getmant_sd">_mm_maskz_getmant_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_getmant_ss.html" title="fn core::arch::x86_64::_mm_maskz_getmant_ss">_mm_maskz_getmant_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内部函数本质上计算 ±(2^k)*|x.significand|，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值：<br />
_MM_MANT_NORM_1_2     // 区间 [1, 2)<br />
_MM_MANT_NORM_p5_2    // 区间 [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // 区间 [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) <br />
该符号由 sc 确定，可以采用以下值：<br />
_MM_MANT_SIGN_src     // sign = sign(src) <br />
_MM_MANT_SIGN_zero    // sign = 0 <br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 <br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_gf2p8affine_epi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_gf2p8affine_epi64_epi8">_mm_maskz_gf2p8affine_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对包中的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_gf2p8affineinv_epi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_gf2p8affineinv_epi64_epi8">_mm_maskz_gf2p8affineinv_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">对 inverted 中的封装的字节进行仿射变换 x.
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_gf2p8mul_epi8.html" title="fn core::arch::x86_64::_mm_maskz_gf2p8mul_epi8">_mm_maskz_gf2p8mul_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `gfni,avx512bw,avx512vl` only">(x86 or x86-64) and <code>gfni,avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在包装的字节上执行 GF(2^8) 乘法。
该字段采用多项式表示，归约多项式 x^8 + x^4 + x^3 + x + 1.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_epi32.html" title="fn core::arch::x86_64::_mm_maskz_load_epi32">_mm_maskz_load_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_epi64.html" title="fn core::arch::x86_64::_mm_maskz_load_epi64">_mm_maskz_load_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_pd.html" title="fn core::arch::x86_64::_mm_maskz_load_pd">_mm_maskz_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_load_ps.html" title="fn core::arch::x86_64::_mm_maskz_load_ps">_mm_maskz_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi8.html" title="fn core::arch::x86_64::_mm_maskz_loadu_epi8">_mm_maskz_loadu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 8 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi16.html" title="fn core::arch::x86_64::_mm_maskz_loadu_epi16">_mm_maskz_loadu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512bw,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512bw,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 16 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi32.html" title="fn core::arch::x86_64::_mm_maskz_loadu_epi32">_mm_maskz_loadu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 32 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_epi64.html" title="fn core::arch::x86_64::_mm_maskz_loadu_epi64">_mm_maskz_loadu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的 64 位整数从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_pd.html" title="fn core::arch::x86_64::_mm_maskz_loadu_pd">_mm_maskz_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的双精度 (64-bit) 浮点元素从内存加载到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_loadu_ps.html" title="fn core::arch::x86_64::_mm_maskz_loadu_ps">_mm_maskz_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl,avx,sse` only">(x86 or x86-64) and <code>avx512f,avx512vl,avx,sse</code></span></div><div class="desc docblock-short">使用 zeromask k 将包装的单精度 (32-bit) 浮点元素从内存加载到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_lzcnt_epi32.html" title="fn core::arch::x86_64::_mm_maskz_lzcnt_epi32">_mm_maskz_lzcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_lzcnt_epi64.html" title="fn core::arch::x86_64::_mm_maskz_lzcnt_epi64">_mm_maskz_lzcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512cd,avx512vl` only">(x86 or x86-64) and <code>avx512cd,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_madd_epi16.html" title="fn core::arch::x86_64::_mm_maskz_madd_epi16">_mm_maskz_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_maddubs_epi16.html" title="fn core::arch::x86_64::_mm_maskz_maddubs_epi16">_mm_maskz_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的一对中间有符号 16 位整数，并使用 zeromask k 将饱和结果打包到 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi8.html" title="fn core::arch::x86_64::_mm_maskz_max_epi8">_mm_maskz_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi16.html" title="fn core::arch::x86_64::_mm_maskz_max_epi16">_mm_maskz_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi32.html" title="fn core::arch::x86_64::_mm_maskz_max_epi32">_mm_maskz_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epi64.html" title="fn core::arch::x86_64::_mm_maskz_max_epi64">_mm_maskz_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu8.html" title="fn core::arch::x86_64::_mm_maskz_max_epu8">_mm_maskz_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu16.html" title="fn core::arch::x86_64::_mm_maskz_max_epu16">_mm_maskz_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu32.html" title="fn core::arch::x86_64::_mm_maskz_max_epu32">_mm_maskz_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_epu64.html" title="fn core::arch::x86_64::_mm_maskz_max_epu64">_mm_maskz_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_pd.html" title="fn core::arch::x86_64::_mm_maskz_max_pd">_mm_maskz_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_ps.html" title="fn core::arch::x86_64::_mm_maskz_max_ps">_mm_maskz_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_max_round_sd">_mm_maskz_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_max_round_ss">_mm_maskz_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_sd.html" title="fn core::arch::x86_64::_mm_maskz_max_sd">_mm_maskz_max_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_max_ss.html" title="fn core::arch::x86_64::_mm_maskz_max_ss">_mm_maskz_max_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epi8.html" title="fn core::arch::x86_64::_mm_maskz_min_epi8">_mm_maskz_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epi16.html" title="fn core::arch::x86_64::_mm_maskz_min_epi16">_mm_maskz_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epi32.html" title="fn core::arch::x86_64::_mm_maskz_min_epi32">_mm_maskz_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu8.html" title="fn core::arch::x86_64::_mm_maskz_min_epu8">_mm_maskz_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu16.html" title="fn core::arch::x86_64::_mm_maskz_min_epu16">_mm_maskz_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu32.html" title="fn core::arch::x86_64::_mm_maskz_min_epu32">_mm_maskz_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_epu64.html" title="fn core::arch::x86_64::_mm_maskz_min_epu64">_mm_maskz_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_pd.html" title="fn core::arch::x86_64::_mm_maskz_min_pd">_mm_maskz_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_ps.html" title="fn core::arch::x86_64::_mm_maskz_min_ps">_mm_maskz_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_min_round_sd">_mm_maskz_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_min_round_ss">_mm_maskz_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_sd.html" title="fn core::arch::x86_64::_mm_maskz_min_sd">_mm_maskz_min_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_min_ss.html" title="fn core::arch::x86_64::_mm_maskz_min_ss">_mm_maskz_min_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi8.html" title="fn core::arch::x86_64::_mm_maskz_mov_epi8">_mm_maskz_mov_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi16.html" title="fn core::arch::x86_64::_mm_maskz_mov_epi16">_mm_maskz_mov_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi32.html" title="fn core::arch::x86_64::_mm_maskz_mov_epi32">_mm_maskz_mov_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 32 位整数从 a 移至 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_epi64.html" title="fn core::arch::x86_64::_mm_maskz_mov_epi64">_mm_maskz_mov_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的 64 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_pd.html" title="fn core::arch::x86_64::_mm_maskz_mov_pd">_mm_maskz_mov_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mov_ps.html" title="fn core::arch::x86_64::_mm_maskz_mov_ps">_mm_maskz_mov_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_move_sd.html" title="fn core::arch::x86_64::_mm_maskz_move_sd">_mm_maskz_move_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将较低的双精度 (64-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_move_ss.html" title="fn core::arch::x86_64::_mm_maskz_move_ss">_mm_maskz_move_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用零掩码 k 将较低的单精度 (32-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的 3 个包装的元素从 a 复制到较高的元素 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_movedup_pd.html" title="fn core::arch::x86_64::_mm_maskz_movedup_pd">_mm_maskz_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_movehdup_ps.html" title="fn core::arch::x86_64::_mm_maskz_movehdup_ps">_mm_maskz_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_moveldup_ps.html" title="fn core::arch::x86_64::_mm_maskz_moveldup_ps">_mm_maskz_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_epi32.html" title="fn core::arch::x86_64::_mm_maskz_mul_epi32">_mm_maskz_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_epu32.html" title="fn core::arch::x86_64::_mm_maskz_mul_epu32">_mm_maskz_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_pd.html" title="fn core::arch::x86_64::_mm_maskz_mul_pd">_mm_maskz_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_ps.html" title="fn core::arch::x86_64::_mm_maskz_mul_ps">_mm_maskz_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_mul_round_sd">_mm_maskz_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_mul_round_ss">_mm_maskz_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_sd.html" title="fn core::arch::x86_64::_mm_maskz_mul_sd">_mm_maskz_mul_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mul_ss.html" title="fn core::arch::x86_64::_mm_maskz_mul_ss">_mm_maskz_mul_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mulhi_epi16.html" title="fn core::arch::x86_64::_mm_maskz_mulhi_epi16">_mm_maskz_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mulhi_epu16.html" title="fn core::arch::x86_64::_mm_maskz_mulhi_epu16">_mm_maskz_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm_maskz_mulhrs_epi16">_mm_maskz_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mullo_epi16.html" title="fn core::arch::x86_64::_mm_maskz_mullo_epi16">_mm_maskz_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_mullo_epi32.html" title="fn core::arch::x86_64::_mm_maskz_mullo_epi32">_mm_maskz_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm_maskz_multishift_epi64_epi8">_mm_maskz_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_or_epi32.html" title="fn core::arch::x86_64::_mm_maskz_or_epi32">_mm_maskz_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_or_epi64.html" title="fn core::arch::x86_64::_mm_maskz_or_epi64">_mm_maskz_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_packs_epi16.html" title="fn core::arch::x86_64::_mm_maskz_packs_epi16">_mm_maskz_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_packs_epi32.html" title="fn core::arch::x86_64::_mm_maskz_packs_epi32">_mm_maskz_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_packus_epi16.html" title="fn core::arch::x86_64::_mm_maskz_packus_epi16">_mm_maskz_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_packus_epi32.html" title="fn core::arch::x86_64::_mm_maskz_packus_epi32">_mm_maskz_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permute_pd.html" title="fn core::arch::x86_64::_mm_maskz_permute_pd">_mm_maskz_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permute_ps.html" title="fn core::arch::x86_64::_mm_maskz_permute_ps">_mm_maskz_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutevar_pd.html" title="fn core::arch::x86_64::_mm_maskz_permutevar_pd">_mm_maskz_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutevar_ps.html" title="fn core::arch::x86_64::_mm_maskz_permutevar_ps">_mm_maskz_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的控件在 128 位 lane 内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_epi8">_mm_maskz_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_epi16">_mm_maskz_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用相应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_epi32">_mm_maskz_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_epi64">_mm_maskz_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_pd.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_pd">_mm_maskz_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引将 a 和 b 中的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutex2var_ps.html" title="fn core::arch::x86_64::_mm_maskz_permutex2var_ps">_mm_maskz_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm_maskz_permutexvar_epi8">_mm_maskz_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm_maskz_permutexvar_epi16">_mm_maskz_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_popcnt_epi8.html" title="fn core::arch::x86_64::_mm_maskz_popcnt_epi8">_mm_maskz_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_popcnt_epi16.html" title="fn core::arch::x86_64::_mm_maskz_popcnt_epi16">_mm_maskz_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_popcnt_epi32.html" title="fn core::arch::x86_64::_mm_maskz_popcnt_epi32">_mm_maskz_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_popcnt_epi64.html" title="fn core::arch::x86_64::_mm_maskz_popcnt_epi64">_mm_maskz_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_pd.html" title="fn core::arch::x86_64::_mm_maskz_rcp14_pd">_mm_maskz_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_ps.html" title="fn core::arch::x86_64::_mm_maskz_rcp14_ps">_mm_maskz_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_sd.html" title="fn core::arch::x86_64::_mm_maskz_rcp14_sd">_mm_maskz_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制较高元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rcp14_ss.html" title="fn core::arch::x86_64::_mm_maskz_rcp14_ss">_mm_maskz_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rol_epi32.html" title="fn core::arch::x86_64::_mm_maskz_rol_epi32">_mm_maskz_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rol_epi64.html" title="fn core::arch::x86_64::_mm_maskz_rol_epi64">_mm_maskz_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rolv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_rolv_epi32">_mm_maskz_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rolv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_rolv_epi64">_mm_maskz_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ror_epi32.html" title="fn core::arch::x86_64::_mm_maskz_ror_epi32">_mm_maskz_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ror_epi64.html" title="fn core::arch::x86_64::_mm_maskz_ror_epi64">_mm_maskz_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rorv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_rorv_epi32">_mm_maskz_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rorv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_rorv_epi64">_mm_maskz_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_pd.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_pd">_mm_maskz_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_ps.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_ps">_mm_maskz_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_round_sd">_mm_maskz_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_round_ss">_mm_maskz_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_sd.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_sd">_mm_maskz_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_roundscale_ss.html" title="fn core::arch::x86_64::_mm_maskz_roundscale_ss">_mm_maskz_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_pd.html" title="fn core::arch::x86_64::_mm_maskz_rsqrt14_pd">_mm_maskz_rsqrt14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_ps.html" title="fn core::arch::x86_64::_mm_maskz_rsqrt14_ps">_mm_maskz_rsqrt14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_sd.html" title="fn core::arch::x86_64::_mm_maskz_rsqrt14_sd">_mm_maskz_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_rsqrt14_ss.html" title="fn core::arch::x86_64::_mm_maskz_rsqrt14_ss">_mm_maskz_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上层元素的上 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_pd.html" title="fn core::arch::x86_64::_mm_maskz_scalef_pd">_mm_maskz_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_ps.html" title="fn core::arch::x86_64::_mm_maskz_scalef_ps">_mm_maskz_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_scalef_round_sd">_mm_maskz_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_scalef_round_ss">_mm_maskz_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_sd.html" title="fn core::arch::x86_64::_mm_maskz_scalef_sd">_mm_maskz_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_scalef_ss.html" title="fn core::arch::x86_64::_mm_maskz_scalef_ss">_mm_maskz_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi8.html" title="fn core::arch::x86_64::_mm_maskz_set1_epi8">_mm_maskz_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi16.html" title="fn core::arch::x86_64::_mm_maskz_set1_epi16">_mm_maskz_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi32.html" title="fn core::arch::x86_64::_mm_maskz_set1_epi32">_mm_maskz_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_set1_epi64.html" title="fn core::arch::x86_64::_mm_maskz_set1_epi64">_mm_maskz_set1_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldi_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shldi_epi16">_mm_maskz_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldi_epi32.html" title="fn core::arch::x86_64::_mm_maskz_shldi_epi32">_mm_maskz_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldi_epi64.html" title="fn core::arch::x86_64::_mm_maskz_shldi_epi64">_mm_maskz_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldv_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shldv_epi16">_mm_maskz_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_shldv_epi32">_mm_maskz_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shldv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_shldv_epi64">_mm_maskz_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdi_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shrdi_epi16">_mm_maskz_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdi_epi32.html" title="fn core::arch::x86_64::_mm_maskz_shrdi_epi32">_mm_maskz_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdi_epi64.html" title="fn core::arch::x86_64::_mm_maskz_shrdi_epi64">_mm_maskz_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdv_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shrdv_epi16">_mm_maskz_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_shrdv_epi32">_mm_maskz_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shrdv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_shrdv_epi64">_mm_maskz_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_epi8.html" title="fn core::arch::x86_64::_mm_maskz_shuffle_epi8">_mm_maskz_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_epi32.html" title="fn core::arch::x86_64::_mm_maskz_shuffle_epi32">_mm_maskz_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 128 位 lane 中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_pd.html" title="fn core::arch::x86_64::_mm_maskz_shuffle_pd">_mm_maskz_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 128 位 lane 内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shuffle_ps.html" title="fn core::arch::x86_64::_mm_maskz_shuffle_ps">_mm_maskz_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件对 a 中的单精度 (32-bit) 浮点元素进行打乱，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shufflehi_epi16">_mm_maskz_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的高 64 位中，使用 zeromask k 将 128 位 lanes 的低 64 位从 a 复制到 dst (当相应的掩码位未设置时，元素被清零) .</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm_maskz_shufflelo_epi16">_mm_maskz_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 imm8 中的控件在 a 的 128 位 lane 的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位 lanes 的低 64 位中，使用 writemask k 将 128 位 lanes 的高 64 位从 a 复制到 dst (当相应的掩码位未设置时，从 src 复制元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sll_epi16.html" title="fn core::arch::x86_64::_mm_maskz_sll_epi16">_mm_maskz_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sll_epi32.html" title="fn core::arch::x86_64::_mm_maskz_sll_epi32">_mm_maskz_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sll_epi64.html" title="fn core::arch::x86_64::_mm_maskz_sll_epi64">_mm_maskz_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_slli_epi16.html" title="fn core::arch::x86_64::_mm_maskz_slli_epi16">_mm_maskz_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_slli_epi32.html" title="fn core::arch::x86_64::_mm_maskz_slli_epi32">_mm_maskz_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_slli_epi64.html" title="fn core::arch::x86_64::_mm_maskz_slli_epi64">_mm_maskz_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sllv_epi16.html" title="fn core::arch::x86_64::_mm_maskz_sllv_epi16">_mm_maskz_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sllv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_sllv_epi32">_mm_maskz_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sllv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_sllv_epi64">_mm_maskz_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_pd.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_pd">_mm_maskz_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_ps.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_ps">_mm_maskz_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_round_sd">_mm_maskz_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_round_ss">_mm_maskz_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_sd.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_sd">_mm_maskz_sqrt_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sqrt_ss.html" title="fn core::arch::x86_64::_mm_maskz_sqrt_ss">_mm_maskz_sqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sra_epi16.html" title="fn core::arch::x86_64::_mm_maskz_sra_epi16">_mm_maskz_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sra_epi32.html" title="fn core::arch::x86_64::_mm_maskz_sra_epi32">_mm_maskz_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sra_epi64.html" title="fn core::arch::x86_64::_mm_maskz_sra_epi64">_mm_maskz_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srai_epi16.html" title="fn core::arch::x86_64::_mm_maskz_srai_epi16">_mm_maskz_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srai_epi32.html" title="fn core::arch::x86_64::_mm_maskz_srai_epi32">_mm_maskz_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srai_epi64.html" title="fn core::arch::x86_64::_mm_maskz_srai_epi64">_mm_maskz_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srav_epi16.html" title="fn core::arch::x86_64::_mm_maskz_srav_epi16">_mm_maskz_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srav_epi32.html" title="fn core::arch::x86_64::_mm_maskz_srav_epi32">_mm_maskz_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srav_epi64.html" title="fn core::arch::x86_64::_mm_maskz_srav_epi64">_mm_maskz_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srl_epi16.html" title="fn core::arch::x86_64::_mm_maskz_srl_epi16">_mm_maskz_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srl_epi32.html" title="fn core::arch::x86_64::_mm_maskz_srl_epi32">_mm_maskz_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srl_epi64.html" title="fn core::arch::x86_64::_mm_maskz_srl_epi64">_mm_maskz_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srli_epi16.html" title="fn core::arch::x86_64::_mm_maskz_srli_epi16">_mm_maskz_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srli_epi32.html" title="fn core::arch::x86_64::_mm_maskz_srli_epi32">_mm_maskz_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srli_epi64.html" title="fn core::arch::x86_64::_mm_maskz_srli_epi64">_mm_maskz_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srlv_epi16.html" title="fn core::arch::x86_64::_mm_maskz_srlv_epi16">_mm_maskz_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srlv_epi32.html" title="fn core::arch::x86_64::_mm_maskz_srlv_epi32">_mm_maskz_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_srlv_epi64.html" title="fn core::arch::x86_64::_mm_maskz_srlv_epi64">_mm_maskz_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi8.html" title="fn core::arch::x86_64::_mm_maskz_sub_epi8">_mm_maskz_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi16.html" title="fn core::arch::x86_64::_mm_maskz_sub_epi16">_mm_maskz_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi32.html" title="fn core::arch::x86_64::_mm_maskz_sub_epi32">_mm_maskz_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_epi64.html" title="fn core::arch::x86_64::_mm_maskz_sub_epi64">_mm_maskz_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_pd.html" title="fn core::arch::x86_64::_mm_maskz_sub_pd">_mm_maskz_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_ps.html" title="fn core::arch::x86_64::_mm_maskz_sub_ps">_mm_maskz_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_round_sd.html" title="fn core::arch::x86_64::_mm_maskz_sub_round_sd">_mm_maskz_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_round_ss.html" title="fn core::arch::x86_64::_mm_maskz_sub_round_ss">_mm_maskz_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_sd.html" title="fn core::arch::x86_64::_mm_maskz_sub_sd">_mm_maskz_sub_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_sub_ss.html" title="fn core::arch::x86_64::_mm_maskz_sub_ss">_mm_maskz_sub_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_subs_epi8.html" title="fn core::arch::x86_64::_mm_maskz_subs_epi8">_mm_maskz_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_subs_epi16.html" title="fn core::arch::x86_64::_mm_maskz_subs_epi16">_mm_maskz_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_subs_epu8.html" title="fn core::arch::x86_64::_mm_maskz_subs_epu8">_mm_maskz_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_subs_epu16.html" title="fn core::arch::x86_64::_mm_maskz_subs_epu16">_mm_maskz_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm_maskz_ternarylogic_epi32">_mm_maskz_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 32 位粒度的 zeromask k (当未设置相应的掩码位时，32 位元素会被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm_maskz_ternarylogic_epi64">_mm_maskz_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位，使用 64 位粒度的 zeromask k (当未设置相应的掩码位时，64 位元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_epi8">_mm_maskz_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_epi16">_mm_maskz_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_epi32">_mm_maskz_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_epi64">_mm_maskz_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_pd.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_pd">_mm_maskz_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpackhi_ps.html" title="fn core::arch::x86_64::_mm_maskz_unpackhi_ps">_mm_maskz_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_epi8">_mm_maskz_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_epi16">_mm_maskz_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_epi32">_mm_maskz_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_epi64">_mm_maskz_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_pd.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_pd">_mm_maskz_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_unpacklo_ps.html" title="fn core::arch::x86_64::_mm_maskz_unpacklo_ps">_mm_maskz_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">从 a 和 b 中每个 128 位 lane 的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_xor_epi32.html" title="fn core::arch::x86_64::_mm_maskz_xor_epi32">_mm_maskz_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskz_xor_epi64.html" title="fn core::arch::x86_64::_mm_maskz_xor_epi64">_mm_maskz_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epi64.html" title="fn core::arch::x86_64::_mm_max_epi64">_mm_max_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epu64.html" title="fn core::arch::x86_64::_mm_max_epu64">_mm_max_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_round_sd.html" title="fn core::arch::x86_64::_mm_max_round_sd">_mm_max_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最大值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_round_ss.html" title="fn core::arch::x86_64::_mm_max_round_ss">_mm_max_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最大值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epu64.html" title="fn core::arch::x86_64::_mm_min_epu64">_mm_min_epu64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_round_sd.html" title="fn core::arch::x86_64::_mm_min_round_sd">_mm_min_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最小值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_round_ss.html" title="fn core::arch::x86_64::_mm_min_round_ss">_mm_min_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最小值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movepi8_mask.html" title="fn core::arch::x86_64::_mm_movepi8_mask">_mm_movepi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据相应封装的 8 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movepi16_mask.html" title="fn core::arch::x86_64::_mm_movepi16_mask">_mm_movepi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据相应封装的 16 位整数的最高位设置掩码寄存器 k 的每一位 a.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movm_epi8.html" title="fn core::arch::x86_64::_mm_movm_epi8">_mm_movm_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 8 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movm_epi16.html" title="fn core::arch::x86_64::_mm_movm_epi16">_mm_movm_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">根据 dst 中相应位的值，将 dst 中每个包的 16 位整数设置为全 1 或全 0 k.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_round_sd.html" title="fn core::arch::x86_64::_mm_mul_round_sd">_mm_mul_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_round_ss.html" title="fn core::arch::x86_64::_mm_mul_round_ss">_mm_mul_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_multishift_epi64_epi8.html" title="fn core::arch::x86_64::_mm_multishift_epi64_epi8">_mm_multishift_epi64_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_epi32.html" title="fn core::arch::x86_64::_mm_or_epi32">_mm_or_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_epi64.html" title="fn core::arch::x86_64::_mm_or_epi64">_mm_or_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi8.html" title="fn core::arch::x86_64::_mm_permutex2var_epi8">_mm_permutex2var_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨 lanes 打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi16.html" title="fn core::arch::x86_64::_mm_permutex2var_epi16">_mm_permutex2var_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi32.html" title="fn core::arch::x86_64::_mm_permutex2var_epi32">_mm_permutex2var_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用对应的选择器和 idx 中的索引在 lanes 中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_epi64.html" title="fn core::arch::x86_64::_mm_permutex2var_epi64">_mm_permutex2var_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_pd.html" title="fn core::arch::x86_64::_mm_permutex2var_pd">_mm_permutex2var_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutex2var_ps.html" title="fn core::arch::x86_64::_mm_permutex2var_ps">_mm_permutex2var_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应选择器和索引在 lanes 中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutexvar_epi8.html" title="fn core::arch::x86_64::_mm_permutexvar_epi8">_mm_permutexvar_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引将 a 中的 8 位整数打乱到 lanes 中，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutexvar_epi16.html" title="fn core::arch::x86_64::_mm_permutexvar_epi16">_mm_permutexvar_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">使用 idx 中的相应索引在跨 lanes 中对 16 位整数进行打乱，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_popcnt_epi8.html" title="fn core::arch::x86_64::_mm_popcnt_epi8">_mm_popcnt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_popcnt_epi16.html" title="fn core::arch::x86_64::_mm_popcnt_epi16">_mm_popcnt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bitalg,avx512vl` only">(x86 or x86-64) and <code>avx512bitalg,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_popcnt_epi32.html" title="fn core::arch::x86_64::_mm_popcnt_epi32">_mm_popcnt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_popcnt_epi64.html" title="fn core::arch::x86_64::_mm_popcnt_epi64">_mm_popcnt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vpopcntdq,avx512vl` only">(x86 or x86-64) and <code>avx512vpopcntdq,avx512vl</code></span></div><div class="desc docblock-short">对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_pd.html" title="fn core::arch::x86_64::_mm_rcp14_pd">_mm_rcp14_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_ps.html" title="fn core::arch::x86_64::_mm_rcp14_ps">_mm_rcp14_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_sd.html" title="fn core::arch::x86_64::_mm_rcp14_sd">_mm_rcp14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp14_ss.html" title="fn core::arch::x86_64::_mm_rcp14_ss">_mm_rcp14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rol_epi32.html" title="fn core::arch::x86_64::_mm_rol_epi32">_mm_rol_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rol_epi64.html" title="fn core::arch::x86_64::_mm_rol_epi64">_mm_rol_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rolv_epi32.html" title="fn core::arch::x86_64::_mm_rolv_epi32">_mm_rolv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rolv_epi64.html" title="fn core::arch::x86_64::_mm_rolv_epi64">_mm_rolv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ror_epi32.html" title="fn core::arch::x86_64::_mm_ror_epi32">_mm_ror_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ror_epi64.html" title="fn core::arch::x86_64::_mm_ror_epi64">_mm_ror_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rorv_epi32.html" title="fn core::arch::x86_64::_mm_rorv_epi32">_mm_rorv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rorv_epi64.html" title="fn core::arch::x86_64::_mm_rorv_epi64">_mm_rorv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_pd.html" title="fn core::arch::x86_64::_mm_roundscale_pd">_mm_roundscale_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_ps.html" title="fn core::arch::x86_64::_mm_roundscale_ps">_mm_roundscale_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_round_sd.html" title="fn core::arch::x86_64::_mm_roundscale_round_sd">_mm_roundscale_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_round_ss.html" title="fn core::arch::x86_64::_mm_roundscale_round_ss">_mm_roundscale_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_sd.html" title="fn core::arch::x86_64::_mm_roundscale_sd">_mm_roundscale_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_roundscale_ss.html" title="fn core::arch::x86_64::_mm_roundscale_ss">_mm_roundscale_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一：<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC； 请参见 _MM_SET_ROUNDING_MODE</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt14_sd.html" title="fn core::arch::x86_64::_mm_rsqrt14_sd">_mm_rsqrt14_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt14_ss.html" title="fn core::arch::x86_64::_mm_rsqrt14_ss">_mm_rsqrt14_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_pd.html" title="fn core::arch::x86_64::_mm_scalef_pd">_mm_scalef_pd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_ps.html" title="fn core::arch::x86_64::_mm_scalef_ps">_mm_scalef_ps</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_round_sd.html" title="fn core::arch::x86_64::_mm_scalef_round_sd">_mm_scalef_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_round_ss.html" title="fn core::arch::x86_64::_mm_scalef_round_ss">_mm_scalef_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_sd.html" title="fn core::arch::x86_64::_mm_scalef_sd">_mm_scalef_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_scalef_ss.html" title="fn core::arch::x86_64::_mm_scalef_ss">_mm_scalef_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldi_epi16.html" title="fn core::arch::x86_64::_mm_shldi_epi16">_mm_shldi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldi_epi32.html" title="fn core::arch::x86_64::_mm_shldi_epi32">_mm_shldi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldi_epi64.html" title="fn core::arch::x86_64::_mm_shldi_epi64">_mm_shldi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldv_epi16.html" title="fn core::arch::x86_64::_mm_shldv_epi16">_mm_shldv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldv_epi32.html" title="fn core::arch::x86_64::_mm_shldv_epi32">_mm_shldv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shldv_epi64.html" title="fn core::arch::x86_64::_mm_shldv_epi64">_mm_shldv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdi_epi16.html" title="fn core::arch::x86_64::_mm_shrdi_epi16">_mm_shrdi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdi_epi32.html" title="fn core::arch::x86_64::_mm_shrdi_epi32">_mm_shrdi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdi_epi64.html" title="fn core::arch::x86_64::_mm_shrdi_epi64">_mm_shrdi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdv_epi16.html" title="fn core::arch::x86_64::_mm_shrdv_epi16">_mm_shrdv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdv_epi32.html" title="fn core::arch::x86_64::_mm_shrdv_epi32">_mm_shrdv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shrdv_epi64.html" title="fn core::arch::x86_64::_mm_shrdv_epi64">_mm_shrdv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512vbmi2,avx512vl` only">(x86 or x86-64) and <code>avx512vbmi2,avx512vl</code></span></div><div class="desc docblock-short">将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sllv_epi16.html" title="fn core::arch::x86_64::_mm_sllv_epi16">_mm_sllv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_round_sd.html" title="fn core::arch::x86_64::_mm_sqrt_round_sd">_mm_sqrt_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的双精度 (64-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_round_ss.html" title="fn core::arch::x86_64::_mm_sqrt_round_ss">_mm_sqrt_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sra_epi64.html" title="fn core::arch::x86_64::_mm_sra_epi64">_mm_sra_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srai_epi64.html" title="fn core::arch::x86_64::_mm_srai_epi64">_mm_srai_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srav_epi16.html" title="fn core::arch::x86_64::_mm_srav_epi16">_mm_srav_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srav_epi64.html" title="fn core::arch::x86_64::_mm_srav_epi64">_mm_srav_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srlv_epi16.html" title="fn core::arch::x86_64::_mm_srlv_epi16">_mm_srlv_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_epi32.html" title="fn core::arch::x86_64::_mm_store_epi32">_mm_store_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_epi64.html" title="fn core::arch::x86_64::_mm_store_epi64">_mm_store_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi8.html" title="fn core::arch::x86_64::_mm_storeu_epi8">_mm_storeu_epi8</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 16 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi16.html" title="fn core::arch::x86_64::_mm_storeu_epi16">_mm_storeu_epi16</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 8 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi32.html" title="fn core::arch::x86_64::_mm_storeu_epi32">_mm_storeu_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_epi64.html" title="fn core::arch::x86_64::_mm_storeu_epi64">_mm_storeu_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_round_sd.html" title="fn core::arch::x86_64::_mm_sub_round_sd">_mm_sub_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_round_ss.html" title="fn core::arch::x86_64::_mm_sub_round_ss">_mm_sub_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">从 a 中的下部单精度 (32-bit) 浮点元素中减去 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ternarylogic_epi32.html" title="fn core::arch::x86_64::_mm_ternarylogic_epi32">_mm_ternarylogic_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ternarylogic_epi64.html" title="fn core::arch::x86_64::_mm_ternarylogic_epi64">_mm_ternarylogic_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">提供执行任何三操作数二进制函数的功能的按位三元逻辑； 特定的二进制函数由 imm8 中的值指定。对于每个包装的 64 位整数中的每一位，使用 a、b、c 中对应的位构成 imm8 的 3 位索引，并将 imm8 中该位的值写入 dst 中的对应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi8_mask.html" title="fn core::arch::x86_64::_mm_test_epi8_mask">_mm_test_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi16_mask.html" title="fn core::arch::x86_64::_mm_test_epi16_mask">_mm_test_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi32_mask.html" title="fn core::arch::x86_64::_mm_test_epi32_mask">_mm_test_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_epi64_mask.html" title="fn core::arch::x86_64::_mm_test_epi64_mask">_mm_test_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi8_mask.html" title="fn core::arch::x86_64::_mm_testn_epi8_mask">_mm_testn_epi8_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi16_mask.html" title="fn core::arch::x86_64::_mm_testn_epi16_mask">_mm_testn_epi16_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw,avx512vl` only">(x86 or x86-64) and <code>avx512bw,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi32_mask.html" title="fn core::arch::x86_64::_mm_testn_epi32_mask">_mm_testn_epi32_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testn_epi64_mask.html" title="fn core::arch::x86_64::_mm_testn_epi64_mask">_mm_testn_epi64_mask</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_epi32.html" title="fn core::arch::x86_64::_mm_xor_epi32">_mm_xor_epi32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_epi64.html" title="fn core::arch::x86_64::_mm_xor_epi64">_mm_xor_epi64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f,avx512vl` only">(x86 or x86-64) and <code>avx512f,avx512vl</code></span></div><div class="desc docblock-short">计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._store_mask32.html" title="fn core::arch::x86_64::_store_mask32">_store_mask32</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 32 位掩码从 a 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._store_mask64.html" title="fn core::arch::x86_64::_store_mask64">_store_mask64</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512bw` only">(x86 or x86-64) and <code>avx512bw</code></span></div><div class="desc docblock-short">将 64 位掩码从 a 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xabort.html" title="fn core::arch::x86_64::_xabort">_xabort</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rtm` only">(x86 or x86-64) and <code>rtm</code></span></div><div class="desc docblock-short">强制将受限制的事务内存 (RTM) 区域中止。
<a href="https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-xabort">Intel’s documentation</a>.</div></li><li><div class="item-name"><a class="fn" href="fn._xabort_code.html" title="fn core::arch::x86_64::_xabort_code">_xabort_code</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">当 <a href="../x86/fn._xbegin.html" title="fn core::arch::x86::_xbegin"><code>_xbegin</code></a> 的状态设置为 <code>_XABORT_EXPLICIT</code> 标志时，检索传递给 <a href="../x86/fn._xabort.html" title="fn core::arch::x86::_xabort"><code>_xabort</code></a> 的参数。</div></li><li><div class="item-name"><a class="fn" href="fn._xbegin.html" title="fn core::arch::x86_64::_xbegin">_xbegin</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rtm` only">(x86 or x86-64) and <code>rtm</code></span></div><div class="desc docblock-short">指定受限制的事务性存储器 (RTM) 代码区域的开始，并返回一个指示状态的值。</div></li><li><div class="item-name"><a class="fn" href="fn._xend.html" title="fn core::arch::x86_64::_xend">_xend</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rtm` only">(x86 or x86-64) and <code>rtm</code></span></div><div class="desc docblock-short">指定受限制的事务性存储器 (RTM) 代码区域的结尾。
<a href="https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-xend">Intel’s documentation</a>.</div></li><li><div class="item-name"><a class="fn" href="fn._xtest.html" title="fn core::arch::x86_64::_xtest">_xtest</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rtm` only">(x86 or x86-64) and <code>rtm</code></span></div><div class="desc docblock-short">查询处理器是在由受限事务存储器 (RTM) 还是硬件锁定扩展 (HLE) 标识的事务区域中执行。</div></li><li><div class="item-name"><a class="fn" href="fn.has_cpuid.html" title="fn core::arch::x86_64::has_cpuid">has_cpuid</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">主机是否支持 <code>cpuid</code> 指令？</div></li><li><div class="item-name"><a class="fn" href="fn.ud2.html" title="fn core::arch::x86_64::ud2">ud2</a><sup title="unsafe function">⚠</sup><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">生成陷阱指令 <code>UD2</code></div></li><li><div class="item-name"><a class="fn" href="fn._MM_GET_EXCEPTION_MASK.html" title="fn core::arch::x86_64::_MM_GET_EXCEPTION_MASK">_MM_GET_EXCEPTION_MASK</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_GET_EXCEPTION_STATE.html" title="fn core::arch::x86_64::_MM_GET_EXCEPTION_STATE">_MM_GET_EXCEPTION_STATE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_GET_FLUSH_ZERO_MODE.html" title="fn core::arch::x86_64::_MM_GET_FLUSH_ZERO_MODE">_MM_GET_FLUSH_ZERO_MODE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_GET_ROUNDING_MODE.html" title="fn core::arch::x86_64::_MM_GET_ROUNDING_MODE">_MM_GET_ROUNDING_MODE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_SET_EXCEPTION_MASK.html" title="fn core::arch::x86_64::_MM_SET_EXCEPTION_MASK">_MM_SET_EXCEPTION_MASK</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_SET_EXCEPTION_STATE.html" title="fn core::arch::x86_64::_MM_SET_EXCEPTION_STATE">_MM_SET_EXCEPTION_STATE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_SET_FLUSH_ZERO_MODE.html" title="fn core::arch::x86_64::_MM_SET_FLUSH_ZERO_MODE">_MM_SET_FLUSH_ZERO_MODE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_SET_ROUNDING_MODE.html" title="fn core::arch::x86_64::_MM_SET_ROUNDING_MODE">_MM_SET_ROUNDING_MODE</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></div></li><li><div class="item-name"><a class="fn" href="fn._MM_TRANSPOSE4_PS.html" title="fn core::arch::x86_64::_MM_TRANSPOSE4_PS">_MM_TRANSPOSE4_PS</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将由 4 行 __m128 组成的 4x4 矩阵转置到位。</div></li><li><div class="item-name"><a class="fn" href="fn.__cpuid.html" title="fn core::arch::x86_64::__cpuid">__cpuid</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">请参见 <a href="fn.__cpuid_count.html"><code>__cpuid_count</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn.__cpuid_count.html" title="fn core::arch::x86_64::__cpuid_count">__cpuid_count</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回给定 <code>leaf</code> (<code>EAX</code>) 和 <code>sub_leaf</code> (<code>ECX</code>) 的 <code>cpuid</code> 指令的结果。</div></li><li><div class="item-name"><a class="fn" href="fn.__get_cpuid_max.html" title="fn core::arch::x86_64::__get_cpuid_max">__get_cpuid_max</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回最高支持的 <code>leaf</code> (<code>EAX</code>) 和子叶 (<code>ECX</code>) <code>cpuid</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn.__rdtscp.html" title="fn core::arch::x86_64::__rdtscp">__rdtscp</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">读取处理器时间戳计数器和 <code>IA32_TSC_AUX MSR</code> 的当前值。</div></li><li><div class="item-name"><a class="fn" href="fn._addcarry_u32.html" title="fn core::arch::x86_64::_addcarry_u32">_addcarry_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._addcarry_u64.html" title="fn core::arch::x86_64::_addcarry_u64">_addcarry_u64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">将无符号的 64 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位标志) 相加，并将无符号的 64 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._addcarryx_u32.html" title="fn core::arch::x86_64::_addcarryx_u32">_addcarryx_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `adx` only">(x86 or x86-64) and <code>adx</code></span></div><div class="desc docblock-short">将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._addcarryx_u64.html" title="fn core::arch::x86_64::_addcarryx_u64">_addcarryx_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `adx` only"><code>adx</code></span></div><div class="desc docblock-short">将无符号的 64 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位或溢出标志) 相加，并将无符号的 64 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._andn_u32.html" title="fn core::arch::x86_64::_andn_u32">_andn_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 的按位逻辑 <code>AND</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._andn_u64.html" title="fn core::arch::x86_64::_andn_u64">_andn_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 的按位逻辑 <code>AND</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._bextr2_u32.html" title="fn core::arch::x86_64::_bextr2_u32">_bextr2_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">将 <code>control</code> 指定的 <code>a</code> 的位提取到结果的最低有效位中。</div></li><li><div class="item-name"><a class="fn" href="fn._bextr2_u64.html" title="fn core::arch::x86_64::_bextr2_u64">_bextr2_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">将 <code>control</code> 指定的 <code>a</code> 的位提取到结果的最低有效位中。</div></li><li><div class="item-name"><a class="fn" href="fn._bextr_u32.html" title="fn core::arch::x86_64::_bextr_u32">_bextr_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">从 <code>a</code> 提取范围为 [start，<code>start</code> + <code>length</code>) 的位到结果的最低有效位。</div></li><li><div class="item-name"><a class="fn" href="fn._bextr_u64.html" title="fn core::arch::x86_64::_bextr_u64">_bextr_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">从 <code>a</code> 提取范围为 [start，<code>start</code> + <code>length</code>) 的位到结果的最低有效位。</div></li><li><div class="item-name"><a class="fn" href="fn._bittest.html" title="fn core::arch::x86_64::_bittest">_bittest</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位。</div></li><li><div class="item-name"><a class="fn" href="fn._bittest64.html" title="fn core::arch::x86_64::_bittest64">_bittest64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandcomplement.html" title="fn core::arch::x86_64::_bittestandcomplement">_bittestandcomplement</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位取反。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandcomplement64.html" title="fn core::arch::x86_64::_bittestandcomplement64">_bittestandcomplement64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位取反。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandreset.html" title="fn core::arch::x86_64::_bittestandreset">_bittestandreset</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位重置为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandreset64.html" title="fn core::arch::x86_64::_bittestandreset64">_bittestandreset64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位重置为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandset.html" title="fn core::arch::x86_64::_bittestandset">_bittestandset</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位设置为 <code>1</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._bittestandset64.html" title="fn core::arch::x86_64::_bittestandset64">_bittestandset64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位设置为 <code>1</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._blcfill_u32.html" title="fn core::arch::x86_64::_blcfill_u32">_blcfill_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除 <code>x</code> 的最低有效零位以下的所有位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcfill_u64.html" title="fn core::arch::x86_64::_blcfill_u64">_blcfill_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除 <code>x</code> 的最低有效零位以下的所有位。</div></li><li><div class="item-name"><a class="fn" href="fn._blci_u32.html" title="fn core::arch::x86_64::_blci_u32">_blci_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将 <code>x</code> 的所有位 (最低有效零位除外) 设置为 1。</div></li><li><div class="item-name"><a class="fn" href="fn._blci_u64.html" title="fn core::arch::x86_64::_blci_u64">_blci_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将 <code>x</code> 的所有位 (最低有效零位除外) 设置为 1。</div></li><li><div class="item-name"><a class="fn" href="fn._blcic_u32.html" title="fn core::arch::x86_64::_blcic_u32">_blcic_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位并清除所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcic_u64.html" title="fn core::arch::x86_64::_blcic_u64">_blcic_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位并清除所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcmsk_u32.html" title="fn core::arch::x86_64::_blcmsk_u32">_blcmsk_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位，并清除该位上方的所有位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcmsk_u64.html" title="fn core::arch::x86_64::_blcmsk_u64">_blcmsk_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位，并清除该位上方的所有位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcs_u32.html" title="fn core::arch::x86_64::_blcs_u32">_blcs_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位。</div></li><li><div class="item-name"><a class="fn" href="fn._blcs_u64.html" title="fn core::arch::x86_64::_blcs_u64">_blcs_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">设置 <code>x</code> 的最低有效零位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsfill_u32.html" title="fn core::arch::x86_64::_blsfill_u32">_blsfill_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将 <code>x</code> 的所有位设置在最低有效位以下。</div></li><li><div class="item-name"><a class="fn" href="fn._blsfill_u64.html" title="fn core::arch::x86_64::_blsfill_u64">_blsfill_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将 <code>x</code> 的所有位设置在最低有效位以下。</div></li><li><div class="item-name"><a class="fn" href="fn._blsi_u32.html" title="fn core::arch::x86_64::_blsi_u32">_blsi_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">提取最低位隔离位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsi_u64.html" title="fn core::arch::x86_64::_blsi_u64">_blsi_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">提取最低位隔离位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsic_u32.html" title="fn core::arch::x86_64::_blsic_u32">_blsic_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除最低有效位并设置所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsic_u64.html" title="fn core::arch::x86_64::_blsic_u64">_blsic_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除最低有效位并设置所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsmsk_u32.html" title="fn core::arch::x86_64::_blsmsk_u32">_blsmsk_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">将掩码提高到最低设置位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsmsk_u64.html" title="fn core::arch::x86_64::_blsmsk_u64">_blsmsk_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">将掩码提高到最低设置位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsr_u32.html" title="fn core::arch::x86_64::_blsr_u32">_blsr_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">复位 <code>x</code> 的最低位。</div></li><li><div class="item-name"><a class="fn" href="fn._blsr_u64.html" title="fn core::arch::x86_64::_blsr_u64">_blsr_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">复位 <code>x</code> 的最低位。</div></li><li><div class="item-name"><a class="fn" href="fn._bswap.html" title="fn core::arch::x86_64::_bswap">_bswap</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">返回整数，其字节顺序为 x</div></li><li><div class="item-name"><a class="fn" href="fn._bswap64.html" title="fn core::arch::x86_64::_bswap64">_bswap64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">返回整数，其字节顺序为 x</div></li><li><div class="item-name"><a class="fn" href="fn._bzhi_u32.html" title="fn core::arch::x86_64::_bzhi_u32">_bzhi_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi2` only">(x86 or x86-64) and <code>bmi2</code></span></div><div class="desc docblock-short">将 <code>a</code> &gt;= <code>index</code> 的高位清零。</div></li><li><div class="item-name"><a class="fn" href="fn._bzhi_u64.html" title="fn core::arch::x86_64::_bzhi_u64">_bzhi_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi2` only"><code>bmi2</code></span></div><div class="desc docblock-short">将 <code>a</code> &gt;= <code>index</code> 的高位清零。</div></li><li><div class="item-name"><a class="fn" href="fn._fxrstor.html" title="fn core::arch::x86_64::_fxrstor">_fxrstor</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fxsr` only">(x86 or x86-64) and <code>fxsr</code></span></div><div class="desc docblock-short">从以下位置恢复 <code>XMM</code>，<code>MMX</code>，<code>MXCSR</code> 和 <code>x87</code> FPU 寄存器
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._fxrstor64.html" title="fn core::arch::x86_64::_fxrstor64">_fxrstor64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `fxsr` only"><code>fxsr</code></span></div><div class="desc docblock-short">从以下位置恢复 <code>XMM</code>，<code>MMX</code>，<code>MXCSR</code> 和 <code>x87</code> FPU 寄存器
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._fxsave.html" title="fn core::arch::x86_64::_fxsave">_fxsave</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fxsr` only">(x86 or x86-64) and <code>fxsr</code></span></div><div class="desc docblock-short">将 <code>x87</code> FPU，<code>MMX</code> 技术，<code>XMM</code> 和 <code>MXCSR</code> 寄存器保存到
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._fxsave64.html" title="fn core::arch::x86_64::_fxsave64">_fxsave64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `fxsr` only"><code>fxsr</code></span></div><div class="desc docblock-short">将 <code>x87</code> FPU，<code>MMX</code> 技术，<code>XMM</code> 和 <code>MXCSR</code> 寄存器保存到
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._lzcnt_u32.html" title="fn core::arch::x86_64::_lzcnt_u32">_lzcnt_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `lzcnt` only">(x86 or x86-64) and <code>lzcnt</code></span></div><div class="desc docblock-short">计算前导最高有效零位。</div></li><li><div class="item-name"><a class="fn" href="fn._lzcnt_u64.html" title="fn core::arch::x86_64::_lzcnt_u64">_lzcnt_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `lzcnt` only"><code>lzcnt</code></span></div><div class="desc docblock-short">计算前导最高有效零位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_abs_epi8.html" title="fn core::arch::x86_64::_mm256_abs_epi8">_mm256_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 8 位整数的绝对值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_abs_epi16.html" title="fn core::arch::x86_64::_mm256_abs_epi16">_mm256_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 16 位整数的绝对值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_abs_epi32.html" title="fn core::arch::x86_64::_mm256_abs_epi32">_mm256_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 32 位整数的绝对值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_epi8.html" title="fn core::arch::x86_64::_mm256_add_epi8">_mm256_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_epi16.html" title="fn core::arch::x86_64::_mm256_add_epi16">_mm256_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_epi32.html" title="fn core::arch::x86_64::_mm256_add_epi32">_mm256_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_epi64.html" title="fn core::arch::x86_64::_mm256_add_epi64">_mm256_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_pd.html" title="fn core::arch::x86_64::_mm256_add_pd">_mm256_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_add_ps.html" title="fn core::arch::x86_64::_mm256_add_ps">_mm256_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_adds_epi8.html" title="fn core::arch::x86_64::_mm256_adds_epi8">_mm256_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_adds_epi16.html" title="fn core::arch::x86_64::_mm256_adds_epi16">_mm256_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_adds_epu8.html" title="fn core::arch::x86_64::_mm256_adds_epu8">_mm256_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_adds_epu16.html" title="fn core::arch::x86_64::_mm256_adds_epu16">_mm256_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_addsub_pd.html" title="fn core::arch::x86_64::_mm256_addsub_pd">_mm256_addsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">或者，将<code>a</code>中的包装双精度 (64 位) 浮点元素与<code>b</code>中的包装元素进行加减。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_addsub_ps.html" title="fn core::arch::x86_64::_mm256_addsub_ps">_mm256_addsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">或者，将<code>a</code>中的包装的单精度 (32 位) 浮点元素与<code>b</code>中的包装的元素进行加减。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_alignr_epi8.html" title="fn core::arch::x86_64::_mm256_alignr_epi8">_mm256_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 <code>n</code> 字节，然后返回低 16 字节。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_and_pd.html" title="fn core::arch::x86_64::_mm256_and_pd">_mm256_and_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_and_ps.html" title="fn core::arch::x86_64::_mm256_and_ps">_mm256_and_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_and_si256.html" title="fn core::arch::x86_64::_mm256_and_si256">_mm256_and_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (代表整数数据) 的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_andnot_pd.html" title="fn core::arch::x86_64::_mm256_andnot_pd">_mm256_andnot_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的双精度 (64-bit) 浮点元素的按位 NOT，然后计算 <code>b</code> 的 AND。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_andnot_ps.html" title="fn core::arch::x86_64::_mm256_andnot_ps">_mm256_andnot_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的按位非，然后计算 <code>b</code> 的 AND。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_andnot_si256.html" title="fn core::arch::x86_64::_mm256_andnot_si256">_mm256_andnot_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中 256 位 (代表整数数据) 的按位非，然后计算 <code>b</code> 的与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_avg_epu8.html" title="fn core::arch::x86_64::_mm256_avg_epu8">_mm256_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 中的包装无符号 8 位整数的平均值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_avg_epu16.html" title="fn core::arch::x86_64::_mm256_avg_epu16">_mm256_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 中的包装无符号 16 位整数的平均值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blend_epi16.html" title="fn core::arch::x86_64::_mm256_blend_epi16">_mm256_blend_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用控制掩码 <code>IMM8</code> 混合包装来自 <code>a</code> 和 <code>b</code> 的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blend_epi32.html" title="fn core::arch::x86_64::_mm256_blend_epi32">_mm256_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用控制掩码 <code>IMM8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blend_pd.html" title="fn core::arch::x86_64::_mm256_blend_pd">_mm256_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用控制掩码 <code>imm8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装后的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blend_ps.html" title="fn core::arch::x86_64::_mm256_blend_ps">_mm256_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用控制掩码 <code>imm8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blendv_epi8.html" title="fn core::arch::x86_64::_mm256_blendv_epi8">_mm256_blendv_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blendv_pd.html" title="fn core::arch::x86_64::_mm256_blendv_pd">_mm256_blendv_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>c</code> 作为掩码，混合来自 <code>a</code> 和 <code>b</code> 的包装后的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_blendv_ps.html" title="fn core::arch::x86_64::_mm256_blendv_ps">_mm256_blendv_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>c</code> 作为掩码，混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_pd.html" title="fn core::arch::x86_64::_mm256_broadcast_pd">_mm256_broadcast_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将内存中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 广播到返回的 vector 的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_ps.html" title="fn core::arch::x86_64::_mm256_broadcast_ps">_mm256_broadcast_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 向广播的 vector 的所有元素广播 128 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_sd.html" title="fn core::arch::x86_64::_mm256_broadcast_sd">_mm256_broadcast_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存向返回的 vector 的所有元素广播双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcast_ss.html" title="fn core::arch::x86_64::_mm256_broadcast_ss">_mm256_broadcast_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm256_broadcastb_epi8">_mm256_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 8 位整数广播到 256 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm256_broadcastd_epi32">_mm256_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 32 位整数广播到 256 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm256_broadcastq_epi64">_mm256_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 64 位整数广播到 256 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm256_broadcastsd_pd">_mm256_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低双精度 (64-bit) 浮点元素从 <code>a</code> 广播到 256 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastsi128_si256.html" title="fn core::arch::x86_64::_mm256_broadcastsi128_si256">_mm256_broadcastsi128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 a 广播 128 位整数数据到 256 位返回值中的所有 128 位 lanes。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastss_ps.html" title="fn core::arch::x86_64::_mm256_broadcastss_ps">_mm256_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低单精度 (32-bit) 浮点元素从 <code>a</code> 广播到 256 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm256_broadcastw_epi16">_mm256_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低位包装的 16 位整数从 a 广播到 256 位返回值的所有元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_bslli_epi128.html" title="fn core::arch::x86_64::_mm256_bslli_epi128">_mm256_bslli_epi128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 128 位 lanes 向左移 <code>imm8</code> 字节，同时向零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_bsrli_epi128.html" title="fn core::arch::x86_64::_mm256_bsrli_epi128">_mm256_bsrli_epi128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 128 位 lanes 右移 <code>imm8</code> 字节，同时将其移位为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castpd128_pd256.html" title="fn core::arch::x86_64::_mm256_castpd128_pd256">_mm256_castpd128_pd256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型 __m128d 的 vector 转换为 __m256d 类型；
结果的高 128 位未定义。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castpd256_pd128.html" title="fn core::arch::x86_64::_mm256_castpd256_pd128">_mm256_castpd256_pd128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256d 的 vector 强制转换为类型为 __m128d 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castpd_ps.html" title="fn core::arch::x86_64::_mm256_castpd_ps">_mm256_castpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256d 的 vector 强制转换为类型为 __m256 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castpd_si256.html" title="fn core::arch::x86_64::_mm256_castpd_si256">_mm256_castpd_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256d 的 vector 强制转换为类型为 __m256i 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castps128_ps256.html" title="fn core::arch::x86_64::_mm256_castps128_ps256">_mm256_castps128_ps256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型 __m128 的 vector 转换为 __m256 类型；
结果的高 128 位未定义。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castps256_ps128.html" title="fn core::arch::x86_64::_mm256_castps256_ps128">_mm256_castps256_ps128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256 的 vector 强制转换为类型为 __m128 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castps_pd.html" title="fn core::arch::x86_64::_mm256_castps_pd">_mm256_castps_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256 的 vector 强制转换为类型为 __m256d 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castps_si256.html" title="fn core::arch::x86_64::_mm256_castps_si256">_mm256_castps_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256 的 vector 强制转换为类型为 __m256i 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castsi128_si256.html" title="fn core::arch::x86_64::_mm256_castsi128_si256">_mm256_castsi128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m128i 的 vector 强制转换为类型 __m256i；
结果的高 128 位未定义。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castsi256_pd.html" title="fn core::arch::x86_64::_mm256_castsi256_pd">_mm256_castsi256_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256i 的 vector 强制转换为类型为 __m256d 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castsi256_ps.html" title="fn core::arch::x86_64::_mm256_castsi256_ps">_mm256_castsi256_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256i 的 vector 强制转换为类型为 __m256 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_castsi256_si128.html" title="fn core::arch::x86_64::_mm256_castsi256_si128">_mm256_castsi256_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将类型为 __m256i 的 vector 强制转换为类型为 __m128i 的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ceil_pd.html" title="fn core::arch::x86_64::_mm256_ceil_pd">_mm256_ceil_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为正无穷大。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_ceil_ps.html" title="fn core::arch::x86_64::_mm256_ceil_ps">_mm256_ceil_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为正无穷大。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_pd.html" title="fn core::arch::x86_64::_mm256_cmp_pd">_mm256_cmp_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmp_ps.html" title="fn core::arch::x86_64::_mm256_cmp_ps">_mm256_cmp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi8.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi8">_mm256_cmpeq_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 8 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi16.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi16">_mm256_cmpeq_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi32.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi32">_mm256_cmpeq_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 32 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpeq_epi64.html" title="fn core::arch::x86_64::_mm256_cmpeq_epi64">_mm256_cmpeq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi8.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi8">_mm256_cmpgt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi16.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi16">_mm256_cmpgt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi32.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi32">_mm256_cmpgt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cmpgt_epi64.html" title="fn core::arch::x86_64::_mm256_cmpgt_epi64">_mm256_cmpgt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm256_cvtepi8_epi16">_mm256_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 8 位整数符号扩展为 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm256_cvtepi8_epi32">_mm256_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 8 位整数符号扩展为 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepi8_epi64">_mm256_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 8 位整数符号扩展为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm256_cvtepi16_epi32">_mm256_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 16 位整数符号扩展为 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepi16_epi64">_mm256_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 16 位整数符号扩展为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepi32_epi64">_mm256_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 32 位整数符号扩展为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm256_cvtepi32_pd">_mm256_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm256_cvtepi32_ps">_mm256_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm256_cvtepu8_epi16">_mm256_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的无符号 8 位整数零扩展为 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm256_cvtepu8_epi32">_mm256_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的低八位无符号 8 位整数零扩展为 32 位整数。<code>a</code> 的前八个元素未使用。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepu8_epi64">_mm256_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的低四位无符号 8 位整数零扩展到 64 位整数。<code>a</code> 的前十二个元素未使用。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm256_cvtepu16_epi32">_mm256_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 32 位整数，并将结果存储在 <code>dst</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepu16_epi64">_mm256_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的低四位无符号 16 位整数零扩展到 64 位整数。<code>a</code> 的前四个元素未使用。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm256_cvtepu32_epi64">_mm256_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的无符号 32 位整数零扩展为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm256_cvtpd_epi32">_mm256_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtpd_ps.html" title="fn core::arch::x86_64::_mm256_cvtpd_ps">_mm256_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtph_ps.html" title="fn core::arch::x86_64::_mm256_cvtph_ps">_mm256_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `f16c` only">(x86 or x86-64) and <code>f16c</code></span></div><div class="desc docblock-short">将 128 位 vector <code>a</code> 中的 8 x 16 位半精度浮点值转换为存储在 256 位宽 vector 中的 8 x 32 位浮点值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtps_epi32.html" title="fn core::arch::x86_64::_mm256_cvtps_epi32">_mm256_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtps_pd.html" title="fn core::arch::x86_64::_mm256_cvtps_pd">_mm256_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtps_ph.html" title="fn core::arch::x86_64::_mm256_cvtps_ph">_mm256_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `f16c` only">(x86 or x86-64) and <code>f16c</code></span></div><div class="desc docblock-short">将 256 位 vector <code>a</code> 中的 8 x 32 位浮点值转换为 8 x
16 位半精度浮点值存储在 128 位宽的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsd_f64.html" title="fn core::arch::x86_64::_mm256_cvtsd_f64">_mm256_cvtsd_f64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">返回 <code>[4 x double]</code> 的输入 vector 的第一个元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtsi256_si32.html" title="fn core::arch::x86_64::_mm256_cvtsi256_si32">_mm256_cvtsi256_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">返回 <code>[8 x i32]</code> 的输入 vector 的第一个元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvtss_f32.html" title="fn core::arch::x86_64::_mm256_cvtss_f32">_mm256_cvtss_f32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回 <code>[8 x float]</code> 的输入 vector 的第一个元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm256_cvttpd_epi32">_mm256_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_cvttps_epi32.html" title="fn core::arch::x86_64::_mm256_cvttps_epi32">_mm256_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_div_pd.html" title="fn core::arch::x86_64::_mm256_div_pd">_mm256_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中的 4 个包装的 64 位浮点元素中的每一个除以 <code>b</code> 中相应的封装元素的除法。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_div_ps.html" title="fn core::arch::x86_64::_mm256_div_ps">_mm256_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中的 8 个包装的 32 位浮点元素中的每一个除以 <code>b</code> 中相应的封装元素的除法。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_dp_ps.html" title="fn core::arch::x86_64::_mm256_dp_ps">_mm256_dp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 的高 4 位有条件地将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，对四个乘积求和，并使用 <code>imm8</code> 的低 4 位有条件地返回总和。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extract_epi8.html" title="fn core::arch::x86_64::_mm256_extract_epi8">_mm256_extract_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取一个 8 位整数，用 <code>INDEX</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extract_epi16.html" title="fn core::arch::x86_64::_mm256_extract_epi16">_mm256_extract_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取一个 16 位整数，用 <code>INDEX</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extract_epi32.html" title="fn core::arch::x86_64::_mm256_extract_epi32">_mm256_extract_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取一个 32 位整数，用 <code>INDEX</code> 选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extract_epi64.html" title="fn core::arch::x86_64::_mm256_extract_epi64">_mm256_extract_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `avx2` only"><code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取一个 64 位整数，用 <code>INDEX</code> 选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extractf128_pd.html" title="fn core::arch::x86_64::_mm256_extractf128_pd">_mm256_extractf128_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 提取 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并使用 <code>imm8</code> 进行选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extractf128_ps.html" title="fn core::arch::x86_64::_mm256_extractf128_ps">_mm256_extractf128_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 <code>imm8</code> 选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extractf128_si256.html" title="fn core::arch::x86_64::_mm256_extractf128_si256">_mm256_extractf128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取 128 位 (由整数数据组成)，并用 <code>imm8</code> 选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_extracti128_si256.html" title="fn core::arch::x86_64::_mm256_extracti128_si256">_mm256_extracti128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>IMM1</code> 选择的 <code>a</code> 中提取 128 位 (整数数据)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_floor_pd.html" title="fn core::arch::x86_64::_mm256_floor_pd">_mm256_floor_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为负无穷大。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_floor_ps.html" title="fn core::arch::x86_64::_mm256_floor_ps">_mm256_floor_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为负无穷大。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmadd_pd.html" title="fn core::arch::x86_64::_mm256_fmadd_pd">_mm256_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的包装的元素相加。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmadd_ps.html" title="fn core::arch::x86_64::_mm256_fmadd_ps">_mm256_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm256_fmaddsub_pd">_mm256_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 <code>c</code> to/from 中将包装的元素相加或减去中间结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm256_fmaddsub_ps">_mm256_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中包装的元素加/减到中间结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmsub_pd.html" title="fn core::arch::x86_64::_mm256_fmsub_pd">_mm256_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装的双精度元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmsub_ps.html" title="fn core::arch::x86_64::_mm256_fmsub_ps">_mm256_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm256_fmsubadd_pd">_mm256_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 <code>c</code> 中的包装元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm256_fmsubadd_ps">_mm256_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中的包装元素从中间结果中减去或加上。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fnmadd_pd.html" title="fn core::arch::x86_64::_mm256_fnmadd_pd">_mm256_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fnmadd_ps.html" title="fn core::arch::x86_64::_mm256_fnmadd_ps">_mm256_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fnmsub_pd.html" title="fn core::arch::x86_64::_mm256_fnmsub_pd">_mm256_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_fnmsub_ps.html" title="fn core::arch::x86_64::_mm256_fnmsub_ps">_mm256_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hadd_epi16.html" title="fn core::arch::x86_64::_mm256_hadd_epi16">_mm256_hadd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 16 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hadd_epi32.html" title="fn core::arch::x86_64::_mm256_hadd_epi32">_mm256_hadd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 32 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hadd_pd.html" title="fn core::arch::x86_64::_mm256_hadd_pd">_mm256_hadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在 4 个 64 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中水平相加相邻对。
结果，来自 <code>a</code> 的元素之和在偶数位置返回，而来自 <code>b</code> 的元素之和在奇数位置返回。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hadd_ps.html" title="fn core::arch::x86_64::_mm256_hadd_ps">_mm256_hadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在 8 个 32 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中水平相加相邻对。
结果，来自 <code>a</code> 的元素之和返回到索引 0、1、4、5 的位置； 而 <code>b</code> 中的元素总和是位置</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hadds_epi16.html" title="fn core::arch::x86_64::_mm256_hadds_epi16">_mm256_hadds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 16 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hsub_epi16.html" title="fn core::arch::x86_64::_mm256_hsub_epi16">_mm256_hsub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">水平减去 <code>a</code> 和 <code>b</code> 中相邻的 16 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hsub_epi32.html" title="fn core::arch::x86_64::_mm256_hsub_epi32">_mm256_hsub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">水平减去 <code>a</code> 和 <code>b</code> 中相邻的 32 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hsub_pd.html" title="fn core::arch::x86_64::_mm256_hsub_pd">_mm256_hsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在 4 个 64 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中对相邻对进行水平减法。
结果，来自 <code>a</code> 的元素之和在偶数位置返回，而来自 <code>b</code> 的元素之和在奇数位置返回。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hsub_ps.html" title="fn core::arch::x86_64::_mm256_hsub_ps">_mm256_hsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 8 个 32 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中的相邻对进行水平减法。
结果，来自 <code>a</code> 的元素之和返回到索引 0、1、4、5 的位置； 而 <code>b</code> 中的元素总和是位置</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_hsubs_epi16.html" title="fn core::arch::x86_64::_mm256_hsubs_epi16">_mm256_hsubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度水平减去 <code>a</code> 和 <code>b</code> 中相邻的 16 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32gather_epi32.html" title="fn core::arch::x86_64::_mm256_i32gather_epi32">_mm256_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32gather_epi64.html" title="fn core::arch::x86_64::_mm256_i32gather_epi64">_mm256_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32gather_pd.html" title="fn core::arch::x86_64::_mm256_i32gather_pd">_mm256_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i32gather_ps.html" title="fn core::arch::x86_64::_mm256_i32gather_ps">_mm256_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i64gather_epi32.html" title="fn core::arch::x86_64::_mm256_i64gather_epi32">_mm256_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i64gather_epi64.html" title="fn core::arch::x86_64::_mm256_i64gather_epi64">_mm256_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i64gather_pd.html" title="fn core::arch::x86_64::_mm256_i64gather_pd">_mm256_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_i64gather_ps.html" title="fn core::arch::x86_64::_mm256_i64gather_ps">_mm256_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insert_epi8.html" title="fn core::arch::x86_64::_mm256_insert_epi8">_mm256_insert_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">复制 <code>a</code> 到结果，并在 <code>index</code> 指定的位置将 8 位整数 <code>i</code> 插入到结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insert_epi16.html" title="fn core::arch::x86_64::_mm256_insert_epi16">_mm256_insert_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">复制 <code>a</code> 到结果，并在 <code>index</code> 指定的位置将 16 位整数 <code>i</code> 插入到 result 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insert_epi32.html" title="fn core::arch::x86_64::_mm256_insert_epi32">_mm256_insert_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">复制 <code>a</code> 到结果，然后在 <code>index</code> 指定的位置将 32 位整数 <code>i</code> 插入到结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insert_epi64.html" title="fn core::arch::x86_64::_mm256_insert_epi64">_mm256_insert_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `avx` only"><code>avx</code></span></div><div class="desc docblock-short">复制 <code>a</code> 到结果，然后在 <code>index</code> 指定的位置将 64 位整数 <code>i</code> 插入到 result 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insertf128_pd.html" title="fn core::arch::x86_64::_mm256_insertf128_pd">_mm256_insertf128_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 复制到结果中，然后将 <code>b</code> 中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 插入 <code>imm8</code> 指定的位置的结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insertf128_ps.html" title="fn core::arch::x86_64::_mm256_insertf128_ps">_mm256_insertf128_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 复制到结果中，然后将 <code>b</code> 中的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 <code>imm8</code> 指定的位置的结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_insertf128_si256.html" title="fn core::arch::x86_64::_mm256_insertf128_si256">_mm256_insertf128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">复制 <code>a</code> 到结果，然后将 <code>b</code> 中的 128 位插入到 <code>imm8</code> 指定的位置的结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_inserti128_si256.html" title="fn core::arch::x86_64::_mm256_inserti128_si256">_mm256_inserti128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 复制到 <code>dst</code>，然后在 <code>IMM1</code> 指定的位置插入来自 <code>b</code> 的 128 位 (整数数据)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_lddqu_si256.html" title="fn core::arch::x86_64::_mm256_lddqu_si256">_mm256_lddqu_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从未对齐的内存中将 256 位整数数据加载到结果中。
当数据越过高速缓存行边界时，此内部函数的性能可能比 <code>_mm256_loadu_si256</code> 更好。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_pd.html" title="fn core::arch::x86_64::_mm256_load_pd">_mm256_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_ps.html" title="fn core::arch::x86_64::_mm256_load_ps">_mm256_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_load_si256.html" title="fn core::arch::x86_64::_mm256_load_si256">_mm256_load_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位整数数据加载到结果中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu2_m128.html" title="fn core::arch::x86_64::_mm256_loadu2_m128">_mm256_loadu2_m128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">从内存中加载两个 128 位值 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并将它们组合为 256 位值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu2_m128d.html" title="fn core::arch::x86_64::_mm256_loadu2_m128d">_mm256_loadu2_m128d</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">从内存中加载两个 128 位值 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并将它们组合为 256 位值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu2_m128i.html" title="fn core::arch::x86_64::_mm256_loadu2_m128i">_mm256_loadu2_m128i</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">从内存中加载两个 128 位值 (由整数数据组成)，并将它们组合为 256 位值。
<code>hiaddr</code> 和 <code>loaddr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_pd.html" title="fn core::arch::x86_64::_mm256_loadu_pd">_mm256_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_ps.html" title="fn core::arch::x86_64::_mm256_loadu_ps">_mm256_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_loadu_si256.html" title="fn core::arch::x86_64::_mm256_loadu_si256">_mm256_loadu_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存中将 256 位整数数据加载到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_madd_epi16.html" title="fn core::arch::x86_64::_mm256_madd_epi16">_mm256_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的带符号的 16 位整数相乘，产生中间的带符号的 32 位整数。
水平添加相邻的中间 32 位整数对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maddubs_epi16.html" title="fn core::arch::x86_64::_mm256_maddubs_epi16">_mm256_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的每个无符号 8 位整数与 <code>b</code> 中的相应带符号 8 位整数垂直相乘，生成中间带符号的 16 位整数。
水平相加相邻的中间带符号的 16 位整数对</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i32gather_epi32.html" title="fn core::arch::x86_64::_mm256_mask_i32gather_epi32">_mm256_mask_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i32gather_epi64.html" title="fn core::arch::x86_64::_mm256_mask_i32gather_epi64">_mm256_mask_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i32gather_pd.html" title="fn core::arch::x86_64::_mm256_mask_i32gather_pd">_mm256_mask_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i32gather_ps.html" title="fn core::arch::x86_64::_mm256_mask_i32gather_ps">_mm256_mask_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i64gather_epi32.html" title="fn core::arch::x86_64::_mm256_mask_i64gather_epi32">_mm256_mask_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i64gather_epi64.html" title="fn core::arch::x86_64::_mm256_mask_i64gather_epi64">_mm256_mask_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i64gather_pd.html" title="fn core::arch::x86_64::_mm256_mask_i64gather_pd">_mm256_mask_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mask_i64gather_ps.html" title="fn core::arch::x86_64::_mm256_mask_i64gather_ps">_mm256_mask_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskload_epi32.html" title="fn core::arch::x86_64::_mm256_maskload_epi32">_mm256_maskload_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskload_epi64.html" title="fn core::arch::x86_64::_mm256_maskload_epi64">_mm256_maskload_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskload_pd.html" title="fn core::arch::x86_64::_mm256_maskload_pd">_mm256_maskload_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskload_ps.html" title="fn core::arch::x86_64::_mm256_maskload_ps">_mm256_maskload_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskstore_epi32.html" title="fn core::arch::x86_64::_mm256_maskstore_epi32">_mm256_maskstore_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将 <code>a</code> 中的包装后的 32 位整数存储到 <code>mem_addr</code> 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskstore_epi64.html" title="fn core::arch::x86_64::_mm256_maskstore_epi64">_mm256_maskstore_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将 <code>a</code> 中的包装 64 位整数存储到 <code>mem_addr</code> 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskstore_pd.html" title="fn core::arch::x86_64::_mm256_maskstore_pd">_mm256_maskstore_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从 <code>a</code> 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_maskstore_ps.html" title="fn core::arch::x86_64::_mm256_maskstore_ps">_mm256_maskstore_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从 <code>a</code> 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epi8.html" title="fn core::arch::x86_64::_mm256_max_epi8">_mm256_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epi16.html" title="fn core::arch::x86_64::_mm256_max_epi16">_mm256_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epi32.html" title="fn core::arch::x86_64::_mm256_max_epi32">_mm256_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epu8.html" title="fn core::arch::x86_64::_mm256_max_epu8">_mm256_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epu16.html" title="fn core::arch::x86_64::_mm256_max_epu16">_mm256_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_epu32.html" title="fn core::arch::x86_64::_mm256_max_epu32">_mm256_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 32 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_pd.html" title="fn core::arch::x86_64::_mm256_max_pd">_mm256_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最大值</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_max_ps.html" title="fn core::arch::x86_64::_mm256_max_ps">_mm256_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最大值</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epi8.html" title="fn core::arch::x86_64::_mm256_min_epi8">_mm256_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epi16.html" title="fn core::arch::x86_64::_mm256_min_epi16">_mm256_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的 16 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epi32.html" title="fn core::arch::x86_64::_mm256_min_epi32">_mm256_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epu8.html" title="fn core::arch::x86_64::_mm256_min_epu8">_mm256_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epu16.html" title="fn core::arch::x86_64::_mm256_min_epu16">_mm256_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_epu32.html" title="fn core::arch::x86_64::_mm256_min_epu32">_mm256_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 32 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_pd.html" title="fn core::arch::x86_64::_mm256_min_pd">_mm256_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最小值</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_min_ps.html" title="fn core::arch::x86_64::_mm256_min_ps">_mm256_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最小值</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movedup_pd.html" title="fn core::arch::x86_64::_mm256_movedup_pd">_mm256_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 复制偶数索引的双精度 (64-bit) 浮点元素，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movehdup_ps.html" title="fn core::arch::x86_64::_mm256_movehdup_ps">_mm256_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 复制奇数索引的单精度 (32-bit) 浮点元素，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_moveldup_ps.html" title="fn core::arch::x86_64::_mm256_moveldup_ps">_mm256_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 复制偶数索引的单精度 (32-bit) 浮点元素，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movemask_epi8.html" title="fn core::arch::x86_64::_mm256_movemask_epi8">_mm256_movemask_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中每个 8 位元素的最高有效位创建掩码，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movemask_pd.html" title="fn core::arch::x86_64::_mm256_movemask_pd">_mm256_movemask_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">根据 <code>a</code> 中相应的包装的双精度 (64-bit) 浮点元素的最高有效位设置返回掩码的每一位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_movemask_ps.html" title="fn core::arch::x86_64::_mm256_movemask_ps">_mm256_movemask_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">基于 <code>a</code> 中相应的包装单精度 (32-bit) 浮点元素的最高有效位来设置返回掩码的每一位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mpsadbw_epu8.html" title="fn core::arch::x86_64::_mm256_mpsadbw_epu8">_mm256_mpsadbw_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算无符号四元组的绝对差之和 (SADs)
<code>a</code> 中的 8 位整数与 <code>b</code> 中的 8 位整数相比较，并将 16 位结果存储在 dst 中。
使用来自 <code>b</code> 的一个四元组和来自 <code>a</code> 的八个四元组，对每个 128 位 lane 执行八个 SAD。
从 <code>b</code> 中指定的偏移量开始，从 <code>b</code> 中选择一个四元组。
从 <code>a</code> 中选择的有序 8 位整数开始的 8 个四元组，起始于 <code>imm8</code> 中指定的偏移量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mul_epi32.html" title="fn core::arch::x86_64::_mm256_mul_epi32">_mm256_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低位 32 位整数相乘</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mul_epu32.html" title="fn core::arch::x86_64::_mm256_mul_epu32">_mm256_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低位无符号 32 位整数相乘</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mul_pd.html" title="fn core::arch::x86_64::_mm256_mul_pd">_mm256_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mul_ps.html" title="fn core::arch::x86_64::_mm256_mul_ps">_mm256_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mulhi_epi16.html" title="fn core::arch::x86_64::_mm256_mulhi_epi16">_mm256_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的高 16 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mulhi_epu16.html" title="fn core::arch::x86_64::_mm256_mulhi_epu16">_mm256_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并返回中间整数的高 16 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm256_mulhrs_epi16">_mm256_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，生成中间带符号的 32 位整数。
将每个中间整数截断为 18 个最高有效位，再加 1 取整，然后返回 <code>[16:1]</code> 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mullo_epi16.html" title="fn core::arch::x86_64::_mm256_mullo_epi16">_mm256_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的低 16 位</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_mullo_epi32.html" title="fn core::arch::x86_64::_mm256_mullo_epi32">_mm256_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数相乘，生成中间 64 位整数，并返回中间整数的低 32 位</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_pd.html" title="fn core::arch::x86_64::_mm256_or_pd">_mm256_or_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中按位或包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_ps.html" title="fn core::arch::x86_64::_mm256_or_ps">_mm256_or_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中按位或包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_or_si256.html" title="fn core::arch::x86_64::_mm256_or_si256">_mm256_or_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位或</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_packs_epi16.html" title="fn core::arch::x86_64::_mm256_packs_epi16">_mm256_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_packs_epi32.html" title="fn core::arch::x86_64::_mm256_packs_epi32">_mm256_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_packus_epi16.html" title="fn core::arch::x86_64::_mm256_packus_epi16">_mm256_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_packus_epi32.html" title="fn core::arch::x86_64::_mm256_packus_epi32">_mm256_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute2f128_pd.html" title="fn core::arch::x86_64::_mm256_permute2f128_pd">_mm256_permute2f128_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">混洗 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 中选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute2f128_ps.html" title="fn core::arch::x86_64::_mm256_permute2f128_ps">_mm256_permute2f128_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">混洗 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成)，由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 中选择。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute2f128_si256.html" title="fn core::arch::x86_64::_mm256_permute2f128_si256">_mm256_permute2f128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">重排 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 选择的 128 位 (由整数数据组成)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute2x128_si256.html" title="fn core::arch::x86_64::_mm256_permute2x128_si256">_mm256_permute2x128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">打乱由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 选择的 128 位整数数据。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute4x64_epi64.html" title="fn core::arch::x86_64::_mm256_permute4x64_epi64">_mm256_permute4x64_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用控制掩码 <code>imm8</code> 从 <code>a</code> 置换 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute4x64_pd.html" title="fn core::arch::x86_64::_mm256_permute4x64_pd">_mm256_permute4x64_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件对 <code>a</code> 中的 64 位浮点元素进行打乱。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute_pd.html" title="fn core::arch::x86_64::_mm256_permute_pd">_mm256_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件在 128 位 lanes 内对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permute_ps.html" title="fn core::arch::x86_64::_mm256_permute_ps">_mm256_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件在 128 位 lanes 内对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutevar8x32_epi32.html" title="fn core::arch::x86_64::_mm256_permutevar8x32_epi32">_mm256_permutevar8x32_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">根据 <code>b</code> 的内容，对 <code>a</code> 的 32 位整数进行包装的排列。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutevar8x32_ps.html" title="fn core::arch::x86_64::_mm256_permutevar8x32_ps">_mm256_permutevar8x32_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>idx</code> 中相应的 32 位整数索引跨 lanes 打乱 <code>a</code> 中的八个 32 位浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutevar_pd.html" title="fn core::arch::x86_64::_mm256_permutevar_pd">_mm256_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>b</code> 中的控件在 256 位 lanes 内对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_permutevar_ps.html" title="fn core::arch::x86_64::_mm256_permutevar_ps">_mm256_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>b</code> 中的控件在 128 位 lanes 内对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rcp_ps.html" title="fn core::arch::x86_64::_mm256_rcp_ps">_mm256_rcp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数，并返回结果。
该近似值的最大相对误差小于 1.5*2^-12。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_round_pd.html" title="fn core::arch::x86_64::_mm256_round_pd">_mm256_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">根据 <code>ROUNDING</code> 标志对 <code>a</code> 中的双精度 (64-bit) 浮点包装的 (64-bit) 浮点元素进行舍入。
<code>ROUNDING</code> 的值可能如下：</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_round_ps.html" title="fn core::arch::x86_64::_mm256_round_ps">_mm256_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">根据标志 <code>ROUNDING</code> 对 <code>a</code> 中的单精度 (32-bit) 浮点包装元素进行舍入。
<code>ROUNDING</code> 的值可能如下：</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_rsqrt_ps.html" title="fn core::arch::x86_64::_mm256_rsqrt_ps">_mm256_rsqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sad_epu8.html" title="fn core::arch::x86_64::_mm256_sad_epu8">_mm256_sad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平求和，产生四个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位返回值的低 16 位中</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_epi8.html" title="fn core::arch::x86_64::_mm256_set1_epi8">_mm256_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">向返回的 vector 的所有元素广播 8 位整数 <code>a</code>。
此内部函数可能会生成 <code>vpbroadcastb</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_epi16.html" title="fn core::arch::x86_64::_mm256_set1_epi16">_mm256_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 16 位整数 <code>a</code> 广播到返回的 vector 的所有元素。
此内部函数可能会生成 <code>vpbroadcastw</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_epi32.html" title="fn core::arch::x86_64::_mm256_set1_epi32">_mm256_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">向返回的 vector 的所有元素广播 32 位整数 <code>a</code>。
此内部函数可能会生成 <code>vpbroadcastd</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_epi64x.html" title="fn core::arch::x86_64::_mm256_set1_epi64x">_mm256_set1_epi64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">向返回的 vector 的所有元素广播 64 位整数 <code>a</code>。
此内部函数可能会生成 <code>vpbroadcastq</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_pd.html" title="fn core::arch::x86_64::_mm256_set1_pd">_mm256_set1_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">向返回的 vector 的所有元素广播双精度 (64-bit) 浮点值 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set1_ps.html" title="fn core::arch::x86_64::_mm256_set1_ps">_mm256_set1_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">向返回的 vector 的所有元素广播单精度 (32-bit) 浮点值 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_epi8.html" title="fn core::arch::x86_64::_mm256_set_epi8">_mm256_set_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_epi16.html" title="fn core::arch::x86_64::_mm256_set_epi16">_mm256_set_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_epi32.html" title="fn core::arch::x86_64::_mm256_set_epi32">_mm256_set_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_epi64x.html" title="fn core::arch::x86_64::_mm256_set_epi64x">_mm256_set_epi64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_m128.html" title="fn core::arch::x86_64::_mm256_set_m128">_mm256_set_m128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">设置包装的 __m256 返回的 vector 与提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_m128d.html" title="fn core::arch::x86_64::_mm256_set_m128d">_mm256_set_m128d</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">设置包装的 __m256d 返回的 vector 具有提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_m128i.html" title="fn core::arch::x86_64::_mm256_set_m128i">_mm256_set_m128i</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">包装的 __m256i 集合使用提供的值返回 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_pd.html" title="fn core::arch::x86_64::_mm256_set_pd">_mm256_set_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_set_ps.html" title="fn core::arch::x86_64::_mm256_set_ps">_mm256_set_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用提供的值在返回的 vector 中设置包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_epi8.html" title="fn core::arch::x86_64::_mm256_setr_epi8">_mm256_setr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_epi16.html" title="fn core::arch::x86_64::_mm256_setr_epi16">_mm256_setr_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中设置包装的 16 位整数，其提供的值的顺序相反。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_epi32.html" title="fn core::arch::x86_64::_mm256_setr_epi32">_mm256_setr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_epi64x.html" title="fn core::arch::x86_64::_mm256_setr_epi64x">_mm256_setr_epi64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中设置包装的 64 位整数，其提供的值的顺序相反。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_m128.html" title="fn core::arch::x86_64::_mm256_setr_m128">_mm256_setr_m128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">设置包装的 __m256 返回的 vector 与提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_m128d.html" title="fn core::arch::x86_64::_mm256_setr_m128d">_mm256_setr_m128d</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">设置包装的 __m256d 返回的 vector 具有提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_m128i.html" title="fn core::arch::x86_64::_mm256_setr_m128i">_mm256_setr_m128i</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">包装的 __m256i 集合使用提供的值返回 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_pd.html" title="fn core::arch::x86_64::_mm256_setr_pd">_mm256_setr_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中使用反向提供的值设置包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setr_ps.html" title="fn core::arch::x86_64::_mm256_setr_ps">_mm256_setr_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">在返回的 vector 中使用反向提供的值设置包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setzero_pd.html" title="fn core::arch::x86_64::_mm256_setzero_pd">_mm256_setzero_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回 __m256d 类型的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setzero_ps.html" title="fn core::arch::x86_64::_mm256_setzero_ps">_mm256_setzero_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回 __m256 类型的 vector，所有元素都设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_setzero_si256.html" title="fn core::arch::x86_64::_mm256_setzero_si256">_mm256_setzero_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回类型为 __m256i 的 vector，所有元素均设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_epi8.html" title="fn core::arch::x86_64::_mm256_shuffle_epi8">_mm256_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">根据 <code>b</code> 的内容，打乱 <code>a</code> 中的字节。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_epi32.html" title="fn core::arch::x86_64::_mm256_shuffle_epi32">_mm256_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件，在 <code>a</code> 的 128 位 lanes 中打乱 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_pd.html" title="fn core::arch::x86_64::_mm256_shuffle_pd">_mm256_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件对 128 位 lanes 中的双精度 (64-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shuffle_ps.html" title="fn core::arch::x86_64::_mm256_shuffle_ps">_mm256_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的单精度 (32-bit) 浮点元素改组为
使用 <code>imm8</code> 中的控件的 128 位 lanes。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm256_shufflehi_epi16">_mm256_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件，在 <code>a</code> 的 128 位 lanes 的高 64 位中打乱 16 位整数。
<code>a</code> 的 128 位 lanes 的低 64 位被复制到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm256_shufflelo_epi16">_mm256_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件在 <code>a</code> 的 128 位 lanes 的低 64 位中打乱 16 位整数。
<code>a</code> 的 128 位 lanes 的高 64 位被复制到输出中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sign_epi8.html" title="fn core::arch::x86_64::_mm256_sign_epi8">_mm256_sign_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">当相应的带符号时，将 <code>a</code> 中的包装的 8 位整数取反
<code>b</code> 中的 8 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sign_epi16.html" title="fn core::arch::x86_64::_mm256_sign_epi16">_mm256_sign_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">当相应的带符号时，将 <code>a</code> 中的 16 位整数包装为无效
<code>b</code> 中的 16 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sign_epi32.html" title="fn core::arch::x86_64::_mm256_sign_epi32">_mm256_sign_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">当相应的带符号时，将 <code>a</code> 中的包装的 32 位整数取反
<code>b</code> 中的 32 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sll_epi16.html" title="fn core::arch::x86_64::_mm256_sll_epi16">_mm256_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 16 位整数移位，同时移零，并返回结果</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sll_epi32.html" title="fn core::arch::x86_64::_mm256_sll_epi32">_mm256_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 32 位整数移位，同时移零，并返回结果</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sll_epi64.html" title="fn core::arch::x86_64::_mm256_sll_epi64">_mm256_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 64 位整数移位，同时移零，并返回结果</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_slli_epi16.html" title="fn core::arch::x86_64::_mm256_slli_epi16">_mm256_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数在 <code>IMM8</code> 左移同时移零，返回结果；</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_slli_epi32.html" title="fn core::arch::x86_64::_mm256_slli_epi32">_mm256_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数在 <code>IMM8</code> 左移同时移零，返回结果；</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_slli_epi64.html" title="fn core::arch::x86_64::_mm256_slli_epi64">_mm256_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数在 <code>IMM8</code> 左移同时移零，返回结果；</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_slli_si256.html" title="fn core::arch::x86_64::_mm256_slli_si256">_mm256_slli_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 128 位 lanes 向左移 <code>imm8</code> 字节，同时向零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sllv_epi32.html" title="fn core::arch::x86_64::_mm256_sllv_epi32">_mm256_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sllv_epi64.html" title="fn core::arch::x86_64::_mm256_sllv_epi64">_mm256_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sqrt_pd.html" title="fn core::arch::x86_64::_mm256_sqrt_pd">_mm256_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中包装的双精度 (64-bit) 浮点元素的平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sqrt_ps.html" title="fn core::arch::x86_64::_mm256_sqrt_ps">_mm256_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sra_epi16.html" title="fn core::arch::x86_64::_mm256_sra_epi16">_mm256_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将符号位移入时，将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sra_epi32.html" title="fn core::arch::x86_64::_mm256_sra_epi32">_mm256_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将符号位移位时，将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srai_epi16.html" title="fn core::arch::x86_64::_mm256_srai_epi16">_mm256_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srai_epi32.html" title="fn core::arch::x86_64::_mm256_srai_epi32">_mm256_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srav_epi32.html" title="fn core::arch::x86_64::_mm256_srav_epi32">_mm256_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 32 位整数向右移动，移动量由 <code>count</code> 中的相应元素指定，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srl_epi16.html" title="fn core::arch::x86_64::_mm256_srl_epi16">_mm256_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srl_epi32.html" title="fn core::arch::x86_64::_mm256_srl_epi32">_mm256_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srl_epi64.html" title="fn core::arch::x86_64::_mm256_srl_epi64">_mm256_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srli_epi16.html" title="fn core::arch::x86_64::_mm256_srli_epi16">_mm256_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时将其移入零</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srli_epi32.html" title="fn core::arch::x86_64::_mm256_srli_epi32">_mm256_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时将其移入零</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srli_epi64.html" title="fn core::arch::x86_64::_mm256_srli_epi64">_mm256_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 64 位整数右移 <code>IMM8</code>，同时将其移入零</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srli_si256.html" title="fn core::arch::x86_64::_mm256_srli_si256">_mm256_srli_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 128 位 lanes 右移 <code>imm8</code> 字节，同时将其移位为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srlv_epi32.html" title="fn core::arch::x86_64::_mm256_srlv_epi32">_mm256_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_srlv_epi64.html" title="fn core::arch::x86_64::_mm256_srlv_epi64">_mm256_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_pd.html" title="fn core::arch::x86_64::_mm256_store_pd">_mm256_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_ps.html" title="fn core::arch::x86_64::_mm256_store_ps">_mm256_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_store_si256.html" title="fn core::arch::x86_64::_mm256_store_si256">_mm256_store_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位整数数据存储到内存中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一个一般的保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu2_m128.html" title="fn core::arch::x86_64::_mm256_storeu2_m128">_mm256_storeu2_m128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的高和低 128 位半部分 (每个半部分由 4 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu2_m128d.html" title="fn core::arch::x86_64::_mm256_storeu2_m128d">_mm256_storeu2_m128d</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的高和低 128 位半部分 (每个半部分由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu2_m128i.html" title="fn core::arch::x86_64::_mm256_storeu2_m128i">_mm256_storeu2_m128i</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的高 128 位和低 128 位 (分别由整数数据组成) 存储到内存中两个不同的 128 位位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_pd.html" title="fn core::arch::x86_64::_mm256_storeu_pd">_mm256_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_ps.html" title="fn core::arch::x86_64::_mm256_storeu_ps">_mm256_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_storeu_si256.html" title="fn core::arch::x86_64::_mm256_storeu_si256">_mm256_storeu_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 256 位整数数据存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_stream_pd.html" title="fn core::arch::x86_64::_mm256_stream_pd">_mm256_stream_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将双精度值从 <code>[4 x double]</code> 的 256 位 vector 移动到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_stream_ps.html" title="fn core::arch::x86_64::_mm256_stream_ps">_mm256_stream_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将单精度浮点值从 <code>[8 x float]</code> 的 256 位 vector 移到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_stream_si256.html" title="fn core::arch::x86_64::_mm256_stream_si256">_mm256_stream_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将整数数据从 256 位整数 vector 移动到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_epi8.html" title="fn core::arch::x86_64::_mm256_sub_epi8">_mm256_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 8 位整数中减去 <code>b</code> 中的包装的 8 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_epi16.html" title="fn core::arch::x86_64::_mm256_sub_epi16">_mm256_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 16 位整数减去 <code>b</code> 中的包装的 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_epi32.html" title="fn core::arch::x86_64::_mm256_sub_epi32">_mm256_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 32 位整数减去 <code>b</code> 中的包装的 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_epi64.html" title="fn core::arch::x86_64::_mm256_sub_epi64">_mm256_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 64 位整数减去 <code>b</code> 中的包装的 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_pd.html" title="fn core::arch::x86_64::_mm256_sub_pd">_mm256_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的元素中减去 <code>b</code> 中的包装后的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_sub_ps.html" title="fn core::arch::x86_64::_mm256_sub_ps">_mm256_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装元素中减去 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_subs_epi8.html" title="fn core::arch::x86_64::_mm256_subs_epi8">_mm256_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_subs_epi16.html" title="fn core::arch::x86_64::_mm256_subs_epi16">_mm256_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_subs_epu8.html" title="fn core::arch::x86_64::_mm256_subs_epu8">_mm256_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的无符号 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_subs_epu16.html" title="fn core::arch::x86_64::_mm256_subs_epu16">_mm256_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的无符号 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testc_pd.html" title="fn core::arch::x86_64::_mm256_testc_pd">_mm256_testc_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>CF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testc_ps.html" title="fn core::arch::x86_64::_mm256_testc_ps">_mm256_testc_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 32 位元素的符号位都置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>CF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testc_si256.html" title="fn core::arch::x86_64::_mm256_testc_si256">_mm256_testc_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testnzc_pd.html" title="fn core::arch::x86_64::_mm256_testnzc_pd">_mm256_testnzc_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
如果 <code>ZF</code> 和 <code>CF</code> 的值都为零则返回 1，否则返回 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testnzc_ps.html" title="fn core::arch::x86_64::_mm256_testnzc_ps">_mm256_testnzc_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 32 位元素的符号位都置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
如果 <code>ZF</code> 和 <code>CF</code> 的值都为零则返回 1，否则返回 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testnzc_si256.html" title="fn core::arch::x86_64::_mm256_testnzc_si256">_mm256_testnzc_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testz_pd.html" title="fn core::arch::x86_64::_mm256_testz_pd">_mm256_testz_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>ZF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testz_ps.html" title="fn core::arch::x86_64::_mm256_testz_ps">_mm256_testz_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 256 位中间值，如果中间值中每个 32 位元素的符号位都置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>ZF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_testz_si256.html" title="fn core::arch::x86_64::_mm256_testz_si256">_mm256_testz_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_undefined_pd.html" title="fn core::arch::x86_64::_mm256_undefined_pd">_mm256_undefined_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回具有不确定元素的 <code>__m256d</code> 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_undefined_ps.html" title="fn core::arch::x86_64::_mm256_undefined_ps">_mm256_undefined_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回具有不确定元素的 <code>__m256</code> 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_undefined_si256.html" title="fn core::arch::x86_64::_mm256_undefined_si256">_mm256_undefined_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m256i 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm256_unpackhi_epi8">_mm256_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个高位的一半拆包并交织 8 位整数
<code>a</code> 和 <code>b</code> 中的 128 位 lane。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm256_unpackhi_epi16">_mm256_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个高位的一半拆包并交织 16 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm256_unpackhi_epi32">_mm256_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个高位的一半拆包并交织 32 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm256_unpackhi_epi64">_mm256_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个高位的一半拆包并交织 64 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_pd.html" title="fn core::arch::x86_64::_mm256_unpackhi_pd">_mm256_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 中每个 128 位 lane 的上半部分解包并交织双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpackhi_ps.html" title="fn core::arch::x86_64::_mm256_unpackhi_ps">_mm256_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 中每个 128 位 lane 的高半部分解包并交织单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm256_unpacklo_epi8">_mm256_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个低位拆包并交织 8 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm256_unpacklo_epi16">_mm256_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个低位拆包并交织 16 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm256_unpacklo_epi32">_mm256_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个低位拆包并交织 32 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm256_unpacklo_epi64">_mm256_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从每个字节的下半部分拆包并交织 64 位整数
<code>a</code> 和 <code>b</code> 的 128 位 lane</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_pd.html" title="fn core::arch::x86_64::_mm256_unpacklo_pd">_mm256_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 中每个 128 位 lane 的下半部分解包并交织双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_unpacklo_ps.html" title="fn core::arch::x86_64::_mm256_unpacklo_ps">_mm256_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 中每个 128 位 lanes 的下半部分解包并交织单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_pd.html" title="fn core::arch::x86_64::_mm256_xor_pd">_mm256_xor_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位 XOR。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_ps.html" title="fn core::arch::x86_64::_mm256_xor_ps">_mm256_xor_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素的按位 XOR。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_xor_si256.html" title="fn core::arch::x86_64::_mm256_xor_si256">_mm256_xor_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位 XOR</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_zeroall.html" title="fn core::arch::x86_64::_mm256_zeroall">_mm256_zeroall</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将所有 XMM 或 YMM 寄存器的内容清零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_zeroupper.html" title="fn core::arch::x86_64::_mm256_zeroupper">_mm256_zeroupper</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">将所有 YMM 寄存器的高 128 位清零；
寄存器的低 128 位保持不变。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_zextpd128_pd256.html" title="fn core::arch::x86_64::_mm256_zextpd128_pd256">_mm256_zextpd128_pd256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">从 a 创建一个 <code>[4 x double]</code> 的 256 位浮点 vector
<code>[2 x double]</code> 的 128 位浮点 vector。低 128 位包含源 vector 的值。
高 128 位设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_zextps128_ps256.html" title="fn core::arch::x86_64::_mm256_zextps128_ps256">_mm256_zextps128_ps256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">从 a 创建一个 <code>[8 x float]</code> 的 256 位浮点 vector
<code>[4 x float]</code> 的 128 位浮点 vector。低 128 位包含源 vector 的值。
高 128 位设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm256_zextsi128_si256.html" title="fn core::arch::x86_64::_mm256_zextsi128_si256">_mm256_zextsi128_si256</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">从 128 位整数 vector 创建一个 256 位整数 vector。
低 128 位包含源 vector 的值。上层
128 位设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm512_storeu_ps.html" title="fn core::arch::x86_64::_mm512_storeu_ps">_mm512_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx512f` only">(x86 or x86-64) and <code>avx512f</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_abs_epi8.html" title="fn core::arch::x86_64::_mm_abs_epi8">_mm_abs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中包装的 8 位带符号整数的绝对值，并返回无符号结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_abs_epi16.html" title="fn core::arch::x86_64::_mm_abs_epi16">_mm_abs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中每个包装的 16 位有符号整数的绝对值，并返回 16 位无符号整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_abs_epi32.html" title="fn core::arch::x86_64::_mm_abs_epi32">_mm_abs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中每个包装的 32 位有符号整数的绝对值，并返回 32 位无符号整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_epi8.html" title="fn core::arch::x86_64::_mm_add_epi8">_mm_add_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_epi16.html" title="fn core::arch::x86_64::_mm_add_epi16">_mm_add_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_epi32.html" title="fn core::arch::x86_64::_mm_add_epi32">_mm_add_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_epi64.html" title="fn core::arch::x86_64::_mm_add_epi64">_mm_add_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_pd.html" title="fn core::arch::x86_64::_mm_add_pd">_mm_add_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中添加包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_ps.html" title="fn core::arch::x86_64::_mm_add_ps">_mm_add_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">添加 __m128 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_sd.html" title="fn core::arch::x86_64::_mm_add_sd">_mm_add_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素替换为 <code>a</code> 和 <code>b</code> 的低位元素之和。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_add_ss.html" title="fn core::arch::x86_64::_mm_add_ss">_mm_add_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">添加 <code>a</code> 和 <code>b</code> 的第一个组件，其他组件从 <code>a</code> 复制。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_adds_epi8.html" title="fn core::arch::x86_64::_mm_adds_epi8">_mm_adds_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_adds_epi16.html" title="fn core::arch::x86_64::_mm_adds_epi16">_mm_adds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_adds_epu8.html" title="fn core::arch::x86_64::_mm_adds_epu8">_mm_adds_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_adds_epu16.html" title="fn core::arch::x86_64::_mm_adds_epu16">_mm_adds_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_addsub_pd.html" title="fn core::arch::x86_64::_mm_addsub_pd">_mm_addsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">或者，在 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素中加减 <code>b</code> 中的 to/from 包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_addsub_ps.html" title="fn core::arch::x86_64::_mm_addsub_ps">_mm_addsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">或者，在 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素上加减 <code>b</code> 中的包装的元素 to/from。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aesdec_si128.html" title="fn core::arch::x86_64::_mm_aesdec_si128">_mm_aesdec_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">对 <code>a</code> 中的数据 (state) 执行一轮 AES 解密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aesdeclast_si128.html" title="fn core::arch::x86_64::_mm_aesdeclast_si128">_mm_aesdeclast_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">对 <code>a</code> 中的数据 (state) 执行 AES 解密流的最后一轮。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aesenc_si128.html" title="fn core::arch::x86_64::_mm_aesenc_si128">_mm_aesenc_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">对 <code>a</code> 中的数据 (state) 执行一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aesenclast_si128.html" title="fn core::arch::x86_64::_mm_aesenclast_si128">_mm_aesenclast_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">对 <code>a</code> 中的数据 (state) 执行最后一轮 AES 加密流程。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aesimc_si128.html" title="fn core::arch::x86_64::_mm_aesimc_si128">_mm_aesimc_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">在 <code>a</code> 上执行 <code>InvMixColumns</code> 转换。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_aeskeygenassist_si128.html" title="fn core::arch::x86_64::_mm_aeskeygenassist_si128">_mm_aeskeygenassist_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `aes` only">(x86 or x86-64) and <code>aes</code></span></div><div class="desc docblock-short">协助扩展 AES 密钥。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_alignr_epi8.html" title="fn core::arch::x86_64::_mm_alignr_epi8">_mm_alignr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的 16 字节块连接成一个 32 字节的临时结果，将结果右移 <code>n</code> 字节，然后返回低 16 字节。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_and_pd.html" title="fn core::arch::x86_64::_mm_and_pd">_mm_and_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_and_ps.html" title="fn core::arch::x86_64::_mm_and_ps">_mm_and_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">包装的单精度 (32-bit) 浮点元素的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_and_si128.html" title="fn core::arch::x86_64::_mm_and_si128">_mm_and_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_andnot_pd.html" title="fn core::arch::x86_64::_mm_andnot_pd">_mm_andnot_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 的按位 NOT，然后计算 <code>b</code> 的 AND。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_andnot_ps.html" title="fn core::arch::x86_64::_mm_andnot_ps">_mm_andnot_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">包装的单精度 (32-bit) 浮点元素的按位与非运算。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_andnot_si128.html" title="fn core::arch::x86_64::_mm_andnot_si128">_mm_andnot_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 中 128 位 (代表整数数据) 的按位非，然后计算 <code>b</code> 的与。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_avg_epu8.html" title="fn core::arch::x86_64::_mm_avg_epu8">_mm_avg_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 中的包装无符号 8 位整数的平均值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_avg_epu16.html" title="fn core::arch::x86_64::_mm_avg_epu16">_mm_avg_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short"><code>a</code> 和 <code>b</code> 中的包装无符号 16 位整数的平均值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blend_epi16.html" title="fn core::arch::x86_64::_mm_blend_epi16">_mm_blend_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用掩码 <code>IMM8</code> 混合来自 <code>a</code> 和 <code>b</code> 的 16 位整数包装。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blend_epi32.html" title="fn core::arch::x86_64::_mm_blend_epi32">_mm_blend_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用控制掩码 <code>IMM4</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blend_pd.html" title="fn core::arch::x86_64::_mm_blend_pd">_mm_blend_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用控制掩码 <code>IMM2</code> 从 <code>a</code> 和 <code>b</code> 混合包装的双精度 (64-bit) 浮点元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blend_ps.html" title="fn core::arch::x86_64::_mm_blend_ps">_mm_blend_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用掩码 <code>IMM4</code> 从 <code>a</code> 和 <code>b</code> 混合包装的单精度 (32-bit) 浮点元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blendv_epi8.html" title="fn core::arch::x86_64::_mm_blendv_epi8">_mm_blendv_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 混合 <code>a</code> 和 <code>b</code> 中的包装 8 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blendv_pd.html" title="fn core::arch::x86_64::_mm_blendv_pd">_mm_blendv_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的双精度 (64-bit) 浮点元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_blendv_ps.html" title="fn core::arch::x86_64::_mm_blendv_ps">_mm_blendv_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcast_ss.html" title="fn core::arch::x86_64::_mm_broadcast_ss">_mm_broadcast_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastb_epi8.html" title="fn core::arch::x86_64::_mm_broadcastb_epi8">_mm_broadcastb_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 8 位整数广播到 128 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastd_epi32.html" title="fn core::arch::x86_64::_mm_broadcastd_epi32">_mm_broadcastd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 32 位整数广播到 128 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastq_epi64.html" title="fn core::arch::x86_64::_mm_broadcastq_epi64">_mm_broadcastq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的低位包装 64 位整数广播到 128 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastsd_pd.html" title="fn core::arch::x86_64::_mm_broadcastsd_pd">_mm_broadcastsd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低双精度 (64-bit) 浮点元素从 <code>a</code> 广播到 128 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastss_ps.html" title="fn core::arch::x86_64::_mm_broadcastss_ps">_mm_broadcastss_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低单精度 (32-bit) 浮点元素从 <code>a</code> 广播到 128 位返回值的所有元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_broadcastw_epi16.html" title="fn core::arch::x86_64::_mm_broadcastw_epi16">_mm_broadcastw_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将低包装的 16 位整数从 a 广播到 128 位返回值的所有元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_bslli_si128.html" title="fn core::arch::x86_64::_mm_bslli_si128">_mm_bslli_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 左移 <code>IMM8</code> 个字节，同时移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_bsrli_si128.html" title="fn core::arch::x86_64::_mm_bsrli_si128">_mm_bsrli_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 右移 <code>IMM8</code> 个字节，同时移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castpd_ps.html" title="fn core::arch::x86_64::_mm_castpd_ps">_mm_castpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位浮点 vector 转换为 <code>[4 x float]</code> 的 128 位浮点 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castpd_si128.html" title="fn core::arch::x86_64::_mm_castpd_si128">_mm_castpd_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位浮点 vector 转换为 128 位整数 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castps_pd.html" title="fn core::arch::x86_64::_mm_castps_pd">_mm_castps_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[4 x float]</code> 的 128 位浮点 vector 转换为 <code>[2 x double]</code> 的 128 位浮点 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castps_si128.html" title="fn core::arch::x86_64::_mm_castps_si128">_mm_castps_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[4 x float]</code> 的 128 位浮点 vector 转换为 128 位整数 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castsi128_pd.html" title="fn core::arch::x86_64::_mm_castsi128_pd">_mm_castsi128_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 128 位整数 vector 转换为 <code>[2 x double]</code> 的 128 位浮点 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_castsi128_ps.html" title="fn core::arch::x86_64::_mm_castsi128_ps">_mm_castsi128_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 128 位整数 vector 转换为 <code>[4 x float]</code> 的 128 位浮点 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ceil_pd.html" title="fn core::arch::x86_64::_mm_ceil_pd">_mm_ceil_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ceil_ps.html" title="fn core::arch::x86_64::_mm_ceil_ps">_mm_ceil_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ceil_sd.html" title="fn core::arch::x86_64::_mm_ceil_sd">_mm_ceil_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的低位双精度 (64-bit) 浮点型元素四舍五入为整数，将结果作为双精度浮点型元素存入内部函数结果的低位元素，并将 <code>a</code> 中的高位元素复制到内部函数结果的上部元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ceil_ss.html" title="fn core::arch::x86_64::_mm_ceil_ss">_mm_ceil_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素四舍五入为整数，将结果作为单精度浮点元素存储在内部结果的下部元素中，并将高 3 个包装的元素从 <code>a</code> 复制到内在结果的上层要素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_clflush.html" title="fn core::arch::x86_64::_mm_clflush">_mm_clflush</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使高速缓存层次结构中所有级别的包含 <code>p</code> 的高速缓存行失效并刷新。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_clmulepi64_si128.html" title="fn core::arch::x86_64::_mm_clmulepi64_si128">_mm_clmulepi64_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `pclmulqdq` only">(x86 or x86-64) and <code>pclmulqdq</code></span></div><div class="desc docblock-short">在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_pd.html" title="fn core::arch::x86_64::_mm_cmp_pd">_mm_cmp_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ps.html" title="fn core::arch::x86_64::_mm_cmp_ps">_mm_cmp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_sd.html" title="fn core::arch::x86_64::_mm_cmp_sd">_mm_cmp_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数，比较 <code>a</code> 和 <code>b</code> 中的低位双精度浮点元素 (64-bit)，将结果存入返回的 vector 的低位元素，并将 <code>a</code> 的高位元素复制到返回的 vector 的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmp_ss.html" title="fn core::arch::x86_64::_mm_cmp_ss">_mm_cmp_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中的低位单精度 (32-bit) 浮点元素，将结果存储在返回的 vector 的低位元素中，并将高 3 个包装的元素从 <code>a</code> 复制到返回 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi8.html" title="fn core::arch::x86_64::_mm_cmpeq_epi8">_mm_cmpeq_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 8 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi16.html" title="fn core::arch::x86_64::_mm_cmpeq_epi16">_mm_cmpeq_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi32.html" title="fn core::arch::x86_64::_mm_cmpeq_epi32">_mm_cmpeq_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 32 位整数是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_epi64.html" title="fn core::arch::x86_64::_mm_cmpeq_epi64">_mm_cmpeq_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否相等</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_pd.html" title="fn core::arch::x86_64::_mm_cmpeq_pd">_mm_cmpeq_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的相应元素是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_ps.html" title="fn core::arch::x86_64::_mm_cmpeq_ps">_mm_cmpeq_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果输入元素相等，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_sd.html" title="fn core::arch::x86_64::_mm_cmpeq_sd">_mm_cmpeq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的相等比较取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpeq_ss.html" title="fn core::arch::x86_64::_mm_cmpeq_ss">_mm_cmpeq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入中的最低 <code>f32</code> 是否相等。
如果两个输入相等，结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。
结果的高 96 位是 <code>a</code> 的高 96 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestra.html" title="fn core::arch::x86_64::_mm_cmpestra">_mm_cmpestra</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 <code>b</code> 不包含空字符且结果掩码为零，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestrc.html" title="fn core::arch::x86_64::_mm_cmpestrc">_mm_cmpestrc</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果结果掩码非零则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestri.html" title="fn core::arch::x86_64::_mm_cmpestri">_mm_cmpestri</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将包装的字符串 <code>a</code> 和 <code>b</code> 与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回生成的索引。
与 <a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> 相似，但 <a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> 隐式确定 <code>a</code> 和 <code>b</code> 的长度。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestrm.html" title="fn core::arch::x86_64::_mm_cmpestrm">_mm_cmpestrm</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中包装的字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回生成的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestro.html" title="fn core::arch::x86_64::_mm_cmpestro">_mm_cmpestro</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回结果位掩码的位 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestrs.html" title="fn core::arch::x86_64::_mm_cmpestrs">_mm_cmpestrs</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 a 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpestrz.html" title="fn core::arch::x86_64::_mm_cmpestrz">_mm_cmpestrz</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 <code>b</code> 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_pd.html" title="fn core::arch::x86_64::_mm_cmpge_pd">_mm_cmpge_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_ps.html" title="fn core::arch::x86_64::_mm_cmpge_ps">_mm_cmpge_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素大于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_sd.html" title="fn core::arch::x86_64::_mm_cmpge_sd">_mm_cmpge_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素大于或等于的比较所取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpge_ss.html" title="fn core::arch::x86_64::_mm_cmpge_ss">_mm_cmpge_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入的最低 <code>f32</code> 大于或等于。
如果 <code>a.extract(0)</code> 大于或等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi8.html" title="fn core::arch::x86_64::_mm_cmpgt_epi8">_mm_cmpgt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi16.html" title="fn core::arch::x86_64::_mm_cmpgt_epi16">_mm_cmpgt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi32.html" title="fn core::arch::x86_64::_mm_cmpgt_epi32">_mm_cmpgt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_epi64.html" title="fn core::arch::x86_64::_mm_cmpgt_epi64">_mm_cmpgt_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 64 位整数是否大于，返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_pd.html" title="fn core::arch::x86_64::_mm_cmpgt_pd">_mm_cmpgt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_ps.html" title="fn core::arch::x86_64::_mm_cmpgt_ps">_mm_cmpgt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素大于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_sd.html" title="fn core::arch::x86_64::_mm_cmpgt_sd">_mm_cmpgt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素大于的比较所代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpgt_ss.html" title="fn core::arch::x86_64::_mm_cmpgt_ss">_mm_cmpgt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入的最低 <code>f32</code> 大于。
如果 <code>a.extract(0)</code> 大于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistra.html" title="fn core::arch::x86_64::_mm_cmpistra">_mm_cmpistra</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>b</code> 不包含空字符且结果掩码为零，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistrc.html" title="fn core::arch::x86_64::_mm_cmpistrc">_mm_cmpistrc</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件将包装的字符串与 <code>a</code> 和 <code>b</code> 中的隐式长度进行比较，如果结果掩码不为零，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistri.html" title="fn core::arch::x86_64::_mm_cmpistri">_mm_cmpistri</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，并返回生成的索引。
与 <a href="../x86/fn._mm_cmpestri.html" title="fn core::arch::x86::_mm_cmpestri"><code>_mm_cmpestri</code></a> 相似，不同之处在于 <a href="../x86/fn._mm_cmpestri.html" title="fn core::arch::x86::_mm_cmpestri"><code>_mm_cmpestri</code></a> 需要明确指定 <code>a</code> 和 <code>b</code> 的长度。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistrm.html" title="fn core::arch::x86_64::_mm_cmpistrm">_mm_cmpistrm</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装的字符串，并返回生成的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistro.html" title="fn core::arch::x86_64::_mm_cmpistro">_mm_cmpistro</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，并返回结果位掩码的位 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistrs.html" title="fn core::arch::x86_64::_mm_cmpistrs">_mm_cmpistrs</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>a</code> 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpistrz.html" title="fn core::arch::x86_64::_mm_cmpistrz">_mm_cmpistrz</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>b</code> 中的任何字符为空，则返回 <code>1</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_pd.html" title="fn core::arch::x86_64::_mm_cmple_pd">_mm_cmple_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素是否小于等于</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_ps.html" title="fn core::arch::x86_64::_mm_cmple_ps">_mm_cmple_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素小于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_sd.html" title="fn core::arch::x86_64::_mm_cmple_sd">_mm_cmple_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素小于或等于的比较所取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmple_ss.html" title="fn core::arch::x86_64::_mm_cmple_ss">_mm_cmple_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入中的最低 <code>f32</code> 小于或等于。最低的
如果 <code>a.extract(0)</code> 小于或等于 <code>b.extract(0)</code>，则结果的 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。
结果的高 96 位是 <code>a</code> 的高 96 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi8.html" title="fn core::arch::x86_64::_mm_cmplt_epi8">_mm_cmplt_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中小于 8 的包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi16.html" title="fn core::arch::x86_64::_mm_cmplt_epi16">_mm_cmplt_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数小于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_epi32.html" title="fn core::arch::x86_64::_mm_cmplt_epi32">_mm_cmplt_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否小于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_pd.html" title="fn core::arch::x86_64::_mm_cmplt_pd">_mm_cmplt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素小于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_ps.html" title="fn core::arch::x86_64::_mm_cmplt_ps">_mm_cmplt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素小于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_sd.html" title="fn core::arch::x86_64::_mm_cmplt_sd">_mm_cmplt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的小于比较所代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmplt_ss.html" title="fn core::arch::x86_64::_mm_cmplt_ss">_mm_cmplt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入的最低 <code>f32</code> 小于。
如果 <code>a.extract(0)</code> 小于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_pd.html" title="fn core::arch::x86_64::_mm_cmpneq_pd">_mm_cmpneq_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_ps.html" title="fn core::arch::x86_64::_mm_cmpneq_ps">_mm_cmpneq_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果输入元素不相等，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_sd.html" title="fn core::arch::x86_64::_mm_cmpneq_sd">_mm_cmpneq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不相等比较代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpneq_ss.html" title="fn core::arch::x86_64::_mm_cmpneq_ss">_mm_cmpneq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入中最低的 <code>f32</code> 是否不相等。
如果 <code>a.extract(0)</code> 不等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnge_pd.html" title="fn core::arch::x86_64::_mm_cmpnge_pd">_mm_cmpnge_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的相应元素是否不大于或等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnge_ps.html" title="fn core::arch::x86_64::_mm_cmpnge_ps">_mm_cmpnge_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不大于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnge_sd.html" title="fn core::arch::x86_64::_mm_cmpnge_sd">_mm_cmpnge_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不大于等于相等的比较所取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnge_ss.html" title="fn core::arch::x86_64::_mm_cmpnge_ss">_mm_cmpnge_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入中的最低 <code>f32</code>，以得出不大于等于。
如果 <code>a.extract(0)</code> 不大于或等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpngt_pd.html" title="fn core::arch::x86_64::_mm_cmpngt_pd">_mm_cmpngt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中相应元素的不大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpngt_ps.html" title="fn core::arch::x86_64::_mm_cmpngt_ps">_mm_cmpngt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不大于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpngt_sd.html" title="fn core::arch::x86_64::_mm_cmpngt_sd">_mm_cmpngt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不大于比较所代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpngt_ss.html" title="fn core::arch::x86_64::_mm_cmpngt_ss">_mm_cmpngt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入的最低 <code>f32</code>，以得出不大于。
如果 <code>a.extract(0)</code> 不大于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnle_pd.html" title="fn core::arch::x86_64::_mm_cmpnle_pd">_mm_cmpnle_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素是否等于或大于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnle_ps.html" title="fn core::arch::x86_64::_mm_cmpnle_ps">_mm_cmpnle_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不小于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnle_sd.html" title="fn core::arch::x86_64::_mm_cmpnle_sd">_mm_cmpnle_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相等或不小于的比较所取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnle_ss.html" title="fn core::arch::x86_64::_mm_cmpnle_ss">_mm_cmpnle_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入的最低 <code>f32</code> 等于或小于等于。
如果 <code>a.extract(0)</code> 不小于或等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnlt_pd.html" title="fn core::arch::x86_64::_mm_cmpnlt_pd">_mm_cmpnlt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的对应元素不少于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnlt_ps.html" title="fn core::arch::x86_64::_mm_cmpnlt_ps">_mm_cmpnlt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不小于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnlt_sd.html" title="fn core::arch::x86_64::_mm_cmpnlt_sd">_mm_cmpnlt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相当的比较所取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpnlt_ss.html" title="fn core::arch::x86_64::_mm_cmpnlt_ss">_mm_cmpnlt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较两个输入中的最低 <code>f32</code> 不少于。
如果 <code>a.extract(0)</code> 不小于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpord_pd.html" title="fn core::arch::x86_64::_mm_cmpord_pd">_mm_cmpord_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的相应元素以查看 <code>NaN</code> 是否都不是。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpord_ps.html" title="fn core::arch::x86_64::_mm_cmpord_ps">_mm_cmpord_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
返回具有两个可能的位模式之一的四个浮点数。
如果 <code>a</code> 和 <code>b</code> 中的输入元素是有序的 (即，它们都不是 NaN)，则输出 vector 中的元素将为 <code>0xffffffff</code>，否则为 0。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpord_sd.html" title="fn core::arch::x86_64::_mm_cmpord_sd">_mm_cmpord_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素都与 <code>NaN</code> 进行比较的结果所代替。
如果两者都不等于 <code>NaN</code>，则使用 <code>0xFFFFFFFFFFFFFFFF</code>，否则使用 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpord_ss.html" title="fn core::arch::x86_64::_mm_cmpord_ss">_mm_cmpord_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">检查两个输入中最低的 <code>f32</code> 是否已订购。
如果 <code>a.extract(0)</code> 或 <code>b.extract(0)</code> 都不是 NaN，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpunord_pd.html" title="fn core::arch::x86_64::_mm_cmpunord_pd">_mm_cmpunord_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的相应元素，以查看是否为 <code>NaN</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpunord_ps.html" title="fn core::arch::x86_64::_mm_cmpunord_ps">_mm_cmpunord_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
返回具有两个可能的位模式之一的四个浮点数。
如果 <code>a</code> 和 <code>b</code> 中的输入元素无序 (即，至少其中一个是 NaN)，则输出 vector 中的元素将为 <code>0xffffffff</code>，否则为 0。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpunord_sd.html" title="fn core::arch::x86_64::_mm_cmpunord_sd">_mm_cmpunord_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素都与 <code>NaN</code> 进行比较的结果所代替。
如果其中一个等于 <code>NaN</code>，则使用 <code>0xFFFFFFFFFFFFFFFF</code>，否则使用 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cmpunord_ss.html" title="fn core::arch::x86_64::_mm_cmpunord_ss">_mm_cmpunord_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">检查两个输入中最低的 <code>f32</code> 是否无序。
如果 <code>a.extract(0)</code> 或 <code>b.extract(0)</code> 中的任何一个为 NaN，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comieq_sd.html" title="fn core::arch::x86_64::_mm_comieq_sd">_mm_comieq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comieq_ss.html" title="fn core::arch::x86_64::_mm_comieq_ss">_mm_comieq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。如果相等则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comige_sd.html" title="fn core::arch::x86_64::_mm_comige_sd">_mm_comige_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comige_ss.html" title="fn core::arch::x86_64::_mm_comige_ss">_mm_comige_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comigt_sd.html" title="fn core::arch::x86_64::_mm_comigt_sd">_mm_comigt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comigt_ss.html" title="fn core::arch::x86_64::_mm_comigt_ss">_mm_comigt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comile_sd.html" title="fn core::arch::x86_64::_mm_comile_sd">_mm_comile_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否等于或小于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comile_ss.html" title="fn core::arch::x86_64::_mm_comile_ss">_mm_comile_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comilt_sd.html" title="fn core::arch::x86_64::_mm_comilt_sd">_mm_comilt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素小于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comilt_ss.html" title="fn core::arch::x86_64::_mm_comilt_ss">_mm_comilt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comineq_sd.html" title="fn core::arch::x86_64::_mm_comineq_sd">_mm_comineq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的较低元素是否不相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_comineq_ss.html" title="fn core::arch::x86_64::_mm_comineq_ss">_mm_comineq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果它们不相等，则返回 <code>1</code>，否则返回 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_crc32_u8.html" title="fn core::arch::x86_64::_mm_crc32_u8">_mm_crc32_u8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">从 <code>crc</code> 中的初始值开始，返回无符号 8 位整数 <code>v</code> 的累积 CRC32-C 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_crc32_u16.html" title="fn core::arch::x86_64::_mm_crc32_u16">_mm_crc32_u16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">从 <code>crc</code> 中的初始值开始，返回无符号 16 位整数 <code>v</code> 的累积 CRC32-C 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_crc32_u32.html" title="fn core::arch::x86_64::_mm_crc32_u32">_mm_crc32_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.2` only">(x86 or x86-64) and <code>sse4.2</code></span></div><div class="desc docblock-short">从 <code>crc</code> 中的初始值开始，返回无符号 32 位整数 <code>v</code> 的累积 CRC32-C 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_crc32_u64.html" title="fn core::arch::x86_64::_mm_crc32_u64">_mm_crc32_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse4.2` only"><code>sse4.2</code></span></div><div class="desc docblock-short">从 <code>crc</code> 中的初始值开始，返回无符号 64 位整数 <code>v</code> 的累积 CRC32-C 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_si2ss.html" title="fn core::arch::x86_64::_mm_cvt_si2ss">_mm_cvt_si2ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_cvtsi32_ss.html"><code>_mm_cvtsi32_ss</code></a> 的别名。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvt_ss2si.html" title="fn core::arch::x86_64::_mm_cvt_ss2si">_mm_cvt_ss2si</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_cvtss_si32.html"><code>_mm_cvtss_si32</code></a> 的别名。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi8_epi16.html" title="fn core::arch::x86_64::_mm_cvtepi8_epi16">_mm_cvtepi8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 中的包装 8 位整数扩展为包装 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi8_epi32.html" title="fn core::arch::x86_64::_mm_cvtepi8_epi32">_mm_cvtepi8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 中的包装 8 位整数扩展为包装 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi8_epi64.html" title="fn core::arch::x86_64::_mm_cvtepi8_epi64">_mm_cvtepi8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 的低 8 字节中的包装的 8 位整数扩展为包装的
64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi16_epi32.html" title="fn core::arch::x86_64::_mm_cvtepi16_epi32">_mm_cvtepi16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 中的包装的 16 位整数扩展为包装的 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi16_epi64.html" title="fn core::arch::x86_64::_mm_cvtepi16_epi64">_mm_cvtepi16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 中的包装 16 位整数扩展为包装 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_epi64.html" title="fn core::arch::x86_64::_mm_cvtepi32_epi64">_mm_cvtepi32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">符号将 <code>a</code> 中的包装 32 位整数扩展为包装 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_pd.html" title="fn core::arch::x86_64::_mm_cvtepi32_pd">_mm_cvtepi32_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的低位两个包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepi32_ps.html" title="fn core::arch::x86_64::_mm_cvtepi32_ps">_mm_cvtepi32_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu8_epi16.html" title="fn core::arch::x86_64::_mm_cvtepu8_epi16">_mm_cvtepu8_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装的无符号 8 位整数扩展为包装的 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu8_epi32.html" title="fn core::arch::x86_64::_mm_cvtepu8_epi32">_mm_cvtepu8_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装无符号 8 位整数扩展为包装 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu8_epi64.html" title="fn core::arch::x86_64::_mm_cvtepu8_epi64">_mm_cvtepu8_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装无符号 8 位整数扩展为包装 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu16_epi32.html" title="fn core::arch::x86_64::_mm_cvtepu16_epi32">_mm_cvtepu16_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu16_epi64.html" title="fn core::arch::x86_64::_mm_cvtepu16_epi64">_mm_cvtepu16_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtepu32_epi64.html" title="fn core::arch::x86_64::_mm_cvtepu32_epi64">_mm_cvtepu32_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">零将 <code>a</code> 中的包装无符号 32 位整数扩展为包装 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtpd_epi32.html" title="fn core::arch::x86_64::_mm_cvtpd_epi32">_mm_cvtpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtpd_ps.html" title="fn core::arch::x86_64::_mm_cvtpd_ps">_mm_cvtpd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtph_ps.html" title="fn core::arch::x86_64::_mm_cvtph_ps">_mm_cvtph_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `f16c` only">(x86 or x86-64) and <code>f16c</code></span></div><div class="desc docblock-short">将 128 位 vector <code>a</code> 的最低 64 位中的 4 x 16 位半精度浮点值转换为存储在 128 位宽的 vector 中的 4 x 32 位浮点值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtps_epi32.html" title="fn core::arch::x86_64::_mm_cvtps_epi32">_mm_cvtps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtps_pd.html" title="fn core::arch::x86_64::_mm_cvtps_pd">_mm_cvtps_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtps_ph.html" title="fn core::arch::x86_64::_mm_cvtps_ph">_mm_cvtps_ph</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `f16c` only">(x86 or x86-64) and <code>f16c</code></span></div><div class="desc docblock-short">将 128 位 vector <code>a</code> 中的 4 x 32 位浮点值转换为 4 x
16 位半精度浮点值存储在 128 位 vector 的最低 64 位中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_f64.html" title="fn core::arch::x86_64::_mm_cvtsd_f64">_mm_cvtsd_f64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的较低的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_si32.html" title="fn core::arch::x86_64::_mm_cvtsd_si32">_mm_cvtsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_si64.html" title="fn core::arch::x86_64::_mm_cvtsd_si64">_mm_cvtsd_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">将 a 中的较低双精度 (64-bit) 浮点元素转换为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_si64x.html" title="fn core::arch::x86_64::_mm_cvtsd_si64x">_mm_cvtsd_si64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short"><code>_mm_cvtsd_si64</code> 的别名</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsd_ss.html" title="fn core::arch::x86_64::_mm_cvtsd_ss">_mm_cvtsd_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在返回值的下部元素中，并将上部元素从 <code>a</code> 复制到返回值的上部元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi32_sd.html" title="fn core::arch::x86_64::_mm_cvtsi32_sd">_mm_cvtsi32_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的下位元素转换为 <code>f64</code> 后，返回其下位元素为 <code>b</code> 的 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi32_si128.html" title="fn core::arch::x86_64::_mm_cvtsi32_si128">_mm_cvtsi32_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 vector，其最低元素为 <code>a</code>，所有更高元素为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi32_ss.html" title="fn core::arch::x86_64::_mm_cvtsi32_ss">_mm_cvtsi32_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 32 位整数转换为 32 位浮点型。
结果 vector 是输入 vector <code>a</code>，其最低 32 位浮点数已由转换后的整数替换。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi64_sd.html" title="fn core::arch::x86_64::_mm_cvtsi64_sd">_mm_cvtsi64_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的下位元素转换为 <code>f64</code> 后，返回其下位元素为 <code>b</code> 的 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi64_si128.html" title="fn core::arch::x86_64::_mm_cvtsi64_si128">_mm_cvtsi64_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">返回 vector，其最低元素为 <code>a</code>，所有更高元素为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi64_ss.html" title="fn core::arch::x86_64::_mm_cvtsi64_ss">_mm_cvtsi64_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse` only"><code>sse</code></span></div><div class="desc docblock-short">将 64 位整数转换为 32 位浮点型。
结果 vector 是输入 vector <code>a</code>，其最低 32 位浮点数已由转换后的整数替换。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi64x_sd.html" title="fn core::arch::x86_64::_mm_cvtsi64x_sd">_mm_cvtsi64x_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的下位元素转换为 <code>f64</code> 后，返回其下位元素为 <code>b</code> 的 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi64x_si128.html" title="fn core::arch::x86_64::_mm_cvtsi64x_si128">_mm_cvtsi64x_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">返回 vector，其最低元素为 <code>a</code>，所有更高元素为 <code>0</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi128_si32.html" title="fn core::arch::x86_64::_mm_cvtsi128_si32">_mm_cvtsi128_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的最低元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi128_si64.html" title="fn core::arch::x86_64::_mm_cvtsi128_si64">_mm_cvtsi128_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的最低元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtsi128_si64x.html" title="fn core::arch::x86_64::_mm_cvtsi128_si64x">_mm_cvtsi128_si64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的最低元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_f32.html" title="fn core::arch::x86_64::_mm_cvtss_f32">_mm_cvtss_f32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从输入 vector 中提取最低的 32 位浮点数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_sd.html" title="fn core::arch::x86_64::_mm_cvtss_sd">_mm_cvtss_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在返回值的下部元素中，然后将 <code>a</code> 的上部元素复制到返回值的上部元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_si32.html" title="fn core::arch::x86_64::_mm_cvtss_si32">_mm_cvtss_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将输入 vector 中的最低 32 位浮点型转换为 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtss_si64.html" title="fn core::arch::x86_64::_mm_cvtss_si64">_mm_cvtss_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse` only"><code>sse</code></span></div><div class="desc docblock-short">将输入 vector 中的最低 32 位浮点型转换为 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvtt_ss2si.html" title="fn core::arch::x86_64::_mm_cvtt_ss2si">_mm_cvtt_ss2si</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_cvttss_si32.html"><code>_mm_cvttss_si32</code></a> 的别名。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttpd_epi32.html" title="fn core::arch::x86_64::_mm_cvttpd_epi32">_mm_cvttpd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttps_epi32.html" title="fn core::arch::x86_64::_mm_cvttps_epi32">_mm_cvttps_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_si32.html" title="fn core::arch::x86_64::_mm_cvttsd_si32">_mm_cvttsd_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中较低的双精度 (64-bit) 浮点元素转换为带截断的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_si64.html" title="fn core::arch::x86_64::_mm_cvttsd_si64">_mm_cvttsd_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中较低的双精度 (64-bit) 浮点元素转换为带截断的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttsd_si64x.html" title="fn core::arch::x86_64::_mm_cvttsd_si64x">_mm_cvttsd_si64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short"><code>_mm_cvttsd_si64</code> 的别名</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_si32.html" title="fn core::arch::x86_64::_mm_cvttss_si32">_mm_cvttss_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将输入 vector 中的最低 32 位浮点型转换为带有截断的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_cvttss_si64.html" title="fn core::arch::x86_64::_mm_cvttss_si64">_mm_cvttss_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse` only"><code>sse</code></span></div><div class="desc docblock-short">将输入 vector 中的最低 32 位浮点型转换为带截断的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_pd.html" title="fn core::arch::x86_64::_mm_div_pd">_mm_div_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素除以 <code>b</code> 中的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_ps.html" title="fn core::arch::x86_64::_mm_div_ps">_mm_div_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">除 __m128 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_sd.html" title="fn core::arch::x86_64::_mm_div_sd">_mm_div_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的下限元素被 <code>a</code> 的下限元素除以 <code>b</code> 的下限元素所代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_div_ss.html" title="fn core::arch::x86_64::_mm_div_ss">_mm_div_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>b</code> 的第一个组件除以 <code>a</code>，其他组件则从 <code>a</code> 复制。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dp_pd.html" title="fn core::arch::x86_64::_mm_dp_pd">_mm_dp_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">返回两个 __m128d vectors 的点积。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_dp_ps.html" title="fn core::arch::x86_64::_mm_dp_ps">_mm_dp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">返回两个 __m128 vectors 的点积。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_epi8.html" title="fn core::arch::x86_64::_mm_extract_epi8">_mm_extract_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">从 <code>a</code> 中提取一个 8 位整数，用 <code>IMM8</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_epi16.html" title="fn core::arch::x86_64::_mm_extract_epi16">_mm_extract_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的 <code>imm8</code> 元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_epi32.html" title="fn core::arch::x86_64::_mm_extract_epi32">_mm_extract_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">从 <code>IMM8</code> 选择的 <code>a</code> 中提取 32 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_epi64.html" title="fn core::arch::x86_64::_mm_extract_epi64">_mm_extract_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="desc docblock-short">从 <code>IMM1</code> 选择的 <code>a</code> 中提取 64 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_ps.html" title="fn core::arch::x86_64::_mm_extract_ps">_mm_extract_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">从用 <code>IMM8</code> 选择的 <code>a</code> 中提取单精度 (32-bit) 浮点元素。
返回的 <code>i32</code> 存储浮点数的位模式，并且可以通过转换将其转换回浮点数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_extract_si64.html" title="fn core::arch::x86_64::_mm_extract_si64">_mm_extract_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4a` only">(x86 or x86-64) and <code>sse4a</code></span></div><div class="desc docblock-short">从 <code>x</code> 的低 64 位提取 <code>y</code> 指定的位范围。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_floor_pd.html" title="fn core::arch::x86_64::_mm_floor_pd">_mm_floor_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_floor_ps.html" title="fn core::arch::x86_64::_mm_floor_ps">_mm_floor_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_floor_sd.html" title="fn core::arch::x86_64::_mm_floor_sd">_mm_floor_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的下部双精度 (64-bit) 浮点元素四舍五入为整数值，将结果作为双精度浮点元素存储在内部结果的下部元素中，并将上部元素从 <code>a</code> 复制到上部内在结果的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_floor_ss.html" title="fn core::arch::x86_64::_mm_floor_ss">_mm_floor_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素四舍五入为整数值，将结果作为单精度浮点元素存储在内部结果的下部元素中，然后将 <code>a</code> 的上部 3 个包装的元素复制到内在结果的上层要素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_pd.html" title="fn core::arch::x86_64::_mm_fmadd_pd">_mm_fmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的包装的元素相加。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_ps.html" title="fn core::arch::x86_64::_mm_fmadd_ps">_mm_fmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_sd.html" title="fn core::arch::x86_64::_mm_fmadd_sd">_mm_fmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的较低的元素相加。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmadd_ss.html" title="fn core::arch::x86_64::_mm_fmadd_ss">_mm_fmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的较低元素相加。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmaddsub_pd.html" title="fn core::arch::x86_64::_mm_fmaddsub_pd">_mm_fmaddsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 <code>c</code> to/from 中将包装的元素相加或减去中间结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmaddsub_ps.html" title="fn core::arch::x86_64::_mm_fmaddsub_ps">_mm_fmaddsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中包装的元素加/减到中间结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_pd.html" title="fn core::arch::x86_64::_mm_fmsub_pd">_mm_fmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装的双精度元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_ps.html" title="fn core::arch::x86_64::_mm_fmsub_ps">_mm_fmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_sd.html" title="fn core::arch::x86_64::_mm_fmsub_sd">_mm_fmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的较低的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的较低的元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsub_ss.html" title="fn core::arch::x86_64::_mm_fmsub_ss">_mm_fmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的较低单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的较低元素。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsubadd_pd.html" title="fn core::arch::x86_64::_mm_fmsubadd_pd">_mm_fmsubadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 <code>c</code> 中的包装元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fmsubadd_ps.html" title="fn core::arch::x86_64::_mm_fmsubadd_ps">_mm_fmsubadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中的包装元素从中间结果中减去或加上。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_pd.html" title="fn core::arch::x86_64::_mm_fnmadd_pd">_mm_fnmadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_ps.html" title="fn core::arch::x86_64::_mm_fnmadd_ps">_mm_fnmadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的包装元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_sd.html" title="fn core::arch::x86_64::_mm_fnmadd_sd">_mm_fnmadd_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中较低的双精度 (64-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的较低元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmadd_ss.html" title="fn core::arch::x86_64::_mm_fnmadd_ss">_mm_fnmadd_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，并将取反的中间结果与 <code>c</code> 中的较低元素相加。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_pd.html" title="fn core::arch::x86_64::_mm_fnmsub_pd">_mm_fnmsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_ps.html" title="fn core::arch::x86_64::_mm_fnmsub_ps">_mm_fnmsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_sd.html" title="fn core::arch::x86_64::_mm_fnmsub_sd">_mm_fnmsub_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中较低的双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 <code>c</code> 中的包装的元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_fnmsub_ss.html" title="fn core::arch::x86_64::_mm_fnmsub_ss">_mm_fnmsub_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `fma` only">(x86 or x86-64) and <code>fma</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 <code>c</code> 中的包装元素。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_getcsr.html" title="fn core::arch::x86_64::_mm_getcsr">_mm_getcsr</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">获取 MXCSR 控制和状态寄存器的无符号 32 位值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hadd_epi16.html" title="fn core::arch::x86_64::_mm_hadd_epi16">_mm_hadd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平相加 2 个包装的包中包含的相邻值对
<code>[8 x i16]</code> 的 128 位 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hadd_epi32.html" title="fn core::arch::x86_64::_mm_hadd_epi32">_mm_hadd_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平相加 2 个包装的包中包含的相邻值对
<code>[4 x i32]</code> 的 128 位 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hadd_pd.html" title="fn core::arch::x86_64::_mm_hadd_pd">_mm_hadd_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的双精度 (64-bit) 浮点元素，并包装结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hadd_ps.html" title="fn core::arch::x86_64::_mm_hadd_ps">_mm_hadd_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hadds_epi16.html" title="fn core::arch::x86_64::_mm_hadds_epi16">_mm_hadds_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平相加 2 个包装的包中包含的相邻值对
<code>[8 x i16]</code> 的 128 位 vectors。大于 7FFFh 的正和饱和到 7FFFh。
小于 8000h 的负数和将饱和到 8000h。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hsub_epi16.html" title="fn core::arch::x86_64::_mm_hsub_epi16">_mm_hsub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平减去 <code>[8 x i16]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hsub_epi32.html" title="fn core::arch::x86_64::_mm_hsub_epi32">_mm_hsub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平减去 <code>[4 x i32]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hsub_pd.html" title="fn core::arch::x86_64::_mm_hsub_pd">_mm_hsub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">水平减去 <code>a</code> 和 <code>b</code> 中相邻的双精度 (64-bit) 浮点元素对，然后包装结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hsub_ps.html" title="fn core::arch::x86_64::_mm_hsub_ps">_mm_hsub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_hsubs_epi16.html" title="fn core::arch::x86_64::_mm_hsubs_epi16">_mm_hsubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">水平减去 <code>[8 x i16]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。
正差异大于
7FFFh 饱和到 7FFFh。小于 8000h 的负差会饱和到 8000h。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i32gather_epi32.html" title="fn core::arch::x86_64::_mm_i32gather_epi32">_mm_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i32gather_epi64.html" title="fn core::arch::x86_64::_mm_i32gather_epi64">_mm_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i32gather_pd.html" title="fn core::arch::x86_64::_mm_i32gather_pd">_mm_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i32gather_ps.html" title="fn core::arch::x86_64::_mm_i32gather_ps">_mm_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i64gather_epi32.html" title="fn core::arch::x86_64::_mm_i64gather_epi32">_mm_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i64gather_epi64.html" title="fn core::arch::x86_64::_mm_i64gather_epi64">_mm_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i64gather_pd.html" title="fn core::arch::x86_64::_mm_i64gather_pd">_mm_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_i64gather_ps.html" title="fn core::arch::x86_64::_mm_i64gather_ps">_mm_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_epi8.html" title="fn core::arch::x86_64::_mm_insert_epi8">_mm_insert_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的副本，其中 <code>i</code> 的 8 位整数插入到 <code>IMM8</code> 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_epi16.html" title="fn core::arch::x86_64::_mm_insert_epi16">_mm_insert_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的 <code>imm8</code> 元素替换为 <code>i</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_epi32.html" title="fn core::arch::x86_64::_mm_insert_epi32">_mm_insert_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的副本，其中 <code>i</code> 的 32 位整数插入到 <code>IMM8</code> 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_epi64.html" title="fn core::arch::x86_64::_mm_insert_epi64">_mm_insert_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse4.1` only"><code>sse4.1</code></span></div><div class="desc docblock-short">返回 <code>a</code> 的副本，其中 <code>i</code> 的 64 位整数插入到 <code>IMM1</code> 指定的位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_ps.html" title="fn core::arch::x86_64::_mm_insert_ps">_mm_insert_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">在 <code>a</code> 中选择单个值存储在 <code>b</code> 中的某个位置，然后根据 <code>IMM8</code> 将元素归零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_insert_si64.html" title="fn core::arch::x86_64::_mm_insert_si64">_mm_insert_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4a` only">(x86 or x86-64) and <code>sse4a</code></span></div><div class="desc docblock-short">将 <code>y</code> 的 <code>[length:0]</code> 位插入 <code>index</code> 处的 <code>x</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_lddqu_si128.html" title="fn core::arch::x86_64::_mm_lddqu_si128">_mm_lddqu_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">从未对齐的内存中加载 128 位整数数据。
当数据越过高速缓存行边界时，此内部函数的性能可能比 <code>_mm_loadu_si128</code> 更好。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_lfence.html" title="fn core::arch::x86_64::_mm_lfence">_mm_lfence</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">对在此指令之前发布的所有内存加载指令执行序列化操作。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load1_pd.html" title="fn core::arch::x86_64::_mm_load1_pd">_mm_load1_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load1_ps.html" title="fn core::arch::x86_64::_mm_load1_ps">_mm_load1_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">通过将从 <code>p</code> 读取的值复制到所有元素中来构造 <code>__m128</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_pd.html" title="fn core::arch::x86_64::_mm_load_pd">_mm_load_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_pd1.html" title="fn core::arch::x86_64::_mm_load_pd1">_mm_load_pd1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_ps.html" title="fn core::arch::x86_64::_mm_load_ps">_mm_load_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <em>aligned</em> 内存中的四个 <code>f32</code> 值加载到 <code>__m128</code> 中。
如果指针未与 128 位边界 (16 个字节) 对齐，则将触发一般保护错误 (致命程序崩溃)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_ps1.html" title="fn core::arch::x86_64::_mm_load_ps1">_mm_load_ps1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_load1_ps.html"><code>_mm_load1_ps</code></a> 的别名</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_sd.html" title="fn core::arch::x86_64::_mm_load_sd">_mm_load_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 64 位双精度值加载到
128 位整数 vector 并清除高位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_si128.html" title="fn core::arch::x86_64::_mm_load_si128">_mm_load_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从内存中将 128 位整数数据加载到新的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_load_ss.html" title="fn core::arch::x86_64::_mm_load_ss">_mm_load_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">使用从 <code>p</code> 读取的最低元素并将其他元素设置为零来构造 <code>__m128</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loaddup_pd.html" title="fn core::arch::x86_64::_mm_loaddup_pd">_mm_loaddup_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">将内存中的双精度 (64-bit) 浮点元素加载到返回 vector 的两个元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadh_pd.html" title="fn core::arch::x86_64::_mm_loadh_pd">_mm_loadh_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将双精度值加载到 <code>[2 x double]</code> 的 128 位 vector 的高阶位中。
低位从第一个操作数的低位复制而来。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadl_epi64.html" title="fn core::arch::x86_64::_mm_loadl_epi64">_mm_loadl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将内存中的 64 位整数加载到返回的 vector 的第一个元素中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadl_pd.html" title="fn core::arch::x86_64::_mm_loadl_pd">_mm_loadl_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将双精度值加载到 <code>[2 x double]</code> 的 128 位 vector 的低位中。
高阶位是从第一个操作数的高阶位复制而来的。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadr_pd.html" title="fn core::arch::x86_64::_mm_loadr_pd">_mm_loadr_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">以相反的顺序将 2 个双精度 (64-bit) 浮点元素从内存加载到返回的 vector 中。
<code>mem_addr</code> 必须对齐在一个
可能会生成 16 字节边界或一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadr_ps.html" title="fn core::arch::x86_64::_mm_loadr_ps">_mm_loadr_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从对齐的内存中以相反的顺序将四个 <code>f32</code> 值加载到 <code>__m128</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_pd.html" title="fn core::arch::x86_64::_mm_loadu_pd">_mm_loadu_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_ps.html" title="fn core::arch::x86_64::_mm_loadu_ps">_mm_loadu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从内存中将四个 <code>f32</code> 值加载到 <code>__m128</code> 中。内存对齐没有任何限制。
对于对齐的内存
<a href="fn._mm_load_ps.html"><code>_mm_load_ps</code></a>
可能更快。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_si64.html" title="fn core::arch::x86_64::_mm_loadu_si64">_mm_loadu_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将未对齐的 64 位整数数据从内存加载到新的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_loadu_si128.html" title="fn core::arch::x86_64::_mm_loadu_si128">_mm_loadu_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从内存中将 128 位整数数据加载到新的 vector 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_madd_epi16.html" title="fn core::arch::x86_64::_mm_madd_epi16">_mm_madd_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在 <code>a</code> 和 <code>b</code> 中相乘，然后水平相加带符号的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maddubs_epi16.html" title="fn core::arch::x86_64::_mm_maddubs_epi16">_mm_maddubs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">将第一个源操作数中包含的包装的 8 位无符号整数值与第二个源操作数中包含的包装的 8 位有符号整数值的对应对相乘，相加具有符号饱和度的连续乘积对，并将 16 位和写入到目标中的相应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i32gather_epi32.html" title="fn core::arch::x86_64::_mm_mask_i32gather_epi32">_mm_mask_i32gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i32gather_epi64.html" title="fn core::arch::x86_64::_mm_mask_i32gather_epi64">_mm_mask_i32gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i32gather_pd.html" title="fn core::arch::x86_64::_mm_mask_i32gather_pd">_mm_mask_i32gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i32gather_ps.html" title="fn core::arch::x86_64::_mm_mask_i32gather_ps">_mm_mask_i32gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i64gather_epi32.html" title="fn core::arch::x86_64::_mm_mask_i64gather_epi32">_mm_mask_i64gather_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i64gather_epi64.html" title="fn core::arch::x86_64::_mm_mask_i64gather_epi64">_mm_mask_i64gather_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i64gather_pd.html" title="fn core::arch::x86_64::_mm_mask_i64gather_pd">_mm_mask_i64gather_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mask_i64gather_ps.html" title="fn core::arch::x86_64::_mm_mask_i64gather_ps">_mm_mask_i64gather_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">从 <code>offsets * scale</code> 确定的偏移处返回 <code>slice</code> 的值，其中 <code>scale</code> 应为 1、2、4 或 8.
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskload_epi32.html" title="fn core::arch::x86_64::_mm_maskload_epi32">_mm_maskload_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskload_epi64.html" title="fn core::arch::x86_64::_mm_maskload_epi64">_mm_maskload_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskload_pd.html" title="fn core::arch::x86_64::_mm_maskload_pd">_mm_maskload_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskload_ps.html" title="fn core::arch::x86_64::_mm_maskload_ps">_mm_maskload_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskmoveu_si128.html" title="fn core::arch::x86_64::_mm_maskmoveu_si128">_mm_maskmoveu_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 有条件地将 <code>a</code> 中的 8 位整数元素存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskstore_epi32.html" title="fn core::arch::x86_64::_mm_maskstore_epi32">_mm_maskstore_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将 <code>a</code> 中的包装后的 32 位整数存储到 <code>mem_addr</code> 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskstore_epi64.html" title="fn core::arch::x86_64::_mm_maskstore_epi64">_mm_maskstore_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将 <code>a</code> 中的包装 64 位整数存储到 <code>mem_addr</code> 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskstore_pd.html" title="fn core::arch::x86_64::_mm_maskstore_pd">_mm_maskstore_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从 <code>a</code> 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_maskstore_ps.html" title="fn core::arch::x86_64::_mm_maskstore_ps">_mm_maskstore_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从 <code>a</code> 存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epi8.html" title="fn core::arch::x86_64::_mm_max_epi8">_mm_max_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并以 dst 返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epi16.html" title="fn core::arch::x86_64::_mm_max_epi16">_mm_max_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epi32.html" title="fn core::arch::x86_64::_mm_max_epi32">_mm_max_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epu8.html" title="fn core::arch::x86_64::_mm_max_epu8">_mm_max_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epu16.html" title="fn core::arch::x86_64::_mm_max_epu16">_mm_max_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_epu32.html" title="fn core::arch::x86_64::_mm_max_epu32">_mm_max_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装无符号 32 位整数，并返回包装最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_pd.html" title="fn core::arch::x86_64::_mm_max_pd">_mm_max_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，它具有 <code>a</code> 和 <code>b</code> 中相应元素的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_ps.html" title="fn core::arch::x86_64::_mm_max_ps">_mm_max_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素，并返回相应的最大值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_sd.html" title="fn core::arch::x86_64::_mm_max_sd">_mm_max_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素最大值取代。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_max_ss.html" title="fn core::arch::x86_64::_mm_max_ss">_mm_max_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最大值，从 <code>a</code> 复制其他元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mfence.html" title="fn core::arch::x86_64::_mm_mfence">_mm_mfence</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">对在此指令之前发布的所有从内存加载和存储到内存指令执行序列化操作。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epi8.html" title="fn core::arch::x86_64::_mm_min_epi8">_mm_min_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并以 dst 返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epi16.html" title="fn core::arch::x86_64::_mm_min_epi16">_mm_min_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的 16 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epi32.html" title="fn core::arch::x86_64::_mm_min_epi32">_mm_min_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epu8.html" title="fn core::arch::x86_64::_mm_min_epu8">_mm_min_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epu16.html" title="fn core::arch::x86_64::_mm_min_epu16">_mm_min_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 16 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_epu32.html" title="fn core::arch::x86_64::_mm_min_epu32">_mm_min_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 32 位整数，并返回包装的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_pd.html" title="fn core::arch::x86_64::_mm_min_pd">_mm_min_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，它具有 <code>a</code> 和 <code>b</code> 中相应元素的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_ps.html" title="fn core::arch::x86_64::_mm_min_ps">_mm_min_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素，并返回相应的最小值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_sd.html" title="fn core::arch::x86_64::_mm_min_sd">_mm_min_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的最小值替换。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_min_ss.html" title="fn core::arch::x86_64::_mm_min_ss">_mm_min_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最小值，从 <code>a</code> 复制其他元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_minpos_epu16.html" title="fn core::arch::x86_64::_mm_minpos_epu16">_mm_minpos_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">在 128 位 __m128i vector 中查找最小的无符号 16 位元素，并返回一个 vector，其中在第一个位置包含其值，在第二个位置包含其索引； 所有其他元素都设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_move_epi64.html" title="fn core::arch::x86_64::_mm_move_epi64">_mm_move_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 vector，其中从 <code>a</code> 提取低位元素，其高位元素为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_move_sd.html" title="fn core::arch::x86_64::_mm_move_sd">_mm_move_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">构造 <code>[2 x double]</code> 的 128 位浮点 vector。下层
将 64 位设置为第二个参数的低 64 位。上层
将 64 位设置为第一个参数的高 64 位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_move_ss.html" title="fn core::arch::x86_64::_mm_move_ss">_mm_move_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>__m128</code>，其中第一个组件来自 <code>b</code>，其余组件来自 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movedup_pd.html" title="fn core::arch::x86_64::_mm_movedup_pd">_mm_movedup_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short">从 <code>a</code> 复制低双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movehdup_ps.html" title="fn core::arch::x86_64::_mm_movehdup_ps">_mm_movehdup_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short"><code>a</code> 中重复的奇数索引单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movehl_ps.html" title="fn core::arch::x86_64::_mm_movehl_ps">_mm_movehl_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">合并 <code>a</code> 和 <code>b</code> 的上半部分。<code>b</code> 的高半部分占据结果的低半部分。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_moveldup_ps.html" title="fn core::arch::x86_64::_mm_moveldup_ps">_mm_moveldup_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse3` only">(x86 or x86-64) and <code>sse3</code></span></div><div class="desc docblock-short"><code>a</code> 中重复的偶数索引单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movelh_ps.html" title="fn core::arch::x86_64::_mm_movelh_ps">_mm_movelh_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">合并 <code>a</code> 和 <code>b</code> 的下半部分。<code>b</code> 的下半部分占据结果的上半部分。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movemask_epi8.html" title="fn core::arch::x86_64::_mm_movemask_epi8">_mm_movemask_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中每个元素的最高有效位的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movemask_pd.html" title="fn core::arch::x86_64::_mm_movemask_pd">_mm_movemask_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中每个元素的最高有效位的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_movemask_ps.html" title="fn core::arch::x86_64::_mm_movemask_ps">_mm_movemask_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中每个元素的最高有效位的掩码。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mpsadbw_epu8.html" title="fn core::arch::x86_64::_mm_mpsadbw_epu8">_mm_mpsadbw_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">减去 8 位无符号整数值，然后将差的绝对值计算为目标中的相应位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_epi32.html" title="fn core::arch::x86_64::_mm_mul_epi32">_mm_mul_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低 32 位整数相乘，并返回带符号的 64 位结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_epu32.html" title="fn core::arch::x86_64::_mm_mul_epu32">_mm_mul_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素中的低 32 位无符号整数相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_pd.html" title="fn core::arch::x86_64::_mm_mul_pd">_mm_mul_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_ps.html" title="fn core::arch::x86_64::_mm_mul_ps">_mm_mul_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">乘以 __m128 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_sd.html" title="fn core::arch::x86_64::_mm_mul_sd">_mm_mul_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mul_ss.html" title="fn core::arch::x86_64::_mm_mul_ss">_mm_mul_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 的第一个组件相乘，然后从 <code>a</code> 复制其他组件。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mulhi_epi16.html" title="fn core::arch::x86_64::_mm_mulhi_epi16">_mm_mulhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mulhi_epu16.html" title="fn core::arch::x86_64::_mm_mulhi_epu16">_mm_mulhi_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mulhrs_epi16.html" title="fn core::arch::x86_64::_mm_mulhrs_epi16">_mm_mulhrs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">将包装的 16 位带符号整数值相乘，通过右移将 32 位乘积截断为 18 个最高有效位，通过加 1 舍入舍入后的值，并将 <code>[16:1]</code> 位写入目标位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mullo_epi16.html" title="fn core::arch::x86_64::_mm_mullo_epi16">_mm_mullo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_mullo_epi32.html" title="fn core::arch::x86_64::_mm_mullo_epi32">_mm_mullo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">将 <code>a</code> 和 <code>b</code> 中包装的 32 位整数相乘，产生中间值
64 位整数，并返回最低的 32 位 (无论它们是什么)，都将重新解释为有符号整数。
虽然 <code>pmulld __m128i::splat(2), __m128i::splat(2)</code> 返回明显的 <code>__m128i::splat(4)</code>，但由于包装算术，<code>pmulld __m128i::splat(i32::MAX), __m128i::splat(2)</code> 将返回负数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_pd.html" title="fn core::arch::x86_64::_mm_or_pd">_mm_or_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 的按位或。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_ps.html" title="fn core::arch::x86_64::_mm_or_ps">_mm_or_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">包装的单精度 (32-bit) 浮点元素的按位或。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_or_si128.html" title="fn core::arch::x86_64::_mm_or_si128">_mm_or_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位或。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_packs_epi16.html" title="fn core::arch::x86_64::_mm_packs_epi16">_mm_packs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_packs_epi32.html" title="fn core::arch::x86_64::_mm_packs_epi32">_mm_packs_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用带符号的饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_packus_epi16.html" title="fn core::arch::x86_64::_mm_packus_epi16">_mm_packus_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用无符号饱和度将 <code>a</code> 和 <code>b</code> 的包装的 16 位整数转换为包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_packus_epi32.html" title="fn core::arch::x86_64::_mm_packus_epi32">_mm_packus_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用无符号饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</div></li><li><div class="item-name"><a class="fn" href="fn._mm_pause.html" title="fn core::arch::x86_64::_mm_pause">_mm_pause</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">向处理器提示代码序列是自旋等待循环。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permute_pd.html" title="fn core::arch::x86_64::_mm_permute_pd">_mm_permute_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse2` only">(x86 or x86-64) and <code>avx,sse2</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permute_ps.html" title="fn core::arch::x86_64::_mm_permute_ps">_mm_permute_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx,sse` only">(x86 or x86-64) and <code>avx,sse</code></span></div><div class="desc docblock-short">使用 <code>imm8</code> 中的控件对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutevar_pd.html" title="fn core::arch::x86_64::_mm_permutevar_pd">_mm_permutevar_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>b</code> 中的控件对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_permutevar_ps.html" title="fn core::arch::x86_64::_mm_permutevar_ps">_mm_permutevar_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">使用 <code>b</code> 中的控件对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_prefetch.html" title="fn core::arch::x86_64::_mm_prefetch">_mm_prefetch</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">使用给定的 <code>STRATEGY</code> 获取包含地址 <code>p</code> 的缓存行。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp_ps.html" title="fn core::arch::x86_64::_mm_rcp_ps">_mm_rcp_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rcp_ss.html" title="fn core::arch::x86_64::_mm_rcp_ss">_mm_rcp_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的近似倒数，其他元素不变。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_round_pd.html" title="fn core::arch::x86_64::_mm_round_pd">_mm_round_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>ROUNDING</code> 参数将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素舍入，并将结果存储为包装的双精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_round_ps.html" title="fn core::arch::x86_64::_mm_round_ps">_mm_round_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>ROUNDING</code> 参数将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素舍入，并将结果存储为包装的单精度浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_round_sd.html" title="fn core::arch::x86_64::_mm_round_sd">_mm_round_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>ROUNDING</code> 参数将 <code>b</code> 中的低位双精度浮点元素 (64-bit) 舍入，将结果作为双精度浮点元素存储在内部结果的低位元素中，并将高位元素从 <code>a</code> 复制到高位元素的内在结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_round_ss.html" title="fn core::arch::x86_64::_mm_round_ss">_mm_round_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">使用 <code>ROUNDING</code> 参数对 <code>b</code> 中的低位单精度 (32-bit) 浮点元素进行舍入，将结果作为单精度浮点元素存储在内部函数结果的低位元素中，并从 <code>a</code> 复制高位 3 个包装元素到内部函数结果的上层元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt_ps.html" title="fn core::arch::x86_64::_mm_rsqrt_ps">_mm_rsqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_rsqrt_ss.html" title="fn core::arch::x86_64::_mm_rsqrt_ss">_mm_rsqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的近似倒数平方根，其他元素不变。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sad_epu8.html" title="fn core::arch::x86_64::_mm_sad_epu8">_mm_sad_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">包装无符号 8 位整数的绝对差之和。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_epi8.html" title="fn core::arch::x86_64::_mm_set1_epi8">_mm_set1_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向所有元素广播 8 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_epi16.html" title="fn core::arch::x86_64::_mm_set1_epi16">_mm_set1_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向所有元素广播 16 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_epi32.html" title="fn core::arch::x86_64::_mm_set1_epi32">_mm_set1_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向所有元素广播 32 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_epi64x.html" title="fn core::arch::x86_64::_mm_set1_epi64x">_mm_set1_epi64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向所有元素广播 64 位整数 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_pd.html" title="fn core::arch::x86_64::_mm_set1_pd">_mm_set1_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向返回值的所有元素广播双精度 (64-bit) 浮点值 a。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set1_ps.html" title="fn core::arch::x86_64::_mm_set1_ps">_mm_set1_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">创建一个 <code>__m128</code>，并将所有元素设置为 <code>a</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_epi8.html" title="fn core::arch::x86_64::_mm_set_epi8">_mm_set_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用提供的值设置包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_epi16.html" title="fn core::arch::x86_64::_mm_set_epi16">_mm_set_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用提供的值设置包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_epi32.html" title="fn core::arch::x86_64::_mm_set_epi32">_mm_set_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用提供的值设置包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_epi64x.html" title="fn core::arch::x86_64::_mm_set_epi64x">_mm_set_epi64x</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用提供的值 (从最高到最低) 设置包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_pd.html" title="fn core::arch::x86_64::_mm_set_pd">_mm_set_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用提供的值在返回值中设置包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_pd1.html" title="fn core::arch::x86_64::_mm_set_pd1">_mm_set_pd1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">向返回值的所有元素广播双精度 (64-bit) 浮点值 a。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_ps.html" title="fn core::arch::x86_64::_mm_set_ps">_mm_set_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从最高到最低的四个浮点值构造 <code>__m128</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_ps1.html" title="fn core::arch::x86_64::_mm_set_ps1">_mm_set_ps1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_set1_ps.html"><code>_mm_set1_ps</code></a> 的别名</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_sd.html" title="fn core::arch::x86_64::_mm_set_sd">_mm_set_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将双精度 (64-bit) 浮点元素 <code>a</code> 复制到包装的 64 位返回值的低位元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_set_ss.html" title="fn core::arch::x86_64::_mm_set_ss">_mm_set_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">创建一个 <code>__m128</code>，将最低元素设置为 <code>a</code>，将剩余部分设置为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setcsr.html" title="fn core::arch::x86_64::_mm_setcsr">_mm_setcsr</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">用 32 位无符号整数值设置 MXCSR 寄存器。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setr_epi8.html" title="fn core::arch::x86_64::_mm_setr_epi8">_mm_setr_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">以相反的顺序设置提供的值的包装 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setr_epi16.html" title="fn core::arch::x86_64::_mm_setr_epi16">_mm_setr_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">以相反的顺序设置提供的值的包装 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setr_epi32.html" title="fn core::arch::x86_64::_mm_setr_epi32">_mm_setr_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">以相反的顺序设置提供的值的包装 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setr_pd.html" title="fn core::arch::x86_64::_mm_setr_pd">_mm_setr_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">在返回值中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供提供的值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setr_ps.html" title="fn core::arch::x86_64::_mm_setr_ps">_mm_setr_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从四个最低到最高的浮点值构造 <code>__m128</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setzero_pd.html" title="fn core::arch::x86_64::_mm_setzero_pd">_mm_setzero_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回全零的包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setzero_ps.html" title="fn core::arch::x86_64::_mm_setzero_ps">_mm_setzero_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">创建一个 <code>__m128</code>，并将所有元素初始化为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_setzero_si128.html" title="fn core::arch::x86_64::_mm_setzero_si128">_mm_setzero_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回所有元素均设置为零的 vector。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sfence.html" title="fn core::arch::x86_64::_mm_sfence">_mm_sfence</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">对在此指令之前发出的所有存储到内存指令执行序列化操作。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha1msg1_epu32.html" title="fn core::arch::x86_64::_mm_sha1msg1_epu32">_mm_sha1msg1_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用来自 <code>a</code> 和 <code>b</code> 的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha1msg2_epu32.html" title="fn core::arch::x86_64::_mm_sha1msg2_epu32">_mm_sha1msg2_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用 <code>a</code> 中的中间结果和 <code>b</code> 中的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha1nexte_epu32.html" title="fn core::arch::x86_64::_mm_sha1nexte_epu32">_mm_sha1nexte_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">经过四轮运算后，从当前 SHA1 状态变量 <code>a</code> 计算 SHA1 状态变量 E，将该值添加到 <code>b</code> 中的计划值 (无符号 32 位整数)，然后返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha1rnds4_epu32.html" title="fn core::arch::x86_64::_mm_sha1rnds4_epu32">_mm_sha1rnds4_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用来自 <code>a</code> 的初始 SHA1 状态 (A,B,C,D) 以及接下来的 4 个回合消息值 (一些无符号的 32 位整数) 和来自 <code>b</code> 的状态变量 E 的一些预先计算的总和，执行四轮 SHA1 操作，并返回更新的 SHA1 状态 (A,B,C,D)。
<code>FUNC</code> 包含逻辑函数和圆常量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha256msg1_epu32.html" title="fn core::arch::x86_64::_mm_sha256msg1_epu32">_mm_sha256msg1_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用来自 <code>a</code> 和 <code>b</code> 的先前消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha256msg2_epu32.html" title="fn core::arch::x86_64::_mm_sha256msg2_epu32">_mm_sha256msg2_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用以前的 <code>a</code> 和 <code>b</code> 的消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sha256rnds2_epu32.html" title="fn core::arch::x86_64::_mm_sha256rnds2_epu32">_mm_sha256rnds2_epu32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sha` only">(x86 or x86-64) and <code>sha</code></span></div><div class="desc docblock-short">使用来自 <code>a</code> 的初始 SHA256 状态 (C,D,G,H)，来自 <code>b</code> 的初始 SHA256 状态 (A,B,E,F) 以及接下来的 2 个回合消息值 (无符号的 32 位整数) 和来自 <code>k</code> 的相应回合常量的预先计算的总和，执行 2 轮 SHA256 操作。，并将更新的 SHA256 状态 (A,B,E,F) 存储在 dst 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shuffle_epi8.html" title="fn core::arch::x86_64::_mm_shuffle_epi8">_mm_shuffle_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">根据 <code>b</code> 的内容，打乱 <code>a</code> 中的字节。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shuffle_epi32.html" title="fn core::arch::x86_64::_mm_shuffle_epi32">_mm_shuffle_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件在 <code>a</code> 中打乱 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shuffle_pd.html" title="fn core::arch::x86_64::_mm_shuffle_pd">_mm_shuffle_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从两个创建一个 <code>[2 x double]</code> 的 128 位浮点 vector
<code>[2 x double]</code> 的 128 位 vector 参数，使用立即值参数作为说明符。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shuffle_ps.html" title="fn core::arch::x86_64::_mm_shuffle_ps">_mm_shuffle_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">使用 <code>MASK</code> 在 <code>a</code> 和 <code>b</code> 中打乱包装的单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shufflehi_epi16.html" title="fn core::arch::x86_64::_mm_shufflehi_epi16">_mm_shufflehi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件在 <code>a</code> 的高 64 位中打乱 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_shufflelo_epi16.html" title="fn core::arch::x86_64::_mm_shufflelo_epi16">_mm_shufflelo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用 <code>IMM8</code> 中的控件在 <code>a</code> 的低 64 位中打乱 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sign_epi8.html" title="fn core::arch::x86_64::_mm_sign_epi8">_mm_sign_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">当 <code>b</code> 中相应的带符号 8 位整数为负时，对 <code>a</code> 中的 8 位包装整数取反，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sign_epi16.html" title="fn core::arch::x86_64::_mm_sign_epi16">_mm_sign_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">当 <code>b</code> 中相应的带符号 16 位整数为负时，将 <code>a</code> 中的 16 位整数包装为无效，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sign_epi32.html" title="fn core::arch::x86_64::_mm_sign_epi32">_mm_sign_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `ssse3` only">(x86 or x86-64) and <code>ssse3</code></span></div><div class="desc docblock-short">当 <code>b</code> 中相应的带符号 32 位整数为负时，对 <code>a</code> 中的包装 32 位整数求反，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sll_epi16.html" title="fn core::arch::x86_64::_mm_sll_epi16">_mm_sll_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 16 位整数移位，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sll_epi32.html" title="fn core::arch::x86_64::_mm_sll_epi32">_mm_sll_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 32 位整数移位，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sll_epi64.html" title="fn core::arch::x86_64::_mm_sll_epi64">_mm_sll_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>count</code> 左移的 <code>a</code> 中的包装的 64 位整数移位，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_slli_epi16.html" title="fn core::arch::x86_64::_mm_slli_epi16">_mm_slli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数左移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_slli_epi32.html" title="fn core::arch::x86_64::_mm_slli_epi32">_mm_slli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 32 位整数左移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_slli_epi64.html" title="fn core::arch::x86_64::_mm_slli_epi64">_mm_slli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 64 位整数左移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_slli_si128.html" title="fn core::arch::x86_64::_mm_slli_si128">_mm_slli_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 左移 <code>IMM8</code> 个字节，同时移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sllv_epi32.html" title="fn core::arch::x86_64::_mm_sllv_epi32">_mm_sllv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sllv_epi64.html" title="fn core::arch::x86_64::_mm_sllv_epi64">_mm_sllv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_pd.html" title="fn core::arch::x86_64::_mm_sqrt_pd">_mm_sqrt_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，它具有 <code>a</code> 中每个值的平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_ps.html" title="fn core::arch::x86_64::_mm_sqrt_ps">_mm_sqrt_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_sd.html" title="fn core::arch::x86_64::_mm_sqrt_sd">_mm_sqrt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低端元素替换为下部元素 <code>b</code> 的平方根。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sqrt_ss.html" title="fn core::arch::x86_64::_mm_sqrt_ss">_mm_sqrt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的平方根，其他元素保持不变。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sra_epi16.html" title="fn core::arch::x86_64::_mm_sra_epi16">_mm_sra_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将符号位移入时，将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sra_epi32.html" title="fn core::arch::x86_64::_mm_sra_epi32">_mm_sra_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将符号位移位时，将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srai_epi16.html" title="fn core::arch::x86_64::_mm_srai_epi16">_mm_srai_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srai_epi32.html" title="fn core::arch::x86_64::_mm_srai_epi32">_mm_srai_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srav_epi32.html" title="fn core::arch::x86_64::_mm_srav_epi32">_mm_srav_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 32 位整数向右移动，移动量由 <code>count</code> 中的相应元素指定，同时移入符号位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srl_epi16.html" title="fn core::arch::x86_64::_mm_srl_epi16">_mm_srl_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srl_epi32.html" title="fn core::arch::x86_64::_mm_srl_epi32">_mm_srl_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srl_epi64.html" title="fn core::arch::x86_64::_mm_srl_epi64">_mm_srl_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code>，同时将零移位。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srli_epi16.html" title="fn core::arch::x86_64::_mm_srli_epi16">_mm_srli_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srli_epi32.html" title="fn core::arch::x86_64::_mm_srli_epi32">_mm_srli_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srli_epi64.html" title="fn core::arch::x86_64::_mm_srli_epi64">_mm_srli_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中包装的 64 位整数右移 <code>IMM8</code>，同时将其移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srli_si128.html" title="fn core::arch::x86_64::_mm_srli_si128">_mm_srli_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 右移 <code>IMM8</code> 个字节，同时移入零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srlv_epi32.html" title="fn core::arch::x86_64::_mm_srlv_epi32">_mm_srlv_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</div></li><li><div class="item-name"><a class="fn" href="fn._mm_srlv_epi64.html" title="fn core::arch::x86_64::_mm_srlv_epi64">_mm_srlv_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx2` only">(x86 or x86-64) and <code>avx2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store1_pd.html" title="fn core::arch::x86_64::_mm_store1_pd">_mm_store1_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。
<code>mem_addr</code> 必须对齐在一个
可能会生成 16 字节边界或一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store1_ps.html" title="fn core::arch::x86_64::_mm_store1_ps">_mm_store1_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 的最低 32 位浮点数重复存储四次到 <em>aligned</em> 存储器中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_pd.html" title="fn core::arch::x86_64::_mm_store_pd">_mm_store_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 必须在 16 字节边界上对齐，否则可能会生成通用保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_pd1.html" title="fn core::arch::x86_64::_mm_store_pd1">_mm_store_pd1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。
<code>mem_addr</code> 必须对齐在一个
可能会生成 16 字节边界或一般保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_ps.html" title="fn core::arch::x86_64::_mm_store_ps">_mm_store_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将四个 32 位浮点数存储到 <em>aligned</em> 存储器中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_ps1.html" title="fn core::arch::x86_64::_mm_store_ps1">_mm_store_ps1</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short"><a href="fn._mm_store1_ps.html"><code>_mm_store1_ps</code></a> 的别名</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_sd.html" title="fn core::arch::x86_64::_mm_store_sd">_mm_store_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位 vector 的低 64 位存储到内存位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_si128.html" title="fn core::arch::x86_64::_mm_store_si128">_mm_store_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 128 位整数数据存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_store_ss.html" title="fn core::arch::x86_64::_mm_store_ss">_mm_store_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将 <code>a</code> 的最低 32 位浮点数存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeh_pd.html" title="fn core::arch::x86_64::_mm_storeh_pd">_mm_storeh_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位 vector 的高 64 位存储到存储位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storel_epi64.html" title="fn core::arch::x86_64::_mm_storel_epi64">_mm_storel_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将低 64 位整数 <code>a</code> 存储到内存位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storel_pd.html" title="fn core::arch::x86_64::_mm_storel_pd">_mm_storel_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位 vector 的低 64 位存储到内存位置。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storer_pd.html" title="fn core::arch::x86_64::_mm_storer_pd">_mm_storer_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>a</code> 中的 2 个双精度 (64-bit) 浮点元素以相反的顺序存储到内存中。
<code>mem_addr</code> 必须在 16 字节边界上对齐，否则可能会生成通用保护异常。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storer_ps.html" title="fn core::arch::x86_64::_mm_storer_ps">_mm_storer_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">以相反的顺序将四个 32 位浮点数存储到 <em>aligned</em> 存储器中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_pd.html" title="fn core::arch::x86_64::_mm_storeu_pd">_mm_storeu_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_ps.html" title="fn core::arch::x86_64::_mm_storeu_ps">_mm_storeu_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">将四个 32 位浮点数存储到内存中。内存对齐没有任何限制。
对于对齐的内存，<a href="fn._mm_store_ps.html"><code>_mm_store_ps</code></a> 可能更快。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_storeu_si128.html" title="fn core::arch::x86_64::_mm_storeu_si128">_mm_storeu_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将来自 <code>a</code> 的 128 位整数数据存储到内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_pd.html" title="fn core::arch::x86_64::_mm_stream_pd">_mm_stream_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 <code>[2 x double]</code> 的 128 位浮点 vector 存储到 128 位对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_ps.html" title="fn core::arch::x86_64::_mm_stream_ps">_mm_stream_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">使用非临时内存提示将 <code>a</code> 存储到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_sd.html" title="fn core::arch::x86_64::_mm_stream_sd">_mm_stream_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4a` only">(x86 or x86-64) and <code>sse4a</code></span></div><div class="desc docblock-short"><code>a.0</code> 的非临时存储到 <code>p</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_si32.html" title="fn core::arch::x86_64::_mm_stream_si32">_mm_stream_si32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 32 位整数值存储在指定的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_si64.html" title="fn core::arch::x86_64::_mm_stream_si64">_mm_stream_si64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `sse2` only"><code>sse2</code></span></div><div class="desc docblock-short">将 64 位整数值存储在指定的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_si128.html" title="fn core::arch::x86_64::_mm_stream_si128">_mm_stream_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">将 128 位整数 vector 存储到 128 位对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_stream_ss.html" title="fn core::arch::x86_64::_mm_stream_ss">_mm_stream_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4a` only">(x86 or x86-64) and <code>sse4a</code></span></div><div class="desc docblock-short"><code>a.0</code> 的非临时存储到 <code>p</code> 中。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_epi8.html" title="fn core::arch::x86_64::_mm_sub_epi8">_mm_sub_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 8 位整数中减去 <code>b</code> 中的包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_epi16.html" title="fn core::arch::x86_64::_mm_sub_epi16">_mm_sub_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 16 位整数减去 <code>b</code> 中的包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_epi32.html" title="fn core::arch::x86_64::_mm_sub_epi32">_mm_sub_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 32 位整数中减去 <code>b</code> 中的包装的 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_epi64.html" title="fn core::arch::x86_64::_mm_sub_epi64">_mm_sub_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中的包装的 64 位整数中减去 <code>b</code> 中的包装的 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_pd.html" title="fn core::arch::x86_64::_mm_sub_pd">_mm_sub_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 中减去 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_ps.html" title="fn core::arch::x86_64::_mm_sub_ps">_mm_sub_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">减去 __m128 vectors。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_sd.html" title="fn core::arch::x86_64::_mm_sub_sd">_mm_sub_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回一个新的 vector，其中 <code>a</code> 的低端元素被 <code>a</code> 的低端元素减去 <code>b</code> 的低端元素所代替。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_sub_ss.html" title="fn core::arch::x86_64::_mm_sub_ss">_mm_sub_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从 <code>a</code> 减去 <code>b</code> 的第一个组件，从 <code>a</code> 复制其他组件。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_subs_epi8.html" title="fn core::arch::x86_64::_mm_subs_epi8">_mm_subs_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_subs_epi16.html" title="fn core::arch::x86_64::_mm_subs_epi16">_mm_subs_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_subs_epu8.html" title="fn core::arch::x86_64::_mm_subs_epu8">_mm_subs_epu8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 中的包装无符号 8 位整数减去 <code>b</code> 中的包装无符号 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_subs_epu16.html" title="fn core::arch::x86_64::_mm_subs_epu16">_mm_subs_epu16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">使用饱和度从 <code>a</code> 中的包装的无符号 16 位整数减去 <code>b</code> 中的包装的无符号 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_all_ones.html" title="fn core::arch::x86_64::_mm_test_all_ones">_mm_test_all_ones</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 <code>a</code> 128 位整数 vector 中的指定位是否全部为 1。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_all_zeros.html" title="fn core::arch::x86_64::_mm_test_all_zeros">_mm_test_all_zeros</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 128 位整数 vector 中的指定位是否全部为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_test_mix_ones_zeros.html" title="fn core::arch::x86_64::_mm_test_mix_ones_zeros">_mm_test_mix_ones_zeros</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testc_pd.html" title="fn core::arch::x86_64::_mm_testc_pd">_mm_testc_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>CF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testc_ps.html" title="fn core::arch::x86_64::_mm_testc_ps">_mm_testc_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 32 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>CF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testc_si128.html" title="fn core::arch::x86_64::_mm_testc_si128">_mm_testc_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 128 位整数 vector 中的指定位是否全部为 1。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testnzc_pd.html" title="fn core::arch::x86_64::_mm_testnzc_pd">_mm_testnzc_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
如果 <code>ZF</code> 和 <code>CF</code> 的值都为零则返回 1，否则返回 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testnzc_ps.html" title="fn core::arch::x86_64::_mm_testnzc_ps">_mm_testnzc_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 32 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
如果 <code>ZF</code> 和 <code>CF</code> 的值都为零则返回 1，否则返回 0.</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testnzc_si128.html" title="fn core::arch::x86_64::_mm_testnzc_si128">_mm_testnzc_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testz_pd.html" title="fn core::arch::x86_64::_mm_testz_pd">_mm_testz_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 64 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
计算 <code>a</code> 的按位非，然后与 <code>b</code> 与，产生一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>ZF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testz_ps.html" title="fn core::arch::x86_64::_mm_testz_ps">_mm_testz_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `avx` only">(x86 or x86-64) and <code>avx</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示单精度 (32-bit) 浮点元素) 的按位与，产生一个 128 位中间值，如果中间值中每个 32 位元素的符号位都设置 <code>ZF</code> 为 1 为零，否则将 <code>ZF</code> 设置为 0.
对 <code>a</code> 进行按位非运算，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 32 位元素的符号位都为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0.
返回 <code>ZF</code> 值。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_testz_si128.html" title="fn core::arch::x86_64::_mm_testz_si128">_mm_testz_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse4.1` only">(x86 or x86-64) and <code>sse4.1</code></span></div><div class="desc docblock-short">测试 128 位整数 vector 中的指定位是否全部为零。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_tzcnt_32.html" title="fn core::arch::x86_64::_mm_tzcnt_32">_mm_tzcnt_32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">计算尾随的最低有效零位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_tzcnt_64.html" title="fn core::arch::x86_64::_mm_tzcnt_64">_mm_tzcnt_64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">计算尾随的最低有效零位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomieq_sd.html" title="fn core::arch::x86_64::_mm_ucomieq_sd">_mm_ucomieq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomieq_ss.html" title="fn core::arch::x86_64::_mm_ucomieq_ss">_mm_ucomieq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。如果相等则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomige_sd.html" title="fn core::arch::x86_64::_mm_ucomige_sd">_mm_ucomige_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomige_ss.html" title="fn core::arch::x86_64::_mm_ucomige_ss">_mm_ucomige_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomigt_sd.html" title="fn core::arch::x86_64::_mm_ucomigt_sd">_mm_ucomigt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomigt_ss.html" title="fn core::arch::x86_64::_mm_ucomigt_ss">_mm_ucomigt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomile_sd.html" title="fn core::arch::x86_64::_mm_ucomile_sd">_mm_ucomile_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素是否等于或小于等于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomile_ss.html" title="fn core::arch::x86_64::_mm_ucomile_ss">_mm_ucomile_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomilt_sd.html" title="fn core::arch::x86_64::_mm_ucomilt_sd">_mm_ucomilt_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的下限元素小于。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomilt_ss.html" title="fn core::arch::x86_64::_mm_ucomilt_ss">_mm_ucomilt_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomineq_sd.html" title="fn core::arch::x86_64::_mm_ucomineq_sd">_mm_ucomineq_sd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的较低元素是否不相等。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_ucomineq_ss.html" title="fn core::arch::x86_64::_mm_ucomineq_ss">_mm_ucomineq_ss</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果它们不相等，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_undefined_pd.html" title="fn core::arch::x86_64::_mm_undefined_pd">_mm_undefined_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m128d 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_undefined_ps.html" title="fn core::arch::x86_64::_mm_undefined_ps">_mm_undefined_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m128 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_undefined_si128.html" title="fn core::arch::x86_64::_mm_undefined_si128">_mm_undefined_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">返回具有不确定元素的 __m128i 类型的 vector。
尽管是 “undefined”，但这是一些有效值，并不等同于 <a href="../../mem/union.MaybeUninit.html" title="union core::mem::MaybeUninit"><code>mem::MaybeUninit</code></a>。
实际上，这相当于 <a href="../../mem/fn.zeroed.html" title="fn core::mem::zeroed"><code>mem::zeroed</code></a>。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_epi8.html" title="fn core::arch::x86_64::_mm_unpackhi_epi8">_mm_unpackhi_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_epi16.html" title="fn core::arch::x86_64::_mm_unpackhi_epi16">_mm_unpackhi_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_epi32.html" title="fn core::arch::x86_64::_mm_unpackhi_epi32">_mm_unpackhi_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_epi64.html" title="fn core::arch::x86_64::_mm_unpackhi_epi64">_mm_unpackhi_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_pd.html" title="fn core::arch::x86_64::_mm_unpackhi_pd">_mm_unpackhi_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">所得的 <code>__m128d</code> 元素由两个 <code>__m128d</code> 交错输入元素的低阶值组成，即：</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpackhi_ps.html" title="fn core::arch::x86_64::_mm_unpackhi_ps">_mm_unpackhi_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的上半部分解包并交织单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_epi8.html" title="fn core::arch::x86_64::_mm_unpacklo_epi8">_mm_unpacklo_epi8</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 8 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_epi16.html" title="fn core::arch::x86_64::_mm_unpacklo_epi16">_mm_unpacklo_epi16</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 16 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_epi32.html" title="fn core::arch::x86_64::_mm_unpacklo_epi32">_mm_unpacklo_epi32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 32 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_epi64.html" title="fn core::arch::x86_64::_mm_unpacklo_epi64">_mm_unpacklo_epi64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 64 位整数。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_pd.html" title="fn core::arch::x86_64::_mm_unpacklo_pd">_mm_unpacklo_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">所得的 <code>__m128d</code> 元素由两个 <code>__m128d</code> 交错输入元素的高阶值组成，即：</div></li><li><div class="item-name"><a class="fn" href="fn._mm_unpacklo_ps.html" title="fn core::arch::x86_64::_mm_unpacklo_ps">_mm_unpacklo_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织单精度 (32-bit) 浮点元素。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_pd.html" title="fn core::arch::x86_64::_mm_xor_pd">_mm_xor_pd</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 的按位异或。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_ps.html" title="fn core::arch::x86_64::_mm_xor_ps">_mm_xor_ps</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse` only">(x86 or x86-64) and <code>sse</code></span></div><div class="desc docblock-short">包装的单精度 (32-bit) 浮点元素的按位异或。</div></li><li><div class="item-name"><a class="fn" href="fn._mm_xor_si128.html" title="fn core::arch::x86_64::_mm_xor_si128">_mm_xor_si128</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `sse2` only">(x86 or x86-64) and <code>sse2</code></span></div><div class="desc docblock-short">计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位 XOR。</div></li><li><div class="item-name"><a class="fn" href="fn._mulx_u32.html" title="fn core::arch::x86_64::_mulx_u32">_mulx_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi2` only">(x86 or x86-64) and <code>bmi2</code></span></div><div class="desc docblock-short">无符号乘法，且不影响标志。</div></li><li><div class="item-name"><a class="fn" href="fn._mulx_u64.html" title="fn core::arch::x86_64::_mulx_u64">_mulx_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi2` only"><code>bmi2</code></span></div><div class="desc docblock-short">无符号乘法，且不影响标志。</div></li><li><div class="item-name"><a class="fn" href="fn._pdep_u32.html" title="fn core::arch::x86_64::_pdep_u32">_pdep_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi2` only">(x86 or x86-64) and <code>bmi2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的连续低阶位分散到 <code>mask</code> 指定的位置处的结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._pdep_u64.html" title="fn core::arch::x86_64::_pdep_u64">_pdep_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi2` only"><code>bmi2</code></span></div><div class="desc docblock-short">将 <code>a</code> 的连续低阶位分散到 <code>mask</code> 指定的位置处的结果中。</div></li><li><div class="item-name"><a class="fn" href="fn._pext_u32.html" title="fn core::arch::x86_64::_pext_u32">_pext_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi2` only">(x86 or x86-64) and <code>bmi2</code></span></div><div class="desc docblock-short">将 <code>mask</code> 指定的 <code>x</code> 的位收集到结果的连续低阶位位置。</div></li><li><div class="item-name"><a class="fn" href="fn._pext_u64.html" title="fn core::arch::x86_64::_pext_u64">_pext_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi2` only"><code>bmi2</code></span></div><div class="desc docblock-short">将 <code>mask</code> 指定的 <code>x</code> 的位收集到结果的连续低阶位位置。</div></li><li><div class="item-name"><a class="fn" href="fn._popcnt32.html" title="fn core::arch::x86_64::_popcnt32">_popcnt32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `popcnt` only">(x86 or x86-64) and <code>popcnt</code></span></div><div class="desc docblock-short">计算设置的位。</div></li><li><div class="item-name"><a class="fn" href="fn._popcnt64.html" title="fn core::arch::x86_64::_popcnt64">_popcnt64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `popcnt` only"><code>popcnt</code></span></div><div class="desc docblock-short">计算设置的位。</div></li><li><div class="item-name"><a class="fn" href="fn._rdrand16_step.html" title="fn core::arch::x86_64::_rdrand16_step">_rdrand16_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rdrand` only">(x86 or x86-64) and <code>rdrand</code></span></div><div class="desc docblock-short">读取硬件生成的 16 位随机值，并将结果存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdrand32_step.html" title="fn core::arch::x86_64::_rdrand32_step">_rdrand32_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rdrand` only">(x86 or x86-64) and <code>rdrand</code></span></div><div class="desc docblock-short">读取硬件生成的 32 位随机值，并将结果存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdrand64_step.html" title="fn core::arch::x86_64::_rdrand64_step">_rdrand64_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `rdrand` only"><code>rdrand</code></span></div><div class="desc docblock-short">读取硬件生成的 64 位随机值，并将结果存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdseed16_step.html" title="fn core::arch::x86_64::_rdseed16_step">_rdseed16_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rdseed` only">(x86 or x86-64) and <code>rdseed</code></span></div><div class="desc docblock-short">读取符合 NIST SP800-90B 和 SP800-90C 的 16 位随机值，并存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdseed32_step.html" title="fn core::arch::x86_64::_rdseed32_step">_rdseed32_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `rdseed` only">(x86 or x86-64) and <code>rdseed</code></span></div><div class="desc docblock-short">读取符合 NIST SP800-90B 和 SP800-90C 的 32 位随机值，并存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdseed64_step.html" title="fn core::arch::x86_64::_rdseed64_step">_rdseed64_step</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `rdseed` only"><code>rdseed</code></span></div><div class="desc docblock-short">读取符合 NIST SP800-90B 和 SP800-90C 的 64 位随机值，并存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</div></li><li><div class="item-name"><a class="fn" href="fn._rdtsc.html" title="fn core::arch::x86_64::_rdtsc">_rdtsc</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">读取处理器时间戳计数器的当前值。</div></li><li><div class="item-name"><a class="fn" href="fn._subborrow_u32.html" title="fn core::arch::x86_64::_subborrow_u32">_subborrow_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._subborrow_u64.html" title="fn core::arch::x86_64::_subborrow_u64">_subborrow_u64</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">将无符号的 64 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位随身输入 <code>c_in</code> 相加。
(进位或溢出标志)，并将无符号的 64 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</div></li><li><div class="item-name"><a class="fn" href="fn._t1mskc_u32.html" title="fn core::arch::x86_64::_t1mskc_u32">_t1mskc_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除 <code>x</code> 的最低有效零以下的所有位，并设置所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._t1mskc_u64.html" title="fn core::arch::x86_64::_t1mskc_u64">_t1mskc_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">清除 <code>x</code> 的最低有效零以下的所有位，并设置所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._tzcnt_u32.html" title="fn core::arch::x86_64::_tzcnt_u32">_tzcnt_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `bmi1` only">(x86 or x86-64) and <code>bmi1</code></span></div><div class="desc docblock-short">计算尾随的最低有效零位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._tzcnt_u64.html" title="fn core::arch::x86_64::_tzcnt_u64">_tzcnt_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `bmi1` only"><code>bmi1</code></span></div><div class="desc docblock-short">计算尾随的最低有效零位的数量。</div></li><li><div class="item-name"><a class="fn" href="fn._tzmsk_u32.html" title="fn core::arch::x86_64::_tzmsk_u32">_tzmsk_u32</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将所有位设置为低于 <code>x</code> 的最低有效位，并清除所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._tzmsk_u64.html" title="fn core::arch::x86_64::_tzmsk_u64">_tzmsk_u64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `tbm` only">(x86 or x86-64) and <code>tbm</code></span></div><div class="desc docblock-short">将所有位设置为低于 <code>x</code> 的最低有效位，并清除所有其他位。</div></li><li><div class="item-name"><a class="fn" href="fn._xgetbv.html" title="fn core::arch::x86_64::_xgetbv">_xgetbv</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave` only">(x86 or x86-64) and <code>xsave</code></span></div><div class="desc docblock-short">读取 <code>xcr_no</code> 中指定的扩展控制寄存器 <code>XCR</code> 的内容。</div></li><li><div class="item-name"><a class="fn" href="fn._xrstor.html" title="fn core::arch::x86_64::_xrstor">_xrstor</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave` only">(x86 or x86-64) and <code>xsave</code></span></div><div class="desc docblock-short">使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</div></li><li><div class="item-name"><a class="fn" href="fn._xrstor64.html" title="fn core::arch::x86_64::_xrstor64">_xrstor64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave` only"><code>xsave</code></span></div><div class="desc docblock-short">使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</div></li><li><div class="item-name"><a class="fn" href="fn._xrstors.html" title="fn core::arch::x86_64::_xrstors">_xrstors</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave,xsaves` only">(x86 or x86-64) and <code>xsave,xsaves</code></span></div><div class="desc docblock-short">使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</div></li><li><div class="item-name"><a class="fn" href="fn._xrstors64.html" title="fn core::arch::x86_64::_xrstors64">_xrstors64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="desc docblock-short">使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</div></li><li><div class="item-name"><a class="fn" href="fn._xsave.html" title="fn core::arch::x86_64::_xsave">_xsave</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave` only">(x86 or x86-64) and <code>xsave</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsave64.html" title="fn core::arch::x86_64::_xsave64">_xsave64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave` only"><code>xsave</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsavec.html" title="fn core::arch::x86_64::_xsavec">_xsavec</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave,xsavec` only">(x86 or x86-64) and <code>xsave,xsavec</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsavec64.html" title="fn core::arch::x86_64::_xsavec64">_xsavec64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave,xsavec` only"><code>xsave,xsavec</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsaveopt.html" title="fn core::arch::x86_64::_xsaveopt">_xsaveopt</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave,xsaveopt` only">(x86 or x86-64) and <code>xsave,xsaveopt</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsaveopt64.html" title="fn core::arch::x86_64::_xsaveopt64">_xsaveopt64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave,xsaveopt` only"><code>xsave,xsaveopt</code></span></div><div class="desc docblock-short">将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</div></li><li><div class="item-name"><a class="fn" href="fn._xsaves.html" title="fn core::arch::x86_64::_xsaves">_xsaves</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave,xsaves` only">(x86 or x86-64) and <code>xsave,xsaves</code></span></div><div class="desc docblock-short">在 <code>mem_addr</code> 处将启用的处理器状态全部或部分保存到内存</div></li><li><div class="item-name"><a class="fn" href="fn._xsaves64.html" title="fn core::arch::x86_64::_xsaves64">_xsaves64</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span></div><div class="desc docblock-short">在 <code>mem_addr</code> 处将启用的处理器状态全部或部分保存到内存</div></li><li><div class="item-name"><a class="fn" href="fn._xsetbv.html" title="fn core::arch::x86_64::_xsetbv">_xsetbv</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available on (x86 or x86-64) and target feature `xsave` only">(x86 or x86-64) and <code>xsave</code></span></div><div class="desc docblock-short">从 <code>val</code> 复制 64 位到 <code>a</code> 指定的扩展控制寄存器 (<code>XCR</code>)。</div></li><li><div class="item-name"><a class="fn" href="fn.cmpxchg16b.html" title="fn core::arch::x86_64::cmpxchg16b">cmpxchg16b</a><sup title="unsafe function">⚠</sup><span class="stab portability" title="Available with target feature `cmpxchg16b` only"><code>cmpxchg16b</code></span></div><div class="desc docblock-short">自动比较和交换 16 字节 (128 位) 的数据。</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type._MM_CMPINT_ENUM.html" title="type core::arch::x86_64::_MM_CMPINT_ENUM">_MM_CMPINT_ENUM</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>_MM_CMPINT_ENUM</code> 类型用于在 AVX-512 内部函数中指定比较操作。</div></li><li><div class="item-name"><a class="type" href="type._MM_MANTISSA_NORM_ENUM.html" title="type core::arch::x86_64::_MM_MANTISSA_NORM_ENUM">_MM_MANTISSA_NORM_ENUM</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>MM_MANTISSA_NORM_ENUM</code> 类型用于指定 AVX-512 内部函数中的尾数归一化操作。</div></li><li><div class="item-name"><a class="type" href="type._MM_MANTISSA_SIGN_ENUM.html" title="type core::arch::x86_64::_MM_MANTISSA_SIGN_ENUM">_MM_MANTISSA_SIGN_ENUM</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>MM_MANTISSA_SIGN_ENUM</code> 类型用于指定 AVX-512 内部函数中的尾数签名操作。</div></li><li><div class="item-name"><a class="type" href="type._MM_PERM_ENUM.html" title="type core::arch::x86_64::_MM_PERM_ENUM">_MM_PERM_ENUM</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short"><code>MM_PERM_ENUM</code> 类型用于指定在 AVX-512 内部函数中的重排操作。</div></li><li><div class="item-name"><a class="type" href="type.__mmask8.html" title="type core::arch::x86_64::__mmask8">__mmask8</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">AVX-512 内部函数中使用的 <code>__mmask8</code> 类型，一个 8 位整数</div></li><li><div class="item-name"><a class="type" href="type.__mmask16.html" title="type core::arch::x86_64::__mmask16">__mmask16</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">AVX-512 内部函数中使用的 <code>__mmask16</code> 类型，一个 16 位整数</div></li><li><div class="item-name"><a class="type" href="type.__mmask32.html" title="type core::arch::x86_64::__mmask32">__mmask32</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">AVX-512 内部函数中使用的 <code>__mmask32</code> 类型，一个 32 位整数</div></li><li><div class="item-name"><a class="type" href="type.__mmask64.html" title="type core::arch::x86_64::__mmask64">__mmask64</a><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="Available on x86 or x86-64 only">x86 or x86-64</span></div><div class="desc docblock-short">AVX-512 内部函数中使用的 <code>__mmask64</code> 类型，一个 64 位整数</div></li></ul></section></div></main></body></html>