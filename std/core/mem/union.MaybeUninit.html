<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="包装器类型，用于创建 `T` 的未初始化实例。"><title>MaybeUninit in core::mem - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items1.71.0.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc union"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">MaybeUninit</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.array_assume_init">array_assume_init</a></li><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.assume_init">assume_init</a></li><li><a href="#method.assume_init_drop">assume_init_drop</a></li><li><a href="#method.assume_init_mut">assume_init_mut</a></li><li><a href="#method.assume_init_read">assume_init_read</a></li><li><a href="#method.assume_init_ref">assume_init_ref</a></li><li><a href="#method.new">new</a></li><li><a href="#method.slice_as_bytes">slice_as_bytes</a></li><li><a href="#method.slice_as_bytes_mut">slice_as_bytes_mut</a></li><li><a href="#method.slice_as_mut_ptr">slice_as_mut_ptr</a></li><li><a href="#method.slice_as_ptr">slice_as_ptr</a></li><li><a href="#method.slice_assume_init_mut">slice_assume_init_mut</a></li><li><a href="#method.slice_assume_init_ref">slice_assume_init_ref</a></li><li><a href="#method.transpose">transpose</a></li><li><a href="#method.uninit">uninit</a></li><li><a href="#method.uninit_array">uninit_array</a></li><li><a href="#method.write">write</a></li><li><a href="#method.write_slice">write_slice</a></li><li><a href="#method.write_slice_cloned">write_slice_cloned</a></li><li><a href="#method.zeroed">zeroed</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-MaybeUninit%3CT%3E">Clone</a></li><li><a href="#impl-Copy-for-MaybeUninit%3CT%3E">Copy</a></li><li><a href="#impl-Debug-for-MaybeUninit%3CT%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-MaybeUninit%3CT%3E">Send</a></li><li><a href="#impl-Sync-for-MaybeUninit%3CT%3E">Sync</a></li><li><a href="#impl-Unpin-for-MaybeUninit%3CT%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-MaybeUninit%3CT%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-MaybeUninit%3CT%3E">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-MaybeUninit%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-MaybeUninit%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-MaybeUninit%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-MaybeUninit%3CT%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-MaybeUninit%3CT%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-MaybeUninit%3CT%3E">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In core::mem</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Union <a href="../index.html">core</a>::<wbr><a href="index.html">mem</a>::<wbr><a class="union" href="#">MaybeUninit</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#249-252">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[repr(transparent)]
pub union MaybeUninit&lt;T&gt; {
    /* private fields */
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>包装器类型，用于创建 <code>T</code> 的未初始化实例。</p>
<h2 id="初始化不变量"><a href="#初始化不变量">初始化不变量</a></h2>
<p>通常，编译器假定已根据变量类型的要求正确初始化了变量。例如，引用类型的变量必须对齐且非空。
即使在不安全的代码中，这也必须始终保持不变。
因此，将引用类型的变量初始化为零会导致瞬时 <a href="../../reference/behavior-considered-undefined.html">未定义的行为</a>，无论该引用是否曾经用于访问内存：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>i32 = <span class="kw">unsafe </span>{ mem::zeroed() }; <span class="comment">// 未定义的行为！ ⚠️
// 与 `MaybeUninit&lt;&amp;i32&gt;` 等效的代码：
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>i32 = <span class="kw">unsafe </span>{ MaybeUninit::zeroed().assume_init() }; <span class="comment">// 未定义的行为！ ⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0Ause+std::mem::%7Bself,+MaybeUninit%7D;%0A%0Alet+x:+%26i32+=+unsafe+%7B+mem::zeroed()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A//+%E4%B8%8E+%60MaybeUninit%3C%26i32%3E%60+%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A%0Alet+x:+%26i32+=+unsafe+%7B+MaybeUninit::zeroed().assume_init()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
<p>编译器利用这一点进行各种优化，例如取消运行时检查和优化 <code>enum</code> 布局。</p>
<p>同样，完全未初始化的存储器可以包含任何内容，而 <code>bool</code> 必须始终为 <code>true</code> 或 <code>false</code>。因此，创建未初始化的 <code>bool</code> 是未定义的行为：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>b: bool = <span class="kw">unsafe </span>{ mem::uninitialized() }; <span class="comment">// 未定义的行为！ ⚠️
// 与 `MaybeUninit&lt;bool&gt;` 等效的代码：
</span><span class="kw">let </span>b: bool = <span class="kw">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class="comment">// 未定义的行为！ ⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0Ause+std::mem::%7Bself,+MaybeUninit%7D;%0A%0Alet+b:+bool+=+unsafe+%7B+mem::uninitialized()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A//+%E4%B8%8E+%60MaybeUninit%3Cbool%3E%60+%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A%0Alet+b:+bool+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
<p>此外，未初始化的存储器的特殊之处在于它没有固定的值 (“fixed” 表示 “it won’t change without being written to”)。多次读取相同的未初始化字节会产生不同的结果。
这使得在变量中具有未初始化的数据成为未定义的行为，即使该变量具有整数类型也可以保留任何固定位模式</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>x: i32 = <span class="kw">unsafe </span>{ mem::uninitialized() }; <span class="comment">// 未定义的行为！ ⚠️
// 与 `MaybeUninit&lt;i32&gt;` 等效的代码：
</span><span class="kw">let </span>x: i32 = <span class="kw">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class="comment">// 未定义的行为！ ⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn+main()+%7B%0Ause+std::mem::%7Bself,+MaybeUninit%7D;%0A%0Alet+x:+i32+=+unsafe+%7B+mem::uninitialized()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A//+%E4%B8%8E+%60MaybeUninit%3Ci32%3E%60+%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A%0Alet+x:+i32+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;+//+%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%EF%BC%81+%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
<p>最重要的是，请记住，大多数类型都有额外的不变量，而不仅仅是在类型级别被初始化。
例如，将 <code>1</code> 初始化的 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 视为已初始化 (在当前实现下; 这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须为非空值。
创建这样的 <code>Vec&lt;T&gt;</code> 不会立即导致未定义的行为，但是在大多数安全操作 (包括丢弃操作) 中都将导致未定义的行为。</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p><code>MaybeUninit&lt;T&gt;</code> 用于启用不安全代码来处理未初始化的数据。
这是向编译器发出的信号，指示此处的数据可能不被初始化：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="comment">// 创建一个显式未初始化的引用。
// 编译器知道 `MaybeUninit&lt;T&gt;` 内部的数据可能无效，因此不是 UB：
</span><span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="kw-2">&amp;</span>i32&gt;::uninit();
<span class="comment">// 将其设置为有效值。
</span>x.write(<span class="kw-2">&amp;</span><span class="number">0</span>);
<span class="comment">// 提取已初始化的数据 - 仅在正确初始化 `x` 之后 * 才允许这样做！
</span><span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0A//+%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%98%BE%E5%BC%8F%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%82%0A//+%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E9%81%93+%60MaybeUninit%3CT%3E%60+%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%83%BD%E6%97%A0%E6%95%88%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E6%98%AF+UB%EF%BC%9A%0Alet+mut+x+=+MaybeUninit::%3C%26i32%3E::uninit();%0A//+%E5%B0%86%E5%85%B6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%89%E6%95%88%E5%80%BC%E3%80%82%0Ax.write(%260);%0A//+%E6%8F%90%E5%8F%96%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE+-+%E4%BB%85%E5%9C%A8%E6%AD%A3%E7%A1%AE%E5%88%9D%E5%A7%8B%E5%8C%96+%60x%60+%E4%B9%8B%E5%90%8E+*+%E6%89%8D%E5%85%81%E8%AE%B8%E8%BF%99%E6%A0%B7%E5%81%9A%EF%BC%81%0Alet+x+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&amp;edition=2021">Run</a></div>
<p>然后，编译器知道不会对此代码进行任何错误的假设或优化。</p>
<p>您可以认为 <code>MaybeUninit&lt;T&gt;</code> 有点像 <code>Option&lt;T&gt;</code>，但是没有任何运行时跟踪且没有任何安全检查。</p>
<h3 id="out-pointers"><a href="#out-pointers">out-pointers</a></h3>
<p>您可以使用 <code>MaybeUninit&lt;T&gt;</code> 来实现 “out-pointers”: 与其从函数中返回数据，还不如将其传递给某个 (uninitialized) 内存的指针以将结果放入其中。
当对调用者来说，控制结果存储在内存中的分配方式很重要并且您希望避免不必要的移动时，这很有用。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">unsafe fn </span>make_vec(out: <span class="kw-2">*mut </span>Vec&lt;i32&gt;) {
    <span class="comment">// `write` 不丢弃旧内容，这一点很重要。
    </span>out.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
}

<span class="kw">let </span><span class="kw-2">mut </span>v = MaybeUninit::uninit();
<span class="kw">unsafe </span>{ make_vec(v.as_mut_ptr()); }
<span class="comment">// 现在我们知道 `v` 已初始化！ 这也可以确保正确丢弃 vector。
</span><span class="kw">let </span>v = <span class="kw">unsafe </span>{ v.assume_init() };
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>v, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Aunsafe+fn+make_vec(out:+*mut+Vec%3Ci32%3E)+%7B%0A++++//+%60write%60+%E4%B8%8D%E4%B8%A2%E5%BC%83%E6%97%A7%E5%86%85%E5%AE%B9%EF%BC%8C%E8%BF%99%E4%B8%80%E7%82%B9%E5%BE%88%E9%87%8D%E8%A6%81%E3%80%82%0A++++out.write(vec!%5B1,+2,+3%5D);%0A%7D%0A%0Alet+mut+v+=+MaybeUninit::uninit();%0Aunsafe+%7B+make_vec(v.as_mut_ptr());+%7D%0A//+%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93+%60v%60+%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%81+%E8%BF%99%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E4%B8%A2%E5%BC%83+vector%E3%80%82%0Alet+v+=+unsafe+%7B+v.assume_init()+%7D;%0Aassert_eq!(%26v,+%26%5B1,+2,+3%5D);%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="逐元素初始化数组"><a href="#逐元素初始化数组">逐元素初始化数组</a></h3>
<p><code>MaybeUninit&lt;T&gt;</code> 可用于逐个元素初始化大数组：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>data = {
    <span class="comment">// 创建一个未初始化的 `MaybeUninit` 数组。
    // `assume_init` 是安全的，因为我们声称这里已经初始化的类型是一堆 `MaybeUninit`，不需要初始化。
    </span><span class="kw">let </span><span class="kw-2">mut </span>data: [MaybeUninit&lt;Vec&lt;u32&gt;&gt;; <span class="number">1000</span>] = <span class="kw">unsafe </span>{
        MaybeUninit::uninit().assume_init()
    };

    <span class="comment">// 丢弃 `MaybeUninit` 什么都不做
    </span><span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[..] {
        elem.write(<span class="macro">vec!</span>[<span class="number">42</span>]);
    }

    <span class="comment">// 一切都已初始化。
    // 将数组转换为初始化的类型。
    </span><span class="kw">unsafe </span>{ mem::transmute::&lt;<span class="kw">_</span>, [Vec&lt;u32&gt;; <span class="number">1000</span>]&gt;(data) }
};

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>data[<span class="number">0</span>], <span class="kw-2">&amp;</span>[<span class="number">42</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::%7Bself,+MaybeUninit%7D;%0A%0Alet+data+=+%7B%0A++++//+%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+%60MaybeUninit%60+%E6%95%B0%E7%BB%84%E3%80%82%0A++++//+%60assume_init%60+%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%A3%B0%E7%A7%B0%E8%BF%99%E9%87%8C%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E5%A0%86+%60MaybeUninit%60%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A++++let+mut+data:+%5BMaybeUninit%3CVec%3Cu32%3E%3E;+1000%5D+=+unsafe+%7B%0A++++++++MaybeUninit::uninit().assume_init()%0A++++%7D;%0A%0A++++//+%E4%B8%A2%E5%BC%83+%60MaybeUninit%60+%E4%BB%80%E4%B9%88%E9%83%BD%E4%B8%8D%E5%81%9A%0A++++for+elem+in+%26mut+data%5B..%5D+%7B%0A++++++++elem.write(vec!%5B42%5D);%0A++++%7D%0A%0A++++//+%E4%B8%80%E5%88%87%E9%83%BD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A++++//+%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82%0A++++unsafe+%7B+mem::transmute::%3C_,+%5BVec%3Cu32%3E;+1000%5D%3E(data)+%7D%0A%7D;%0A%0Aassert_eq!(%26data%5B0%5D,+%26%5B42%5D);%0A%7D&amp;edition=2021">Run</a></div>
<p>您也可以使用部分初始化的数组，这些数组可以在不稳定的数据结构中找到。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="comment">// 创建一个未初始化的 `MaybeUninit` 数组。
// `assume_init` 是安全的，因为我们声称这里已经初始化的类型是一堆 `MaybeUninit`，不需要初始化。
</span><span class="kw">let </span><span class="kw-2">mut </span>data: [MaybeUninit&lt;String&gt;; <span class="number">1000</span>] = <span class="kw">unsafe </span>{ MaybeUninit::uninit().assume_init() };
<span class="comment">// 计算我们分配的元素数。
</span><span class="kw">let </span><span class="kw-2">mut </span>data_len: usize = <span class="number">0</span>;

<span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[<span class="number">0</span>..<span class="number">500</span>] {
    elem.write(String::from(<span class="string">&quot;hello&quot;</span>));
    data_len += <span class="number">1</span>;
}

<span class="comment">// 对于数组中的每个项，如果我们分配了它，则将其丢弃。
</span><span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[<span class="number">0</span>..data_len] {
    <span class="kw">unsafe </span>{ elem.assume_init_drop(); }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0A//+%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+%60MaybeUninit%60+%E6%95%B0%E7%BB%84%E3%80%82%0A//+%60assume_init%60+%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%A3%B0%E7%A7%B0%E8%BF%99%E9%87%8C%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E5%A0%86+%60MaybeUninit%60%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet+mut+data:+%5BMaybeUninit%3CString%3E;+1000%5D+=+unsafe+%7B+MaybeUninit::uninit().assume_init()+%7D;%0A//+%E8%AE%A1%E7%AE%97%E6%88%91%E4%BB%AC%E5%88%86%E9%85%8D%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E3%80%82%0Alet+mut+data_len:+usize+=+0;%0A%0Afor+elem+in+%26mut+data%5B0..500%5D+%7B%0A++++elem.write(String::from(%22hello%22));%0A++++data_len+%2B=+1;%0A%7D%0A%0A//+%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E9%A1%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%88%86%E9%85%8D%E4%BA%86%E5%AE%83%EF%BC%8C%E5%88%99%E5%B0%86%E5%85%B6%E4%B8%A2%E5%BC%83%E3%80%82%0Afor+elem+in+%26mut+data%5B0..data_len%5D+%7B%0A++++unsafe+%7B+elem.assume_init_drop();+%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="逐字段初始化结构体"><a href="#逐字段初始化结构体">逐字段初始化结构体</a></h3>
<p>您可以使用 <code>MaybeUninit&lt;T&gt;</code> 和 <a href="../ptr/macro.addr_of_mut.html" title="macro core::ptr::addr_of_mut"><code>std::ptr::addr_of_mut</code></a> 宏来逐字段初始化结构体：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;
<span class="kw">use </span>std::ptr::addr_of_mut;

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">pub struct </span>Foo {
    name: String,
    list: Vec&lt;u8&gt;,
}

<span class="kw">let </span>foo = {
    <span class="kw">let </span><span class="kw-2">mut </span>uninit: MaybeUninit&lt;Foo&gt; = MaybeUninit::uninit();
    <span class="kw">let </span>ptr = uninit.as_mut_ptr();

    <span class="comment">// 初始化 `name` 字段 使用 `write` 而不是通过 `=` 赋值，而不是在旧的、未初始化的值上调用 `drop`。
    </span><span class="kw">unsafe </span>{ <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span>ptr).name).write(<span class="string">&quot;Bob&quot;</span>.to_string()); }

    <span class="comment">// 初始化 `list` 字段如果此处存在 panic，则 `name` 字段中的 `String` 泄漏。
    </span><span class="kw">unsafe </span>{ <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span>ptr).list).write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]); }

    <span class="comment">// 所有字段都已初始化，因此我们调用 `assume_init` 来获取已初始化的 Foo。
    </span><span class="kw">unsafe </span>{ uninit.assume_init() }
};

<span class="macro">assert_eq!</span>(
    foo,
    Foo {
        name: <span class="string">&quot;Bob&quot;</span>.to_string(),
        list: <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]
    }
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0Ause+std::ptr::addr_of_mut;%0A%0A%23%5Bderive(Debug,+PartialEq)%5D%0Apub+struct+Foo+%7B%0A++++name:+String,%0A++++list:+Vec%3Cu8%3E,%0A%7D%0A%0Alet+foo+=+%7B%0A++++let+mut+uninit:+MaybeUninit%3CFoo%3E+=+MaybeUninit::uninit();%0A++++let+ptr+=+uninit.as_mut_ptr();%0A%0A++++//+%E5%88%9D%E5%A7%8B%E5%8C%96+%60name%60+%E5%AD%97%E6%AE%B5+%E4%BD%BF%E7%94%A8+%60write%60+%E8%80%8C%E4%B8%8D%E6%98%AF%E9%80%9A%E8%BF%87+%60=%60+%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%97%A7%E7%9A%84%E3%80%81%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%80%BC%E4%B8%8A%E8%B0%83%E7%94%A8+%60drop%60%E3%80%82%0A++++unsafe+%7B+addr_of_mut!((*ptr).name).write(%22Bob%22.to_string());+%7D%0A%0A++++//+%E5%88%9D%E5%A7%8B%E5%8C%96+%60list%60+%E5%AD%97%E6%AE%B5%E5%A6%82%E6%9E%9C%E6%AD%A4%E5%A4%84%E5%AD%98%E5%9C%A8+panic%EF%BC%8C%E5%88%99+%60name%60+%E5%AD%97%E6%AE%B5%E4%B8%AD%E7%9A%84+%60String%60+%E6%B3%84%E6%BC%8F%E3%80%82%0A++++unsafe+%7B+addr_of_mut!((*ptr).list).write(vec!%5B0,+1,+2%5D);+%7D%0A%0A++++//+%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E9%83%BD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8+%60assume_init%60+%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+Foo%E3%80%82%0A++++unsafe+%7B+uninit.assume_init()+%7D%0A%7D;%0A%0Aassert_eq!(%0A++++foo,%0A++++Foo+%7B%0A++++++++name:+%22Bob%22.to_string(),%0A++++++++list:+vec!%5B0,+1,+2%5D%0A++++%7D%0A);%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="layout-1"><a href="#layout-1">Layout</a></h2>
<p><code>MaybeUninit&lt;T&gt;</code> 保证与 <code>T</code> 具有相同的大小、对齐方式和 ABI：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{MaybeUninit, size_of, align_of};
<span class="macro">assert_eq!</span>(size_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), size_of::&lt;u64&gt;());
<span class="macro">assert_eq!</span>(align_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), align_of::&lt;u64&gt;());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::%7BMaybeUninit,+size_of,+align_of%7D;%0Aassert_eq!(size_of::%3CMaybeUninit%3Cu64%3E%3E(),+size_of::%3Cu64%3E());%0Aassert_eq!(align_of::%3CMaybeUninit%3Cu64%3E%3E(),+align_of::%3Cu64%3E());%0A%7D&amp;edition=2021">Run</a></div>
<p>但是请记住，<em>包含</em><code>MaybeUninit&lt;T&gt;</code> 的类型不一定是相同的布局。Rust 通常不保证 <code>Foo&lt;T&gt;</code> 的字段具有与 <code>Foo&lt;U&gt;</code> 相同的顺序，即使 <code>T</code> 和 <code>U</code> 具有相同的大小和对齐方式。</p>
<p>此外，由于任何位值对于 <code>MaybeUninit&lt;T&gt;</code> 都是有效的，因此编译器无法应用 non-zero/niche-filling 优化，从而可能导致更大的大小：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(size_of::&lt;<span class="prelude-ty">Option</span>&lt;bool&gt;&gt;(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(size_of::&lt;<span class="prelude-ty">Option</span>&lt;MaybeUninit&lt;bool&gt;&gt;&gt;(), <span class="number">2</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::%7BMaybeUninit,+size_of%7D;%0Aassert_eq!(size_of::%3COption%3Cbool%3E%3E(),+1);%0Aassert_eq!(size_of::%3COption%3CMaybeUninit%3Cbool%3E%3E%3E(),+2);%0A%7D&amp;edition=2021">Run</a></div>
<p>如果 <code>T</code> 是 FFI 安全的，则 <code>MaybeUninit&lt;T&gt;</code> 也是如此。</p>
<p>虽然 <code>MaybeUninit</code> 是 <code>#[repr(transparent)]</code> (表示它保证与 <code>T</code> 相同的大小，对齐方式和 ABI)，但是这 <em>不会</em> 更改任何先前的警告。
<code>Option&lt;T&gt;</code> 和 <code>Option&lt;MaybeUninit&lt;T&gt;&gt;</code> 可能仍然具有不同的大小，并且包含 <code>T</code> 类型字段的类型的布局 (和大小) 可能与该字段为 <code>MaybeUninit&lt;T&gt;</code> 时不同。
<code>MaybeUninit</code> 是 union 类型，union 上的 <code>#[repr(transparent)]</code> 不稳定 (参见 <a href="https://github.com/rust-lang/rust/issues/60405">跟踪问题</a>).
随着时间的推移，对 union 的 <code>#[repr(transparent)]</code> 的确切保证可能会发生变化，并且 <code>MaybeUninit</code> 可能会或可能不会保留 <code>#[repr(transparent)]</code>。
就是说，<code>MaybeUninit&lt;T&gt;</code> 将总是保证它具有与 <code>T</code> 有相同的大小、对齐方式和 ABI； 只是 <code>MaybeUninit</code> 实现保证的方式可能会演变。</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#270-1273">source</a><a href="#impl-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="const since 1.36.0">const: 1.36.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#290-292">source</a></span><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(val: T) -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>创建一个使用给定值初始化的新 <code>MaybeUninit&lt;T&gt;</code>。
在此函数的返回值上调用 <a href="union.MaybeUninit.html#method.assume_init" title="method core::mem::MaybeUninit::assume_init"><code>assume_init</code></a> 是安全的。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>v: MaybeUninit&lt;Vec&lt;u8&gt;&gt; = MaybeUninit::new(<span class="macro">vec!</span>[<span class="number">42</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+v:+MaybeUninit%3CVec%3Cu8%3E%3E+=+MaybeUninit::new(vec!%5B42%5D);%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.uninit" class="method"><span class="rightside"><span class="since" title="const since 1.36.0">const: 1.36.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#313-315">source</a></span><h4 class="code-header">pub const fn <a href="#method.uninit" class="fn">uninit</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>以未初始化的状态创建一个新的 <code>MaybeUninit&lt;T&gt;</code>。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<p>有关一些示例，请参见 <a href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">类型级文档</a>。</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>v: MaybeUninit&lt;String&gt; = MaybeUninit::uninit();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+v:+MaybeUninit%3CString%3E+=+MaybeUninit::uninit();%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.uninit_array" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96097" title="Tracking issue for const_maybe_uninit_uninit_array">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#350-353">source</a></span><h4 class="code-header">pub fn <a href="#method.uninit_array" class="fn">uninit_array</a>&lt;const N: <a class="primitive" href="../primitive.usize.html">usize</a>&gt;() -&gt; <a class="primitive" href="../primitive.array.html">[Self; N]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96097">#96097</a>)</span></div></span></summary><div class="docblock"><p>在未初始化状态下创建 <code>MaybeUninit&lt;T&gt;</code> 项的新数组。</p>
<p>Note: 在 future Rust 版本中，当 Rust 允许 <a href="https://github.com/rust-lang/rust/issues/76001">内联常量表达式</a> 时，此方法可能变得不必要。</p>
<p>下面的示例可以使用 <code>let mut buf = [const { MaybeUninit::&lt;u8&gt;::uninit() }; 32];</code>。</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_uninit_array, maybe_uninit_slice)]

</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="kw">fn </span>read_into_buffer(ptr: <span class="kw-2">*mut </span>u8, max_len: usize) -&gt; usize;
}

<span class="doccomment">/// 返回实际读取的 (可能较小的) 数据切片
</span><span class="kw">fn </span>read(buf: <span class="kw-2">&amp;mut </span>[MaybeUninit&lt;u8&gt;]) -&gt; <span class="kw-2">&amp;</span>[u8] {
    <span class="kw">unsafe </span>{
        <span class="kw">let </span>len = read_into_buffer(buf.as_mut_ptr() <span class="kw">as </span><span class="kw-2">*mut </span>u8, buf.len());
        MaybeUninit::slice_assume_init_ref(<span class="kw-2">&amp;</span>buf[..len])
    }
}

<span class="kw">let </span><span class="kw-2">mut </span>buf: [MaybeUninit&lt;u8&gt;; <span class="number">32</span>] = MaybeUninit::uninit_array();
<span class="kw">let </span>data = read(<span class="kw-2">&amp;mut </span>buf);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array,+maybe_uninit_slice)%5D%0A%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Aextern+%22C%22+%7B%0A++++fn+read_into_buffer(ptr:+*mut+u8,+max_len:+usize)+-%3E+usize;%0A%7D%0A%0A///+%E8%BF%94%E5%9B%9E%E5%AE%9E%E9%99%85%E8%AF%BB%E5%8F%96%E7%9A%84+(%E5%8F%AF%E8%83%BD%E8%BE%83%E5%B0%8F%E7%9A%84)+%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%0Afn+read(buf:+%26mut+%5BMaybeUninit%3Cu8%3E%5D)+-%3E+%26%5Bu8%5D+%7B%0A++++unsafe+%7B%0A++++++++let+len+=+read_into_buffer(buf.as_mut_ptr()+as+*mut+u8,+buf.len());%0A++++++++MaybeUninit::slice_assume_init_ref(%26buf%5B..len%5D)%0A++++%7D%0A%7D%0A%0Alet+mut+buf:+%5BMaybeUninit%3Cu8%3E;+32%5D+=+MaybeUninit::uninit_array();%0Alet+data+=+read(%26mut+buf);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeroed" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91850" title="Tracking issue for const_maybe_uninit_zeroed">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#395-402">source</a></span><h4 class="code-header">pub fn <a href="#method.zeroed" class="fn">zeroed</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>在未初始化状态下创建新的 <code>MaybeUninit&lt;T&gt;</code>，并用 <code>0</code> 字节填充内存。取决于 <code>T</code> 是否已经进行了正确的初始化。</p>
<p>例如，初始化 <code>MaybeUninit&lt;usize&gt;::zeroed()</code>，但不初始化 <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code>，因为引用不能为空。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>此函数的正确用法：用零初始化结构体，其中结构体的所有字段都可以将位模式 0 保留为有效值。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;(u8, bool)&gt;::zeroed();
<span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(x, (<span class="number">0</span>, <span class="bool-val">false</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+x+=+MaybeUninit::%3C(u8,+bool)%3E::zeroed();%0Alet+x+=+unsafe+%7B+x.assume_init()+%7D;%0Aassert_eq!(x,+(0,+false));%0A%7D&amp;edition=2021">Run</a></div>
<p>该函数的 <em>错误</em> 用法：当 <code>0</code> 不是该类型的有效位模式时，调用 <code>x.zeroed().assume_init()</code>：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">enum </span>NotZero { One = <span class="number">1</span>, Two = <span class="number">2 </span>}

<span class="kw">let </span>x = MaybeUninit::&lt;(u8, NotZero)&gt;::zeroed();
<span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="comment">// 在一个对中，我们创建一个没有有效判别式的 `NotZero`。
// 这是未定义的行为。⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Aenum+NotZero+%7B+One+=+1,+Two+=+2+%7D%0A%0Alet+x+=+MaybeUninit::%3C(u8,+NotZero)%3E::zeroed();%0Alet+x+=+unsafe+%7B+x.assume_init()+%7D;%0A//+%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%9C%89%E6%95%88%E5%88%A4%E5%88%AB%E5%BC%8F%E7%9A%84+%60NotZero%60%E3%80%82%0A//+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const unstable">1.55.0 (const: <a href="https://github.com/rust-lang/rust/issues/63567" title="Tracking issue for const_maybe_uninit_write">unstable</a>)</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#488-492">source</a></span><h4 class="code-header">pub fn <a href="#method.write" class="fn">write</a>(&amp;mut self, val: T) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>设置 <code>MaybeUninit&lt;T&gt;</code> 的值。</p>
<p>这将覆盖任何先前的值而不将其丢弃，因此请注意不要重复使用此两次，除非您要跳过运行析构函数。
为了您的方便，这也将 <code>self</code> 的内容 (现在已安全初始化) 返回变量引用。</p>
<p>由于内容存储在 <code>MaybeUninit</code> 中，如果 MaybeUninit 离开作用域而没有调用到 <a href="union.MaybeUninit.html#method.assume_init" title="method core::mem::MaybeUninit::assume_init"><code>assume_init</code></a>、<a href="union.MaybeUninit.html#method.assume_init_drop" title="method core::mem::MaybeUninit::assume_init_drop"><code>assume_init_drop</code></a> 或类似对象，则不会为内部数据运行析构函数。
接收该函数返回的可变引用的代码需要记住这一点。
Rust 的安全模型认为泄漏是安全的，但它们通常仍然是不可取的。
话虽这么说，但借用引用与其他任何一个借用引用一样，因此为其赋予新的值将摒弃旧的内容。</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>正确使用此方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u8&gt;&gt;::uninit();

{
    <span class="kw">let </span>hello = x.write((<span class="kw-2">&amp;</span><span class="string">b&quot;Hello, world!&quot;</span>).to_vec());
    <span class="comment">// 设置 hello 不会预先分配，但不会泄漏它们
    </span><span class="kw-2">*</span>hello = (<span class="kw-2">&amp;</span><span class="string">b&quot;Hello&quot;</span>).to_vec();
    hello[<span class="number">0</span>] = <span class="string">&#39;h&#39; </span><span class="kw">as </span>u8;
}
<span class="comment">// x 现在初始化：
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>, s.as_slice());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CVec%3Cu8%3E%3E::uninit();%0A%0A%7B%0A++++let+hello+=+x.write((%26b%22Hello,+world!%22).to_vec());%0A++++//+%E8%AE%BE%E7%BD%AE+hello+%E4%B8%8D%E4%BC%9A%E9%A2%84%E5%85%88%E5%88%86%E9%85%8D%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E6%B3%84%E6%BC%8F%E5%AE%83%E4%BB%AC%0A++++*hello+=+(%26b%22Hello%22).to_vec();%0A++++hello%5B0%5D+=+'h'+as+u8;%0A%7D%0A//+x+%E7%8E%B0%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%0Alet+s+=+unsafe+%7B+x.assume_init()+%7D;%0Aassert_eq!(b%22hello%22,+s.as_slice());%0A%7D&amp;edition=2021">Run</a></div>
<p>该方法的这种用法会导致泄漏：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;String&gt;::uninit();

x.write(<span class="string">&quot;Hello&quot;</span>.to_string());
<span class="comment">// 这会泄漏包含的字符串：
</span>x.write(<span class="string">&quot;hello&quot;</span>.to_string());
<span class="comment">// x 现在初始化：
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CString%3E::uninit();%0A%0Ax.write(%22Hello%22.to_string());%0A//+%E8%BF%99%E4%BC%9A%E6%B3%84%E6%BC%8F%E5%8C%85%E5%90%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%0Ax.write(%22hello%22.to_string());%0A//+x+%E7%8E%B0%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%0Alet+s+=+unsafe+%7B+x.assume_init()+%7D;%0A%7D&amp;edition=2021">Run</a></div>
<p>这种方法可以用来避免在某些情况下不安全。下面的例子展示了一个固定大小的 arena 实现的一部分，它提供了固定的引用。
有了 <code>write</code>，我们就可以避免通过裸指针路径来写：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::pin::Pin;
<span class="kw">use </span>core::mem::MaybeUninit;

<span class="kw">struct </span>PinArena&lt;T&gt; {
    memory: Box&lt;[MaybeUninit&lt;T&gt;]&gt;,
    len: usize,
}

<span class="kw">impl </span>&lt;T&gt; PinArena&lt;T&gt; {
    <span class="kw">pub fn </span>capacity(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.memory.len()
    }
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;mut </span><span class="self">self</span>, val: T) -&gt; Pin&lt;<span class="kw-2">&amp;mut </span>T&gt; {
        <span class="kw">if </span><span class="self">self</span>.len &gt;= <span class="self">self</span>.capacity() {
            <span class="macro">panic!</span>(<span class="string">&quot;Attempted to push to a full pin arena!&quot;</span>);
        }
        <span class="kw">let </span>ref_ = <span class="self">self</span>.memory[<span class="self">self</span>.len].write(val);
        <span class="self">self</span>.len += <span class="number">1</span>;
        <span class="kw">unsafe </span>{ Pin::new_unchecked(ref_) }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23core;%0Afn+main()+%7B%0Ause+core::pin::Pin;%0Ause+core::mem::MaybeUninit;%0A%0Astruct+PinArena%3CT%3E+%7B%0A++++memory:+Box%3C%5BMaybeUninit%3CT%3E%5D%3E,%0A++++len:+usize,%0A%7D%0A%0Aimpl+%3CT%3E+PinArena%3CT%3E+%7B%0A++++pub+fn+capacity(%26self)+-%3E+usize+%7B%0A++++++++self.memory.len()%0A++++%7D%0A++++pub+fn+push(%26mut+self,+val:+T)+-%3E+Pin%3C%26mut+T%3E+%7B%0A++++++++if+self.len+%3E=+self.capacity()+%7B%0A++++++++++++panic!(%22Attempted+to+push+to+a+full+pin+arena!%22);%0A++++++++%7D%0A++++++++let+ref_+=+self.memory%5Bself.len%5D.write(val);%0A++++++++self.len+%2B=+1;%0A++++++++unsafe+%7B+Pin::new_unchecked(ref_)+%7D%0A++++%7D%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="const since 1.59.0">const: 1.59.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#528-531">source</a></span><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>获取指向所包含值的指针。
除非初始化 <code>MaybeUninit&lt;T&gt;</code>，否则从该指针读取或将其转换为 quot 是未定义的行为。
写入该指针 (non-transitively) 指向的内存是未定义的行为 (<code>UnsafeCell&lt;T&gt;</code> 内部除外)。</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>正确使用此方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// 在 `MaybeUninit&lt;T&gt;` 中创建引用。可以，因为我们已将其初始化。
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Ax.write(vec!%5B0,+1,+2%5D);%0A//+%E5%9C%A8+%60MaybeUninit%3CT%3E%60+%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E3%80%82%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%B7%B2%E5%B0%86%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0Aassert_eq!(x_vec.len(),+3);%0A%7D&amp;edition=2021">Run</a></div>
<p>这个方法的错误用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用！ 这是未定义的行为。⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Alet+x_vec+=+unsafe+%7B+%26*x.as_ptr()+%7D;%0A//+%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+vector+%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%81+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
<p>(请注意，围绕未初始化数据引用的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/75251" title="Tracking issue for const_maybe_uninit_as_mut_ptr">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#567-570">source</a></span><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>获取指向包含值的可变指针。
除非初始化 <code>MaybeUninit&lt;T&gt;</code>，否则从该指针读取或将其转换为 quot 是未定义的行为。</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>正确使用此方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// 在 `MaybeUninit&lt;Vec&lt;u32&gt;&gt;` 中创建引用。
// 可以，因为我们已将其初始化。
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
x_vec.push(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">4</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Ax.write(vec!%5B0,+1,+2%5D);%0A//+%E5%9C%A8+%60MaybeUninit%3CVec%3Cu32%3E%3E%60+%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E3%80%82%0A//+%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%B7%B2%E5%B0%86%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0Ax_vec.push(3);%0Aassert_eq!(x_vec.len(),+4);%0A%7D&amp;edition=2021">Run</a></div>
<p>这个方法的错误用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用！ 这是未定义的行为。⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Alet+x_vec+=+unsafe+%7B+%26mut+*x.as_mut_ptr()+%7D;%0A//+%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+vector+%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%81+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
<p>(请注意，围绕未初始化数据引用的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init" class="method"><span class="rightside"><span class="since" title="const since 1.59.0">const: 1.59.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#622-629">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init" class="fn">assume_init</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>MaybeUninit&lt;T&gt;</code> 容器中提取值。这是确保数据将被丢弃的好方法，因为生成的 <code>T</code> 受到通常的丢弃处理。</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。
<a href="#initialization-invariant">类型级文档</a> 中包含了有关此初始化不变量的更多信息。</p>
<p>最重要的是，请记住，大多数类型都有额外的不变量，而不仅仅是在类型级别被初始化。
例如，将 <code>1</code> 初始化的 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 视为已初始化 (在当前实现下; 这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须为非空值。</p>
<p>创建这样的 <code>Vec&lt;T&gt;</code> 不会立即导致未定义的行为，但是在大多数安全操作 (包括丢弃操作) 中都将导致未定义的行为。</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<p>正确使用此方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(<span class="bool-val">true</span>);
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(x_init, <span class="bool-val">true</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3Cbool%3E::uninit();%0Ax.write(true);%0Alet+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0Aassert_eq!(x_init,+true);%0A%7D&amp;edition=2021">Run</a></div>
<p>这个方法的错误用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="comment">// `x` 尚未初始化，因此最后一行导致未定义的行为。⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Alet+x_init+=+unsafe+%7B+x.assume_init()+%7D;%0A//+%60x%60+%E5%B0%9A%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%AF%BC%E8%87%B4%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0, const unstable">1.60.0 (const: <a href="https://github.com/rust-lang/rust/issues/63567" title="Tracking issue for const_maybe_uninit_assume_init_read">unstable</a>)</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#692-699">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_read" class="fn">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class="docblock"><p>从 <code>MaybeUninit&lt;T&gt;</code> 容器中读取值。结果 <code>T</code> 受通常的 drop 处理影响。</p>
<p>只要有可能，最好改用 <a href="union.MaybeUninit.html#method.assume_init" title="method core::mem::MaybeUninit::assume_init"><code>assume_init</code></a>，这样可以防止重复 <code>MaybeUninit&lt;T&gt;</code> 的内容。</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。在内容尚未完全初始化时调用此方法会导致未定义的行为。
<a href="#initialization-invariant">类型级文档</a> 中包含了有关此初始化不变量的更多信息。</p>
<p>此外，类似于 <a href="../ptr/fn.read.html" title="fn core::ptr::read"><code>ptr::read</code></a> 函数，该函数创建内容的按位副本，无论所包含的类型是否实现 <a href="../marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a> trait。
当使用数据的多个副本时 (通过多次调用 <code>assume_init_read</code>，或先调用 <code>assume_init_read</code> 再调用 <a href="union.MaybeUninit.html#method.assume_init" title="method core::mem::MaybeUninit::assume_init"><code>assume_init</code></a>)，您有责任确保数据确实可能重复。</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>正确使用此方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;u32&gt;::uninit();
x.write(<span class="number">13</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// `u32` 是 `Copy`，因此我们可能会读取多次。
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">None</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// 复制 `None` 值是可以的，因此我们可能会多次读取。
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3Cu32%3E::uninit();%0Ax.write(13);%0Alet+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A//+%60u32%60+%E6%98%AF+%60Copy%60%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%AF%BB%E5%8F%96%E5%A4%9A%E6%AC%A1%E3%80%82%0Alet+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0Aassert_eq!(x1,+x2);%0A%0Alet+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0Ax.write(None);%0Alet+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0A//+%E5%A4%8D%E5%88%B6+%60None%60+%E5%80%BC%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%8F%96%E3%80%82%0Alet+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0Aassert_eq!(x1,+x2);%0A%7D&amp;edition=2021">Run</a></div>
<p>这个方法的错误用法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]));
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// 现在，我们创建了同一 vector 的两个副本，当它们都被丢弃时，将导致双重释放！</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3COption%3CVec%3Cu32%3E%3E%3E::uninit();%0Ax.write(Some(vec!%5B0,+1,+2%5D));%0Alet+x1+=+unsafe+%7B+x.assume_init_read()+%7D;%0Alet+x2+=+unsafe+%7B+x.assume_init_read()+%7D;%0A//+%E7%8E%B0%E5%9C%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%90%8C%E4%B8%80+vector+%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%89%AF%E6%9C%AC%EF%BC%8C%E5%BD%93%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A2%AB%E4%B8%A2%E5%BC%83%E6%97%B6%EF%BC%8C%E5%B0%86%E5%AF%BC%E8%87%B4%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE%EF%BC%81%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_drop" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#724-729">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_drop" class="fn">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>将包含的值放置到位。</p>
<p>如果您拥有 <code>MaybeUninit</code>，您也可以使用 <a href="union.MaybeUninit.html#method.assume_init" title="method core::mem::MaybeUninit::assume_init"><code>assume_init</code></a> 作为替代。</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。
在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>最重要的是，必须满足类型 <code>T</code> 的所有附加不变量，因为 <code>T</code> (或其变体) 的 <code>Drop</code> 实现可能依赖于此。</p>
<p>例如，将 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 设置为无效但非空的地址使其初始化 (在当前实现下；
这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须非空。
但是，丢弃这样的 <code>Vec&lt;T&gt;</code> 会导致不确定的行为。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_ref" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const since 1.59.0">1.55.0 (const: 1.59.0)</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#786-793">source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init_ref" class="fn">assume_init_ref</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;T</a></h4></section></summary><div class="docblock"><p>获取对包含的值的共享引用。</p>
<p>当我们要访问已初始化但没有 <code>MaybeUninit</code> 所有权 (防止使用 <code>.assume_init()</code>) 的 <code>MaybeUninit</code> 时，这很有用。</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为：取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5><h6 id="正确使用此方法"><a href="#正确使用此方法">正确使用此方法：</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="comment">// 初始化 `x`：
</span>x.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// 现在已知我们的 `MaybeUninit&lt;_&gt;` 已初始化，可以创建对其的共享引用：
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `x` 已初始化。
    </span>x.assume_init_ref()
};
<span class="macro">assert_eq!</span>(x, <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0A//+%E5%88%9D%E5%A7%8B%E5%8C%96+%60x%60%EF%BC%9A%0Ax.write(vec!%5B1,+2,+3%5D);%0A//+%E7%8E%B0%E5%9C%A8%E5%B7%B2%E7%9F%A5%E6%88%91%E4%BB%AC%E7%9A%84+%60MaybeUninit%3C_%3E%60+%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%85%B6%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8%EF%BC%9A%0Alet+x:+%26Vec%3Cu32%3E+=+unsafe+%7B%0A++++//+SAFETY:+%60x%60+%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A++++x.assume_init_ref()%0A%7D;%0Aassert_eq!(x,+%26vec!%5B1,+2,+3%5D);%0A%7D&amp;edition=2021">Run</a></div>
<h6 id="这个方法的错误用法"><a href="#这个方法的错误用法">这个方法的错误用法：</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{ x.assume_init_ref() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用！ 这是未定义的行为。⚠️</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+x+=+MaybeUninit::%3CVec%3Cu32%3E%3E::uninit();%0Alet+x_vec:+%26Vec%3Cu32%3E+=+unsafe+%7B+x.assume_init_ref()+%7D;%0A//+%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+vector+%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%81+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{cell::Cell, mem::MaybeUninit};

<span class="kw">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();
<span class="comment">// 使用 `Cell::set` 初始化 `MaybeUninit`：
</span><span class="kw">unsafe </span>{
    b.assume_init_ref().set(<span class="bool-val">true</span>);
   <span class="comment">// ^^^^^^^^^^^^^^^
   // 引用未初始化的 `Cell&lt;bool&gt;`: UB!
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::%7Bcell::Cell,+mem::MaybeUninit%7D;%0A%0Alet+b+=+MaybeUninit::%3CCell%3Cbool%3E%3E::uninit();%0A//+%E4%BD%BF%E7%94%A8+%60Cell::set%60+%E5%88%9D%E5%A7%8B%E5%8C%96+%60MaybeUninit%60%EF%BC%9A%0Aunsafe+%7B%0A++++b.assume_init_ref().set(true);%0A+++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++//+%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+%60Cell%3Cbool%3E%60:+UB!%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const unstable">1.55.0 (const: unstable)</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#903-910">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_mut" class="fn">assume_init_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>获取所包含值的可变 (unique) 引用。</p>
<p>当我们要访问已初始化但没有 <code>MaybeUninit</code> 所有权 (防止使用 <code>.assume_init()</code>) 的 <code>MaybeUninit</code> 时，这很有用。</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为：取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。
例如，<code>.assume_init_mut()</code> 不能用于初始化 <code>MaybeUninit</code>。</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5><h6 id="正确使用此方法-1"><a href="#正确使用此方法-1">正确使用此方法：</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">extern </span><span class="string">&quot;C&quot; </span>{
    <span class="doccomment">/// 初始化所有输入缓冲区的字节。
    </span><span class="kw">fn </span>initialize_buffer(buf: <span class="kw-2">*mut </span>[u8; <span class="number">1024</span>]);
}

<span class="kw">let </span><span class="kw-2">mut </span>buf = MaybeUninit::&lt;[u8; <span class="number">1024</span>]&gt;::uninit();

<span class="comment">// 初始化 `buf`：
</span><span class="kw">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }
<span class="comment">// 现在我们知道 `buf` 已被初始化，因此我们可以对其进行 `.assume_init()`。
// 但是，使用 `.assume_init()` 可能会触发 1024 字节的 `memcpy`。
// 为了断言我们的缓冲区已经初始化而不复制它，我们将 `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` 升级为 `&amp;mut [u8; 1024]`：
</span><span class="kw">let </span>buf: <span class="kw-2">&amp;mut </span>[u8; <span class="number">1024</span>] = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `buf` 已初始化。
    </span>buf.assume_init_mut()
};

<span class="comment">// 现在我们可以将 `buf` 用作普通切片：
</span>buf.sort_unstable();
<span class="macro">assert!</span>(
    buf.windows(<span class="number">2</span>).all(|pair| pair[<span class="number">0</span>] &lt;= pair[<span class="number">1</span>]),
    <span class="string">&quot;buffer is sorted&quot;</span>,
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unexpected_cfgs)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Aunsafe+extern+%22C%22+fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D)+%7B+*buf+=+%5B0;+1024%5D+%7D%0A%23%5Bcfg(FALSE)%5D%0Aextern+%22C%22+%7B%0A++++///+%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AD%97%E8%8A%82%E3%80%82%0A++++fn+initialize_buffer(buf:+*mut+%5Bu8;+1024%5D);%0A%7D%0A%0Alet+mut+buf+=+MaybeUninit::%3C%5Bu8;+1024%5D%3E::uninit();%0A%0A//+%E5%88%9D%E5%A7%8B%E5%8C%96+%60buf%60%EF%BC%9A%0Aunsafe+%7B+initialize_buffer(buf.as_mut_ptr());+%7D%0A//+%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93+%60buf%60+%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C+%60.assume_init()%60%E3%80%82%0A//+%E4%BD%86%E6%98%AF%EF%BC%8C%E4%BD%BF%E7%94%A8+%60.assume_init()%60+%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A7%A6%E5%8F%91+1024+%E5%AD%97%E8%8A%82%E7%9A%84+%60memcpy%60%E3%80%82%0A//+%E4%B8%BA%E4%BA%86%E6%96%AD%E8%A8%80%E6%88%91%E4%BB%AC%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%80%8C%E4%B8%8D%E5%A4%8D%E5%88%B6%E5%AE%83%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86+%60%26mut+MaybeUninit%3C%5Bu8;+1024%5D%3E%60+%E5%8D%87%E7%BA%A7%E4%B8%BA+%60%26mut+%5Bu8;+1024%5D%60%EF%BC%9A%0Alet+buf:+%26mut+%5Bu8;+1024%5D+=+unsafe+%7B%0A++++//+SAFETY:+%60buf%60+%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A++++buf.assume_init_mut()%0A%7D;%0A%0A//+%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86+%60buf%60+%E7%94%A8%E4%BD%9C%E6%99%AE%E9%80%9A%E5%88%87%E7%89%87%EF%BC%9A%0Abuf.sort_unstable();%0Aassert!(%0A++++buf.windows(2).all(%7Cpair%7C+pair%5B0%5D+%3C=+pair%5B1%5D),%0A++++%22buffer+is+sorted%22,%0A);%0A%7D&amp;edition=2021">Run</a></div>
<h6 id="这个方法的错误用法-1"><a href="#这个方法的错误用法-1">这个方法的错误用法：</a></h6>
<p>您不能使用 <code>.assume_init_mut()</code> 初始化值：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();
<span class="kw">unsafe </span>{
    <span class="kw-2">*</span>b.assume_init_mut() = <span class="bool-val">true</span>;
    <span class="comment">// 我们已经创建了 (mutable) 引用未初始化的 `bool`!
    // 这是未定义的行为。⚠️
</span>}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+b+=+MaybeUninit::%3Cbool%3E::uninit();%0Aunsafe+%7B%0A++++*b.assume_init_mut()+=+true;%0A++++//+%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E4%BA%86+(mutable)+%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84+%60bool%60!%0A++++//+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>例如，您不能 <a href="../../std/io/trait.Read.html"><code>Read</code></a> 进入未初始化的缓冲区：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{io, mem::MaybeUninit};

<span class="kw">fn </span>read_chunk (reader: <span class="kw-2">&amp;</span><span class="lifetime">&#39;_ </span><span class="kw-2">mut </span><span class="kw">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class="number">64</span>]&gt;
{
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = MaybeUninit::&lt;[u8; <span class="number">64</span>]&gt;::uninit();
    reader.read_exact(<span class="kw">unsafe </span>{ buffer.assume_init_mut() })<span class="question-mark">?</span>;
                            <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^^^^
                            // (mutable) 引用到未初始化的内存！
                            // 这是未定义的行为。
    </span><span class="prelude-val">Ok</span>(<span class="kw">unsafe </span>{ buffer.assume_init() })
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::%7Bio,+mem::MaybeUninit%7D;%0A%0Afn+read_chunk+(reader:+%26'_+mut+dyn+io::Read)+-%3E+io::Result%3C%5Bu8;+64%5D%3E%0A%7B%0A++++let+mut+buffer+=+MaybeUninit::%3C%5Bu8;+64%5D%3E::uninit();%0A++++reader.read_exact(unsafe+%7B+buffer.assume_init_mut()+%7D)?;%0A++++++++++++++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A++++++++++++++++++++++++++++//+(mutable)+%E5%BC%95%E7%94%A8%E5%88%B0%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%81%0A++++++++++++++++++++++++++++//+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A++++Ok(unsafe+%7B+buffer.assume_init()+%7D)%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>也不能使用直接字段访问来进行逐字段逐步初始化：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{mem::MaybeUninit, ptr};

<span class="kw">struct </span>Foo {
    a: u32,
    b: u8,
}

<span class="kw">let </span>foo: Foo = <span class="kw">unsafe </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();
    ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().a <span class="kw">as </span><span class="kw-2">*mut </span>u32, <span class="number">1337</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) 引用到未初始化的内存！
                 // 这是未定义的行为。
    </span>ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().b <span class="kw">as </span><span class="kw-2">*mut </span>u8, <span class="number">42</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^
                 // (mutable) 引用到未初始化的内存！
                 // 这是未定义的行为。
    </span>foo.assume_init()
};</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::%7Bmem::MaybeUninit,+ptr%7D;%0A%0Astruct+Foo+%7B%0A++++a:+u32,%0A++++b:+u8,%0A%7D%0A%0Alet+foo:+Foo+=+unsafe+%7B%0A++++let+mut+foo+=+MaybeUninit::%3CFoo%3E::uninit();%0A++++ptr::write(%26mut+foo.assume_init_mut().a+as+*mut+u32,+1337);%0A+++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++//+(mutable)+%E5%BC%95%E7%94%A8%E5%88%B0%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%81%0A+++++++++++++++++//+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A++++ptr::write(%26mut+foo.assume_init_mut().b+as+*mut+u8,+42);%0A+++++++++++++++++//+%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A+++++++++++++++++//+(mutable)+%E5%BC%95%E7%94%A8%E5%88%B0%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%81%0A+++++++++++++++++//+%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A++++foo.assume_init()%0A%7D;%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.array_assume_init" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/96097" title="Tracking issue for const_maybe_uninit_array_assume_init">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#942-952">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.array_assume_init" class="fn">array_assume_init</a>&lt;const N: <a class="primitive" href="../primitive.usize.html">usize</a>&gt;(array: <a class="primitive" href="../primitive.array.html">[Self; N]</a>) -&gt; <a class="primitive" href="../primitive.array.html">[T; N]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_array_assume_init</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96097">#96097</a>)</span></div></span></summary><div class="docblock"><p>从 <code>MaybeUninit</code> 容器数组中提取值。</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>调用者有责任保证数组的所有元素都处于初始化状态。</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_uninit_array)]
#![feature(maybe_uninit_array_assume_init)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>array: [MaybeUninit&lt;i32&gt;; <span class="number">3</span>] = MaybeUninit::uninit_array();
array[<span class="number">0</span>].write(<span class="number">0</span>);
array[<span class="number">1</span>].write(<span class="number">1</span>);
array[<span class="number">2</span>].write(<span class="number">2</span>);

<span class="comment">// SAFETY: 现在安全了，因为我们初始化了所有元素
</span><span class="kw">let </span>array = <span class="kw">unsafe </span>{
    MaybeUninit::array_assume_init(array)
};

<span class="macro">assert_eq!</span>(array, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array)%5D%0A%23!%5Bfeature(maybe_uninit_array_assume_init)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+array:+%5BMaybeUninit%3Ci32%3E;+3%5D+=+MaybeUninit::uninit_array();%0Aarray%5B0%5D.write(0);%0Aarray%5B1%5D.write(1);%0Aarray%5B2%5D.write(2);%0A%0A//+SAFETY:+%E7%8E%B0%E5%9C%A8%E5%AE%89%E5%85%A8%E4%BA%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%0Alet+array+=+unsafe+%7B%0A++++MaybeUninit::array_assume_init(array)%0A%7D;%0A%0Aassert_eq!(array,+%5B0,+1,+2%5D);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_assume_init_ref" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/63569" title="Tracking issue for maybe_uninit_slice">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#968-974">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_assume_init_ref" class="fn">slice_assume_init_ref</a>(slice: &amp;<a class="primitive" href="../primitive.slice.html">[Self]</a>) -&gt; &amp;<a class="primitive" href="../primitive.slice.html">[T]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</span></div></span></summary><div class="docblock"><p>假设所有元素都已初始化，请对其进行切片。</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p>取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 元素确实处于初始化状态。</p>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>有关更多详细信息和示例，请参见 <a href="union.MaybeUninit.html#method.assume_init_ref" title="method core::mem::MaybeUninit::assume_init_ref"><code>assume_init_ref</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_assume_init_mut" class="method"><span class="rightside"><span class="since" title="const unstable">const: unstable</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#990-994">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_assume_init_mut" class="fn">slice_assume_init_mut</a>(slice: &amp;mut <a class="primitive" href="../primitive.slice.html">[Self]</a>) -&gt; &amp;mut <a class="primitive" href="../primitive.slice.html">[T]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</span></div></span></summary><div class="docblock"><p>假设所有元素都已初始化，请为其获取可变切片。</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p>取决于调用者，以确保 <code>MaybeUninit&lt;T&gt;</code> 元素确实处于初始化状态。</p>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>有关更多详细信息和示例，请参见 <a href="union.MaybeUninit.html#method.assume_init_mut" title="method core::mem::MaybeUninit::assume_init_mut"><code>assume_init_mut</code></a>。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/63569" title="Tracking issue for maybe_uninit_slice">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#1000-1002">source</a></span><h4 class="code-header">pub fn <a href="#method.slice_as_ptr" class="fn">slice_as_ptr</a>(this: &amp;[<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class="primitive" href="../primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</span></div></span></summary><div class="docblock"><p>获取指向数组第一个元素的指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_mut_ptr" class="method"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/63569" title="Tracking issue for maybe_uninit_slice">unstable</a></span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#1008-1010">source</a></span><h4 class="code-header">pub fn <a href="#method.slice_as_mut_ptr" class="fn">slice_as_mut_ptr</a>(this: &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class="primitive" href="../primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</span></div></span></summary><div class="docblock"><p>获取指向数组第一个元素的可变指针。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_slice" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1056-1067">source</a><h4 class="code-header">pub fn <a href="#method.write_slice" class="fn">write_slice</a>&lt;'a&gt;(this: &amp;'a mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;], src: &amp;<a class="primitive" href="../primitive.slice.html">[T]</a>) -&gt; &amp;'a mut <a class="primitive" href="../primitive.slice.html">[T]</a><span class="where fmt-newline">where
    T: <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/79995">#79995</a>)</span></div></span></summary><div class="docblock"><p>从 <code>src</code> 复制元素，将 <code>this</code> 现在初始化的内容返回给 <code>this</code> 的资源引用。</p>
<p>如果 <code>T</code> 未实现 <code>Copy</code>，请使用 <a href="union.MaybeUninit.html#method.write_slice_cloned" title="associated function core::mem::MaybeUninit::write_slice_cloned"><code>write_slice_cloned</code></a></p>
<p>这类似于 <a href="../primitive.slice.html#method.copy_from_slice" title="method slice::copy_from_slice"><code>slice::copy_from_slice</code></a>。</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>如果两个切片的长度不同，则此函数将为 panic。</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_write_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>dst = [MaybeUninit::uninit(); <span class="number">32</span>];
<span class="kw">let </span>src = [<span class="number">0</span>; <span class="number">32</span>];

<span class="kw">let </span>init = MaybeUninit::write_slice(<span class="kw-2">&amp;mut </span>dst, <span class="kw-2">&amp;</span>src);

<span class="macro">assert_eq!</span>(init, src);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+dst+=+%5BMaybeUninit::uninit();+32%5D;%0Alet+src+=+%5B0;+32%5D;%0A%0Alet+init+=+MaybeUninit::write_slice(%26mut+dst,+%26src);%0A%0Aassert_eq!(init,+src);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_write_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>vec = Vec::with_capacity(<span class="number">32</span>);
<span class="kw">let </span>src = [<span class="number">0</span>; <span class="number">16</span>];

MaybeUninit::write_slice(<span class="kw-2">&amp;mut </span>vec.spare_capacity_mut()[..src.len()], <span class="kw-2">&amp;</span>src);

<span class="comment">// SAFETY: 我们刚刚将 len 的所有元素复制到了备用容量中，vec 的第一个 src.len() 元素现在有效。
</span><span class="kw">unsafe </span>{
    vec.set_len(src.len());
}

<span class="macro">assert_eq!</span>(vec, src);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+vec+=+Vec::with_capacity(32);%0Alet+src+=+%5B0;+16%5D;%0A%0AMaybeUninit::write_slice(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A%0A//+SAFETY:+%E6%88%91%E4%BB%AC%E5%88%9A%E5%88%9A%E5%B0%86+len+%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BA%86%E5%A4%87%E7%94%A8%E5%AE%B9%E9%87%8F%E4%B8%AD%EF%BC%8Cvec+%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA+src.len()+%E5%85%83%E7%B4%A0%E7%8E%B0%E5%9C%A8%E6%9C%89%E6%95%88%E3%80%82%0Aunsafe+%7B%0A++++vec.set_len(src.len());%0A%7D%0A%0Aassert_eq!(vec,+src);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_slice_cloned" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1116-1158">source</a><h4 class="code-header">pub fn <a href="#method.write_slice_cloned" class="fn">write_slice_cloned</a>&lt;'a&gt;(
    this: &amp;'a mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;],
    src: &amp;<a class="primitive" href="../primitive.slice.html">[T]</a>
) -&gt; &amp;'a mut <a class="primitive" href="../primitive.slice.html">[T]</a><span class="where fmt-newline">where
    T: <a class="trait" href="../clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/79995">#79995</a>)</span></div></span></summary><div class="docblock"><p>将元素从 <code>src</code> 克隆到 <code>this</code>，返回对 <code>this</code> 现在初始化内容的可变引用。
任何已经初始化的元素都不会被丢弃。</p>
<p>如果 <code>T</code> 实现 <code>Copy</code>，请使用 <a href="union.MaybeUninit.html#method.write_slice" title="associated function core::mem::MaybeUninit::write_slice"><code>write_slice</code></a></p>
<p>这类似于 <a href="../primitive.slice.html#method.clone_from_slice" title="method slice::clone_from_slice"><code>slice::clone_from_slice</code></a>，但不会丢弃现有元素。</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>如果两个切片的长度不同，或者 <code>Clone</code> panics 的实现，则此函数将为 panic。</p>
<p>如果存在 panic，将丢弃已经克隆的元素。</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_write_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>dst = [MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit()];
<span class="kw">let </span>src = [<span class="string">&quot;wibbly&quot;</span>.to_string(), <span class="string">&quot;wobbly&quot;</span>.to_string(), <span class="string">&quot;timey&quot;</span>.to_string(), <span class="string">&quot;wimey&quot;</span>.to_string(), <span class="string">&quot;stuff&quot;</span>.to_string()];

<span class="kw">let </span>init = MaybeUninit::write_slice_cloned(<span class="kw-2">&amp;mut </span>dst, <span class="kw-2">&amp;</span>src);

<span class="macro">assert_eq!</span>(init, src);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+dst+=+%5BMaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit(),+MaybeUninit::uninit()%5D;%0Alet+src+=+%5B%22wibbly%22.to_string(),+%22wobbly%22.to_string(),+%22timey%22.to_string(),+%22wimey%22.to_string(),+%22stuff%22.to_string()%5D;%0A%0Alet+init+=+MaybeUninit::write_slice_cloned(%26mut+dst,+%26src);%0A%0Aassert_eq!(init,+src);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_write_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>vec = Vec::with_capacity(<span class="number">32</span>);
<span class="kw">let </span>src = [<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;pretty&quot;</span>, <span class="string">&quot;cool&quot;</span>, <span class="string">&quot;language&quot;</span>];

MaybeUninit::write_slice_cloned(<span class="kw-2">&amp;mut </span>vec.spare_capacity_mut()[..src.len()], <span class="kw-2">&amp;</span>src);

<span class="comment">// SAFETY: 我们刚刚将 len 的所有元素克隆到了备用容量中，vec 的第一个 src.len() 元素现在有效。
</span><span class="kw">unsafe </span>{
    vec.set_len(src.len());
}

<span class="macro">assert_eq!</span>(vec, src);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+vec+=+Vec::with_capacity(32);%0Alet+src+=+%5B%22rust%22,+%22is%22,+%22a%22,+%22pretty%22,+%22cool%22,+%22language%22%5D;%0A%0AMaybeUninit::write_slice_cloned(%26mut+vec.spare_capacity_mut()%5B..src.len()%5D,+%26src);%0A%0A//+SAFETY:+%E6%88%91%E4%BB%AC%E5%88%9A%E5%88%9A%E5%B0%86+len+%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%85%8B%E9%9A%86%E5%88%B0%E4%BA%86%E5%A4%87%E7%94%A8%E5%AE%B9%E9%87%8F%E4%B8%AD%EF%BC%8Cvec+%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA+src.len()+%E5%85%83%E7%B4%A0%E7%8E%B0%E5%9C%A8%E6%9C%89%E6%95%88%E3%80%82%0Aunsafe+%7B%0A++++vec.set_len(src.len());%0A%7D%0A%0Aassert_eq!(vec,+src);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1178-1183">source</a><h4 class="code-header">pub fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93092">#93092</a>)</span></div></span></summary><div class="docblock"><p>将此 <code>MaybeUninit</code> 的内容作为可能未初始化的字节切片返回。</p>
<p>请注意，即使 <code>MaybeUninit</code> 的内容已初始化，该值仍可能包含未初始化的填充字节。</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678_i32</span>;
<span class="kw">let </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes();
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ MaybeUninit::slice_assume_init_ref(uninit_bytes) };
<span class="macro">assert_eq!</span>(bytes, val.to_ne_bytes());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+val+=+0x12345678_i32;%0Alet+uninit+=+MaybeUninit::new(val);%0Alet+uninit_bytes+=+uninit.as_bytes();%0Alet+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(uninit_bytes)+%7D;%0Aassert_eq!(bytes,+val.to_ne_bytes());%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1209-1217">source</a><h4 class="code-header">pub fn <a href="#method.as_bytes_mut" class="fn">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93092">#93092</a>)</span></div></span></summary><div class="docblock"><p>返回此 <code>MaybeUninit</code> 的内容作为可能未初始化字节的可变切片返回。</p>
<p>请注意，即使 <code>MaybeUninit</code> 的内容已初始化，该值仍可能包含未初始化的填充字节。</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678_i32</span>;
<span class="kw">let </span><span class="kw-2">mut </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes_mut();
<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">&quot;little&quot;</span>) {
    uninit_bytes[<span class="number">0</span>].write(<span class="number">0xcd</span>);
} <span class="kw">else </span>{
    uninit_bytes[<span class="number">3</span>].write(<span class="number">0xcd</span>);
}
<span class="kw">let </span>val2 = <span class="kw">unsafe </span>{ uninit.assume_init() };
<span class="macro">assert_eq!</span>(val2, <span class="number">0x123456cd</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+val+=+0x12345678_i32;%0Alet+mut+uninit+=+MaybeUninit::new(val);%0Alet+uninit_bytes+=+uninit.as_bytes_mut();%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++uninit_bytes%5B0%5D.write(0xcd);%0A%7D+else+%7B%0A++++uninit_bytes%5B3%5D.write(0xcd);%0A%7D%0Alet+val2+=+unsafe+%7B+uninit.assume_init()+%7D;%0Aassert_eq!(val2,+0x123456cd);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_bytes" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1239-1243">source</a><h4 class="code-header">pub fn <a href="#method.slice_as_bytes" class="fn">slice_as_bytes</a>(this: &amp;[<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;[<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93092">#93092</a>)</span></div></span></summary><div class="docblock"><p>将此 <code>MaybeUninit</code> 切片的内容作为可能未初始化的字节切片返回。</p>
<p>请注意，即使 <code>MaybeUninit</code> 的内容已初始化，该值仍可能包含未初始化的填充字节。</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>uninit = [MaybeUninit::new(<span class="number">0x1234u16</span>), MaybeUninit::new(<span class="number">0x5678u16</span>)];
<span class="kw">let </span>uninit_bytes = MaybeUninit::slice_as_bytes(<span class="kw-2">&amp;</span>uninit);
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ MaybeUninit::slice_assume_init_ref(<span class="kw-2">&amp;</span>uninit_bytes) };
<span class="kw">let </span>val1 = u16::from_ne_bytes(bytes[<span class="number">0</span>..<span class="number">2</span>].try_into().unwrap());
<span class="kw">let </span>val2 = u16::from_ne_bytes(bytes[<span class="number">2</span>..<span class="number">4</span>].try_into().unwrap());
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>[val1, val2], <span class="kw-2">&amp;</span>[<span class="number">0x1234u16</span>, <span class="number">0x5678u16</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+uninit+=+%5BMaybeUninit::new(0x1234u16),+MaybeUninit::new(0x5678u16)%5D;%0Alet+uninit_bytes+=+MaybeUninit::slice_as_bytes(%26uninit);%0Alet+bytes+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit_bytes)+%7D;%0Alet+val1+=+u16::from_ne_bytes(bytes%5B0..2%5D.try_into().unwrap());%0Alet+val2+=+u16::from_ne_bytes(bytes%5B2..4%5D.try_into().unwrap());%0Aassert_eq!(%26%5Bval1,+val2%5D,+%26%5B0x1234u16,+0x5678u16%5D);%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_bytes_mut" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1268-1272">source</a><h4 class="code-header">pub fn <a href="#method.slice_as_bytes_mut" class="fn">slice_as_bytes_mut</a>(this: &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/93092">#93092</a>)</span></div></span></summary><div class="docblock"><p>将 <code>MaybeUninit</code> 的可变切片的内容作为可能未初始化字节的可变切片返回。</p>
<p>请注意，即使 <code>MaybeUninit</code> 的内容已初始化，该值仍可能包含未初始化的填充字节。</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>uninit = [MaybeUninit::&lt;u16&gt;::uninit(), MaybeUninit::&lt;u16&gt;::uninit()];
<span class="kw">let </span>uninit_bytes = MaybeUninit::slice_as_bytes_mut(<span class="kw-2">&amp;mut </span>uninit);
MaybeUninit::write_slice(uninit_bytes, <span class="kw-2">&amp;</span>[<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x78</span>]);
<span class="kw">let </span>vals = <span class="kw">unsafe </span>{ MaybeUninit::slice_assume_init_ref(<span class="kw-2">&amp;</span>uninit) };
<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">&quot;little&quot;</span>) {
    <span class="macro">assert_eq!</span>(vals, <span class="kw-2">&amp;</span>[<span class="number">0x3412u16</span>, <span class="number">0x7856u16</span>]);
} <span class="kw">else </span>{
    <span class="macro">assert_eq!</span>(vals, <span class="kw-2">&amp;</span>[<span class="number">0x1234u16</span>, <span class="number">0x5678u16</span>]);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_as_bytes,+maybe_uninit_write_slice,+maybe_uninit_slice)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+mut+uninit+=+%5BMaybeUninit::%3Cu16%3E::uninit(),+MaybeUninit::%3Cu16%3E::uninit()%5D;%0Alet+uninit_bytes+=+MaybeUninit::slice_as_bytes_mut(%26mut+uninit);%0AMaybeUninit::write_slice(uninit_bytes,+%26%5B0x12,+0x34,+0x56,+0x78%5D);%0Alet+vals+=+unsafe+%7B+MaybeUninit::slice_assume_init_ref(%26uninit)+%7D;%0Aif+cfg!(target_endian+=+%22little%22)+%7B%0A++++assert_eq!(vals,+%26%5B0x3412u16,+0x7856u16%5D);%0A%7D+else+%7B%0A++++assert_eq!(vals,+%26%5B0x1234u16,+0x5678u16%5D);%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MaybeUninit%3C%5BT;+N%5D%3E" class="impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1275-1292">source</a><a href="#impl-MaybeUninit%3C%5BT;+N%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, const N: <a class="primitive" href="../primitive.usize.html">usize</a>&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="../primitive.array.html">[T; N]</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.transpose" class="method"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#1288-1291">source</a><h4 class="code-header">pub const fn <a href="#method.transpose" class="fn">transpose</a>(self) -&gt; [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;; <a class="primitive" href="../primitive.array.html">N</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array_transpose</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96097">#96097</a>)</span></div></span></summary><div class="docblock"><p>将 <code>MaybeUninit&lt;[T; N]&gt;</code> 移调为 <code>[MaybeUninit&lt;T&gt;; N]</code>。</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_uninit_array_transpose)]

</span><span class="kw">let </span>data: [MaybeUninit&lt;u8&gt;; <span class="number">1000</span>] = MaybeUninit::uninit().transpose();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array_transpose)%5D%0Afn+main()+%7B%0Ause+std::mem::MaybeUninit;%0A%0Alet+data:+%5BMaybeUninit%3Cu8%3E;+1000%5D+=+MaybeUninit::uninit().transpose();%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#255-261">source</a><a href="#impl-Clone-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt; <a class="trait" href="../clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#257-260">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="../clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'>返回值的副本。 <a href="../clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../src/core/clone.rs.html#129-131">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="../clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="../primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>从 <code>source</code> 执行复制分配。 <a href="../clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-MaybeUninit%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.41.0">1.41.0</span> · <a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#264-268">source</a></span><a href="#impl-Debug-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#265-267">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>使用给定的格式化程序格式化该值。 <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><section id="impl-Copy-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/mem/maybe_uninit.rs.html#247">source</a><a href="#impl-Copy-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt; <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../panic/trait.RefUnwindSafe.html" title="trait core::panic::RefUnwindSafe">RefUnwindSafe</a>,</span></h3></section><section id="impl-Send-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Send-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</span></h3></section><section id="impl-Sync-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Sync-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</span></h3></section><section id="impl-Unpin-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Unpin-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</span></h3></section><section id="impl-UnwindSafe-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<span class="where fmt-newline">where
    T: <a class="trait" href="../panic/trait.UnwindSafe.html" title="trait core::panic::UnwindSafe">UnwindSafe</a>,</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/any.rs.html#200-204">source</a><a href="#impl-Any-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="../../src/core/any.rs.html#201-203">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/borrow.rs.html#208-213">source</a><a href="#impl-Borrow%3CT%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="../../src/core/borrow.rs.html#210-212">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>从拥有的值中一成不变地借用。 <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/borrow.rs.html#216-220">source</a><a href="#impl-BorrowMut%3CT%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="../../src/core/borrow.rs.html#217-219">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>从拥有的值中借用。 <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#723-729">source</a><a href="#impl-From%3CT%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#726-728">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>返回未更改的参数。</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#707-719">source</a><a href="#impl-Into%3CU%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#716-718">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>调用 <code>U::from(self)</code>。</p>
<p>也就是说，这种转换是 <code><a href="../convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> 实现选择执行的任何操作。</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#763-773">source</a><a href="#impl-TryFrom%3CU%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>发生转换错误时返回的类型。</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#770-772">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>执行转换。</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-MaybeUninit%3CT%3E" class="impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#748-758">source</a><a href="#impl-TryInto%3CU%3E-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>发生转换错误时返回的类型。</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="../../src/core/convert/mod.rs.html#755-757">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>执行转换。</div></details></div></details></div></section></div></main></body></html>