<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`Result` 类型的错误处理。"><title>core::result - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module result</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">core</a>::<wbr><a class="mod" href="#">result</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../src/core/result.rs.html#1-1977">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>Result</code> 类型的错误处理。</p>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 是用于返回和传播错误的类型。
它是一个带有变体的枚举，<a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(T)</code></a>，表示成功并包含一个值，而 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(E)</code></a> 表示错误并包含一个错误值。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
   <span class="prelude-val">Ok</span>(T),
   <span class="prelude-val">Err</span>(E),
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Ballow(dead_code)%5D%0Aenum+Result%3CT,+E%3E+%7B%0A+++Ok(T),%0A+++Err(E),%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>只要预期到错误并且可以恢复，函数就返回 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a>。在 <code>std</code> crate 中，<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 最主要用于 <a href="../../std/io/index.html">I/O</a>。</p>
<p>返回 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的简单函数可以像这样定义和使用：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(Debug)]
</span><span class="kw">enum </span>Version { Version1, Version2 }

<span class="kw">fn </span>parse_version(header: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;Version, <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str&gt; {
    <span class="kw">match </span>header.get(<span class="number">0</span>) {
        <span class="prelude-val">None </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid header length&quot;</span>),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version1),
        <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>) =&gt; <span class="prelude-val">Ok</span>(Version::Version2),
        <span class="prelude-val">Some</span>(<span class="kw">_</span>) =&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid version&quot;</span>),
    }
}

<span class="kw">let </span>version = parse_version(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">match </span>version {
    <span class="prelude-val">Ok</span>(v) =&gt; <span class="macro">println!</span>(<span class="string">&quot;working with version: {v:?}&quot;</span>),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">&quot;error parsing header: {e:?}&quot;</span>),
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A%23%5Bderive(Debug)%5D%0Aenum+Version+%7B+Version1,+Version2+%7D%0A%0Afn+parse_version(header:+%26%5Bu8%5D)+-%3E+Result%3CVersion,+%26'static+str%3E+%7B%0A++++match+header.get(0)+%7B%0A++++++++None+=%3E+Err(%22invalid+header+length%22),%0A++++++++Some(%261)+=%3E+Ok(Version::Version1),%0A++++++++Some(%262)+=%3E+Ok(Version::Version2),%0A++++++++Some(_)+=%3E+Err(%22invalid+version%22),%0A++++%7D%0A%7D%0A%0Alet+version+=+parse_version(%26%5B1,+2,+3,+4%5D);%0Amatch+version+%7B%0A++++Ok(v)+=%3E+println!(%22working+with+version:+%7Bv:?%7D%22),%0A++++Err(e)+=%3E+println!(%22error+parsing+header:+%7Be:?%7D%22),%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>在简单情况下，在 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 上进行模式匹配非常简单明了，但是 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 附带了一些方便的方法，使使用它更加简洁。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Ok</span>(<span class="number">10</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = <span class="prelude-val">Err</span>(<span class="number">10</span>);

<span class="comment">// `is_ok` 和 `is_err` 方法按照他们说的做。
</span><span class="macro">assert!</span>(good_result.is_ok() &amp;&amp; !good_result.is_err());
<span class="macro">assert!</span>(bad_result.is_err() &amp;&amp; !bad_result.is_ok());

<span class="comment">// `map` 消耗 `Result` 并产生另一个。
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = good_result.map(|i| i + <span class="number">1</span>);
<span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.map(|i| i - <span class="number">1</span>);

<span class="comment">// 使用 `and_then` 继续计算。
</span><span class="kw">let </span>good_result: <span class="prelude-ty">Result</span>&lt;bool, i32&gt; = good_result.and_then(|i| <span class="prelude-val">Ok</span>(i == <span class="number">11</span>));

<span class="comment">// 使用 `or_else` 处理该错误。
</span><span class="kw">let </span>bad_result: <span class="prelude-ty">Result</span>&lt;i32, i32&gt; = bad_result.or_else(|i| <span class="prelude-val">Ok</span>(i + <span class="number">20</span>));

<span class="comment">// 消费结果并用 `unwrap` 返回内容。
</span><span class="kw">let </span>final_awesome_result = good_result.unwrap();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+good_result:+Result%3Ci32,+i32%3E+=+Ok(10);%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+Err(10);%0A%0A//+%60is_ok%60+%E5%92%8C+%60is_err%60+%E6%96%B9%E6%B3%95%E6%8C%89%E7%85%A7%E4%BB%96%E4%BB%AC%E8%AF%B4%E7%9A%84%E5%81%9A%E3%80%82%0Aassert!(good_result.is_ok()+%26%26+!good_result.is_err());%0Aassert!(bad_result.is_err()+%26%26+!bad_result.is_ok());%0A%0A//+%60map%60+%E6%B6%88%E8%80%97+%60Result%60+%E5%B9%B6%E4%BA%A7%E7%94%9F%E5%8F%A6%E4%B8%80%E4%B8%AA%E3%80%82%0Alet+good_result:+Result%3Ci32,+i32%3E+=+good_result.map(%7Ci%7C+i+%2B+1);%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.map(%7Ci%7C+i+-+1);%0A%0A//+%E4%BD%BF%E7%94%A8+%60and_then%60+%E7%BB%A7%E7%BB%AD%E8%AE%A1%E7%AE%97%E3%80%82%0Alet+good_result:+Result%3Cbool,+i32%3E+=+good_result.and_then(%7Ci%7C+Ok(i+==+11));%0A%0A//+%E4%BD%BF%E7%94%A8+%60or_else%60+%E5%A4%84%E7%90%86%E8%AF%A5%E9%94%99%E8%AF%AF%E3%80%82%0Alet+bad_result:+Result%3Ci32,+i32%3E+=+bad_result.or_else(%7Ci%7C+Ok(i+%2B+20));%0A%0A//+%E6%B6%88%E8%B4%B9%E7%BB%93%E6%9E%9C%E5%B9%B6%E7%94%A8+%60unwrap%60+%E8%BF%94%E5%9B%9E%E5%86%85%E5%AE%B9%E3%80%82%0Alet+final_awesome_result+=+good_result.unwrap();%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="必须使用结果"><a href="#必须使用结果">必须使用结果</a></h2>
<p>使用返回值指示错误的一个常见问题是，很容易忽略返回值，从而无法处理错误。
<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 与 <code>#[must_use]</code> 属性一起注解，当忽略 Result 值时会导致编译器发出警告。
这使得 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 对于可能遇到错误但不会返回有用值的函数特别有用。</p>
<p>考虑 <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> trait 为 I/O 类型定义的 <a href="../../std/io/trait.Write.html#method.write_all" title="io::Write::write_all"><code>write_all</code></a> 方法：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">trait </span>Write {
    <span class="kw">fn </span>write_all(<span class="kw-2">&amp;mut </span><span class="self">self</span>, bytes: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), io::Error&gt;;
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::io;%0A%0Atrait+Write+%7B%0A++++fn+write_all(%26mut+self,+bytes:+%26%5Bu8%5D)+-%3E+Result%3C(),+io::Error%3E;%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>Note: <a href="../../std/io/trait.Write.html" title="io::Write"><code>Write</code></a> 的实际定义使用了 <a href="../../std/io/type.Result.html" title="io::Result"><code>io::Result</code></a>，它只是 <code><a href="enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, <a href="../../std/io/struct.Error.html" title="io::Error">io::Error</a>&gt;</code> 的同义词。</em></p>
<p>该方法不会产生值，但是写入可能会失败。处理错误情况至关重要，并且 <em>不要</em> 编写类似以下内容的代码：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
<span class="comment">// 如果 `write_all` 错误，那么我们将永远不会知道，因为返回值将被忽略。
//
</span>file.write_all(<span class="string">b&quot;important message&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D+//+%5Co/%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0A%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0A//+%E5%A6%82%E6%9E%9C+%60write_all%60+%E9%94%99%E8%AF%AF%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%B0%86%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E7%9F%A5%E9%81%93%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E5%B0%86%E8%A2%AB%E5%BF%BD%E7%95%A5%E3%80%82%0A//%0Afile.write_all(b%22important+message%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>如果您确实将其写在 Rust 中，则编译器将向您发出警告 (默认情况下，由 <code>unused_must_use</code> lint 控制)。</p>
<p>相反，如果您不想处理该错误，则可以断言 <a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a> 成功。
如果写入失败，这将为 panic，提供了一条边际有用的消息，指出原因：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>).unwrap();
file.write_all(<span class="string">b&quot;important message&quot;</span>).expect(<span class="string">&quot;failed to write message&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0A%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0Afile.write_all(b%22important+message%22).expect(%22failed+to+write+message%22);%0A%7D&amp;edition=2021">Run</a></div>
<p>您可能还简单地宣称成功：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(file.write_all(<span class="string">b&quot;important message&quot;</span>).is_ok());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Alet+mut+file+=+File::create(%22valuable_data.txt%22).unwrap();%0Aassert!(file.write_all(b%22important+message%22).is_ok());%0A%7D&amp;edition=2021">Run</a></div>
<p>或者使用 <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> 在调用栈中传播错误：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>write_message() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;valuable_data.txt&quot;</span>)<span class="question-mark">?</span>;
    file.write_all(<span class="string">b&quot;important message&quot;</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%23%5Ballow(dead_code)%5D%0Afn+write_message()+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+file+=+File::create(%22valuable_data.txt%22)?;%0A++++file.write_all(b%22important+message%22)?;%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<h2 id="问号运算符"><a href="#问号运算符">问号运算符，<code>?</code></a></h2>
<p>在编写调用许多返回 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 类型的函数的代码时，错误处理可能很乏味。
问号运算符 <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> 在调用栈中隐藏了一些传播错误的样板。</p>
<p>它将替换为：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="comment">// 尽早返回错误
    </span><span class="kw">let </span><span class="kw-2">mut </span>file = <span class="kw">match </span>File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>) {
           <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(e),
           <span class="prelude-val">Ok</span>(f) =&gt; f,
    };
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes()) {
        <span class="kw">return </span><span class="prelude-val">Err</span>(e)
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%0Astruct+Info+%7B%0A++++name:+String,%0A++++age:+i32,%0A++++rating:+i32,%0A%7D%0A%0Afn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++//+%E5%B0%BD%E6%97%A9%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%0A++++let+mut+file+=+match+File::create(%22my_best_friends.txt%22)+%7B%0A+++++++++++Err(e)+=%3E+return+Err(e),%0A+++++++++++Ok(f)+=%3E+f,%0A++++%7D;%0A++++if+let+Err(e)+=+file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++if+let+Err(e)+=+file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++if+let+Err(e)+=+file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())+%7B%0A++++++++return+Err(e)%0A++++%7D%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>有了这个：</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io;

<span class="kw">struct </span>Info {
    name: String,
    age: i32,
    rating: i32,
}

<span class="kw">fn </span>write_info(info: <span class="kw-2">&amp;</span>Info) -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::create(<span class="string">&quot;my_best_friends.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// 尽早返回错误
    </span>file.write_all(<span class="macro">format!</span>(<span class="string">&quot;name: {}\n&quot;</span>, info.name).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;age: {}\n&quot;</span>, info.age).as_bytes())<span class="question-mark">?</span>;
    file.write_all(<span class="macro">format!</span>(<span class="string">&quot;rating: {}\n&quot;</span>, info.rating).as_bytes())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn+main()+%7B%0Ause+std::fs::File;%0Ause+std::io::prelude::*;%0Ause+std::io;%0A%0Astruct+Info+%7B%0A++++name:+String,%0A++++age:+i32,%0A++++rating:+i32,%0A%7D%0A%0Afn+write_info(info:+%26Info)+-%3E+io::Result%3C()%3E+%7B%0A++++let+mut+file+=+File::create(%22my_best_friends.txt%22)?;%0A++++//+%E5%B0%BD%E6%97%A9%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%0A++++file.write_all(format!(%22name:+%7B%7D%5Cn%22,+info.name).as_bytes())?;%0A++++file.write_all(format!(%22age:+%7B%7D%5Cn%22,+info.age).as_bytes())?;%0A++++file.write_all(format!(%22rating:+%7B%7D%5Cn%22,+info.rating).as_bytes())?;%0A++++Ok(())%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p><em>好多了！</em></p>
<p>以 <a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> 结束表达式将导致 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 的展开值，除非结果为 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>，在这种情况下，<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 会从封闭的函数中提前返回。</p>
<p><a href="../ops/trait.Try.html" title="trait core::ops::Try"><code>?</code></a> 可以用在返回 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的函数中，因为它提供了 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 的提前返回。</p>
<h2 id="方法概述"><a href="#方法概述">方法概述</a></h2>
<p>除了使用模式匹配，<a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 还提供了多种不同的方法。</p>
<h3 id="查询变体"><a href="#查询变体">查询变体</a></h3>
<p>如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 分别为 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 或 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>，则 <a href="enum.Result.html#method.is_ok" title="method core::result::Result::is_ok"><code>is_ok</code></a> 和 <a href="enum.Result.html#method.is_err" title="method core::result::Result::is_err"><code>is_err</code></a> 方法返回 <a href="../primitive.bool.html" title="primitive bool"><code>true</code></a>。</p>
<h3 id="用于处理引用的适配器"><a href="#用于处理引用的适配器">用于处理引用的适配器</a></h3>
<ul>
<li><a href="enum.Result.html#method.as_ref" title="method core::result::Result::as_ref"><code>as_ref</code></a> 从 <code>&amp;Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;T, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_mut" title="method core::result::Result::as_mut"><code>as_mut</code></a> 从 <code>&amp;mut Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref" title="method core::result::Result::as_deref"><code>as_deref</code></a> 从 <code>&amp;Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;T::Target, &amp;E&gt;</code></li>
<li><a href="enum.Result.html#method.as_deref_mut" title="method core::result::Result::as_deref_mut"><code>as_deref_mut</code></a> 从 <code>&amp;mut Result&lt;T, E&gt;</code> 转换为 <code>Result&lt;&amp;mut T::Target, &amp;mut E&gt;</code></li>
</ul>
<h3 id="提取包含的值"><a href="#提取包含的值">提取包含的值</a></h3>
<p>当它是 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 变体时，这些方法提取 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 中包含的值。如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 是 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>：</p>
<ul>
<li><a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a> panics 带有提供的自定义消息</li>
<li><a href="enum.Result.html#method.unwrap" title="method core::result::Result::unwrap"><code>unwrap</code></a> panics 带有泛型信息</li>
<li><a href="enum.Result.html#method.unwrap_or" title="method core::result::Result::unwrap_or"><code>unwrap_or</code></a> 返回提供的默认值</li>
<li><a href="enum.Result.html#method.unwrap_or_default" title="method core::result::Result::unwrap_or_default"><code>unwrap_or_default</code></a> 返回类型 <code>T</code> 的默认值 (必须实现 <a href="../default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> trait)</li>
<li><a href="enum.Result.html#method.unwrap_or_else" title="method core::result::Result::unwrap_or_else"><code>unwrap_or_else</code></a> 返回对提供的函数求值的结果</li>
</ul>
<p>panicking 方法 <a href="enum.Result.html#method.expect" title="method core::result::Result::expect"><code>expect</code></a> 和 <a href="enum.Result.html#method.unwrap" title="method core::result::Result::unwrap"><code>unwrap</code></a> 需要 <code>E</code> 来实现 <a href="../fmt/trait.Debug.html" title="trait core::fmt::Debug"><code>Debug</code></a> trait。</p>
<p>当它是 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 变体时，这些方法提取 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 中包含的值。他们需要 <code>T</code> 来实现 <a href="../fmt/trait.Debug.html" title="trait core::fmt::Debug"><code>Debug</code></a> trait。如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 是 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>：</p>
<ul>
<li><a href="enum.Result.html#method.expect_err" title="method core::result::Result::expect_err"><code>expect_err</code></a> panics 带有提供的自定义消息</li>
<li><a href="enum.Result.html#method.unwrap_err" title="method core::result::Result::unwrap_err"><code>unwrap_err</code></a> panics 带有泛型信息</li>
</ul>
<h3 id="转换包含的值"><a href="#转换包含的值">转换包含的值</a></h3>
<p>这些方法将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 转换为 <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a>：</p>
<ul>
<li><a href="enum.Result.html#method.err" title="method core::result::Result::err"><code>err</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;E&gt;</code></a>, mapping <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(e)</code></a> and <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.ok" title="method core::result::Result::ok"><code>ok</code></a> transforms <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> into <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;T&gt;</code></a>, mapping <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a> to <a href="../option/enum.Option.html#variant.Some" title="variant core::option::Option::Some"><code>Some(v)</code></a> and <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err(e)</code></a> to <a href="../option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a></li>
<li><a href="enum.Result.html#method.transpose" title="method core::result::Result::transpose"><code>transpose</code></a> transposes a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> of an <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> into an <a href="../option/enum.Option.html" title="enum core::option::Option"><code>Option</code></a> of a <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a></li>
</ul>
<p>此方法转换 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 变体中包含的值：</p>
<ul>
<li><a href="enum.Result.html#method.map" title="method core::result::Result::map"><code>map</code></a> 通过将提供的函数应用于 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 的包含值并保持 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 值不变，将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 转换为 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;U, E&gt;</code></a></li>
</ul>
<p>此方法转换 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 变体中包含的值：</p>
<ul>
<li><a href="enum.Result.html#method.map_err" title="method core::result::Result::map_err"><code>map_err</code></a> 通过将提供的函数应用于 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 的包含值并保持 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 值不变，将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 转换为 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a></li>
</ul>
<p>这些方法将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 转换为可能不同类型 <code>U</code> 的值：</p>
<ul>
<li><a href="enum.Result.html#method.map_or" title="method core::result::Result::map_or"><code>map_or</code></a> 将提供的函数应用于 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 的包含值，或者如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 是返回提供的默认值
<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a></li>
<li><a href="enum.Result.html#method.map_or_else" title="method core::result::Result::map_or_else"><code>map_or_else</code></a> applies the provided function to the contained value of <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>, or applies the provided default fallback function to the contained value of <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a></li>
</ul>
<h3 id="布尔运算符"><a href="#布尔运算符">布尔运算符</a></h3>
<p>这些方法将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 视为布尔值，其中 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 的作用类似于 <a href="../primitive.bool.html" title="primitive bool"><code>true</code></a>，而 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 的作用类似于 <a href="../primitive.bool.html" title="primitive bool"><code>false</code></a>。这些方法有两类：一类以 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 作为输入，一类以函数作为输入 (延迟评估)。</p>
<p><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a> 和 <a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a> 方法将另一个 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 作为输入，并生成一个 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 作为输出。<a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a> 方法可以生成具有与 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 不同的内部类型 <code>U</code> 的 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;U, E&gt;</code></a> 值。
<a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a> 方法可以生成具有与 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 不同的错误类型 <code>F</code> 的 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a> 值。</p>
<div><table><thead><tr><th>method</th><th>self</th><th>input</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Err(e)</code></td><td>(ignored)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and" title="method core::result::Result::and"><code>and</code></a></td><td><code>Ok(x)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Err(e)</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or" title="method core::result::Result::or"><code>or</code></a></td><td><code>Ok(x)</code></td><td>(ignored)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div>
<p><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a> 和 <a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a> 方法将函数作为输入，并且仅在需要产生新值时才评估函数。<a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a> 方法可以生成一个 [<code>Result&lt;U，E&gt;</code>] 值，该值的内部类型 <code>U</code> 与 [<code>Result&lt;T，E&gt;</code>] 不同。
<a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a> 方法可以生成具有与 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 不同的错误类型 <code>F</code> 的 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, F&gt;</code></a> 值。</p>
<div><table><thead><tr><th>method</th><th>self</th><th>function input</th><th>function result</th><th>output</th></tr></thead><tbody>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Err(e)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Err(e)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.and_then" title="method core::result::Result::and_then"><code>and_then</code></a></td><td><code>Ok(x)</code></td><td><code>x</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Err(d)</code></td><td><code>Err(d)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Err(e)</code></td><td><code>e</code></td><td><code>Ok(y)</code></td><td><code>Ok(y)</code></td></tr>
<tr><td><a href="enum.Result.html#method.or_else" title="method core::result::Result::or_else"><code>or_else</code></a></td><td><code>Ok(x)</code></td><td>(not provided)</td><td>(not evaluated)</td><td><code>Ok(x)</code></td></tr>
</tbody></table>
</div><h3 id="比较运算符"><a href="#比较运算符">比较运算符</a></h3>
<p>如果 <code>T</code> 和 <code>E</code> 都实现 <a href="../cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a>，那么 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 将派生其 <a href="../cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> 实现。
按照此顺序，一个 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 的比较小于任何 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>，而两个 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 或两个 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 的比较与其包含的值分别在 <code>T</code> 或 <code>E</code> 中进行比较。
如果 <code>T</code> 和 <code>E</code> 都实现了 <a href="../cmp/trait.Ord.html" title="trait core::cmp::Ord"><code>Ord</code></a>，那么 <a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 也实现了。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>) &lt; <span class="prelude-val">Err</span>(<span class="number">0</span>));
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;i32, ()&gt; = <span class="prelude-val">Ok</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Ok</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);
<span class="kw">let </span>x: <span class="prelude-ty">Result</span>&lt;(), i32&gt; = <span class="prelude-val">Err</span>(<span class="number">0</span>);
<span class="kw">let </span>y = <span class="prelude-val">Err</span>(<span class="number">1</span>);
<span class="macro">assert!</span>(x &lt; y);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aassert!(Ok(1)+%3C+Err(0));%0Alet+x:+Result%3Ci32,+()%3E+=+Ok(0);%0Alet+y+=+Ok(1);%0Aassert!(x+%3C+y);%0Alet+x:+Result%3C(),+i32%3E+=+Err(0);%0Alet+y+=+Err(1);%0Aassert!(x+%3C+y);%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="迭代-result"><a href="#迭代-result">迭代 <code>Result</code></a></h3>
<p>可以对 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 进行迭代。如果您需要一个条件为空的迭代器，这会很有帮助。迭代器要么产生单个值 (当 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 为 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 时)，要么不产生任何值 (当 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 为 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a> 时)。
例如，如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 是 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok(v)</code></a>，则 <a href="enum.Result.html#method.into_iter" title="method core::result::Result::into_iter"><code>into_iter</code></a> 的作用类似于 <a href="../iter/fn.once.html" title="fn core::iter::once"><code>once(v)</code></a>; 如果 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 是 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>，则它的作用类似于 <a href="../iter/fn.empty.html" title="fn core::iter::empty"><code>empty()</code></a>。</p>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a> 上的迭代器分为三种类型：</p>
<ul>
<li><a href="enum.Result.html#method.into_iter" title="method core::result::Result::into_iter"><code>into_iter</code></a> 消耗 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 并产生包含的值</li>
<li><a href="enum.Result.html#method.iter" title="method core::result::Result::iter"><code>iter</code></a> 对包含的值产生类型为 <code>&amp;T</code> 的不可变引用</li>
<li><a href="enum.Result.html#method.iter_mut" title="method core::result::Result::iter_mut"><code>iter_mut</code></a> 产生一个 <code>&amp;mut T</code> 类型的可变引用到包含的值</li>
</ul>
<p>有关这如何有用的示例，请参见 <a href="../option/index.html#iterating-over-option" title="mod core::option">迭代 <code>Option</code></a>。</p>
<p>您可能希望使用迭代器链来执行可能失败的操作的多个实例，但希望在继续处理成功结果的同时忽略失败。
在本例中，我们利用 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的可迭代特性，使用 <a href="../iter/trait.Iterator.html#method.flatten" title="method core::iter::Iterator::flatten"><code>flatten</code></a> 仅选择 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 值。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>results = <span class="macro">vec!</span>[];
<span class="kw">let </span><span class="kw-2">mut </span>errs = <span class="macro">vec!</span>[];
<span class="kw">let </span>nums: Vec&lt;<span class="kw">_</span>&gt; = [<span class="string">&quot;17&quot;</span>, <span class="string">&quot;not a number&quot;</span>, <span class="string">&quot;99&quot;</span>, <span class="string">&quot;-27&quot;</span>, <span class="string">&quot;768&quot;</span>]
   .into_iter()
   .map(u8::from_str)
   <span class="comment">// 保存原始 `Result` 值的克隆以进行检查
   </span>.inspect(|x| results.push(x.clone()))
   <span class="comment">// 挑战：解释这如何仅捕获 `Err` 值
   </span>.inspect(|x| errs.extend(x.clone().err()))
   .flatten()
   .collect();
<span class="macro">assert_eq!</span>(errs.len(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(nums, [<span class="number">17</span>, <span class="number">99</span>]);
<span class="macro">println!</span>(<span class="string">&quot;results {results:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;errs {errs:?}&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;nums {nums:?}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::str::FromStr;%0Alet+mut+results+=+vec!%5B%5D;%0Alet+mut+errs+=+vec!%5B%5D;%0Alet+nums:+Vec%3C_%3E+=+%5B%2217%22,+%22not+a+number%22,+%2299%22,+%22-27%22,+%22768%22%5D%0A+++.into_iter()%0A+++.map(u8::from_str)%0A+++//+%E4%BF%9D%E5%AD%98%E5%8E%9F%E5%A7%8B+%60Result%60+%E5%80%BC%E7%9A%84%E5%85%8B%E9%9A%86%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%9F%A5%0A+++.inspect(%7Cx%7C+results.push(x.clone()))%0A+++//+%E6%8C%91%E6%88%98%EF%BC%9A%E8%A7%A3%E9%87%8A%E8%BF%99%E5%A6%82%E4%BD%95%E4%BB%85%E6%8D%95%E8%8E%B7+%60Err%60+%E5%80%BC%0A+++.inspect(%7Cx%7C+errs.extend(x.clone().err()))%0A+++.flatten()%0A+++.collect();%0Aassert_eq!(errs.len(),+3);%0Aassert_eq!(nums,+%5B17,+99%5D);%0Aprintln!(%22results+%7Bresults:?%7D%22);%0Aprintln!(%22errs+%7Berrs:?%7D%22);%0Aprintln!(%22nums+%7Bnums:?%7D%22);%0A%7D&amp;edition=2021">Run</a></div>
<h3 id="收集到-result"><a href="#收集到-result">收集到 <code>Result</code></a></h3>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 实现了 <a href="enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E" title="enum core::result::Result"><code>FromIterator</code></a> trait，它允许将 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 值上的迭代器收集到原始 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 值的每个包含值的集合的 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 中，或者如果任何元素是 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>，则为 <a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;err!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="prelude-val">Ok</span>(<span class="number">8</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;Vec&lt;<span class="kw">_</span>&gt;, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().collect();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="macro">vec!</span>[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+v+=+%5BOk(2),+Ok(4),+Err(%22err!%22),+Ok(8)%5D;%0Alet+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0Aassert_eq!(res,+Err(%22err!%22));%0Alet+v+=+%5BOk(2),+Ok(4),+Ok(8)%5D;%0Alet+res:+Result%3CVec%3C_%3E,+%26str%3E+=+v.into_iter().collect();%0Aassert_eq!(res,+Ok(vec!%5B2,+4,+8%5D));%0A%7D&amp;edition=2021">Run</a></div>
<p><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 还实现了 <a href="enum.Result.html#impl-Product%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum core::result::Result"><code>Product</code></a> 和 <a href="enum.Result.html#impl-Sum%3CResult%3CU,+E%3E%3E-for-Result%3CT,+E%3E" title="enum core::result::Result"><code>Sum</code></a> traits，允许对 <a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 值的迭代器提供 <a href="../iter/trait.Iterator.html#method.product" title="method core::iter::Iterator::product"><code>product</code></a> 和 <a href="../iter/trait.Iterator.html#method.sum" title="method core::iter::Iterator::sum"><code>sum</code></a> 方法。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = [<span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>), <span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;foo&quot;</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().sum();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Err</span>(<span class="string">&quot;error!&quot;</span>));
<span class="kw">let </span>v = [<span class="prelude-val">Ok</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">21</span>)];
<span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;i32, <span class="kw-2">&amp;</span>str&gt; = v.into_iter().product();
<span class="macro">assert_eq!</span>(res, <span class="prelude-val">Ok</span>(<span class="number">42</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Alet+v+=+%5BErr(%22error!%22),+Ok(1),+Ok(2),+Ok(3),+Err(%22foo%22)%5D;%0Alet+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().sum();%0Aassert_eq!(res,+Err(%22error!%22));%0Alet+v+=+%5BOk(1),+Ok(2),+Ok(21)%5D;%0Alet+res:+Result%3Ci32,+%26str%3E+=+v.into_iter().product();%0Aassert_eq!(res,+Ok(42));%0A%7D&amp;edition=2021">Run</a></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct core::result::IntoIter">IntoIter</a></div><div class="desc docblock-short"><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 变体中的值的迭代器。</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct core::result::Iter">Iter</a></div><div class="desc docblock-short"><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 变体的引用上的迭代器。</div></li><li><div class="item-name"><a class="struct" href="struct.IterMut.html" title="struct core::result::IterMut">IterMut</a></div><div class="desc docblock-short"><a href="enum.Result.html" title="enum core::result::Result"><code>Result</code></a> 的 <a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a> 变体的可变引用上的迭代器。</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Result.html" title="enum core::result::Result">Result</a></div><div class="desc docblock-short"><code>Result</code> 是代表成功 (<a href="enum.Result.html#variant.Ok" title="variant core::result::Result::Ok"><code>Ok</code></a>) 或失败 (<a href="enum.Result.html#variant.Err" title="variant core::result::Result::Err"><code>Err</code></a>) 的类型。</div></li></ul></section></div></main></body></html>