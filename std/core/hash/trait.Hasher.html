<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="对任意字节流进行散列的 trait。"><title>Hasher in core::hash - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.71.0" data-rustdoc-version="1.71.0-dev" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items1.71.0.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Hasher</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.finish">finish</a></li><li><a href="#tymethod.write">write</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.write_i128">write_i128</a></li><li><a href="#method.write_i16">write_i16</a></li><li><a href="#method.write_i32">write_i32</a></li><li><a href="#method.write_i64">write_i64</a></li><li><a href="#method.write_i8">write_i8</a></li><li><a href="#method.write_isize">write_isize</a></li><li><a href="#method.write_length_prefix">write_length_prefix</a></li><li><a href="#method.write_str">write_str</a></li><li><a href="#method.write_u128">write_u128</a></li><li><a href="#method.write_u16">write_u16</a></li><li><a href="#method.write_u32">write_u32</a></li><li><a href="#method.write_u64">write_u64</a></li><li><a href="#method.write_u8">write_u8</a></li><li><a href="#method.write_usize">write_usize</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In core::hash</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">core</a>::<wbr><a href="index.html">hash</a>::<wbr><a class="trait" href="#">Hasher</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#316-558">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Hasher {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 16 methods</span></summary>    // Required methods
    fn <a href="#tymethod.finish" class="fn">finish</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.u64.html">u64</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.write" class="fn">write</a>(&amp;mut self, bytes: &amp;[<a class="primitive" href="../primitive.u8.html">u8</a>]);

    // Provided methods
    fn <a href="#method.write_u8" class="fn">write_u8</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u8.html">u8</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_u16" class="fn">write_u16</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u16.html">u16</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_u32" class="fn">write_u32</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u32.html">u32</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_u64" class="fn">write_u64</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u64.html">u64</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_u128" class="fn">write_u128</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u128.html">u128</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_usize" class="fn">write_usize</a>(&amp;mut self, i: <a class="primitive" href="../primitive.usize.html">usize</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_i8" class="fn">write_i8</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i8.html">i8</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_i16" class="fn">write_i16</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i16.html">i16</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_i32" class="fn">write_i32</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i32.html">i32</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_i64" class="fn">write_i64</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i64.html">i64</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_i128" class="fn">write_i128</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i128.html">i128</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_isize" class="fn">write_isize</a>(&amp;mut self, i: <a class="primitive" href="../primitive.isize.html">isize</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_length_prefix" class="fn">write_length_prefix</a>(&amp;mut self, len: <a class="primitive" href="../primitive.usize.html">usize</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.write_str" class="fn">write_str</a>(&amp;mut self, s: &amp;<a class="primitive" href="../primitive.str.html">str</a>) { ... }
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>对任意字节流进行散列的 trait。</p>
<p><code>Hasher</code> 的实例通常表示在对数据进行哈希处理时更改的状态。</p>
<p><code>Hasher</code> 提供了一个相当基本的接口，用于检索生成的散列 (使用 <a href="trait.Hasher.html#tymethod.finish" title="method core::hash::Hasher::finish"><code>finish</code></a>)，并将整数和字节片写入实例 (使用 <a href="trait.Hasher.html#tymethod.write" title="method core::hash::Hasher::write"><code>write</code></a> 和 <a href="trait.Hasher.html#method.write_u8" title="method core::hash::Hasher::write_u8"><code>write_u8</code></a> 等)。
大多数情况下，<code>Hasher</code> 实例与 <a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a> trait 结合使用。</p>
<p>这个 trait 不保证如何定义各种 <code>write_*</code> 方法，并且 <a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a> 的实现不应假设它们以一种或另一种方式工作。
例如，您不能假设一个 <a href="trait.Hasher.html#method.write_u32" title="method core::hash::Hasher::write_u32"><code>write_u32</code></a> 调用等同于 <a href="trait.Hasher.html#method.write_u8" title="method core::hash::Hasher::write_u8"><code>write_u8</code></a> 的四个调用。
您也不能假设相邻的 <code>write</code> 调用是合并的，所以有可能，例如，</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>hasher.write(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>]);
hasher.write(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Afn+foo(hasher:+%26mut+impl+std::hash::Hasher)+%7B%0Ahasher.write(%26%5B1,+2%5D);%0Ahasher.write(%26%5B3,+4,+5,+6%5D);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>and</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>hasher.write(<span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
hasher.write(<span class="kw-2">&amp;</span>[<span class="number">5</span>, <span class="number">6</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Afn+foo(hasher:+%26mut+impl+std::hash::Hasher)+%7B%0Ahasher.write(%26%5B1,+2,+3,+4%5D);%0Ahasher.write(%26%5B5,+6%5D);%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
<p>最终产生不同的哈希值。</p>
<p>因此，为了产生相同的散列值，<a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a> 实现必须确保对等价项进行完全相同的调用序列 – 相同的方法具有相同的参数以相同的顺序。</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::hash_map::DefaultHasher;
<span class="kw">use </span>std::hash::Hasher;

<span class="kw">let </span><span class="kw-2">mut </span>hasher = DefaultHasher::new();

hasher.write_u32(<span class="number">1989</span>);
hasher.write_u8(<span class="number">11</span>);
hasher.write_u8(<span class="number">9</span>);
hasher.write(<span class="string">b&quot;Huh?&quot;</span>);

<span class="macro">println!</span>(<span class="string">&quot;Hash is {:x}!&quot;</span>, hasher.finish());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::hash_map::DefaultHasher;%0Ause+std::hash::Hasher;%0A%0Alet+mut+hasher+=+DefaultHasher::new();%0A%0Ahasher.write_u32(1989);%0Ahasher.write_u8(11);%0Ahasher.write_u8(9);%0Ahasher.write(b%22Huh?%22);%0A%0Aprintln!(%22Hash+is+%7B:x%7D!%22,+hasher.finish());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.finish" class="method"><a class="srclink rightside" href="../../src/core/hash/mod.rs.html#338">source</a><h4 class="code-header">fn <a href="#tymethod.finish" class="fn">finish</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>返回到目前为止写入的值的哈希值。</p>
<p>尽管名称如此，该方法不会重置哈希器的内部状态。
额外的 <a href="trait.Hasher.html#tymethod.write" title="method core::hash::Hasher::write"><code>write</code></a> 将从当前值继续。
如果需要开始一个新的哈希值，则必须创建一个新的哈希器。</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::hash_map::DefaultHasher;
<span class="kw">use </span>std::hash::Hasher;

<span class="kw">let </span><span class="kw-2">mut </span>hasher = DefaultHasher::new();
hasher.write(<span class="string">b&quot;Cool!&quot;</span>);

<span class="macro">println!</span>(<span class="string">&quot;Hash is {:x}!&quot;</span>, hasher.finish());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::hash_map::DefaultHasher;%0Ause+std::hash::Hasher;%0A%0Alet+mut+hasher+=+DefaultHasher::new();%0Ahasher.write(b%22Cool!%22);%0A%0Aprintln!(%22Hash+is+%7B:x%7D!%22,+hasher.finish());%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.write" class="method"><a class="srclink rightside" href="../../src/core/hash/mod.rs.html#362">source</a><h4 class="code-header">fn <a href="#tymethod.write" class="fn">write</a>(&amp;mut self, bytes: &amp;[<a class="primitive" href="../primitive.u8.html">u8</a>])</h4></section></summary><div class="docblock"><p>将一些数据写入此 <code>Hasher</code>。</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::hash_map::DefaultHasher;
<span class="kw">use </span>std::hash::Hasher;

<span class="kw">let </span><span class="kw-2">mut </span>hasher = DefaultHasher::new();
<span class="kw">let </span>data = [<span class="number">0x01</span>, <span class="number">0x23</span>, <span class="number">0x45</span>, <span class="number">0x67</span>, <span class="number">0x89</span>, <span class="number">0xab</span>, <span class="number">0xcd</span>, <span class="number">0xef</span>];

hasher.write(<span class="kw-2">&amp;</span>data);

<span class="macro">println!</span>(<span class="string">&quot;Hash is {:x}!&quot;</span>, hasher.finish());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Ause+std::collections::hash_map::DefaultHasher;%0Ause+std::hash::Hasher;%0A%0Alet+mut+hasher+=+DefaultHasher::new();%0Alet+data+=+%5B0x01,+0x23,+0x45,+0x67,+0x89,+0xab,+0xcd,+0xef%5D;%0A%0Ahasher.write(%26data);%0A%0Aprintln!(%22Hash+is+%7B:x%7D!%22,+hasher.finish());%0A%7D&amp;edition=2021">Run</a></div>
<h5 id="给实现者的注意事项"><a href="#给实现者的注意事项">给实现者的注意事项</a></h5>
<p>您通常不应该将长度前缀作为实现此方法的一部分。
在需要它的序列之前调用 <a href="trait.Hasher.html#method.write_length_prefix" title="method core::hash::Hasher::write_length_prefix"><code>Hasher::write_length_prefix</code></a> 取决于 <a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a> 实现。</p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.write_u8" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#367-369">source</a></span><h4 class="code-header">fn <a href="#method.write_u8" class="fn">write_u8</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u8.html">u8</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>u8</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_u16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#373-375">source</a></span><h4 class="code-header">fn <a href="#method.write_u16" class="fn">write_u16</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u16.html">u16</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>u16</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_u32" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#379-381">source</a></span><h4 class="code-header">fn <a href="#method.write_u32" class="fn">write_u32</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u32.html">u32</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>u32</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_u64" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#385-387">source</a></span><h4 class="code-header">fn <a href="#method.write_u64" class="fn">write_u64</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u64.html">u64</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>u64</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_u128" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#391-393">source</a></span><h4 class="code-header">fn <a href="#method.write_u128" class="fn">write_u128</a>(&amp;mut self, i: <a class="primitive" href="../primitive.u128.html">u128</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>u128</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_usize" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#397-399">source</a></span><h4 class="code-header">fn <a href="#method.write_usize" class="fn">write_usize</a>(&amp;mut self, i: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>usize</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_i8" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#404-406">source</a></span><h4 class="code-header">fn <a href="#method.write_i8" class="fn">write_i8</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i8.html">i8</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>i8</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_i16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#410-412">source</a></span><h4 class="code-header">fn <a href="#method.write_i16" class="fn">write_i16</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i16.html">i16</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>i16</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_i32" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#416-418">source</a></span><h4 class="code-header">fn <a href="#method.write_i32" class="fn">write_i32</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i32.html">i32</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>i32</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_i64" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#422-424">source</a></span><h4 class="code-header">fn <a href="#method.write_i64" class="fn">write_i64</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i64.html">i64</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>i64</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_i128" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#428-430">source</a></span><h4 class="code-header">fn <a href="#method.write_i128" class="fn">write_i128</a>(&amp;mut self, i: <a class="primitive" href="../primitive.i128.html">i128</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>i128</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_isize" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#434-436">source</a></span><h4 class="code-header">fn <a href="#method.write_isize" class="fn">write_isize</a>(&amp;mut self, i: <a class="primitive" href="../primitive.isize.html">isize</a>)</h4></section></summary><div class="docblock"><p>将单个 <code>isize</code> 写入此哈希器。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_length_prefix" class="method"><a class="srclink rightside" href="../../src/core/hash/mod.rs.html#487-489">source</a><h4 class="code-header">fn <a href="#method.write_length_prefix" class="fn">write_length_prefix</a>(&amp;mut self, len: <a class="primitive" href="../primitive.usize.html">usize</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>hasher_prefixfree_extras</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96762">#96762</a>)</span></div></span><div class="docblock"><p>将长度前缀写入此哈希器，作为无前缀的一部分。</p>
<p>如果您正在为自定义集合实现 <a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a>，请在将其内容写入此 <code>Hasher</code> 之前调用 this。
这样 <code>(collection![1, 2, 3], collection![4, 5])</code> 和 <code>(collection![1, 2], collection![3, 4, 5])</code> 将为 <code>Hasher</code> 提供不同的值序列</p>
<p><code>impl&lt;T&gt; Hash for [T]</code> 包含对该方法的调用，因此如果您通过其 <code>Hash::hash</code> 方法对切片 (或数组或 vector) 进行哈希处理，您不应该 ** 自己调用 this。</p>
<p>此方法仅用于提供域分离。
如果您想对表示 <em>data</em> 的一部分的 <code>usize</code> 进行散列处理，那么将其传递给 <a href="trait.Hasher.html#method.write_usize" title="method core::hash::Hasher::write_usize"><code>Hasher::write_usize</code></a> 而不是此方法很重要。</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(hasher_prefixfree_extras)]

</span><span class="kw">use </span>std::hash::{Hash, Hasher};
<span class="kw">impl</span>&lt;T: Hash&gt; Hash <span class="kw">for </span>MyCollection&lt;T&gt; {
    <span class="kw">fn </span>hash&lt;H: Hasher&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, state: <span class="kw-2">&amp;mut </span>H) {
        state.write_length_prefix(<span class="self">self</span>.len());
        <span class="kw">for </span>elt <span class="kw">in </span><span class="self">self </span>{
            elt.hash(state);
        }
    }
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hasher_prefixfree_extras)%5D%0A//+%E4%BD%BF%E4%B8%8B%E9%9D%A2%E7%9A%84+%60impl%60+%E9%80%9A%E8%BF%87%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%AD%98%E6%A0%B9%0Afn+main()+%7B%0Astruct+MyCollection%3CT%3E(Option%3CT%3E);%0Aimpl%3CT%3E+MyCollection%3CT%3E+%7B%0A++++fn+len(%26self)+-%3E+usize+%7B+todo!()+%7D%0A%7D%0Aimpl%3C'a,+T%3E+IntoIterator+for+%26'a+MyCollection%3CT%3E+%7B%0A++++type+Item+=+T;%0A++++type+IntoIter+=+std::iter::Empty%3CT%3E;%0A++++fn+into_iter(self)+-%3E+Self::IntoIter+%7B+todo!()+%7D%0A%7D%0A%0Ause+std::hash::%7BHash,+Hasher%7D;%0Aimpl%3CT:+Hash%3E+Hash+for+MyCollection%3CT%3E+%7B%0A++++fn+hash%3CH:+Hasher%3E(%26self,+state:+%26mut+H)+%7B%0A++++++++state.write_length_prefix(self.len());%0A++++++++for+elt+in+self+%7B%0A++++++++++++elt.hash(state);%0A++++++++%7D%0A++++%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<h5 id="给实现者的注意事项-1"><a href="#给实现者的注意事项-1">给实现者的注意事项</a></h5>
<p>如果您确定您的 <code>Hasher</code> 愿意受到 Hash-DoS 攻击，那么您可以考虑跳过以提高性能为名提供的部分或全部 <code>len</code> 的散列。</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_str" class="method"><a class="srclink rightside" href="../../src/core/hash/mod.rs.html#554-557">source</a><h4 class="code-header">fn <a href="#method.write_str" class="fn">write_str</a>(&amp;mut self, s: &amp;<a class="primitive" href="../primitive.str.html">str</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>hasher_prefixfree_extras</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/96762">#96762</a>)</span></div></span><div class="docblock"><p>将单个 <code>str</code> 写入此哈希器。</p>
<p>如果您正在实现 <a href="trait.Hash.html" title="trait core::hash::Hash"><code>Hash</code></a>，您通常不需要像 <code>impl Hash for str</code> 那样调用 this，所以您应该更喜欢它。</p>
<p>这包括前缀自由的域分隔符，所以在调用它之前您不应该 ** 调用 <code>Self::write_length_prefix</code>。</p>
<h5 id="给实现者的注意事项-2"><a href="#给实现者的注意事项-2">给实现者的注意事项</a></h5>
<p>至少有两种合理的默认方式来实现这一点。
哪一个将是默认值尚未确定，所以现在您可能想要专门覆盖它。</p>
<h6 id="一般答案"><a href="#一般答案">一般答案</a></h6>
<p>使用长度前缀来实现它总是正确的:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>write_str(<span class="kw-2">&amp;mut </span><span class="self">self</span>, s: <span class="kw-2">&amp;</span>str) {
    <span class="self">self</span>.write_length_prefix(s.len());
    <span class="self">self</span>.write(s.as_bytes());
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hasher_prefixfree_extras)%5D%0Afn+main()+%7B%0Astruct+Foo;%0Aimpl+std::hash::Hasher+for+Foo+%7B%0Afn+finish(%26self)+-%3E+u64+%7B+unimplemented!()+%7D%0Afn+write(%26mut+self,+_bytes:+%26%5Bu8%5D)+%7B+unimplemented!()+%7D%0Afn+write_str(%26mut+self,+s:+%26str)+%7B%0A++++self.write_length_prefix(s.len());%0A++++self.write(s.as_bytes());%0A%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>而且，如果您的 <code>Hasher</code> 在 <code>usize</code> 块中工作，这可能是一种非常有效的方法，因为任何更复杂的事情最终都可能比仅以长度运行一轮更慢。</p>
<h6 id="如果您的-hasher-按字节工作"><a href="#如果您的-hasher-按字节工作">如果您的 <code>Hasher</code> 按字节工作</a></h6>
<p><code>str</code> 是 UTF-8 的一个好处是 <code>b'\xFF'</code> 字节永远不会发生。这意味着您可以将其，追加，到被散列的字节流并保持前缀自由:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>write_str(<span class="kw-2">&amp;mut </span><span class="self">self</span>, s: <span class="kw-2">&amp;</span>str) {
    <span class="self">self</span>.write(s.as_bytes());
    <span class="self">self</span>.write_u8(<span class="number">0xff</span>);
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(hasher_prefixfree_extras)%5D%0Afn+main()+%7B%0Astruct+Foo;%0Aimpl+std::hash::Hasher+for+Foo+%7B%0Afn+finish(%26self)+-%3E+u64+%7B+unimplemented!()+%7D%0Afn+write(%26mut+self,+_bytes:+%26%5Bu8%5D)+%7B+unimplemented!()+%7D%0Afn+write_str(%26mut+self,+s:+%26str)+%7B%0A++++self.write(s.as_bytes());%0A++++self.write_u8(0xff);%0A%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2021">Run</a></div>
<p>这确实要求您的实现不添加额外的填充，因此通常需要您维护一个缓冲区，仅在该缓冲区已满 (或调用 <code>finish</code>) 时运行一轮。</p>
<p>那是因为如果 <code>write</code> 将数据填充到固定的块大小，它很可能会以这样的方式进行，即 <code>&quot;a&quot;</code> 和 <code>&quot;a\x00&quot;</code> 最终会散列相同的事物序列，从而引入冲突。</p>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-Hasher-for-SipHasher" class="impl"><a class="srclink rightside" href="../../src/core/hash/sip.rs.html#228-243">source</a><a href="#impl-Hasher-for-SipHasher" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a> for <a class="struct" href="struct.SipHasher.html" title="struct core::hash::SipHasher">SipHasher</a></h3></section><section id="impl-Hasher-for-%26mut+H" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.22.0">1.22.0</span> · <a class="srclink" href="../../src/core/hash/mod.rs.html#561-610">source</a></span><a href="#impl-Hasher-for-%26mut+H" class="anchor">§</a><h3 class="code-header">impl&lt;H: <a class="trait" href="trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a> + ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a> for <a class="primitive" href="../primitive.reference.html">&amp;mut H</a></h3></section></div><script src="../../implementors/core/hash/trait.Hasher.js" async></script></section></div></main></body></html>