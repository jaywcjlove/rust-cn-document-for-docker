<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Additions to the prelude - The Rust Edition Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../editions/index.html"><strong aria-hidden="true">1.</strong> What are editions?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../editions/creating-a-new-project.html"><strong aria-hidden="true">1.1.</strong> Creating a new project</a></li><li class="chapter-item expanded "><a href="../editions/transitioning-an-existing-project-to-a-new-edition.html"><strong aria-hidden="true">1.2.</strong> Transitioning an existing project to a new edition</a></li><li class="chapter-item expanded "><a href="../editions/advanced-migrations.html"><strong aria-hidden="true">1.3.</strong> Advanced migrations</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-2015/index.html"><strong aria-hidden="true">2.</strong> Rust 2015</a></li><li class="chapter-item expanded "><a href="../rust-2018/index.html"><strong aria-hidden="true">3.</strong> Rust 2018</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust-2018/path-changes.html"><strong aria-hidden="true">3.1.</strong> Path and module system changes</a></li><li class="chapter-item expanded "><a href="../rust-2018/trait-fn-parameters.html"><strong aria-hidden="true">3.2.</strong> Anonymous trait function parameters deprecated</a></li><li class="chapter-item expanded "><a href="../rust-2018/new-keywords.html"><strong aria-hidden="true">3.3.</strong> New keywords</a></li><li class="chapter-item expanded "><a href="../rust-2018/tyvar-behind-raw-pointer.html"><strong aria-hidden="true">3.4.</strong> Method dispatch for raw pointers to inference variables</a></li><li class="chapter-item expanded "><a href="../rust-2018/cargo.html"><strong aria-hidden="true">3.5.</strong> Cargo changes</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-2021/index.html"><strong aria-hidden="true">4.</strong> Rust 2021</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rust-2021/prelude.html" class="active"><strong aria-hidden="true">4.1.</strong> Additions to the prelude</a></li><li class="chapter-item expanded "><a href="../rust-2021/default-cargo-resolver.html"><strong aria-hidden="true">4.2.</strong> Default Cargo feature resolver</a></li><li class="chapter-item expanded "><a href="../rust-2021/IntoIterator-for-arrays.html"><strong aria-hidden="true">4.3.</strong> IntoIterator for arrays</a></li><li class="chapter-item expanded "><a href="../rust-2021/disjoint-capture-in-closures.html"><strong aria-hidden="true">4.4.</strong> Disjoint capture in closures</a></li><li class="chapter-item expanded "><a href="../rust-2021/panic-macro-consistency.html"><strong aria-hidden="true">4.5.</strong> Panic macro consistency</a></li><li class="chapter-item expanded "><a href="../rust-2021/reserving-syntax.html"><strong aria-hidden="true">4.6.</strong> Reserving syntax</a></li><li class="chapter-item expanded "><a href="../rust-2021/warnings-promoted-to-error.html"><strong aria-hidden="true">4.7.</strong> Warnings promoted to errors</a></li><li class="chapter-item expanded "><a href="../rust-2021/or-patterns-macro-rules.html"><strong aria-hidden="true">4.8.</strong> Or patterns in macro-rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Edition Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/edition-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="additions-to-the-prelude"><a class="header" href="#additions-to-the-prelude">Additions to the prelude</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>The <code>TryInto</code>, <code>TryFrom</code> and <code>FromIterator</code> traits are now part of the prelude.</li>
<li>This might make calls to trait methods ambiguous which could make some code fail to compile.</li>
</ul>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>The <a href="https://doc.rust-lang.org/stable/std/prelude/index.html">prelude of the standard library</a>
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as <code>Option</code>, <code>Vec</code>, <code>drop</code>, and <code>Clone</code>.</p>
<p>The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called <code>example</code> containing a <code>pub struct Option;</code>,
then <code>use example::*;</code> will make <code>Option</code> unambiguously refer to the one from <code>example</code>;
not the one from the standard library.</p>
<p>However, adding a <em>trait</em> to the prelude can break existing code in a subtle way.
For example, a call to <code>x.try_into()</code> which comes from a <code>MyTryInto</code> trait might fail 
to compile if <code>std</code>'s <code>TryInto</code> is also imported, because the call to <code>try_into</code> is now 
ambiguous and could come from either trait. This is the reason we haven't added <code>TryInto</code> 
to the prelude yet, since there is a lot of code that would break this way.</p>
<p>As a solution, Rust 2021 will use a new prelude.
It's identical to the current one, except for three new additions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html"><code>std::convert::TryInto</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html"><code>std::convert::TryFrom</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html"><code>std::iter::FromIterator</code></a></li>
</ul>
<p>The tracking issue <a href="https://github.com/rust-lang/rust/issues/85684">can be found here</a>.</p>
<h2 id="migration"><a class="header" href="#migration">Migration</a></h2>
<p>As a part of the 2021 edition a migration lint, <code>rust_2021_prelude_collisions</code>, has been added in order to aid in automatic migration of Rust 2018 codebases to Rust 2021.</p>
<p>In order to have <code>rustfix</code> migrate your code to be Rust 2021 Edition compatible, run:</p>
<pre><code class="language-sh">cargo fix --edition
</code></pre>
<p>The lint detects cases where functions or methods are called that have the same name as the methods defined in one of the new prelude traits. In some cases, it may rewrite your calls in various ways to ensure that you continue to call the same function you did before.</p>
<p>If you'd like to migrate your code manually or better understand what <code>rustfix</code> is doing, below we've outlined the situations where a migration is needed along with a counter example of when it's not needed.</p>
<h3 id="migration-needed"><a class="header" href="#migration-needed">Migration needed</a></h3>
<h4 id="conflicting-trait-methods"><a class="header" href="#conflicting-trait-methods">Conflicting trait methods</a></h4>
<p>When two traits that are in scope have the same method name, it is ambiguous which trait method should be used. For example:</p>
<pre><pre class="playground"><code class="language-rust">trait MyTrait&lt;A&gt; {
  // This name is the same as the `from_iter` method on the `FromIterator` trait from `std`.  
  fn from_iter(x: Option&lt;A&gt;);
}

impl&lt;T&gt; MyTrait&lt;()&gt; for Vec&lt;T&gt; {
  fn from_iter(_: Option&lt;()&gt;) {}
}

fn main() {
  // Vec&lt;T&gt; implements both `std::iter::FromIterator` and `MyTrait` 
  // If both traits are in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `from_iter` method to call
  &lt;Vec&lt;i32&gt;&gt;::from_iter(None);
}</code></pre></pre>
<p>We can fix this by using fully qualified syntax:</p>
<pre><code class="language-rust ignore">fn main() {
  // Now it is clear which trait method we're referring to
  &lt;Vec&lt;i32&gt; as MyTrait&lt;()&gt;&gt;::from_iter(None);
}</code></pre>
<h4 id="inherent-methods-on-dyn-trait-objects"><a class="header" href="#inherent-methods-on-dyn-trait-objects">Inherent methods on <code>dyn Trait</code> objects</a></h4>
<p>Some users invoke methods on a <code>dyn Trait</code> value where the method name overlaps with a new prelude trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod submodule {
  pub trait MyTrait {
    // This has the same name as `TryInto::try_into`
    fn try_into(&amp;self) -&gt; Result&lt;u32, ()&gt;;
  }
}

// `MyTrait` isn't in scope here and can only be referred to through the path `submodule::MyTrait`
fn bar(f: Box&lt;dyn submodule::MyTrait&gt;) {
  // If `std::convert::TryInto` is in scope (as would be the case in Rust 2021),
  // then it becomes ambiguous which `try_into` method to call
  f.try_into();
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike with static dispatch methods, calling a trait method on a trait object does not require that the trait be in scope. The code above works 
as long as there is no trait in scope with a conflicting method name. When the <code>TryInto</code> trait is in scope (which is the case in Rust 2021),
this causes an ambiguity. Should the call be to <code>MyTrait::try_into</code> or <code>std::convert::TryInto::try_into</code>?</p>
<p>In these cases, we can fix this by adding an additional dereferences or otherwise clarify the type of the method receiver. This ensures that 
the <code>dyn Trait</code> method is chosen, versus the methods from the prelude trait. For example, turning <code>f.try_into()</code> above into <code>(&amp;*f).try_into()</code> 
ensures that we're calling <code>try_into</code> on the <code>dyn MyTrait</code> which can only refer to the <code>MyTrait::try_into</code> method.</p>
<h3 id="no-migration-needed"><a class="header" href="#no-migration-needed">No migration needed</a></h3>
<h4 id="inherent-methods"><a class="header" href="#inherent-methods">Inherent methods</a></h4>
<p>Many types define their own inherent methods with the same name as a trait method. For instance, below the struct <code>MyStruct</code> implements <code>from_iter</code> which shares the same name with the method from the trait <code>FromIterator</code> found in the standard library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::iter::IntoIterator;

struct MyStruct {
  data: Vec&lt;u32&gt;
}

impl MyStruct {
  // This has the same name as `std::iter::FromIterator::from_iter`
  fn from_iter(iter: impl IntoIterator&lt;Item = u32&gt;) -&gt; Self {
    Self {
      data: iter.into_iter().collect()
    }
  }
}

impl std::iter::FromIterator&lt;u32&gt; for MyStruct {
    fn from_iter&lt;I: IntoIterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; Self {
      Self {
        data: iter.into_iter().collect()
      }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Inherent methods always take precedent over trait methods so there's no need for any migration.</p>
<h3 id="implementation-reference"><a class="header" href="#implementation-reference">Implementation Reference</a></h3>
<p>The lint needs to take a couple of factors into account when determining whether or not introducing 2021 Edition to a codebase will cause a name resolution collision (thus breaking the code after changing edition). These factors include:</p>
<ul>
<li>Is the call a <a href="https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls">fully-qualified call</a> or does it use <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">dot-call method syntax</a>?
<ul>
<li>This will affect how the name is resolved due to auto-reference and auto-dereferencing on method call syntax. Manually dereferencing/referencing will allow specifying priority in the case of dot-call method syntax, while fully-qualified call requires specification of the type and the trait name in the method path (e.g. <code>&lt;Type as Trait&gt;::method</code>)</li>
</ul>
</li>
<li>Is this an <a href="https://doc.rust-lang.org/reference/items/implementations.html#inherent-implementations">inherent method</a> or <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementations">a trait method</a>?
<ul>
<li>Inherent methods that take <code>self</code> will take priority over <code>TryInto::try_into</code> as inherent methods take priority over trait methods, but inherent methods that take <code>&amp;self</code> or <code>&amp;mut self</code> won't take priority due to requiring a auto-reference (while <code>TryInto::try_into</code> does not, as it takes <code>self</code>)</li>
</ul>
</li>
<li>Is the origin of this method from <code>core</code>/<code>std</code>? (As the traits can't have a collision with themselves)</li>
<li>Does the given type implement the trait it could have a collision against?</li>
<li>Is the method being called via dynamic dispatch? (i.e. is the <code>self</code> type <code>dyn Trait</code>)
<ul>
<li>If so, trait imports don't affect resolution, and no migration lint needs to occur</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust-2021/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../rust-2021/default-cargo-resolver.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust-2021/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../rust-2021/default-cargo-resolver.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
