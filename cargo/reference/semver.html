<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SemVer Compatibility - Cargo 手册 中文版</title>
        
        


        <!-- Custom HTML head -->
        <style>
    dd {
        margin-bottom: 1em;
    }
</style>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Cargo 手册是使用 Cargo 全面指南教程，Cargo 是 Rust 的包管理器，通过本手册全面了解如何构建 Rust 程序和大型项目。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">简介</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="../getting-started/first-steps.html"><strong aria-hidden="true">1.2.</strong> 初次使用 Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="../guide/index.html"><strong aria-hidden="true">2.</strong> Cargo 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guide/why-cargo-exists.html"><strong aria-hidden="true">2.1.</strong> 为什么存在 Cargo</a></li><li class="chapter-item expanded "><a href="../guide/creating-a-new-project.html"><strong aria-hidden="true">2.2.</strong> 创建一个新的包</a></li><li class="chapter-item expanded "><a href="../guide/working-on-an-existing-project.html"><strong aria-hidden="true">2.3.</strong> 处理现有包</a></li><li class="chapter-item expanded "><a href="../guide/dependencies.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="../guide/project-layout.html"><strong aria-hidden="true">2.5.</strong> 项目布局</a></li><li class="chapter-item expanded "><a href="../guide/cargo-toml-vs-cargo-lock.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml 和 Cargo.lock</a></li><li class="chapter-item expanded "><a href="../guide/tests.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li class="chapter-item expanded "><a href="../guide/continuous-integration.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="../guide/cargo-home.html"><strong aria-hidden="true">2.9.</strong> Cargo Home</a></li><li class="chapter-item expanded "><a href="../guide/build-cache.html"><strong aria-hidden="true">2.10.</strong> 构建缓存</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">3.</strong> Cargo 参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/specifying-dependencies.html"><strong aria-hidden="true">3.1.</strong> 指定依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/overriding-dependencies.html"><strong aria-hidden="true">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/manifest.html"><strong aria-hidden="true">3.2.</strong> 清单格式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/cargo-targets.html"><strong aria-hidden="true">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/workspaces.html"><strong aria-hidden="true">3.3.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="../reference/features.html"><strong aria-hidden="true">3.4.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/features-examples.html"><strong aria-hidden="true">3.4.1.</strong> Features Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/profiles.html"><strong aria-hidden="true">3.5.</strong> Profiles</a></li><li class="chapter-item expanded "><a href="../reference/config.html"><strong aria-hidden="true">3.6.</strong> 设置</a></li><li class="chapter-item expanded "><a href="../reference/environment-variables.html"><strong aria-hidden="true">3.7.</strong> 环境变量</a></li><li class="chapter-item expanded "><a href="../reference/build-scripts.html"><strong aria-hidden="true">3.8.</strong> 构建脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/build-script-examples.html"><strong aria-hidden="true">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/publishing.html"><strong aria-hidden="true">3.9.</strong> 将 crate 发布到 Crates.io</a></li><li class="chapter-item expanded "><a href="../reference/pkgid-spec.html"><strong aria-hidden="true">3.10.</strong> 包 ID 规格</a></li><li class="chapter-item expanded "><a href="../reference/source-replacement.html"><strong aria-hidden="true">3.11.</strong> 更换源</a></li><li class="chapter-item expanded "><a href="../reference/external-tools.html"><strong aria-hidden="true">3.12.</strong> 外部工具</a></li><li class="chapter-item expanded "><a href="../reference/registries.html"><strong aria-hidden="true">3.13.</strong> Registries</a></li><li class="chapter-item expanded "><a href="../reference/resolver.html"><strong aria-hidden="true">3.14.</strong> Dependency Resolution</a></li><li class="chapter-item expanded "><a href="../reference/semver.html" class="active"><strong aria-hidden="true">3.15.</strong> SemVer Compatibility</a></li><li class="chapter-item expanded "><a href="../reference/unstable.html"><strong aria-hidden="true">3.16.</strong> 不稳定功能</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/index.html"><strong aria-hidden="true">4.</strong> Cargo Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/general-commands.html"><strong aria-hidden="true">4.1.</strong> General Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="../commands/cargo-help.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="../commands/cargo-version.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/build-commands.html"><strong aria-hidden="true">4.2.</strong> Build Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-bench.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="../commands/cargo-build.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="../commands/cargo-check.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="../commands/cargo-clean.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="../commands/cargo-doc.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fetch.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="../commands/cargo-fix.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="../commands/cargo-run.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustc.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-rustdoc.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="../commands/cargo-test.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/manifest-commands.html"><strong aria-hidden="true">4.3.</strong> Manifest Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-generate-lockfile.html"><strong aria-hidden="true">4.3.1.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="../commands/cargo-locate-project.html"><strong aria-hidden="true">4.3.2.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="../commands/cargo-metadata.html"><strong aria-hidden="true">4.3.3.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="../commands/cargo-pkgid.html"><strong aria-hidden="true">4.3.4.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="../commands/cargo-tree.html"><strong aria-hidden="true">4.3.5.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="../commands/cargo-update.html"><strong aria-hidden="true">4.3.6.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="../commands/cargo-vendor.html"><strong aria-hidden="true">4.3.7.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="../commands/cargo-verify-project.html"><strong aria-hidden="true">4.3.8.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/package-commands.html"><strong aria-hidden="true">4.4.</strong> Package Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-init.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="../commands/cargo-install.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="../commands/cargo-new.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="../commands/cargo-search.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="../commands/cargo-uninstall.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="../commands/publishing-commands.html"><strong aria-hidden="true">4.5.</strong> Publishing Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../commands/cargo-login.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="../commands/cargo-owner.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="../commands/cargo-package.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="../commands/cargo-publish.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="../commands/cargo-yank.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">5.</strong> 参见问题</a></li><li class="chapter-item expanded "><a href="../appendix/glossary.html"><strong aria-hidden="true">6.</strong> 附录：术语白</a></li><li class="chapter-item expanded "><a href="../appendix/git-authentication.html"><strong aria-hidden="true">7.</strong> Appendix: Git Authentication</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Cargo 手册 中文版</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-cn/cargo-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#semver-compatibility" id="semver-compatibility">SemVer Compatibility</a></h1>
<p>This chapter provides details on what is conventionally considered a
compatible or breaking SemVer change for new releases of a package. See the
<a href="resolver.html#semver-compatibility">SemVer compatibility</a> section for details on what SemVer is, and how Cargo
uses it to ensure compatibility of libraries.</p>
<p>These are only <em>guidelines</em>, and not necessarily hard-and-fast rules that all
projects will obey. The <a href="#change-categories">Change categories</a> section details how this guide
classifies the level and severity of a change. Most of this guide focuses on
changes that will cause <code>cargo</code> and <code>rustc</code> to fail to build something that
previously worked. Almost every change carries some risk that it will
negatively affect the runtime behavior, and for those cases it is usually a
judgment call by the project maintainers whether or not it is a
SemVer-incompatible change.</p>
<p>See also <a href="https://github.com/rust-dev-tools/rust-semverver">rust-semverver</a>, which is an experimental tool that attempts to
programmatically check compatibility rules.</p>
<h2><a class="header" href="#change-categories" id="change-categories">Change categories</a></h2>
<p>All of the policies listed below are categorized by the level of change:</p>
<ul>
<li><strong>Major change</strong>: a change that requires a major SemVer bump.</li>
<li><strong>Minor change</strong>: a change that requires only a minor SemVer bump.</li>
<li><strong>Possibly-breaking change</strong>: a change that some projects may consider major
and others consider minor.</li>
</ul>
<p>The &quot;Possibly-breaking&quot; category covers changes that have the <em>potential</em> to
break during an update, but may not necessarily cause a breakage. The impact
of these changes should be considered carefully. The exact nature will depend
on the change and the principles of the project maintainers.</p>
<p>Some projects may choose to only bump the patch number on a minor change. It
is encouraged to follow the SemVer spec, and only apply bug fixes in patch
releases. However, a bug fix may require an API change that is marked as a
&quot;minor change&quot;, and shouldn't affect compatibility. This guide does not take a
stance on how each individual &quot;minor change&quot; should be treated, as the
difference between minor and patch changes are conventions that depend on the
nature of the change.</p>
<p>Some changes are marked as &quot;minor&quot;, even though they carry the potential risk
of breaking a build. This is for situations where the potential is extremely
low, and the potentially breaking code is unlikely to be written in idiomatic
Rust, or is specifically discouraged from use.</p>
<p>This guide uses the terms &quot;major&quot; and &quot;minor&quot; assuming this relates to a
&quot;1.0.0&quot; release or later. Initial development releases starting with &quot;0.y.z&quot;
can treat changes in &quot;y&quot; as a major release, and &quot;z&quot; as a minor release.
&quot;0.0.z&quot; releases are always major changes. This is because Cargo uses the
convention that only changes in the left-most non-zero component are
considered incompatible.</p>
<ul>
<li>API compatibility
<ul>
<li>Items
<ul>
<li><a href="#item-remove">Major: renaming/moving/removing any public items</a></li>
<li><a href="#item-new">Minor: adding new public items</a></li>
</ul>
</li>
<li>Structs
<ul>
<li><a href="#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></li>
<li><a href="#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></li>
<li><a href="#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></li>
<li><a href="#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>
</ul>
</li>
<li>Enums
<ul>
<li><a href="#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></li>
<li><a href="#enum-fields-new">Major: adding new fields to an enum variant</a></li>
</ul>
</li>
<li>Traits
<ul>
<li><a href="#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></li>
<li><a href="#trait-item-signature">Major: any change to trait item signatures</a></li>
<li><a href="#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></li>
<li><a href="#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></li>
<li><a href="#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></li>
<li><a href="#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></li>
</ul>
</li>
<li>Implementations
<ul>
<li><a href="#impl-item-new">Possibly-breaking change: adding any inherent items</a></li>
</ul>
</li>
<li>Generics
<ul>
<li><a href="#generic-bounds-tighten">Major: tightening generic bounds</a></li>
<li><a href="#generic-bounds-loosen">Minor: loosening generic bounds</a></li>
<li><a href="#generic-new-default">Minor: adding defaulted type parameters</a></li>
<li><a href="#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></li>
<li><a href="#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></li>
<li><a href="#generic-more-generic">Minor: changing a generic type to a more generic type</a></li>
</ul>
</li>
<li>Functions
<ul>
<li><a href="#fn-change-arity">Major: adding/removing function parameters</a></li>
<li><a href="#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></li>
<li><a href="#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></li>
<li><a href="#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></li>
</ul>
</li>
<li>Attributes
<ul>
<li><a href="#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></li>
</ul>
</li>
</ul>
</li>
<li>Tooling and environment compatibility
<ul>
<li><a href="#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></li>
<li><a href="#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></li>
<li>Cargo
<ul>
<li><a href="#cargo-feature-add">Minor: adding a new Cargo feature</a></li>
<li><a href="#cargo-feature-remove">Major: removing a Cargo feature</a></li>
<li><a href="#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></li>
<li><a href="#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></li>
<li><a href="#cargo-change-dep-feature">Minor: changing dependency features</a></li>
<li><a href="#cargo-dep-add">Minor: adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#application-compatibility">Application compatibility</a></li>
</ul>
<h2><a class="header" href="#api-compatibility" id="api-compatibility">API compatibility</a></h2>
<p>All of the examples below contain three parts: the original code, the code
after it has been modified, and an example usage of the code that could appear
in another project. In a minor change, the example usage should successfully
build with both the before and after versions.</p>
<p><a id="item-remove"></a></p>
<h3><a class="header" href="#major-renamingmovingremoving-any-public-items" id="major-renamingmovingremoving-any-public-items">Major: renaming/moving/removing any public items</a></h3>
<p>The absence of a publicly exposed <a href="../../reference/items.html">item</a> will cause any uses of that item to
fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
// ... item has been removed

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: cannot find function `foo`
}
</code></pre>
<p>This includes adding any sort of <a href="../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> which can change which
items or behavior is available based on <a href="../../reference/conditional-compilation.html">conditional compilation</a>.</p>
<p>Mitigating strategies:</p>
<ul>
<li>Mark items to be removed as <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and then remove them at a later
date in a SemVer-breaking release.</li>
<li>Mark renamed items as <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and use a <a href="../../reference/items/use-declarations.html"><code>pub use</code></a> item to re-export
to the old name.</li>
</ul>
<p><a id="item-new"></a></p>
<h3><a class="header" href="#minor-adding-new-public-items" id="minor-adding-new-public-items">Minor: adding new public items</a></h3>
<p>Adding new, public <a href="../../reference/items.html">items</a> is a minor change.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
// ... absence of item

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
// `foo` is not used since it didn't previously exist.
</code></pre>
<p>Note that in some rare cases this can be a <strong>breaking change</strong> due to glob
imports. For example, if you add a new trait, and a project has used a glob
import that brings that trait into scope, and the new trait introduces an
associated item that conflicts with any types it is implemented on, this can
cause a compile-time error due to the ambiguity. Example:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
// ... absence of trait

///////////////////////////////////////////////////////////
// After
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  multiple applicable items in scope
}
</code></pre>
<p>This is not considered a major change because conventionally glob imports are
a known forwards-compatibility hazard. Glob imports of items from external
crates should be avoided.</p>
<p><a id="struct-add-private-field-when-public"></a></p>
<h3><a class="header" href="#major-adding-a-private-struct-field-when-all-current-fields-are-public" id="major-adding-a-private-struct-field-when-all-current-fields-are-public">Major: adding a private struct field when all current fields are public</a></h3>
<p>When a private field is added to a struct that previously had all public fields,
this will break any code that attempts to construct it with a <a href="../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new fields to all-public field structs.</li>
<li>Mark structs as <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<p><a id="struct-add-public-field-when-no-private"></a></p>
<h3><a class="header" href="#major-adding-a-public-field-when-no-private-field-exists" id="major-adding-a-public-field-when-no-private-field-exists">Major: adding a public field when no private field exists</a></h3>
<p>When a public field is added to a struct that has all public fields, this will
break any code that attempts to construct it with a <a href="../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new new fields to all-public field structs.</li>
<li>Mark structs as <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<p><a id="struct-private-fields-with-private"></a></p>
<h3><a class="header" href="#minor-adding-or-removing-private-fields-when-at-least-one-already-exists" id="minor-adding-or-removing-private-fields-when-at-least-one-already-exists">Minor: adding or removing private fields when at least one already exists</a></h3>
<p>It is safe to add or remove private fields from a struct when the struct
already has at least one private field.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>This is safe because existing code cannot use a <a href="../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor exhaustively match its contents.</p>
<p>Note that for tuple structs, this is a <strong>major change</strong> if the tuple contains
public fields, and the addition or removal of a private field changes the
index of any public field.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: is private
}
</code></pre>
<p><a id="struct-tuple-normal-with-private"></a></p>
<h3><a class="header" href="#minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa" id="minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>
<p>Changing a tuple struct to a normal struct (or vice-versa) is safe if all
fields are private.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>This is safe because existing code cannot use a <a href="../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor match its contents.</p>
<p><a id="enum-variant-new"></a></p>
<h3><a class="header" href="#major-adding-new-enum-variants-without-non_exhaustive" id="major-adding-new-enum-variants-without-non_exhaustive">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>
<p>It is a breaking change to add a new enum variant if the enum does not use the
<a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> attribute.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `Variant2` not covered
        E::Variant1 =&gt; {}
    }
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark it as <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>
to force users to use <a href="../../reference/patterns.html#wildcard-pattern">wildcard patterns</a> to catch new variants.</li>
</ul>
<p><a id="enum-fields-new"></a></p>
<h3><a class="header" href="#major-adding-new-fields-to-an-enum-variant" id="major-adding-new-fields-to-an-enum-variant">Major: adding new fields to an enum variant</a></h3>
<p>It is a breaking change to add new fields to an enum variant because all
fields are public, and constructors and matching will fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: missing f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: missing f2
    }
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark the variant as <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>
so that it cannot be constructed or matched without wildcards.
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}
</code></pre>
</li>
<li>When introducing the enum, use an explicit struct as a value, where you can
have control over the field visibility.
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}
</code></pre>
</li>
</ul>
<p><a id="trait-new-item-no-default"></a></p>
<h3><a class="header" href="#major-adding-a-non-defaulted-trait-item" id="major-adding-a-non-defaulted-trait-item">Major: adding a non-defaulted trait item</a></h3>
<p>It is a breaking change to add a non-defaulted item to a trait. This will
break any implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: not all trait items implemented
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Always provide a default implementation or value for new associated trait
items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<p><a id="trait-item-signature"></a></p>
<h3><a class="header" href="#major-any-change-to-trait-item-signatures" id="major-any-change-to-trait-item-signatures">Major: any change to trait item signatures</a></h3>
<p>It is a breaking change to make any change to a trait item signature. This can
break external implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // For sealed traits or normal functions, this would be a minor change
    // because generalizing with generics strictly expands the possible uses.
    // But in this case, trait implementations must use the same signature.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait declaration has 1 type parameter
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Introduce new items with default implementations to cover the new
functionality instead of modifying existing items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<p><a id="trait-new-default-item"></a></p>
<h3><a class="header" href="#possibly-breaking-adding-a-defaulted-trait-item" id="possibly-breaking-adding-a-defaulted-trait-item">Possibly-breaking: adding a defaulted trait item</a></h3>
<p>It is usually safe to add a defaulted trait item. However, this can sometimes
cause a compile error. For example, this can introduce an ambiguity if a
method of the same name exists in another trait.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: multiple applicable items in scope
}
</code></pre>
<p>Note that this ambiguity does <em>not</em> exist for name collisions on <a href="../../reference/items/implementations.html#inherent-implementations">inherent
implementations</a>, as they take priority over trait items.</p>
<p>See <a href="#trait-object-safety">trait-object-safety</a> for a special case to consider
when adding trait items.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<p><a id="trait-object-safety"></a></p>
<h3><a class="header" href="#major-adding-a-trait-item-that-makes-the-trait-non-object-safe" id="major-adding-a-trait-item-that-makes-the-trait-non-object-safe">Major: adding a trait item that makes the trait non-object safe</a></h3>
<p>It is a breaking change to add a trait item that changes the trait to not be
<a href="../../reference/items/traits.html#object-safety">object safe</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // An associated const makes the trait not object-safe.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: cannot be made into an object
}
</code></pre>
<p>It is safe to do the converse (making a non-object safe trait into a safe
one).</p>
<p><a id="trait-new-parameter-no-default"></a></p>
<h3><a class="header" href="#major-adding-a-type-parameter-without-a-default" id="major-adding-a-type-parameter-without-a-default">Major: adding a type parameter without a default</a></h3>
<p>It is a breaking change to add a type parameter without a default to a trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: missing generics
</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>See <a href="#trait-new-parameter-default">adding a defaulted trait type parameter</a>.</li>
</ul>
<p><a id="trait-new-parameter-default"></a></p>
<h3><a class="header" href="#minor-adding-a-defaulted-trait-type-parameter" id="minor-adding-a-defaulted-trait-type-parameter">Minor: adding a defaulted trait type parameter</a></h3>
<p>It is safe to add a type parameter to a trait as long as it has a default.
External implementors will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}
</code></pre>
<p><a id="impl-item-new"></a></p>
<h3><a class="header" href="#possibly-breaking-change-adding-any-inherent-items" id="possibly-breaking-change-adding-any-inherent-items">Possibly-breaking change: adding any inherent items</a></h3>
<p>Usually adding inherent items to an implementation should be safe because
inherent items take priority over trait items. However, in some cases the
collision can cause problems if the name is the same as an implemented trait
item with a different signature.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub struct Foo;

///////////////////////////////////////////////////////////
// After
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: this function takes 0 arguments
}
</code></pre>
<p>Note that if the signatures match, there would not be a compile-time error,
but possibly a silent change in runtime behavior (because it is now executing
a different function).</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<p><a id="generic-bounds-tighten"></a></p>
<h3><a class="header" href="#major-tightening-generic-bounds" id="major-tightening-generic-bounds">Major: tightening generic bounds</a></h3>
<p>It is a breaking change to tighten generic bounds on a type since this can
break users expecting the looser bounds.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied
}
</code></pre>
<p><a id="generic-bounds-loosen"></a></p>
<h3><a class="header" href="#minor-loosening-generic-bounds" id="minor-loosening-generic-bounds">Minor: loosening generic bounds</a></h3>
<p>It is safe to loosen the generic bounds on a type, as it only expands what is
allowed.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}
</code></pre>
<p><a id="generic-new-default"></a></p>
<h3><a class="header" href="#minor-adding-defaulted-type-parameters" id="minor-adding-defaulted-type-parameters">Minor: adding defaulted type parameters</a></h3>
<p>It is safe to add a type parameter to a type as long as it has a default. All
existing references will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}
</code></pre>
<p><a id="generic-generalize-identical"></a></p>
<h3><a class="header" href="#minor-generalizing-a-type-to-use-generics-with-identical-types" id="minor-generalizing-a-type-to-use-generics-with-identical-types">Minor: generalizing a type to use generics (with identical types)</a></h3>
<p>A struct or enum field can change from a concrete type to a generic type
parameter, provided that the change results in an identical type for all
existing use cases. For example, the following change is permitted:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}
</code></pre>
<p>because existing uses of <code>Foo</code> are shorthand for <code>Foo&lt;u8&gt;</code> which yields the
identical field type.</p>
<p><a id="generic-generalize-different"></a></p>
<h3><a class="header" href="#major-generalizing-a-type-to-use-generics-with-possibly-different-types" id="major-generalizing-a-type-to-use-generics-with-possibly-different-types">Major: generalizing a type to use generics (with possibly different types)</a></h3>
<p>Changing a struct or enum field from a concrete type to a generic type
parameter can break if the type can change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: mismatched types
}
</code></pre>
<p><a id="generic-more-generic"></a></p>
<h3><a class="header" href="#minor-changing-a-generic-type-to-a-more-generic-type" id="minor-changing-a-generic-type-to-a-more-generic-type">Minor: changing a generic type to a more generic type</a></h3>
<p>It is safe to change a generic type to a more generic one. For example, the
following adds a generic parameter that defaults to the original type, which
is safe because all existing users will be using the same type for both
fields, the the defaulted parameter does not need to be specified.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}
</code></pre>
<p><a id="fn-change-arity"></a></p>
<h3><a class="header" href="#major-addingremoving-function-parameters" id="major-addingremoving-function-parameters">Major: adding/removing function parameters</a></h3>
<p>Changing the arity of a function is a breaking change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: this function takes 1 argument
}
</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>Introduce a new function with the new signature and possibly
<a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecate</a> the old one.</li>
<li>Introduce functions that take a struct argument, where the struct is built
with the builder pattern. This allows new fields to be added to the struct
in the future.</li>
</ul>
<p><a id="fn-generic-new"></a></p>
<h3><a class="header" href="#possibly-breaking-introducing-a-new-function-type-parameter" id="possibly-breaking-introducing-a-new-function-type-parameter">Possibly-breaking: introducing a new function type parameter</a></h3>
<p>Usually, adding a non-defaulted type parameter is safe, but in some
cases it can be a breaking change:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: this function takes 2 type arguments but only 1 type argument was supplied
}
</code></pre>
<p>However, such explicit calls are rare enough (and can usually be written in
other ways) that this breakage is usually acceptable. One should take into
account how likely it is that the function in question is being called with
explicit type arguments.</p>
<p><a id="fn-generalize-compatible"></a></p>
<h3><a class="header" href="#minor-generalizing-a-function-to-use-generics-supporting-original-type" id="minor-generalizing-a-function-to-use-generics-supporting-original-type">Minor: generalizing a function to use generics (supporting original type)</a></h3>
<p>The type of an parameter to a function, or its return value, can be
<em>generalized</em> to use generics, including by introducing a new type parameter,
as long as it can be instantiated to the original type. For example, the
following changes are allowed:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// After
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}
</code></pre>
<p>because all existing uses are instantiations of the new signature.</p>
<p>Perhaps somewhat surprisingly, generalization applies to trait objects as
well, given that every trait implements itself:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}
</code></pre>
<p>(The use of <code>?Sized</code> is essential; otherwise you couldn't recover the original
signature.)</p>
<p>Introducing generics in this way can potentially create type inference
failures. These are usually rare, and may be acceptable breakage for some
projects, as this can be fixed with additional type annotations.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: type annotations needed
}
</code></pre>
<p><a id="fn-generalize-mismatch"></a></p>
<h3><a class="header" href="#major-generalizing-a-function-to-use-generics-with-type-mismatch" id="major-generalizing-a-function-to-use-generics-with-type-mismatch">Major: generalizing a function to use generics with type mismatch</a></h3>
<p>It is a breaking change to change a function parameter or return type if the
generic type constrains or changes the types previously allowed. For example,
the following adds a generic constraint that may not be satisfied by existing
code:</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec&lt;u8&gt;`
}
</code></pre>
<p><a id="attr-no-std-to-std"></a></p>
<h3><a class="header" href="#major-switching-from-no_std-support-to-requiring-std" id="major-switching-from-no_std-support-to-requiring-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>
<p>If your library specifically supports a <a href="../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> environment, it is a
breaking change to make a new release that requires <code>std</code>.</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// Example usage that will break.
// This will fail to link for no_std targets because they don't have a `std` crate.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>A common idiom to avoid this is to include a <code>std</code> <a href="features.html">Cargo feature</a> that
optionally enables <code>std</code> support, and when the feature is off, the library
can be used in a <code>no_std</code> environment.</li>
</ul>
<h2><a class="header" href="#tooling-and-environment-compatibility" id="tooling-and-environment-compatibility">Tooling and environment compatibility</a></h2>
<p><a id="env-new-rust"></a></p>
<h3><a class="header" href="#possibly-breaking-changing-the-minimum-version-of-rust-required" id="possibly-breaking-changing-the-minimum-version-of-rust-required">Possibly-breaking: changing the minimum version of Rust required</a></h3>
<p>Introducing the use of new features in a new release of Rust can break
projects that are using older versions of Rust. This also includes using new
features in a new release of Cargo, and requiring the use of a nightly-only
feature in a crate that previously worked on stable.</p>
<p>Some projects choose to allow this in a minor release for various reasons. It
is usually relatively easy to update to a newer version of Rust. Rust also has
a rapid 6-week release cycle, and some projects will provide compatibility
within a window of releases (such as the current stable release plus N
previous releases). Just keep in mind that some large projects may not be able
to update their Rust toolchain rapidly.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Use <a href="features.html">Cargo features</a> to make the new features opt-in.</li>
<li>Provide a large window of support for older releases.</li>
<li>Copy the source of new standard library items if possible so that you
can continue to use an older version but take advantage of the new feature.</li>
<li>Provide a separate branch of older minor releases that can receive backports
of important bugfixes.</li>
<li>Keep an eye out for the <a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a> and
<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a> features which provide an opt-in
mechanism for new features. These are currently unstable and only available
in the nightly channel.</li>
</ul>
<p><a id="env-change-requirements"></a></p>
<h3><a class="header" href="#possibly-breaking-changing-the-platform-and-environment-requirements" id="possibly-breaking-changing-the-platform-and-environment-requirements">Possibly-breaking: changing the platform and environment requirements</a></h3>
<p>There is a very wide range of assumptions a library makes about the
environment that it runs in, such as the host platform, operating system
version, available services, filesystem support, etc. It can be a breaking
change if you make a new release that restricts what was previously supported,
for example requiring a newer version of an operating system. These changes
can be difficult to track, since you may not always know if a change breaks in
an environment that is not automatically tested.</p>
<p>Some projects may deem this acceptable breakage, particularly if the breakage
is unlikely for most users, or the project doesn't have the resources to
support all environments. Another notable situation is when a vendor
discontinues support for some hardware or OS, the project may deem it
reasonable to also discontinue support.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Document the platforms and environments you specifically support.</li>
<li>Test your code on a wide range of environments in CI.</li>
</ul>
<h3><a class="header" href="#cargo" id="cargo">Cargo</a></h3>
<p><a id="cargo-feature-add"></a></p>
<h4><a class="header" href="#minor-adding-a-new-cargo-feature" id="minor-adding-a-new-cargo-feature">Minor: adding a new Cargo feature</a></h4>
<p>It is usually safe to add new <a href="features.html">Cargo features</a>. If the feature introduces new
changes that cause a breaking change, this can cause difficulties for projects
that have stricter backwards-compatibility needs. In that scenario, avoid
adding the feature to the &quot;default&quot; list, and possibly document the
consequences of enabling the feature.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<p><a id="cargo-feature-remove"></a></p>
<h4><a class="header" href="#major-removing-a-cargo-feature" id="major-removing-a-cargo-feature">Major: removing a Cargo feature</a></h4>
<p>It is usually a breaking change to remove <a href="features.html">Cargo features</a>. This will cause
an error for any project that enabled the feature.</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Clearly document your features. If there is an internal or experimental
feature, mark it as such, so that users know the status of the feature.</li>
<li>Leave the old feature in <code>Cargo.toml</code>, but otherwise remove its
functionality. Document that the feature is deprecated, and remove it in a
future major SemVer release.</li>
</ul>
<p><a id="cargo-feature-remove-another"></a></p>
<h4><a class="header" href="#major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items" id="major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>
<p>If removing a feature from another feature, this can break existing users if
they are expecting that functionality to be available through that feature.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[features]
default = [&quot;std&quot;]
std = []

###########################################################
# After
[features]
default = []  # This may cause packages to fail if they are expecting std to be enabled.
std = []
</code></pre>
<p><a id="cargo-remove-opt-dep"></a></p>
<h4><a class="header" href="#possibly-breaking-removing-an-optional-dependency" id="possibly-breaking-removing-an-optional-dependency">Possibly-breaking: removing an optional dependency</a></h4>
<p>Removing an optional dependency can break a project using your library because
another project may be enabling that dependency via <a href="features.html">Cargo features</a>.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[dependencies]
curl = { version = &quot;0.4.31&quot;, optional = true }

###########################################################
# After
[dependencies]
# ..curl removed
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Clearly document your features. If the optional dependency is not included
in the documented list of features, then you may decide to consider it safe
to change undocumented entries.</li>
<li>Leave the optional dependency, and just don't use it within your library.</li>
<li>Replace the optional dependency with a <a href="features.html">Cargo feature</a> that does nothing,
and document that it is deprecated.</li>
<li>Use high-level features which enable optional dependencies, and document
those as the preferred way to enable the extended functionality. For
example, if your library has optional support for something like
&quot;networking&quot;, create a generic feature name &quot;networking&quot; that enables the
optional dependencies necessary to implement &quot;networking&quot;. Then document the
&quot;networking&quot; feature.</li>
</ul>
<p><a id="cargo-change-dep-feature"></a></p>
<h4><a class="header" href="#minor-changing-dependency-features" id="minor-changing-dependency-features">Minor: changing dependency features</a></h4>
<p>It is usually safe to change the features on a dependency, as long as the
feature does not introduce a breaking change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;small_rng&quot;] }


###########################################################
# After
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p><a id="cargo-dep-add"></a></p>
<h4><a class="header" href="#minor-adding-dependencies" id="minor-adding-dependencies">Minor: adding dependencies</a></h4>
<p>It is usually safe to add new dependencies, as long as the new dependency
does not introduce new requirements that result in a breaking change.
For example, adding a new dependency that requires nightly in a project
that previously worked on stable is a major change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
# ..empty

###########################################################
# After
[dependencies]
log = &quot;0.4.11&quot;
</code></pre>
<h2><a class="header" href="#application-compatibility" id="application-compatibility">Application compatibility</a></h2>
<p>Cargo projects may also include executable binaries which have their own
interfaces (such as a CLI interface, OS-level interaction, etc.). Since these
are part of the Cargo package, they often use and share the same version as
the package. You will need to decide if and how you want to employ a SemVer
contract with your users in the changes you make to your application. The
potential breaking and compatible changes to an application are too numerous
to list, so you are encouraged to use the spirit of the <a href="https://semver.org/">SemVer</a> spec to guide
your decisions on how to apply versioning to your application, or at least
document what your commitments are.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../reference/resolver.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../reference/unstable.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../reference/resolver.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../reference/unstable.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../language.js"></script>
        

        

    </body>
</html>
