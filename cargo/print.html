<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cargo 手册 中文版</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <style>
    dd {
        margin-bottom: 1em;
    }
</style>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Cargo 手册是使用 Cargo 全面指南教程，Cargo 是 Rust 的包管理器，通过本手册全面了解如何构建 Rust 程序和大型项目。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="getting-started/first-steps.html"><strong aria-hidden="true">1.2.</strong> 初次使用 Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="guide/index.html"><strong aria-hidden="true">2.</strong> Cargo 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/why-cargo-exists.html"><strong aria-hidden="true">2.1.</strong> 为什么存在 Cargo</a></li><li class="chapter-item expanded "><a href="guide/creating-a-new-project.html"><strong aria-hidden="true">2.2.</strong> 创建一个新的包</a></li><li class="chapter-item expanded "><a href="guide/working-on-an-existing-project.html"><strong aria-hidden="true">2.3.</strong> 处理现有包</a></li><li class="chapter-item expanded "><a href="guide/dependencies.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="guide/project-layout.html"><strong aria-hidden="true">2.5.</strong> 项目布局</a></li><li class="chapter-item expanded "><a href="guide/cargo-toml-vs-cargo-lock.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml 和 Cargo.lock</a></li><li class="chapter-item expanded "><a href="guide/tests.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li class="chapter-item expanded "><a href="guide/continuous-integration.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="guide/cargo-home.html"><strong aria-hidden="true">2.9.</strong> Cargo Home</a></li><li class="chapter-item expanded "><a href="guide/build-cache.html"><strong aria-hidden="true">2.10.</strong> 构建缓存</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">3.</strong> Cargo 参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/specifying-dependencies.html"><strong aria-hidden="true">3.1.</strong> 指定依赖</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/overriding-dependencies.html"><strong aria-hidden="true">3.1.1.</strong> Overriding Dependencies</a></li></ol></li><li class="chapter-item expanded "><a href="reference/manifest.html"><strong aria-hidden="true">3.2.</strong> 清单格式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/cargo-targets.html"><strong aria-hidden="true">3.2.1.</strong> Cargo Targets</a></li></ol></li><li class="chapter-item expanded "><a href="reference/workspaces.html"><strong aria-hidden="true">3.3.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="reference/features.html"><strong aria-hidden="true">3.4.</strong> Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/features-examples.html"><strong aria-hidden="true">3.4.1.</strong> Features Examples</a></li></ol></li><li class="chapter-item expanded "><a href="reference/profiles.html"><strong aria-hidden="true">3.5.</strong> Profiles</a></li><li class="chapter-item expanded "><a href="reference/config.html"><strong aria-hidden="true">3.6.</strong> 设置</a></li><li class="chapter-item expanded "><a href="reference/environment-variables.html"><strong aria-hidden="true">3.7.</strong> 环境变量</a></li><li class="chapter-item expanded "><a href="reference/build-scripts.html"><strong aria-hidden="true">3.8.</strong> 构建脚本</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/build-script-examples.html"><strong aria-hidden="true">3.8.1.</strong> Build Script Examples</a></li></ol></li><li class="chapter-item expanded "><a href="reference/publishing.html"><strong aria-hidden="true">3.9.</strong> 将 crate 发布到 Crates.io</a></li><li class="chapter-item expanded "><a href="reference/pkgid-spec.html"><strong aria-hidden="true">3.10.</strong> 包 ID 规格</a></li><li class="chapter-item expanded "><a href="reference/source-replacement.html"><strong aria-hidden="true">3.11.</strong> 更换源</a></li><li class="chapter-item expanded "><a href="reference/external-tools.html"><strong aria-hidden="true">3.12.</strong> 外部工具</a></li><li class="chapter-item expanded "><a href="reference/registries.html"><strong aria-hidden="true">3.13.</strong> Registries</a></li><li class="chapter-item expanded "><a href="reference/resolver.html"><strong aria-hidden="true">3.14.</strong> Dependency Resolution</a></li><li class="chapter-item expanded "><a href="reference/semver.html"><strong aria-hidden="true">3.15.</strong> SemVer Compatibility</a></li><li class="chapter-item expanded "><a href="reference/unstable.html"><strong aria-hidden="true">3.16.</strong> 不稳定功能</a></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">4.</strong> Cargo Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/general-commands.html"><strong aria-hidden="true">4.1.</strong> General Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo.html"><strong aria-hidden="true">4.1.1.</strong> cargo</a></li><li class="chapter-item expanded "><a href="commands/cargo-help.html"><strong aria-hidden="true">4.1.2.</strong> cargo help</a></li><li class="chapter-item expanded "><a href="commands/cargo-version.html"><strong aria-hidden="true">4.1.3.</strong> cargo version</a></li></ol></li><li class="chapter-item expanded "><a href="commands/build-commands.html"><strong aria-hidden="true">4.2.</strong> Build Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-bench.html"><strong aria-hidden="true">4.2.1.</strong> cargo bench</a></li><li class="chapter-item expanded "><a href="commands/cargo-build.html"><strong aria-hidden="true">4.2.2.</strong> cargo build</a></li><li class="chapter-item expanded "><a href="commands/cargo-check.html"><strong aria-hidden="true">4.2.3.</strong> cargo check</a></li><li class="chapter-item expanded "><a href="commands/cargo-clean.html"><strong aria-hidden="true">4.2.4.</strong> cargo clean</a></li><li class="chapter-item expanded "><a href="commands/cargo-doc.html"><strong aria-hidden="true">4.2.5.</strong> cargo doc</a></li><li class="chapter-item expanded "><a href="commands/cargo-fetch.html"><strong aria-hidden="true">4.2.6.</strong> cargo fetch</a></li><li class="chapter-item expanded "><a href="commands/cargo-fix.html"><strong aria-hidden="true">4.2.7.</strong> cargo fix</a></li><li class="chapter-item expanded "><a href="commands/cargo-run.html"><strong aria-hidden="true">4.2.8.</strong> cargo run</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustc.html"><strong aria-hidden="true">4.2.9.</strong> cargo rustc</a></li><li class="chapter-item expanded "><a href="commands/cargo-rustdoc.html"><strong aria-hidden="true">4.2.10.</strong> cargo rustdoc</a></li><li class="chapter-item expanded "><a href="commands/cargo-test.html"><strong aria-hidden="true">4.2.11.</strong> cargo test</a></li></ol></li><li class="chapter-item expanded "><a href="commands/manifest-commands.html"><strong aria-hidden="true">4.3.</strong> Manifest Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-generate-lockfile.html"><strong aria-hidden="true">4.3.1.</strong> cargo generate-lockfile</a></li><li class="chapter-item expanded "><a href="commands/cargo-locate-project.html"><strong aria-hidden="true">4.3.2.</strong> cargo locate-project</a></li><li class="chapter-item expanded "><a href="commands/cargo-metadata.html"><strong aria-hidden="true">4.3.3.</strong> cargo metadata</a></li><li class="chapter-item expanded "><a href="commands/cargo-pkgid.html"><strong aria-hidden="true">4.3.4.</strong> cargo pkgid</a></li><li class="chapter-item expanded "><a href="commands/cargo-tree.html"><strong aria-hidden="true">4.3.5.</strong> cargo tree</a></li><li class="chapter-item expanded "><a href="commands/cargo-update.html"><strong aria-hidden="true">4.3.6.</strong> cargo update</a></li><li class="chapter-item expanded "><a href="commands/cargo-vendor.html"><strong aria-hidden="true">4.3.7.</strong> cargo vendor</a></li><li class="chapter-item expanded "><a href="commands/cargo-verify-project.html"><strong aria-hidden="true">4.3.8.</strong> cargo verify-project</a></li></ol></li><li class="chapter-item expanded "><a href="commands/package-commands.html"><strong aria-hidden="true">4.4.</strong> Package Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-init.html"><strong aria-hidden="true">4.4.1.</strong> cargo init</a></li><li class="chapter-item expanded "><a href="commands/cargo-install.html"><strong aria-hidden="true">4.4.2.</strong> cargo install</a></li><li class="chapter-item expanded "><a href="commands/cargo-new.html"><strong aria-hidden="true">4.4.3.</strong> cargo new</a></li><li class="chapter-item expanded "><a href="commands/cargo-search.html"><strong aria-hidden="true">4.4.4.</strong> cargo search</a></li><li class="chapter-item expanded "><a href="commands/cargo-uninstall.html"><strong aria-hidden="true">4.4.5.</strong> cargo uninstall</a></li></ol></li><li class="chapter-item expanded "><a href="commands/publishing-commands.html"><strong aria-hidden="true">4.5.</strong> Publishing Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/cargo-login.html"><strong aria-hidden="true">4.5.1.</strong> cargo login</a></li><li class="chapter-item expanded "><a href="commands/cargo-owner.html"><strong aria-hidden="true">4.5.2.</strong> cargo owner</a></li><li class="chapter-item expanded "><a href="commands/cargo-package.html"><strong aria-hidden="true">4.5.3.</strong> cargo package</a></li><li class="chapter-item expanded "><a href="commands/cargo-publish.html"><strong aria-hidden="true">4.5.4.</strong> cargo publish</a></li><li class="chapter-item expanded "><a href="commands/cargo-yank.html"><strong aria-hidden="true">4.5.5.</strong> cargo yank</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> 参见问题</a></li><li class="chapter-item expanded "><a href="appendix/glossary.html"><strong aria-hidden="true">6.</strong> 附录：术语白</a></li><li class="chapter-item expanded "><a href="appendix/git-authentication.html"><strong aria-hidden="true">7.</strong> Appendix: Git Authentication</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Cargo 手册 中文版</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-cn/cargo-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#cargo-手册" id="cargo-手册">Cargo 手册</a></h1>
<blockquote>
<p>中文译注（Chinese translation of the <a href="https://doc.rust-lang.org/cargo">Cargo Book</a>）：</p>
<ol>
<li>《Rust Cookbook 中文版》 翻译自 <a href="https://doc.rust-lang.org/cargo">Cargo Book</a>，查看此书的 <a href="https://doc.rust-lang.org/cargo-cn">Github 翻译项目</a>。</li>
<li>本书翻译内容源自 <a href="https://github.com/chinanf-boy">chinanf-boy</a>的开源的<a href="https://github.com/chinanf-boy/cargo-book-zh">翻译版本</a>，我们对原译者感激不尽！该版本最后翻译更新时间是 2019 年 5 月 12 日，与当前的英文版差异比较大，特别期待您加入到本开源翻译项目组中来维护本书，确保本书紧跟英文版。</li>
<li>目前英文版已经加入了命令行帮助页部分，还有其他章节内容，内容已经扩充了一倍以上，所以中文版翻译（包括网上所有版本）的部分还不到 1/2。</li>
<li>许可协议：跟随英文原书使用 MIT 和 Apache 2.0 双许可授权。</li>
<li><a href="https://rustwiki.org/zh-CN/cargo" style="color:red;">本站支持文档中英文切换</a>，点击页面右上角语言图标可切换到相同章节的英文页面，<strong>英文版每天都会自动同步一次官方的最新版本</strong>。</li>
<li>若发现本页表达错误或帮助我们改进翻译，可点击右上角的编辑按钮打开本页对应源码文件进行编辑和修改，Rust 中文资源的开源组织发展离不开大家，感谢您的支持和帮助！</li>
</ol>
</blockquote>
<p><img src="images/Cargo-Logo-Small.png" alt="Cargo Logo" /></p>
<p>Cargo 是<a href="https://www.rust-lang.org/">Rust</a>的 <em>包经理</em>。Cargo 会下载您 Rust 的包依赖项，编译您的包，生成可分发的包，并将它们上传到<a href="https://crates.io/">crates.io</a> - Rust 社区的<em>包注册表</em>。你可以为这本书做出贡献在<a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src">GitHub</a>.</p>
<h3><a class="header" href="#章节" id="章节">章节</a></h3>
<p><strong><a href="getting-started/index.html">入门</a></strong></p>
<p>要开始使用 Cargo，请安装 Cargo(和 Rust)并设置您的第一个箱子.</p>
<p><strong><a href="guide/index.html">Cargo 指南</a></strong></p>
<p>该指南将为您提供，有关如何使用 Cargo 开发 Rust 包的所有信息.</p>
<p><strong><a href="reference/index.html">Cargo 参考</a></strong></p>
<p>该参考文献涵盖了 Cargo 各个领域的细节.</p>
<p><strong><a href="faq.html">常见问题</a></strong></p>
<h2><a class="header" href="#开始入门" id="开始入门">开始入门</a></h2>
<p>要开始使用 Cargo，请安装 Cargo(和 Rust)，并设置您的第一个箱子.</p>
<ul>
<li><a href="getting-started/./installation.html">安装</a></li>
<li><a href="getting-started/./first-steps.html">Cargo 的第一步</a></li>
</ul>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<h3><a class="header" href="#安装-rust-和-cargo" id="安装-rust-和-cargo">安装 Rust 和 Cargo</a></h3>
<p>获得 Cargo 的最简单方法是使用<code>rustup</code>脚本，获取当前稳定版本的 <a href="https://www.rust-lang.org/">Rust</a>:</p>
<p>在 Linux 和 macOS 系统上，这可以通过以下方式完成:</p>
<pre><code class="language-console">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>它将下载一个脚本，然后开始安装。如果一切顺利，您会看到:</p>
<pre><code class="language-console">Rust is installed now. Great!
</code></pre>
<p>在 Windows 上，下载并运行<a href="https://win.rustup.rs/">rustup-init.exe</a>。它将在控制台中启动安装，并在成功时显示上述消息.</p>
<p>在此之后，你可以使用<code>rustup</code>命令，安装<code>beta</code>或者<code>nightly</code>版本的 Rust 和 Cargo。</p>
<p>有关其他安装选项和信息，请访问 Rust 网站的<a href="https://www.rust-lang.org/install.md">安装</a>页面.</p>
<h3><a class="header" href="#从源头构建-cargo" id="从源头构建-cargo">从源头构建 Cargo</a></h3>
<p>或者，你可以<a href="https://github.com/rust-lang/cargo#compiling-from-source">从源头构建 Cargo</a>.</p>
<h2><a class="header" href="#cargo-的第一步" id="cargo-的第一步">Cargo 的第一步</a></h2>
<p>要使用 Cargo 启动新项目，请使用<code>cargo new</code>:</p>
<pre><code class="language-shell">$ cargo new hello_world --bin
</code></pre>
<p>我们传递<code>--bin</code>，是因为我们正在制作一个二进制程序(默认): 如果我们正在创建一个库(lib)，我们就会把传递<code>--lib</code>.</p>
<p>让我们来看看 Cargo 为我们带来了什么:</p>
<pre><code class="language-shell">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>这就是我们开始所需要的一切。首先，让我们看看<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>这被称为一个<strong>manifest</strong>元清单，它包含了 Cargo 编译项目所需的所有元数据.</p>
<p>那<code>src/main.rs</code>有啥:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 为我们创造了一个&quot;hello_world&quot;.我们来编译它:</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>然后运行它:</p>
<pre><code class="language-shell">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>我们也可以直接使用<code>cargo run</code>，它会自行编译，然后运行它， 一步到位:</p>
<pre><code class="language-shell">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<h2><a class="header" href="#走得更远" id="走得更远">走得更远</a></h2>
<p>有关使用 Cargo 的更多详细信息，请查看<a href="getting-started/../guide/index.html">Cargo 指南</a></p>
<h2><a class="header" href="#cargo-guide" id="cargo-guide">Cargo Guide</a></h2>
<p>本指南将为您提供有关如何使用 Cargo 开发 Rust 包的所有信息.</p>
<ul>
<li><a href="guide/./why-cargo-exists.html">为什么 Cargo 存在</a></li>
<li><a href="guide/./creating-a-new-project.html">创建一个新包</a></li>
<li><a href="guide/./working-on-an-existing-project.html">使用现有的 Cargo 包装</a></li>
<li><a href="guide/./dependencies.html">依赖</a></li>
<li><a href="guide/./project-layout.html">包装布局</a></li>
<li><a href="guide/./cargo-toml-vs-cargo-lock.html">Cargo.toml 与 Cargo.lock</a></li>
<li><a href="guide/./tests.html">测试</a></li>
<li><a href="guide/./continuous-integration.html">持续集成</a></li>
<li><a href="guide/./build-cache.html">构建缓存</a></li>
</ul>
<h2><a class="header" href="#为什么-cargo-存在" id="为什么-cargo-存在">为什么 Cargo 存在</a></h2>
<p>Cargo 是一个工具,允许 Rust 项目声明其各种依赖项，并确保您始终获得可重复的构建。</p>
<p>为了实现这一目标,Cargo 做了四件事:</p>
<ul>
<li>引入两个，包含各种项目信息的元数据文件。</li>
<li>获取，并构建项目的依赖项.</li>
<li>正确使用参数，以调用<code>rustc</code>或其他构建工具，构建你的项目。</li>
<li>介绍，更容易使用 Rust 项目的约定(规范/风格)。</li>
</ul>
<h2><a class="header" href="#创建一个新项目" id="创建一个新项目">创建一个新项目</a></h2>
<p>要使用 Cargo 启动新项目，请使用<code>cargo new</code>:</p>
<pre><code class="language-shell">$ cargo new hello_world --bin
</code></pre>
<p>我们传递<code>--bin</code>，是因为我们正在制作一个二进制程序(默认): 如果我们正在创建一个库(lib)，我们就会把传递<code>--lib</code>。默认情况下，这个目录会初始化为一个新的<code>git</code>存储库，如果您不希望它这样做，请传递<code>--vcs none</code>。</p>
<p>让我们来看看 Cargo 为我们带来了什么:</p>
<pre><code class="language-shell">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>这就是我们开始所需要的一切首。先让我们看看<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>这被称为一个<strong>manifest</strong>元清单，它包含了 Cargo 编译项目所需的所有元数据.</p>
<p>那<code>src/main.rs</code>有啥:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 为我们创造了一个&quot;hello_world&quot;.我们来编译它:</p>
<pre><code class="language-shell">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>然后运行它:</p>
<pre><code class="language-shell">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>我们也可以直接使用<code>cargo run</code>，它会自行编译，然后运行它, 一步到位:</p>
<pre><code class="language-shell">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<p>您会注意到已创建了几个新文件和目录:</p>
<pre><code class="language-shell">$ tree .
.
|-- Cargo.lock
|-- Cargo.toml
|-- src
|   `-- main.rs
`-- target
    `-- debug
        |-- build
        |-- deps
        |   |-- hello_world-6ad0b2df81336e7f
        |   |-- hello_world-6ad0b2df81336e7f.d
        |   `-- hello_world-6ad0b2df81336e7f.dSYM
        |       `-- Contents
        |           |-- Info.plist
        |           `-- Resources
        |               `-- DWARF
        |                   `-- hello_world-6ad0b2df81336e7f
        |-- examples
        |-- hello_world
        |-- hello_world.d
        |-- hello_world.dSYM -&gt; deps/hello_world-6ad0b2df81336e7f.dSYM
        |-- incremental
        |   // ...
        `-- native

15 directories, 19 files
</code></pre>
<p>这个<code>Cargo.lock</code>文件啊，是包含我们的依赖项的有关信息(即便还没有依赖)，其内容看起来可不是很有趣啊。再有就是<code>target</code>目录包含所有构建产品(二进制文件..)，并且，可以看出，Cargo 默认生成调试(debug)版本。您可以使用<code>cargo build --release</code>，这会在开启优化的情况下，编译文件:</p>
<pre><code class="language-shell">$ cargo build --release
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p><code>cargo build --release</code>将结果二进制文件放入<code>target/release</code>，而不再是<code>target/debug</code>目录.</p>
<p>调试模式的编译是开发的默认设置 - 编译时间较短，因为编译器不进行优化，但代码运行速度较慢。发布(release)模式编译需要更长时间，但代码运行速度更快。</p>
<h2><a class="header" href="#在现有的-cargo-项目上工作" id="在现有的-cargo-项目上工作">在现有的 Cargo 项目上工作</a></h2>
<p>如果您下载使用 Cargo 的现有项目，那么它很容易上手.</p>
<p>首先，从某个地方获取项目.在这个例子中，我们将使用<code>rand</code>项目，其从 GitHub 上的存储库克隆而来:</p>
<pre><code class="language-shell">$ git clone https://github.com/rust-lang-nursery/rand.git
$ cd rand
</code></pre>
<p>要建立，使用<code>cargo build</code>:</p>
<pre><code class="language-shell">$ cargo build
   Compiling rand v0.1.0 (file:///path/to/project/rand)
</code></pre>
<p>这将获取所有依赖项，然后与项目一起构建它们.</p>
<h2><a class="header" href="#从-cratesio-添加依赖项" id="从-cratesio-添加依赖项">从 crates.io 添加依赖项</a></h2>
<p><a href="https://crates.io/">crates.io</a>是 Rust 社区的中央存储库，用作发现和下载包的位置。<code>cargo</code>默认配置为，使用它来查找请求的包.</p>
<p>获取托管在<a href="https://crates.io/">crates.io</a>的依赖'库'，将它添加到您的<code>Cargo.toml</code>.</p>
<h3><a class="header" href="#添加依赖项" id="添加依赖项">添加依赖项</a></h3>
<p>如果你的<code>Cargo.toml</code>，还没有<code>[dependencies]</code>部分，添加它，然后列出您要使用的包名称和版本。这个例子增加了一个<code>time</code>箱(crate)依赖:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>版本字符串是<a href="https://github.com/steveklabnik/semver#requirements">semver</a>版本要求。该<a href="guide/03-01-specifying-dependencies.html">指定依赖项</a>文档 提供了有关此处选项的更多信息.</p>
<p>如果我们还想添加一个<code>regex</code>箱子依赖，我们不需要为每个箱子都添加<code>[dependencies]</code>。下面就是你的<code>Cargo.toml</code>文件整体，看起来像依赖于<code>time</code>和<code>regex</code>箱:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
time = &quot;0.1.12&quot;
regex = &quot;0.1.41&quot;
</code></pre>
<p>重新运行<code>cargo build</code>，Cargo 将获取新的依赖项及其所有依赖项，将它们全部编译，然后更新<code>Cargo.lock</code>:</p>
<pre><code class="language-shell">$ cargo build
      Updating registry `https://github.com/rust-lang/crates.io-index`
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
</code></pre>
<p>我们的<code>Cargo.lock</code>包含有关，我们使用的所有这些依赖项的哪个版本的确实信息.</p>
<p>现在，如果<code>regex</code>在<a href="https://crates.io/">crates.io</a>上更新了，在我们选择<code>cargo update</code>之前，我们仍会使用相同的版本进行构建.</p>
<p>你现在可以使用<code>regex</code>箱了，通过在<code>main.rs</code>使用<code>extern crate</code>。</p>
<pre><pre class="playground"><code class="language-rust">extern crate regex;

use regex::Regex;

fn main() {
    let re = Regex::new(r&quot;^\d{4}-\d{2}-\d{2}$&quot;).unwrap();
    println!(&quot;Did our date match? {}&quot;, re.is_match(&quot;2014-01-01&quot;));
}
</code></pre></pre>
<p>运行它将显示:</p>
<pre><code class="language-shell">$ cargo run
   Running `target/hello_world`
Did our date match? true
</code></pre>
<h2><a class="header" href="#项目布局" id="项目布局">项目布局</a></h2>
<p>Cargo 使用文件放置惯例，以便轻松进入新的 Cargo 项目:</p>
<pre><code class="language-shell">.
├── Cargo.lock
├── Cargo.toml
├── benches
│   └── large-input.rs
├── examples
│   └── simple.rs
├── src
│   ├── bin
│   │   └── another_executable.rs
│   ├── lib.rs
│   └── main.rs
└── tests
    └── some-integration-tests.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code>和<code>Cargo.lock</code>存储在项目的根目录中.</li>
<li>源代码进入<code>src</code>目录.</li>
<li>默认库文件是<code>src/lib.rs</code>.</li>
<li>默认的可执行文件是<code>src/main.rs</code>.</li>
<li>其他可执行文件，可以放入<code>src/bin/*.rs</code>.</li>
<li>集成测试进入<code>tests</code>目录(单元测试进到，正在测试的每个文件中).</li>
<li>示例进入<code>examples</code>目录.</li>
<li>基准进入<code>benches</code>目录.</li>
</ul>
<p>这些将在更详细的<a href="guide/../reference/manifest.html#the-project-layout">清单描述</a>说明中解释.</p>
<h2><a class="header" href="#cargotoml-与-cargolock" id="cargotoml-与-cargolock">Cargo.toml 与 Cargo.lock</a></h2>
<p><code>Cargo.toml</code>和<code>Cargo.lock</code>各有其目的。在我们谈论它们之前，这是一个总结:</p>
<ul>
<li><code>Cargo.toml</code>是从广义上描述你的依赖，并由你编写.</li>
<li><code>Cargo.lock</code>包含有关您的依赖项的确切信息。它由 Cargo 维护，不应手动编辑.</li>
</ul>
<p>如果您正在构建，其他项目要依赖的库，请将<code>Cargo.lock</code>放置在你的<code>.gitignore</code>。如果您正在构建可执行文件，如命令行工具或应用程序，请检查<code>Cargo.lock</code>位于<code>git</code>管理下。如果你对这是为什么感到好奇，请参阅<a href="guide/../faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries">&quot;为什么二进制文件在版本控制系统中有<code>Cargo.lock</code>，而库没有?&quot; - FAQ </a>.</p>
<p>让我们再挖掘一下.</p>
<p><code>Cargo.toml</code>是一个<strong>manifest(清单)</strong>，我们可以在其中指定一系列关于我们项目的不同元数据的文件。例如，我们可以说我们依赖于另一个项目:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
</code></pre>
<p>这个项目有一个依赖关系<code>rand</code>箱。在这种情况下，我们已经说过，我们依赖于 GitHub 上的特定 Git 存储库。由于我们尚未指定任何其他信息，因此 Cargo 假定我们打算使用最新提交的<code>master</code>分支构建我们的项目。</p>
<p>听起来不错? 嗯，但有一个问题: 如果你今天构建这个项目，然后你发送一份副本给我，我明天构建这个项目，可能会发生一些不好的事情。因在此期间，可能会有更多的<code>rand</code>提交，我的构建将包括新的提交，而你的不会。因此，我们会得到不同的构建。这很糟糕，因为我们需要可重复的构建.</p>
<p>我们可以通过放置一个<code>rev</code>来解决这个问题，写入我们<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot;, rev = &quot;9f35b8e&quot; }
</code></pre>
<p>现在我们的构建将是相同的。但是有一个很大的缺点:现在我们每次想要更新库时，都必须手动考虑 SHA-1。这既乏味又容易出错.</p>
<p>那现在<code>Cargo.lock</code>登场了。由于它的存在，我们不需要手动跟踪确切的修订版本: Cargo 将为我们做。当我们有这样的清单时:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand.git&quot; }
</code></pre>
<p>Cargo 将采取最新的提交，并在我们第一次构建时，将这些信息写入我们的<code>Cargo.lock</code>。该文件将如下所示:</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
dependencies = [
 &quot;rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)&quot;，
]

[[package]]
name = &quot;rand&quot;
version = &quot;0.1.0&quot;
source = &quot;git+https://github.com/rust-lang-nursery/rand.git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9&quot;
</code></pre>
<p>你可以看到这里有更多的信息，包括我们用来构建的确切修订版本。现在，当您将项目交给其他人时，他们将使用完全相同的 SHA，即使我们没有在我们的项目<code>Cargo.toml</code>中指定它.</p>
<p>当我们准备选择，更新库的版本时，Cargo 会自动重新计算依赖关系，并为我们更新内容:</p>
<pre><code class="language-shell">$ cargo update           # updates all dependencies
$ cargo update -p rand   # updates just “rand”
</code></pre>
<p>这将写出一个新的<code>Cargo.lock</code>与新版本信息。请注意<code>cargo update</code>参数，实际上会是是一个<a href="guide/../reference/pkgid-spec.html">包 ID 规范</a>，和<code>rand</code>只是一个简短的规范.</p>
<h2><a class="header" href="#测试" id="测试">测试</a></h2>
<p>Cargo 可以使用<code>cargo test</code>命令运行您的测试。Cargo 寻找在两个地方运行的测试 :在你<code>src</code>中的每个文件，和<code>tests/</code>中的任何测试。测试你的<code>src</code>文件应该是单元测试，并在<code>tests/</code>中的应该是整合式测试。因此，您需要将包装箱导入到<code>tests</code>的文件中.</p>
<p>这是在我们的项目中，运行<code>cargo test</code>的一个例子，目前没有测试:</p>
<pre><code class="language-shell">$ cargo test
   Compiling rand v0.1.0 (https://github.com/rust-lang-nursery/rand.git#9f35b8e)
   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>如果我们的项目有测试，我们会看到更多的输出与正确的测试数量.</p>
<p>您还可以通过传递过滤器，来运行特定测试:</p>
<pre><code class="language-shell">$ cargo test foo
</code></pre>
<p>这将运行任何匹配的<code>foo</code>测试.</p>
<p><code>cargo test</code>还运行其他检查。例如，它将编译您包含的任何示例(examples)，并且还将测试文档中的示例。请看在 Rust 文档中的<a href="https://doc.rust-lang.org/book/testing.md">测试指南</a>，了解更多详细信息.</p>
<h2><a class="header" href="#持续集成" id="持续集成">持续集成</a></h2>
<h3><a class="header" href="#travis-ci" id="travis-ci">Travis CI</a></h3>
<p>要在 Travis CI 上测试您的项目，这里有一个<code>.travis.yml</code>文件示例:</p>
<pre><code class="language-yaml">language: rust
rust:
  - stable
  - beta
  - nightly
matrix:
  allow_failures:
    - rust: nightly
</code></pre>
<p>这将在所有三个 rust 版本下，进行测试，但 nightly 的任何破坏，都不会使整体构建失败。请看看<a href="https://docs.travis-ci.com/user/languages/rust/">Travis CI Rust 文档</a>了解更多信息.</p>
<h3><a class="header" href="#gitlab-ci" id="gitlab-ci">GitLab CI</a></h3>
<p>要在 GitLab CI 上测试您的包，这里有一个<code>.gitlab-ci.yml</code>文件示例:</p>
<pre><code class="language-yaml">stages:
  - build

rust-latest:
  stage: build
  image: rust:latest
  script:
    - cargo build --verbose
    - cargo test --verbose

rust-nightly:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose
  allow_failure: true
</code></pre>
<p>这将测试 stable 版本和 nightly 版本，但 nightly 的任何破损，都不会使整体构建失败。欲获得更多信息，请看<a href="https://docs.gitlab.com/ce/ci/yaml/README.md">GitLab CI</a>.</p>
<h2><a class="header" href="#cargo-home" id="cargo-home">Cargo Home</a></h2>
<p>“Cargo home”起到下载和源（source）缓存的作用。
当我们构建一个<a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)">crate</a>时，Cargo将把下载的依赖项存储在Cargo home中。
您可以通过修改<code>CARGO_HOME</code><a href="guide/../reference/environment-variables.html">环境变量</a>来改变Cargo home的位置。
<a href="https://crates.io/crates/home">home</a> crate提供了一个API，允许您在您的Rust crate中检索Cargo home的位置。
默认情况下，Cargo home的位置是<code>$HOME/.cargo/</code>。</p>
<p>请注意，Cargo home的内部结构并不稳定，可能会随时发生变化。</p>
<p>Cargo home由这些部件共同组成：</p>
<h2><a class="header" href="#文件" id="文件">文件:</a></h2>
<ul>
<li>
<p><code>config.toml</code>
Caro的全局配置文件，请参阅<a href="guide/../reference/config.html">参考文档中的config条目</a>。</p>
</li>
<li>
<p><code>credentials.toml</code>
加密登录的凭证，来自（from）<a href="guide/../commands/cargo-login.html"><code>cargo login</code></a>，用于登录<a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>。
Private login credentials from <a href="guide/../commands/cargo-login.html"><code>cargo login</code></a> in order to log in to a <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>.</p>
</li>
<li>
<p><code>.crates.toml</code>
该隐藏文件包含了通过<a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>安装的crate的<a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a>信息。<strong>不要</strong>手动修改它！</p>
</li>
</ul>
<h2><a class="header" href="#目录" id="目录">目录:</a></h2>
<ul>
<li>
<p><code>bin</code>
bin目录包含了通过<a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>或者<a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a>安装的crate的可执行文件。
要使这些可执行文件可用，只需将目录的路径添加到<code>$PATH</code>环境变量中。</p>
</li>
<li>
<p><code>git</code>
Git源（Git sources）存储在这里：</p>
<ul>
<li>
<p><code>git/db</code>
当一个crate依赖于一个git仓库时，Cargo将克隆一个该git仓库的裸仓库（bare repo）到这个文件夹，并在必要时更新它。</p>
<blockquote>
<p>译者注：裸仓库（bare repo）是没有<code>.git</code>目录的仓库。也就是说，它只有裸仓库数据，而没有工作目录或者工作树。</p>
</blockquote>
</li>
<li>
<p><code>git/checkouts</code>
若一个git源被使用，Cargo将从<code>git/db</code>中的裸仓库中检出（check out）所需的提交（commit）到这个目录。
该目录为编译器提供了具体的文件，这些文件包含于这个依赖关系所指定的提交的仓库中。
Cargo支持检出相同仓库中的多个不同提交。
This provides the compiler with the actual files contained in the repo of the commit specified for that dependency.
Multiple checkouts of different commits of the same repo are possible.</p>
</li>
</ul>
</li>
<li>
<p><code>registry</code>
这里存放着包（Packages）和crate registries的元数据（例如<a href="https://crates.io/">crates.io</a>）</p>
<ul>
<li>
<p><code>registry/index</code>
该目录是个裸仓库，它包含了该registry中所有可用的crate的元数据（版本，依赖，等等）</p>
</li>
<li>
<p><code>registry/cache</code>
已经下载的依赖将被存放于该文件夹中。这些crate会经过gzip压缩为归档文件（gzip archive），并以<code>.crate</code>为扩展名。</p>
</li>
<li>
<p><code>registry/src</code>
若某个包要求依赖一个已下载的<code>.crate</code>归档文件，该归档文件将被解压到这个目录中。rustc将在该目录中找到它所需的<code>.rs</code>文件。</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#在ci中缓存cargo-home" id="在ci中缓存cargo-home">在CI中缓存Cargo home</a></h2>
<p>为防止在持续集成（CI）中重新下载所有crate依赖，您可以缓存<code>$CARGO_HOME</code>目录。
然而，缓存整个目录通常并不高效，因为它可能会将已经下载过的源再缓存一次（it will contain downloaded sources twice）。
若我们依赖了一个crate，例如<code>serde 1.0.92</code>，并将整个<code>$CARGO_HOME</code>缓存，我们实际上将缓存两次，一次是在<code>registry/cache</code>中的<code>serde-1.0.92.crate</code>，另一次是serde在<code>registry/src</code>中解压的<code>.rs</code>文件。
由于下载、解压，再压缩和再上传缓存到CI服务器上这些操作可能花费大量时间，构建过程可能会额外耗费不必要的时间成本。</p>
<p>实际上，在构建过程中只缓存下列目录就足够了：</p>
<ul>
<li><code>bin/</code></li>
<li><code>registry/index/</code></li>
<li><code>registry/cache/</code></li>
<li><code>git/db/</code></li>
</ul>
<h2><a class="header" href="#供应vendoring项目中的所有依赖" id="供应vendoring项目中的所有依赖">供应（Vendoring）项目中的所有依赖</a></h2>
<p>请参阅<a href="guide/../commands/cargo-vendor.html"><code>cargo vendor</code></a>子命令。</p>
<h2><a class="header" href="#清除缓存" id="清除缓存">清除缓存</a></h2>
<p>理论上，您可以随时清除缓存的任何部分，当某个crate要求这些被清除的依赖内容时，Cargo将尽力恢复它们。这可以通过解压归档文件、检出裸仓库或简单地重新下载来实现。</p>
<p>作为替代，您可以使用<a href="https://crates.io/crates/cargo-cache">cargo-cache</a> crate提供的命令行工具来选择性清除指定部分的缓存，或显示其组件占用空间的大小。</p>
<h2><a class="header" href="#构建-缓存" id="构建-缓存">构建 缓存</a></h2>
<p>Cargo 在单个工作区，共享其中所有包的构建工件。今天，Cargo 不会在不同的工作区共享构建结果，但使用第三方工具可以实现类似的结果，<a href="https://github.com/mozilla/sccache">sccache</a>。</p>
<p>装置<code>sccache</code>，用<code>cargo install sccache</code>安装它，并在调用 Cargo 之前，设置<code>RUSTC_WRAPPER</code>环境变量成<code>sccache</code>。如果你使用 bash，更好是添加<code>export RUSTC_WRAPPER=sccache</code>到<code>.bashrc</code>文件。有关更多详细信息，请参阅 sccache 文档.</p>
<h2><a class="header" href="#cargo-参考" id="cargo-参考">Cargo 参考</a></h2>
<p>该参考文献涵盖了 Cargo 各个领域的细节.</p>
<ul>
<li><a href="reference/./specifying-dependencies.html">指定依赖项</a></li>
<li><a href="reference/./manifest.html">清单格式</a></li>
<li><a href="reference/./config.html">配置</a></li>
<li><a href="reference/./environment-variables.html">环境变量</a></li>
<li><a href="reference/./build-scripts.html">构建脚本</a></li>
<li><a href="reference/./publishing.html">在 crates.io 上发布</a></li>
<li><a href="reference/./pkgid-spec.html">包 ID 规格</a></li>
<li><a href="reference/./source-replacement.html">来源更换</a></li>
<li><a href="reference/./external-tools.html">外部工具</a></li>
<li><a href="reference/./unstable.html">不稳定的功能</a></li>
</ul>
<h2><a class="header" href="#依赖指定" id="依赖指定">依赖指定</a></h2>
<p>您的箱子，可以依赖多个来源的库，如<a href="https://crates.io/">crates.io</a>，<code>git</code>的存储库或本地文件系统上的子目录。您还可以临时覆盖依赖项的位置 - 例如， 便于能够测试您在本地工作的依赖项中的错误修复。您可以为不同的平台，和或仅在开发期间使用不同的依赖项。我们来看看如何做到这些.</p>
<h3><a class="header" href="#指定依赖来自-cratesio" id="指定依赖来自-cratesio">指定依赖，来自 crates.io</a></h3>
<p>默认情况下，Cargo 是准备好，在<a href="https://crates.io/">crates.io</a>上查找依赖项。在这种情况下，只需要名称和版本字符串。在<a href="reference/../guide/index.html">Cargo 指南</a>，我们选择了一个依赖项-<code>time</code>箱:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>字符串<code>&quot;0.1.12&quot;</code>是一个<a href="https://github.com/steveklabnik/semver#requirements">semver</a>版本格式字符串。由于此字符串中没有任何运算符，因此它的解释方式与我们指定的<code>&quot;^0.1.12&quot;</code>方式相同，而<code>^</code>被称为跳脱条件.</p>
<h3><a class="header" href="#caret-requirements跳脱条件" id="caret-requirements跳脱条件">Caret requirements(跳脱条件)</a></h3>
<p><strong>跳脱条件</strong>: 允许 SemVer 兼容更新指定版本。新的版本允许更新的条件是，不修改最左边的非零数字(无论<code>major，minor，patch</code>)。在这种情况下，如果我们执行了<code>cargo update -p time</code>，Cargo 应该更新我们的<code>0.1.13</code>版本(如果是最新的<code>0.1.z</code>发布)，但不会更新为<code>0.2.0</code>。相反，我们若将版本字符串指定为<code>^1.0</code>，Cargo 应更新至<code>1.1</code>，如果是最新的<code>1.y</code>发布，但不是<code>2.0</code>版本。<code>0.0.x</code>并不与任何其他版本兼容.</p>
<p>以下是一些跳脱条件的例子以及它们允许的版本:</p>
<pre><code class="language-notrust">^1.2.3 := &gt;=1.2.3 &lt;2.0.0
^1.2 := &gt;=1.2.0 &lt;2.0.0
^1 := &gt;=1.0.0 &lt;2.0.0
^0.2.3 := &gt;=0.2.3 &lt;0.3.0
^0.2 := &gt;= 0.2.0 &lt; 0.3.0
^0.0.3 := &gt;=0.0.3 &lt;0.0.4
^0.0 := &gt;=0.0.0 &lt;0.1.0
^0 := &gt;=0.0.0 &lt;1.0.0
</code></pre>
<p>此兼容性约定与 SemVer ，在处理 1.0.0 之前的版本方面有所不同。虽然 SemVer 说在 1.0.0 之前没有兼容性，但 Cargo 认为<code>0.x.y</code>是兼容<code>0.x.z</code>，这里<code>y ≥ z</code>和<code>x &gt; 0</code>.</p>
<h3><a class="header" href="#tilde-条件" id="tilde-条件">Tilde 条件</a></h3>
<p><strong>Tilde 条件</strong>指定具有更新最小版本的一定能力。如果指定 major 版本，minor 版本和 patch 程序版本，或仅指定 major 版本和 minor 版本，则仅允许 patch 程序级别更改。如果仅指定 major 版本，则允许进行 minor 和 patch 级别更改.</p>
<p><code>~1.2.3</code>是 Tilde 条件的一个例子.</p>
<pre><code class="language-notrust">~1.2.3 := &gt;=1.2.3 &lt;1.3.0
~1.2 := &gt;=1.2.0 &lt;1.3.0
~1 := &gt;=1.0.0 &lt;2.0.0
</code></pre>
<h3><a class="header" href="#通配符要求" id="通配符要求">通配符要求</a></h3>
<p><strong>通配符条件</strong>允许任何通配符所在的版本.</p>
<p><code>*</code>，<code>1.*</code>和<code>1.2.*</code>是通配符条件的示例.</p>
<pre><code class="language-notrust">* := &gt;=0.0.0
1.* := &gt;=1.0.0 &lt;2.0.0
1.2.* := &gt;=1.2.0 &lt;1.3.0
</code></pre>
<h3><a class="header" href="#inequality-requirements范围条件" id="inequality-requirements范围条件">Inequality requirements(范围条件)</a></h3>
<p><strong>范围条件</strong>允许手动指定要依赖的版本范围或确切版本.</p>
<p>以下是范围条件的一些示例:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<h3><a class="header" href="#多版本条件" id="多版本条件">多版本条件</a></h3>
<p>多个版本，要求用逗号分隔，例如<code>&gt;= 1.2， &lt; 1.5</code>.</p>
<h3><a class="header" href="#依赖指定来自-git-存储库" id="依赖指定来自-git-存储库">依赖指定，来自 <code>git</code> 存储库</a></h3>
<p>依赖于位于<code>git</code>存储库的库，您需要指定的最小信息，为一个<code>git</code>字段，其是存储库的<code>github</code>位置:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; }
</code></pre>
<p>Cargo 将取得<code>git</code>，然后在这个位置找到一个存储库的请求箱子的<code>Cargo.toml</code>。方式是对<code>git</code>存储库里面的任何地方(不一定在根目录) - 例如，指定工作区中的成员包名称，和设置<code>git</code>到包含工作区的存储库).</p>
<p>由于我们尚未指定任何其他信息，因此 Cargo 假定我们打算使用最新的提交<code>master</code>分支，来构建我们的包。你可以将<code>git</code>字段和<code>rev</code>，<code>tag</code>， 还有<code>branch</code>，这些用于指定其他内容的字段组合起来。这是一个指定您希望在名为<code>next</code>分支上，使用最新提交的示例:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot;, branch = &quot;next&quot; }
</code></pre>
<h3><a class="header" href="#路径依赖指定" id="路径依赖指定">路径，依赖指定</a></h3>
<p>随着时间的推移，我们来自<a href="reference/../guide/index.html">指南</a>的<code>hello_world</code>示例已大幅增长! 它已经到了我们可能想分出一个单独的箱子供其他人使用的地步。为此，Cargo 支持<strong>路径依赖</strong>通常是位于一个存储库中的子箱。让我们开始在<code>hello_world</code>包的内部制作一个新的箱子:</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>这将创建一个新文件夹<code>hello_utils</code>，里面有一个<code>Cargo.toml</code>和<code>src</code>文件夹已准备好进行配置。为了告诉 Cargo，请打开<code>hello_world/Cargo.toml</code>，并添加你的<code>hello_utils</code>依赖:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot; }
</code></pre>
<p>这告诉 Cargo 我们依赖于一个叫做<code>hello_utils</code>的箱子，这能在<code>hello_utils</code>文件夹找到(相对于，写在<code>Cargo.toml</code>路径).</p>
<p>就是这样! 下一步<code>cargo build</code>将自动构建<code>hello_utils</code>，以及它自己的所有依赖项，其他人也可以开始使用它。但是，<a href="https://crates.io/">crates.io</a>不允许仅使用 <strong>路径指定依赖项</strong> 的包。如果我们想发布我们的<code>hello_world</code>箱子，我们需要发布一个版本<code>hello_utils</code>至<a href="https://crates.io">crates.io</a>，并在依赖项行中指定其版本:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<h3><a class="header" href="#依赖覆盖" id="依赖覆盖">依赖覆盖</a></h3>
<p>Cargo 中有许多方法支持，覆盖依赖关系以及控制依赖关系图。但是，这些选项通常仅在工作区级别可用，并且不通过依赖项传播。换句话说，&quot;应用程序&quot;具有覆盖依赖关系的能力，但&quot;库&quot;却没有。</p>
<p>许多场景，会产生想，覆盖依赖性或以其他方式改变某些依赖关系的愿望。然而，他们中的大多数都可以归结为，将箱子发布到 crates.io 之前使用箱子(覆盖依赖)的能力。例如:</p>
<ul>
<li>您编写的 <code>crate</code> ，也用于您编写的更大应用程序中，并且您希望测试在更大应用程序内，<code>crate</code>的错误修复情况。</li>
<li>不是你编写的上游包，现在其 git 存储库的主分支上，有一个新功能或错误修复，您要测试它。</li>
<li>您即将发布新版本的 major 版本，但您希望在整个软件包中进行集成测试，以确保新的主要版本能够正常运行.</li>
<li>您已经为上游的软件包提交了一个针对您找到的错误的修复程序，但是您希望立即让您的应用程序依赖，此程序包的固定修复版本，以避免错误修复程序被拒绝合并.</li>
</ul>
<p>这些场景目前都是通过<a href="reference/./manifest.html#the-patch-section"><code>[patch]</code> 清单部分 </a>解决的，从历史上看，其中一些方案是<a href="reference/./manifest.html#the-replace-section">该<code>[replace]</code>部分</a>解决的，但我们在这里会记录<code>[patch]</code>解决的部分。</p>
<h3><a class="header" href="#测试一个错误修复" id="测试一个错误修复">测试一个错误修复</a></h3>
<p>假设你正在使用<a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a>，但是当你正在研究它时，你会发现一个错误.但是，你很有进取心，所以你决定尝试修复这个 bug! 最初你的清单看起来像:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
uuid = &quot;1.0&quot;
</code></pre>
<p>我们要做的第一件事是克隆<a href="https://github.com/rust-lang-nursery/uuid"><code>uuid</code>存储库</a>，到本地:</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang-nursery/uuid
</code></pre>
<p>接下来我们将编辑<code>my-library</code>-Cargo.toml，为:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
</code></pre>
<p>在这里，我们宣布我们是*修补(patch)*来源<code>crates-io</code>，其有一个新的依赖，这将有效地添加本地(签出 checkout)版本<code>uuid</code>到 crates.io 注册表，指向本地包。</p>
<p>接下来我们需要确保我们的锁(lock)文件已更新为，使用此新版本<code>uuid</code>，所以我们的包使用本地签出的副本，而不是 crates.io 中的副本。<code>[patch]</code>工作方式是它将从<code>../path/to/uuid</code>加载依赖，然后每当 crates.io 查询<code>uuid</code>的版本时，它<em>也</em>会返回本地版本.</p>
<p>这意味着本地签出的版本号很重要，会影响是否使用该补丁。我们的清单宣布<code>uuid = &quot;1.0&quot;</code>，这意味着我们只会解析<code>&gt;= 1.0.0， &lt; 2.0.0</code>，和 Cargo 的贪婪解析算法，也意味着我们将解析到该范围内的最大版本。通常情况下这并不重要，因为 git 存储库的版本已经更大，或与 crates.io 上发布的最大版本相匹配，但重要的是要记住这一点!</p>
<p>无论如何，通常您现在需要做的就是:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>就是这样! 您现在正在使用本地版本<code>uuid</code>构建(注意构建输出中括号中的路径)。如果您没有看到构建本地路径版本，那么您可能需要运行<code>cargo update -p uuid --precise $version</code>，这里<code>$version</code>是本地签出版本的<code>uuid</code>副本。</p>
<p>一旦你修复了你最初发现的错误，你要做的下一件事就是将其作为拉取请求提交给<code>uuid</code>箱子本身。一旦你完成了这个，你也可以更新下<code>[patch]</code>部分。<code>[patch]</code>里面的内容列表就像是<code>[dependencies]</code>部分，所以一旦你的拉动请求合并，你就可以改变你的<code>path</code>依赖:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<h3><a class="header" href="#working-with-an-unpublished-minor-version" id="working-with-an-unpublished-minor-version">Working with an unpublished minor version</a></h3>
<blockquote>
<p>与 一个未发布的次要版本，一起工作</p>
</blockquote>
<p>现在让我们稍微改变一下，从错误修复，变成要添加功能。在努力<code>my-library</code>的同时，你发现需要<code>uuid</code>箱的一个全新的功能。而您已实现<code>uuid</code>此功能，并在<code>[patch]</code>上面进行本地测试，并提交了拉取请求。让我们来看看在实际发布之前，你如何继续使用和测试它。</p>
<p>我们也说当前版本的<code>uuid</code>，在 crates.io 上是<code>1.0.0</code>版本，但从提交那时起，git 存储库的主分支已更新为<code>1.0.1</code>。此分支包含您之前提交的新功能。要使用此存储库，我们将编辑我们的<code>Cargo.toml</code>，看起来像</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
uuid = &quot;1.0.1&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>注意我们对本地<code>uuid</code>的依赖已更新为<code>1.0.1</code>，因为这是我们在箱子发布后实际需要的东西。但是，这个版本在 crates.io 上不存在，所以我们提供给它清单的<code>[patch]</code>部分.</p>
<p>现在，当我们的库被构建时，它将<code>uuid</code>从 git 存储库取出，并解析到存储库中的 1.0.1 ，而不是尝试从 crates.io 下载版本。一旦 1.0.1 发布在 crates.io 上，那<code>[patch]</code>部分就可以删除了。</p>
<p>值得注意的是，<code>[patch]</code>是<em>连带关系</em>。假设您在更大的包中使用<code>my-library</code>，例如:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>记住这<code>[patch]</code>是<em>连带关系</em>，但只能在<em>顶层</em>，所以我们的<code>my-library</code>消费者不得不重写<code>[patch]</code>部分(如有必要的话)。不过，在这里，新的<code>uuid</code>箱子会适用对<code>uuid</code>的依赖和<code>my-library -&gt; uuid</code>的依赖，两个依赖<strong>都</strong>指定了。该<code>uuid</code>箱 将被解析为整个 crate 关系图 的 1.0.1 版本，并且它是将从 git 存储库中提取。</p>
<h4><a class="header" href="#overriding-repository-url" id="overriding-repository-url">Overriding repository URL</a></h4>
<blockquote>
<p>覆盖 注册表 URL</p>
</blockquote>
<p>如果要覆盖的依赖项不是加载自<code>crates.io</code>，你将不得不改变一下你的<code>[patch]</code>使用方式:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
</code></pre>
<p>就是这样!</p>
<h3><a class="header" href="#prepublishing-a-breaking-change" id="prepublishing-a-breaking-change">Prepublishing a breaking change</a></h3>
<blockquote>
<p>预发布一个重要变化</p>
</blockquote>
<p>让我们来看看最后一个场景。若要使用一个新的主要版本的箱子，其通常伴随着重大变化。而要坚持使用我们以前的箱，这意味着我们将创建 2.0.0 版本<code>uuid</code>箱。在我们提交了所有上游更改后，我们可以更新我们的<code>my-library</code>清单，看起来像:</p>
<pre><code class="language-toml">[dependencies]
uuid = &quot;2.0&quot;

[patch.crates-io]
uuid = { git = &quot;https://github.com/rust-lang-nursery/uuid&quot;, branch = &quot;2.0.0&quot; }
</code></pre>
<p>就是这样!与前面的示例一样，2.0.0 版本实际上，并不存在于 crates.io 上，但我们仍然可以通过<code>[patch]</code>部分使用。作为一个思考练习，让我们再看看<code>my-binary</code>(被使用)的再次表现:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid', branch = '2.0.0' }
</code></pre>
<p>请注意，这实际上将解析为两个版本的<code>uuid</code>箱。该<code>my-binary</code>箱子将继续使用 1.x.y 系列的<code>uuid</code>箱子，但是<code>my-library</code>箱 会使用 2.0.0 版本<code>uuid</code>。这将允许您通过依赖关系图逐步推出对包的更改，而无需一次性更新所有内容。</p>
<h3><a class="header" href="#overriding-with-local-dependencies" id="overriding-with-local-dependencies">Overriding with local dependencies</a></h3>
<blockquote>
<p>覆盖 本地依赖项</p>
</blockquote>
<p>有时你只是暂时在一个箱子上工作，而你不想修改<code>Cargo.toml</code>中像上诉的<code>[patch]</code>部分。对于这个用例，Cargo 提供了更为有限的覆盖版本<strong>路径覆盖</strong>.</p>
<p>路径覆盖是通过<code>.cargo/config</code>指定，而不是<code>Cargo.toml</code>，你可以寻找<a href="reference/./config.html">有关此配置的更多文档</a>。在<code>.cargo/config</code>内，你要指定的是一个名为<code>paths</code>字段:</p>
<pre><code class="language-toml">paths = [&quot;/path/to/uuid&quot;]
</code></pre>
<p>该数组应填充包含<code>Cargo.toml</code>的目录。在这种情况下，我们只是添加<code>uuid</code>，所以它将是唯一一个被覆盖的。此路径可以是包含该路径的绝对路径或相对<code>.cargo</code>文件夹的路径.</p>
<p>路径覆盖，比<code>[patch]</code>部分的限制更严格，但是，路径覆盖不能改变依赖图的结构。而当使用路径替换时，前一组依赖项必须完全匹配新的<code>Cargo.toml</code>规格。如此，就意味着路径覆盖不能用于向箱添加依赖项的测试，而换成<code>[patch]</code>在该种情况下使用。因此，路径覆盖的使用，通常会与快速错误修复分隔开来，而不是大更新分开。</p>
<p>注意:使用本地配置覆盖路径，仅适用于已发布到<a href="https://crates.io/">crates.io</a>的包。您无法使用此功能告诉 Cargo 如何查找本地未发布的箱。</p>
<h3><a class="header" href="#platform-specific-dependencies" id="platform-specific-dependencies">Platform specific dependencies</a></h3>
<blockquote>
<p>平台决定依赖</p>
</blockquote>
<p>特定于平台的依赖项采用相同的格式，但在<code>target</code>下列出。像正常 Rust 一样的<code>#[cfg]</code>语法，将用于定义这些部分:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

[target.'cfg(target_arch = &quot;x86&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

[target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies]
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<p>与 Rust 一样，这里的语法支持<code>not</code>，<code>any</code>，和<code>all</code>运算符组合各种 cfg 名称/值对。请注意<code>cfg</code>语法仅在 Cargo 0.9.0(Rust 1.8.0)之后可用.</p>
<p>除了<code>#[cfg]</code>语法，Cargo 还支持列出依赖关系适用的完整目标:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;

[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<p>如果您使用的是自定义目标规范，请引用完整路径和文件名:</p>
<pre><code class="language-toml">[target.&quot;x86_64/windows.json&quot;.dependencies]
winhttp = &quot;0.4.0&quot;

[target.&quot;i686/linux.json&quot;.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }

[target.&quot;x86_64/linux.json&quot;.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<h3><a class="header" href="#development-dependencies" id="development-dependencies">Development dependencies</a></h3>
<blockquote>
<p>开发(Dev)依赖项</p>
</blockquote>
<p>你可以添加一个<code>[dev-dependencies]</code>表格到<code>Cargo.toml</code>，其格式相当于<code>[dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = &quot;0.3&quot;
</code></pre>
<p>编译用于构建的包时，不会使用 Dev 依赖，但用于编译测试，示例和基准。</p>
<p>这些依赖关系是<em>不会</em>传播到依赖于此包的其他包.</p>
<p>您还可以让<code>dev-dependencies</code>具有特定目标的开发依赖项，而不是<code>dependencies</code>标题。例如:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = &quot;0.0.1&quot;
</code></pre>
<h3><a class="header" href="#build-dependencies" id="build-dependencies">Build dependencies</a></h3>
<blockquote>
<p>构建 依赖项</p>
</blockquote>
<p>您可以在构建脚本中使用，依赖其他基于 Cargo 的箱。依赖关系是由清单的<code>build-dependencies</code>部分定义:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>构建脚本<strong>并不是</strong>有权访问中 dependencies<code>要么</code>dev-dependencies<code>部分列出的依赖项</code>。除非也在<code>dependencies</code>部分下面列出，否则构建依赖项同样不可用于包本身。包本身及其构建脚本是分开构建的，因此它们的依赖关系不重合。通过将独立依赖用于独立目的，使 Cargo 更简单，更清洁。</p>
<h3><a class="header" href="#choosing-features" id="choosing-features">Choosing features</a></h3>
<blockquote>
<p>选择 特性</p>
</blockquote>
<p>如果您依赖的包提供条件特性，您可以指定使用哪个:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不会包括默认特性， 和 任君选
                         # 单特性
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<p>有关 features 的更多信息，请参阅<a href="reference/./manifest.html#the-features-section">清单文档</a>.</p>
<h3><a class="header" href="#renaming-dependencies-in-cargotoml" id="renaming-dependencies-in-cargotoml">Renaming dependencies in <code>Cargo.toml</code></a></h3>
<blockquote>
<p>在<code>Cargo.toml</code>中的重命名依赖项</p>
</blockquote>
<p>写<code>Cargo.toml</code>的<code>[dependencies]</code>部分的时候，您为依赖项编写的字段通常与您在代码中导入的包的名称相匹配。但是，对于某些项目，您可能希望在代码中引用具有不同名称的包，而不管它是如何在 crates.io 上发布的。例如，您可能希望:</p>
<ul>
<li>避免在 Rust 代码常用<code>use foo as bar</code>.</li>
<li>依赖箱子的多个版本.</li>
<li>依赖来自不同注册表管理机构的同名箱.</li>
</ul>
<p>为了支持这个 ，Cargo 在<code>[dependencies]</code>部分使用 一个<code>package</code>字段，决定应该依赖哪个包:</p>
<pre><code class="language-toml">[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;

[dependencies]
foo = &quot;0.1&quot;
bar = { git = &quot;https://github.com/example/project&quot;, package = &quot;foo&quot; }
baz = { version = &quot;0.1&quot;, registry = &quot;custom&quot;, package = &quot;foo&quot; }
</code></pre>
<p>在此示例中，Rust 代码中现在提供了三个包:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`
<span class="boring">}
</span></code></pre></pre>
<p>所有这三个箱的包名称在他们自己<code>Cargo.toml</code>，都是<code>foo</code>，所以我们明确地告知 Cargo ，使用的是我们想要的<code>package</code>字段(如 package = &quot;foo&quot;包名，即我们在本地调用其他东西)。如果没有指定<code>package</code>，则默认为所请求的依赖项的名称。</p>
<p>请注意，如果您有一个可选的(optional)依赖项，例如:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = &quot;0.1&quot;, package = 'bar', optional = true }
</code></pre>
<p>你依赖于一个<code>bar</code>箱子，其来自 crates.io，但你箱子有一个<code>foo</code>特性，取代了一个<code>bar</code>特性。也就是说，在重命名时，特性的名称拿掉了依赖项的名称，而不是包名称。</p>
<p>启用传递依赖项的工作方式类似，例如我们可以将以下内容，添加到上面的清单中:</p>
<pre><code class="language-toml">[features]
log-debug = ['foo/log-debug'] # 使用 'bar/log-debug' 就会出现一个错误!
</code></pre>
<h2><a class="header" href="#overriding-dependencies" id="overriding-dependencies">Overriding Dependencies</a></h2>
<p>The desire to override a dependency can arise through a number of scenarios.
Most of them, however, boil down to the ability to work with a crate before
it's been published to <a href="https://crates.io/">crates.io</a>. For example:</p>
<ul>
<li>A crate you're working on is also used in a much larger application you're
working on, and you'd like to test a bug fix to the library inside of the
larger application.</li>
<li>An upstream crate you don't work on has a new feature or a bug fix on the
master branch of its git repository which you'd like to test out.</li>
<li>You're about to publish a new major version of your crate, but you'd like to
do integration testing across an entire package to ensure the new major
version works.</li>
<li>You've submitted a fix to an upstream crate for a bug you found, but you'd
like to immediately have your application start depending on the fixed
version of the crate to avoid blocking on the bug fix getting merged.</li>
</ul>
<p>These scenarios can be solved with the <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> manifest
section</a>.</p>
<p>This chapter walks through a few different use cases, and includes details
on the different ways to override a dependency.</p>
<ul>
<li>Example use cases
<ul>
<li><a href="reference/overriding-dependencies.html#testing-a-bugfix">Testing a bugfix</a></li>
<li><a href="reference/overriding-dependencies.html#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a>
<ul>
<li><a href="reference/overriding-dependencies.html#overriding-repository-url">Overriding repository URL</a></li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#prepublishing-a-breaking-change">Prepublishing a breaking change</a></li>
<li><a href="reference/overriding-dependencies.html#using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></li>
</ul>
</li>
<li>Reference
<ul>
<li><a href="reference/overriding-dependencies.html#the-patch-section">The <code>[patch]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#the-replace-section">The <code>[replace]</code> section</a></li>
<li><a href="reference/overriding-dependencies.html#paths-overrides"><code>paths</code> overrides</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: See also specifying a dependency with <a href="reference/specifying-dependencies.html#multiple-locations">multiple locations</a>, which
can be used to override the source for a single dependency declaration in a
local package.</p>
</blockquote>
<h3><a class="header" href="#testing-a-bugfix" id="testing-a-bugfix">Testing a bugfix</a></h3>
<p>Let's say you're working with the <a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a> but while you're working on it
you discover a bug. You are, however, quite enterprising so you decide to also
try to fix the bug! Originally your manifest will look like:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0&quot;
</code></pre>
<p>First thing we'll do is to clone the <a href="https://github.com/uuid-rs/uuid"><code>uuid</code> repository</a>
locally via:</p>
<pre><code class="language-console">$ git clone https://github.com/uuid-rs/uuid
</code></pre>
<p>Next we'll edit the manifest of <code>my-library</code> to contain:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
</code></pre>
<p>Here we declare that we're <em>patching</em> the source <code>crates-io</code> with a new
dependency. This will effectively add the local checked out version of <code>uuid</code> to
the crates.io registry for our local package.</p>
<p>Next up we need to ensure that our lock file is updated to use this new version
of <code>uuid</code> so our package uses the locally checked out copy instead of one from
crates.io. The way <code>[patch]</code> works is that it'll load the dependency at
<code>../path/to/uuid</code> and then whenever crates.io is queried for versions of <code>uuid</code>
it'll <em>also</em> return the local version.</p>
<p>This means that the version number of the local checkout is significant and will
affect whether the patch is used. Our manifest declared <code>uuid = &quot;1.0&quot;</code> which
means we'll only resolve to <code>&gt;= 1.0.0, &lt; 2.0.0</code>, and Cargo's greedy resolution
algorithm also means that we'll resolve to the maximum version within that
range. Typically this doesn't matter as the version of the git repository will
already be greater or match the maximum version published on crates.io, but it's
important to keep this in mind!</p>
<p>In any case, typically all you need to do now is:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>And that's it! You're now building with the local version of <code>uuid</code> (note the
path in parentheses in the build output). If you don't see the local path version getting
built then you may need to run <code>cargo update -p uuid --precise $version</code> where
<code>$version</code> is the version of the locally checked out copy of <code>uuid</code>.</p>
<p>Once you've fixed the bug you originally found the next thing you'll want to do
is to likely submit that as a pull request to the <code>uuid</code> crate itself. Once
you've done this then you can also update the <code>[patch]</code> section. The listing
inside of <code>[patch]</code> is just like the <code>[dependencies]</code> section, so once your pull
request is merged you could change your <code>path</code> dependency to:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
</code></pre>
<h3><a class="header" href="#working-with-an-unpublished-minor-version-1" id="working-with-an-unpublished-minor-version-1">Working with an unpublished minor version</a></h3>
<p>Let's now shift gears a bit from bug fixes to adding features. While working on
<code>my-library</code> you discover that a whole new feature is needed in the <code>uuid</code>
crate. You've implemented this feature, tested it locally above with <code>[patch]</code>,
and submitted a pull request. Let's go over how you continue to use and test it
before it's actually published.</p>
<p>Let's also say that the current version of <code>uuid</code> on crates.io is <code>1.0.0</code>, but
since then the master branch of the git repository has updated to <code>1.0.1</code>. This
branch includes your new feature you submitted previously. To use this
repository we'll edit our <code>Cargo.toml</code> to look like</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;

[dependencies]
uuid = &quot;1.0.1&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
</code></pre>
<p>Note that our local dependency on <code>uuid</code> has been updated to <code>1.0.1</code> as it's
what we'll actually require once the crate is published. This version doesn't
exist on crates.io, though, so we provide it with the <code>[patch]</code> section of the
manifest.</p>
<p>Now when our library is built it'll fetch <code>uuid</code> from the git repository and
resolve to 1.0.1 inside the repository instead of trying to download a version
from crates.io. Once 1.0.1 is published on crates.io the <code>[patch]</code> section can
be deleted.</p>
<p>It's also worth noting that <code>[patch]</code> applies <em>transitively</em>. Let's say you use
<code>my-library</code> in a larger package, such as:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid' }
</code></pre>
<p>Remember that <code>[patch]</code> is applicable <em>transitively</em> but can only be defined at
the <em>top level</em> so we consumers of <code>my-library</code> have to repeat the <code>[patch]</code> section
if necessary. Here, though, the new <code>uuid</code> crate applies to <em>both</em> our dependency on
<code>uuid</code> and the <code>my-library -&gt; uuid</code> dependency. The <code>uuid</code> crate will be resolved to
one version for this entire crate graph, 1.0.1, and it'll be pulled from the git
repository.</p>
<h4><a class="header" href="#overriding-repository-url-1" id="overriding-repository-url-1">Overriding repository URL</a></h4>
<p>In case the dependency you want to override isn't loaded from <code>crates.io</code>,
you'll have to change a bit how you use <code>[patch]</code>. For example, if the
dependency is a git dependency, you can override it to a local path with:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
</code></pre>
<p>And that's it!</p>
<h3><a class="header" href="#prepublishing-a-breaking-change-1" id="prepublishing-a-breaking-change-1">Prepublishing a breaking change</a></h3>
<p>Let's take a look at working with a new major version of a crate, typically
accompanied with breaking changes. Sticking with our previous crates, this
means that we're going to be creating version 2.0.0 of the <code>uuid</code> crate. After
we've submitted all changes upstream we can update our manifest for
<code>my-library</code> to look like:</p>
<pre><code class="language-toml">[dependencies]
uuid = &quot;2.0&quot;

[patch.crates-io]
uuid = { git = &quot;https://github.com/uuid-rs/uuid&quot;, branch = &quot;2.0.0&quot; }
</code></pre>
<p>And that's it! Like with the previous example the 2.0.0 version doesn't actually
exist on crates.io but we can still put it in through a git dependency through
the usage of the <code>[patch]</code> section. As a thought exercise let's take another
look at the <code>my-binary</code> manifest from above again as well:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid', branch = '2.0.0' }
</code></pre>
<p>Note that this will actually resolve to two versions of the <code>uuid</code> crate. The
<code>my-binary</code> crate will continue to use the 1.x.y series of the <code>uuid</code> crate but
the <code>my-library</code> crate will use the <code>2.0.0</code> version of <code>uuid</code>. This will allow you
to gradually roll out breaking changes to a crate through a dependency graph
without being force to update everything all at once.</p>
<h3><a class="header" href="#using-patch-with-multiple-versions" id="using-patch-with-multiple-versions">Using <code>[patch]</code> with multiple versions</a></h3>
<p>You can patch in multiple versions of the same crate with the <code>package</code> key
used to rename dependencies. For example let's say that the <code>serde</code> crate has
a bugfix that we'd like to use to its <code>1.*</code> series but we'd also like to
prototype using a <code>2.0.0</code> version of serde we have in our git repository. To
configure this we'd do:</p>
<pre><code class="language-toml">[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde' }
serde2 = { git = 'https://github.com/example/serde', package = 'serde', branch = 'v2' }
</code></pre>
<p>The first <code>serde = ...</code> directive indicates that serde <code>1.*</code> should be used
from the git repository (pulling in the bugfix we need) and the second <code>serde2 = ...</code> directive indicates that the <code>serde</code> package should also be pulled from
the <code>v2</code> branch of <code>https://github.com/example/serde</code>. We're assuming here
that <code>Cargo.toml</code> on that branch mentions version <code>2.0.0</code>.</p>
<p>Note that when using the <code>package</code> key the <code>serde2</code> identifier here is actually
ignored. We simply need a unique name which doesn't conflict with other patched
crates.</p>
<h3><a class="header" href="#the-patch-section" id="the-patch-section">The <code>[patch]</code> section</a></h3>
<p>The <code>[patch]</code> section of <code>Cargo.toml</code> can be used to override dependencies
with other copies. The syntax is similar to the
<a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> section:</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }
</code></pre>
<p>The <code>[patch]</code> table is made of dependency-like sub-tables. Each key after
<code>[patch]</code> is a URL of the source that is being patched, or the name of a
registry. The name <code>crates-io</code> may be used to override the default registry
<a href="https://crates.io/">crates.io</a>. The first <code>[patch]</code> in the example above demonstrates overriding
<a href="https://crates.io/">crates.io</a>, and the second <code>[patch]</code> demonstrates overriding a git source.</p>
<p>Each entry in these tables is a normal dependency specification, the same as
found in the <code>[dependencies]</code> section of the manifest. The dependencies listed
in the <code>[patch]</code> section are resolved and used to patch the source at the
URL specified. The above manifest snippet patches the <code>crates-io</code> source (e.g.
crates.io itself) with the <code>foo</code> crate and <code>bar</code> crate. It also
patches the <code>https://github.com/example/baz</code> source with a <code>my-branch</code> that
comes from elsewhere.</p>
<p>Sources can be patched with versions of crates that do not exist, and they can
also be patched with versions of crates that already exist. If a source is
patched with a crate version that already exists in the source, then the
source's original crate is replaced.</p>
<h3><a class="header" href="#the-replace-section" id="the-replace-section">The <code>[replace]</code> section</a></h3>
<blockquote>
<p><strong>Note</strong>: <code>[replace]</code> is deprecated. You should use the
<a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> table instead.</p>
</blockquote>
<p>This section of Cargo.toml can be used to override dependencies with other
copies. The syntax is similar to the <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">[replace]
&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo' }
&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }
</code></pre>
<p>Each key in the <code>[replace]</code> table is a <a href="reference/pkgid-spec.html">package ID
specification</a>, which allows arbitrarily choosing a node in the
dependency graph to override (the 3-part version number is required). The
value of each key is the same as the <code>[dependencies]</code> syntax for specifying
dependencies, except that you can't specify features. Note that when a crate
is overridden the copy it's overridden with must have both the same name and
version, but it can come from a different source (e.g., git or a local path).</p>
<h3><a class="header" href="#paths-overrides" id="paths-overrides"><code>paths</code> overrides</a></h3>
<p>Sometimes you're only temporarily working on a crate and you don't want to have
to modify <code>Cargo.toml</code> like with the <code>[patch]</code> section above. For this use
case Cargo offers a much more limited version of overrides called <strong>path
overrides</strong>.</p>
<p>Path overrides are specified through <a href="reference/config.html"><code>.cargo/config.toml</code></a> instead of
<code>Cargo.toml</code>. Inside of <code>.cargo/config.toml</code> you'll specify a key called <code>paths</code>:</p>
<pre><code class="language-toml">paths = [&quot;/path/to/uuid&quot;]
</code></pre>
<p>This array should be filled with directories that contain a <code>Cargo.toml</code>. In
this instance, we’re just adding <code>uuid</code>, so it will be the only one that’s
overridden. This path can be either absolute or relative to the directory that
contains the <code>.cargo</code> folder.</p>
<p>Path overrides are more restricted than the <code>[patch]</code> section, however, in
that they cannot change the structure of the dependency graph. When a
path replacement is used then the previous set of dependencies
must all match exactly to the new <code>Cargo.toml</code> specification. For example this
means that path overrides cannot be used to test out adding a dependency to a
crate, instead <code>[patch]</code> must be used in that situation. As a result usage of a
path override is typically isolated to quick bug fixes rather than larger
changes.</p>
<p>Note: using a local configuration to override paths will only work for crates
that have been published to <a href="https://crates.io/">crates.io</a>. You cannot use this feature to tell
Cargo how to find local unpublished crates.</p>
<h2><a class="header" href="#the-manifest-format" id="the-manifest-format">The Manifest Format</a></h2>
<blockquote>
<p>清单格式</p>
</blockquote>
<p>每个包的这个<code>Cargo.toml</code>文件称为<em>清单</em>. 每个清单文件由一个或多个部分(表格)组成.</p>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="reference/manifest.html#the-package-section"><code>[package]</code> 部分</a></li>
<li><a href="reference/manifest.html#dependency-sections">依赖项 部分</a></li>
<li><a href="reference/manifest.html#the-profile-sections"><code>[profile.*]</code> 部分</a></li>
<li><a href="reference/manifest.html#the-features-section"><code>[features]</code> 部分</a></li>
<li><a href="reference/manifest.html#the-workspace-section"><code>[workspace]</code> 部分</a></li>
<li><a href="reference/manifest.html#the-project-layout">项目布局</a></li>
<li><a href="reference/manifest.html#examples">Rust 示例</a></li>
<li><a href="reference/manifest.html#tests">Rust 测试</a></li>
<li><a href="reference/manifest.html#configuring-a-target">配置一个 target</a></li>
<li><a href="reference/manifest.html#the-patch-section"><code>[patch]</code> 部分</a></li>
<li><a href="reference/manifest.html#the-replace-section"><code>[replace]</code> 部分</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h3><a class="header" href="#the-package-section" id="the-package-section">The <code>[package]</code> section</a></h3>
<blockquote>
<p><code>[package]</code>部分</p>
</blockquote>
<p><code>Cargo.toml</code>的第一部分是<code>[package]</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot; # the name of the package
version = &quot;0.1.0&quot;    # the current version, obeying semver
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
<p>所有这三个字段都是必要性的.</p>
<h4><a class="header" href="#the-version-field" id="the-version-field">The <code>version</code> field</a></h4>
<blockquote>
<p><code>version</code> 字段</p>
</blockquote>
<p>Cargo 烘烤的概念是<a href="http://semver.org/">语义版本控制</a>，所以确保你遵循一些基本规则:</p>
<ul>
<li>在您达到 1.0.0 之前，任何事情都会发生，但是如果您进行了重大变化的更新，则增加次要(minor)版本。在 Rust 语言中，重大变化包括，向结构添加字段，或增加变量到枚举。</li>
<li>在 1.0.0 之后，只在增加主要(major)版本时进行重大变化。不要破坏建筑.</li>
<li>在 1.0.0 之后，不要在补丁级别(patch)的版本添加任何新的公共 API(没有任何新的<code>pub</code>)。如果添加<code>pub</code>结构、特性、字段、类型、函数、方法或其他任何东东，则总是增加次要版本。</li>
<li>使用具有三个数字部分的版本号，如 1.0.0，而不是 1.0。</li>
</ul>
<h4><a class="header" href="#the-edition-field-optional" id="the-edition-field-optional">The <code>edition</code> field (optional)</a></h4>
<blockquote>
<p><code>edition</code> 字段 (可选)</p>
</blockquote>
<p>您可以在<code>Cargo.toml</code>中的<code>edition</code>字段，选择一个特定的 Rust 版本，用于您的包。 如果没有指定版本,它将默认为 2015。</p>
<pre><code class="language-toml">[package]
# ...
edition = '2018'
</code></pre>
<p>这个<code>edition</code>字段会影响到您的包编译的版本。若是通过<code>cargo new</code>得来的项目，Cargo 将始终让<code>edition</code>字段设置为最新版本。设置<code>[package]</code>下的<code>edition</code>字段将影响包中的所有目标/箱，包括测试套件、基准、二进制文件、示例等。</p>
<h4><a class="header" href="#the-build-field-optional" id="the-build-field-optional">The <code>build</code> field (optional)</a></h4>
<blockquote>
<p><code>build</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定包根目录中的文件，该文件是<a href="reference/./build-scripts.html">构建脚本</a>，用于生成本机代码。可以在构建脚本<a href="reference/./build-scripts.html">指导</a>中找到更多信息..</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<h4><a class="header" href="#the-links-field-optional" id="the-links-field-optional">The <code>links</code> field (optional)</a></h4>
<blockquote>
<p><code>links</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定，要链接到的本机库名，更多信息可以在构建脚本指南的<a href="reference/./build-scripts.html#the-links-manifest-key"><code>links</code></a>部分.</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
build = &quot;build.rs&quot;
</code></pre>
<h4><a class="header" href="#the-documentation-field-optional" id="the-documentation-field-optional">The <code>documentation</code> field (optional)</a></h4>
<blockquote>
<p><code>documentation</code> 字段 (可选)</p>
</blockquote>
<p>此字段指定托管箱(crate)文档的网站的 URL。如果清单文件中没有指定 URL，<a href="https://crates.io/">crates.io</a>自动将你的箱子连接到相应的箱子的<a href="https://docs.rs/">docs.rs</a>页.</p>
<p>来自特定主机的文档链接被列入黑名单。如果已知主机不承载文档，并且可能具有恶意意图，例如广告跟踪网络，则主机被添加到黑名单中。下列主机的 URL 就被列入黑名单:</p>
<ul>
<li>rust-ci.org</li>
</ul>
<p>来自黑名单主机的文档 URL 将不会出现在 crates.io 上，并且可能被 docs.rs 链接替换。</p>
<h4><a class="header" href="#the-exclude-and-include-fields-optional" id="the-exclude-and-include-fields-optional">The <code>exclude</code> and <code>include</code> fields (optional)</a></h4>
<blockquote>
<p><code>exclude</code> 和 <code>include</code> 字段 (可选)</p>
</blockquote>
<p>出于打包和重建包的目的，您可以显式地指定一组<a href="https://docs.rs/glob/0.2.11/glob/struct.Pattern.md">globs</a>模式，匹配项应被忽略或包含。如<code>exclude</code>字段标识了在发布包时，不包括的一组文件，以及检测何时重建包时，应该忽略的文件，而<code>include</code>就是显式指定一定包含的文件。</p>
<p>如果一个 VCS 被用于一个包，则<code>exclude</code>字段将被植入 VCS 的忽略设置(例如 Git 的<code>.gitignore</code>)。</p>
<pre><code class="language-toml">[package]
# ...
exclude = [&quot;build/**/*.o&quot;, &quot;doc/**/*.md&quot;]
</code></pre>
<pre><code class="language-toml">[package]
# ...
include = [&quot;src/**/*&quot;, &quot;Cargo.toml&quot;]
</code></pre>
<p>选项是相互排斥的: <code>include</code>设置覆盖<code>exclude</code>。 注意<code>include</code>必须是文件的详尽列表，否则可能不包括必要的源文件。</p>
<h4><a class="header" href="#migrating-to-gitignore-like-pattern-matching" id="migrating-to-gitignore-like-pattern-matching">Migrating to <code>gitignore</code>-like pattern matching</a></h4>
<blockquote>
<p>转移成 类<code>gitignore</code> 模式匹配</p>
</blockquote>
<p>这些配置的当前解释实现都基于 UNIX Globs，如<a href="https://crates.io/crates/glob"><code>glob</code>箱</a>。 若是我们想要 Cargo 的<code>include</code>和<code>exclude</code>尽可能配置为类似于<code>gitignore</code>。可看看<a href="https://git-scm.com/docs/gitignore">这个<code>gitignore</code>规范</a>，其也是基于 Globs 的，但是还有许多其他的特性，这些特性使模式编写更容易，控制也更多。因此，我们正在迁移这些配置规则的解释实现，以使用<a href="https://crates.io/crates/ignore"><code>ignore</code>箱</a>，并认真对待<code>gitignore</code>文件的每一条行规则。见<a href="https://github.com/rust-lang/cargo/issues/4268">跟踪问题</a>有关迁移的更多细节。</p>
<h4><a class="header" href="#the-publish-field-optional" id="the-publish-field-optional">The <code>publish</code> field (optional)</a></h4>
<blockquote>
<p><code>publish</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>publish</code>字段通过错误，防止将包(crate)，发布到包注册中心(如<em>crates.io</em>)。</p>
<pre><code class="language-toml">[package]
# ...
publish = false
</code></pre>
<h4><a class="header" href="#the-workspace-field-optional" id="the-workspace-field-optional">The <code>workspace</code> field (optional)</a></h4>
<blockquote>
<p><code>workspace</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>workspace</code>字段可用于配置此包将属于的工作区。如果没有指定，这将被推断为文件系统中第一个 Cargo.toml 的<code>[workspace]</code>。</p>
<pre><code class="language-toml">[package]
# ...
workspace = &quot;path/to/workspace/root&quot;
</code></pre>
<p>有关更多信息，请参见下面的工作区(workspace)表格的文档.</p>
<h4><a class="header" href="#package-metadata" id="package-metadata">Package metadata</a></h4>
<blockquote>
<p>包 元信息</p>
</blockquote>
<p><code>[package]</code>部分会接受许多可选的元数据字段:</p>
<pre><code class="language-toml">[package]
# ...

# 关于包的简短介绍. 这不会以任何格式呈现
# 到 crates.io (又名 这不是markdown).
description = &quot;...&quot;

# 这些URL指向有关包的更多信息 这些是
# 旨在成为相关数据的网页入口， 不一定兼容
# VCS工具(类似的)等.
documentation = &quot;...&quot;
homepage = &quot;...&quot;
repository = &quot;...&quot;

# 这指向包根目录下的文件 (与 `Cargo.toml` 相对的).
# 该文件的内容会存储，并在注册表中编入索引。
# crates.io 将渲染此文件，并将结果放在包的页面上.
readme = &quot;...&quot;

# 这是一个，最多五个描述此箱的关键字的列表. 关键词
# 可以在 crates.io 上搜索, 和你可以选择任何单词
# 帮助别人找到这个箱子。
keywords = [&quot;...&quot;, &quot;...&quot;]

# 这是此箱子最适合的(最多五个)类别的列表.
# 类别是 crates.io/category_slugs 上可用的固定列表, 和
# 他们必须完全匹配.
categories = [&quot;...&quot;, &quot;...&quot;]

# 这是此包的SPDX 2.1许可证表达式.  目前
# crates.io将根据白名单的已知许可证和SPDX许可证列表2.4中的异常标识符，
# 验证提供的许可证。目前不支持括号。
#
# 使用AND和OR的许可证表达式
# 运算符以获得更明确的语义。
license = &quot;...&quot;

# 如果程序包使用非标准许可证, 则可以指定此 key
# 代替上述 key 和 必须指向相对于此清单的文件
# (类似于 readme key).
license-file = &quot;...&quot;

# 要在crates.io上显示的徽章规范，的可选项。
#
#  - 与当前可用的构建状态有关的徽章是
#   Appveyor, CircleCI, GitLab, 和 TravisCI.
# - 与代码测试覆盖有关的可用徽章是 Codecov 和
#   Coveralls.
# - 还有基于 isitmaintained.com的维护相关徽章
#   其中说明了问题解决时间，未决问题的百分比和未来
#   维护意图。
#
# 若要求一个`repository` key, 就表示一个`user/repo` 格式的存储库
[badges]

# Appveyor: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`; `id` 是可选的; 如果你想改用，可以指定appveyor 项目ID.
# `project_name` 是可选的; 使用在 repository
# 名称 与 appveyor 项目名称 不同的情况.
appveyor = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# Circle CI: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
circle-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# GitLab: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
gitlab = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# Travis CI: `repository`为 &quot;&lt;user&gt;/&lt;project&gt;&quot;格式 是必须的.
# `branch` 是可选的; 默认为 `master`
travis-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }

# Codecov: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认), `bitbucket`, 和
# `gitlab`.
codecov = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# Coveralls: `repository` 是必须的. `branch` 是可选的; 默认为 `master`
# `service` 是可选的; 有效值是 `github` (默认) 和 `bitbucket`.
coveralls = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }

# 是否保持解决时间: `repository` 是必须的.
is-it-maintained-issue-resolution = { repository = &quot;...&quot; }

# 它是否保持未解决问题的百分比: `repository` 是必须的.
is-it-maintained-open-issues = { repository = &quot;...&quot; }

# Maintenance: `status` 是必须的. 可用的选项是 `actively-developed`,
# `passively-maintained`, `as-is`, `experimental`, `looking-for-maintainer`,
# `deprecated`, 和 默认为 `none`, 不会在 crates.io 显示徽章.
maintenance = { status = &quot;...&quot; }
</code></pre>
<p>这个<a href="https://crates.io">crates.io</a>注册中心将呈现描述、显示许可证、链接到三个 URL 并根据关键字进行分类。这些字段为注册表的用户提供有用的信息，并且还影响箱子的搜索排名。在发布箱的'展示栏'，省略任何东西都是非常令人沮丧的。</p>
<p>SPDX 2.1 许可证表达式被记录在案<a href="https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">在这里</a>。 许可证列表的当前版本可用的，<a href="https://spdx.org/licenses/">在这里</a>，版本 2.4 是可用的，<a href="https://github.com/spdx/license-list-data/tree/v2.4">在这里</a>.</p>
<h4><a class="header" href="#the-metadata-table-optional" id="the-metadata-table-optional">The <code>metadata</code> table (optional)</a></h4>
<blockquote>
<p><code>metadata</code> 表格 (可选)</p>
</blockquote>
<p>默认情况下，Cargo 将对<code>Cargo.toml</code>不使用的字段发出警告，协助检测错别字等。就像这个<code>package.metadata</code>表格，但是，完全不写了的话， Cargo 将不会被警告。这个表格可在<code>Cargo.toml</code>，用于将包配置存储好。 例如:</p>
<pre><code class="language-toml">[package]
name = &quot;...&quot;
# ...

# 当要生成一个 Android APK，这个元信息会被使用, 例如.
[package.metadata.android]
package-name = &quot;my-awesome-android-app&quot;
assets = &quot;path/to/static&quot;
</code></pre>
<h3><a class="header" href="#dependency-sections" id="dependency-sections">Dependency sections</a></h3>
<blockquote>
<p>依赖 部分</p>
</blockquote>
<p>见<a href="reference/./specifying-dependencies.html">指定依赖-那页</a>有关<code>[dependencies]</code>，<code>[dev-dependencies]</code>，<code>[build-dependencies]</code>和特定目标的<code>[target.*.dependencies]</code>部分的信息。</p>
<h3><a class="header" href="#the-profile-sections" id="the-profile-sections">The <code>[profile.*]</code> sections</a></h3>
<blockquote>
<p><code>[profile.*]</code> 部分</p>
</blockquote>
<p>Cargo 支持了，可通过顶层 配置文件(profile) 调用 rustc 的自定义配置。任何清单都可以声明一个配置文件，但是实际上只读取顶级包的配置文件。所有依赖项的配置文件都将被重写，这样做是为了让顶级包能够控制，其依赖项如何编译的。</p>
<p>目前有四个受支持的配置文件名称，它们都具有相同的配置。下面列出了可用的配置，以及每个配置文件的默认设置.</p>
<pre><code class="language-toml"># 此为 开发配置文件, 给 `cargo build` 所使用.
[profile.dev]
opt-level = 0      # 控制编译器构建的`--opt-level`。
                   # 0-1适合调试。 2是良好优化的。最大为 3。
                   # 's' 企图优化大小, 'z' 则 进一步优化大小.
debug = true       # (u32 or bool) 包括调试信息（调试符号）.
                   # 相当于 `-C debuginfo=2` 编译器 标志.
rpath = false      # 控制 编译器 是否应该设置加载器路径.
                   # 若为 true, 传递 `-C rpath` 标志 给 编译器.
lto = false        # 链接时间优化通常会减少二进制文件和静态库的大小
                   # 但会增加编译时间.
                   # 若是 true, 传递 `-C lto` 标志 给 编译器, 和 若是一个
                   # 字符串值 像 'thin' ，那会传递 `-C lto=thin`
                   # 给 编译器
debug-assertions = true # 控制是否启用调试断言
                   # (e.g. debug_assert!() 和 算术溢出检查)
codegen-units = 16 # if &gt; 1 并行代码生成，以改善
                   # 编译时间, 但阻止了些优化.
                   # 传递 `-C codegen-units`.
panic = 'unwind'   # 恐慌策略 (`-C panic=...`), 也可以是 'abort'
incremental = true # 是否启用增量编译
overflow-checks = true # 使用溢出检查进行整数运算。
                   # 传递 `-C overflow-checks=...`标志 给 compiler.

# 发布(release)的配置文件, 用于 `cargo build --release` (和 依赖项的
# `cargo test --release`,  包括本地 library 或 binary).
[profile.release]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false

# 测试的配置文件, 用于 `cargo test` (对于 `cargo test --release`，可看
# `release` 和 `bench` 配置文件).
[profile.test]
opt-level = 0
debug = 2
rpath = false
lto = false
debug-assertions = true
codegen-units = 16
panic = 'unwind'
incremental = true
overflow-checks = true

# 基准的配置文件, 用于`cargo bench` (和 要测试的目标 和
# 单元测试的 `cargo test --release`).
[profile.bench]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 16
panic = 'unwind'
incremental = false
overflow-checks = false
</code></pre>
<h3><a class="header" href="#the-features-section" id="the-features-section">The <code>[features]</code> section</a></h3>
<blockquote>
<p><code>[features]</code> 部分</p>
</blockquote>
<p>Cargo 支持特性，允许表达:</p>
<ul>
<li>条件编译选项(通过<code>cfg</code>属性);</li>
<li>可选的依赖项，增强了包，但不是必需的;还有</li>
<li>可选依赖项的簇，如<code>postgres</code>，其中就包括<code>postgres</code>包<code>postgres-macros</code>包，以及可能的其他包(如开发时的模拟库、调试工具等)。</li>
</ul>
<p>包的特性也可以是可选的依赖项，也可以是一组其他特性。指定特性的格式是:</p>
<pre><code class="language-toml">[package]
name = &quot;awesome&quot;

[features]
# 默认的可选包集。大多数人都想使用这些
# 包, 但它们是严格可选的。请注意，`session`不是包
# 而是此清单中列出的另一个功能。
default = [&quot;jquery&quot;, &quot;uglifier&quot;, &quot;session&quot;]

# 没有依赖关系的特性，主要用于条件编译，
# 像 `#[cfg(feature = &quot;go-faster&quot;)]`.
go-faster = []

# `secure-password` 特性 需要 bcrypt 包. 这种别名
将允许人们以更高级别的方式讨论该 特性 和 允许
# 此软件包将在未来为该特性添加更多要求.
secure-password = [&quot;bcrypt&quot;]

# 特性可用于重新导出其他包的特性. `awesome`包的 `session`
# 特性将确保 cookie/session 也是可用的
session = [&quot;cookie/session&quot;]

[dependencies]
# 这些包是强制性的，是该软件包发行版的核心。
cookie = &quot;1.2.0&quot;
oauth = &quot;1.1.0&quot;
route-recognizer = &quot;=2.1.0&quot;

# 所以可选依赖项的列表, 其中一些是上面的
# `features`. 它们可以通过应用程序选择加入。
jquery = { version = &quot;1.0.2&quot;, optional = true }
uglifier = { version = &quot;1.5.3&quot;, optional = true }
bcrypt = { version = &quot;*&quot;, optional = true }
civet = { version = &quot;*&quot;, optional = true }
</code></pre>
<p>使用<code>awesome</code>包:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不包括默认功能，和可选,
                         # 任君选 个性化特性
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<h4><a class="header" href="#rules" id="rules">Rules</a></h4>
<blockquote>
<p>规则</p>
</blockquote>
<p>特性的使用遵循一些规则:</p>
<ul>
<li>特性名称不能与清单中的其他包名称冲突。这是因为他们被选择加入<code>features = [...]</code>，而它只有一个命名空间。</li>
<li>除此<code>default</code>特性之外，所有的特性都是可选的。若要退出默认功能，请使用<code>default-features = false</code>，任君选择个人特性.</li>
<li>特性群组不允许周期性地相互依赖.</li>
<li>开发 依赖项不能是可选的.</li>
<li>特性群组只能引用可选的依赖项.</li>
<li>当选择一个特性时，Cargo 将调用具有<code>--cfg feature=&quot;${feature_name}&quot;</code>的<code>rustc</code>。如果包含一个特性群组，那么它将包括所有单独的特性。这可以通过<code>#[cfg(feature = &quot;foo&quot;)]</code>在代码中进行测试..</li>
</ul>
<p>主要注意的是，显露的特性，实际上不激活任何可选的依赖项。这就允许包在不需要新的依赖项的情况下，于内部启用/禁用特性。</p>
<h4><a class="header" href="#usage-in-end-products" id="usage-in-end-products">Usage in end products</a></h4>
<blockquote>
<p>生产终点的用法</p>
</blockquote>
<p>该特性的一个主要用例是在最终产品中，指定可选特性。例如，Servo 包可能希望包含可选特性，人们可以在构建时，启用或禁用它。</p>
<p>在这种情况下，Servo 将在<code>Cargo.toml</code>描述特性，且用命令行标志来启用这些特性:</p>
<pre><code class="language-console">$ cargo build --release --features &quot;shumway pdf&quot;
</code></pre>
<p>可以使用<code>--no-default-features</code>，排除默认特性。</p>
<h4><a class="header" href="#usage-in-packages" id="usage-in-packages">Usage in packages</a></h4>
<blockquote>
<p>包(库)的用法</p>
</blockquote>
<p>在大多数情况下，在库中<em>可选依赖</em>的概念，最好将其表示为顶级应用程序所依赖的单独包。</p>
<p>然而，像 Iron 或 Piston 这样的高级软件包会需要排布多个软件包以便于安装。当前的 Cargo 系统允许它们将一些强制依赖项，整合到一个包中，以便于安装。</p>
<p>在某些情况下，包可能希望为可选依赖项，提供额外的管理:</p>
<ul>
<li>将多个低层可选依赖项，组合到一个单独的高级特性中;</li>
<li>由包用户指定推荐(或建议)要包括的包;</li>
<li>包括特性(类似<code>secure-password</code>在激励示例中)，这只在可选的依赖项可用时才能工作，并且很难实现为单独的包(例如，设计一个与 OpenSSL 完全解耦的 IO 包可能过于困难，那这时，就可通过包含单独的包来选择相关特性)。</li>
</ul>
<p>在几乎所有情况下，在设计牢固的高级包之外，使用这些特性都是反模式的。如果某个特性是可选的，那么它几乎可以肯定地表示为单独的包。</p>
<h3><a class="header" href="#the-workspace-section" id="the-workspace-section">The <code>[workspace]</code> section</a></h3>
<blockquote>
<p><code>[workspace]</code> 部分</p>
</blockquote>
<p>包可以定义一个工作区，它是一组箱，所有箱将共享相同<code>Cargo.lock</code>和输出目录。这个<code>[workspace]</code>表格可以定义为:</p>
<pre><code class="language-toml">[workspace]

# 可选字段，从路径依赖推断（如果不存在）。
# 此处必须给出，包含的其他非路径依赖。
# 特别是, 对于 一个虚拟清单，所有成员都要列出来。
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]

# 可选字段, 如果不存在则为空
exclude = [&quot;path1&quot;, &quot;path/to/dir2&quot;]
</code></pre>
<p>工作区作为 Cargo 的<a href="https://github.com/rust-lang/rfcs/blob/master/text/1525-cargo-workspace.md">RFC 1525</a>一部分被添加到 Cargo 中，并具有许多属性:</p>
<ul>
<li>工作区可以包含多个箱，其中一个是<em>根箱</em>.</li>
<li>这个<em>根箱</em>的<code>Cargo.toml</code>包含<code>[workspace]</code>表格，但不要求必有其他配置.</li>
<li>每当编译工作区中的任何箱时，输出被放置在<em>工作区根</em>。 即紧挨着<em>根箱</em>的<code>Cargo.toml</code>.</li>
<li>工作区中所有箱的那个锁定文件驻留在<em>工作区根</em>.</li>
<li>在<code>Cargo.toml</code>的<code>[patch]</code>，<code>[replace]</code>和<code>[profile.*]</code>部分，只认<em>根箱</em>的清单，而忽略成员箱的。</li>
</ul>
<p>这个工作区的<em>根箱</em>，由其清单中存在的<code>[workspace]</code>指定，并负责定义整个工作区。所有驻留在工作区目录中的<code>path</code>依赖项都变成成员。您可以通过<code>members</code>字段将附加包添加到工作区中。请注意，显式列出的工作区成员，也在工作区中包含了它们的路径依赖项。有时候，一个包可能有很多工作区成员，并且都保持最新会很麻烦。</p>
<p>路径依赖也可以使用<a href="https://docs.rs/glob/0.2.11/glob/struct.Pattern.md">globs</a>匹配多个路径。
最后，<code>exclude</code>字段 可以用于将工作路径中的路径列入黑名单。如果根本不希望某些路径依赖项存在于工作区中，那么这非常有用.</p>
<p>这个<code>package.workspace</code>清单字段(如上所述)用于成员箱中，以指向工作区的根箱。如果省略此字段，则推断它是文件系统(向上的父目录)中，清单包含<code>[workspace]</code>的第一个箱。</p>
<p>箱可以指定<code>package.workspace</code>或指定<code>[workspace]</code>。 也就是说，箱不能同时作为工作区中的根箱(包含<code>[workspace]</code>)，和另一个工作区的成员箱(包含<code>package.workspace</code>)</p>
<p>大多数时间工作区都不需要处理。因<code>cargo new</code>和<code>cargo init</code>将自动处理工作区配置。</p>
<h4><a class="header" href="#virtual-manifest" id="virtual-manifest">Virtual Manifest</a></h4>
<blockquote>
<p>虚拟清单</p>
</blockquote>
<p>在工作区清单中，如果<code>package</code>表格存在，则工作区根箱将被视为普通包和工作区。如果<code>package</code>表格不存在工作区清单中，那它被称为<em>虚拟清单</em>。</p>
<h4><a class="header" href="#package-selection" id="package-selection">Package selection</a></h4>
<blockquote>
<p>Package 部分</p>
</blockquote>
<p>在工作区中，与包相关的 Cargo 命令，如<code>cargo build</code>，会应用<code>-p</code> / <code>--package</code>或<code>--all</code>命令行参数选定的包。当未指定时，可选<code>default-members</code>配置被使用:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]
default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]
</code></pre>
<p><code>default-members</code>指定时，必会扩展到子集的<code>members</code>中.</p>
<p>若是<code>default-members</code>未指定，如果它是包，则默认为根清单，或者若是虚拟工作区，就为每个成员的清单(如同<code>--all</code>在命令行上).</p>
<h3><a class="header" href="#the-project-layout" id="the-project-layout">The project layout</a></h3>
<blockquote>
<p>项目布局</p>
</blockquote>
<p>如果包是可执行文件，则将主源文件命名为<code>src/main.rs</code>。 如果它是一个库，请命名主源文件<code>src/lib.rs</code>。</p>
<p>Cargo 也将处理位于<code>src/bin/*.rs</code>任何文件作为可执行文件。如果可执行文件包含不止一个源文件，则可以使用<code>src/bin</code>目录下，又一个包含<code>main.rs</code>文件的目录，而该目录将被视为具有父目录名称的可执行文件。但是，一旦添加了<code>[[bin]]</code>部分<a href="reference/manifest.html#configuring-a-target">见下文</a>，Cargo 将不再自动建立<code>src/bin/*.rs</code>文件。 相反，你必须创建一个<code>[[bin]]</code>部分，给出你想要生成的每个文件。</p>
<!-- HERE -->
<p>您的包可以(可选地)包含命名为<code>examples</code>，<code>tests</code>和<code>benches</code>文件夹，Cargo 将分别将其视为包含示例、集成测试和基准。类似于<code>bin</code>目标，它们可以由单个文件或拥有<code>main.rs</code>文件的目录组成。</p>
<pre><code>▾ src/           # 包含源文件的目录
  lib.rs         # 库和包的主要入口点
  main.rs        # 包生成可执行文件的主要入口点
  ▾ bin/         # （可选）包含其他可执行文件的目录
    *.rs
  ▾ */           # （可选）包含多文件可执行文件的目录
    main.rs
▾ examples/      # （可选）示例
  *.rs
  ▾ */           # （可选）包含多文件示例的目录
    main.rs
▾ tests/         # （可选）集成测试
  *.rs
  ▾ */           # （可选）包含多文件测试的目录
    main.rs
▾ benches/       # （可选）基准
  *.rs
  ▾ */           # （可选）包含多文件基准的目录
    main.rs
</code></pre>
<p>为了在创建文件和文件夹之后，为包构造代码，应该记住使用 Rust 的模块系统，您可以在这本<a href="https://doc.rust-lang.org/book/crates-and-modules.md">书</a>找到。</p>
<blockquote>
<p>(译)：<a href="https://kaisery.github.io/trpl-zh-cn/ch07-00-packages-crates-and-modules.html">中文</a></p>
</blockquote>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<blockquote>
<p>示例</p>
</blockquote>
<p>位于<code>examples</code>下方的文件，是库提供的功能示例用法。编译时，它们被放置在<code>target/examples</code>目录。</p>
<p>它们可以编译为可执行文件(用<code>main()</code>函数)或，库。和可通过使用<code>extern crate &lt;library-name&gt;</code>导入库。 当您运行测试以保护它们免遭篡改时，它们会被编译。</p>
<p>可以使用命令<code>cargo run --example &lt;example-name&gt;</code>运行单个可执行示例.</p>
<p>指定<code>crate-type</code>将示例编译为库(有关箱类型的附加信息可在<a href="https://doc.rust-lang.org/reference/linkage.html">Rust 参考</a>找到):</p>
<pre><code class="language-toml">[[example]]
name = &quot;foo&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>可以使用命令<code>cargo build --example &lt;example-name&gt;</code>构建单个库实例.</p>
<h3><a class="header" href="#tests" id="tests">Tests</a></h3>
<blockquote>
<p>测试</p>
</blockquote>
<p>当你运行<code>cargo test</code>，Cargo 会:</p>
<ul>
<li>编译并运行库的单元测试，这些测试位于<code>lib.rs</code>(当然，任何标记为<code>#[cfg(test)]</code>部分将考虑为同个阶段);</li>
<li>编译并运行嵌入到文档区块内部的库的文档测试;</li>
<li>编译并运行您库的<a href="reference/manifest.html#integration-tests">集成测试</a>和</li>
<li>编译你库的例子.</li>
</ul>
<h4><a class="header" href="#integration-tests" id="integration-tests">Integration tests</a></h4>
<blockquote>
<p>集成测试</p>
</blockquote>
<p>在<code>tests/*.rs</code>的每个文件是一个集成测试。当你运行<code>cargo test</code>，Cargo 将编译每个文件作为一个单独的箱子。箱可以通过使用<code>extern crate &lt;library-name&gt;</code>链接(导入)您的库，就像其他导入项一样。</p>
<p>Cargo 不会自动编译<code>tests</code>子目录内的文件，但是，集成测试可以像往常一样从这些目录导入模块。例如，如果希望多个集成测试共享一些代码，可以将共享代码放入<code>tests/common/mod.rs</code>，然后为每个测试文件添加<code>mod common;</code>。</p>
<h3><a class="header" href="#configuring-a-target" id="configuring-a-target">Configuring a target</a></h3>
<blockquote>
<p>配置为一个目标</p>
</blockquote>
<p>所有的<code>[[bin]]</code>，<code>[lib]</code>，<code>[[bench]]</code>，<code>[[test]]</code>和<code>[[example]]</code>部分都支持类似的配置，用于指定应该如何构建目标。双括号<code>[[bin]]</code>部分，是<a href="https://github.com/toml-lang/toml#array-of-tables">TOML</a>格式的数组。这意味着你可以在您的箱中写多个<code>[[bin]]</code>，这样就会生成几个可执行文件。</p>
<p>下面的例子使用<code>[lib]</code>，但它也适用于所有其他部分。除非另有说明，下面所有列出的值都是对应选项的<strong>默认值</strong>。</p>
<pre><code class="language-toml">[package]
# ...

[lib]
# 生成目标与库的名称. 本该默认是
# 包名, 替换所有破折号
# 为 下划线. (Rust `extern crate` 声明会参考该名;
# 因此，该值必须是可用的有效Rust标识符.)
name = &quot;foo&quot;

# 该字段，指向 crate 的入口(位置), 路径相对于 `Cargo.toml`.
path = &quot;src/lib.rs&quot;

# 一个给目标启用单元测试 的 标志. 会被 `cargo test`使用.
test = true

# 一个给目标启用文档测试 的 标志. 只与库相关
# , 不会影响其他部分。会被
# `cargo test`使用.
doctest = true

# 一个给目标启用基准 的 标志. 会被 `cargo bench`使用.
bench = true

# 一个给目标启用文档 的 标志. 会被 `cargo doc`使用.
doc = true

# 若该目标为 编译器扩展, 那要把该字段设为 true
# ，以让 Cargo 正确编译和，可用于所有依赖项.
plugin = false

# 若该目标为 &quot;macros 1.1&quot; 程序宏, 那要把该字段设为 true
proc-macro = false

# 若设为 false, `cargo test` 会为 rustc 省略 `--test` 标志, 这
# 阻止它生成测试工具 这在二进制存在，
# 构建管理测试运行器本身的情况下，有用.
harness = true

# 若设置了，那 目标会使用一个与`[package]`配置不同的版本
# , 也许是，编译一个库
2018年版本或，编译单元测试的2015年版本. 默认情况下
# 所有目标都使用`[package]`中指定的版本进行编译。
edition = '2015'
</code></pre>
<p>这个<code>[package]</code>还包括可选的<code>autobins</code>,<code>autoexamples</code>,<code>autotests</code>和<code>autobenches</code>，来明确 进入/退出 自动发现特定的目标种类。</p>
<h4><a class="header" href="#the-required-features-field-optional" id="the-required-features-field-optional">The <code>required-features</code> field (optional)</a></h4>
<blockquote>
<p><code>required-features</code> 字段 (可选)</p>
</blockquote>
<p>这个<code>required-features</code>字段指定目标需要构建的特性。如果未选择任何所需的特性，则将跳过目标。这只与<code>[[bin]]</code>，<code>[[bench]]</code>，<code>[[test]]</code>和<code>[[example]]</code>部分有影响，它没有影响<code>[lib]</code>。</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
# ...
required-features = [&quot;postgres&quot;, &quot;tools&quot;]
</code></pre>
<h4><a class="header" href="#building-dynamic-or-static-libraries" id="building-dynamic-or-static-libraries">Building dynamic or static libraries</a></h4>
<blockquote>
<p>构建 动态 或 静态 库</p>
</blockquote>
<p>如果您的包生成一个库，则可以通过在<code>Cargo.toml</code>显式地指明构建的库类型:</p>
<pre><code class="language-toml"># ...

[lib]
name = &quot;...&quot;
crate-type = [&quot;dylib&quot;] # 也能是 `staticlib`
</code></pre>
<p>可用的选项是<code>dylib</code>，<code>rlib</code>，<code>staticlib</code>，<code>cdylib</code>和<code>proc-macro</code>。 您应该只在包中使用一次此选项。Cargo 总是根据(包括的)包的要求来编译包(依赖项)。</p>
<p>您可以阅读<a href="https://doc.rust-lang.org/reference/linkage.html">Rust 参考手册</a>中更多关于不同的箱类型</p>
<h3><a class="header" href="#the-patch-section-1" id="the-patch-section-1">The <code>[patch]</code> Section</a></h3>
<blockquote>
<p><code>[patch]</code> 部分</p>
</blockquote>
<p>这部分可以用来<a href="reference/./specifying-dependencies.html#overriding-dependencies">重写其他副本的依赖项</a>。语法类似于<code>[dependencies]</code>部分:</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }
</code></pre>
<p>这个<code>[patch]</code>表格由，类似依赖表格的子表组成。<code>[patch]</code>后的每个字段是正在修补的源 URL，或者<code>crates-io</code>(如果你正在修改<a href="https://crates.io">HTTPS://CRATESIO</a>注册表)。在上面的例子中，<code>crates-io</code>可以用 Git URL 替换，例如<code>https://github.com/rust-lang-nursery/log</code>；第二个示例中的<code>[patch]</code>部分使用此来指定一个名为<code>baz</code>的源。</p>
<p>这些表格中的每个项都是一个正常的依赖关系规范，与<code>[dependencies]</code>清单的部分一样。<code>[patch]</code>部分中列出的依赖项，被解析并用于在指定的 URL 上对源进行补丁。上面的清单片段补丁<code>crates-io</code>源(例如 crates.io 本身)的<code>foo</code>箱和<code>bar</code>箱。它也用一个来自其他地方的<code>my-branch</code>分支修补了<code>https://github.com/example/baz</code>源。</p>
<p>可以用不存在的箱版本来修补源，也可以用已经存在的箱版本来修补源。如果用源中已经存在的箱版本对源进行修补，则会替换源的原始箱。</p>
<p>有关重写依赖关系的更多信息，可阅读本文档的<a href="reference/./specifying-dependencies.html#overriding-dependencies">重写依赖项</a>章节和对于这一特性的<a href="https://github.com/rust-lang/rfcs/pull/1969">RFC 1969</a>技术规范说明。</p>
<h3><a class="header" href="#the-replace-section-1" id="the-replace-section-1">The <code>[replace]</code> Section</a></h3>
<blockquote>
<p><code>[replace]</code> 部分</p>
</blockquote>
<p>这部分可以用来<a href="reference/./specifying-dependencies.html#overriding-dependencies">重写其他副本的依赖项</a>。语法类似于<code>[dependencies]</code>部分:</p>
<pre><code class="language-toml">[replace]
&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo' }
&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }
</code></pre>
<p><code>[replace]</code>表格的每个字段都是<a href="reference/./pkgid-spec.html">包标识规范</a>，它任意选择依赖图中的节点来重写。每个字段值与`[dependencies]指定依赖关系的语法是一样，除了不能指定特性。注意，当覆盖一个箱时，覆盖它的副本必须具有相同的名称和版本，但它可以来自不同的源(例如，git 或本地路径).</p>
<p>有关重写依赖关系的更多信息，可阅读本文档的<a href="reference/./specifying-dependencies.html#overriding-dependencies">重写依赖项</a>章节。</p>
<h2><a class="header" href="#cargo-targets" id="cargo-targets">Cargo Targets</a></h2>
<p>Cargo packages consist of <em>targets</em> which correspond to source files which can
be compiled into a crate. Packages can have <a href="reference/cargo-targets.html#library">library</a>,
<a href="reference/cargo-targets.html#binaries">binary</a>, <a href="reference/cargo-targets.html#examples">example</a>, <a href="reference/cargo-targets.html#tests">test</a>, and
<a href="reference/cargo-targets.html#benchmarks">benchmark</a> targets. The list of targets can be configured in the
<code>Cargo.toml</code> manifest, often <a href="reference/cargo-targets.html#target-auto-discovery">inferred automatically</a>
by the <a href="reference/../guide/project-layout.html">directory layout</a> of the source files.</p>
<p>See <a href="reference/cargo-targets.html#configuring-a-target">Configuring a target</a> below for details on
configuring the settings for a target.</p>
<h3><a class="header" href="#library" id="library">Library</a></h3>
<p>The library target defines a &quot;library&quot; that can be used and linked by other
libraries and executables. The filename defaults to <code>src/lib.rs</code>, and the name
of the library defaults to the name of the package. A package can have only
one library. The settings for the library can be <a href="reference/cargo-targets.html#configuring-a-target">customized</a> in the <code>[lib]</code>
table in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml"># Example of customizing the library in Cargo.toml.
[lib]
crate-type = [&quot;cdylib&quot;]
bench = false
</code></pre>
<h3><a class="header" href="#binaries" id="binaries">Binaries</a></h3>
<p>Binary targets are executable programs that can be run after being compiled.
The default binary filename is <code>src/main.rs</code>, which defaults to the name of
the package. Additional binaries are stored in the <a href="reference/../guide/project-layout.html"><code>src/bin/</code>
directory</a>. The settings for each binary can be <a href="reference/cargo-targets.html#configuring-a-target">customized</a>
in the <code>[[bin]]</code> tables in <code>Cargo.toml</code>.</p>
<p>Binaries can use the public API of the package's library. They are also linked
with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>You can run individual binaries with the <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> command with the <code>--bin &lt;bin-name&gt;</code> option. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> can be used to copy the executable to a
common location.</p>
<pre><code class="language-toml"># Example of customizing binaries in Cargo.toml.
[[bin]]
name = &quot;cool-tool&quot;
test = false
bench = false

[[bin]]
name = &quot;frobnicator&quot;
required-features = [&quot;frobnicate&quot;]
</code></pre>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<p>Files located under the <a href="reference/../guide/project-layout.html"><code>examples</code> directory</a> are example
uses of the functionality provided by the library. When compiled, they are
placed in the <a href="reference/../guide/build-cache.html"><code>target/debug/examples</code> directory</a>.</p>
<p>Examples can use the public API of the package's library. They are also linked
with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> and
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>By default, examples are executable binaries (with a <code>main()</code> function). You
can specify the <a href="reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> field</a> to make an example
be compiled as a library:</p>
<pre><code class="language-toml">[[example]]
name = &quot;foo&quot;
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>You can run individual executable examples with the <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> command with
the <code>--example &lt;example-name&gt;</code> option. Library examples can be built with
<a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> with the <code>--example &lt;example-name&gt;</code> option. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>
with the <code>--example &lt;example-name&gt;</code> option can be used to copy executable
binaries to a common location. Examples are compiled by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> by
default to protect them from bit-rotting. Set <a href="reference/cargo-targets.html#the-test-field">the <code>test</code>
field</a> to <code>true</code> if you have <code>#[test]</code> functions in the
example that you want to run with <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>.</p>
<h3><a class="header" href="#tests-1" id="tests-1">Tests</a></h3>
<p>There are two styles of tests within a Cargo project:</p>
<ul>
<li><em>Unit tests</em> which are functions marked with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a> located within your library or binaries (or any
target enabled with <a href="reference/cargo-targets.html#the-test-field">the <code>test</code> field</a>). These tests have
access to private APIs located within the target they are defined in.</li>
<li><em>Integration tests</em> which is a separate executable binary, also containing
<code>#[test]</code> functions, which is linked with the project's library and has
access to its <em>public</em> API.</li>
</ul>
<p>Tests are run with the <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> command. By default, Cargo and <code>rustc</code>
use the libtest harness which is responsible for collecting functions
annotated with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> attribute</a> and executing them in
parallel, reporting the success and failure of each test. See <a href="reference/cargo-targets.html#the-harness-field">the <code>harness</code>
field</a> if you want to use a different harness or test
strategy.</p>
<h4><a class="header" href="#integration-tests-1" id="integration-tests-1">Integration tests</a></h4>
<p>Files located under the <a href="reference/../guide/project-layout.html"><code>tests</code> directory</a> are integration
tests. When you run <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>, Cargo will compile each of these files as
a separate crate, and execute them.</p>
<p>Integration tests can use the public API of the package's library. They are
also linked with the <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> and
<a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> defined in <code>Cargo.toml</code>.</p>
<p>If you want to share code among multiple integration tests, you can place it
in a separate module such as <code>tests/common/mod.rs</code> and then put <code>mod common;</code>
in each test to import it.</p>
<p>Each integration test results in a separate executable binary, and <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> will run them serially. In some cases this can be inefficient, as it
can take longer to compile, and may not make full use of multiple CPUs when
running the tests. If you have a lot of integration tests, you may want to
consider creating a single integration test, and split the tests into multiple
modules. The libtest harness will automatically find all of the <code>#[test]</code>
annotated functions and run them in parallel. You can pass module names to
<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> to only run the tests within that module.</p>
<p>Binary targets are automatically built if there is an integration test. This
allows an integration test to execute the binary to exercise and test its
behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the
integration test is built so that it can use the <a href="reference/../../std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<h3><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h3>
<p>Benchmarks provide a way to test the performance of your code using the
<a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> command. They follow the same structure as <a href="reference/cargo-targets.html#tests">tests</a>,
with each benchmark function annotated with the <code>#[bench]</code> attribute.
Similarly to tests:</p>
<ul>
<li>Benchmarks are placed in the <a href="reference/../guide/project-layout.html"><code>benches</code> directory</a>.</li>
<li>Benchmark functions defined in libraries and binaries have access to the
<em>private</em> API within the target they are defined in. Benchmarks in the
<code>benches</code> directory may use the <em>public</em> API.</li>
<li><a href="reference/cargo-targets.html#the-bench-field">The <code>bench</code> field</a> can be used to define which targets
are benchmarked by default.</li>
<li><a href="reference/cargo-targets.html#the-harness-field">The <code>harness</code> field</a> can be used to disable the
built-in harness.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The <a href="reference/../../unstable-book/library-features/test.html"><code>#[bench]</code>
attribute</a> is currently
unstable and only available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. There are some
packages available on <a href="https://crates.io/keywords/benchmark">crates.io</a> that
may help with running benchmarks on the stable channel, such as
<a href="https://crates.io/crates/criterion">Criterion</a>.</p>
</blockquote>
<h3><a class="header" href="#configuring-a-target-1" id="configuring-a-target-1">Configuring a target</a></h3>
<p>All of the  <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, and <code>[[bench]]</code>
sections in <code>Cargo.toml</code> support similar configuration for specifying how a
target should be built. The double-bracket sections like <code>[[bin]]</code> are
<a href="https://toml.io/en/v1.0.0-rc.3#array-of-tables">array-of-table of TOML</a>,
which means you can write more than one <code>[[bin]]</code> section to make several
executables in your crate. You can only specify one library, so <code>[lib]</code> is a
normal TOML table.</p>
<p>The following is an overview of the TOML settings for each target, with each
field described in detail below.</p>
<pre><code class="language-toml">[lib]
name = &quot;foo&quot;           # The name of the target.
path = &quot;src/lib.rs&quot;    # The source file of the target.
test = true            # Is tested by default.
doctest = true         # Documentation examples are tested by default.
bench = true           # Is benchmarked by default.
doc = true             # Is documented by default.
plugin = false         # Used as a compiler plugin (deprecated).
proc-macro = false     # Set to `true` for a proc-macro library.
harness = true         # Use libtest harness.
edition = &quot;2015&quot;       # The edition of the target.
crate-type = [&quot;lib&quot;]   # The crate types to generate.
required-features = [] # Features required to build this target (N/A for lib).
</code></pre>
<h4><a class="header" href="#the-name-field" id="the-name-field">The <code>name</code> field</a></h4>
<p>The <code>name</code> field specifies the name of the target, which corresponds to the
filename of the artifact that will be generated. For a library, this is the
crate name that dependencies will use to reference it.</p>
<p>For the <code>[lib]</code> and the default binary (<code>src/main.rs</code>), this defaults to the
name of the package, with any dashes replaced with underscores. For other
<a href="reference/cargo-targets.html#target-auto-discovery">auto discovered</a> targets, it defaults to the
directory or file name.</p>
<p>This is required for all targets except <code>[lib]</code>.</p>
<h4><a class="header" href="#the-path-field" id="the-path-field">The <code>path</code> field</a></h4>
<p>The <code>path</code> field specifies where the source for the crate is located, relative
to the <code>Cargo.toml</code> file.</p>
<p>If not specified, the <a href="reference/cargo-targets.html#target-auto-discovery">inferred path</a> is used based on
the target name.</p>
<h4><a class="header" href="#the-test-field" id="the-test-field">The <code>test</code> field</a></h4>
<p>The <code>test</code> field indicates whether or not the target is tested by default by
<a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>. The default is <code>true</code> for lib, bins, and tests.</p>
<blockquote>
<p><strong>Note</strong>: Examples are built by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> by default to ensure they
continue to compile, but they are not <em>tested</em> by default. Setting <code>test = true</code> for an example will also build it as a test and run any
<a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> functions defined in the example.</p>
</blockquote>
<h4><a class="header" href="#the-doctest-field" id="the-doctest-field">The <code>doctest</code> field</a></h4>
<p>The <code>doctest</code> field indicates whether or not <a href="reference/../../rustdoc/documentation-tests.html">documentation examples</a> are
tested by default by <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>. This is only relevant for libraries, it
has no effect on other sections. The default is <code>true</code> for the library.</p>
<h4><a class="header" href="#the-bench-field" id="the-bench-field">The <code>bench</code> field</a></h4>
<p>The <code>bench</code> field indicates whether or not the target is benchmarked by
default by <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a>. The default is <code>true</code> for lib, bins, and
benchmarks.</p>
<h4><a class="header" href="#the-doc-field" id="the-doc-field">The <code>doc</code> field</a></h4>
<p>The <code>doc</code> field indicates whether or not the target is included in the
documentation generated by <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> by default. The default is <code>true</code> for
libraries and binaries.</p>
<blockquote>
<p><strong>Note</strong>: The binary will be skipped if its name is the same as the lib
target.</p>
</blockquote>
<h4><a class="header" href="#the-plugin-field" id="the-plugin-field">The <code>plugin</code> field</a></h4>
<p>This field is used for <code>rustc</code> plugins, which are being deprecated.</p>
<h4><a class="header" href="#the-proc-macro-field" id="the-proc-macro-field">The <code>proc-macro</code> field</a></h4>
<p>The <code>proc-macro</code> field indicates that the library is a <a href="reference/../../book/ch19-06-macros.html">procedural macro</a>
(<a href="reference/../../reference/procedural-macros.html">reference</a>). This is only valid for the <code>[lib]</code>
target.</p>
<h4><a class="header" href="#the-harness-field" id="the-harness-field">The <code>harness</code> field</a></h4>
<p>The <code>harness</code> field indicates that the <a href="reference/../../rustc/command-line-arguments.html#option-test"><code>--test</code> flag</a> will be passed to
<code>rustc</code> which will automatically include the libtest library which is the
driver for collecting and running tests marked with the <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a> or benchmarks with the <code>#[bench]</code> attribute. The
default is <code>true</code> for all targets.</p>
<p>If set to <code>false</code>, then you are responsible for defining a <code>main()</code> function
to run tests and benchmarks.</p>
<p>Tests have the <a href="reference/../../reference/conditional-compilation.html#test"><code>cfg(test)</code> conditional expression</a> enabled whether
or not the harness is enabled.</p>
<h4><a class="header" href="#the-edition-field" id="the-edition-field">The <code>edition</code> field</a></h4>
<p>The <code>edition</code> field defines the <a href="reference/../../edition-guide/index.html">Rust edition</a> the target will use. If not
specified, it defaults to the <a href="reference/manifest.html#the-edition-field"><code>edition</code> field</a> for the
<code>[package]</code>. This field should usually not be set, and is only intended for
advanced scenarios such as incrementally transitioning a large package to a
new edition.</p>
<h4><a class="header" href="#the-crate-type-field" id="the-crate-type-field">The <code>crate-type</code> field</a></h4>
<p>The <code>crate-type</code> field defines the <a href="reference/../../reference/linkage.html">crate types</a> that will be generated by the
target. It is an array of strings, allowing you to specify multiple crate
types for a single target. This can only be specified for libraries and
examples. Binaries, tests, and benchmarks are always the &quot;bin&quot; crate type. The
defaults are:</p>
<table><thead><tr><th>Target</th><th>Crate Type</th></tr></thead><tbody>
<tr><td>Normal library</td><td><code>&quot;lib&quot;</code></td></tr>
<tr><td>Proc-macro library</td><td><code>&quot;proc-macro&quot;</code></td></tr>
<tr><td>Example</td><td><code>&quot;bin&quot;</code></td></tr>
</tbody></table>
<p>The available options are <code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>cdylib</code>,
<code>staticlib</code>, and <code>proc-macro</code>. You can read more about the different crate
types in the <a href="reference/../../reference/linkage.html">Rust Reference Manual</a>.</p>
<h4><a class="header" href="#the-required-features-field" id="the-required-features-field">The <code>required-features</code> field</a></h4>
<p>The <code>required-features</code> field specifies which <a href="reference/features.html">features</a> the target needs in
order to be built. If any of the required features are not enabled, the
target will be skipped. This is only relevant for the <code>[[bin]]</code>, <code>[[bench]]</code>,
<code>[[test]]</code>, and <code>[[example]]</code> sections, it has no effect on <code>[lib]</code>.</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = &quot;my-pg-tool&quot;
required-features = [&quot;postgres&quot;, &quot;tools&quot;]
</code></pre>
<h3><a class="header" href="#target-auto-discovery" id="target-auto-discovery">Target auto-discovery</a></h3>
<p>By default, Cargo automatically determines the targets to build based on the
<a href="reference/../guide/project-layout.html">layout of the files</a> on the filesystem. The target
configuration tables, such as <code>[lib]</code>, <code>[[bin]]</code>, <code>[[test]]</code>, <code>[[bench]]</code>, or
<code>[[example]]</code>, can be used to add additional targets that don't follow the
standard directory layout.</p>
<p>The automatic target discovery can be disabled so that only manually
configured targets will be built. Setting the keys <code>autobins</code>, <code>autoexamples</code>,
<code>autotests</code>, or <code>autobenches</code> to <code>false</code> in the <code>[package]</code> section will
disable auto-discovery of the corresponding target type.</p>
<pre><code class="language-toml">[package]
# ...
autobins = false
autoexamples = false
autotests = false
autobenches = false
</code></pre>
<p>Disabling automatic discovery should only be needed for specialized
situations. For example, if you have a library where you want a <em>module</em> named
<code>bin</code>, this would present a problem because Cargo would usually attempt to
compile anything in the <code>bin</code> directory as an executable. Here is a sample
layout of this scenario:</p>
<pre><code class="language-text">├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
</code></pre>
<p>To prevent Cargo from inferring <code>src/bin/mod.rs</code> as an executable, set
<code>autobins = false</code> in <code>Cargo.toml</code> to disable auto-discovery:</p>
<pre><code class="language-toml">[package]
# …
autobins = false
</code></pre>
<blockquote>
<p><strong>Note</strong>: For packages with the 2015 edition, the default for auto-discovery
is <code>false</code> if at least one target is manually defined in <code>Cargo.toml</code>.
Beginning with the 2018 edition, the default is always <code>true</code>.</p>
</blockquote>
<h2><a class="header" href="#workspaces" id="workspaces">Workspaces</a></h2>
<p>A <em>workspace</em> is a collection of one or more packages that share common
dependency resolution (with a shared <code>Cargo.lock</code>), output directory, and
various settings such as profiles. Packages that are part of a workspaces are
called <em>workspace members</em>. There are two flavours of workspaces: as root
package or as virtual manifest.</p>
<h3><a class="header" href="#root-package" id="root-package">Root package</a></h3>
<p>A workspace can be created by adding a <a href="reference/workspaces.html#the-workspace-section"><code>[workspace]</code>
section</a> to <code>Cargo.toml</code>. This can be added to a
<code>Cargo.toml</code> that already defines a <code>[package]</code>, in which case the package is
the <em>root package</em> of the workspace. The <em>workspace root</em> is the directory
where the workspace's <code>Cargo.toml</code> is located.</p>
<h3><a class="header" href="#virtual-manifest-1" id="virtual-manifest-1">Virtual manifest</a></h3>
<p>Alternatively, a <code>Cargo.toml</code> file can be created with a <code>[workspace]</code> section
but without a <a href="reference/manifest.html#the-package-section"><code>[package]</code> section</a>. This is called a <em>virtual
manifest</em>. This is typically useful when there isn't a &quot;primary&quot; package, or
you want to keep all the packages organized in separate directories.</p>
<h3><a class="header" href="#key-features" id="key-features">Key features</a></h3>
<p>The key points of workspaces are:</p>
<ul>
<li>All packages share a common <code>Cargo.lock</code> file which resides in the
<em>workspace root</em>.</li>
<li>All packages share a common <a href="reference/../guide/build-cache.html">output directory</a>, which defaults to a
directory named <code>target</code> in the <em>workspace root</em>.</li>
<li>The <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>, <a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> and <a href="reference/profiles.html"><code>[profile.*]</code></a>
sections in <code>Cargo.toml</code> are only recognized in the <em>root</em> manifest, and
ignored in member crates' manifests.</li>
</ul>
<h3><a class="header" href="#the-workspace-section-1" id="the-workspace-section-1">The <code>[workspace]</code> section</a></h3>
<p>The <code>[workspace]</code> table in <code>Cargo.toml</code> defines which packages are members of
the workspace:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;path/to/member2&quot;, &quot;crates/*&quot;]
exclude = [&quot;crates/foo&quot;, &quot;path/to/other&quot;]
</code></pre>
<p>All <a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>path</code> dependencies</a> residing in the workspace directory automatically
become members. Additional members can be listed with the <code>members</code> key, which
should be an array of strings containing directories with <code>Cargo.toml</code> files.</p>
<p>The <code>members</code> list also supports <a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html">globs</a> to match multiple paths, using
typical filename glob patterns like <code>*</code> and <code>?</code>.</p>
<p>The <code>exclude</code> key can be used to prevent paths from being included in a
workspace. This can be useful if some path dependencies aren't desired to be
in the workspace at all, or using a glob pattern and you want to remove a
directory.</p>
<p>An empty <code>[workspace]</code> table can be used with a <code>[package]</code> to conveniently
create a workspace with the package and all of its path dependencies.</p>
<h3><a class="header" href="#workspace-selection" id="workspace-selection">Workspace selection</a></h3>
<p>When inside a subdirectory within the workspace, Cargo will automatically
search the parent directories for a <code>Cargo.toml</code> file with a <code>[workspace]</code>
definition to determine which workspace to use. The <a href="reference/manifest.html#the-workspace-field"><code>package.workspace</code></a>
manifest key can be used in member crates to point at a workspace's root to
override this automatic search. The manual setting can be useful if the member
is not inside a subdirectory of the workspace root.</p>
<h3><a class="header" href="#package-selection-1" id="package-selection-1">Package selection</a></h3>
<p>In a workspace, package-related cargo commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> can use
the <code>-p</code> / <code>--package</code> or <code>--workspace</code> command-line flags to determine which
packages to operate on. If neither of those flags are specified, Cargo will
use the package in the current working directory. If the current directory is
a virtual workspace, it will apply to all members (as if <code>--workspace</code> were
specified on the command-line).</p>
<p>The optional <code>default-members</code> key can be specified to set the members to
operate on when in the workspace root and the package selection flags are not
used:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]
default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]
</code></pre>
<p>When specified, <code>default-members</code> must expand to a subset of <code>members</code>.</p>
<h3><a class="header" href="#the-workspacemetadata-table" id="the-workspacemetadata-table">The <code>workspace.metadata</code> table</a></h3>
<p>The <code>workspace.metadata</code> table is ignored by Cargo and will not be warned
about. This section can be used for tools that would like to store workspace
configuration in <code>Cargo.toml</code>. For example:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]

[workspace.metadata.webcontents]
root = &quot;path/to/webproject&quot;
tool = [&quot;npm&quot;, &quot;run&quot;, &quot;build&quot;]
# ...
</code></pre>
<p>There is a similar set of tables at the package level at
<a href="reference/manifest.html#the-metadata-table"><code>package.metadata</code></a>. While cargo does not specify a
format for the content of either of these tables, it is suggested that
external tools may wish to use them in a consistent fashion, such as referring
to the data in <code>workspace.metadata</code> if data is missing from <code>package.metadata</code>,
if that makes sense for the tool in question.</p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<p>Cargo &quot;features&quot; provide a mechanism to express <a href="reference/../../reference/conditional-compilation.html">conditional compilation</a> and
<a href="reference/features.html#optional-dependencies">optional dependencies</a>. A package defines a set of
named features in the <code>[features]</code> table of <code>Cargo.toml</code>, and each feature can
either be enabled or disabled. Features for the package being built can be
enabled on the command-line with flags such as <code>--features</code>. Features for
dependencies can be enabled in the dependency declaration in <code>Cargo.toml</code>.</p>
<p>See also the <a href="reference/features-examples.html">Features Examples</a> chapter for some examples of how features can
be used.</p>
<h3><a class="header" href="#the-features-section-1" id="the-features-section-1">The <code>[features]</code> section</a></h3>
<p>Features are defined in the <code>[features]</code> table in <code>Cargo.toml</code>. Each feature
specifies an array of other features or optional dependencies that it enables.
The following examples illustrate how features could be used for a 2D image
processing library where support for different image formats can be optionally
included:</p>
<pre><code class="language-toml">[features]
# Defines a feature named `webp` that does not enable any other features.
webp = []
</code></pre>
<p>With this feature defined, <a href="reference/../../reference/conditional-compilation.html"><code>cfg</code> expressions</a> can be used to conditionally
include code to support the requested feature at compile time. For example,
inside <code>lib.rs</code> of the package could include this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This conditionally includes a module which implements WEBP support.
#[cfg(feature = &quot;webp&quot;)]
pub mod webp;
<span class="boring">}
</span></code></pre></pre>
<p>Cargo sets features in the package using the <code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> flag</a>, and code
can test for their presence with the <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> or the <a href="reference/../../std/macro.cfg.html"><code>cfg</code> macro</a>.</p>
<p>Features can list other features to enable. For example, the ICO image format
can contain BMP and PNG images, so when it is enabled, it should make sure
those other features are enabled, too:</p>
<pre><code class="language-toml">[features]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>Feature names may include characters from the <a href="https://unicode.org/reports/tr31/">Unicode XID standard</a> (which
includes most letters), and additionally allows starting with <code>_</code> or digits
<code>0</code> through <code>9</code>, and after the first character may also contain <code>-</code>, <code>+</code>, or
<code>.</code>.</p>
<blockquote>
<p><strong>Note</strong>: <a href="https://crates.io/">crates.io</a> imposes additional constraints on feature name syntax
that they must only be <a href="reference/../../std/primitive.char.html#method.is_ascii_alphanumeric">ASCII alphanumeric</a> characters or <code>_</code>, <code>-</code>, or <code>+</code>.</p>
</blockquote>
<h3><a class="header" href="#the-default-feature" id="the-default-feature">The <code>default</code> feature</a></h3>
<p>By default, all features are disabled unless explicitly enabled. This can be
changed by specifying the <code>default</code> feature:</p>
<pre><code class="language-toml">[features]
default = [&quot;ico&quot;, &quot;webp&quot;]
bmp = []
png = []
ico = [&quot;bmp&quot;, &quot;png&quot;]
webp = []
</code></pre>
<p>When the package is built, the <code>default</code> feature is enabled which in turn
enables the listed features. This behavior can be changed by:</p>
<ul>
<li>The <code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">command-line
flag</a> disables the default features of the
package.</li>
<li>The <code>default-features = false</code> option can be specified in a <a href="reference/features.html#dependency-features">dependency
declaration</a>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Be careful about choosing the default feature set. The default
features are a convenience that make it easier to use a package without
forcing the user to carefully select which features to enable for common
use, but there are some drawbacks. Dependencies automatically enable default
features unless <code>default-features = false</code> is specified. This can make it
difficult to ensure that the default features are not enabled, especially
for a dependency that appears multiple times in the dependency graph. Every
package must ensure that <code>default-features = false</code> is specified to avoid
enabling them.</p>
<p>Another issue is that it can be a <a href="reference/features.html#semver-compatibility">SemVer incompatible
change</a> to remove a feature from the default set, so
you should be confident that you will keep those features.</p>
</blockquote>
<h3><a class="header" href="#optional-dependencies" id="optional-dependencies">Optional dependencies</a></h3>
<p>Dependencies can be marked &quot;optional&quot;, which means they will not be compiled
by default. For example, let's say that our 2D image processing library uses
an external package to handle GIF images. This can be expressed like this:</p>
<pre><code class="language-toml">[dependencies]
gif = { version = &quot;0.11.1&quot;, optional = true }
</code></pre>
<p>Optional dependencies implicitly define a feature of the same name as the
dependency. This means that the same <code>cfg(feature = &quot;gif&quot;)</code> syntax can be used
in the code, and the dependency can be enabled just like a feature such as
<code>--features gif</code> (see <a href="reference/features.html#command-line-feature-options">Command-line feature
options</a> below).</p>
<blockquote>
<p><strong>Note</strong>: A feature in the <code>[feature]</code> table cannot use the same name as a
dependency. Experimental support for enabling this and other extensions is
available on the nightly channel via <a href="reference/unstable.html#namespaced-features">namespaced
features</a>.</p>
</blockquote>
<p>Explicitly defined features can enable optional dependencies, too. Just
include the name of the optional dependency in the feature list. For example,
let's say in order to support the AVIF image format, our library needs two
other dependencies to be enabled:</p>
<pre><code class="language-toml">[dependencies]
ravif = { version = &quot;0.6.3&quot;, optional = true }
rgb = { version = &quot;0.8.25&quot;, optional = true }

[features]
avif = [&quot;ravif&quot;, &quot;rgb&quot;]
</code></pre>
<p>In this example, the <code>avif</code> feature will enable the two listed dependencies.</p>
<blockquote>
<p><strong>Note</strong>: Another way to optionally include a dependency is to use
<a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a>. Instead of using features, these are
conditional based on the target platform.</p>
</blockquote>
<h3><a class="header" href="#dependency-features" id="dependency-features">Dependency features</a></h3>
<p>Features of dependencies can be enabled within the dependency declaration. The
<code>features</code> key indicates which features to enable:</p>
<pre><code class="language-toml">[dependencies]
# Enables the `derive` feature of serde.
serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }
</code></pre>
<p>The <a href="reference/features.html#the-default-feature"><code>default</code> features</a> can be disabled using
<code>default-features = false</code>:</p>
<pre><code class="language-toml">[dependencies]
flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] }
</code></pre>
<blockquote>
<p><strong>Note</strong>: This may not ensure the default features are disabled. If another
dependency includes <code>flate2</code> without specifying <code>default-features = false</code>,
then the default features will be enabled. See <a href="reference/features.html#feature-unification">feature
unification</a> below for more details.</p>
</blockquote>
<p>Features of dependencies can also be enabled in the <code>[features]</code> table. The
syntax is <code>&quot;package-name/feature-name&quot;</code>. For example:</p>
<pre><code class="language-toml">[dependencies]
jpeg-decoder = { version = &quot;0.1.20&quot;, default-features = false }

[features]
# Enables parallel processing support by enabling the &quot;rayon&quot; feature of jpeg-decoder.
parallel = [&quot;jpeg-decoder/rayon&quot;]
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>&quot;package-name/feature-name&quot;</code> syntax will also enable
<code>package-name</code> if it is an optional dependency. Experimental support for
disabling that behavior is available on the nightly channel via <a href="reference/unstable.html#weak-dependency-features">weak
dependency features</a>.</p>
</blockquote>
<h3><a class="header" href="#command-line-feature-options" id="command-line-feature-options">Command-line feature options</a></h3>
<p>The following command-line flags can be used to control which features are
enabled:</p>
<ul>
<li>
<p><code>--features</code> <em>FEATURES</em>: Enables the listed features. Multiple features may
be separated with commas or spaces. If using spaces, be sure to use quotes
around all the features if running Cargo from a shell (such as <code>--features &quot;foo bar&quot;</code>). If building multiple packages in a <a href="reference/workspaces.html">workspace</a>, the
<code>package-name/feature-name</code> syntax can be used to specify features for
specific workspace members.</p>
</li>
<li>
<p><code>--all-features</code>: Activates all features of all packages selected on the
command-line.</p>
</li>
<li>
<p><code>--no-default-features</code>: Does not activate the <a href="reference/features.html#the-default-feature"><code>default</code>
feature</a> of the selected packages.</p>
</li>
</ul>
<h3><a class="header" href="#feature-unification" id="feature-unification">Feature unification</a></h3>
<p>Features are unique to the package that defines them. Enabling a feature on a
package does not enable a feature of the same name on other packages.</p>
<p>When a dependency is used by multiple packages, Cargo will use the union of
all features enabled on that dependency when building it. This helps ensure
that only a single copy of the dependency is used. See the <a href="reference/resolver.html#features">features section</a>
of the resolver documentation for more details.</p>
<p>For example, let's look at the <a href="https://crates.io/crates/winapi"><code>winapi</code></a> package which uses a <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">large
number</a> of features. If your package depends on a package
<code>foo</code> which enables the &quot;fileapi&quot; and &quot;handleapi&quot; features of <code>winapi</code>, and
another dependency <code>bar</code> which enables the &quot;std&quot; and &quot;winnt&quot; features of
<code>winapi</code>, then <code>winapi</code> will be built with all four of those features enabled.</p>
<p><img src="reference/../images/winapi-features.svg" alt="winapi features example" /></p>
<p>A consequence of this is that features should be <em>additive</em>. That is, enabling
a feature should not disable functionality, and it should usually be safe to
enable any combination of features. A feature should not introduce a
<a href="reference/features.html#semver-compatibility">SemVer-incompatible change</a>.</p>
<p>For example, if you want to optionally support <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> environments, <strong>do
not</strong> use a <code>no_std</code> feature. Instead, use a <code>std</code> feature that <em>enables</em>
<code>std</code>. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = &quot;std&quot;)]
extern crate std;

#[cfg(feature = &quot;std&quot;)]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#mutually-exclusive-features" id="mutually-exclusive-features">Mutually exclusive features</a></h4>
<p>There are rare cases where features may be mutually incompatible with one
another. This should be avoided if at all possible, because it requires
coordinating all uses of the package in the dependency graph to cooperate to
avoid enabling them together. If it is not possible, consider adding a compile
error to detect this scenario. For example:</p>
<pre><code class="language-rust ignore">#[cfg(all(feature = &quot;foo&quot;, feature = &quot;bar&quot;))]
compile_error!(&quot;feature \&quot;foo\&quot; and feature \&quot;bar\&quot; cannot be enabled at the same time&quot;);
</code></pre>
<p>Instead of using mutually exclusive features, consider some other options:</p>
<ul>
<li>Split the functionality into separate packages.</li>
<li>When there is a conflict, <a href="reference/features-examples.html#feature-precedence">choose one feature over
another</a>. The <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> package can help with writing
more complex <code>cfg</code> expressions.</li>
<li>Architect the code to allow the features to be enabled concurrently, and use
runtime options to control which is used. For example, use a config file,
command-line argument, or environment variable to choose which behavior to
enable.</li>
</ul>
<h4><a class="header" href="#inspecting-resolved-features" id="inspecting-resolved-features">Inspecting resolved features</a></h4>
<p>In complex dependency graphs, it can sometimes be difficult to understand how
different features get enabled on various packages. The <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> command
offers several options to help inspect and visualize which features are
enabled. Some options to try:</p>
<ul>
<li><code>cargo tree -e features</code>: This will show features in the dependency graph.
Each feature will appear showing which package enabled it.</li>
<li><code>cargo tree -f &quot;{p} {f}&quot;</code>: This is a more compact view that shows a
comma-spearated list of features enabled on each package.</li>
<li><code>cargo tree -e features -i foo</code>: This will invert the tree, showing how
features flow into the given package &quot;foo&quot;. This can be useful because
viewing the entire graph can be quite large and overwhelming. Use this when
you are trying to figure out which features are enabled on a specific
package and why. See the example at the bottom of the <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> page on
how to read this.</li>
</ul>
<h3><a class="header" href="#feature-resolver-version-2" id="feature-resolver-version-2">Feature resolver version 2</a></h3>
<p>A different feature resolver can be specified with the <code>resolver</code> field in
<code>Cargo.toml</code>, like this:</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>See the <a href="reference/resolver.html#resolver-versions">resolver versions</a> section for more detail on specifying resolver
versions.</p>
<p>The version <code>&quot;2&quot;</code> resolver avoids unifying features in a few situations where
that unification can be unwanted. The exact situations are described in the
<a href="reference/resolver.html#feature-resolver-version-2">resolver chapter</a>, but in short, it avoids unifying in these
situations:</p>
<ul>
<li>Features enabled on <a href="reference/specifying-dependencies.html#platform-specific-dependencies">platform-specific dependencies</a> for targets not
currently being built are ignored.</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies">Build-dependencies</a> and proc-macros do not share features with normal
dependencies.</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies">Dev-dependencies</a> do not activate features unless building a target that
needs them (like tests or examples).</li>
</ul>
<p>Avoiding the unification is necessary for some situations. For example, if a
build-dependency enables a <code>std</code> feature, and the same dependency is used as a
normal dependency for a <code>no_std</code> environment, enabling <code>std</code> would break the
build.</p>
<p>However, one drawback is that this can increase build times because the
dependency is built multiple times (each with different features). When using
the version <code>&quot;2&quot;</code> resolver, it is recommended to check for dependencies that
are built multiple times to reduce overall build time. If it is not <em>required</em>
to build those duplicated packages with separate features, consider adding
features to the <code>features</code> list in the <a href="reference/features.html#dependency-features">dependency
declaration</a> so that the duplicates end up with the same
features (and thus Cargo will build it only once). You can detect these
duplicate dependencies with the <a href="reference/../commands/cargo-tree.html"><code>cargo tree --duplicates</code></a>
command. It will show which packages are built multiple times; look for any
entries listed with the same version. See <a href="reference/features.html#inspecting-resolved-features">Inspecting resolved
features</a> for more on fetching information on
the resolved features. For build dependencies, this is not necessary if you
are cross-compiling with the <code>--target</code> flag because build dependencies are
always built separately from normal dependencies in that scenario.</p>
<h4><a class="header" href="#resolver-version-2-command-line-flags" id="resolver-version-2-command-line-flags">Resolver version 2 command-line flags</a></h4>
<p>The <code>resolver = &quot;2&quot;</code> setting also changes the behavior of the <code>--features</code> and
<code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">command-line options</a>.</p>
<p>With version <code>&quot;1&quot;</code>, you can only enable features for the package in the
current working directory. For example, in a workspace with packages <code>foo</code> and
<code>bar</code>, and you are in the directory for package <code>foo</code>, and ran the command
<code>cargo build -p bar --features bar-feat</code>, this would fail because the
<code>--features</code> flag only allowed enabling features on <code>foo</code>.</p>
<p>With <code>resolver = &quot;2&quot;</code>, the features flags allow enabling features for any of
the packages selected on the command-line with <code>-p</code> and <code>--workspace</code> flags.
For example:</p>
<pre><code class="language-sh"># This command is allowed with resolver = &quot;2&quot;, regardless of which directory
# you are in.
cargo build -p foo -p bar --features foo-feat,bar-feat

# This explicit equivalent works with any resolver version:
cargo build -p foo -p bar --features foo/foo-feat,bar/bar-feat
</code></pre>
<p>Additionally, with <code>resolver = &quot;1&quot;</code>, the <code>--no-default-features</code> flag only
disables the default feature for the package in the current directory. With
version &quot;2&quot;, it will disable the default features for all workspace members.</p>
<h3><a class="header" href="#build-scripts" id="build-scripts">Build scripts</a></h3>
<p><a href="reference/build-scripts.html">Build scripts</a> can detect which features are enabled on the package by
inspecting the <code>CARGO_FEATURE_&lt;name&gt;</code> environment variable, where <code>&lt;name&gt;</code> is
the feature name converted to uppercase and <code>-</code> converted to <code>_</code>.</p>
<h3><a class="header" href="#required-features" id="required-features">Required features</a></h3>
<p>The <a href="reference/cargo-targets.html#the-required-features-field"><code>required-features</code> field</a> can be used to disable specific <a href="reference/cargo-targets.html">Cargo
targets</a> if a feature is not enabled. See the linked documentation for more
details.</p>
<h3><a class="header" href="#semver-compatibility" id="semver-compatibility">SemVer compatibility</a></h3>
<p>Enabling a feature should not introduce a SemVer-incompatible change. For
example, the feature shouldn't change an existing API in a way that could
break existing uses. More details about what changes are compatible can be
found in the <a href="reference/semver.html">SemVer Compatibility chapter</a>.</p>
<p>Care should be taken when adding and removing feature definitions and optional
dependencies, as these can sometimes be backwards-incompatible changes. More
details can be found in the <a href="reference/semver.html#cargo">Cargo section</a> of the SemVer
Compatibility chapter. In short, follow these rules:</p>
<ul>
<li>The following is usually safe to do in a minor release:
<ul>
<li>Add a <a href="reference/semver.html#cargo-feature-add">new feature</a> or <a href="reference/semver.html#cargo-dep-add">optional dependency</a>.</li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Change the features used on a dependency</a>.</li>
</ul>
</li>
<li>The following should usually <strong>not</strong> be done in a minor release:
<ul>
<li><a href="reference/semver.html#cargo-feature-remove">Remove a feature</a> or <a href="reference/semver.html#cargo-remove-opt-dep">optional dependency</a>.</li>
<li><a href="reference/semver.html#item-remove">Moving existing public code behind a feature</a>.</li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Remove a feature from a feature list</a>.</li>
</ul>
</li>
</ul>
<p>See the links for caveats and examples.</p>
<h3><a class="header" href="#feature-documentation-and-discovery" id="feature-documentation-and-discovery">Feature documentation and discovery</a></h3>
<p>You are encouraged to document which features are available in your package.
This can be done by adding <a href="reference/../../rustdoc/how-to-write-documentation.html">doc comments</a> at the top of <code>lib.rs</code>. As an
example, see the <a href="https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583">regex crate source</a>, which when rendered can be viewed on
<a href="https://docs.rs/regex/1.4.2/regex/#crate-features">docs.rs</a>. If you have other documentation, such as a user
guide, consider adding the documentation there (for example, see <a href="https://serde.rs/feature-flags.html">serde.rs</a>).
If you have a binary project, consider documenting the features in the README
or other documentation for the project (for example, see <a href="https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements">sccache</a>).</p>
<p>Clearly documenting the features can set expectations about features
considered &quot;unstable&quot; or otherwise shouldn't be used. For example, if there is
an optional dependency, but you don't want users to explicitly list that
optional dependency as a feature, exclude it from the documented list.</p>
<p>Documentation published on <a href="https://docs.rs/">docs.rs</a> can use metadata in <code>Cargo.toml</code> to
control which features are enabled when the documentation is built. See
<a href="https://docs.rs/about/metadata">docs.rs metadata documentation</a> for more details.</p>
<blockquote>
<p><strong>Note</strong>: Rustdoc has experimental support for annotating the documentation
to indicate which features are required to use certain APIs. See the
<a href="reference/../../unstable-book/language-features/doc-cfg.html"><code>doc_cfg</code></a> documentation for more details. An example is the <a href="https://docs.rs/syn/1.0.54/syn/#modules"><code>syn</code>
documentation</a>, where you can see colored boxes which note which features
are required to use it.</p>
</blockquote>
<h4><a class="header" href="#discovering-features" id="discovering-features">Discovering features</a></h4>
<p>When features are documented in the library API, this can make it easier for
your users to discover which features are available and what they do. If the
feature documentation for a package isn't readily available, you can look at
the <code>Cargo.toml</code> file, but sometimes it can be hard to track it down. The
crate page on <a href="https://crates.io/">crates.io</a> has a link to the source repository if available.
Tools like <a href="reference/../commands/cargo-vendor.html"><code>cargo vendor</code></a> or <a href="https://crates.io/crates/cargo-clone-crate">cargo-clone-crate</a> can be used to download the
source and inspect it.</p>
<h2><a class="header" href="#features-examples" id="features-examples">Features Examples</a></h2>
<p>The following illustrates some real-world examples of features in action.</p>
<h3><a class="header" href="#minimizing-build-times-and-file-sizes" id="minimizing-build-times-and-file-sizes">Minimizing build times and file sizes</a></h3>
<p>Some packages use features so that if the features are not enabled, it reduces
the size of the crate and reduces compile time. Some examples are:</p>
<ul>
<li><a href="https://crates.io/crates/syn"><code>syn</code></a> is a popular crate for parsing Rust code. Since it is so popular, it
is helpful to reduce compile times since it affects so many projects. It has
a <a href="https://docs.rs/syn/1.0.54/syn/#optional-features">clearly documented list</a> of features which can be used to
minimize the amount of code it contains.</li>
<li><a href="https://crates.io/crates/regex"><code>regex</code></a> has a <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L33-L101">several features</a> that are <a href="https://docs.rs/regex/1.4.2/regex/#crate-features">well
documented</a>. Cutting out Unicode support can reduce the
resulting file size as it can remove some large tables.</li>
<li><a href="https://crates.io/crates/winapi"><code>winapi</code></a> has <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">a large number</a> of features that
limit which Windows API bindings it supports.</li>
<li><a href="https://crates.io/crates/web-sys"><code>web-sys</code></a> is another example similar to <code>winapi</code> that provides a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/crates/web-sys/Cargo.toml#L32-L1395">huge
surface area</a> of API bindings that are limited by using
features.</li>
</ul>
<h3><a class="header" href="#extending-behavior" id="extending-behavior">Extending behavior</a></h3>
<p>The <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> package has a <a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56"><code>preserve_order</code> feature</a>
which <a href="https://github.com/serde-rs/json/blob/v1.0.60/src/map.rs#L23-L26">changes the behavior</a> of JSON maps to preserve the
order that keys are inserted. Notice that it enables an optional dependency
<a href="https://crates.io/crates/indexmap"><code>indexmap</code></a> to implement the new behavior.</p>
<p>When changing behavior like this, be careful to make sure the changes are
<a href="reference/features.html#semver-compatibility">SemVer compatible</a>. That is, enabling the feature should not break code that
usually builds with the feature off.</p>
<h3><a class="header" href="#no_std-support" id="no_std-support"><code>no_std</code> support</a></h3>
<p>Some packages want to support both <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> and <code>std</code> environments. This is
useful for supporting embedded and resource-constrained platforms, but still
allowing extended capabilities for platforms that support the full standard
library.</p>
<p>The <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> package defines a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25"><code>std</code> feature</a> that
is <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L23">enabled by default</a>. At the top of the library, it
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8">unconditionally enables the <code>no_std</code> attribute</a>. This
ensures that <code>std</code> and the <a href="reference/../../std/prelude/index.html"><code>std</code> prelude</a> are not automatically in scope.
Then, in various places in the code (<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L270-L273">example1</a>,
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L67-L75">example2</a>), it uses <code>#[cfg(feature = &quot;std&quot;)]</code> attributes
to conditionally enable extra functionality that requires <code>std</code>.</p>
<h3><a class="header" href="#re-exporting-dependency-features" id="re-exporting-dependency-features">Re-exporting dependency features</a></h3>
<p>It can be convenient to re-export the features from a dependency. This allows
the user depending on the crate to control those features without needing to
specify those dependencies directly. For example, <a href="https://crates.io/crates/regex"><code>regex</code></a> <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89">re-exports the
features</a> from the <a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32"><code>regex_syntax</code></a>
package. Users of <code>regex</code> don't need to know about the <code>regex_syntax</code> package,
but they can still access the features it contains.</p>
<h3><a class="header" href="#vendoring-of-c-libraries" id="vendoring-of-c-libraries">Vendoring of C libraries</a></h3>
<p>Some packages provide bindings to common C libraries (sometimes referred to as
<a href="reference/build-scripts.html#-sys-packages">&quot;sys&quot; crates</a>). Sometimes these packages give you the choice to use the
C library installed on the system, or to build it from source. For example,
the <a href="https://crates.io/crates/openssl"><code>openssl</code></a> package has a <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl/Cargo.toml#L19"><code>vendored</code> feature</a> which
enables the corresponding <code>vendored</code> feature of <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code></a>. The
<code>openssl-sys</code> build script has some <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl-sys/build/main.rs#L47-L54">conditional logic</a> which
causes it to build from a local copy of the OpenSSL source code instead of
using the version from the system.</p>
<p>The <a href="https://crates.io/crates/curl-sys"><code>curl-sys</code></a> package is another example where the <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L49"><code>static-curl</code>
feature</a> causes it to build libcurl from source. Notice that
it also has a <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L52"><code>force-system-lib-on-osx</code></a> feature which forces
it <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/build.rs#L15-L20">to use the system libcurl</a>, overriding the
static-curl setting.</p>
<h3><a class="header" href="#feature-precedence" id="feature-precedence">Feature precedence</a></h3>
<p>Some packages may have mutually-exclusive features. One option to handle this
is to prefer one feature over another. The <a href="https://crates.io/crates/log"><code>log</code></a> package is an example. It
has <a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42">several features</a> for choosing the maximum logging level at
compile-time described <a href="https://docs.rs/log/0.4.11/log/#compile-time-filters">here</a>. It uses <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> to <a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448">choose a
precedence</a>. If multiple features are enabled, the higher &quot;max&quot;
levels will be preferred over the lower levels.</p>
<h3><a class="header" href="#proc-macro-companion-package" id="proc-macro-companion-package">Proc-macro companion package</a></h3>
<p>Some packages have a proc-macro that is intimately tied with it. However, not
all users will need to use the proc-macro. By making the proc-macro an
optional-dependency, this allows you to conveniently choose whether or not it
is included. This is helpful, because sometimes the proc-macro version must
stay in sync with the parent package, and you don't want to force the users to
have to specify both dependencies and keep them in sync.</p>
<p>An example is <a href="https://crates.io/crates/serde"><code>serde</code></a> which has a <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35"><code>derive</code></a> feature which
enables the <a href="https://crates.io/crates/serde_derive"><code>serde_derive</code></a> proc-macro. The <code>serde_derive</code> crate is very
tightly tied to <code>serde</code>, so it uses an <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17">equals version
requirement</a> to ensure they stay in sync.</p>
<h3><a class="header" href="#nightly-only-features" id="nightly-only-features">Nightly-only features</a></h3>
<p>Some packages want to experiment with APIs or language features that are only
available on the Rust <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. However, they may not want to require
their users to also use the nightly channel. An example is <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>
which has a <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L27"><code>nightly</code> feature</a> which enables an
<a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/closure.rs#L257-L269">extended API</a> that uses the <a href="reference/../../std/marker/trait.Unsize.html"><code>Unsize</code></a> marker trait that
is only available on the nightly channel at the time of this writing.</p>
<p>Note that at the root of the crate it uses <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L11"><code>cfg_attr</code> to enable the nightly
feature</a>. Keep in mind that the <a href="reference/../../unstable-book/index.html"><code>feature</code> attribute</a>
is unrelated to Cargo features, and is used to opt-in to experimental language
features.</p>
<p>The <a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40"><code>simd_support</code> feature</a> of the <a href="https://crates.io/crates/rand"><code>rand</code></a> package is another example,
which relies on a dependency that only builds on the nightly channel.</p>
<h3><a class="header" href="#experimental-features" id="experimental-features">Experimental features</a></h3>
<p>Some packages have new functionality that they may want to experiment with,
without having to commit to the stability of those APIs. The features are
usually documented that they are experimental, and thus may change or break in
the future, even during a minor release. An example is the <a href="https://crates.io/crates/async-std"><code>async-std</code></a>
package, which has an <a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42"><code>unstable</code> feature</a>, which <a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46">gates
new APIs</a> that people can opt-in to using, but may not be
completely ready to be relied upon.</p>
<h2><a class="header" href="#profiles" id="profiles">Profiles</a></h2>
<p>Profiles provide a way to alter the compiler settings, influencing things like
optimizations and debugging symbols.</p>
<p>Cargo has 4 built-in profiles: <code>dev</code>, <code>release</code>, <code>test</code>, and <code>bench</code>. It
automatically chooses the profile based on which command is being run, the
package and target that is being built, and command-line flags like
<code>--release</code>. The selection process is <a href="reference/profiles.html#profile-selection">described below</a>.</p>
<p>Profile settings can be changed in <a href="reference/manifest.html"><code>Cargo.toml</code></a> with the
<code>[profile]</code> table. Within each named profile, individual settings can be changed
with key/value pairs like this:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1               # Use slightly better optimizations.
overflow-checks = false     # Disable integer overflow checks.
</code></pre>
<p>Cargo only looks at the profile settings in the <code>Cargo.toml</code> manifest at the
root of the workspace. Profile settings defined in dependencies will be
ignored.</p>
<p>Additionally, profiles can be overridden from a <a href="reference/config.html">config</a> definition.
Specifying a profile in a config file or environment variable will override
the settings from <code>Cargo.toml</code>.</p>
<h3><a class="header" href="#profile-settings" id="profile-settings">Profile settings</a></h3>
<p>The following is a list of settings that can be controlled in a profile.</p>
<h4><a class="header" href="#opt-level" id="opt-level">opt-level</a></h4>
<p>The <code>opt-level</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#opt-level"><code>-C opt-level</code> flag</a> which controls the level
of optimization. Higher optimization levels may produce faster runtime code at
the expense of longer compiler times. Higher levels may also change and
rearrange the compiled code which may make it harder to use with a debugger.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code>: no optimizations</li>
<li><code>1</code>: basic optimizations</li>
<li><code>2</code>: some optimizations</li>
<li><code>3</code>: all optimizations</li>
<li><code>&quot;s&quot;</code>: optimize for binary size</li>
<li><code>&quot;z&quot;</code>: optimize for binary size, but also turn off loop vectorization.</li>
</ul>
<p>It is recommended to experiment with different levels to find the right
balance for your project. There may be surprising results, such as level <code>3</code>
being slower than <code>2</code>, or the <code>&quot;s&quot;</code> and <code>&quot;z&quot;</code> levels not being necessarily
smaller. You may also want to reevaluate your settings over time as newer
versions of <code>rustc</code> changes optimization behavior.</p>
<p>See also <a href="reference/../../rustc/profile-guided-optimization.html">Profile Guided Optimization</a> for more advanced optimization
techniques.</p>
<h4><a class="header" href="#debug" id="debug">debug</a></h4>
<p>The <code>debug</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debuginfo"><code>-C debuginfo</code> flag</a> which controls the
amount of debug information included in the compiled binary.</p>
<p>The valid options are:</p>
<ul>
<li><code>0</code> or <code>false</code>: no debug info at all</li>
<li><code>1</code>: line tables only</li>
<li><code>2</code> or <code>true</code>: full debug info</li>
</ul>
<p>You may wish to also configure the <a href="reference/profiles.html#split-debuginfo"><code>split-debuginfo</code></a> option
depending on your needs as well.</p>
<h4><a class="header" href="#split-debuginfo" id="split-debuginfo">split-debuginfo</a></h4>
<p>The <code>split-debuginfo</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo"><code>-C split-debuginfo</code> flag</a> which
controls whether debug information, if generated, is either placed in the
executable itself or adjacent to it.</p>
<p>This option is a string and acceptable values are the same as those the
<a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">compiler accepts</a>. The default value for this option
is <code>unpacked</code> on macOS for profiles that have debug information otherwise
enabled. Otherwise the default for this option is <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">documented with rustc</a> and is platform-specific. Some options are only
available on the <a href="reference/../../book/appendix-07-nightly-rust.html">nightly channel</a>. The Cargo default may change in the future
once more testing has been performed, and support for DWARF is stabilized.</p>
<h4><a class="header" href="#debug-assertions" id="debug-assertions">debug-assertions</a></h4>
<p>The <code>debug-assertions</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#debug-assertions"><code>-C debug-assertions</code> flag</a> which
turns <code>cfg(debug_assertions)</code> <a href="reference/../../reference/conditional-compilation.html#debug_assertions">conditional compilation</a> on or off. Debug
assertions are intended to include runtime validation which is only available
in debug/development builds. These may be things that are too expensive or
otherwise undesirable in a release build. Debug assertions enables the
<a href="reference/../../std/macro.debug_assert.html"><code>debug_assert!</code> macro</a> in the standard library.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h4><a class="header" href="#overflow-checks" id="overflow-checks">overflow-checks</a></h4>
<p>The <code>overflow-checks</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#overflow-checks"><code>-C overflow-checks</code> flag</a> which
controls the behavior of <a href="reference/../../reference/expressions/operator-expr.html#overflow">runtime integer overflow</a>. When overflow-checks are
enabled, a panic will occur on overflow.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<h4><a class="header" href="#lto" id="lto">lto</a></h4>
<p>The <code>lto</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#lto"><code>-C lto</code> flag</a> which controls LLVM's <a href="https://llvm.org/docs/LinkTimeOptimization.html">link
time optimizations</a>. LTO can produce better optimized code, using
whole-program analysis, at the cost of longer linking time.</p>
<p>The valid options are:</p>
<ul>
<li><code>false</code>: Performs &quot;thin local LTO&quot; which performs &quot;thin&quot; LTO on the local
crate only across its <a href="reference/profiles.html#codegen-units">codegen units</a>. No LTO is performed
if codegen units is 1 or <a href="reference/profiles.html#opt-level">opt-level</a> is 0.</li>
<li><code>true</code> or <code>&quot;fat&quot;</code>: Performs &quot;fat&quot; LTO which attempts to perform
optimizations across all crates within the dependency graph.</li>
<li><code>&quot;thin&quot;</code>: Performs <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">&quot;thin&quot; LTO</a>. This is similar to &quot;fat&quot;, but takes
substantially less time to run while still achieving performance gains
similar to &quot;fat&quot;.</li>
<li><code>&quot;off&quot;</code>: Disables LTO.</li>
</ul>
<p>See also the <a href="reference/../../rustc/codegen-options/index.html#linker-plugin-lto"><code>-C linker-plugin-lto</code></a> <code>rustc</code> flag for cross-language LTO.</p>
<h4><a class="header" href="#panic" id="panic">panic</a></h4>
<p>The <code>panic</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#panic"><code>-C panic</code> flag</a> which controls which panic
strategy to use.</p>
<p>The valid options are:</p>
<ul>
<li><code>&quot;unwind&quot;</code>: Unwind the stack upon panic.</li>
<li><code>&quot;abort&quot;</code>: Terminate the process upon panic.</li>
</ul>
<p>When set to <code>&quot;unwind&quot;</code>, the actual value depends on the default of the target
platform. For example, the NVPTX platform does not support unwinding, so it
always uses <code>&quot;abort&quot;</code>.</p>
<p>Tests, benchmarks, build scripts, and proc macros ignore the <code>panic</code> setting.
The <code>rustc</code> test harness currently requires <code>unwind</code> behavior. See the
<a href="reference/unstable.html#panic-abort-tests"><code>panic-abort-tests</code></a> unstable flag which enables <code>abort</code> behavior.</p>
<p>Additionally, when using the <code>abort</code> strategy and building a test, all of the
dependencies will also be forced to build with the <code>unwind</code> strategy.</p>
<h4><a class="header" href="#incremental" id="incremental">incremental</a></h4>
<p>The <code>incremental</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#incremental"><code>-C incremental</code> flag</a> which controls
whether or not incremental compilation is enabled. Incremental compilation
causes <code>rustc</code> to save additional information to disk which will be reused
when recompiling the crate, improving re-compile times. The additional
information is stored in the <code>target</code> directory.</p>
<p>The valid options are:</p>
<ul>
<li><code>true</code>: enabled</li>
<li><code>false</code>: disabled</li>
</ul>
<p>Incremental compilation is only used for workspace members and &quot;path&quot;
dependencies.</p>
<p>The incremental value can be overridden globally with the <code>CARGO_INCREMENTAL</code>
<a href="reference/environment-variables.html">environment variable</a> or the <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> config variable.</p>
<h4><a class="header" href="#codegen-units" id="codegen-units">codegen-units</a></h4>
<p>The <code>codegen-units</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#codegen-units"><code>-C codegen-units</code> flag</a> which
controls how many &quot;code generation units&quot; a crate will be split into. More
code generation units allows more of a crate to be processed in parallel
possibly reducing compile time, but may produce slower code.</p>
<p>This option takes an integer greater than 0.</p>
<p>The default is 256 for <a href="reference/profiles.html#incremental">incremental</a> builds, and 16 for
non-incremental builds.</p>
<h4><a class="header" href="#rpath" id="rpath">rpath</a></h4>
<p>The <code>rpath</code> setting controls the <a href="reference/../../rustc/codegen-options/index.html#rpath"><code>-C rpath</code> flag</a> which controls
whether or not <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> is enabled.</p>
<h3><a class="header" href="#default-profiles" id="default-profiles">Default profiles</a></h3>
<h4><a class="header" href="#dev" id="dev">dev</a></h4>
<p>The <code>dev</code> profile is used for normal development and debugging. It is the
default for build commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>.</p>
<p>The default settings for the <code>dev</code> profile are:</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0
debug = true
split-debuginfo = '...'  # Platform-specific.
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h4><a class="header" href="#release" id="release">release</a></h4>
<p>The <code>release</code> profile is intended for optimized artifacts used for releases
and in production. This profile is used when the <code>--release</code> flag is used, and
is the default for <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>.</p>
<p>The default settings for the <code>release</code> profile are:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h4><a class="header" href="#test" id="test">test</a></h4>
<p>The <code>test</code> profile is used for building tests, or when benchmarks are built in
debug mode with <code>cargo build</code>.</p>
<p>The default settings for the <code>test</code> profile are:</p>
<pre><code class="language-toml">[profile.test]
opt-level = 0
debug = 2
split-debuginfo = '...'  # Platform-specific.
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'    # This setting is always ignored.
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h4><a class="header" href="#bench" id="bench">bench</a></h4>
<p>The <code>bench</code> profile is used for building benchmarks, or when tests are built
with the <code>--release</code> flag.</p>
<p>The default settings for the <code>bench</code> profile are:</p>
<pre><code class="language-toml">[profile.bench]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'    # This setting is always ignored.
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h4><a class="header" href="#build-dependencies-1" id="build-dependencies-1">Build Dependencies</a></h4>
<p>All profiles, by default, do not optimize build dependencies (build scripts,
proc macros, and their dependencies). The default settings for build overrides
are:</p>
<pre><code class="language-toml">[profile.dev.build-override]
opt-level = 0
codegen-units = 256

[profile.release.build-override]
opt-level = 0
codegen-units = 256
</code></pre>
<p>Build dependencies otherwise inherit settings from the active profile in use, as
described below.</p>
<h3><a class="header" href="#profile-selection" id="profile-selection">Profile selection</a></h3>
<p>The profile used depends on the command, the package, the Cargo target, and
command-line flags like <code>--release</code>.</p>
<p>Build commands like <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>, <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a>, <a href="reference/../commands/cargo-check.html"><code>cargo check</code></a>, and
<a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> default to using the <code>dev</code> profile. The <code>--release</code> flag may be
used to switch to the <code>release</code> profile.</p>
<p>The <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> command defaults to the <code>release</code> profile, and may use
the <code>--debug</code> flag to switch to the <code>dev</code> profile.</p>
<p>Test targets are built with the <code>test</code> profile by default. The <code>--release</code>
flag switches tests to the <code>bench</code> profile.</p>
<p>Bench targets are built with the <code>bench</code> profile by default. The <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> command can be used to build a bench target with the <code>test</code> profile to
enable debugging.</p>
<p>Note that when using the <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> and <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> commands, the
<code>test</code>/<code>bench</code> profiles only apply to the final test executable. Dependencies
will continue to use the <code>dev</code>/<code>release</code> profiles. Also note that when a
library is built for unit tests, then the library is built with the <code>test</code>
profile. However, when building an integration test target, the library target
is built with the <code>dev</code> profile and linked into the integration test
executable.</p>
<p><img src="reference/../images/profile-selection.svg" alt="Profile selection for cargo test" /></p>
<h3><a class="header" href="#overrides" id="overrides">Overrides</a></h3>
<p>Profile settings can be overridden for specific packages and build-time
crates. To override the settings for a specific package, use the <code>package</code>
table to change the settings for the named package:</p>
<pre><code class="language-toml"># The `foo` package will use the -Copt-level=3 flag.
[profile.dev.package.foo]
opt-level = 3
</code></pre>
<p>The package name is actually a <a href="reference/pkgid-spec.html">Package ID Spec</a>, so you can
target individual versions of a package with syntax such as
<code>[profile.dev.package.&quot;foo:2.1.0&quot;]</code>.</p>
<p>To override the settings for all dependencies (but not any workspace member),
use the <code>&quot;*&quot;</code> package name:</p>
<pre><code class="language-toml"># Set the default for dependencies.
[profile.dev.package.&quot;*&quot;]
opt-level = 2
</code></pre>
<p>To override the settings for build scripts, proc macros, and their
dependencies, use the <code>build-override</code> table:</p>
<pre><code class="language-toml"># Set the settings for build scripts and proc-macros.
[profile.dev.build-override]
opt-level = 3
</code></pre>
<blockquote>
<p>Note: When a dependency is both a normal dependency and a build dependency,
Cargo will try to only build it once when <code>--target</code> is not specified. When
using <code>build-override</code>, the dependency may need to be built twice, once as a
normal dependency and once with the overridden build settings. This may
increase initial build times.</p>
</blockquote>
<p>The precedence for which value is used is done in the following order (first
match wins):</p>
<ol>
<li><code>[profile.dev.package.name]</code> — A named package.</li>
<li><code>[profile.dev.package.&quot;*&quot;]</code> — For any non-workspace member.</li>
<li><code>[profile.dev.build-override]</code> — Only for build scripts, proc macros, and
their dependencies.</li>
<li><code>[profile.dev]</code> — Settings in <code>Cargo.toml</code>.</li>
<li>Default values built-in to Cargo.</li>
</ol>
<p>Overrides cannot specify the <code>panic</code>, <code>lto</code>, or <code>rpath</code> settings.</p>
<h4><a class="header" href="#overrides-and-generics" id="overrides-and-generics">Overrides and generics</a></h4>
<p>The location where generic code is instantiated will influence the
optimization settings used for that generic code. This can cause subtle
interactions when using profile overrides to change the optimization level of
a specific crate. If you attempt to raise the optimization level of a
dependency which defines generic functions, those generic functions may not be
optimized when used in your local crate. This is because the code may be
generated in the crate where it is instantiated, and thus may use the
optimization settings of that crate.</p>
<p>For example, <a href="https://crates.io/crates/nalgebra">nalgebra</a> is a library which defines vectors and matrices making
heavy use of generic parameters. If your local code defines concrete nalgebra
types like <code>Vector4&lt;f64&gt;</code> and uses their methods, the corresponding nalgebra
code will be instantiated and built within your crate. Thus, if you attempt to
increase the optimization level of <code>nalgebra</code> using a profile override, it may
not result in faster performance.</p>
<p>Further complicating the issue, <code>rustc</code> has some optimizations where it will
attempt to share monomorphized generics between crates. If the opt-level is 2
or 3, then a crate will not use monomorphized generics from other crates, nor
will it export locally defined monomorphized items to be shared with other
crates. When experimenting with optimizing dependencies for development,
consider trying opt-level 1, which will apply some optimizations while still
allowing monomorphized items to be shared.</p>
<h2><a class="header" href="#配置" id="配置">配置</a></h2>
<p>本文档将解释 Cargo 的配置系统如何工作，以及可用的字段或配置。有关通过其清单，来配置程序包的信息，请参阅<a href="reference/./manifest.html">清单格式</a>.</p>
<h3><a class="header" href="#hierarchical-structure" id="hierarchical-structure">Hierarchical structure</a></h3>
<p>分层策略</p>
<p>Cargo 允许特定包，具有本地配置以及全局配置，就像 git 一样。Cargo 将其扩展为分层策略。例如，如果在<code>/projects/foo/bar/baz</code>调用 Cargo，然后将按以下顺序，探测和统一配置文件:</p>
<ul>
<li><code>/projects/foo/bar/baz/.cargo/config</code></li>
<li><code>/projects/foo/bar/.cargo/config</code></li>
<li><code>/projects/foo/.cargo/config</code></li>
<li><code>/projects/.cargo/config</code></li>
<li><code>/.cargo/config</code></li>
<li><code>$HOME/.cargo/config</code></li>
</ul>
<p>使用此结构，您可以为每个包指定配置，甚至可以将其检入版本控制。您还可以在主目录中，使用指定默认值的配置文件。</p>
<h3><a class="header" href="#configuration-format" id="configuration-format">Configuration format</a></h3>
<p>配置格式</p>
<p>所有配置目前都在<a href="https://github.com/toml-lang/toml">TOML 格式</a>(与 Cargo.toml 清单一样)，在字段(表格)内部使用简单的键值对，它们都被合并在一起。</p>
<h3><a class="header" href="#configuration-keys" id="configuration-keys">Configuration keys</a></h3>
<p>配置字段</p>
<p>以下所有字段都是可选的，除非另有说明，否则它们的默认值将作为其值。</p>
<p>指定工具的键值可以给出，一个‘绝对路径，相对路径或无路径工具名称’。给定的绝对路径和无路径工具名称直接使用。相对路径，则解析相对于<code>.cargo</code>目录的父目录，配置文件就居住在里面。</p>
<pre><code class="language-bash"># 路径数组，指向本地将要覆盖依赖项的存储库.
# 更多信息，请看 指定 依赖项 指南.
paths = [&quot;/path/to/override&quot;]

[cargo-new]
# 这是你 放 name/email 的地方， 在一个新Cargo.toml中的
#`authors` 表格就会生成。若不存在， 那 `git` 会去调查， 若还是不
# 存在，那 `$USER` 和 `$EMAIL` 会被使用.
name = &quot;...&quot;
email = &quot;...&quot;

# 默认来说， `cargo new` 会初始化一个新的  Git repository. 该字段若设为 `hg` ，就是新建一个 Mercurial repository， 或 `none` 禁用此行为.
vcs = &quot;none&quot;

# 接下来的 部分， $triple 是 一些有效目标 triple的引用， 而不是一个字面量&quot;$triple&quot;的意思， 这个引用是无论何时都能应用编译的。
# 'cfg(...)' 是参考 类Rust `#[cfg]` 语法 (条件语句)
[target.$triple]
#  linker 可传递参数给 rustc (通过 `-C linker=`) 当 `$triple`
# 要被编译. 默认不传递东东
linker = &quot;..&quot;
# 一样，但这是传递给 rustc 关于 库压缩的参数 ，通过 `-C ar=`.
ar = &quot;..&quot;
# 若 提供了 一个 runner ， 编译`$triple`目标 会通过 执行 runner 执行文件来完成， 它会将真正的目标 作为第一参数.
# 这可运行 `cargo run`， `cargo test` 和 `cargo bench` 命令.
# 默认，编译目标是 直接执行的.
runner = &quot;..&quot;
# 自定义 全编译器，目标为 $triple
# 这些值会覆盖 build.rustflags
rustflags = [&quot;..&quot;, &quot;..&quot;]

[target.'cfg(...)']
# 与 $triple 配置类似， 但使用的是 `cfg` 语法.
# 若有几个 `cfg` 和 $triple 目标作为备用， 那 rustflags
# 会被串联起来. 该 `cfg` 语法仅能应用到 rustflags， 而不能是
# linker.
rustflags = [&quot;..&quot;, &quot;..&quot;]
# 与 $triple 配置类似 ， 但使用的是 `cfg` 语法.
# 若 一个或多个 `cfg`s， 和一个 a $triple 目标作为备用，那 该$triple将会被使用
# 若有几个 `cfg` 和 备用的， 那构建会 error
runner = &quot;..&quot;

# 关联到 注册表 的配置字段
[registry]
index = &quot;...&quot;   # 注册表索引的URL（默认为中央存储库）
token = &quot;...&quot;   # 访问令牌（在中央回购网站上找到）
default = &quot;...&quot; # 要使用的默认备用注册表（可以使用--registry覆盖）

[http]
proxy = &quot;host:port&quot; # 用于HTTP请求的HTTP代理（默认为none）
                    # libcurl格式，例如“socks5h://host:port”
timeout = 30        # 每个HTTP请求的超时，以秒为单位
cainfo = &quot;cert.pem&quot; # 证书颁发机构（CA）包的路径（可选）
check-revoke = true # 指示是否检查SSL证书是否已废除
low-speed-limit = 5 # 限速 字节/秒（10 = 默认值，0 = 禁用）
multiplexing = true # 是否在可能的情况下使用 HTTP/2多路复用

# 此设置可用于帮助调试Cargo所发生的HTTP请求
# 当设置为“true”时，将填充Cargo的正常调试日志记录
# 关于HTTP的信息，您可以使用
# `RUST_LOG=cargo::ops::registry=debug`提取（和`trace`可能会打印更多）。
#
# 在将这些日志发布到其他地方时要小心，因可能存在这样的
# header中，有一个你不想泄露的身份验证令牌的情况！务必
# 在发布之前简要查看日志。
debug = false

[build]
jobs = 1                  # 并行作业数，默认为CPU数
rustc = &quot;rustc&quot;           # rust编译器工具
rustdoc = &quot;rustdoc&quot;       # doc生成器工具
target = &quot;triple&quot;         # build为目标 triple（被`cargo install`忽略）
target-dir = &quot;target&quot;     # 放置所有生成的工件的路径
rustflags = [&quot;..&quot;, &quot;..&quot;]  # 自定义 传递给所有编译器调用 的参数
incremental = true        # 是否启用增量编译
dep-info-basedir = &quot;..&quot;   # depfiles中，目标的基本目录的完整路径

[term]
verbose = false        # Cargo否提供详细输出
color = 'auto'         # Cargo否着色输出

# 网络配置
[net]
retry = 2 # 失败 自动重试 次数
git-fetch-with-cli = false  # 若为 `true` 我们会使用 `git`命令行去 fetch git repos

# 别名 cargo 命令. 前 3 个aliases 是内置的. 如果你的命令 要求 整行命令，请使用 list 格式.
[alias]
b = &quot;build&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rr = &quot;run --release&quot;
space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;\&quot;command list\&quot;&quot;]
</code></pre>
<h3><a class="header" href="#environment-variables" id="environment-variables">Environment variables</a></h3>
<p>环境变量</p>
<p>除了上面的 TOML 语法之外，还可以通过环境变量配置 Cargo。对于上方的<code>foo.bar</code>表格的每个配置字段，也可以用环境变量<code>CARGO_FOO_BAR</code>来定义值。比如说<code>build.jobs</code>字段，也可以通过<code>CARGO_BUILD_JOBS</code>定义。</p>
<p>环境变量将优先于 TOML 配置，并且当前仅支持由环境变量定义的整数，布尔和字符串字段，这意味着<a href="reference/./source-replacement.html">来源更换</a>，能由表格表示，却不能通过环境变量配置。</p>
<p>除上述系统外，Cargo 还认可其他一些特定的<a href="reference/./environment-variables.html">环境变量</a>.</p>
<h2><a class="header" href="#environment-variables-1" id="environment-variables-1">Environment Variables</a></h2>
<p>Cargo 设置，并读取许多环境变量，代码可以检测或覆盖这些环境变量。以下是 Cargo 与它们交互时，组织的变量列表:</p>
<h3><a class="header" href="#environment-variables-cargo-reads" id="environment-variables-cargo-reads">Environment variables Cargo reads</a></h3>
<p>Cargo 会读取的环境变量</p>
<p>您可以重写这些环境变量来更改 Cargo 在系统中的行为:</p>
<table><thead><tr><th>名(ENV)</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO_HOME</code></td><td>Cargo 在本地缓存注册表索引和箱子的 git 版本。默认情况下，这些存储在<code>$HOME/.cargo</code>，但是这个变量重写了这个目录的位置。一旦箱被缓存，它就不会被清除命令删除。</td></tr>
<tr><td><code>CARGO_TARGET_DIR</code></td><td>相对于当前工作目录，放置所有生成的工件的位置.</td></tr>
<tr><td><code>RUSTC</code></td><td>Cargo 不运行<code>rustc</code>，而执行指定的编译器。</td></tr>
<tr><td><code>RUSTC_WRAPPER</code></td><td>Cargo 将执行这个指定的包装器，而不是简单地运行<code>rustc</code>。将 rustc 调用 作为其命令行参数传递，第一个参数是 rustc.</td></tr>
<tr><td><code>RUSTDOC</code></td><td>Cargo 将执行此指定的<code>rustdoc</code>实例，而不是<code>rustdoc</code>.</td></tr>
<tr><td><code>RUSTDOCFLAGS</code></td><td>空格分隔的自定义标志列表，用来传递给 Cargo 执行的所有<code>rustdoc</code>调用 。与<code>cargo rustdoc</code>不同，这对于传递一个参数给 <em>全部的</em> <code>rustdoc</code>实例是有用的。</td></tr>
<tr><td><code>RUSTFLAGS</code></td><td>自定义参数的空格分隔列表，用来传递给 Cargo 执行的所有编译器调用。与<code>cargo rustc</code>不同，这对于传递一个标志 <em>全部的</em> 编译实例是有用的。</td></tr>
<tr><td><code>CARGO_INCREMENTAL</code></td><td>如果设置为 1，则 Cargo 将强制在当前编译中启用增量编译，而当设置为 0，则强制禁用增量编译。如果这个 ENV 不存在，否则将使用 Cargo 默认值。</td></tr>
<tr><td><code>CARGO_CACHE_RUSTC_INFO</code></td><td>如果这个设置为 0，那么 Cargo 将不尝试缓存编译器版本信息.</td></tr>
</tbody></table>
<p>注意，Cargo 也会在<code>.cargo/config</code>配置中读取环境变量，如<a href="reference/./config.html#environment-variables">那份文件</a></p>
<h3><a class="header" href="#environment-variables-cargo-sets-for-crates" id="environment-variables-cargo-sets-for-crates">Environment variables Cargo sets for crates</a></h3>
<p>Cargo 为 crates 设置的环境变量</p>
<p>Cargo 在编译时，会将这些环境变量暴露在箱子中。请注意，这也适用于测试二进制文件。要在 Rust 程序中获得这些变量中的任何一个变量的值，请执行以下操作:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let version = env!(&quot;CARGO_PKG_VERSION&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><code>version</code>现在将包含了<code>CARGO_PKG_VERSION</code>值。</p>
<table><thead><tr><th>名</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO</code></td><td>执行构建的二进制<code>cargo</code>路径.</td></tr>
<tr><td><code>CARGO_MANIFEST_DIR</code></td><td>包含包的清单的目录.</td></tr>
<tr><td><code>CARGO_PKG_VERSION</code></td><td>您的包的完整版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_MAJOR</code></td><td>你的软件包的主要版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_MINOR</code></td><td>您的包的次要版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_PATCH</code></td><td>包的补丁版本.</td></tr>
<tr><td><code>CARGO_PKG_VERSION_PRE</code></td><td>包的预发布版本.</td></tr>
<tr><td><code>CARGO_PKG_AUTHORS</code></td><td>从程序包的清单中，冒号分隔出作者列表.</td></tr>
<tr><td><code>CARGO_PKG_NAME</code></td><td>你的包的名字.</td></tr>
<tr><td><code>CARGO_PKG_DESCRIPTION</code></td><td>从包的清单中描述.</td></tr>
<tr><td><code>CARGO_PKG_HOMEPAGE</code></td><td>从包的清单中的主页.</td></tr>
<tr><td><code>CARGO_PKG_REPOSITORY</code></td><td>从包的清单中存储库.</td></tr>
<tr><td><code>OUT_DIR</code></td><td>如果包具有构建脚本，则将其设置为，构建脚本应该在其中放置其输出的文件夹。更多信息见下文.</td></tr>
</tbody></table>
<h3><a class="header" href="#environment-variables-cargo-sets-for-build-scripts" id="environment-variables-cargo-sets-for-build-scripts">Environment variables Cargo sets for build scripts</a></h3>
<p>Cargo 为构建脚本设置的环境变量</p>
<p>当运行构建脚本时，Cargo 设置多个环境变量.因为编译生成脚本时还没有设置这些变量，所以上面的示例使用<code>env!</code>无法工作，而是在运行构建脚本时需要检索值:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><code>out_dir</code>现在将包含的价值<code>OUT_DIR</code>.</p>
<table><thead><tr><th>名</th><th>曰</th></tr></thead><tbody>
<tr><td><code>CARGO</code></td><td>执行构建的二进制<code>cargo</code>路径.</td></tr>
<tr><td><code>CARGO_MANIFEST_DIR</code></td><td>包含正在构建的包的清单的目录(包含构建脚本的包)。还要注意，这是生成脚本启动时，当前工作目录的值.</td></tr>
<tr><td><code>CARGO_MANIFEST_LINKS</code></td><td>清单<code>links</code>的值.</td></tr>
<tr><td><code>CARGO_FEATURE_&lt;name&gt;</code></td><td>对于正在构建的包的每个激活特性，此环境变量会让<code>&lt;name&gt;</code>功能名称存在，名称的<code>-</code>会转换成<code>_</code>.</td></tr>
<tr><td><code>CARGO_CFG_&lt;cfg&gt;</code></td><td>对正在构建包的每个<a href="https://doc.rust-lang.org/reference/attributes.md#conditional-compilation">配置选项</a>，此环境变量将包含配置的值，其中<code>&lt;cfg&gt;</code>就是配置的名称，并将<code>-</code>翻译成<code>_</code>. 如果设置了布尔配置，则存在布尔配置，否则不存在。具有多个值的配置被连接到单个变量，该变量用<code>，</code>分隔就好。</td></tr>
<tr><td><code>OUT_DIR</code></td><td>所有输出都应该放在这个文件夹。此文件夹位于正在构建的包的构建目录中，并且对于所讨论的包是唯一的。</td></tr>
<tr><td><code>TARGET</code></td><td>正在编译的目标三元组。该为这个三元组编译本机代码。关于目标三元组的更多信息在<a href="http://clang.llvm.org/docs/CrossCompilation.md#target-triple">clang 自身文档中</a>.</td></tr>
<tr><td><code>HOST</code></td><td>Rust 编译器的主机三元组.</td></tr>
<tr><td><code>NUM_JOBS</code></td><td>指定为顶层并行的并行性。这可以传递一个<code>-j</code>参数到系统(像<code>make</code>). 注意，在解释这个环境变量时应该小心。出于历史目的，仍然提供此功能，但是例如，最新版本的 Cargo 不需要运行<code>make -j</code>，因为它会自动。Cargo 自行实现[JooServer]，并且允许构建脚本继承这些信息，因此与 GNU 兼容的程序将使作业服务器已经具有适当配置的并行性。</td></tr>
<tr><td><code>OPT_LEVEL</code> ，<code>DEBUG</code></td><td>为了分析，当前正在构建的相应变量值.</td></tr>
<tr><td><code>PROFILE</code></td><td>发布版本用<code>release</code>，而<code>debug</code>用于其他构建.</td></tr>
<tr><td><code>DEP_&lt;name&gt;_&lt;key&gt;</code></td><td>有关此组环境变量的更多信息，请参阅<a href="reference/./build-scripts.html#the-links-manifest-key"><code>links</code></a>.</td></tr>
<tr><td><code>RUSTC</code> ，<code>RUSTDOC</code></td><td>Cargo 已经决定使用的编译器和文档生成器，传递给构建脚本，以便构建脚本也可以使用它.</td></tr>
<tr><td><code>RUSTC_LINKER</code></td><td>如果指定了，Cargo 为了当前目标，决定使用的链接器(二进制文件)的路径。这个链接器可以通过编辑<code>.cargo/config</code>更改，欲了解更多信息，请参阅有关文档<a href="reference/./config.html">Cargo 配置</a>。</td></tr>
</tbody></table>
<h3><a class="header" href="#environment-variables-cargo-sets-for-3rd-party-subcommands" id="environment-variables-cargo-sets-for-3rd-party-subcommands">Environment variables Cargo sets for 3rd party subcommands</a></h3>
<p>Cargo 为 第三方子命令设置的环境变量</p>
<p>Cargo 将这个环境变量公开给第三方子命令(即，名为<code>cargo-foobar</code>放置在<code>$PATH</code>):</p>
<ul>
<li><code>CARGO</code> - 执行构建的二进制<code>cargo</code>路径。</li>
</ul>
<h2><a class="header" href="#build-scripts-1" id="build-scripts-1">Build Scripts</a></h2>
<blockquote>
<p>构建脚本</p>
</blockquote>
<p>一些包需要编译第三方非 Rust 代码，例如 C 库。其他的包需要链接到 C 库，当然这些库既可以位于系统上，也可以从源代码构建。其他人或许还需要功能工具，比如构建之前的代码生成(想想解析生成器)。</p>
<p>Cargo 并不打算替换为这些能良好优化任务的其他工具，但是它与<code>build</code>配置选项.</p>
<pre><code class="language-toml">[package]
# ...
build = &quot;build.rs&quot;
</code></pre>
<p>指定的<code>build</code>命令应执行的 Rust 文件(相对于包根)，将在包编译其他内容之前，被编译和调用，从而具备 Rust 代码所依赖的构建或生成的工件。默认情况下 Cargo 在包根文件中寻找<code>&quot;build.rs&quot;</code>(即使您没有给<code>build</code>字段指定值)使用<code>build = &quot;custom_build_name.rs&quot;</code>指定自定义生成名，或<code>build = false</code>禁用对构建脚本的自动检测。</p>
<p>Build 命令的一些用例是:</p>
<ul>
<li>构建一个捆绑的 C 库.</li>
<li>在主机系统上找到 C 库.</li>
<li>从规范中生成 Rust 模块.</li>
<li>为箱，执行所需的某平台特定配置.</li>
</ul>
<p>下面将详细介绍每一个用例，以给出构建命令如何工作的示例.</p>
<h3><a class="header" href="#inputs-to-the-build-script" id="inputs-to-the-build-script">Inputs to the Build Script</a></h3>
<blockquote>
<p>输入到构建脚本</p>
</blockquote>
<p>当运行构建脚本时，存在许多构建脚本用到的输入，所有输入都以<a href="reference/./environment-variables.html">环境变量</a>传入。</p>
<p>除了环境变量之外，构建脚本的当前目录是构建脚本包的源目录.</p>
<h3><a class="header" href="#outputs-of-the-build-script" id="outputs-of-the-build-script">Outputs of the Build Script</a></h3>
<blockquote>
<p>构建脚本的输出</p>
</blockquote>
<p>由构建脚本打印到 stdout 的所有行都被写入像<code>target/debug/build/&lt;pkg&gt;/output</code>这样的文件(精确的位置可能取决于你的配置)。如果您希望直接在终端中看到这样的输出，那么使用非常详细<code>-vv</code>标志。注意，如果既不修改构建脚本也不修改包源文件，下一次的<code>-vv</code>调用将<strong>不</strong>打印重复输出到终端，因为没有执行新的构建。可执行<code>cargo clean</code>，如果希望确保输出始终显示在终端上，但要在每次 Cargo 调用之前执行。任何一行以<code>cargo:</code>开始的，直接由 Cargo 解释。行必须是<code>cargo:key=value</code>形式，就像下面的例子:</p>
<pre><code># specially recognized by Cargo
cargo:rustc-link-lib=static=foo
cargo:rustc-link-search=native=/path/to/foo
cargo:rustc-cfg=foo
cargo:rustc-env=FOO=bar
# arbitrary user-defined metadata
cargo:root=/path/to/foo
cargo:libdir=/path/to/foo/lib
cargo:include=/path/to/foo/include
</code></pre>
<p>另一方面，打印到 stderr 的行被写入像<code>target/debug/build/&lt;pkg&gt;/stderr</code>这样的文件，但不被 Cargo 解释。</p>
<p>Cargo 识别一些特殊的 key，其中一些影响箱的构造:</p>
<ul>
<li>
<p><code>rustc-link-lib=[KIND=]NAME</code>说明了，指定值是库名，且会作为<code>-l</code>标志传递给编译器。<code>KIND</code>可选为<code>static</code>，<code>dylib</code>(默认值)，或<code>framework</code>的其中之一，用<code>rustc --help</code>见更多细节。</p>
</li>
<li>
<p><code>rustc-link-search=[KIND=]PATH</code>说明了，指定值是库搜索路径，且会作为<code>-L</code>标志传递给编译器。<code>KIND</code>可选为<code>dependency</code>，<code>crate</code>，<code>native</code>，<code>framework</code>或<code>all</code>(默认值)的其中之一，使用<code>rustc --help</code>见更多细节.</p>
</li>
<li>
<p><code>rustc-flags=FLAGS</code>是传递给编译器的一组标志，仅支持<code>-l</code>和<code>-L</code>标志。</p>
</li>
<li>
<p><code>rustc-cfg=FEATURE</code>说明了，指定的特性，且会作为<code>--cfg</code>标志传递给编译器。这通常对检测，执行各种特征的编译时间，是有用的。</p>
</li>
<li>
<p><code>rustc-env=VAR=VALUE</code>说明了，指定的环境变量，且会被添加到编译器所在的环境中。然后，可以通过编译箱中的<code>env!</code>宏检索该值。这对于在箱的代码中嵌入额外的元数据很有用，比如 Git HEAD 的散列，或持续集成服务器的唯一标识符。</p>
</li>
<li>
<p><code>rerun-if-changed=PATH</code>是文件或目录的路径，说明了如果构建脚本发生更改(由文件上最近修改的时间戳检测到)，则应重新运行构建脚本。通常，如果箱根目录中的任何文件发生更改，则重新运行构建脚本，但这可用于将更改范围扩展到仅一小组文件。(如果这个路径指向一个目录，则不会遍历整个目录以进行更改——只对目录本身的时间戳进行更改(该时间戳对应于目录中的某些类型的更改，取决于平台)，将触发重新构建。要请求重新运行整个目录中的任何更改，请递归地为该目录打印一行，为该目录内的所有内容打印另一行。)请注意，如果构建脚本本身(或其依赖项之一)更改，则无条件地重新构建和重新运行该脚本，因此，<code>cargo:rerun-if-changed=build.rs</code>几乎总是冗余(除非您想要忽略除了<code>build.rs</code>，所有其他文件的变化)</p>
</li>
<li>
<p><code>rerun-if-env-changed=VAR</code>是环境变量的名称，说明了它指示如果环境变量的值发生变化，则应重新运行构建脚本。这基本上与<code>rerun-if-changed</code>是一样的，除了它与环境变量一起工作。注意，这里的环境变量用于全局环境变量，如<code>CC</code>这样的，对于 Cargo 所设的像<code>TARGET</code>，就不必使用它。还要注意，如果<code>rerun-if-env-changed</code>打印出来，然后 Cargo 将<em>只</em>在，那些环境变量发生变化，或者打印出<code>rerun-if-changed</code>改变的文件的情况下，才重新运行构建脚本。</p>
</li>
<li>
<p><code>warning=MESSAGE</code>是构建脚本运行完毕后，打印到主控制台的消息/警告只针对路径依赖项(即，您在本地工作的那些依赖项)显示，因此如， crates.io 的箱在默认情况下不会打印警告。</p>
</li>
</ul>
<p>其他哪些元素都是用户定义的元数据，这些元数据传递给了依赖的。关于这个的更多信息可以在<a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a>部分查看.</p>
<h3><a class="header" href="#build-dependencies-2" id="build-dependencies-2">Build Dependencies</a></h3>
<blockquote>
<p>构建依赖</p>
</blockquote>
<p>构建脚本也可以依赖其他基于 Cargo 的箱。依赖关系通过清单的<code>build-dependencies</code>部分指定。</p>
<pre><code class="language-toml">[build-dependencies]
foo = { git = &quot;https://github.com/your-packages/foo&quot; }
</code></pre>
<p>构建脚本<strong>不</strong>可以访问<code>dependencies</code>或<code>dev-dependencies</code>部分列表中的依赖项(它们还没有建成!)，除非明确声明，否则包本身也不能使用所有构建依赖项。</p>
<h3><a class="header" href="#the-links-manifest-key" id="the-links-manifest-key">The <code>links</code> Manifest Key</a></h3>
<blockquote>
<p><code>links</code> 清单 键</p>
</blockquote>
<p>除了清单键<code>build</code>，Cargo 也支持一个，要链接到本地库的名称声明，那就是<code>links</code>清单键:</p>
<pre><code class="language-toml">[package]
# ...
links = &quot;foo&quot;
build = &quot;build.rs&quot;
</code></pre>
<p>此清单说明了包会链接到本机库<code>libfoo</code>，并且它还具有定位和/或构建该本机库的构建脚本。Cargo 要求<code>build</code>如果有值，那<code>links</code>也要有值。</p>
<p>这个清单键的目的是，让 Cargo 了解包所具有的本地依赖项集合，并提供在包构建脚本之间，传递元数据的合适的系统.</p>
<p>首先，Cargo 要求一个包最多只有一个<code>links</code>值。换句话说，禁止两个包链接到同一个本机库。然而，这里也有<a href="reference/build-scripts.html#a-sys-packages">约定位置</a>的方式，用来缓解这个问题。</p>
<p>如上面在输出格式中提到的，每个构建脚本可以以键-值对的形式生成一组任意的元数据。此元数据传递给<strong>依赖的</strong>包。例如，如果<code>libbar</code>依赖<code>libfoo</code>，当<code>libfoo</code>生成<code>key=value</code>作为其元数据的一部分，那<code>libbar</code>的构建脚本会有<code>DEP_FOO_KEY=value</code>环境变量。</p>
<p>注意，元数据只传递给直接依赖项，而不是把依赖项串起来。此元数据传递的动机，会在接下来，关联到系统库案例研究中概述。</p>
<h3><a class="header" href="#overriding-build-scripts" id="overriding-build-scripts">Overriding Build Scripts</a></h3>
<blockquote>
<p>覆盖 构建脚本</p>
</blockquote>
<p>如果一个清单包含<code>links</code>关键字，那 Cargo 支持重写用自定义库指定的构建脚本。此功能的目的是防止完全运行有问题的构建脚本，而是提前提供下元数据。</p>
<p>要覆盖构建脚本，请将下列配置放在任何可接受的 Cargo 的<a href="reference/./config.html">配置位置</a>中。</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-search = [&quot;/path/to/foo&quot;]
rustc-link-lib = [&quot;foo&quot;]
root = &quot;/path/to/foo&quot;
key = &quot;value&quot;
</code></pre>
<p>本节说明目标<code>x86_64-unknown-linux-gnu</code>，命名为<code>foo</code>的库，具有指定的元数据。此元数据与构建脚本时生成的元数据相同，提供了许多键/值对，其中<code>rustc-flags</code>，<code>rustc-link-search</code>和<code>rustc-link-lib</code>有点特殊.</p>
<p>使用此配置，如果一个包声明它链接到此<code>foo</code>，那构建脚本将<strong>不</strong>编译或运行，而会使用指定的元数据。</p>
<h3><a class="header" href="#case-study-code-generation" id="case-study-code-generation">Case study: Code generation</a></h3>
<blockquote>
<p>案例学习: 代码生成</p>
</blockquote>
<p>由于各种原因，一些 Cargo 包在编译之前需要生成代码。这里我们将介绍一个简单的示例，该示例把，'生成库调用'作为构建脚本的一部分.</p>
<p>首先，让我们看一下这个包的目录结构:</p>
<pre><code>.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>在这里我们可以看到我们有一个<code>build.rs</code>构建脚本，和二进制文件<code>main.rs</code>。 接下来，让我们看一下清单:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-from-generated-code&quot;
version = &quot;0.1.0&quot;
authors = [&quot;you@example.com&quot;]
build = &quot;build.rs&quot;
</code></pre>
<p>在这里，我们可以看到，我们已经指定了一个构建脚本<code>build.rs</code>，我们将使用它来生成一些代码。让我们看看构建脚本里面有什么:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    let mut f = File::create(&amp;dest_path).unwrap();

    f.write_all(b&quot;
        pub fn message() -&gt; &amp;'static str {
            \&quot;Hello, World!\&quot;
        }
    &quot;).unwrap();
}
</code></pre></pre>
<p>这里有两点值得注意的地方:</p>
<ul>
<li>脚本使用<code>OUT_DIR</code>环境变量，以知道输出文件到哪里。它可以使用进程的当前工作目录，来查找输入文件应该到哪里，但是在这种情况下，我们是没有任何输入文件的。</li>
<li>一般来说，构建脚本不应该修改<code>OUT_DIR</code>目录外的任何文件。 乍看之下，似乎不错，但当您使用这种箱子作为依赖项时，它确会带来问题，因为<code>.cargo/registry</code>源中的<em>隐性的</em>常量应该是不变的。<code>cargo</code>在打包时不会允许这样的脚本。</li>
<li>这个脚本相对简单，只是写出一个小生成的文件。可以想象，其他更奇特的操作也可能发生，例如从 C 头文件或其他定义的语言生成 Rust 模块。</li>
</ul>
<p>接下来，我们来看看库本身:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}
</code></pre>
<p>这就是真正的魔法发生的地方。该库正在使用 rustc 定义的 <code>include!</code>宏，它又结合<code>concat!</code>与<code>env!</code>宏去包含生成文件(<code>hello.rs</code>)，从而进入箱的编译。</p>
<p>使用此处所示的结构，箱可以包括(include)构建脚本在内的，任何数量的生成文件。</p>
<h3><a class="header" href="#case-study-building-some-native-code" id="case-study-building-some-native-code">Case study: Building some native code</a></h3>
<blockquote>
<p>案例学习: 构建一些原生代码</p>
</blockquote>
<p>有时需要建立一些本地 C 或 C++代码作为包的一部分。这是在用构建脚本到 Rust 箱本身之前，构建本机库的另一个极好用例。作为一个例子，我们将创建一个 Rust 库，它调用 C 来打印&quot;Hello,World!&quot;.</p>
<p>和上面一样，让我们先来看看包的布局:</p>
<pre><code>.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>很像之前的吧! 下一步，清单如下:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-world-from-c&quot;
version = &quot;0.1.0&quot;
authors = [&quot;you@example.com&quot;]
build = &quot;build.rs&quot;
</code></pre>
<p>现在，我们不打算使用任何-构建的依赖项，所以现在让我们看一下构建脚本:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();

    // 请注意，这种方法存在许多缺点，
    // 下个代码展示，会详细介绍如何提高这些命令的可移植性。
    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])
                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))
                       .status().unwrap();
    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);
    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
}
</code></pre></pre>
<p>此构建脚本首先将 C 文件编译为对象文件(通过调用<code>gcc</code>)，然后将这个对象文件转换为静态库(通过调用<code>ar</code>)，最后一步是反馈给 Cargo ，以表示我们的输出在<code>out_dir</code>和通过<code>-l static=hello</code>标志，编译器应该将箱静态链接到<code>libhello.a</code>。</p>
<p>请注意，这种硬编码方法有许多缺点:</p>
<ul>
<li>这个<code>gcc</code>命令本身不是跨平台可移植的。如，在 Windows 平台不太可能<code>gcc</code>，甚至不是所有 UNIX 平台都可能有<code>gcc</code>。 这个<code>ar</code>命令也处于类似的情况。</li>
<li>这些命令不考虑跨编译。如果我们为 Android 这样的平台进行跨编译，<code>gcc</code>就不太可能产生一个可执行的 ARM.</li>
</ul>
<p>但不要害怕，这里<code>build-dependencies</code>就帮到你! Cargo 生态系统有许多包，为了使此类任务更加容易、可移植和标准化。构建脚本可以写成:</p>
<pre><code class="language-rust ignore">// build.rs

// 依赖于外部维护的`cc`包，管理
// 调用C编译器。
extern crate cc;

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
}
</code></pre>
<p>添加<code>cc</code>箱，这样将构建，依赖<code>cc</code>就好啦，将下面的添加到您的<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0&quot;
</code></pre>
<p>这个<a href="https://crates.io/crates/cc"><code>cc</code>箱</a>抽象了 C 代码构建，主要用于脚本需求范围:</p>
<ul>
<li>它调用适当的编译器(Windows 的 MSVC，<code>gcc</code>对 MinGW ，<code>cc</code>对 UNIX 平台等等).</li>
<li>通过向正在使用的编译器传递适当的标志，获取<code>TARGET</code>变量.</li>
<li>其他环境变量，如<code>OPT_LEVEL</code>，<code>DEBUG</code>等等，都是自动处理的.</li>
<li>stdout 输出和<code>OUT_DIR</code>位置也由<code>cc</code>库控制.</li>
</ul>
<p>在这里，我们可以开始看到，将尽可能多的功能移植到公共构建依赖项，而不是在所有构建脚本之间复制来复制去，的一些主要好处!</p>
<p>回到案例研究，让我们快速浏览一下<code>src</code>目录中的内容:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// 注意缺少`#[link]`属性。 我们选择，将责任委派给
// 构建脚本的链接，而不是硬编码
// 它在源文件中.
extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}
</code></pre>
<p>然后，就好啦! 这就完成了使用构建脚本，从 Cargo 包构建一些 C 代码的示例。这也说明了为什么在许多情况下使，用构建依赖项非常重要，甚至更加简洁!</p>
<p>我们还看到了构建脚本使用箱，纯粹作为用于构建过程的依赖项，而不是在运行时，用作箱本身的依赖项的简要示例。</p>
<h3><a class="header" href="#case-study-linking-to-system-libraries" id="case-study-linking-to-system-libraries">Case study: Linking to system libraries</a></h3>
<blockquote>
<p>案例学习: 链接到系统库</p>
</blockquote>
<p>这里的最后一个案例研究，将研究 Cargo 库如何链接到系统库，以及构建脚本如何支持这个用例。</p>
<p>通常，Rust 箱希望链接到系统上经常提供的本地库，以绑定其功能，或者只是将其用作实现细节的一部分。想以不管平台的方式执行这个操作，而这却是一个相当微妙的问题，再次说明下，构建脚本的目的是尽可能多地分配这些(微妙)内容，以便让消费者尽可能容易地使用它.</p>
<p>作为一个例子，让我们来看一个<a href="https://github.com/alexcrichton/git2-rs/tree/master/libgit2-sys">Cargo 本身的依赖</a>，<a href="https://github.com/libgit2/libgit2">libgit2</a>。这个 C 库其实有许多约束条件:</p>
<ul>
<li>它可选为依赖 Unix 上的 OpenSSL ，来实现 https 传输.</li>
<li>它可选为依赖所有平台上的 libssh2 ，来实现 ssh 传输.</li>
<li>默认情况下，它通常不安装在所有系统上.</li>
<li>它可以从源代码使用<code>cmake</code>构建.</li>
</ul>
<p>为了可视化这里发生的事情，让我们看一下，链接本机 C 库的相关 Cargo 包的清单。</p>
<pre><code class="language-toml">[package]
name = &quot;libgit2-sys&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]
links = &quot;git2&quot;
build = &quot;build.rs&quot;

[dependencies]
libssh2-sys = { git = &quot;https://github.com/alexcrichton/ssh2-rs&quot; }

[target.'cfg(unix)'.dependencies]
openssl-sys = { git = &quot;https://github.com/alexcrichton/openssl-sys&quot; }

# ...
</code></pre>
<p>正如上面的清单所显示的，我们指定了一个<code>build</code>脚本，但值得注意的是，该示例具有<code>links</code>项，说明该箱(<code>libgit2-sys</code>)链接到了这个本地库<code>git2</code>。</p>
<p>在这里，我们还看到，我们选择让 Rust 箱有一个无条件的，通过<code>libssh2-sys</code>箱依赖<code>libssh2</code>(ssh2-rs)，以及(有条件的)特定于平 unix 台的<code>openssl-sys</code>依赖(其他平台现在被漠视)。这似乎有点违反在 <em>Cargo 清单</em> 的 <em>C 依赖</em> 的明确性，但这实际上是这'地方'中使用 Cargo 的一种约定.</p>
<h3><a class="header" href="#-sys-packages" id="-sys-packages"><code>*-sys</code> Packages</a></h3>
<blockquote>
<p><code>*-sys</code> 包们</p>
</blockquote>
<p>为了减轻对系统库的链接，crates.io 有一个包命名和功能的<em>惯例</em>。比如包名<code>foo-sys</code>，它应该提供两个主要功能:</p>
<ul>
<li>库箱应链接到本地库<code>libfoo</code>。 在源代码最后构建之前，这将经常探测当前的系统的<code>libfoo</code>。</li>
<li>库箱应提供在<code>libfoo</code>的<strong>声明</strong>函数，但是<strong>不</strong>绑定或高级抽象。</li>
</ul>
<p>一套<code>*-sys</code>包，提供了一组用于连接到本地库的公共依赖项。通过这种'本机库相关'的包约定，可以获得许多好处:</p>
<ul>
<li><code>foo-sys</code>的公共依赖，会减轻上面所说的，关于一个包的<code>links</code>的每个值规则。</li>
<li>一个公共依赖关系，更能发现<code>libfoo</code>本身的集中逻辑(或者从源代码构建它).</li>
<li>这些依赖关系很容易被重写.</li>
</ul>
<h3><a class="header" href="#building-libgit2" id="building-libgit2">Building libgit2</a></h3>
<blockquote>
<p>构建 libgit2 吧</p>
</blockquote>
<p>现在我们已经整理了 libgit2 的依赖，我们需要实际编写下构建脚本。我们这里不讨论特定的代码片段，而只研究<code>libgit2-sys</code>构建脚本的高层细节。这并不是建议所有包都遵循这个策略，而仅概述一个特定的策略。</p>
<p>构建脚本应该做的第一步是查询 libgit2 是否已经安装在主机系统上。要做到这一点，我们将利用现有的工具<code>pkg-config</code>(当它可用时)。我们也会使用<code>build-dependencies</code>部分重构成<code>pkg-config</code>相关的所有代码(或者有人已经这样做了!)。</p>
<p>如果<code>pkg-config</code>找不到 libgit2，或者如果<code>pkg-config</code>只是没有安装，下一步就要从捆绑源代码构建 libgit2 (捆绑源码作为<code>libgit2-sys</code>本身的一部分)。然而，在这样做时有一些细微差别，我们需要加以考虑:</p>
<ul>
<li>
<p>libgit2 的构建系统，<code>cmake</code>需要能够找到 libgit2 可选依赖 libssh2 。而我们确信我们已经构建了它(因它是一个 Cargo 依赖项)，我们只需要传递这个信息。为此，我们利用元数据格式，在构建脚本之间传递信息。在这个例子中，打印出的 libssh2 包信息是<code>cargo:root=...</code>，它来告诉我们 libssh2 安装在哪里，然后我们可以通过<code>CMAKE_PREFIX_PATH</code>环境变量让 cmkae 知道。</p>
</li>
<li>
<p>我们需要处理下，编译 C 代码时的一些<code>CFLAGS</code>值(也要告诉<code>cmake</code>关于这个信息)。我们想传递的一些标志是 64 位的<code>-m64</code>，32 位的<code>-m32</code>，或<code>-fPIC</code>也适用于 64 位。</p>
</li>
<li>
<p>最后，我们调用<code>cmake</code>将所有输出放入环境变量<code>OUT_DIR</code>目录，然后打印必要的元数据，以指导 rustc 如何链接到 libgit2。</p>
</li>
</ul>
<p>这个构建脚本的大部分功能，很容易就重构为常见的依赖项，因此我们的构建脚本不像这个描述那样长烦! 实际上，通过构建依赖项，构建脚本应该非常简单。</p>
<h2><a class="header" href="#build-script-examples" id="build-script-examples">Build Script Examples</a></h2>
<p>The following sections illustrate some examples of writing build scripts.</p>
<p>Some common build script functionality can be found via crates on <a href="https://crates.io/">crates.io</a>.
Check out the <a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code>
keyword</a> to see what is
available. The following is a sample of some popular crates<sup class="footnote-reference"><a href="#†">1</a></sup>:</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — Automatically generate Rust
FFI bindings to C libraries.</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — Compiles C/C++/assembly.</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — Detect system
libraries using the <code>pkg-config</code> utility.</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — Runs the <code>cmake</code> build tool to build a native library.</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>,
<a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>,
<a href="https://crates.io/crates/version_check"><code>version_check</code></a> — These crates
provide ways to implement conditional compilation based on the current
<code>rustc</code> such as the version of the compiler.</li>
</ul>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>This list is not an endorsement. Evaluate your dependencies to see which
is right for your project.</p>
</div>
<h3><a class="header" href="#code-generation" id="code-generation">Code generation</a></h3>
<p>Some Cargo packages need to have code generated just before they are compiled
for various reasons. Here we’ll walk through a simple example which generates a
library call as part of the build script.</p>
<p>First, let’s take a look at the directory structure of this package:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>Here we can see that we have a <code>build.rs</code> build script and our binary in
<code>main.rs</code>. This package has a basic manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-from-generated-code&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>Let’s see what’s inside the build script:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os(&quot;OUT_DIR&quot;).unwrap();
    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);
    fs::write(
        &amp;dest_path,
        &quot;pub fn message() -&gt; &amp;'static str {
            \&quot;Hello, World!\&quot;
        }
        &quot;
    ).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}
</code></pre></pre>
<p>There’s a couple of points of note here:</p>
<ul>
<li>The script uses the <code>OUT_DIR</code> environment variable to discover where the
output files should be located. It can use the process’ current working
directory to find where the input files should be located, but in this case we
don’t have any input files.</li>
<li>In general, build scripts should not modify any files outside of <code>OUT_DIR</code>.
It may seem fine on the first blush, but it does cause problems when you use
such crate as a dependency, because there's an <em>implicit</em> invariant that
sources in <code>.cargo/registry</code> should be immutable. <code>cargo</code> won't allow such
scripts when packaging.</li>
<li>This script is relatively simple as it just writes out a small generated file.
One could imagine that other more fanciful operations could take place such as
generating a Rust module from a C header file or another language definition,
for example.</li>
<li>The <a href="reference/build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> instruction</a>
tells Cargo that the build script only needs to re-run if the build script
itself changes. Without this line, Cargo will automatically run the build
script if any file in the package changes. If your code generation uses some
input files, this is where you would print a list of each of those files.</li>
</ul>
<p>Next, let’s peek at the library itself:</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));

fn main() {
    println!(&quot;{}&quot;, message());
}
</code></pre>
<p>This is where the real magic happens. The library is using the rustc-defined
<a href="reference/../../std/macro.include.html"><code>include!</code> macro</a> in combination with the
<a href="reference/../../std/macro.concat.html"><code>concat!</code></a> and <a href="reference/../../std/macro.env.html"><code>env!</code></a> macros to include the
generated file (<code>hello.rs</code>) into the crate’s compilation.</p>
<p>Using the structure shown here, crates can include any number of generated files
from the build script itself.</p>
<h3><a class="header" href="#building-a-native-library" id="building-a-native-library">Building a native library</a></h3>
<p>Sometimes it’s necessary to build some native C or C++ code as part of a
package. This is another excellent use case of leveraging the build script to
build a native library before the Rust crate itself. As an example, we’ll create
a Rust library which calls into C to print “Hello, World!”.</p>
<p>Like above, let’s first take a look at the package layout:</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>Pretty similar to before! Next, the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;hello-world-from-c&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;
</code></pre>
<p>For now we’re not going to use any build dependencies, so let’s take a look at
the build script now:</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();

    // Note that there are a number of downsides to this approach, the comments
    // below detail how to improve the portability of these commands.
    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])
                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))
                       .status().unwrap();
    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);
    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}
</code></pre></pre>
<p>This build script starts out by compiling our C file into an object file (by
invoking <code>gcc</code>) and then converting this object file into a static library (by
invoking <code>ar</code>). The final step is feedback to Cargo itself to say that our
output was in <code>out_dir</code> and the compiler should link the crate to <code>libhello.a</code>
statically via the <code>-l static=hello</code> flag.</p>
<p>Note that there are a number of drawbacks to this hard-coded approach:</p>
<ul>
<li>The <code>gcc</code> command itself is not portable across platforms. For example it’s
unlikely that Windows platforms have <code>gcc</code>, and not even all Unix platforms
may have <code>gcc</code>. The <code>ar</code> command is also in a similar situation.</li>
<li>These commands do not take cross-compilation into account. If we’re cross
compiling for a platform such as Android it’s unlikely that <code>gcc</code> will produce
an ARM executable.</li>
</ul>
<p>Not to fear, though, this is where a <code>build-dependencies</code> entry would help!
The Cargo ecosystem has a number of packages to make this sort of task much
easier, portable, and standardized. Let's try the <a href="https://crates.io/crates/cc"><code>cc</code>
crate</a> from <a href="https://crates.io/">crates.io</a>. First, add it to the
<code>build-dependencies</code> in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0&quot;
</code></pre>
<p>And rewrite the build script to use this crate:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);
    println!(&quot;cargo:rerun-if-changed=src/hello.c&quot;);
}
</code></pre>
<p>The <a href="https://crates.io/crates/cc"><code>cc</code> crate</a> abstracts a range of build script requirements for C code:</p>
<ul>
<li>It invokes the appropriate compiler (MSVC for windows, <code>gcc</code> for MinGW, <code>cc</code>
for Unix platforms, etc.).</li>
<li>It takes the <code>TARGET</code> variable into account by passing appropriate flags to
the compiler being used.</li>
<li>Other environment variables, such as <code>OPT_LEVEL</code>, <code>DEBUG</code>, etc., are all
handled automatically.</li>
<li>The stdout output and <code>OUT_DIR</code> locations are also handled by the <code>cc</code>
library.</li>
</ul>
<p>Here we can start to see some of the major benefits of farming as much
functionality as possible out to common build dependencies rather than
duplicating logic across all build scripts!</p>
<p>Back to the case study though, let’s take a quick look at the contents of the
<code>src</code> directory:</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf(&quot;Hello, World!\n&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// Note the lack of the `#[link]` attribute. We’re delegating the responsibility
// of selecting what to link over to the build script rather than hard-coding
// it in the source file.
extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}
</code></pre>
<p>And there we go! This should complete our example of building some C code from a
Cargo package using the build script itself. This also shows why using a build
dependency can be crucial in many situations and even much more concise!</p>
<p>We’ve also seen a brief example of how a build script can use a crate as a
dependency purely for the build process and not for the crate itself at runtime.</p>
<h3><a class="header" href="#linking-to-system-libraries" id="linking-to-system-libraries">Linking to system libraries</a></h3>
<p>This example demonstrates how to link a system library and how the build
script is used to support this use case.</p>
<p>Quite frequently a Rust crate wants to link to a native library provided on
the system to bind its functionality or just use it as part of an
implementation detail. This is quite a nuanced problem when it comes to
performing this in a platform-agnostic fashion. It is best, if possible, to
farm out as much of this as possible to make this as easy as possible for
consumers.</p>
<p>For this example, we will be creating a binding to the system's zlib library.
This is a library that is commonly found on most Unix-like systems that
provides data compression. This is already wrapped up in the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a>, but for this example, we'll do an extremely simplified version. Check
out <a href="https://github.com/rust-lang/libz-sys">the source code</a> for the full example.</p>
<p>To make it easy to find the location of the library, we will use the
<a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> crate</a>. This crate uses the system's <code>pkg-config</code> utility to
discover information about a library. It will automatically tell Cargo what is
needed to link the library. This will likely only work on Unix-like systems
with <code>pkg-config</code> installed. Let's start by setting up the manifest:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;libz-sys&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;
links = &quot;z&quot;

[build-dependencies]
pkg-config = &quot;0.3.16&quot;
</code></pre>
<p>Take note that we included the <code>links</code> key in the <code>package</code> table. This tells
Cargo that we are linking to the <code>libz</code> library. See <a href="reference/build-script-examples.html#using-another-sys-crate">&quot;Using another sys
crate&quot;</a> for an example that will leverage this.</p>
<p>The build script is fairly simple:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe(&quot;zlib&quot;).unwrap();
    println!(&quot;cargo:rerun-if-changed=build.rs&quot;);
}
</code></pre>
<p>Let's round out the example with a basic FFI binding:</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

extern &quot;C&quot; {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = &quot;hello&quot;;
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}
</code></pre>
<p>Run <code>cargo build -vv</code> to see the output from the build script. On a system
with <code>libz</code> already installed, it may look something like this:</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo:rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo:rustc-link-lib=z
[libz-sys 0.1.0] cargo:rerun-if-changed=build.rs
</code></pre>
<p>Nice! <code>pkg-config</code> did all the work of finding the library and telling Cargo
where it is.</p>
<p>It is not unusual for packages to include the source for the library, and
build it statically if it is not found on the system, or if a feature or
environment variable is set. For example, the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a> checks the
environment variable <code>LIBZ_SYS_STATIC</code> or the <code>static</code> feature to build it
from source instead of using the system library. Check out <a href="https://github.com/rust-lang/libz-sys">the
source</a> for a more complete example.</p>
<h3><a class="header" href="#using-another-sys-crate" id="using-another-sys-crate">Using another <code>sys</code> crate</a></h3>
<p>When using the <code>links</code> key, crates may set metadata that can be read by other
crates that depend on it. This provides a mechanism to communicate information
between crates. In this example, we'll be creating a C library that makes use
of zlib from the real <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> crate</a>.</p>
<p>If you have a C library that depends on zlib, you can leverage the <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code>
crate</a> to automatically find it or build it. This is great for cross-platform
support, such as Windows where zlib is not usually installed. <code>libz-sys</code> <a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156">sets
the <code>include</code>
metadata</a>
to tell other packages where to find the header files for zlib. Our build
script can read that metadata with the <code>DEP_Z_INCLUDE</code> environment variable.
Here's an example:</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = &quot;zuser&quot;
version = &quot;0.1.0&quot;
edition = &quot;2018&quot;

[dependencies]
libz-sys = &quot;1.0.25&quot;

[build-dependencies]
cc = &quot;1.0.46&quot;
</code></pre>
<p>Here we have included <code>libz-sys</code> which will ensure that there is only one
<code>libz</code> used in the final library, and give us access to it from our build
script:</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file(&quot;src/zuser.c&quot;);
    if let Some(include) = std::env::var_os(&quot;DEP_Z_INCLUDE&quot;) {
        cfg.include(include);
    }
    cfg.compile(&quot;zuser&quot;);
    println!(&quot;cargo:rerun-if-changed=src/zuser.c&quot;);
}
</code></pre>
<p>With <code>libz-sys</code> doing all the heavy lifting, the C source code may now include
the zlib header, and it should find the header, even on systems where it isn't
already installed.</p>
<pre><code class="language-c">// src/zuser.c

#include &quot;zlib.h&quot;

// … rest of code that makes use of zlib.
</code></pre>
<h3><a class="header" href="#conditional-compilation" id="conditional-compilation">Conditional compilation</a></h3>
<p>A build script may emit <a href="reference/build-scripts.html#rustc-cfg"><code>rustc-cfg</code> instructions</a> which can enable conditions
that can be checked at compile time. In this example, we'll take a look at how
the <a href="https://crates.io/crates/openssl"><code>openssl</code> crate</a> uses this to support multiple versions of the OpenSSL
library.</p>
<p>The <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> crate</a> implements building and linking the OpenSSL library.
It supports multiple different implementations (like LibreSSL) and multiple
versions. It makes use of the <code>links</code> key so that it may pass information to
other build scripts. One of the things it passes is the <code>version_number</code> key,
which is the version of OpenSSL that was detected. The code in the build
script looks something <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">like
this</a>:</p>
<pre><code class="language-rust ignore">println!(&quot;cargo:version_number={:x}&quot;, openssl_version);
</code></pre>
<p>This instruction causes the <code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable
to be set in any crates that directly depend on <code>openssl-sys</code>.</p>
<p>The <code>openssl</code> crate, which provides the higher-level interface, specifies
<code>openssl-sys</code> as a dependency. The <code>openssl</code> build script can read the
version information generated by the <code>openssl-sys</code> build script with the
<code>DEP_OPENSSL_VERSION_NUMBER</code> environment variable. It uses this to generate
some <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code>
values</a>:</p>
<pre><code class="language-rust ignore">// (portion of build.rs)

if let Ok(version) = env::var(&quot;DEP_OPENSSL_VERSION_NUMBER&quot;) {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl101&quot;);
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl102&quot;);
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl110&quot;);
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!(&quot;cargo:rustc-cfg=ossl110g&quot;);
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!(&quot;cargo:rustc-cfg=ossl111&quot;);
    }
}
</code></pre>
<p>These <code>cfg</code> values can then be used with the <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> or the <a href="reference/../../std/macro.cfg.html"><code>cfg</code>
macro</a> to conditionally include code. For example, SHA3 support was added in
OpenSSL 1.1.1, so it is <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">conditionally
excluded</a>
for older versions:</p>
<pre><code class="language-rust ignore">// (portion of openssl crate)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}
</code></pre>
<p>Of course, one should be careful when using this, since it makes the resulting
binary even more dependent on the build environment. In this example, if the
binary is distributed to another system, it may not have the exact same shared
libraries, which could cause problems.</p>
<h2><a class="header" href="#发布到-cratesio" id="发布到-cratesio">发布到 crates.io</a></h2>
<p>一旦你有一个你想与世界分享的 crate，就该把它发布到<a href="https://crates.io/">crates.io</a>! 发布是指，上载特定版本的，以让<a href="https://crates.io/">crates.io</a>进行托管.</p>
<p>发布箱(crate)子时，要小心，因为发布是<strong>常驻</strong>。永远不能覆盖同版本，并且无法删除代码。但是，可以发布的版本数量没有限制。</p>
<h3><a class="header" href="#在你开始发布前" id="在你开始发布前">在你开始发布前</a></h3>
<p>首先，你需要一个<a href="https://crates.io/">crates.io</a>帐户，用来获取 API 令牌。为此，<a href="https://crates.io/">访问主页</a>，并通过 GitHub 帐户登录(现在需要)。在此之后，访问你的<a href="https://crates.io/me">帐号设定</a>页面，并运行<code>cargo login</code>命令联通账号。</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>此命令将告诉 Cargo 关于您的 API 令牌，并将其存储在您的本地<code>~/.cargo/credentials</code>(以前是<code>~/.cargo/config</code>)。请注意，此令牌是一个<strong>秘密</strong>，不应与其他任何人分享。如果因任何原因泄漏，您应立即重新生成。</p>
<h3><a class="header" href="#在你创建新-crate-前" id="在你创建新-crate-前">在你创建新 crate 前</a></h3>
<p>请记住<a href="https://crates.io/">crates.io</a>上箱子的名字，会采取先到先得的方式分配。一旦获得箱子名称，它就不能用于另一个箱子.</p>
<h4><a class="header" href="#打包一个-crate" id="打包一个-crate">打包一个 crate</a></h4>
<p>下一步是，将您的包装箱打包成可供<a href="https://crates.io/">crates.io</a>上传的格式。为此，我们将使用<code>cargo package</code>子命令。这将把我们的整个包装箱全部打包成一个<code>*.crate</code>文件，其在<code>target/package</code>目录中。</p>
<pre><code class="language-console">$ cargo package
</code></pre>
<p>作为一个额外的功能，<code>*.crate</code>将独立于当前源树进行验证。在<code>*.crate</code>创建之后，会解压到<code>target/package</code>目录，然后从头开始构建，以确保构建成功的所有必要文件。可以使用<code>--no-verify</code>参数禁用此行为。</p>
<p>现在是时候看看<code>*.crate</code>文件了，为了确保您不会意外地打包 2GB 视频资源，或用于代码生成，集成测试或基准测试的大型数据文件。目前存在 10MB 的<code>*.crate</code>文件上传大小限制。所以，如果<code>tests</code>和<code>benches</code>目录及其依赖项大小，最多只达 几 MB，您仍可以将它们保存在包; 不然的话，最好排除它们。</p>
<p>在打包时，Cargo 会自动忽略版本控制系统的忽略文件，但是如果要指定要额外的忽略文件集，则可以使用清单中的<code>exclude</code>字段:</p>
<pre><code class="language-toml">[package]
# ...
exclude = [
    &quot;public/assets/*&quot;,
    &quot;videos/*&quot;,
]
</code></pre>
<p>这个数组中每个元素接受的语法是<a href="https://github.com/rust-lang/glob">rust-lang/glob</a>。如果您宁愿使用白名单，而不是黑名单,Cargo 也支持<code>include</code>字段，如果设置,则会覆盖<code>exclude</code>字段:</p>
<pre><code class="language-toml">[package]
# ...
include = [
    &quot;**/*.rs&quot;,
    &quot;Cargo.toml&quot;,
]
</code></pre>
<h3><a class="header" href="#上传该-crate" id="上传该-crate">上传该 crate</a></h3>
<p>现在我们已经有了<code>*.crate</code>文件准备好了，可以上传到<a href="https://crates.io/">crates.io</a>，接着使用<code>cargo publish</code>命令就好。就是这样，你现在已经发布了你的第一个箱子!</p>
<pre><code class="language-console">$ cargo publish
</code></pre>
<p>如果你想跳过<code>cargo package</code>那一步，<code>cargo publish</code>如果找不到副本，子命令将自动打包本地包.</p>
<p>一定要看看<a href="reference/./manifest.html#package-metadata">您可以指定的元数据</a>确保您的箱子更容易被发现!</p>
<h3><a class="header" href="#为已存在的-crate发布一个新版本" id="为已存在的-crate发布一个新版本">为已存在的 crate，发布一个新版本</a></h3>
<p>要发布新版本，请在<code>Cargo.toml</code>更改<code>version</code>为您指定的值。记住<a href="reference/./manifest.html#the-version-field">semver 规则</a>。然后可选择运行<code>cargo package</code>，如果你想检查一下<code>*.crate</code>发布前的新版本文件，然后运行<code>cargo publish</code>上传新版本.</p>
<h3><a class="header" href="#管理一个-基于-cratesio-的-crate" id="管理一个-基于-cratesio-的-crate">管理一个 基于 crates.io 的 crate</a></h3>
<p>箱的管理主要通过命令行完成<code>cargo</code>工具，而不是<a href="https://crates.io/">crates.io</a>网络界面。为此，有一些子命令来管理包.</p>
<h4><a class="header" href="#cargo-yank" id="cargo-yank"><code>cargo yank</code></a></h4>
<p>在您发布时，实际上可能会因某种原因，而最终破坏的箱子版本(语法错误，忘记包含文件等)的情况。对于诸如此类的情况，Cargo 支持一个箱子版本的&quot;yank&quot;。</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>一个 yank <strong>不是</strong>删除任何代码。例如，此功能不用于删除意外上传的机密。如果发生这种情况，您必须立即重置这些秘密.</p>
<p>一个 yank 版本的语义是，不为该版本创建新的依赖项，但所有现有的依赖项继续有效。<a href="https://crates.io/">crates.io</a>其中一个主要目标是作为永久存档的箱子库，不会随着时间的推移而改变，而允许删除版本将违背这一目标。所以基本上，一个 yank 意味着所有包的<code>Cargo.lock</code>不会被破坏，在任何的未来，<code>Cargo.lock</code>生成的文件不会列出 yank 的版本。(成为了一个孤岛版本)</p>
<h4><a class="header" href="#cargo-owner" id="cargo-owner"><code>cargo owner</code></a></h4>
<p>箱子通常由不止一个人开发，或者主要维护者可能会随着时间而改变!箱子的所有者是唯一允许发布新版本箱子的人，但是所有者可以指定其他所有者。</p>
<pre><code class="language-console">$ cargo owner --add my-buddy
$ cargo owner --remove my-buddy
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
</code></pre>
<p>给这些命令的所有者 ID 必须是 GitHub 用户名或 GitHub 团队.</p>
<p>如果用<code>--add</code>了一个用户名，那该用户成为&quot;命名&quot;所有者，拥有该箱子的完全权利。除了能够发布或 yank 箱子的版本，他们还能够添加或删除所有者，<em>包含</em>任命<em>他们</em>的所有者。毋庸置疑，你不应该让那些你不完全信任的人，作命名所有者。要成为命名所有者，用户必须之前就已登录<a href="https://crates.io/">crates.io</a>。</p>
<p>如果用<code>--add</code>了一个团队，那该团队成为&quot;团队&quot;所有者，对箱的权利受到限制。虽然他们有权发布或 yank 箱子的版本，但他们<em>不</em>能够添加或删除所有者。除了更方便管理所有者群体之外，团队还可以更安全地防止恶意所有者。</p>
<p>团队的目前的语法是<code>github:org:team</code>(见上面的例子)。要将团队添加为所有者，必须是该团队的成员。删除所有者的团队就没有此类限制.</p>
<h3><a class="header" href="#github-权限" id="github-权限">GitHub 权限</a></h3>
<p>团队成员资格，不是 GitHub 提供的简单公共访问权限，并且在使用它时可能会遇到以下消息:</p>
<blockquote>
<p>您似乎无权从 GitHub 查询必要的属性，来完成此请求。您可能需要在<a href="https://crates.io/">crates.io</a>重新进行身份验证，并申请阅读 GitHub 组织成员资格的权限。去<a href="https://crates.io/login">https://crates.io/login</a>看看</p>
</blockquote>
<p>这基本上是一个全查询防御，当&quot;你试图查询团队信息，而其中的五级成员访问控制，拒绝了它&quot;。这并不夸张。GitHub 对团队访问控制的支持是企业级.</p>
<p>最可能的原因是您最后一次登录是在添加此功能之前。我们最初<em>没有</em>要求 GitHub 对用户进行身份验证时的权限，因为我们实际上并没有将用户的令牌用于登录以外的任何其他内容。但是，为了代表您能够查询团队成员资格，我们现在需要<a href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/"><code>read:org</code>范围权限</a>。</p>
<p>您完全可以拒绝我们这个范围，且在团队介绍之前所做的一切，都将继续有效。但是，您永远无法将团队添加为所有者，或者将团队作为团队所有者发布。如果您尝试这样做，您将收到上述错误。如果你试图发布一个你根本不拥有的箱子，但恰好有一个团队，你可能也会看到这个错误。</p>
<p>如果你改变主意，或者只是不确定是否<a href="https://crates.io/">crates.io</a>有足够的许可，你可以随时去<a href="https://crates.io/login">https://crates.io/login</a>查看，<a href="https://crates.io/">crates.io</a>会提示您，它没有获得它想要的所有范围许可。</p>
<p>查询 GitHub 的另一个障碍，是组织可能会主动拒绝第三方访问。要检查这一点，您可以访问:</p>
<pre><code>https://github.com/organizations/:org/settings/oauth_application_policy
</code></pre>
<p>这里的<code>:org</code>是组织的名称(例如 rust-lang)。你可能会看到类似的东西:</p>
<p><img src="reference/../images/org-level-acl.png" alt="Organization Access Control" /></p>
<p>你可以选择，从您组织的黑名单中，明确删除<a href="https://crates.io/">crates.io</a>，或只需按&quot;删除限制(Remove Restrictions)&quot;按钮，允许所有第三方应用程序访问此数据。</p>
<p>或者，当<a href="https://crates.io/">crates.io</a>请求了<code>read:org</code>范围，您可以明确进入白名单的<a href="https://crates.io/">crates.io</a>，能查询组织的问题，通过按其名称旁边的&quot;授予访问权限(Grant Access)&quot;按钮:</p>
<p><img src="reference/../images/auth-level-acl.png" alt="Authentication Access Control" /></p>
<h2><a class="header" href="#package-id-specifications" id="package-id-specifications">Package ID Specifications</a></h2>
<h3><a class="header" href="#package-id-specifications-1" id="package-id-specifications-1">Package ID specifications</a></h3>
<p>包 ID 规范</p>
<p>Cargo 的子命令经常需要引用依赖关系图中的特定包来进行各种操作，例如更新，清理，构建等。为了解决这个问题，Cargo 支持包 ID 规范。规范是一个字符串，用于唯一地引用依赖关系图中的一个包.</p>
<h4><a class="header" href="#specification-grammar" id="specification-grammar">Specification grammar</a></h4>
<p>规范语法</p>
<p>包 ID 规范的形式语法是:</p>
<pre><code class="language-notrust">pkgid := pkgname
       | [ proto &quot;://&quot; ] hostname-and-path [ &quot;#&quot; ( pkgname | semver ) ]
pkgname := name [ &quot;:&quot; semver ]

proto := &quot;http&quot; | &quot;git&quot; | ...
</code></pre>
<p>这里，括号表示内容是可选的.</p>
<h4><a class="header" href="#example-specifications" id="example-specifications">Example specifications</a></h4>
<p>规范示例</p>
<p>这些都可以是对<code>foo</code>包的引用，版本<code>1.2.3</code>，来自注册表<code>crates.io</code></p>
<table><thead><tr><th align="left">pkgid</th><th align="center">名称</th><th align="center">版本</th><th align="center">网址</th></tr></thead><tbody>
<tr><td align="left"><code>foo</code></td><td align="center"><code>foo</code></td><td align="center"><code>*</code></td><td align="center"><code>*</code></td></tr>
<tr><td align="left"><code>foo:1.2.3</code></td><td align="center"><code>foo</code></td><td align="center"><code>1.2.3</code></td><td align="center"><code>*</code></td></tr>
<tr><td align="left"><code>crates.io/foo</code></td><td align="center"><code>foo</code></td><td align="center"><code>*</code></td><td align="center"><code>*://crates.io/foo</code></td></tr>
<tr><td align="left"><code>crates.io/foo#1.2.3</code></td><td align="center"><code>foo</code></td><td align="center"><code>1.2.3</code></td><td align="center"><code>*://crates.io/foo</code></td></tr>
<tr><td align="left"><code>crates.io/bar#foo:1.2.3</code></td><td align="center"><code>foo</code></td><td align="center"><code>1.2.3</code></td><td align="center"><code>*://crates.io/bar</code></td></tr>
<tr><td align="left"><code>http://crates.io/foo#1.2.3</code></td><td align="center"><code>foo</code></td><td align="center"><code>1.2.3</code></td><td align="center"><code>http://crates.io/foo</code></td></tr>
</tbody></table>
<h4><a class="header" href="#brevity-of-specifications" id="brevity-of-specifications">Brevity of specifications</a></h4>
<p>规范的简洁</p>
<p>这样做的目的是用简洁和详尽的语法来引用依赖图中的包。而不明确的引用可以指代一个或多个包。若使用相同的规范会引用多个包，那大多数命令都会生成错误。</p>
<h2><a class="header" href="#来源-更换" id="来源-更换">来源 更换</a></h2>
<p>本文档是关于更换 crate 索引(注册表)。您可以阅读有关重写依赖项的信息，它在本文档的<a href="reference/reference/specifying-dependencies.html#overriding-dependencies">重写依赖关系</a>部分。</p>
<p>Cargo 支持<strong>用另一个来源更换一个来源</strong>的能力，可根据镜像或 vendoring 依赖关系来表达倾向。要配置这些，目前通过<a href="reference/reference/config.html"><code>.cargo/config</code>配置</a>机制完成，像这样:</p>
<pre><code class="language-toml"># `source` 表下，就是存储有关要更换的来源名称
[source]

# 在`source` 表格之下的，可为一定数量的有关来源名称. 示例下面就# 定义了一个新源， 叫 `my-awesome-source`， 其内容来自本地 # `vendor`目录 ，其相对于包含`.cargo/config`文件的目录
[source.my-awesome-source]
directory = &quot;vendor&quot;

# Git sources 也指定一个 branch/tag/rev
git = &quot;https://example.com/path/to/repo&quot;
# branch = &quot;master&quot;
# tag = &quot;v1.0.1&quot;
# rev = &quot;313f44e8&quot;

# The crates.io 默认源 在&quot;crates-io&quot;名称下， 且在这里我们使用 `replace-with` 字段指明 默认源更换成&quot;my-awesome-source&quot;源
[source.crates-io]
replace-with = &quot;my-awesome-source&quot;
</code></pre>
<p>使用此配置，Cargo 会尝试在&quot;vendor&quot;目录中，查找所有包，而不是 查询在线注册表 crates.io 。Cargo 有两种来源更换的表达 :</p>
<ul>
<li>
<p>供应(Vendoring) - 可以定义自定义源，它们表示本地文件系统上的包。这些源是它们正在更换的源的子集，并在需要时可以检入包中。</p>
</li>
<li>
<p>镜像(Mirroring) - 可以更换为等效版本的源，行为表现为 crates.io 本身的缓存。</p>
</li>
</ul>
<p>Cargo 有一个关于来源更换的核心假设，源代码从两个完全相同的源而来。在上面的例子中，Cargo 假设所有的箱子都来自<code>my-awesome-source</code>，与<code>crates-io</code>副本完全相同。请注意，这也意味着<code>my-awesome-source</code>，不允许有<code>crates-io</code>源不存在的箱。</p>
<p>因此，来源更换不适用于依赖项补丁(fix bug)，或私有注册表等情况。Cargo 是通过使用<a href="reference/reference/manifest.html#the-replace-section"><code>[replace]</code>字段</a>支持依赖项补丁，计划为未来版本的 Cargo 提供私人注册表的支持。</p>
<h3><a class="header" href="#配置-1" id="配置-1">配置</a></h3>
<p>更换源的配置通过完成<a href="reference/reference/config.html"><code>.cargo/config</code></a>，下面为全套可用字段是:</p>
<pre><code class="language-toml"># 每个源都有自己的表格，名称即是表名
[source.the-source-name]

# 命令 ，`the-source-name` 会被`another-source`取代
replace-with = &quot;another-source&quot;

# 有几种可用的源定义(接下来有所描述)
registry = &quot;https://example.com/path/to/index&quot;
local-registry = &quot;path/to/registry&quot;
directory = &quot;path/to/vendor&quot;
</code></pre>
<p><code>crates-io</code>代表 crates.io 在线注册表(箱的默认来源)，可以更换为:</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'another-source'
</code></pre>
<h3><a class="header" href="#注册表源" id="注册表源">注册表源</a></h3>
<p>&quot;注册表源&quot;与 crates.io 本身相同。也就是说，它也有一个在 git 存储库中提供的索引，该存储库匹配<a href="https://github.com/rust-lang/crates.io-index">crates.io index</a>的格式。然后该存储库具有指示从哪里下载包的配置。</p>
<p>目前还没有一个已经设置 crates.io 的镜像的可用项目。请继续关注!</p>
<blockquote>
<p>中国用户，可搜索 'rust 换 中科大 源'</p>
</blockquote>
<h3><a class="header" href="#本地-注册表源" id="本地-注册表源">本地 注册表源</a></h3>
<p>&quot;本地注册表源&quot;旨在成为另一个注册表源的子集，但可在本地文件系统(也称为 vendoring)上使用。本地注册表是提前下载，通常与一个 <code>Cargo.lock</code>同步，并由一组<code>*.crate</code>文件和像普通注册表一样的索引组成。</p>
<p>管理和创建本地注册表源的主要方法是通过<a href="https://crates.io/crates/cargo-local-registry"><code>cargo-local-registry</code></a>子命令，可在 crates.io 上找到，并用<code>cargo install cargo-local-registry</code>安装。</p>
<p>本地注册表包含在一个目录，其中包含许多从 crates.io 下载的<code>*.crate</code>文件，以及<code>index</code>目录，它与 crates.io-index 项目目录具有相同格式(仅填充有存在的 crates).</p>
<h3><a class="header" href="#目录-源" id="目录-源">目录 源</a></h3>
<p>&quot;目录源&quot;类似于本地注册表源，其中包含本地文件系统上许多的可用包，适用于 vendoring 依赖项。与本地注册表一样，目录源主要由外部子命令管理<a href="https://crates.io/crates/cargo-vendor"><code>cargo-vendor</code></a>，可用<code>cargo install cargo-vendor</code>安装。</p>
<p>目录源与本地注册表不同，但它们包含<code>*.crate</code>文件的解压缩版本，使其在某些情况下，更适合检查所有内容到源代码控制工具。目录源只是一个包含许多其他目录的目录，其中包含 crates 的源代码(解压缩版本的<code>*.crate</code>文件)。目前，对每个目录的名称没有限制。</p>
<p>目录源中的每个包也有一个关联的元数据文件，指示包中每个文件的校验和，以防止意外修改。</p>
<h2><a class="header" href="#external-tools" id="external-tools">External tools</a></h2>
<p>外部工具</p>
<p>Cargo 的目标之一是与第三方工具(如 IDE 和其他构建系统)的简单集成。为了简化集成，Cargo 有几个设施:</p>
<ul>
<li>
<p>一个<code>cargo metadata</code>命令，以 JSON 格式输出包结构和依赖关系信息，</p>
</li>
<li>
<p>一个<code>--message-format</code>标志，输出有关特定构建的信息，以及</p>
</li>
<li>
<p>支持自定义子命令.</p>
</li>
</ul>
<h3><a class="header" href="#information-about-package-structure" id="information-about-package-structure">Information about package structure</a></h3>
<p>包结构的资料</p>
<p>您可以使用<code>cargo metadata</code>命令，以获取有关包结构和依赖关系的信息。命令的输出如下所示:</p>
<pre><code class="language-text">{
  // Integer 版本格式数字.
  &quot;version&quot;: integer,

  // 工作区包的列表, 包括 依赖项.
  &quot;packages&quot;: [
    {
      // 包 识别id 队列.
      &quot;id&quot;: PackageId,

      &quot;name&quot;: string,

      &quot;version&quot;: string,

      &quot;source&quot;: SourceId,

      // 确认依赖的一个列表, 可看 `resolve` 字段中的真实依赖.
      &quot;dependencies&quot;: [ Dependency ],

      &quot;targets: [ Target ],

      //  Cargo.toml 路径
      &quot;manifest_path&quot;: string,
    }
  ],

  &quot;workspace_members&quot;: [ PackageId ],

  // 依赖 关系图.
  &quot;resolve&quot;: {
     &quot;nodes&quot;: [
       {
         &quot;id&quot;: PackageId,
         &quot;dependencies&quot;: [ PackageId ]
       }
     ]
  }
}
</code></pre>
<p>格式稳定且有版本化。调用<code>cargo metadata</code>时，你应该通过<code>--format-version</code>明确标记，以避免向前不兼容的危险。</p>
<p>如果你正在使用 Rust，这有个<a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a>箱.</p>
<h3><a class="header" href="#information-about-build" id="information-about-build">Information about build</a></h3>
<p>关于构建的资料</p>
<p>传递<code>--message-format=json</code>给，Cargo， 将在构建期间输出以下信息:</p>
<ul>
<li>
<p>编译器错误和警告，</p>
</li>
<li>
<p>制作的工件，</p>
</li>
<li>
<p>构建脚本的结果(例如，本机依赖项).</p>
</li>
</ul>
<p>输出以每行格式的 JSON 对象转到 stdout。<code>reason</code>字段区分不同类型的消息.</p>
<p>有关 Makefile 兼容格式的依赖关系的信息存储在工件旁的<code>.d</code>文件中。</p>
<h3><a class="header" href="#custom-subcommands" id="custom-subcommands">Custom subcommands</a></h3>
<p>自定义的子命令</p>
<p>Cargo 设计为，可以使用新的子命令进行扩展，而无需修改 Cargo 本身。这是通过转化一个 cargo <code>(?&lt;command&gt;[^ ]+)</code>的命令调用，变化为调用外部工具<code>cargo-${command}</code>来实现的。外部工具必须存在于用户其中一个<code>$PATH</code>目录中.</p>
<p>当 Cargo 调用自定义子命令时，子命令的第一个参数将像往常一样是自定义子命令的文件名。第二个参数将是子命令名称本身。例如，在调用<code>cargo-${command}</code>时，第二个参数是<code>${command}</code>。命令行上的其他所有参数将保持不变.</p>
<p>Cargo 还可以用<code>cargo help ${command}</code>显示自定义子命令的帮助输出。Cargo 假定子命令将在第三个参数出现时，打印帮助消息<code>--help</code>.所以，<code>cargo help ${command}</code>会调用<code>cargo-${command} ${command} --help</code>.</p>
<p>自定义子命令可以使用<code>CARGO</code>环境变量回调 Cargo。或者，它可以链接到作为一个库的<code>cargo</code>箱，但这种方法有缺点:</p>
<ul>
<li>
<p>Cargo 作为库是不稳定的:API 可能会更改，但不会弃用</p>
</li>
<li>
<p>链接的 Cargo 库的版本可能与 Cargo 二进制文件不同</p>
</li>
</ul>
<h2><a class="header" href="#registries" id="registries">Registries</a></h2>
<p>Cargo installs crates and fetches dependencies from a &quot;registry&quot;. The default
registry is <a href="https://crates.io/">crates.io</a>. A registry contains an &quot;index&quot; which contains a
searchable list of available crates. A registry may also provide a web API to
support publishing new crates directly from Cargo.</p>
<blockquote>
<p>Note: If you are interested in mirroring or vendoring an existing registry,
take a look at <a href="reference/source-replacement.html">Source Replacement</a>.</p>
</blockquote>
<h3><a class="header" href="#using-an-alternate-registry" id="using-an-alternate-registry">Using an Alternate Registry</a></h3>
<p>To use a registry other than <a href="https://crates.io/">crates.io</a>, the name and index URL of the
registry must be added to a <a href="reference/config.html"><code>.cargo/config.toml</code> file</a>. The <code>registries</code>
table has a key for each registry, for example:</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:8080/git/index&quot; }
</code></pre>
<p>The <code>index</code> key should be a URL to a git repository with the registry's index.
A crate can then depend on a crate from another registry by specifying the
<code>registry</code> key and a value of the registry's name in that dependency's entry
in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># Sample Cargo.toml
[package]
name = &quot;my-project&quot;
version = &quot;0.1.0&quot;

[dependencies]
other-crate = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot; }
</code></pre>
<p>As with most config values, the index may be specified with an environment
variable instead of a config file. For example, setting the following
environment variable will accomplish the same thing as defining a config file:</p>
<pre><code class="language-ignore">CARGO_REGISTRIES_MY_REGISTRY_INDEX=https://my-intranet:8080/git/index
</code></pre>
<blockquote>
<p>Note: <a href="https://crates.io/">crates.io</a> does not accept packages that depend on crates from other
registries.</p>
</blockquote>
<h3><a class="header" href="#publishing-to-an-alternate-registry" id="publishing-to-an-alternate-registry">Publishing to an Alternate Registry</a></h3>
<p>If the registry supports web API access, then packages can be published
directly to the registry from Cargo. Several of Cargo's commands such as
<a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> take a <code>--registry</code> command-line flag to indicate which
registry to use. For example, to publish the package in the current directory:</p>
<ol>
<li>
<p><code>cargo login --registry=my-registry</code></p>
<p>This only needs to be done once. You must enter the secret API token
retrieved from the registry's website. Alternatively the token may be
passed directly to the <code>publish</code> command with the <code>--token</code> command-line
flag or an environment variable with the name of the registry such as
<code>CARGO_REGISTRIES_MY_REGISTRY_TOKEN</code>.</p>
</li>
<li>
<p><code>cargo publish --registry=my-registry</code></p>
</li>
</ol>
<p>Instead of always passing the <code>--registry</code> command-line option, the default
registry may be set in <a href="reference/config.html"><code>.cargo/config.toml</code></a> with the <code>registry.default</code>
key.</p>
<p>Setting the <code>package.publish</code> key in the <code>Cargo.toml</code> manifest restricts which
registries the package is allowed to be published to. This is useful to
prevent accidentally publishing a closed-source package to <a href="https://crates.io/">crates.io</a>. The
value may be a list of registry names, for example:</p>
<pre><code class="language-toml">[package]
# ...
publish = [&quot;my-registry&quot;]
</code></pre>
<p>The <code>publish</code> value may also be <code>false</code> to restrict all publishing, which is
the same as an empty list.</p>
<p>The authentication information saved by <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> is stored in the
<code>credentials.toml</code> file in the Cargo home directory (default <code>$HOME/.cargo</code>). It
has a separate table for each registry, for example:</p>
<pre><code class="language-toml">[registries.my-registry]
token = &quot;854DvwSlUwEHtIo3kWy6x7UCPKHfzCmy&quot;
</code></pre>
<h3><a class="header" href="#running-a-registry" id="running-a-registry">Running a Registry</a></h3>
<p>A minimal registry can be implemented by having a git repository that contains
an index, and a server that contains the compressed <code>.crate</code> files created by
<a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>. Users won't be able to use Cargo to publish to it, but this
may be sufficient for closed environments.</p>
<p>A full-featured registry that supports publishing will additionally need to
have a web API service that conforms to the API used by Cargo. The web API is
documented below.</p>
<p>At this time, there is no widely used software for running a custom registry.
There is interest in documenting projects that implement registry support, or
existing package caches that add support for Cargo.</p>
<h3><a class="header" href="#index-format" id="index-format">Index Format</a></h3>
<p>The following defines the format of the index. New features are occasionally
added, which are only understood starting with the version of Cargo that
introduced them. Older versions of Cargo may not be able to use packages that
make use of new features. However, the format for older packages should not
change, so older versions of Cargo should be able to use them.</p>
<p>The index is stored in a git repository so that Cargo can efficiently fetch
incremental updates to the index. In the root of the repository is a file
named <code>config.json</code> which contains JSON information used by Cargo for
accessing the registry. This is an example of what the <a href="https://crates.io/">crates.io</a> config file
looks like:</p>
<pre><code class="language-javascript">{
    &quot;dl&quot;: &quot;https://crates.io/api/v1/crates&quot;,
    &quot;api&quot;: &quot;https://crates.io&quot;
}
</code></pre>
<p>The keys are:</p>
<ul>
<li>
<p><code>dl</code>: This is the URL for downloading crates listed in the index. The value
may have the following markers which will be replaced with their
corresponding value:</p>
<ul>
<li><code>{crate}</code>: The name of crate.</li>
<li><code>{version}</code>: The crate version.</li>
<li><code>{prefix}</code>: A directory prefix computed from the crate name. For example,
a crate named <code>cargo</code> has a prefix of <code>ca/rg</code>. See below for details.</li>
<li><code>{lowerprefix}</code>: Lowercase variant of <code>{prefix}</code>.</li>
</ul>
<p>If none of the markers are present, then the value
<code>/{crate}/{version}/download</code> is appended to the end.</p>
</li>
<li>
<p><code>api</code>: This is the base URL for the web API. This key is optional, but if it
is not specified, commands such as <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> will not work. The web
API is described below.</p>
</li>
</ul>
<p>The download endpoint should send the <code>.crate</code> file for the requested package.
Cargo supports https, http, and file URLs, HTTP redirects, HTTP1 and HTTP2.
The exact specifics of TLS support depend on the platform that Cargo is
running on, the version of Cargo, and how it was compiled.</p>
<p>The rest of the index repository contains one file for each package, where the
filename is the name of the package in lowercase. Each version of the package
has a separate line in the file. The files are organized in a tier of
directories:</p>
<ul>
<li>Packages with 1 character names are placed in a directory named <code>1</code>.</li>
<li>Packages with 2 character names are placed in a directory named <code>2</code>.</li>
<li>Packages with 3 character names are placed in the directory
<code>3/{first-character}</code> where <code>{first-character}</code> is the first character of
the package name.</li>
<li>All other packages are stored in directories named
<code>{first-two}/{second-two}</code> where the top directory is the first two
characters of the package name, and the next subdirectory is the third and
fourth characters of the package name. For example, <code>cargo</code> would be stored
in a file named <code>ca/rg/cargo</code>.</li>
</ul>
<blockquote>
<p>Note: Although the index filenames are in lowercase, the fields that contain
package names in <code>Cargo.toml</code> and the index JSON data are case-sensitive and
may contain upper and lower case characters.</p>
</blockquote>
<p>The directory name above is calculated based on the package name converted to
lowercase; it is represented by the marker <code>{lowerprefix}</code>.  When the original
package name is used without case conversion, the resulting directory name is
represented by the marker <code>{prefix}</code>.  For example, the package <code>MyCrate</code> would
have a <code>{prefix}</code> of <code>My/Cr</code> and a <code>{lowerprefix}</code> of <code>my/cr</code>.  In general,
using <code>{prefix}</code> is recommended over <code>{lowerprefix}</code>, but there are pros and
cons to each choice.  Using <code>{prefix}</code> on case-insensitive filesystems results
in (harmless-but-inelegant) directory aliasing.  For example, <code>crate</code> and
<code>CrateTwo</code> have <code>{prefix}</code> values of <code>cr/at</code> and <code>Cr/at</code>; these are distinct on
Unix machines but alias to the same directory on Windows.  Using directories
with normalized case avoids aliasing, but on case-sensitive filesystems it's
harder to support older versions of Cargo that lack <code>{prefix}</code>/<code>{lowerprefix}</code>.
For example, nginx rewrite rules can easily construct <code>{prefix}</code> but can't
perform case-conversion to construct <code>{lowerprefix}</code>.</p>
<p>Registries should consider enforcing limitations on package names added to
their index. Cargo itself allows names with any <a href="reference/../../std/primitive.char.html#method.is_alphanumeric">alphanumeric</a>, <code>-</code>, or <code>_</code>
characters. <a href="https://crates.io/">crates.io</a> imposes its own limitations, including the following:</p>
<ul>
<li>Only allows ASCII characters.</li>
<li>Only alphanumeric, <code>-</code>, and <code>_</code> characters.</li>
<li>First character must be alphabetic.</li>
<li>Case-insensitive collision detection.</li>
<li>Prevent differences of <code>-</code> vs <code>_</code>.</li>
<li>Under a specific length (max 64).</li>
<li>Rejects reserved names, such as Windows special filenames like &quot;nul&quot;.</li>
</ul>
<p>Registries should consider incorporating similar restrictions, and consider
the security implications, such as <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">IDN homograph
attacks</a> and other
concerns in <a href="https://www.unicode.org/reports/tr36/">UTR36</a> and
<a href="https://www.unicode.org/reports/tr39/">UTS39</a>.</p>
<p>Each line in a package file contains a JSON object that describes a published
version of the package. The following is a pretty-printed example with comments
explaining the format of the entry.</p>
<pre><code class="language-javascript">{
    // The name of the package.
    // This must only contain alphanumeric, `-`, or `_` characters.
    &quot;name&quot;: &quot;foo&quot;,
    // The version of the package this row is describing.
    // This must be a valid version number according to the Semantic
    // Versioning 2.0.0 spec at https://semver.org/.
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // Array of direct dependencies of the package.
    &quot;deps&quot;: [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the new name. The original package name is stored in
            // the `package` field.
            &quot;name&quot;: &quot;rand&quot;,
            // The semver requirement for this dependency.
            // This must be a valid version requirement defined at
            // https://github.com/steveklabnik/semver#requirements.
            &quot;req&quot;: &quot;^0.6&quot;,
            // Array of features (as strings) enabled for this dependency.
            &quot;features&quot;: [&quot;i128_support&quot;],
            // Boolean of whether or not this is an optional dependency.
            &quot;optional&quot;: false,
            // Boolean of whether or not default features are enabled.
            &quot;default_features&quot;: true,
            // The target platform for the dependency.
            // null if not a target dependency.
            // Otherwise, a string such as &quot;cfg(windows)&quot;.
            &quot;target&quot;: null,
            // The dependency kind.
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            // Note: this is a required field, but a small number of entries
            // exist in the crates.io index with either a missing or null
            // `kind` field due to implementation bugs.
            &quot;kind&quot;: &quot;normal&quot;,
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or null, it is assumed the
            // dependency is in the current registry.
            &quot;registry&quot;: null,
            // If the dependency is renamed, this is a string of the actual
            // package name. If not specified or null, this dependency is not
            // renamed.
            &quot;package&quot;: null,
        }
    ],
    // A SHA256 checksum of the `.crate` file.
    &quot;cksum&quot;: &quot;d867001db0e2b6e0496f9fac96930e2d42233ecd3ca0413e0753d4c7695d289c&quot;,
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // Boolean of whether or not this version has been yanked.
    &quot;yanked&quot;: false,
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    &quot;links&quot;: null
}
</code></pre>
<p>The JSON objects should not be modified after they are added except for the
<code>yanked</code> field whose value may change at any time.</p>
<h3><a class="header" href="#web-api" id="web-api">Web API</a></h3>
<p>A registry may host a web API at the location defined in <code>config.json</code> to
support any of the actions listed below.</p>
<p>Cargo includes the <code>Authorization</code> header for requests that require
authentication. The header value is the API token. The server should respond
with a 403 response code if the token is not valid. Users are expected to
visit the registry's website to obtain a token, and Cargo can store the token
using the <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> command, or by passing the token on the
command-line.</p>
<p>Responses use a 200 response code for both success and errors. Cargo looks at
the JSON response to determine if there was success or failure. Failure
responses have a JSON object with the following structure:</p>
<pre><code class="language-javascript">{
    // Array of errors to display to the user.
    &quot;errors&quot;: [
        {
            // The error message as a string.
            &quot;detail&quot;: &quot;error message text&quot;
        }
    ]
}
</code></pre>
<p>Servers may also respond with a 404 response code to indicate the requested
resource is not found (for example, an unknown crate name). However, using a
200 response with an <code>errors</code> object allows a registry to provide a more
detailed error message if desired.</p>
<p>For backwards compatibility, servers should ignore any unexpected query
parameters or JSON fields. If a JSON field is missing, it should be assumed to
be null. The endpoints are versioned with the <code>v1</code> component of the path, and
Cargo is responsible for handling backwards compatibility fallbacks should any
be required in the future.</p>
<p>Cargo sets the following headers for all requests:</p>
<ul>
<li><code>Content-Type</code>: <code>application/json</code></li>
<li><code>Accept</code>: <code>application/json</code></li>
<li><code>User-Agent</code>: The Cargo version such as <code>cargo 1.32.0 (8610973aa 2019-01-02)</code>. This may be modified by the user in a configuration value.
Added in 1.29.</li>
</ul>
<h4><a class="header" href="#publish" id="publish">Publish</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/new</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>The publish endpoint is used to publish a new version of a crate. The server
should validate the crate, make it available for download, and add it to the
index.</p>
<p>The body of the data sent by Cargo is:</p>
<ul>
<li>32-bit unsigned little-endian integer of the length of JSON data.</li>
<li>Metadata of the package as a JSON object.</li>
<li>32-bit unsigned little-endian integer of the length of the <code>.crate</code> file.</li>
<li>The <code>.crate</code> file.</li>
</ul>
<p>The following is a commented example of the JSON object. Some notes of some
restrictions imposed by <a href="https://crates.io/">crates.io</a> are included only to illustrate some
suggestions on types of validation that may be done, and should not be
considered as an exhaustive list of restrictions <a href="https://crates.io/">crates.io</a> imposes.</p>
<pre><code class="language-javascript">{
    // The name of the package.
    &quot;name&quot;: &quot;foo&quot;,
    // The version of the package being published.
    &quot;vers&quot;: &quot;0.1.0&quot;,
    // Array of direct dependencies of the package.
    &quot;deps&quot;: [
        {
            // Name of the dependency.
            // If the dependency is renamed from the original package name,
            // this is the original name. The new package name is stored in
            // the `explicit_name_in_toml` field.
            &quot;name&quot;: &quot;rand&quot;,
            // The semver requirement for this dependency.
            &quot;version_req&quot;: &quot;^0.6&quot;,
            // Array of features (as strings) enabled for this dependency.
            &quot;features&quot;: [&quot;i128_support&quot;],
            // Boolean of whether or not this is an optional dependency.
            &quot;optional&quot;: false,
            // Boolean of whether or not default features are enabled.
            &quot;default_features&quot;: true,
            // The target platform for the dependency.
            // null if not a target dependency.
            // Otherwise, a string such as &quot;cfg(windows)&quot;.
            &quot;target&quot;: null,
            // The dependency kind.
            // &quot;dev&quot;, &quot;build&quot;, or &quot;normal&quot;.
            &quot;kind&quot;: &quot;normal&quot;,
            // The URL of the index of the registry where this dependency is
            // from as a string. If not specified or null, it is assumed the
            // dependency is in the current registry.
            &quot;registry&quot;: null,
            // If the dependency is renamed, this is a string of the new
            // package name. If not specified or null, this dependency is not
            // renamed.
            &quot;explicit_name_in_toml&quot;: null,
        }
    ],
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    // Cargo does not impose limitations on feature names, but crates.io
    // requires alphanumeric ASCII, `_` or `-` characters.
    &quot;features&quot;: {
        &quot;extras&quot;: [&quot;rand/simd_support&quot;]
    },
    // List of strings of the authors.
    // May be empty.
    &quot;authors&quot;: [&quot;Alice &lt;a@example.com&gt;&quot;],
    // Description field from the manifest.
    // May be null. crates.io requires at least some content.
    &quot;description&quot;: null,
    // String of the URL to the website for this package's documentation.
    // May be null.
    &quot;documentation&quot;: null,
    // String of the URL to the website for this package's home page.
    // May be null.
    &quot;homepage&quot;: null,
    // String of the content of the README file.
    // May be null.
    &quot;readme&quot;: null,
    // String of a relative path to a README file in the crate.
    // May be null.
    &quot;readme_file&quot;: null,
    // Array of strings of keywords for the package.
    &quot;keywords&quot;: [],
    // Array of strings of categories for the package.
    &quot;categories&quot;: [],
    // String of the license for the package.
    // May be null. crates.io requires either `license` or `license_file` to be set.
    &quot;license&quot;: null,
    // String of a relative path to a license file in the crate.
    // May be null.
    &quot;license_file&quot;: null,
    // String of the URL to the website for the source repository of this package.
    // May be null.
    &quot;repository&quot;: null,
    // Optional object of &quot;status&quot; badges. Each value is an object of
    // arbitrary string to string mappings.
    // crates.io has special interpretation of the format of the badges.
    &quot;badges&quot;: {
        &quot;travis-ci&quot;: {
            &quot;branch&quot;: &quot;master&quot;,
            &quot;repository&quot;: &quot;rust-lang/cargo&quot;
        }
    },
    // The `links` string value from the package's manifest, or null if not
    // specified. This field is optional and defaults to null.
    &quot;links&quot;: null
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Optional object of warnings to display to the user.
    &quot;warnings&quot;: {
        // Array of strings of categories that are invalid and ignored.
        &quot;invalid_categories&quot;: [],
        // Array of strings of badge names that are invalid and ignored.
        &quot;invalid_badges&quot;: [],
        // Array of strings of arbitrary warnings to display to the user.
        &quot;other&quot;: []
    }
}
</code></pre>
<h4><a class="header" href="#yank" id="yank">Yank</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/yank</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>The yank endpoint will set the <code>yank</code> field of the given version of a crate to
<code>true</code> in the index.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the delete succeeded, always true.
    &quot;ok&quot;: true,
}
</code></pre>
<h4><a class="header" href="#unyank" id="unyank">Unyank</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/{version}/unyank</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>The unyank endpoint will set the <code>yank</code> field of the given version of a crate
to <code>false</code> in the index.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the delete succeeded, always true.
    &quot;ok&quot;: true,
}
</code></pre>
<h4><a class="header" href="#owners" id="owners">Owners</a></h4>
<p>Cargo does not have an inherent notion of users and owners, but it does
provide the <code>owner</code> command to assist managing who has authorization to
control a crate. It is up to the registry to decide exactly how users and
owners are handled. See the <a href="reference/publishing.html#cargo-owner">publishing documentation</a> for a description of
how <a href="https://crates.io/">crates.io</a> handles owners via GitHub users and teams.</p>
<h5><a class="header" href="#owners-list" id="owners-list">Owners: List</a></h5>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: GET</li>
<li>Authorization: Included</li>
</ul>
<p>The owners endpoint returns a list of owners of the crate.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Array of owners of the crate.
    &quot;users&quot;: [
        {
            // Unique unsigned 32-bit integer of the owner.
            &quot;id&quot;: 70,
            // The unique username of the owner.
            &quot;login&quot;: &quot;github:rust-lang:core&quot;,
            // Name of the owner.
            // This is optional and may be null.
            &quot;name&quot;: &quot;Core&quot;,
        }
    ]
}
</code></pre>
<h5><a class="header" href="#owners-add" id="owners-add">Owners: Add</a></h5>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: PUT</li>
<li>Authorization: Included</li>
</ul>
<p>A PUT request will send a request to the registry to add a new owner to a
crate. It is up to the registry how to handle the request. For example,
<a href="https://crates.io/">crates.io</a> sends an invite to the user that they must accept before being
added.</p>
<p>The request should include the following JSON object:</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to add.
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the add succeeded, always true.
    &quot;ok&quot;: true,
    // A string to be displayed to the user.
    &quot;msg&quot;: &quot;user ehuss has been invited to be an owner of crate cargo&quot;
}
</code></pre>
<h5><a class="header" href="#owners-remove" id="owners-remove">Owners: Remove</a></h5>
<ul>
<li>Endpoint: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>Method: DELETE</li>
<li>Authorization: Included</li>
</ul>
<p>A DELETE request will remove an owner from a crate. The request should include
the following JSON object:</p>
<pre><code class="language-javascript">{
    // Array of `login` strings of owners to remove.
    &quot;users&quot;: [&quot;login_name&quot;]
}
</code></pre>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Indicates the remove succeeded, always true.
    &quot;ok&quot;: true
}
</code></pre>
<h4><a class="header" href="#search" id="search">Search</a></h4>
<ul>
<li>Endpoint: <code>/api/v1/crates</code></li>
<li>Method: GET</li>
<li>Query Parameters:
<ul>
<li><code>q</code>: The search query string.</li>
<li><code>per_page</code>: Number of results, default 10, max 100.</li>
</ul>
</li>
</ul>
<p>The search request will perform a search for crates, using criteria defined on
the server.</p>
<p>A successful response includes the JSON object:</p>
<pre><code class="language-javascript">{
    // Array of results.
    &quot;crates&quot;: [
        {
            // Name of the crate.
            &quot;name&quot;: &quot;rand&quot;,
            // The highest version available.
            &quot;max_version&quot;: &quot;0.6.1&quot;,
            // Textual description of the crate.
            &quot;description&quot;: &quot;Random number generators and other randomness functionality.\n&quot;,
        }
    ],
    &quot;meta&quot;: {
        // Total number of results available on the server.
        &quot;total&quot;: 119
    }
}
</code></pre>
<h4><a class="header" href="#login" id="login">Login</a></h4>
<ul>
<li>Endpoint: <code>/me</code></li>
</ul>
<p>The &quot;login&quot; endpoint is not an actual API request. It exists solely for the
<a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> command to display a URL to instruct a user to visit in a web
browser to log in and retrieve an API token.</p>
<h1><a class="header" href="#dependency-resolution" id="dependency-resolution">Dependency Resolution</a></h1>
<p>One of Cargo's primary tasks is to determine the versions of dependencies to
use based on the version requirements specified in each package. This process
is called &quot;dependency resolution&quot; and is performed by the &quot;resolver&quot;. The
result of the resolution is stored in the <code>Cargo.lock</code> file which &quot;locks&quot; the
dependencies to specific versions, and keeps them fixed over time.</p>
<p>The resolver attempts to unify common dependencies while considering possibly
conflicting requirements. The sections below provide some details on how these
constraints are handled, and how to work with the resolver.</p>
<p>See the chapter <a href="reference/specifying-dependencies.html">Specifying Dependencies</a> for more details about how
dependency requirements are specified.</p>
<p>The <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> command can be used to visualize the result of the
resolver.</p>
<h2><a class="header" href="#semver-compatibility-1" id="semver-compatibility-1">SemVer compatibility</a></h2>
<p>Cargo uses <a href="https://semver.org/">SemVer</a> for specifying version numbers. This establishes a common
convention for what is compatible between different versions of a package. See
the <a href="reference/semver.html">SemVer Compatibility</a> chapter for guidance on what is considered a
&quot;compatible&quot; change. This notion of &quot;compatibility&quot; is important because Cargo
assumes it should be safe to update a dependency within a compatibility range
without breaking the build.</p>
<p>Versions are considered compatible if their left-most non-zero
major/minor/patch component is the same. For example, <code>1.0.3</code> and <code>1.1.0</code> are
considered compatible, and thus it should be safe to update from the older
release to the newer one. However, an update from <code>1.1.0</code> to <code>2.0.0</code> would not
be allowed to be made automatically. This convention also applies to versions
with leading zeros. For example, <code>0.1.0</code> and <code>0.1.2</code> are compatible, but
<code>0.1.0</code> and <code>0.2.0</code> are not. Similarly, <code>0.0.1</code> and <code>0.0.2</code> are not
compatible.</p>
<p>As a quick refresher, the <em>version requirement</em> syntax Cargo uses for
dependencies is:</p>
<table><thead><tr><th>Requirement</th><th>Example</th><th>Equivalence</th><th>Description</th></tr></thead><tbody>
<tr><td>Caret</td><td><code>1.2.3</code> or <code>^1.2.3</code></td><td><code>&gt;=1.2.3, &lt;2.0.0</code></td><td>Any SemVer-compatible version of at least the given value.</td></tr>
<tr><td>Tilde</td><td><code>~1.2</code></td><td><code>&gt;=1.2.0, &lt;1.3.0</code></td><td>Minimum version, with restricted compatibility range.</td></tr>
<tr><td>Wildcard</td><td><code>1.*</code></td><td><code>&gt;=1.0.0, &lt;2.0.0</code></td><td>Any version in the <code>*</code> position.</td></tr>
<tr><td>Equals</td><td><code>=1.2.3</code></td><td><code>=1.2.3</code></td><td>Exactly the specified version only.</td></tr>
<tr><td>Comparison</td><td><code>&gt;1.1</code></td><td><code>&gt;=1.2.0</code></td><td>Naive numeric comparison of specified digits.</td></tr>
<tr><td>Compound</td><td><code>&gt;=1.2, &lt;1.5</code></td><td><code>&gt;1.2.0, &lt;1.5.0</code></td><td>Multiple requirements that must be simultaneously satisfied.</td></tr>
</tbody></table>
<p>When multiple packages specify a dependency for a common package, the resolver
attempts to ensure that they use the same version of that common package, as
long as they are within a SemVer compatibility range. It also attempts to use
the greatest version currently available within that compatibility range. For
example, if there are two packages in the resolve graph with the following
requirements:</p>
<pre><code class="language-toml"># Package A
[dependencies]
bitflags = &quot;1.0&quot;

# Package B
[dependencies]
bitflags = &quot;1.1&quot;
</code></pre>
<p>If at the time the <code>Cargo.lock</code> file is generated, the greatest version of
<code>bitflags</code> is <code>1.2.1</code>, then both packages will use <code>1.2.1</code> because it is the
greatest within the compatibility range. If <code>2.0.0</code> is published, it will
still use <code>1.2.1</code> because <code>2.0.0</code> is considered incompatible.</p>
<p>If multiple packages have a common dependency with semver-incompatible
versions, then Cargo will allow this, but will build two separate copies of
the dependency. For example:</p>
<pre><code class="language-toml"># Package A
[dependencies]
rand = &quot;0.7&quot;

# Package B
[dependencies]
rand = &quot;0.6&quot;
</code></pre>
<p>The above will result in Package A using the greatest <code>0.7</code> release (<code>0.7.3</code>
at the time of this writing) and Package B will use the greatest <code>0.6</code> release
(<code>0.6.5</code> for example). This can lead to potential problems, see the
<a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> section for more details.</p>
<p>Multiple versions within the same compatibility range are not allowed and will
result in a resolver error if it is constrained to two different versions
within a compatibility range. For example, if there are two packages in the
resolve graph with the following requirements:</p>
<pre><code class="language-toml"># Package A
[dependencies]
log = &quot;=0.4.11&quot;

# Package B
[dependencies]
log = &quot;=0.4.8&quot;
</code></pre>
<p>The above will fail because it is not allowed to have two separate copies of
the <code>0.4</code> release of the <code>log</code> package.</p>
<h3><a class="header" href="#version-incompatibility-hazards" id="version-incompatibility-hazards">Version-incompatibility hazards</a></h3>
<p>When multiple versions of a crate appear in the resolve graph, this can cause
problems when types from those crates are exposed by the crates using them.
This is because the types and items are considered different by the Rust
compiler, even if they have the same name. Libraries should take care when
publishing a SemVer-incompatible version (for example, publishing <code>2.0.0</code>
after <code>1.0.0</code> has been in use), particularly for libraries that are widely
used.</p>
<p>The &quot;<a href="https://github.com/dtolnay/semver-trick">semver trick</a>&quot; is a workaround for this problem of publishing a breaking
change while retaining compatibility with older versions. The linked page goes
into detail about what the problem is and how to address it. In short, when a
library wants to publish a SemVer-breaking release, publish the new release,
and also publish a point release of the previous version that reexports the
types from the newer version.</p>
<p>These incompatibilities usually manifest as a compile-time error, but
sometimes they will only appear as a runtime misbehavior. For example, let's
say there is a common library named <code>foo</code> that ends up appearing with both
version <code>1.0.0</code> and <code>2.0.0</code> in the resolve graph. If <a href="reference/../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> is used
on a object created by a library using version <code>1.0.0</code>, and the code calling
<code>downcast_ref</code> is downcasting to a type from version <code>2.0.0</code>, the downcast
will fail at runtime.</p>
<p>It is important to make sure that if you have multiple versions of a library
that you are properly using them, especially if it is ever possible for the
types from different versions to be used together. The <a href="reference/../commands/cargo-tree.html"><code>cargo tree -d</code></a> command can be used to identify duplicate versions and
where they come from. Similarly, it is important to consider the impact on the
ecosystem if you publish a SemVer-incompatible version of a popular library.</p>
<h3><a class="header" href="#pre-releases" id="pre-releases">Pre-releases</a></h3>
<p>SemVer has the concept of &quot;pre-releases&quot; with a dash in the version, such as
<code>1.0.0-alpha</code>, or <code>1.0.0-beta</code>. Cargo will avoid automatically using
pre-releases unless explicitly asked. For example, if <code>1.0.0-alpha</code> of package
<code>foo</code> is published, then a requirement of <code>foo = &quot;1.0&quot;</code> will <em>not</em> match, and
will return an error. The pre-release must be specified, such as <code>foo = &quot;1.0.0-alpha&quot;</code>. Similarly <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> will avoid pre-releases unless
explicitly asked to install one.</p>
<p>Cargo allows &quot;newer&quot; pre-releases to be used automatically. For example, if
<code>1.0.0-beta</code> is published, then a requirement <code>foo = &quot;1.0.0-alpha&quot;</code> will allow
updating to the <code>beta</code> version. Beware that pre-release versions can be
unstable, and as such care should be taken when using them. Some projects may
choose to publish breaking changes between pre-release versions. It is
recommended to not use pre-release dependencies in a library if your library
is not also a pre-release. Care should also be taken when updating your
<code>Cargo.lock</code>, and be prepared if a pre-release update causes issues.</p>
<p>The pre-release tag may be separated with periods to distinguish separate
components. Numeric components will use numeric comparison. For example,
<code>1.0.0-alpha.4</code> will use numeric comparison for the <code>4</code> component. That means
that if <code>1.0.0-alpha.11</code> is published, that will be chosen as the greatest
release. Non-numeric components are compared lexicographically.</p>
<h3><a class="header" href="#version-metadata" id="version-metadata">Version metadata</a></h3>
<p>SemVer has the concept of &quot;version metadata&quot; with a plus in the version, such
as <code>1.0.0+21AF26D3</code>. This metadata is usually ignored, and should not be used
in a version requirement. You should never publish multiple versions that
differ only in the metadata tag (note, this is a <a href="https://github.com/rust-lang/crates.io/issues/1059">known issue</a> with
<a href="https://crates.io/">crates.io</a> that currently permits this).</p>
<h2><a class="header" href="#other-constraints" id="other-constraints">Other constraints</a></h2>
<p>Version requirements aren't the only constraint that the resolver considers
when selecting and unifying dependencies. The following sections cover some of
the other constraints that can affect resolution.</p>
<h3><a class="header" href="#features-1" id="features-1">Features</a></h3>
<p>For the purpose of generating <code>Cargo.lock</code>, the resolver builds the dependency
graph as-if all <a href="reference/features.html">features</a> of all <a href="reference/workspaces.html">workspace</a> members are enabled. This
ensures that any optional dependencies are available and properly resolved
with the rest of the graph when features are added or removed with the
<a href="reference/features.html#command-line-feature-options"><code>--features</code> command-line flag</a>.
The resolver runs a second time to determine the actual features used when
<em>compiling</em> a crate, based on the features selected on the command-line.</p>
<p>Dependencies are resolved with the union of all features enabled on them. For
example, if one package depends on the <a href="https://crates.io/crates/im"><code>im</code></a> package with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code>
dependency</a> enabled and another package depends on it with the <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code>
dependency</a> enabled, then <code>im</code> will be built with both features enabled, and
the <code>serde</code> and <code>rayon</code> crates will be included in the resolve graph. If no
packages depend on <code>im</code> with those features, then those optional dependencies
will be ignored, and they will not affect resolution.</p>
<p>When building multiple packages in a workspace (such as with <code>--workspace</code> or
multiple <code>-p</code> flags), the features of the dependencies of all of those
packages are unified. If you have a circumstance where you want to avoid that
unification for different workspace members, you will need to build them via
separate <code>cargo</code> invocations.</p>
<p>The resolver will skip over versions of packages that are missing required
features. For example, if a package depends on version <code>^1</code> of <a href="https://crates.io/crates/regex"><code>regex</code></a> with
the <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> feature</a>, then the oldest version it can select is <code>1.3.0</code>,
because versions prior to that did not contain the <code>perf</code> feature. Similarly,
if a feature is removed from a new release, then packages that require that
feature will be stuck on the older releases that contain that feature. It is
discouraged to remove features in a SemVer-compatible release. Beware that
optional dependencies also define an implicit feature, so removing an optional
dependency or making it non-optional can cause problems, see <a href="reference/semver.html#cargo-remove-opt-dep">removing an
optional dependency</a>.</p>
<h4><a class="header" href="#feature-resolver-version-2-1" id="feature-resolver-version-2-1">Feature resolver version 2</a></h4>
<p>When <code>resolver = &quot;2&quot;</code> is specified in <code>Cargo.toml</code> (see <a href="reference/resolver.html#resolver-versions">resolver
versions</a> below), a different feature resolver is used
which uses a different algorithm for unifying features. The version <code>&quot;1&quot;</code>
resolver will unify features for a package no matter where it is specified.
The version <code>&quot;2&quot;</code> resolver will avoid unifying features in the following
situations:</p>
<ul>
<li>
<p>Features for target-specific dependencies are not enabled if the target is
not currently being built. For example:</p>
<pre><code class="language-toml">[dependency.common]
version = &quot;1.0&quot;
features = [&quot;f1&quot;]

[target.'cfg(windows)'.dependencies.common]
version = &quot;1.0&quot;
features = [&quot;f2&quot;]
</code></pre>
<p>When building this example for a non-Windows platform, the <code>f2</code> feature will
<em>not</em> be enabled.</p>
</li>
<li>
<p>Features enabled on <a href="reference/specifying-dependencies.html#build-dependencies">build-dependencies</a> or proc-macros will not be unified
when those same dependencies are used as a normal dependency. For example:</p>
<pre><code class="language-toml">[dependencies]
log = &quot;0.4&quot;

[build-dependencies]
log = {version = &quot;0.4&quot;, features=['std']}
</code></pre>
<p>When building the build script, the <code>log</code> crate will be built with the <code>std</code>
feature. When building the library of your package, it will not enable the
feature.</p>
</li>
<li>
<p>Features enabled on <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a> will not be unified when those same
dependencies are used as a normal dependency, unless those dev-dependencies
are currently being built. For example:</p>
<pre><code class="language-toml">[dependencies]
serde = {version = &quot;1.0&quot;, default-features = false}

[dev-dependencies]
serde = {version = &quot;1.0&quot;, features = [&quot;std&quot;]}
</code></pre>
<p>In this example, the library will normally link against <code>serde</code> without the
<code>std</code> feature. However, when built as a test or example, it will include the
<code>std</code> feature. For example, <code>cargo test</code> or <code>cargo build --all-targets</code> will
unify these features. Note that dev-dependencies in dependencies are always
ignored, this is only relevant for the top-level package or workspace
members.</p>
</li>
</ul>
<h3><a class="header" href="#links" id="links"><code>links</code></a></h3>
<p>The <a href="reference/manifest.html#the-links-field"><code>links</code> field</a> is used to ensure only one copy of a native library is
linked into a binary. The resolver will attempt to find a graph where there is
only one instance of each <code>links</code> name. If it is unable to find a graph that
satisfies that constraint, it will return an error.</p>
<p>For example, it is an error if one package depends on <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> version
<code>0.11</code> and another depends on <code>0.12</code>, because Cargo is unable to unify those,
but they both link to the <code>git2</code> native library. Due to this requirement, it
is encouraged to be very careful when making SemVer-incompatible releases with
the <code>links</code> field if your library is in common use.</p>
<h3><a class="header" href="#yanked-versions" id="yanked-versions">Yanked versions</a></h3>
<p><a href="reference/publishing.html#cargo-yank">Yanked releases</a> are those that are marked that they should not be
used. When the resolver is building the graph, it will ignore all yanked
releases unless they already exist in the <code>Cargo.lock</code> file.</p>
<h2><a class="header" href="#dependency-updates" id="dependency-updates">Dependency updates</a></h2>
<p>Dependency resolution is automatically performed by all Cargo commands that
need to know about the dependency graph. For example, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> will run
the resolver to discover all the dependencies to build. After the first time
it runs, the result is stored in the <code>Cargo.lock</code> file. Subsequent commands
will run the resolver, keeping dependencies locked to the versions in
<code>Cargo.lock</code> <em>if it can</em>.</p>
<p>If the dependency list in <code>Cargo.toml</code> has been modified, for example changing
the version of a dependency from <code>1.0</code> to <code>2.0</code>, then the resolver will select
a new version for that dependency that matches the new requirements. If that
new dependency introduces new requirements, those new requirements may also
trigger additional updates. The <code>Cargo.lock</code> file will be updated with the new
result. The <code>--locked</code> or <code>--frozen</code> flags can be used to change this behavior
to prevent automatic updates when requirements change, and return an error
instead.</p>
<p><a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> can be used to update the entries in <code>Cargo.lock</code> when new
versions are published. Without any options, it will attempt to update all
packages in the lock file. The <code>-p</code> flag can be used to target the update for
a specific package, and other flags such as <code>--aggressive</code> or <code>--precise</code> can
be used to control how versions are selected.</p>
<h2><a class="header" href="#overrides-1" id="overrides-1">Overrides</a></h2>
<p>Cargo has several mechanisms to override dependencies within the graph. The
<a href="reference/overriding-dependencies.html">Overriding Dependencies</a> chapter goes into detail on how to use overrides.
The overrides appear as an overlay to a registry, replacing the patched
version with the new entry. Otherwise, resolution is performed like normal.</p>
<h2><a class="header" href="#dependency-kinds" id="dependency-kinds">Dependency kinds</a></h2>
<p>There are three kinds of dependencies in a package: normal, <a href="reference/specifying-dependencies.html#build-dependencies">build</a>, and
<a href="reference/specifying-dependencies.html#development-dependencies">dev</a>. For the most part these are all treated the same from
the perspective of the resolver. One difference is that dev-dependencies for
non-workspace members are always ignored, and do not influence resolution.</p>
<p><a href="reference/specifying-dependencies.html#platform-specific-dependencies">Platform-specific dependencies</a> with the <code>[target]</code> table are resolved as-if
all platforms are enabled. In other words, the resolver ignores the platform
or <code>cfg</code> expression.</p>
<h3><a class="header" href="#dev-dependency-cycles" id="dev-dependency-cycles">dev-dependency cycles</a></h3>
<p>Usually the resolver does not allow cycles in the graph, but it does allow
them for <a href="reference/specifying-dependencies.html#development-dependencies">dev-dependencies</a>. For example, project &quot;foo&quot; has a dev-dependency
on &quot;bar&quot;, which has a normal dependency on &quot;foo&quot; (usually as a &quot;path&quot;
dependency). This is allowed because there isn't really a cycle from the
perspective of the build artifacts. In this example, the &quot;foo&quot; library is
built (which does not need &quot;bar&quot; because &quot;bar&quot; is only used for tests), and
then &quot;bar&quot; can be built depending on &quot;foo&quot;, then the &quot;foo&quot; tests can be built
linking to &quot;bar&quot;.</p>
<p>Beware that this can lead to confusing errors. In the case of building library
unit tests, there are actually two copies of the library linked into the final
test binary: the one that was linked with &quot;bar&quot;, and the one built that
contains the unit tests. Similar to the issues highlighted in the
<a href="reference/resolver.html#version-incompatibility-hazards">Version-incompatibility hazards</a> section, the types between the two are not
compatible. Be careful when exposing types of &quot;foo&quot; from &quot;bar&quot; in this
situation, since the &quot;foo&quot; unit tests won't treat them the same as the local
types.</p>
<p>If possible, try to split your package into multiple packages and restructure
it so that it remains strictly acyclic.</p>
<h2><a class="header" href="#resolver-versions" id="resolver-versions">Resolver versions</a></h2>
<p>A different feature resolver algorithm can be used by specifying the resolver
version in <code>Cargo.toml</code> like this:</p>
<pre><code class="language-toml">[package]
name = &quot;my-package&quot;
version = &quot;1.0.0&quot;
resolver = &quot;2&quot;
</code></pre>
<p>The version <code>&quot;1&quot;</code> resolver is the original resolver that shipped with Cargo up
to version 1.50, and is the default if the <code>resolver</code> is not specified.</p>
<p>The version <code>&quot;2&quot;</code> resolver introduces changes in <a href="reference/resolver.html#features">feature
unification</a>. See the <a href="reference/features.html#feature-resolver-version-2">features chapter</a> for more
details.</p>
<p>The resolver is a global option that affects the entire workspace. The
<code>resolver</code> version in dependencies is ignored, only the value in the top-level
package will be used. If using a <a href="reference/workspaces.html#virtual-manifest">virtual workspace</a>, the version should be
specified in the <code>[workspace]</code> table, for example:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;member1&quot;, &quot;member2&quot;]
resolver = &quot;2&quot;
</code></pre>
<h2><a class="header" href="#recommendations" id="recommendations">Recommendations</a></h2>
<p>The following are some recommendations for setting the version within your
package, and for specifying dependency requirements. These are general
guidelines that should apply to common situations, but of course some
situations may require specifying unusual requirements.</p>
<ul>
<li>
<p>Follow the <a href="reference/semver.html">SemVer guidelines</a> when deciding how to update your version
number, and whether or not you will need to make a SemVer-incompatible
version change.</p>
</li>
<li>
<p>Use caret requirements for dependencies, such as <code>&quot;1.2.3&quot;</code>, for most
situations. This ensures that the resolver can be maximally flexible in
choosing a version while maintaining build compatibility.</p>
<ul>
<li>Specify all three components with the version you are currently using.
This helps set the minimum version that will be used, and ensures that
other users won't end up with an older version of the dependency that
might be missing something that your package requires.</li>
<li>Avoid <code>*</code> requirements, as they are not allowed on <a href="https://crates.io/">crates.io</a>, and they
can pull in SemVer-breaking changes during a normal <code>cargo update</code>.</li>
<li>Avoid overly broad version requirements. For example, <code>&gt;=2.0.0</code> can pull
in any SemVer-incompatible version, like version <code>5.0.0</code>, which can result
in broken builds in the future.</li>
<li>Avoid overly narrow version requirements if possible. For example, if you
specify a tilde requirement like <code>bar=&quot;~1.3&quot;</code>, and another package
specifies a requirement of <code>bar=&quot;1.4&quot;</code>, this will fail to resolve, even
though minor releases should be compatible.</li>
</ul>
</li>
<li>
<p>Try to keep the dependency versions up-to-date with the actual minimum
versions that your library requires. For example, if you have a requirement
of <code>bar=&quot;1.0.12&quot;</code>, and then in a future release you start using new features
added in the <code>1.1.0</code> release of &quot;bar&quot;, update your dependency requirement to
<code>bar=&quot;1.1.0&quot;</code>.</p>
<p>If you fail to do this, it may not be immediately obvious because Cargo can
opportunistically choose the newest version when you run a blanket <code>cargo update</code>. However, if another user depends on your library, and runs <code>cargo update -p your-library</code>, it will <em>not</em> automatically update &quot;bar&quot; if it is
locked in their <code>Cargo.lock</code>. It will only update &quot;bar&quot; in that situation if
the dependency declaration is also updated. Failure to do so can cause
confusing build errors for the user using <code>cargo update -p</code>.</p>
</li>
<li>
<p>If two packages are tightly coupled, then an <code>=</code> dependency requirement may
help ensure that they stay in sync. For example, a library with a companion
proc-macro library will sometimes make assumptions between the two libraries
that won't work well if the two are out of sync (and it is never expected to
use the two libraries independently). The parent library can use an <code>=</code>
requirement on the proc-macro, and re-export the macros for easy access.</p>
</li>
<li>
<p><code>0.0.x</code> versions can be used for packages that are permanently unstable.</p>
</li>
</ul>
<p>In general, the stricter you make the dependency requirements, the more likely
it will be for the resolver to fail. Conversely, if you use requirements that
are too loose, it may be possible for new versions to be published that will
break the build.</p>
<h2><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h2>
<p>The following illustrates some problems you may experience, and some possible
solutions.</p>
<h3><a class="header" href="#semver-breaking-patch-release-breaks-the-build" id="semver-breaking-patch-release-breaks-the-build">SemVer-breaking patch release breaks the build</a></h3>
<p>Sometimes a project may inadvertently publish a point release with a
SemVer-breaking change. When users update with <code>cargo update</code>, they will pick
up this new release, and then their build may break. In this situation, it is
recommended that the project should <a href="reference/publishing.html#cargo-yank">yank</a> the release, and either remove the
SemVer-breaking change, or publish it as a new SemVer-major version increase.</p>
<p>If the change happened in a third-party project, if possible try to
(politely!) work with the project to resolve the issue.</p>
<p>While waiting for the release to be yanked, some workarounds depend on the
circumstances:</p>
<ul>
<li>If your project is the end product (such as a binary executable), just avoid
updating the offending package in <code>Cargo.lock</code>. This can be done with the
<code>--precise</code> flag in <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a>.</li>
<li>If you publish a binary on <a href="https://crates.io/">crates.io</a>, then you can temporarily add an <code>=</code>
requirement to force the dependency to a specific good version.
<ul>
<li>Binary projects can alternatively recommend users to use the <code>--locked</code>
flag with <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> to use the original <code>Cargo.lock</code> that contains
the known good version.</li>
</ul>
</li>
<li>Libraries may also consider publishing a temporary new release with stricter
requirements that avoid the troublesome dependency. You may want to consider
using range requirements (instead of <code>=</code>) to avoid overly-strict
requirements that may conflict with other packages using the same
dependency. Once the problem has been resolved, you can publish another
point release that relaxes the dependency back to a caret requirement.</li>
<li>If it looks like the third-party project is unable or unwilling to yank the
release, then one option is to update your code to be compatible with the
changes, and update the dependency requirement to set the minimum version to
the new release. You will also need to consider if this is a SemVer-breaking
change of your own library, for example if it exposes types from the
dependency.</li>
</ul>
<h1><a class="header" href="#semver-compatibility-2" id="semver-compatibility-2">SemVer Compatibility</a></h1>
<p>This chapter provides details on what is conventionally considered a
compatible or breaking SemVer change for new releases of a package. See the
<a href="reference/resolver.html#semver-compatibility">SemVer compatibility</a> section for details on what SemVer is, and how Cargo
uses it to ensure compatibility of libraries.</p>
<p>These are only <em>guidelines</em>, and not necessarily hard-and-fast rules that all
projects will obey. The <a href="reference/semver.html#change-categories">Change categories</a> section details how this guide
classifies the level and severity of a change. Most of this guide focuses on
changes that will cause <code>cargo</code> and <code>rustc</code> to fail to build something that
previously worked. Almost every change carries some risk that it will
negatively affect the runtime behavior, and for those cases it is usually a
judgment call by the project maintainers whether or not it is a
SemVer-incompatible change.</p>
<p>See also <a href="https://github.com/rust-dev-tools/rust-semverver">rust-semverver</a>, which is an experimental tool that attempts to
programmatically check compatibility rules.</p>
<h2><a class="header" href="#change-categories" id="change-categories">Change categories</a></h2>
<p>All of the policies listed below are categorized by the level of change:</p>
<ul>
<li><strong>Major change</strong>: a change that requires a major SemVer bump.</li>
<li><strong>Minor change</strong>: a change that requires only a minor SemVer bump.</li>
<li><strong>Possibly-breaking change</strong>: a change that some projects may consider major
and others consider minor.</li>
</ul>
<p>The &quot;Possibly-breaking&quot; category covers changes that have the <em>potential</em> to
break during an update, but may not necessarily cause a breakage. The impact
of these changes should be considered carefully. The exact nature will depend
on the change and the principles of the project maintainers.</p>
<p>Some projects may choose to only bump the patch number on a minor change. It
is encouraged to follow the SemVer spec, and only apply bug fixes in patch
releases. However, a bug fix may require an API change that is marked as a
&quot;minor change&quot;, and shouldn't affect compatibility. This guide does not take a
stance on how each individual &quot;minor change&quot; should be treated, as the
difference between minor and patch changes are conventions that depend on the
nature of the change.</p>
<p>Some changes are marked as &quot;minor&quot;, even though they carry the potential risk
of breaking a build. This is for situations where the potential is extremely
low, and the potentially breaking code is unlikely to be written in idiomatic
Rust, or is specifically discouraged from use.</p>
<p>This guide uses the terms &quot;major&quot; and &quot;minor&quot; assuming this relates to a
&quot;1.0.0&quot; release or later. Initial development releases starting with &quot;0.y.z&quot;
can treat changes in &quot;y&quot; as a major release, and &quot;z&quot; as a minor release.
&quot;0.0.z&quot; releases are always major changes. This is because Cargo uses the
convention that only changes in the left-most non-zero component are
considered incompatible.</p>
<ul>
<li>API compatibility
<ul>
<li>Items
<ul>
<li><a href="reference/semver.html#item-remove">Major: renaming/moving/removing any public items</a></li>
<li><a href="reference/semver.html#item-new">Minor: adding new public items</a></li>
</ul>
</li>
<li>Structs
<ul>
<li><a href="reference/semver.html#struct-add-private-field-when-public">Major: adding a private struct field when all current fields are public</a></li>
<li><a href="reference/semver.html#struct-add-public-field-when-no-private">Major: adding a public field when no private field exists</a></li>
<li><a href="reference/semver.html#struct-private-fields-with-private">Minor: adding or removing private fields when at least one already exists</a></li>
<li><a href="reference/semver.html#struct-tuple-normal-with-private">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></li>
</ul>
</li>
<li>Enums
<ul>
<li><a href="reference/semver.html#enum-variant-new">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></li>
<li><a href="reference/semver.html#enum-fields-new">Major: adding new fields to an enum variant</a></li>
</ul>
</li>
<li>Traits
<ul>
<li><a href="reference/semver.html#trait-new-item-no-default">Major: adding a non-defaulted trait item</a></li>
<li><a href="reference/semver.html#trait-item-signature">Major: any change to trait item signatures</a></li>
<li><a href="reference/semver.html#trait-new-default-item">Possibly-breaking: adding a defaulted trait item</a></li>
<li><a href="reference/semver.html#trait-object-safety">Major: adding a trait item that makes the trait non-object safe</a></li>
<li><a href="reference/semver.html#trait-new-parameter-no-default">Major: adding a type parameter without a default</a></li>
<li><a href="reference/semver.html#trait-new-parameter-default">Minor: adding a defaulted trait type parameter</a></li>
</ul>
</li>
<li>Implementations
<ul>
<li><a href="reference/semver.html#impl-item-new">Possibly-breaking change: adding any inherent items</a></li>
</ul>
</li>
<li>Generics
<ul>
<li><a href="reference/semver.html#generic-bounds-tighten">Major: tightening generic bounds</a></li>
<li><a href="reference/semver.html#generic-bounds-loosen">Minor: loosening generic bounds</a></li>
<li><a href="reference/semver.html#generic-new-default">Minor: adding defaulted type parameters</a></li>
<li><a href="reference/semver.html#generic-generalize-identical">Minor: generalizing a type to use generics (with identical types)</a></li>
<li><a href="reference/semver.html#generic-generalize-different">Major: generalizing a type to use generics (with possibly different types)</a></li>
<li><a href="reference/semver.html#generic-more-generic">Minor: changing a generic type to a more generic type</a></li>
</ul>
</li>
<li>Functions
<ul>
<li><a href="reference/semver.html#fn-change-arity">Major: adding/removing function parameters</a></li>
<li><a href="reference/semver.html#fn-generic-new">Possibly-breaking: introducing a new function type parameter</a></li>
<li><a href="reference/semver.html#fn-generalize-compatible">Minor: generalizing a function to use generics (supporting original type)</a></li>
<li><a href="reference/semver.html#fn-generalize-mismatch">Major: generalizing a function to use generics with type mismatch</a></li>
</ul>
</li>
<li>Attributes
<ul>
<li><a href="reference/semver.html#attr-no-std-to-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></li>
</ul>
</li>
</ul>
</li>
<li>Tooling and environment compatibility
<ul>
<li><a href="reference/semver.html#env-new-rust">Possibly-breaking: changing the minimum version of Rust required</a></li>
<li><a href="reference/semver.html#env-change-requirements">Possibly-breaking: changing the platform and environment requirements</a></li>
<li>Cargo
<ul>
<li><a href="reference/semver.html#cargo-feature-add">Minor: adding a new Cargo feature</a></li>
<li><a href="reference/semver.html#cargo-feature-remove">Major: removing a Cargo feature</a></li>
<li><a href="reference/semver.html#cargo-feature-remove-another">Major: removing a feature from a feature list if that changes functionality or public items</a></li>
<li><a href="reference/semver.html#cargo-remove-opt-dep">Possibly-breaking: removing an optional dependency</a></li>
<li><a href="reference/semver.html#cargo-change-dep-feature">Minor: changing dependency features</a></li>
<li><a href="reference/semver.html#cargo-dep-add">Minor: adding dependencies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html#application-compatibility">Application compatibility</a></li>
</ul>
<h2><a class="header" href="#api-compatibility" id="api-compatibility">API compatibility</a></h2>
<p>All of the examples below contain three parts: the original code, the code
after it has been modified, and an example usage of the code that could appear
in another project. In a minor change, the example usage should successfully
build with both the before and after versions.</p>
<p><a id="item-remove"></a></p>
<h3><a class="header" href="#major-renamingmovingremoving-any-public-items" id="major-renamingmovingremoving-any-public-items">Major: renaming/moving/removing any public items</a></h3>
<p>The absence of a publicly exposed <a href="reference/../../reference/items.html">item</a> will cause any uses of that item to
fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
// ... item has been removed

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: cannot find function `foo`
}
</code></pre>
<p>This includes adding any sort of <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> attribute</a> which can change which
items or behavior is available based on <a href="reference/../../reference/conditional-compilation.html">conditional compilation</a>.</p>
<p>Mitigating strategies:</p>
<ul>
<li>Mark items to be removed as <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and then remove them at a later
date in a SemVer-breaking release.</li>
<li>Mark renamed items as <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecated</a>, and use a <a href="reference/../../reference/items/use-declarations.html"><code>pub use</code></a> item to re-export
to the old name.</li>
</ul>
<p><a id="item-new"></a></p>
<h3><a class="header" href="#minor-adding-new-public-items" id="minor-adding-new-public-items">Minor: adding new public items</a></h3>
<p>Adding new, public <a href="reference/../../reference/items.html">items</a> is a minor change.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
// ... absence of item

///////////////////////////////////////////////////////////
// After
pub fn foo() {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
// `foo` is not used since it didn't previously exist.
</code></pre>
<p>Note that in some rare cases this can be a <strong>breaking change</strong> due to glob
imports. For example, if you add a new trait, and a project has used a glob
import that brings that trait into scope, and the new trait introduces an
associated item that conflicts with any types it is implemented on, this can
cause a compile-time error due to the ambiguity. Example:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
// ... absence of trait

///////////////////////////////////////////////////////////
// After
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // Error:  multiple applicable items in scope
}
</code></pre>
<p>This is not considered a major change because conventionally glob imports are
a known forwards-compatibility hazard. Glob imports of items from external
crates should be avoided.</p>
<p><a id="struct-add-private-field-when-public"></a></p>
<h3><a class="header" href="#major-adding-a-private-struct-field-when-all-current-fields-are-public" id="major-adding-a-private-struct-field-when-all-current-fields-are-public">Major: adding a private struct field when all current fields are public</a></h3>
<p>When a private field is added to a struct that previously had all public fields,
this will break any code that attempts to construct it with a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: cannot construct `Foo`
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new fields to all-public field structs.</li>
<li>Mark structs as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="reference/../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<p><a id="struct-add-public-field-when-no-private"></a></p>
<h3><a class="header" href="#major-adding-a-public-field-when-no-private-field-exists" id="major-adding-a-public-field-when-no-private-field-exists">Major: adding a public field when no private field exists</a></h3>
<p>When a public field is added to a struct that has all public fields, this will
break any code that attempts to construct it with a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // Error: missing field `f2`
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Do not add new new fields to all-public field structs.</li>
<li>Mark structs as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> when first introducing
a struct to prevent users from using struct literal syntax, and instead
provide a constructor method and/or <a href="reference/../../std/default/trait.Default.html">Default</a> implementation.</li>
</ul>
<p><a id="struct-private-fields-with-private"></a></p>
<h3><a class="header" href="#minor-adding-or-removing-private-fields-when-at-least-one-already-exists" id="minor-adding-or-removing-private-fields-when-at-least-one-already-exists">Minor: adding or removing private fields when at least one already exists</a></h3>
<p>It is safe to add or remove private fields from a struct when the struct
already has at least one private field.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>This is safe because existing code cannot use a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor exhaustively match its contents.</p>
<p>Note that for tuple structs, this is a <strong>major change</strong> if the tuple contains
public fields, and the addition or removal of a private field changes the
index of any public field.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // Error: is private
}
</code></pre>
<p><a id="struct-tuple-normal-with-private"></a></p>
<h3><a class="header" href="#minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa" id="minor-going-from-a-tuple-struct-with-all-private-fields-with-at-least-one-field-to-a-normal-struct-or-vice-versa">Minor: going from a tuple struct with all private fields (with at least one field) to a normal struct, or vice versa</a></h3>
<p>Changing a tuple struct to a normal struct (or vice-versa) is safe if all
fields are private.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
fn main() {
    // Cannot access private fields.
    let x = updated_crate::Foo::default();
}
</code></pre>
<p>This is safe because existing code cannot use a <a href="reference/../../reference/expressions/struct-expr.html">struct literal</a> to construct
it, nor match its contents.</p>
<p><a id="enum-variant-new"></a></p>
<h3><a class="header" href="#major-adding-new-enum-variants-without-non_exhaustive" id="major-adding-new-enum-variants-without-non_exhaustive">Major: adding new enum variants (without <code>non_exhaustive</code>)</a></h3>
<p>It is a breaking change to add a new enum variant if the enum does not use the
<a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> attribute.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // Error: `Variant2` not covered
        E::Variant1 =&gt; {}
    }
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark it as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>
to force users to use <a href="reference/../../reference/patterns.html#wildcard-pattern">wildcard patterns</a> to catch new variants.</li>
</ul>
<p><a id="enum-fields-new"></a></p>
<h3><a class="header" href="#major-adding-new-fields-to-an-enum-variant" id="major-adding-new-fields-to-an-enum-variant">Major: adding new fields to an enum variant</a></h3>
<p>It is a breaking change to add new fields to an enum variant because all
fields are public, and constructors and matching will fail to compile.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// After
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // Error: missing f2
    match x {
        E::Variant1 { f1 } =&gt; {} // Error: missing f2
    }
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>When introducing the enum, mark the variant as <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>
so that it cannot be constructed or matched without wildcards.
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}
</code></pre>
</li>
<li>When introducing the enum, use an explicit struct as a value, where you can
have control over the field visibility.
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}
</code></pre>
</li>
</ul>
<p><a id="trait-new-item-no-default"></a></p>
<h3><a class="header" href="#major-adding-a-non-defaulted-trait-item" id="major-adding-a-non-defaulted-trait-item">Major: adding a non-defaulted trait item</a></h3>
<p>It is a breaking change to add a non-defaulted item to a trait. This will
break any implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: not all trait items implemented
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Always provide a default implementation or value for new associated trait
items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<p><a id="trait-item-signature"></a></p>
<h3><a class="header" href="#major-any-change-to-trait-item-signatures" id="major-any-change-to-trait-item-signatures">Major: any change to trait item signatures</a></h3>
<p>It is a breaking change to make any change to a trait item signature. This can
break external implementors of the trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // For sealed traits or normal functions, this would be a minor change
    // because generalizing with generics strictly expands the possible uses.
    // But in this case, trait implementations must use the same signature.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // Error: trait declaration has 1 type parameter
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Introduce new items with default implementations to cover the new
functionality instead of modifying existing items.</li>
<li>When introducing the trait, use the <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">sealed trait</a> technique to prevent
users outside of the crate from implementing the trait.</li>
</ul>
<p><a id="trait-new-default-item"></a></p>
<h3><a class="header" href="#possibly-breaking-adding-a-defaulted-trait-item" id="possibly-breaking-adding-a-defaulted-trait-item">Possibly-breaking: adding a defaulted trait item</a></h3>
<p>It is usually safe to add a defaulted trait item. However, this can sometimes
cause a compile error. For example, this can introduce an ambiguity if a
method of the same name exists in another trait.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // Error: multiple applicable items in scope
}
</code></pre>
<p>Note that this ambiguity does <em>not</em> exist for name collisions on <a href="reference/../../reference/items/implementations.html#inherent-implementations">inherent
implementations</a>, as they take priority over trait items.</p>
<p>See <a href="reference/semver.html#trait-object-safety">trait-object-safety</a> for a special case to consider
when adding trait items.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<p><a id="trait-object-safety"></a></p>
<h3><a class="header" href="#major-adding-a-trait-item-that-makes-the-trait-non-object-safe" id="major-adding-a-trait-item-that-makes-the-trait-non-object-safe">Major: adding a trait item that makes the trait non-object safe</a></h3>
<p>It is a breaking change to add a trait item that changes the trait to not be
<a href="reference/../../reference/items/traits.html#object-safety">object safe</a>.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {
    // An associated const makes the trait not object-safe.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: cannot be made into an object
}
</code></pre>
<p>It is safe to do the converse (making a non-object safe trait into a safe
one).</p>
<p><a id="trait-new-parameter-no-default"></a></p>
<h3><a class="header" href="#major-adding-a-type-parameter-without-a-default" id="major-adding-a-type-parameter-without-a-default">Major: adding a type parameter without a default</a></h3>
<p>It is a breaking change to add a type parameter without a default to a trait.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // Error: missing generics
</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>See <a href="reference/semver.html#trait-new-parameter-default">adding a defaulted trait type parameter</a>.</li>
</ul>
<p><a id="trait-new-parameter-default"></a></p>
<h3><a class="header" href="#minor-adding-a-defaulted-trait-type-parameter" id="minor-adding-a-defaulted-trait-type-parameter">Minor: adding a defaulted trait type parameter</a></h3>
<p>It is safe to add a type parameter to a trait as long as it has a default.
External implementors will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}

///////////////////////////////////////////////////////////
// After
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}
</code></pre>
<p><a id="impl-item-new"></a></p>
<h3><a class="header" href="#possibly-breaking-change-adding-any-inherent-items" id="possibly-breaking-change-adding-any-inherent-items">Possibly-breaking change: adding any inherent items</a></h3>
<p>Usually adding inherent items to an implementation should be safe because
inherent items take priority over trait items. However, in some cases the
collision can cause problems if the name is the same as an implemented trait
item with a different signature.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub struct Foo;

///////////////////////////////////////////////////////////
// After
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // Error: this function takes 0 arguments
}
</code></pre>
<p>Note that if the signatures match, there would not be a compile-time error,
but possibly a silent change in runtime behavior (because it is now executing
a different function).</p>
<p>Mitigation strategies:</p>
<ul>
<li>Some projects may deem this acceptable breakage, particularly if the new
item name is unlikely to collide with any existing code. Choose names
carefully to help avoid these collisions. Additionally, it may be acceptable
to require downstream users to add <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">disambiguation syntax</a> to select the
correct function when updating the dependency.</li>
</ul>
<p><a id="generic-bounds-tighten"></a></p>
<h3><a class="header" href="#major-tightening-generic-bounds" id="major-tightening-generic-bounds">Major: tightening generic bounds</a></h3>
<p>It is a breaking change to tighten generic bounds on a type since this can
break users expecting the looser bounds.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // Error: the trait bound `{float}: Eq` is not satisfied
}
</code></pre>
<p><a id="generic-bounds-loosen"></a></p>
<h3><a class="header" href="#minor-loosening-generic-bounds" id="minor-loosening-generic-bounds">Minor: loosening generic bounds</a></h3>
<p>It is safe to loosen the generic bounds on a type, as it only expands what is
allowed.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}
</code></pre>
<p><a id="generic-new-default"></a></p>
<h3><a class="header" href="#minor-adding-defaulted-type-parameters" id="minor-adding-defaulted-type-parameters">Minor: adding defaulted type parameters</a></h3>
<p>It is safe to add a type parameter to a type as long as it has a default. All
existing references will use the default without needing to specify the
parameter.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// After
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}
</code></pre>
<p><a id="generic-generalize-identical"></a></p>
<h3><a class="header" href="#minor-generalizing-a-type-to-use-generics-with-identical-types" id="minor-generalizing-a-type-to-use-generics-with-identical-types">Minor: generalizing a type to use generics (with identical types)</a></h3>
<p>A struct or enum field can change from a concrete type to a generic type
parameter, provided that the change results in an identical type for all
existing use cases. For example, the following change is permitted:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}
</code></pre>
<p>because existing uses of <code>Foo</code> are shorthand for <code>Foo&lt;u8&gt;</code> which yields the
identical field type.</p>
<p><a id="generic-generalize-different"></a></p>
<h3><a class="header" href="#major-generalizing-a-type-to-use-generics-with-possibly-different-types" id="major-generalizing-a-type-to-use-generics-with-possibly-different-types">Major: generalizing a type to use generics (with possibly different types)</a></h3>
<p>Changing a struct or enum field from a concrete type to a generic type
parameter can break if the type can change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // Error: mismatched types
}
</code></pre>
<p><a id="generic-more-generic"></a></p>
<h3><a class="header" href="#minor-changing-a-generic-type-to-a-more-generic-type" id="minor-changing-a-generic-type-to-a-more-generic-type">Minor: changing a generic type to a more generic type</a></h3>
<p>It is safe to change a generic type to a more generic one. For example, the
following adds a generic parameter that defaults to the original type, which
is safe because all existing users will be using the same type for both
fields, the the defaulted parameter does not need to be specified.</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// After
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}
</code></pre>
<p><a id="fn-change-arity"></a></p>
<h3><a class="header" href="#major-addingremoving-function-parameters" id="major-addingremoving-function-parameters">Major: adding/removing function parameters</a></h3>
<p>Changing the arity of a function is a breaking change.</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
fn main() {
    updated_crate::foo(); // Error: this function takes 1 argument
}
</code></pre>
<p>Mitigating strategies:</p>
<ul>
<li>Introduce a new function with the new signature and possibly
<a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">deprecate</a> the old one.</li>
<li>Introduce functions that take a struct argument, where the struct is built
with the builder pattern. This allows new fields to be added to the struct
in the future.</li>
</ul>
<p><a id="fn-generic-new"></a></p>
<h3><a class="header" href="#possibly-breaking-introducing-a-new-function-type-parameter" id="possibly-breaking-introducing-a-new-function-type-parameter">Possibly-breaking: introducing a new function type parameter</a></h3>
<p>Usually, adding a non-defaulted type parameter is safe, but in some
cases it can be a breaking change:</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // Error: this function takes 2 type arguments but only 1 type argument was supplied
}
</code></pre>
<p>However, such explicit calls are rare enough (and can usually be written in
other ways) that this breakage is usually acceptable. One should take into
account how likely it is that the function in question is being called with
explicit type arguments.</p>
<p><a id="fn-generalize-compatible"></a></p>
<h3><a class="header" href="#minor-generalizing-a-function-to-use-generics-supporting-original-type" id="minor-generalizing-a-function-to-use-generics-supporting-original-type">Minor: generalizing a function to use generics (supporting original type)</a></h3>
<p>The type of an parameter to a function, or its return value, can be
<em>generalized</em> to use generics, including by introducing a new type parameter,
as long as it can be instantiated to the original type. For example, the
following changes are allowed:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// After
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}
</code></pre>
<p>because all existing uses are instantiations of the new signature.</p>
<p>Perhaps somewhat surprisingly, generalization applies to trait objects as
well, given that every trait implements itself:</p>
<pre><code class="language-rust ignore">// MINOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// After
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// Example use of the library that will safely work.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}
</code></pre>
<p>(The use of <code>?Sized</code> is essential; otherwise you couldn't recover the original
signature.)</p>
<p>Introducing generics in this way can potentially create type inference
failures. These are usually rare, and may be acceptable breakage for some
projects, as this can be fixed with additional type annotations.</p>
<pre><code class="language-rust ignore">// Breaking change example

///////////////////////////////////////////////////////////
// Before
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    let x = foo(); // Error: type annotations needed
}
</code></pre>
<p><a id="fn-generalize-mismatch"></a></p>
<h3><a class="header" href="#major-generalizing-a-function-to-use-generics-with-type-mismatch" id="major-generalizing-a-function-to-use-generics-with-type-mismatch">Major: generalizing a function to use generics with type mismatch</a></h3>
<p>It is a breaking change to change a function parameter or return type if the
generic type constrains or changes the types previously allowed. For example,
the following adds a generic constraint that may not be satisfied by existing
code:</p>
<pre><code class="language-rust ignore">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// After
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// Example usage that will break.
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // Error: `Copy` is not implemented for `Vec&lt;u8&gt;`
}
</code></pre>
<p><a id="attr-no-std-to-std"></a></p>
<h3><a class="header" href="#major-switching-from-no_std-support-to-requiring-std" id="major-switching-from-no_std-support-to-requiring-std">Major: switching from <code>no_std</code> support to requiring <code>std</code></a></h3>
<p>If your library specifically supports a <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> environment, it is a
breaking change to make a new release that requires <code>std</code>.</p>
<pre><code class="language-rust ignore skip">// MAJOR CHANGE

///////////////////////////////////////////////////////////
// Before
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// After
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// Example usage that will break.
// This will fail to link for no_std targets because they don't have a `std` crate.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>A common idiom to avoid this is to include a <code>std</code> <a href="reference/features.html">Cargo feature</a> that
optionally enables <code>std</code> support, and when the feature is off, the library
can be used in a <code>no_std</code> environment.</li>
</ul>
<h2><a class="header" href="#tooling-and-environment-compatibility" id="tooling-and-environment-compatibility">Tooling and environment compatibility</a></h2>
<p><a id="env-new-rust"></a></p>
<h3><a class="header" href="#possibly-breaking-changing-the-minimum-version-of-rust-required" id="possibly-breaking-changing-the-minimum-version-of-rust-required">Possibly-breaking: changing the minimum version of Rust required</a></h3>
<p>Introducing the use of new features in a new release of Rust can break
projects that are using older versions of Rust. This also includes using new
features in a new release of Cargo, and requiring the use of a nightly-only
feature in a crate that previously worked on stable.</p>
<p>Some projects choose to allow this in a minor release for various reasons. It
is usually relatively easy to update to a newer version of Rust. Rust also has
a rapid 6-week release cycle, and some projects will provide compatibility
within a window of releases (such as the current stable release plus N
previous releases). Just keep in mind that some large projects may not be able
to update their Rust toolchain rapidly.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Use <a href="reference/features.html">Cargo features</a> to make the new features opt-in.</li>
<li>Provide a large window of support for older releases.</li>
<li>Copy the source of new standard library items if possible so that you
can continue to use an older version but take advantage of the new feature.</li>
<li>Provide a separate branch of older minor releases that can receive backports
of important bugfixes.</li>
<li>Keep an eye out for the <a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a> and
<a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a> features which provide an opt-in
mechanism for new features. These are currently unstable and only available
in the nightly channel.</li>
</ul>
<p><a id="env-change-requirements"></a></p>
<h3><a class="header" href="#possibly-breaking-changing-the-platform-and-environment-requirements" id="possibly-breaking-changing-the-platform-and-environment-requirements">Possibly-breaking: changing the platform and environment requirements</a></h3>
<p>There is a very wide range of assumptions a library makes about the
environment that it runs in, such as the host platform, operating system
version, available services, filesystem support, etc. It can be a breaking
change if you make a new release that restricts what was previously supported,
for example requiring a newer version of an operating system. These changes
can be difficult to track, since you may not always know if a change breaks in
an environment that is not automatically tested.</p>
<p>Some projects may deem this acceptable breakage, particularly if the breakage
is unlikely for most users, or the project doesn't have the resources to
support all environments. Another notable situation is when a vendor
discontinues support for some hardware or OS, the project may deem it
reasonable to also discontinue support.</p>
<p>Mitigation strategies:</p>
<ul>
<li>Document the platforms and environments you specifically support.</li>
<li>Test your code on a wide range of environments in CI.</li>
</ul>
<h3><a class="header" href="#cargo" id="cargo">Cargo</a></h3>
<p><a id="cargo-feature-add"></a></p>
<h4><a class="header" href="#minor-adding-a-new-cargo-feature" id="minor-adding-a-new-cargo-feature">Minor: adding a new Cargo feature</a></h4>
<p>It is usually safe to add new <a href="reference/features.html">Cargo features</a>. If the feature introduces new
changes that cause a breaking change, this can cause difficulties for projects
that have stricter backwards-compatibility needs. In that scenario, avoid
adding the feature to the &quot;default&quot; list, and possibly document the
consequences of enabling the feature.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<p><a id="cargo-feature-remove"></a></p>
<h4><a class="header" href="#major-removing-a-cargo-feature" id="major-removing-a-cargo-feature">Major: removing a Cargo feature</a></h4>
<p>It is usually a breaking change to remove <a href="reference/features.html">Cargo features</a>. This will cause
an error for any project that enabled the feature.</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Clearly document your features. If there is an internal or experimental
feature, mark it as such, so that users know the status of the feature.</li>
<li>Leave the old feature in <code>Cargo.toml</code>, but otherwise remove its
functionality. Document that the feature is deprecated, and remove it in a
future major SemVer release.</li>
</ul>
<p><a id="cargo-feature-remove-another"></a></p>
<h4><a class="header" href="#major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items" id="major-removing-a-feature-from-a-feature-list-if-that-changes-functionality-or-public-items">Major: removing a feature from a feature list if that changes functionality or public items</a></h4>
<p>If removing a feature from another feature, this can break existing users if
they are expecting that functionality to be available through that feature.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[features]
default = [&quot;std&quot;]
std = []

###########################################################
# After
[features]
default = []  # This may cause packages to fail if they are expecting std to be enabled.
std = []
</code></pre>
<p><a id="cargo-remove-opt-dep"></a></p>
<h4><a class="header" href="#possibly-breaking-removing-an-optional-dependency" id="possibly-breaking-removing-an-optional-dependency">Possibly-breaking: removing an optional dependency</a></h4>
<p>Removing an optional dependency can break a project using your library because
another project may be enabling that dependency via <a href="reference/features.html">Cargo features</a>.</p>
<pre><code class="language-toml"># Breaking change example

###########################################################
# Before
[dependencies]
curl = { version = &quot;0.4.31&quot;, optional = true }

###########################################################
# After
[dependencies]
# ..curl removed
</code></pre>
<p>Mitigation strategies:</p>
<ul>
<li>Clearly document your features. If the optional dependency is not included
in the documented list of features, then you may decide to consider it safe
to change undocumented entries.</li>
<li>Leave the optional dependency, and just don't use it within your library.</li>
<li>Replace the optional dependency with a <a href="reference/features.html">Cargo feature</a> that does nothing,
and document that it is deprecated.</li>
<li>Use high-level features which enable optional dependencies, and document
those as the preferred way to enable the extended functionality. For
example, if your library has optional support for something like
&quot;networking&quot;, create a generic feature name &quot;networking&quot; that enables the
optional dependencies necessary to implement &quot;networking&quot;. Then document the
&quot;networking&quot; feature.</li>
</ul>
<p><a id="cargo-change-dep-feature"></a></p>
<h4><a class="header" href="#minor-changing-dependency-features" id="minor-changing-dependency-features">Minor: changing dependency features</a></h4>
<p>It is usually safe to change the features on a dependency, as long as the
feature does not introduce a breaking change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;small_rng&quot;] }


###########################################################
# After
[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<p><a id="cargo-dep-add"></a></p>
<h4><a class="header" href="#minor-adding-dependencies" id="minor-adding-dependencies">Minor: adding dependencies</a></h4>
<p>It is usually safe to add new dependencies, as long as the new dependency
does not introduce new requirements that result in a breaking change.
For example, adding a new dependency that requires nightly in a project
that previously worked on stable is a major change.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[dependencies]
# ..empty

###########################################################
# After
[dependencies]
log = &quot;0.4.11&quot;
</code></pre>
<h2><a class="header" href="#application-compatibility" id="application-compatibility">Application compatibility</a></h2>
<p>Cargo projects may also include executable binaries which have their own
interfaces (such as a CLI interface, OS-level interaction, etc.). Since these
are part of the Cargo package, they often use and share the same version as
the package. You will need to decide if and how you want to employ a SemVer
contract with your users in the changes you make to your application. The
potential breaking and compatible changes to an application are too numerous
to list, so you are encouraged to use the spirit of the <a href="https://semver.org/">SemVer</a> spec to guide
your decisions on how to apply versioning to your application, or at least
document what your commitments are.</p>
<h2><a class="header" href="#unstable-features" id="unstable-features">Unstable Features</a></h2>
<blockquote>
<p>不稳定的特性</p>
</blockquote>
<p>实验性 Cargo 特性仅适用于夜间通道(Rust 的 nightly 版本)。您通常使用<code>-Z</code>带其中一个特性，以启用它们。运行<code>cargo -Z help</code>查看可用的标志列表。</p>
<p><code>-Z unstable-options</code>是用于启用其他不稳定命令行标志的通用标志。需要的此选项将在下面列出。</p>
<p>某些不稳定的特性需要您，在<code>Cargo.toml</code>指定<code>cargo-features</code>字段。</p>
<h3><a class="header" href="#alternate-registries" id="alternate-registries">Alternate Registries</a></h3>
<blockquote>
<p>替换(/备用)注册表</p>
</blockquote>
<ul>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2141-alternative-registries.md">#2141</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/44931">rust-lang/rust#44931</a></li>
</ul>
<p>备用注册表，允许您使用 crates.io 以外的注册表。</p>
<p>注册表的名称定义在<code>.cargo/config</code>中，<code>registries</code>表格的下面:</p>
<pre><code class="language-toml">[registries]
my-registry = { index = &quot;https://my-intranet:8080/git/index&quot; }
</code></pre>
<p>可以在<code>.cargo/credentials</code>添加备用注册表的身份验证信息:</p>
<pre><code class="language-toml">[registries.my-registry]
token = &quot;api-token&quot;
</code></pre>
<p>在<code>Cargo.toml</code>里面，您可以使用指定<code>registry</code>字段，让某个依赖项来自哪个注册表。但首先，您需要在文件的顶部包含适当的<code>cargo-features</code>:</p>
<pre><code class="language-toml">cargo-features = [&quot;alternative-registries&quot;]

[package]
...

[dependencies]
other-create = { version = &quot;1.0&quot;, registry = &quot;my-registry&quot;}
</code></pre>
<p>一个<code>--registry</code>标志 已添加到与注册表交互的<code>publish</code>，<code>login</code>等命令中。示例:</p>
<pre><code>cargo +nightly publish -Z unstable-options --registry my-registry
</code></pre>
<p>在<code>Cargo.toml</code>的 <code>publish</code> 字段，已被扩展为接受限制为发布到这些注册表的注册表列表。</p>
<pre><code class="language-toml">[package]
...
publish = [&quot;my-registry&quot;]
</code></pre>
<h3><a class="header" href="#publish-lockfile" id="publish-lockfile">publish-lockfile</a></h3>
<blockquote>
<p>发布-锁文件</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/2263">#2263</a></li>
<li>PR:<a href="https://github.com/rust-lang/cargo/pull/5093">#5093</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5654">#5654</a></li>
</ul>
<p>创建<code>.crate</code>文件分发时，Cargo 历史上不包括<code>Cargo.lock</code>文件。这可能会导致<code>cargo install</code>用于二进制文件的问题。您可以在<code>cargo package</code>要么<code>cargo publish</code>使用时，指定您的包应包含<code>Cargo.lock</code>，方法是在<code>Cargo.toml</code>中指定<code>publish-lockfile</code>字段。这也需要适当的<code>cargo-features</code>要求:</p>
<pre><code class="language-toml">cargo-features = [&quot;publish-lockfile&quot;]

[package]
...
publish-lockfile = true
</code></pre>
<h3><a class="header" href="#offline-mode" id="offline-mode">Offline Mode</a></h3>
<blockquote>
<p>离线模式</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4686">#4686</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5655">#5655</a></li>
</ul>
<p><code>-Z offline</code>标志 可防止 Cargo 因任何原因尝试访问网络。通常情况下，如果 Cargo 要访问网络但它不可用，则会因错误而停止。</p>
<p>请注意，这可能会导致与在线模式不同的依赖项解析。即使可能有索引的较新版本的本地副本，Cargo 也会将自己限制在本地可用的箱(crate)中。</p>
<h3><a class="header" href="#no-index-update" id="no-index-update">no-index-update</a></h3>
<blockquote>
<p>无索引更新</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
</ul>
<p><code>-Z no-index-update</code>标志 确保 Cargo 不会尝试更新注册表索引。这适用于测试(调制)许多 Cargo 命令的 Crater 等工具，并且您希望每次都避免更新索引的网络延迟。</p>
<h3><a class="header" href="#avoid-dev-deps" id="avoid-dev-deps">avoid-dev-deps</a></h3>
<blockquote>
<p>阻止 开发依赖项</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>稳定问题:<a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p>运行命令如<code>cargo install</code>要么<code>cargo build</code>时，Cargo 当前会需要下载 dev 依赖项，即使它们未被使用。而该<code>-Z avoid-dev-deps</code>标志 则让 Cargo 避免在不需要时下载 dev 依赖项。该<code>Cargo.lock</code>如果跳过了 dev-dependencies，将不会生成相关信息。</p>
<h3><a class="header" href="#minimal-versions" id="minimal-versions">minimal-versions</a></h3>
<blockquote>
<p>最小的版本</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<p>当一个<code>Cargo.lock</code>文件被生成，<code>-Z minimal-versions</code>标志的使用， 将解析依赖关系为满足要求的最小 semver 版本(而不是最高版本)。</p>
<p>此标志的预期用例，是在持续集成期间，检查 Cargo.toml 中指定的版本是否是您实际使用的最低版本的正确反映。也就是说，如果 Cargo.toml 有<code>foo = &quot;1.0.0&quot;</code>说明，那您依赖该特性，不会意外地添加<code>foo 1.5.0</code>。</p>
<h3><a class="header" href="#out-dir" id="out-dir">out-dir</a></h3>
<blockquote>
<p>输出目录</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
</ul>
<p>此功能允许您指定，构建工件后，将复制到的目录。通常，工件只写入<code>target/release</code>要么<code>target/debug</code>目录。但是，确定明确的文件名可能很棘手，因为您需要解析 JSON 输出。而该<code>--out-dir</code>标志 可以更容易地预测访问工件。但是请注意，工件只是被复制，因此原件仍在<code>target</code>目录.例:</p>
<pre><code>cargo +nightly build --out-dir=out -Z unstable-options
</code></pre>
<h3><a class="header" href="#profile-overrides" id="profile-overrides">Profile Overrides</a></h3>
<blockquote>
<p>覆盖配置</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/48683">rust-lang/rust#48683</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2282-profile-dependencies.md">#2282</a></li>
</ul>
<p>可以为特定包和自定义生成脚本覆盖配置文件。一般格式如下:</p>
<pre><code class="language-toml">cargo-features = [&quot;profile-overrides&quot;]

[package]
...

[profile.dev]
opt-level = 0
debug = true

# 这个 `image` 箱 会编译的等级 -Copt-level=3
[profile.dev.overrides.image]
opt-level = 3

# 所有 依赖项 (但 不是 箱本身 或 某些工作区成员)
# 会编译的等级 -Copt-level=2 。 其中包括 构建依赖项.
[profile.dev.overrides.&quot;*&quot;]
opt-level = 2

# 构建 脚本和他们的 依赖项， 会编译的等级 -Copt-level=3
# 默认情况， 构建 脚本 对剩下的配置使用相同的选择
[profile.dev.build-override]
opt-level = 3
</code></pre>
<p>能只为 dev 和 release 配置文件指定覆盖。</p>
<h3><a class="header" href="#config-profiles" id="config-profiles">Config Profiles</a></h3>
<blockquote>
<p>配置 配置文件 (第一个动词，第二个名词)</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/48683">rust-lang/rust#48683</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2282-profile-dependencies.md">#2282</a></li>
</ul>
<!-- HERE -->
<p>可以在<code>.cargo/config</code>文件中指定配置文件。该<code>-Z config-profile</code>命令行标志是使用此功能所必需的。格式与一个 <code>Cargo.toml</code>清单格式相同。如果在多个文件中找到相同的配置，则通过使用常规设置<a href="reference/./config.html#hierarchical-structure">配置层次结构</a>合并。配置设置优先于清单设置。</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 3
</code></pre>
<pre><code>cargo +nightly build -Z config-profile
</code></pre>
<h3><a class="header" href="#namespaced-features" id="namespaced-features">Namespaced features</a></h3>
<blockquote>
<p>特性的命名区间化</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/1286">#1286</a></li>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5565">rust-lang/Cargo#5565</a></li>
</ul>
<p>目前，不可能在清单中具有相同名称的特性和依赖项。但如果你设置<code>namespaced-features</code>至<code>true</code>，功能和依赖项的命名空间就会是分开的。这样做的结果是，在特性请求中，依赖项必须以<code>crate:</code>为前缀。像这样:</p>
<pre><code class="language-toml">[package]
namespaced-features = true

[features]
bar = [&quot;crate:baz&quot;, &quot;foo&quot;]
foo = []

[dependencies]
baz = { version = &quot;0.1&quot;, optional = true }
</code></pre>
<p>为了防止不必要的，必须为每个可选依赖项显式声明特性的模版，将为任何不是定义为相同名称的特性，的可选依赖项创建隐式特性。但是，如果定义了与依赖项同名的特性，则该特性必须将依赖项作为必需项，正如<code>foo = [&quot;crate:foo&quot;]</code>。</p>
<h3><a class="header" href="#build-plan" id="build-plan">Build-plan</a></h3>
<blockquote>
<p>构建计划</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/cargo/issues/5579">rust-lang/Cargo#5579</a></li>
</ul>
<p><code>build</code>命令的<code>--build-plan</code>参数，将输出 JSON，其中包含有关将运行哪些命令，和不实际执行任何操作的信息。与其他构建工具集成时，这可能很有用。例:</p>
<pre><code>cargo +nightly build --build-plan -Z unstable-options
</code></pre>
<h3><a class="header" href="#default-run" id="default-run">default-run</a></h3>
<blockquote>
<p>默认运行</p>
</blockquote>
<ul>
<li>原始问题:<a href="https://github.com/rust-lang/cargo/issues/2200">#2200</a></li>
</ul>
<p>清单中<code>[package]</code>部分的该<code>default-run</code>选项，可用于指定<code>cargo run</code>选择的默认二进制文件。例如，当存在<code>src/bin/a.rs</code>和<code>src/bin/b.rs</code>两者时，选择前者:</p>
<pre><code class="language-toml">[package]
default-run = &quot;a&quot;
</code></pre>
<h3><a class="header" href="#metabuild" id="metabuild">Metabuild</a></h3>
<blockquote>
<p>元构建</p>
</blockquote>
<ul>
<li>跟踪问题:<a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC:<a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild 是一个具有声明性构建脚本的特性。作为不去写一个<code>build.rs</code>脚本，而是您在<code>Cargo.toml</code>中的<code>metabuild</code>字段，指定构建依赖项列表。其将自动生成一个构建脚本，该脚本按顺序运行每个构建依赖项。然后，Metabuild 包可以从<code>Cargo.toml</code>中读取元数据，执行他们的指定行为。</p>
<p>需要包括<code>cargo-features</code>在<code>Cargo.toml</code>的顶部， 一个<code>metadata</code>字段在<code>package</code>下，列出<code>build-dependencies</code>依赖项，并添加 metabuild 包所需的任何元数据。例:</p>
<pre><code class="language-toml">cargo-features = [&quot;metabuild&quot;]

[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;
metabuild = [&quot;foo&quot;, &quot;bar&quot;]

[build-dependencies]
foo = &quot;1.0&quot;
bar = &quot;1.0&quot;

[package.metadata.foo]
extra-info = &quot;qwerty&quot;
</code></pre>
<p>Metabuild 包应该有一个名<code>metabuild</code>为的公共函数，它会执行与常规<code>build.rs</code>脚本一样，执行相同操作。</p>
<h1><a class="header" href="#cargo-commands" id="cargo-commands">Cargo Commands</a></h1>
<ul>
<li><a href="commands/general-commands.html">General Commands</a></li>
<li><a href="commands/build-commands.html">Build Commands</a></li>
<li><a href="commands/manifest-commands.html">Manifest Commands</a></li>
<li><a href="commands/package-commands.html">Package Commands</a></li>
<li><a href="commands/publishing-commands.html">Publishing Commands</a></li>
</ul>
<h1><a class="header" href="#general-commands" id="general-commands">General Commands</a></h1>
<ul>
<li><a href="commands/cargo.html">cargo</a></li>
<li><a href="commands/cargo-help.html">cargo help</a></li>
<li><a href="commands/cargo-version.html">cargo version</a></li>
</ul>
<h1><a class="header" href="#cargo1" id="cargo1">cargo(1)</a></h1>
<h2><a class="header" href="#name" id="name">NAME</a></h2>
<p>cargo - The Rust package manager</p>
<h2><a class="header" href="#synopsis" id="synopsis">SYNOPSIS</a></h2>
<p><code>cargo</code> [<em>options</em>] <em>command</em> [<em>args</em>]<br />
<code>cargo</code> [<em>options</em>] <code>--version</code><br />
<code>cargo</code> [<em>options</em>] <code>--list</code><br />
<code>cargo</code> [<em>options</em>] <code>--help</code><br />
<code>cargo</code> [<em>options</em>] <code>--explain</code> <em>code</em></p>
<h2><a class="header" href="#description" id="description">DESCRIPTION</a></h2>
<p>This program is a package manager and build tool for the Rust language,
available at <a href="https://rust-lang.org">https://rust-lang.org</a>.</p>
<h2><a class="header" href="#commands" id="commands">COMMANDS</a></h2>
<h3><a class="header" href="#build-commands" id="build-commands">Build Commands</a></h3>
<p><a href="commands/cargo-bench.html">cargo-bench(1)</a><br />
    Execute benchmarks of a package.</p>
<p><a href="commands/cargo-build.html">cargo-build(1)</a><br />
    Compile a package.</p>
<p><a href="commands/cargo-check.html">cargo-check(1)</a><br />
    Check a local package and all of its dependencies for errors.</p>
<p><a href="commands/cargo-clean.html">cargo-clean(1)</a><br />
    Remove artifacts that Cargo has generated in the past.</p>
<p><a href="commands/cargo-doc.html">cargo-doc(1)</a><br />
    Build a package's documentation.</p>
<p><a href="commands/cargo-fetch.html">cargo-fetch(1)</a><br />
    Fetch dependencies of a package from the network.</p>
<p><a href="commands/cargo-fix.html">cargo-fix(1)</a><br />
    Automatically fix lint warnings reported by rustc.</p>
<p><a href="commands/cargo-run.html">cargo-run(1)</a><br />
    Run a binary or example of the local package.</p>
<p><a href="commands/cargo-rustc.html">cargo-rustc(1)</a><br />
    Compile a package, and pass extra options to the compiler.</p>
<p><a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a><br />
    Build a package's documentation, using specified custom flags.</p>
<p><a href="commands/cargo-test.html">cargo-test(1)</a><br />
    Execute unit and integration tests of a package.</p>
<h3><a class="header" href="#manifest-commands" id="manifest-commands">Manifest Commands</a></h3>
<p><a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a><br />
    Generate <code>Cargo.lock</code> for a project.</p>
<p><a href="commands/cargo-locate-project.html">cargo-locate-project(1)</a><br />
    Print a JSON representation of a <code>Cargo.toml</code> file's location.</p>
<p><a href="commands/cargo-metadata.html">cargo-metadata(1)</a><br />
    Output the resolved dependencies of a package in machine-readable format.</p>
<p><a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a><br />
    Print a fully qualified package specification.</p>
<p><a href="commands/cargo-tree.html">cargo-tree(1)</a><br />
    Display a tree visualization of a dependency graph.</p>
<p><a href="commands/cargo-update.html">cargo-update(1)</a><br />
    Update dependencies as recorded in the local lock file.</p>
<p><a href="commands/cargo-vendor.html">cargo-vendor(1)</a><br />
    Vendor all dependencies locally.</p>
<p><a href="commands/cargo-verify-project.html">cargo-verify-project(1)</a><br />
    Check correctness of crate manifest.</p>
<h3><a class="header" href="#package-commands" id="package-commands">Package Commands</a></h3>
<p><a href="commands/cargo-init.html">cargo-init(1)</a><br />
    Create a new Cargo package in an existing directory.</p>
<p><a href="commands/cargo-install.html">cargo-install(1)</a><br />
    Build and install a Rust binary.</p>
<p><a href="commands/cargo-new.html">cargo-new(1)</a><br />
    Create a new Cargo package.</p>
<p><a href="commands/cargo-search.html">cargo-search(1)</a><br />
    Search packages in crates.io.</p>
<p><a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a><br />
    Remove a Rust binary.</p>
<h3><a class="header" href="#publishing-commands" id="publishing-commands">Publishing Commands</a></h3>
<p><a href="commands/cargo-login.html">cargo-login(1)</a><br />
    Save an API token from the registry locally.</p>
<p><a href="commands/cargo-owner.html">cargo-owner(1)</a><br />
    Manage the owners of a crate on the registry.</p>
<p><a href="commands/cargo-package.html">cargo-package(1)</a><br />
    Assemble the local package into a distributable tarball.</p>
<p><a href="commands/cargo-publish.html">cargo-publish(1)</a><br />
    Upload a package to the registry.</p>
<p><a href="commands/cargo-yank.html">cargo-yank(1)</a><br />
    Remove a pushed crate from the index.</p>
<h3><a class="header" href="#general-commands-1" id="general-commands-1">General Commands</a></h3>
<p><a href="commands/cargo-help.html">cargo-help(1)</a><br />
    Display help information about Cargo.</p>
<p><a href="commands/cargo-version.html">cargo-version(1)</a><br />
    Show version information.</p>
<h2><a class="header" href="#options" id="options">OPTIONS</a></h2>
<h3><a class="header" href="#special-options" id="special-options">Special Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--V"><a class="option-anchor" href="commands/cargo.html#option-cargo--V"></a><code>-V</code></dt>
<dt class="option-term" id="option-cargo---version"><a class="option-anchor" href="commands/cargo.html#option-cargo---version"></a><code>--version</code></dt>
<dd class="option-desc">Print version info and exit. If used with <code>--verbose</code>, prints extra
information.</dd>
<dt class="option-term" id="option-cargo---list"><a class="option-anchor" href="commands/cargo.html#option-cargo---list"></a><code>--list</code></dt>
<dd class="option-desc">List all installed Cargo subcommands. If used with <code>--verbose</code>, prints extra
information.</dd>
<dt class="option-term" id="option-cargo---explain"><a class="option-anchor" href="commands/cargo.html#option-cargo---explain"></a><code>--explain</code> <em>code</em></dt>
<dd class="option-desc">Run <code>rustc --explain CODE</code> which will print out a detailed explanation of an
error message (for example, <code>E0004</code>).</dd>
</dl>
<h3><a class="header" href="#display-options" id="display-options">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo--v"><a class="option-anchor" href="commands/cargo.html#option-cargo--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo---verbose"><a class="option-anchor" href="commands/cargo.html#option-cargo---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo--q"><a class="option-anchor" href="commands/cargo.html#option-cargo--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo---quiet"><a class="option-anchor" href="commands/cargo.html#option-cargo---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo---color"><a class="option-anchor" href="commands/cargo.html#option-cargo---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options" id="manifest-options">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo---frozen"><a class="option-anchor" href="commands/cargo.html#option-cargo---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo---locked"><a class="option-anchor" href="commands/cargo.html#option-cargo---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo---offline"><a class="option-anchor" href="commands/cargo.html#option-cargo---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options" id="common-options">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-+toolchain"><a class="option-anchor" href="commands/cargo.html#option-cargo-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo--h"><a class="option-anchor" href="commands/cargo.html#option-cargo--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo---help"><a class="option-anchor" href="commands/cargo.html#option-cargo---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo--Z"><a class="option-anchor" href="commands/cargo.html#option-cargo--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境" id="环境">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态" id="退出状态">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#files" id="files">FILES</a></h2>
<p><code>~/.cargo/</code><br />
    Default location for Cargo's &quot;home&quot; directory where it
stores various files. The location can be changed with the <code>CARGO_HOME</code>
environment variable.</p>
<p><code>$CARGO_HOME/bin/</code><br />
    Binaries installed by <a href="commands/cargo-install.html">cargo-install(1)</a> will be located here. If using
<a href="https://rust-lang.github.io/rustup/">rustup</a>, executables distributed with Rust are also located here.</p>
<p><code>$CARGO_HOME/config.toml</code><br />
    The global configuration file. See <a href="commands/../reference/config.html">the reference</a>
for more information about configuration files.</p>
<p><code>.cargo/config.toml</code><br />
    Cargo automatically searches for a file named <code>.cargo/config.toml</code> in the
current directory, and all parent directories. These configuration files
will be merged with the global configuration file.</p>
<p><code>$CARGO_HOME/credentials.toml</code><br />
    Private authentication information for logging in to a registry.</p>
<p><code>$CARGO_HOME/registry/</code><br />
    This directory contains cached downloads of the registry index and any
downloaded dependencies.</p>
<p><code>$CARGO_HOME/git/</code><br />
    This directory contains cached downloads of git dependencies.</p>
<p>Please note that the internal structure of the <code>$CARGO_HOME</code> directory is not
stable yet and may be subject to change.</p>
<h2><a class="header" href="#examples-2" id="examples-2">EXAMPLES</a></h2>
<ol>
<li>
<p>Build a local package and all of its dependencies:</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>Build a package with optimizations:</p>
<pre><code>cargo build --release
</code></pre>
</li>
<li>
<p>Run tests for a cross-compiled target:</p>
<pre><code>cargo test --target i686-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>Create a new package that builds an executable:</p>
<pre><code>cargo new foobar
</code></pre>
</li>
<li>
<p>Create a package in the current directory:</p>
<pre><code>mkdir foo &amp;&amp; cd foo
cargo init .
</code></pre>
</li>
<li>
<p>Learn about a command's options and usage:</p>
<pre><code>cargo help clean
</code></pre>
</li>
</ol>
<h2><a class="header" href="#bugs" id="bugs">BUGS</a></h2>
<p>See <a href="https://github.com/rust-lang/cargo/issues">https://github.com/rust-lang/cargo/issues</a> for issues.</p>
<h2><a class="header" href="#see-also" id="see-also">SEE ALSO</a></h2>
<p><a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<h1><a class="header" href="#cargo-help1" id="cargo-help1">cargo-help(1)</a></h1>
<h2><a class="header" href="#name-1" id="name-1">NAME</a></h2>
<p>cargo-help - Get help for a Cargo command</p>
<h2><a class="header" href="#synopsis-1" id="synopsis-1">SYNOPSIS</a></h2>
<p><code>cargo help</code> [<em>subcommand</em>]</p>
<h2><a class="header" href="#description-1" id="description-1">DESCRIPTION</a></h2>
<p>Prints a help message for the given command.</p>
<h2><a class="header" href="#examples-3" id="examples-3">EXAMPLES</a></h2>
<ol>
<li>
<p>Get help for a command:</p>
<pre><code>cargo help build
</code></pre>
</li>
<li>
<p>Help is also available with the <code>--help</code> flag:</p>
<pre><code>cargo build --help
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-1" id="see-also-1">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<h1><a class="header" href="#cargo-version1" id="cargo-version1">cargo-version(1)</a></h1>
<h2><a class="header" href="#name-2" id="name-2">NAME</a></h2>
<p>cargo-version - Show version information</p>
<h2><a class="header" href="#synopsis-2" id="synopsis-2">SYNOPSIS</a></h2>
<p><code>cargo version</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-2" id="description-2">DESCRIPTION</a></h2>
<p>Displays the version of Cargo.</p>
<h2><a class="header" href="#options-1" id="options-1">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-version--v"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-version---verbose"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">Display additional version information.</dd>
</dl>
<h2><a class="header" href="#examples-4" id="examples-4">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the version:</p>
<pre><code>cargo version
</code></pre>
</li>
<li>
<p>The version is also available via flags:</p>
<pre><code>cargo --version
cargo -V
</code></pre>
</li>
<li>
<p>Display extra version information:</p>
<pre><code>cargo -Vv
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-2" id="see-also-2">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<h1><a class="header" href="#build-commands-1" id="build-commands-1">Build Commands</a></h1>
<ul>
<li><a href="commands/cargo-bench.html">cargo bench</a></li>
<li><a href="commands/cargo-build.html">cargo build</a></li>
<li><a href="commands/cargo-check.html">cargo check</a></li>
<li><a href="commands/cargo-clean.html">cargo clean</a></li>
<li><a href="commands/cargo-doc.html">cargo doc</a></li>
<li><a href="commands/cargo-fetch.html">cargo fetch</a></li>
<li><a href="commands/cargo-fix.html">cargo fix</a></li>
<li><a href="commands/cargo-run.html">cargo run</a></li>
<li><a href="commands/cargo-rustc.html">cargo rustc</a></li>
<li><a href="commands/cargo-rustdoc.html">cargo rustdoc</a></li>
<li><a href="commands/cargo-test.html">cargo test</a></li>
</ul>
<h1><a class="header" href="#cargo-bench1" id="cargo-bench1">cargo-bench(1)</a></h1>
<h2><a class="header" href="#name-3" id="name-3">NAME</a></h2>
<p>cargo-bench - Execute benchmarks of a package</p>
<h2><a class="header" href="#synopsis-3" id="synopsis-3">SYNOPSIS</a></h2>
<p><code>cargo bench</code> [<em>options</em>] [<em>benchname</em>] [<code>--</code> <em>bench-options</em>]</p>
<h2><a class="header" href="#description-3" id="description-3">DESCRIPTION</a></h2>
<p>Compile and execute benchmarks.</p>
<p>The benchmark filtering argument <em>benchname</em> and all the arguments following
the two dashes (<code>--</code>) are passed to the benchmark binaries and thus to
<em>libtest</em> (rustc's built in unit-test and micro-benchmarking framework). If
you are passing arguments to both Cargo and the binary, the ones after <code>--</code> go
to the binary, the ones before go to Cargo. For details about libtest's
arguments see the output of <code>cargo bench -- --help</code> and check out the rustc
book's chapter on how tests work at
<a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>As an example, this will run only the benchmark named <code>foo</code> (and skip other
similarly named benchmarks like <code>foobar</code>):</p>
<pre><code>cargo bench -- foo --exact
</code></pre>
<p>Benchmarks are built with the <code>--test</code> option to <code>rustc</code> which creates an
executable with a <code>main</code> function that automatically runs all functions
annotated with the <code>#[bench]</code> attribute. Cargo passes the <code>--bench</code> flag to
the test harness to tell it to run only benchmarks.</p>
<p>The libtest harness may be disabled by setting <code>harness = false</code> in the target
manifest settings, in which case your code will need to provide its own <code>main</code>
function to handle running benchmarks.</p>
<blockquote>
<p><strong>Note</strong>: The
<a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html"><code>#[bench]</code> attribute</a>
is currently unstable and only available on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>.
There are some packages available on
<a href="https://crates.io/keywords/benchmark">crates.io</a> that may help with
running benchmarks on the stable channel, such as
<a href="https://crates.io/crates/criterion">Criterion</a>.</p>
</blockquote>
<p>By default, <code>cargo bench</code> uses the <a href="commands/../reference/profiles.html#bench"><code>bench</code> profile</a>, which enables
optimizations and disables debugging information. If you need to debug a
benchmark, you can use the <code>--profile=dev</code> command-line option to switch to
the dev profile. You can then run the debug-enabled benchmark within a
debugger.</p>
<h2><a class="header" href="#options-2" id="options-2">OPTIONS</a></h2>
<h3><a class="header" href="#benchmark-options" id="benchmark-options">Benchmark Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---no-run"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">Compile, but don't run benchmarks.</dd>
<dt class="option-term" id="option-cargo-bench---no-fail-fast"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">Run all benchmarks regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all benchmarks
within the executable to completion, this flag only applies to the executable
as a whole.</dd>
</dl>
<h3><a class="header" href="#选择包" id="选择包">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-bench--p"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-bench---package"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Benchmark指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-bench---workspace"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Benchmark 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-bench---all"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-bench---exclude"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection" id="target-selection">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo bench</code> will build the
following targets of the selected packages:</p>
<ul>
<li>lib — used to link with binaries and benchmarks</li>
<li>bins (only if benchmark targets are built and required features are
available)</li>
<li>lib as a benchmark</li>
<li>bins as benchmarks</li>
<li>benchmark targets</li>
</ul>
<p>The default behavior can be changed by setting the <code>bench</code> flag for the target
in the manifest settings. Setting examples to <code>bench = true</code> will build and
run the example as a benchmark. Setting targets to <code>bench = false</code> will stop
them from being benchmarked by default. Target selection options that take a
target by name ignore the <code>bench</code> flag and will always benchmark the given
target.</p>
<p>Passing target selection flags will benchmark only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-bench---lib"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Benchmark the package's library.</dd>
<dt class="option-term" id="option-cargo-bench---bin"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---bins"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Benchmark all binary targets.</dd>
<dt class="option-term" id="option-cargo-bench---example"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---examples"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Benchmark all example targets.</dd>
<dt class="option-term" id="option-cargo-bench---test"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---tests"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Benchmark all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---bench"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Benchmark the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-bench---benches"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Benchmark all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-bench---all-targets"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Benchmark all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择" id="特性选择">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-bench---features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-bench---all-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-bench---no-default-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options" id="compilation-options">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Benchmark 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-bench---profile"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Benchmark with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-bench---ignore-rust-version"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Benchmark the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options" id="output-options">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target-dir"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-1" id="display-options-1">Display Options</a></h3>
<p>By default the Rust test harness hides output from benchmark execution to keep
results readable. Benchmark output can be recovered (e.g., for debugging) by
passing <code>--nocapture</code> to the benchmark binaries:</p>
<pre><code>cargo bench -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-bench--v"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-bench---verbose"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench--q"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-bench---quiet"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---color"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-bench---message-format"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-1" id="manifest-options-1">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---manifest-path"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-bench---frozen"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-bench---locked"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-bench---offline"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-1" id="common-options-1">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench-+toolchain"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-bench--h"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-bench---help"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-bench--Z"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options" id="miscellaneous-options">Miscellaneous Options</a></h3>
<p>The <code>--jobs</code> argument affects the building of the benchmark executable but
does not affect how many threads are used when running the benchmarks. The
Rust test harness runs benchmarks serially in a single thread.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--j"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-bench---jobs"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h2><a class="header" href="#环境-1" id="环境-1">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-1" id="退出状态-1">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-5" id="examples-5">EXAMPLES</a></h2>
<ol>
<li>
<p>Build and execute all the benchmarks of the current package:</p>
<pre><code>cargo bench
</code></pre>
</li>
<li>
<p>Run only a specific benchmark within a specific benchmark target:</p>
<pre><code>cargo bench --bench bench_name -- modname::some_benchmark
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-3" id="see-also-3">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-test.html">cargo-test(1)</a></p>
<h1><a class="header" href="#cargo-build1" id="cargo-build1">cargo-build(1)</a></h1>
<h2><a class="header" href="#name-4" id="name-4">NAME</a></h2>
<p>cargo-build - Compile the current package</p>
<h2><a class="header" href="#synopsis-4" id="synopsis-4">SYNOPSIS</a></h2>
<p><code>cargo build</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-4" id="description-4">DESCRIPTION</a></h2>
<p>Compile local packages and all of their dependencies.</p>
<h2><a class="header" href="#options-3" id="options-3">OPTIONS</a></h2>
<h3><a class="header" href="#选择包-1" id="选择包-1">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-build--p"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-build---package"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Build指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-build---workspace"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Build 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-build---all"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-build---exclude"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection-1" id="target-selection-1">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo build</code> will build all
binary and library targets of the selected packages. Binaries are skipped if
they have <code>required-features</code> that are missing.</p>
<p>Passing target selection flags will build only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-build---lib"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Build the package's library.</dd>
<dt class="option-term" id="option-cargo-build---bin"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---bins"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Build all binary targets.</dd>
<dt class="option-term" id="option-cargo-build---example"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---examples"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Build all example targets.</dd>
<dt class="option-term" id="option-cargo-build---test"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---tests"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Build all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-build---bench"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-build---benches"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Build all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-build---all-targets"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-1" id="特性选择-1">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-build---features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-build---all-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-build---no-default-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-1" id="compilation-options-1">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Build 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-build--r"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-build---release"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---release"></a><code>--release</code></dt>
<dd class="option-desc">Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-build---profile"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Build with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-build---ignore-rust-version"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Build the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-1" id="output-options-1">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
<dt class="option-term" id="option-cargo-build---out-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---out-dir"></a><code>--out-dir</code> <em>directory</em></dt>
<dd class="option-desc">Copy final artifacts to this directory.</p>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/6790">https://github.com/rust-lang/cargo/issues/6790</a> for more information.</dd>
</dl>
<h3><a class="header" href="#display-options-2" id="display-options-2">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--v"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-build---verbose"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build--q"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-build---quiet"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build---color"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-build---message-format"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-build---build-plan"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---build-plan"></a><code>--build-plan</code></dt>
<dd class="option-desc">Outputs a series of JSON messages to stdout that indicate the commands to run
the build.</p>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/5579">https://github.com/rust-lang/cargo/issues/5579</a> for more information.</dd>
</dl>
<h3><a class="header" href="#manifest-options-2" id="manifest-options-2">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---manifest-path"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-build---frozen"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-build---locked"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-build---offline"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-2" id="common-options-2">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build-+toolchain"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-build--h"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-build---help"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-build--Z"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-1" id="miscellaneous-options-1">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--j"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-build---jobs"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
<dt class="option-term" id="option-cargo-build---future-incompat-report"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2><a class="header" href="#环境-2" id="环境-2">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-2" id="退出状态-2">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-6" id="examples-6">EXAMPLES</a></h2>
<ol>
<li>
<p>Build the local package and all of its dependencies:</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>Build with optimizations:</p>
<pre><code>cargo build --release
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-4" id="see-also-4">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustc.html">cargo-rustc(1)</a></p>
<h1><a class="header" href="#cargo-check1" id="cargo-check1">cargo-check(1)</a></h1>
<h2><a class="header" href="#name-5" id="name-5">NAME</a></h2>
<p>cargo-check - Check the current package</p>
<h2><a class="header" href="#synopsis-5" id="synopsis-5">SYNOPSIS</a></h2>
<p><code>cargo check</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-5" id="description-5">DESCRIPTION</a></h2>
<p>Check a local package and all of its dependencies for errors. This will
essentially compile the packages without performing the final step of code
generation, which is faster than running <code>cargo build</code>. The compiler will save
metadata files to disk so that future runs will reuse them if the source has
not been modified. Some diagnostics and errors are only emitted during code
generation, so they inherently won't be reported with <code>cargo check</code>.</p>
<h2><a class="header" href="#options-4" id="options-4">OPTIONS</a></h2>
<h3><a class="header" href="#选择包-2" id="选择包-2">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-check--p"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-check---package"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Check指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-check---workspace"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Check 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-check---all"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-check---exclude"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection-2" id="target-selection-2">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo check</code> will check all
binary and library targets of the selected packages. Binaries are skipped if
they have <code>required-features</code> that are missing.</p>
<p>Passing target selection flags will check only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-check---lib"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Check the package's library.</dd>
<dt class="option-term" id="option-cargo-check---bin"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---bins"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Check all binary targets.</dd>
<dt class="option-term" id="option-cargo-check---example"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---examples"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Check all example targets.</dd>
<dt class="option-term" id="option-cargo-check---test"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---tests"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Check all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---bench"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Check the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-check---benches"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Check all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-check---all-targets"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Check all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-2" id="特性选择-2">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-check---features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-check---all-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-check---no-default-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-2" id="compilation-options-2">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Check 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-check--r"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-check---release"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---release"></a><code>--release</code></dt>
<dd class="option-desc">Check optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-check---profile"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Check with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-check---ignore-rust-version"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Check the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-2" id="output-options-2">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target-dir"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-3" id="display-options-3">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--v"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-check---verbose"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check--q"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-check---quiet"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---color"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-check---message-format"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-3" id="manifest-options-3">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---manifest-path"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-check---frozen"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-check---locked"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-check---offline"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-3" id="common-options-3">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check-+toolchain"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-check--h"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-check---help"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-check--Z"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-2" id="miscellaneous-options-2">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--j"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-check---jobs"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
<dt class="option-term" id="option-cargo-check---future-incompat-report"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2><a class="header" href="#环境-3" id="环境-3">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-3" id="退出状态-3">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-7" id="examples-7">EXAMPLES</a></h2>
<ol>
<li>
<p>Check the local package for errors:</p>
<pre><code>cargo check
</code></pre>
</li>
<li>
<p>Check all targets, including unit tests:</p>
<pre><code>cargo check --all-targets --profile=test
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-5" id="see-also-5">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<h1><a class="header" href="#cargo-clean1" id="cargo-clean1">cargo-clean(1)</a></h1>
<h2><a class="header" href="#名称" id="名称">名称</a></h2>
<p>cargo-clean - 移除已生成的工件</p>
<h2><a class="header" href="#用法" id="用法">用法</a></h2>
<p><code>cargo clean</code> [<em>options</em>]</p>
<h2><a class="header" href="#描述" id="描述">描述</a></h2>
<p>将Cargo生成的工件从生成目标目录中移除。</p>
<p>若不添加参数，<code>cargo clean</code> 会删除整个target目录。</p>
<h2><a class="header" href="#可选参数" id="可选参数">可选参数</a></h2>
<h3><a class="header" href="#选择包-3" id="选择包-3">选择包</a></h3>
<p>若不指定包名，则清除工作目录中的所有的包和依赖</p>
<dl>
<dt class="option-term" id="option-cargo-clean--p"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-clean---package"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">只清理参数指定的包中的文件。这个参数可以多次使用来指定多个包，详见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。</dd>
</dl>
<h3><a class="header" href="#清理选项" id="清理选项">清理选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---doc"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---doc"></a><code>--doc</code></dt>
<dd class="option-desc">添加该参数后，<code>cargo clean</code>命令只会移除生成目标目录中的<code>doc</code>目录。</dd>
<dt class="option-term" id="option-cargo-clean---release"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---release"></a><code>--release</code></dt>
<dd class="option-desc">移除<code>release</code>目录中的工件。</dd>
<dt class="option-term" id="option-cargo-clean---profile"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">移除指定编译配置(<strong>Profile</strong>)目录中的全部工件。</dd>
<dt class="option-term" id="option-cargo-clean---target-dir"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
<dt class="option-term" id="option-cargo-clean---target"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Clean 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
</dl>
<h3><a class="header" href="#显示选项" id="显示选项">显示选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean--v"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-clean---verbose"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean--q"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-clean---quiet"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-clean---color"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#清单选项" id="清单选项">清单选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---manifest-path"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-clean---frozen"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-clean---locked"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-clean---offline"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-4" id="common-options-4">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean-+toolchain"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-clean--h"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-clean---help"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-clean--Z"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-4" id="环境-4">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-4" id="退出状态-4">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#示例" id="示例">示例</a></h2>
<ol>
<li>
<p>移除整个生成目标目录:</p>
<pre><code>cargo clean
</code></pre>
</li>
<li>
<p>仅移除release目录中的工件:</p>
<pre><code>cargo clean --release
</code></pre>
</li>
</ol>
<h2><a class="header" href="#相关" id="相关">相关</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<h1><a class="header" href="#cargo-doc1" id="cargo-doc1">cargo-doc(1)</a></h1>
<h2><a class="header" href="#name-6" id="name-6">NAME</a></h2>
<p>cargo-doc - Build a package's documentation</p>
<h2><a class="header" href="#synopsis-6" id="synopsis-6">SYNOPSIS</a></h2>
<p><code>cargo doc</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-6" id="description-6">DESCRIPTION</a></h2>
<p>Build the documentation for the local package and all dependencies. The output
is placed in <code>target/doc</code> in rustdoc's usual format.</p>
<h2><a class="header" href="#options-5" id="options-5">OPTIONS</a></h2>
<h3><a class="header" href="#documentation-options" id="documentation-options">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---open"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
<dt class="option-term" id="option-cargo-doc---no-deps"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Do not build documentation for dependencies.</dd>
<dt class="option-term" id="option-cargo-doc---document-private-items"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---document-private-items"></a><code>--document-private-items</code></dt>
<dd class="option-desc">Include non-public items in the documentation. This will be enabled by default if documenting a binary target.</dd>
</dl>
<h3><a class="header" href="#选择包-4" id="选择包-4">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-doc--p"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-doc---package"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Document指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-doc---workspace"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Document 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-doc---all"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-doc---exclude"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection-3" id="target-selection-3">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo doc</code> will document all
binary and library targets of the selected package. The binary will be skipped
if its name is the same as the lib target. Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>The default behavior can be changed by setting <code>doc = false</code> for the target in
the manifest settings. Using target selection options will ignore the <code>doc</code>
flag and will always document the given target.</p>
<dl>
<dt class="option-term" id="option-cargo-doc---lib"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-doc---bin"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---bins"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-doc---example"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-doc---examples"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
</dl>
<h3><a class="header" href="#特性选择-3" id="特性选择-3">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-doc---features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-doc---all-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-doc---no-default-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-3" id="compilation-options-3">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Document 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-doc--r"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-doc---release"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-doc---profile"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-doc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-3" id="output-options-3">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target-dir"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-4" id="display-options-4">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--v"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-doc---verbose"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc--q"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-doc---quiet"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---color"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-doc---message-format"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-4" id="manifest-options-4">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---manifest-path"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-doc---frozen"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-doc---locked"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-doc---offline"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-5" id="common-options-5">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc-+toolchain"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-doc--h"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-doc---help"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-doc--Z"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-3" id="miscellaneous-options-3">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--j"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-doc---jobs"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h2><a class="header" href="#环境-5" id="环境-5">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-5" id="退出状态-5">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-8" id="examples-8">EXAMPLES</a></h2>
<ol>
<li>
<p>Build the local package documentation and its dependencies and output to
<code>target/doc</code>.</p>
<pre><code>cargo doc
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-6" id="see-also-6">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<h1><a class="header" href="#cargo-fetch1" id="cargo-fetch1">cargo-fetch(1)</a></h1>
<h2><a class="header" href="#name-7" id="name-7">NAME</a></h2>
<p>cargo-fetch - Fetch dependencies of a package from the network</p>
<h2><a class="header" href="#synopsis-7" id="synopsis-7">SYNOPSIS</a></h2>
<p><code>cargo fetch</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-7" id="description-7">DESCRIPTION</a></h2>
<p>If a <code>Cargo.lock</code> file is available, this command will ensure that all of the
git dependencies and/or registry dependencies are downloaded and locally
available. Subsequent Cargo commands never touch the network after a <code>cargo fetch</code> unless the lock file changes.</p>
<p>If the lock file is not available, then this command will generate the lock
file before fetching the dependencies.</p>
<p>If <code>--target</code> is not specified, then all target dependencies are fetched.</p>
<p>See also the <a href="https://crates.io/crates/cargo-prefetch">cargo-prefetch</a>
plugin which adds a command to download popular crates. This may be useful if
you plan to use Cargo without a network with the <code>--offline</code> flag.</p>
<h2><a class="header" href="#options-6" id="options-6">OPTIONS</a></h2>
<h3><a class="header" href="#fetch-options" id="fetch-options">Fetch options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---target"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Fetch 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
</dl>
<h3><a class="header" href="#display-options-5" id="display-options-5">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch--v"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fetch---verbose"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch--q"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fetch---quiet"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fetch---color"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-5" id="manifest-options-5">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---manifest-path"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-fetch---frozen"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fetch---locked"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-fetch---offline"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-6" id="common-options-6">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch-+toolchain"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fetch--h"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fetch---help"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fetch--Z"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-6" id="环境-6">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-6" id="退出状态-6">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-9" id="examples-9">EXAMPLES</a></h2>
<ol>
<li>
<p>Fetch all dependencies:</p>
<pre><code>cargo fetch
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-7" id="see-also-7">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<h1><a class="header" href="#cargo-fix1" id="cargo-fix1">cargo-fix(1)</a></h1>
<h2><a class="header" href="#name-8" id="name-8">NAME</a></h2>
<p>cargo-fix - Automatically fix lint warnings reported by rustc</p>
<h2><a class="header" href="#synopsis-8" id="synopsis-8">SYNOPSIS</a></h2>
<p><code>cargo fix</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-8" id="description-8">DESCRIPTION</a></h2>
<p>This Cargo subcommand will automatically take rustc's suggestions from
diagnostics like warnings and apply them to your source code. This is intended
to help automate tasks that rustc itself already knows how to tell you to fix!</p>
<p>Executing <code>cargo fix</code> will under the hood execute <a href="commands/cargo-check.html">cargo-check(1)</a>. Any warnings
applicable to your crate will be automatically fixed (if possible) and all
remaining warnings will be displayed when the check process is finished. For
example if you'd like to apply all fixes to the current package, you can run:</p>
<pre><code>cargo fix
</code></pre>
<p>which behaves the same as <code>cargo check --all-targets</code>.</p>
<p><code>cargo fix</code> is only capable of fixing code that is normally compiled with
<code>cargo check</code>. If code is conditionally enabled with optional features, you
will need to enable those features for that code to be analyzed:</p>
<pre><code>cargo fix --features foo
</code></pre>
<p>Similarly, other <code>cfg</code> expressions like platform-specific code will need to
pass <code>--target</code> to fix code for the given target.</p>
<pre><code>cargo fix --target x86_64-pc-windows-gnu
</code></pre>
<p>If you encounter any problems with <code>cargo fix</code> or otherwise have any questions
or feature requests please don't hesitate to file an issue at
<a href="https://github.com/rust-lang/cargo">https://github.com/rust-lang/cargo</a>.</p>
<h3><a class="header" href="#edition-migration" id="edition-migration">Edition migration</a></h3>
<p>The <code>cargo fix</code> subcommand can also be used to migrate a package from one
<a href="https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html">edition</a> to the next. The general procedure is:</p>
<ol>
<li>Run <code>cargo fix --edition</code>. Consider also using the <code>--all-features</code> flag if
your project has multiple features. You may also want to run <code>cargo fix --edition</code> multiple times with different <code>--target</code> flags if your project
has platform-specific code gated by <code>cfg</code> attributes.</li>
<li>Modify <code>Cargo.toml</code> to set the <a href="commands/../reference/manifest.html#the-edition-field">edition field</a> to the new edition.</li>
<li>Run your project tests to verify that everything still works. If new
warnings are issued, you may want to consider running <code>cargo fix</code> again
(without the <code>--edition</code> flag) to apply any suggestions given by the
compiler.</li>
</ol>
<p>And hopefully that's it! Just keep in mind of the caveats mentioned above that
<code>cargo fix</code> cannot update code for inactive features or <code>cfg</code> expressions.
Also, in some rare cases the compiler is unable to automatically migrate all
code to the new edition, and this may require manual changes after building
with the new edition.</p>
<h2><a class="header" href="#options-7" id="options-7">OPTIONS</a></h2>
<h3><a class="header" href="#fix-options" id="fix-options">Fix options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---broken-code"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---broken-code"></a><code>--broken-code</code></dt>
<dd class="option-desc">Fix code even if it already has compiler errors. This is useful if <code>cargo fix</code>
fails to apply the changes. It will apply the changes and leave the broken
code in the working directory for you to inspect and manually fix.</dd>
<dt class="option-term" id="option-cargo-fix---edition"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition"></a><code>--edition</code></dt>
<dd class="option-desc">Apply changes that will update the code to the next edition. This will not
update the edition in the <code>Cargo.toml</code> manifest, which must be updated
manually after <code>cargo fix --edition</code> has finished.</dd>
<dt class="option-term" id="option-cargo-fix---edition-idioms"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition-idioms"></a><code>--edition-idioms</code></dt>
<dd class="option-desc">Apply suggestions that will update code to the preferred style for the current
edition.</dd>
<dt class="option-term" id="option-cargo-fix---allow-no-vcs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-no-vcs"></a><code>--allow-no-vcs</code></dt>
<dd class="option-desc">Fix code even if a VCS was not detected.</dd>
<dt class="option-term" id="option-cargo-fix---allow-dirty"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Fix code even if the working directory has changes.</dd>
<dt class="option-term" id="option-cargo-fix---allow-staged"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-staged"></a><code>--allow-staged</code></dt>
<dd class="option-desc">Fix code even if the working directory has staged changes.</dd>
</dl>
<h3><a class="header" href="#选择包-5" id="选择包-5">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-fix--p"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-fix---package"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Fix指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-fix---workspace"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Fix 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-fix---all"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-fix---exclude"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection-4" id="target-selection-4">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo fix</code> will fix all targets
(<code>--all-targets</code> implied). Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>Passing target selection flags will fix only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-fix---lib"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Fix the package's library.</dd>
<dt class="option-term" id="option-cargo-fix---bin"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---bins"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Fix all binary targets.</dd>
<dt class="option-term" id="option-cargo-fix---example"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---examples"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Fix all example targets.</dd>
<dt class="option-term" id="option-cargo-fix---test"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---tests"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Fix all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---bench"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Fix the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-fix---benches"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Fix all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-fix---all-targets"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Fix all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-4" id="特性选择-4">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-fix---features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-fix---all-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-fix---no-default-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-4" id="compilation-options-4">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Fix 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-fix--r"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-fix---release"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---release"></a><code>--release</code></dt>
<dd class="option-desc">Fix optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-fix---profile"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Fix with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-fix---ignore-rust-version"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Fix the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-4" id="output-options-4">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target-dir"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-6" id="display-options-6">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--v"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-fix---verbose"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix--q"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-fix---quiet"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---color"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-fix---message-format"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-6" id="manifest-options-6">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---manifest-path"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-fix---frozen"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-fix---locked"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-fix---offline"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-7" id="common-options-7">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix-+toolchain"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-fix--h"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-fix---help"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-fix--Z"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-4" id="miscellaneous-options-4">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--j"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-fix---jobs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h2><a class="header" href="#环境-7" id="环境-7">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-7" id="退出状态-7">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-10" id="examples-10">EXAMPLES</a></h2>
<ol>
<li>
<p>Apply compiler suggestions to the local package:</p>
<pre><code>cargo fix
</code></pre>
</li>
<li>
<p>Update a package to prepare it for the next edition:</p>
<pre><code>cargo fix --edition
</code></pre>
</li>
<li>
<p>Apply suggested idioms for the current edition:</p>
<pre><code>cargo fix --edition-idioms
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-8" id="see-also-8">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-check.html">cargo-check(1)</a></p>
<h1><a class="header" href="#cargo-run1" id="cargo-run1">cargo-run(1)</a></h1>
<h2><a class="header" href="#name-9" id="name-9">NAME</a></h2>
<p>cargo-run - Run the current package</p>
<h2><a class="header" href="#synopsis-9" id="synopsis-9">SYNOPSIS</a></h2>
<p><code>cargo run</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2><a class="header" href="#description-9" id="description-9">DESCRIPTION</a></h2>
<p>Run a binary or example of the local package.</p>
<p>All the arguments following the two dashes (<code>--</code>) are passed to the binary to
run. If you're passing arguments to both Cargo and the binary, the ones after
<code>--</code> go to the binary, the ones before go to Cargo.</p>
<h2><a class="header" href="#options-8" id="options-8">OPTIONS</a></h2>
<h3><a class="header" href="#package-selection-2" id="package-selection-2">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-run--p"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-run---package"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to run. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3><a class="header" href="#target-selection-5" id="target-selection-5">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo run</code> will run the binary
target. If there are multiple binary targets, you must pass a target flag to
choose one. Or, the <code>default-run</code> field may be specified in the <code>[package]</code>
section of <code>Cargo.toml</code> to choose the name of the binary to run by default.</p>
<dl>
<dt class="option-term" id="option-cargo-run---bin"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---bin"></a><code>--bin</code> <em>name</em></dt>
<dd class="option-desc">Run the specified binary.</dd>
<dt class="option-term" id="option-cargo-run---example"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---example"></a><code>--example</code> <em>name</em></dt>
<dd class="option-desc">Run the specified example.</dd>
</dl>
<h3><a class="header" href="#特性选择-5" id="特性选择-5">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-run---features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-run---all-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-run---no-default-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-5" id="compilation-options-5">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Run 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-run--r"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-run---release"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---release"></a><code>--release</code></dt>
<dd class="option-desc">Run optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-run---profile"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Run with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-run---ignore-rust-version"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Run the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-5" id="output-options-5">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target-dir"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-7" id="display-options-7">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--v"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-run---verbose"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run--q"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-run---quiet"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---color"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-run---message-format"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-7" id="manifest-options-7">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---manifest-path"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-run---frozen"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-run---locked"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-run---offline"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-8" id="common-options-8">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run-+toolchain"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-run--h"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-run---help"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-run--Z"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-5" id="miscellaneous-options-5">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--j"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-run---jobs"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h2><a class="header" href="#环境-8" id="环境-8">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-8" id="退出状态-8">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-11" id="examples-11">EXAMPLES</a></h2>
<ol>
<li>
<p>Build the local package and run its main target (assuming only one binary):</p>
<pre><code>cargo run
</code></pre>
</li>
<li>
<p>Run an example with extra arguments:</p>
<pre><code>cargo run --example exname -- --exoption exarg1 exarg2
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-9" id="see-also-9">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<h1><a class="header" href="#cargo-rustc1" id="cargo-rustc1">cargo-rustc(1)</a></h1>
<h2><a class="header" href="#name-10" id="name-10">NAME</a></h2>
<p>cargo-rustc - Compile the current package, and pass extra options to the compiler</p>
<h2><a class="header" href="#synopsis-10" id="synopsis-10">SYNOPSIS</a></h2>
<p><code>cargo rustc</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2><a class="header" href="#description-10" id="description-10">DESCRIPTION</a></h2>
<p>The specified target for the current package (or package specified by <code>-p</code> if
provided) will be compiled along with all of its dependencies. The specified
<em>args</em> will all be passed to the final compiler invocation, not any of the
dependencies. Note that the compiler will still unconditionally receive
arguments such as <code>-L</code>, <code>--extern</code>, and <code>--crate-type</code>, and the specified
<em>args</em> will simply be added to the compiler invocation.</p>
<p>See <a href="https://doc.rust-lang.org/rustc/index.html">https://doc.rust-lang.org/rustc/index.html</a> for documentation on rustc
flags.</p>
<p>This command requires that only one target is being compiled when additional
arguments are provided. If more than one target is available for the current
package the filters of <code>--lib</code>, <code>--bin</code>, etc, must be used to select which
target is compiled.</p>
<p>To pass flags to all compiler processes spawned by Cargo, use the <code>RUSTFLAGS</code>
<a href="commands/../reference/environment-variables.html">environment variable</a> or the
<code>build.rustflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2><a class="header" href="#options-9" id="options-9">OPTIONS</a></h2>
<h3><a class="header" href="#package-selection-3" id="package-selection-3">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--p"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustc---package"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to build. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3><a class="header" href="#target-selection-6" id="target-selection-6">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo rustc</code> will build all
binary and library targets of the selected package.</p>
<p>Passing target selection flags will build only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---lib"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Build the package's library.</dd>
<dt class="option-term" id="option-cargo-rustc---bin"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---bins"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Build all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustc---example"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---examples"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Build all example targets.</dd>
<dt class="option-term" id="option-cargo-rustc---test"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---tests"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Build all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---bench"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustc---benches"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Build all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustc---all-targets"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-6" id="特性选择-6">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-rustc---all-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-rustc---no-default-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-6" id="compilation-options-6">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Build 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-rustc--r"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustc---release"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---release"></a><code>--release</code></dt>
<dd class="option-desc">Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustc---profile"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Build with the given profile.</p>
<p>The <code>rustc</code> subcommand will treat the following named profiles with special behaviors:</p>
<ul>
<li><code>check</code> — Builds in the same way as the <a href="commands/cargo-check.html">cargo-check(1)</a> command with
the <code>dev</code> profile.</li>
<li><code>test</code> — Builds in the same way as the <a href="commands/cargo-test.html">cargo-test(1)</a> command,
enabling building in test mode which will enable tests and enable the <code>test</code>
cfg option. See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc
tests</a> for more detail.</li>
<li><code>bench</code> — Builds in the same was as the <a href="commands/cargo-bench.html">cargo-bench(1)</a> command,
similar to the <code>test</code> profile.</li>
</ul>
<p>See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Build the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-6" id="output-options-6">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target-dir"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-8" id="display-options-8">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--v"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustc---verbose"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc--q"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustc---quiet"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---color"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustc---message-format"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-8" id="manifest-options-8">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---manifest-path"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-rustc---frozen"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustc---locked"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-rustc---offline"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-9" id="common-options-9">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc-+toolchain"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustc--h"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustc---help"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustc--Z"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-6" id="miscellaneous-options-6">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--j"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustc---jobs"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
<dt class="option-term" id="option-cargo-rustc---future-incompat-report"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2><a class="header" href="#环境-9" id="环境-9">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-9" id="退出状态-9">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-12" id="examples-12">EXAMPLES</a></h2>
<ol>
<li>
<p>Check if your package (not including dependencies) uses unsafe code:</p>
<pre><code>cargo rustc --lib -- -D unsafe-code
</code></pre>
</li>
<li>
<p>Try an experimental flag on the nightly compiler, such as this which prints
the size of every type:</p>
<pre><code>cargo rustc --lib -- -Z print-type-sizes
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-10" id="see-also-10">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a>, <a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a></p>
<h1><a class="header" href="#cargo-rustdoc1" id="cargo-rustdoc1">cargo-rustdoc(1)</a></h1>
<h2><a class="header" href="#name-11" id="name-11">NAME</a></h2>
<p>cargo-rustdoc - Build a package's documentation, using specified custom flags</p>
<h2><a class="header" href="#synopsis-11" id="synopsis-11">SYNOPSIS</a></h2>
<p><code>cargo rustdoc</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2><a class="header" href="#description-11" id="description-11">DESCRIPTION</a></h2>
<p>The specified target for the current package (or package specified by <code>-p</code> if
provided) will be documented with the specified <em>args</em> being passed to the
final rustdoc invocation. Dependencies will not be documented as part of this
command. Note that rustdoc will still unconditionally receive arguments such
as <code>-L</code>, <code>--extern</code>, and <code>--crate-type</code>, and the specified <em>args</em> will simply
be added to the rustdoc invocation.</p>
<p>See <a href="https://doc.rust-lang.org/rustdoc/index.html">https://doc.rust-lang.org/rustdoc/index.html</a> for documentation on rustdoc
flags.</p>
<p>This command requires that only one target is being compiled when additional
arguments are provided. If more than one target is available for the current
package the filters of <code>--lib</code>, <code>--bin</code>, etc, must be used to select which
target is compiled.</p>
<p>To pass flags to all rustdoc processes spawned by Cargo, use the
<code>RUSTDOCFLAGS</code> <a href="commands/../reference/environment-variables.html">environment variable</a>
or the <code>build.rustdocflags</code> <a href="commands/../reference/config.html">config value</a>.</p>
<h2><a class="header" href="#options-10" id="options-10">OPTIONS</a></h2>
<h3><a class="header" href="#documentation-options-1" id="documentation-options-1">Documentation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---open"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---open"></a><code>--open</code></dt>
<dd class="option-desc">Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</dd>
</dl>
<h3><a class="header" href="#package-selection-4" id="package-selection-4">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--p"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---package"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to document. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3><a class="header" href="#target-selection-7" id="target-selection-7">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo rustdoc</code> will document all
binary and library targets of the selected package. The binary will be skipped
if its name is the same as the lib target. Binaries are skipped if they have
<code>required-features</code> that are missing.</p>
<p>Passing target selection flags will document only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---lib"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Document the package's library.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bin"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bins"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Document all binary targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---example"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---examples"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Document all example targets.</dd>
<dt class="option-term" id="option-cargo-rustdoc---test"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---tests"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Document all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---bench"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Document the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-rustdoc---benches"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Document all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-targets"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Document all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-7" id="特性选择-7">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-rustdoc---no-default-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-7" id="compilation-options-7">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Document 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-rustdoc--r"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---release"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---release"></a><code>--release</code></dt>
<dd class="option-desc">Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-rustdoc---profile"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Document with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-rustdoc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Document the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-7" id="output-options-7">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target-dir"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-9" id="display-options-9">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--v"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---verbose"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc--q"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---quiet"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---color"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-rustdoc---message-format"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-9" id="manifest-options-9">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---manifest-path"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-rustdoc---frozen"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---locked"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-rustdoc---offline"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-10" id="common-options-10">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc-+toolchain"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-rustdoc--h"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-rustdoc---help"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-rustdoc--Z"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-7" id="miscellaneous-options-7">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--j"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-rustdoc---jobs"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h2><a class="header" href="#环境-10" id="环境-10">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-10" id="退出状态-10">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-13" id="examples-13">EXAMPLES</a></h2>
<ol>
<li>
<p>Build documentation with custom CSS included from a given file:</p>
<pre><code>cargo rustdoc --lib -- --extend-css extra.css
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-11" id="see-also-11">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-doc.html">cargo-doc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<h1><a class="header" href="#cargo-test1" id="cargo-test1">cargo-test(1)</a></h1>
<h2><a class="header" href="#name-12" id="name-12">NAME</a></h2>
<p>cargo-test - Execute unit and integration tests of a package</p>
<h2><a class="header" href="#synopsis-12" id="synopsis-12">SYNOPSIS</a></h2>
<p><code>cargo test</code> [<em>options</em>] [<em>testname</em>] [<code>--</code> <em>test-options</em>]</p>
<h2><a class="header" href="#description-12" id="description-12">DESCRIPTION</a></h2>
<p>Compile and execute unit and integration tests.</p>
<p>The test filtering argument <code>TESTNAME</code> and all the arguments following the two
dashes (<code>--</code>) are passed to the test binaries and thus to <em>libtest</em> (rustc's
built in unit-test and micro-benchmarking framework).  If you're passing
arguments to both Cargo and the binary, the ones after <code>--</code> go to the binary,
the ones before go to Cargo.  For details about libtest's arguments see the
output of <code>cargo test -- --help</code> and check out the rustc book's chapter on
how tests work at <a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>.</p>
<p>As an example, this will filter for tests with <code>foo</code> in their name and run them
on 3 threads in parallel:</p>
<pre><code>cargo test foo -- --test-threads 3
</code></pre>
<p>Tests are built with the <code>--test</code> option to <code>rustc</code> which creates an
executable with a <code>main</code> function that automatically runs all functions
annotated with the <code>#[test]</code> attribute in multiple threads. <code>#[bench]</code>
annotated functions will also be run with one iteration to verify that they
are functional.</p>
<p>The libtest harness may be disabled by setting <code>harness = false</code> in the target
manifest settings, in which case your code will need to provide its own <code>main</code>
function to handle running tests.</p>
<p>Documentation tests are also run by default, which is handled by <code>rustdoc</code>. It
extracts code samples from documentation comments and executes them. See the
<a href="https://doc.rust-lang.org/rustdoc/">rustdoc book</a> for more information on
writing doc tests.</p>
<h2><a class="header" href="#options-11" id="options-11">OPTIONS</a></h2>
<h3><a class="header" href="#test-options" id="test-options">Test Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---no-run"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-run"></a><code>--no-run</code></dt>
<dd class="option-desc">Compile, but don't run tests.</dd>
<dt class="option-term" id="option-cargo-test---no-fail-fast"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-fail-fast"></a><code>--no-fail-fast</code></dt>
<dd class="option-desc">Run all tests regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all tests
within the executable to completion, this flag only applies to the executable
as a whole.</dd>
</dl>
<h3><a class="header" href="#选择包-6" id="选择包-6">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-test--p"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-test---package"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Test指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-test---workspace"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Test 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-test---all"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all"></a><code>--all</code></dt>
<dd class="option-desc"><code>--workspace</code>的已废弃的别名。</dd>
<dt class="option-term" id="option-cargo-test---exclude"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#target-selection-8" id="target-selection-8">Target Selection</a></h3>
<p>When no target selection options are given, <code>cargo test</code> will build the
following targets of the selected packages:</p>
<ul>
<li>lib — used to link with binaries, examples, integration tests, and doc tests</li>
<li>bins (only if integration tests are built and required features are
available)</li>
<li>examples — to ensure they compile</li>
<li>lib as a unit test</li>
<li>bins as unit tests</li>
<li>integration tests</li>
<li>doc tests for the lib target</li>
</ul>
<p>The default behavior can be changed by setting the <code>test</code> flag for the target
in the manifest settings. Setting examples to <code>test = true</code> will build and run
the example as a test. Setting targets to <code>test = false</code> will stop them from
being tested by default. Target selection options that take a target by name
ignore the <code>test</code> flag and will always test the given target.</p>
<p>Doc tests for libraries may be disabled by setting <code>doctest = false</code> for the
library in the manifest.</p>
<p>Binary targets are automatically built if there is an integration test or
benchmark. This allows an integration test to execute the binary to exercise
and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code>
<a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a>
is set when the integration test is built so that it can use the
<a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> to locate the
executable.</p>
<p>Passing target selection flags will test only the specified
targets. </p>
<p>Note that <code>--bin</code>, <code>--example</code>, <code>--test</code> and <code>--bench</code> flags also 
support common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your 
shell accidentally expanding glob patterns before Cargo handles them, you must 
use single quotes or double quotes around each glob pattern.</p>
<dl>
<dt class="option-term" id="option-cargo-test---lib"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Test the package's library.</dd>
<dt class="option-term" id="option-cargo-test---bin"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---bins"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Test all binary targets.</dd>
<dt class="option-term" id="option-cargo-test---example"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---examples"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Test all example targets.</dd>
<dt class="option-term" id="option-cargo-test---test"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---test"></a><code>--test</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---tests"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---tests"></a><code>--tests</code></dt>
<dd class="option-desc">Test all targets in test mode that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---bench"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bench"></a><code>--bench</code> <em>name</em>...</dt>
<dd class="option-desc">Test the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</dd>
<dt class="option-term" id="option-cargo-test---benches"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---benches"></a><code>--benches</code></dt>
<dd class="option-desc">Test all targets in benchmark mode that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</dd>
<dt class="option-term" id="option-cargo-test---all-targets"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-targets"></a><code>--all-targets</code></dt>
<dd class="option-desc">Test all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</dd>
</dl>
<dl>
<dt class="option-term" id="option-cargo-test---doc"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---doc"></a><code>--doc</code></dt>
<dd class="option-desc">Test only the library's documentation. This cannot be mixed with other
target options.</dd>
</dl>
<h3><a class="header" href="#特性选择-8" id="特性选择-8">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-test---features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-test---all-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-test---no-default-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-8" id="compilation-options-8">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Test 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-test--r"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-test---release"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---release"></a><code>--release</code></dt>
<dd class="option-desc">Test optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-test---profile"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Test with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
<dt class="option-term" id="option-cargo-test---ignore-rust-version"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---ignore-rust-version"></a><code>--ignore-rust-version</code></dt>
<dd class="option-desc">Test the target even if the selected Rust compiler is older than the
required Rust version as configured in the project's <code>rust-version</code> field.</dd>
</dl>
<h3><a class="header" href="#output-options-8" id="output-options-8">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target-dir"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#display-options-10" id="display-options-10">Display Options</a></h3>
<p>By default the Rust test harness hides output from test execution to keep
results readable. Test output can be recovered (e.g., for debugging) by passing
<code>--nocapture</code> to the test binaries:</p>
<pre><code>cargo test -- --nocapture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--v"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-test---verbose"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test--q"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-test---quiet"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---color"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-test---message-format"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#manifest-options-10" id="manifest-options-10">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---manifest-path"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-test---frozen"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-test---locked"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-test---offline"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-11" id="common-options-11">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test-+toolchain"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-test--h"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-test---help"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-test--Z"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-8" id="miscellaneous-options-8">Miscellaneous Options</a></h3>
<p>The <code>--jobs</code> argument affects the building of the test executable but does not
affect how many threads are used when running the tests. The Rust test harness
includes an option to control the number of threads used:</p>
<pre><code>cargo test -j 2 -- --test-threads=2
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--j"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-test---jobs"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
<dt class="option-term" id="option-cargo-test---future-incompat-report"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---future-incompat-report"></a><code>--future-incompat-report</code></dt>
<dd class="option-desc">Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></dd>
</dl>
<h2><a class="header" href="#环境-11" id="环境-11">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-11" id="退出状态-11">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-14" id="examples-14">EXAMPLES</a></h2>
<ol>
<li>
<p>Execute all the unit and integration tests of the current package:</p>
<pre><code>cargo test
</code></pre>
</li>
<li>
<p>Run only tests whose names match against a filter string:</p>
<pre><code>cargo test name_filter
</code></pre>
</li>
<li>
<p>Run only a specific test within a specific integration test:</p>
<pre><code>cargo test --test int_test_name -- modname::test_name
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-12" id="see-also-12">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-bench.html">cargo-bench(1)</a></p>
<h1><a class="header" href="#manifest-commands-1" id="manifest-commands-1">Manifest Commands</a></h1>
<ul>
<li><a href="commands/cargo-generate-lockfile.html">cargo generate-lockfile</a></li>
<li><a href="commands/cargo-locate-project.html">cargo locate-project</a></li>
<li><a href="commands/cargo-metadata.html">cargo metadata</a></li>
<li><a href="commands/cargo-pkgid.html">cargo pkgid</a></li>
<li><a href="commands/cargo-tree.html">cargo tree</a></li>
<li><a href="commands/cargo-update.html">cargo update</a></li>
<li><a href="commands/cargo-vendor.html">cargo vendor</a></li>
<li><a href="commands/cargo-verify-project.html">cargo verify-project</a></li>
</ul>
<h1><a class="header" href="#cargo-generate-lockfile1" id="cargo-generate-lockfile1">cargo-generate-lockfile(1)</a></h1>
<h2><a class="header" href="#name-13" id="name-13">NAME</a></h2>
<p>cargo-generate-lockfile - Generate the lockfile for a package</p>
<h2><a class="header" href="#synopsis-13" id="synopsis-13">SYNOPSIS</a></h2>
<p><code>cargo generate-lockfile</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-13" id="description-13">DESCRIPTION</a></h2>
<p>This command will create the <code>Cargo.lock</code> lockfile for the current package or
workspace. If the lockfile already exists, it will be rebuilt with the latest
available version of every package.</p>
<p>See also <a href="commands/cargo-update.html">cargo-update(1)</a> which is also capable of creating a <code>Cargo.lock</code>
lockfile and has more options for controlling update behavior.</p>
<h2><a class="header" href="#options-12" id="options-12">OPTIONS</a></h2>
<h3><a class="header" href="#display-options-11" id="display-options-11">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile--v"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---verbose"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--q"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---quiet"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---color"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-11" id="manifest-options-11">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile---manifest-path"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---frozen"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---locked"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---offline"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-12" id="common-options-12">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile-+toolchain"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--h"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---help"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--Z"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-12" id="环境-12">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-12" id="退出状态-12">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-15" id="examples-15">EXAMPLES</a></h2>
<ol>
<li>
<p>Create or update the lockfile for the current package or workspace:</p>
<pre><code>cargo generate-lockfile
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-13" id="see-also-13">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a></p>
<h1><a class="header" href="#cargo-locate-project1" id="cargo-locate-project1">cargo-locate-project(1)</a></h1>
<h2><a class="header" href="#name-14" id="name-14">NAME</a></h2>
<p>cargo-locate-project - Print a JSON representation of a Cargo.toml file's location</p>
<h2><a class="header" href="#synopsis-14" id="synopsis-14">SYNOPSIS</a></h2>
<p><code>cargo locate-project</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-14" id="description-14">DESCRIPTION</a></h2>
<p>This command will print a JSON object to stdout with the full path to the
<code>Cargo.toml</code> manifest.</p>
<h2><a class="header" href="#options-13" id="options-13">OPTIONS</a></h2>
<dl>
<dt class="option-term" id="option-cargo-locate-project---workspace"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Locate the <code>Cargo.toml</code> at the root of the workspace, as opposed to the current
workspace member.</dd>
</dl>
<h3><a class="header" href="#display-options-12" id="display-options-12">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---message-format"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The representation in which to print the project location. Valid values:</p>
<ul>
<li><code>json</code> (default): JSON object with the path under the key &quot;root&quot;.</li>
<li><code>plain</code>: Just the path.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-locate-project--v"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-locate-project---verbose"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project--q"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-locate-project---quiet"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-locate-project---color"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-12" id="manifest-options-12">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---manifest-path"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
</dl>
<h3><a class="header" href="#common-options-13" id="common-options-13">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project-+toolchain"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-locate-project--h"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-locate-project---help"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-locate-project--Z"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-13" id="环境-13">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-13" id="退出状态-13">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-16" id="examples-16">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the path to the manifest based on the current directory:</p>
<pre><code>cargo locate-project
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-14" id="see-also-14">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<h1><a class="header" href="#cargo-metadata1" id="cargo-metadata1">cargo-metadata(1)</a></h1>
<h2><a class="header" href="#name-15" id="name-15">NAME</a></h2>
<p>cargo-metadata - Machine-readable metadata about the current package</p>
<h2><a class="header" href="#synopsis-15" id="synopsis-15">SYNOPSIS</a></h2>
<p><code>cargo metadata</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-15" id="description-15">DESCRIPTION</a></h2>
<p>Output JSON to stdout containing information about the workspace members and
resolved dependencies of the current package.</p>
<p>It is recommended to include the <code>--format-version</code> flag to future-proof
your code to ensure the output is in the format you are expecting.</p>
<p>See the <a href="https://crates.io/crates/cargo_metadata">cargo_metadata crate</a>
for a Rust API for reading the metadata.</p>
<h2><a class="header" href="#output-format" id="output-format">OUTPUT FORMAT</a></h2>
<p>The output has the following format:</p>
<pre><code class="language-javascript">{
    /* Array of all packages in the workspace.
       It also includes all feature-enabled dependencies unless --no-deps is used.
    */
    &quot;packages&quot;: [
        {
            /* The name of the package. */
            &quot;name&quot;: &quot;my-package&quot;,
            /* The version of the package. */
            &quot;version&quot;: &quot;0.1.0&quot;,
            /* The Package ID, a unique identifier for referring to the package. */
            &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
            /* The license value from the manifest, or null. */
            &quot;license&quot;: &quot;MIT/Apache-2.0&quot;,
            /* The license-file value from the manifest, or null. */
            &quot;license_file&quot;: &quot;LICENSE&quot;,
            /* The description value from the manifest, or null. */
            &quot;description&quot;: &quot;Package description.&quot;,
            /* The source ID of the package. This represents where
               a package is retrieved from.
               This is null for path dependencies and workspace members.
               For other dependencies, it is a string with the format:
               - &quot;registry+URL&quot; for registry-based dependencies.
                 Example: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
               - &quot;git+URL&quot; for git-based dependencies.
                 Example: &quot;git+https://github.com/rust-lang/cargo?rev=5e85ba14aaa20f8133863373404cb0af69eeef2c#5e85ba14aaa20f8133863373404cb0af69eeef2c&quot;
            */
            &quot;source&quot;: null,
            /* Array of dependencies declared in the package's manifest. */
            &quot;dependencies&quot;: [
                {
                    /* The name of the dependency. */
                    &quot;name&quot;: &quot;bitflags&quot;,
                    /* The source ID of the dependency. May be null, see
                       description for the package source.
                    */
                    &quot;source&quot;: &quot;registry+https://github.com/rust-lang/crates.io-index&quot;,
                    /* The version requirement for the dependency.
                       Dependencies without a version requirement have a value of &quot;*&quot;.
                    */
                    &quot;req&quot;: &quot;^1.0&quot;,
                    /* The dependency kind.
                       &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                    */
                    &quot;kind&quot;: null,
                    /* If the dependency is renamed, this is the new name for
                       the dependency as a string.  null if it is not renamed.
                    */
                    &quot;rename&quot;: null,
                    /* Boolean of whether or not this is an optional dependency. */
                    &quot;optional&quot;: false,
                    /* Boolean of whether or not default features are enabled. */
                    &quot;uses_default_features&quot;: true,
                    /* Array of features enabled. */
                    &quot;features&quot;: [],
                    /* The target platform for the dependency.
                       null if not a target dependency.
                    */
                    &quot;target&quot;: &quot;cfg(windows)&quot;,
                    /* The file system path for a local path dependency.
                       not present if not a path dependency.
                    */
                    &quot;path&quot;: &quot;/path/to/dep&quot;,
                    /* A string of the URL of the registry this dependency is from.
                       If not specified or null, the dependency is from the default
                       registry (crates.io).
                    */
                    &quot;registry&quot;: null
                }
            ],
            /* Array of Cargo targets. */
            &quot;targets&quot;: [
                {
                    /* Array of target kinds.
                       - lib targets list the `crate-type` values from the
                         manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - binary is [&quot;bin&quot;]
                       - example is [&quot;example&quot;]
                       - integration test is [&quot;test&quot;]
                       - benchmark is [&quot;bench&quot;]
                       - build script is [&quot;custom-build&quot;]
                    */
                    &quot;kind&quot;: [
                        &quot;bin&quot;
                    ],
                    /* Array of crate types.
                       - lib and example libraries list the `crate-type` values
                         from the manifest such as &quot;lib&quot;, &quot;rlib&quot;, &quot;dylib&quot;,
                         &quot;proc-macro&quot;, etc. (default [&quot;lib&quot;])
                       - all other target kinds are [&quot;bin&quot;]
                    */
                    &quot;crate_types&quot;: [
                        &quot;bin&quot;
                    ],
                    /* The name of the target. */
                    &quot;name&quot;: &quot;my-package&quot;,
                    /* Absolute path to the root source file of the target. */
                    &quot;src_path&quot;: &quot;/path/to/my-package/src/main.rs&quot;,
                    /* The Rust edition of the target.
                       Defaults to the package edition.
                    */
                    &quot;edition&quot;: &quot;2018&quot;,
                    /* Array of required features.
                       This property is not included if no required features are set.
                    */
                    &quot;required-features&quot;: [&quot;feat1&quot;],
                    /* Whether the target should be documented by `cargo doc`. */
                    &quot;doc&quot;: true,
                    /* Whether or not this target has doc tests enabled, and
                       the target is compatible with doc testing.
                    */
                    &quot;doctest&quot;: false,
                    /* Whether or not this target should be built and run with `--test`
                    */
                    &quot;test&quot;: true
                }
            ],
            /* Set of features defined for the package.
               Each feature maps to an array of features or dependencies it
               enables.
            */
            &quot;features&quot;: {
                &quot;default&quot;: [
                    &quot;feat1&quot;
                ],
                &quot;feat1&quot;: [],
                &quot;feat2&quot;: []
            },
            /* Absolute path to this package's manifest. */
            &quot;manifest_path&quot;: &quot;/path/to/my-package/Cargo.toml&quot;,
            /* Package metadata.
               This is null if no metadata is specified.
            */
            &quot;metadata&quot;: {
                &quot;docs&quot;: {
                    &quot;rs&quot;: {
                        &quot;all-features&quot;: true
                    }
                }
            },
            /* List of registries to which this package may be published.
               Publishing is unrestricted if null, and forbidden if an empty array. */
            &quot;publish&quot;: [
                &quot;crates-io&quot;
            ],
            /* Array of authors from the manifest.
               Empty array if no authors specified.
            */
            &quot;authors&quot;: [
                &quot;Jane Doe &lt;user@example.com&gt;&quot;
            ],
            /* Array of categories from the manifest. */
            &quot;categories&quot;: [
                &quot;command-line-utilities&quot;
            ],
            /* Optional string that is the default binary picked by cargo run. */
            &quot;default_run&quot;: null,
            /* Optional string that is the minimum supported rust version */
            &quot;rust_version&quot;: &quot;1.56&quot;,
            /* Array of keywords from the manifest. */
            &quot;keywords&quot;: [
                &quot;cli&quot;
            ],
            /* The readme value from the manifest or null if not specified. */
            &quot;readme&quot;: &quot;README.md&quot;,
            /* The repository value from the manifest or null if not specified. */
            &quot;repository&quot;: &quot;https://github.com/rust-lang/cargo&quot;,
            /* The homepage value from the manifest or null if not specified. */
            &quot;homepage&quot;: &quot;https://rust-lang.org&quot;,
            /* The documentation value from the manifest or null if not specified. */
            &quot;documentation&quot;: &quot;https://doc.rust-lang.org/stable/std&quot;,
            /* The default edition of the package.
               Note that individual targets may have different editions.
            */
            &quot;edition&quot;: &quot;2018&quot;,
            /* Optional string that is the name of a native library the package
               is linking to.
            */
            &quot;links&quot;: null,
        }
    ],
    /* Array of members of the workspace.
       Each entry is the Package ID for the package.
    */
    &quot;workspace_members&quot;: [
        &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
    ],
    // The resolved dependency graph for the entire workspace. The enabled
    // features are based on the enabled features for the &quot;current&quot; package.
    // Inactivated optional dependencies are not listed.
    //
    // This is null if --no-deps is specified.
    //
    // By default, this includes all dependencies for all target platforms.
    // The `--filter-platform` flag may be used to narrow to a specific
    // target triple.
    &quot;resolve&quot;: {
        /* Array of nodes within the dependency graph.
           Each node is a package.
        */
        &quot;nodes&quot;: [
            {
                /* The Package ID of this node. */
                &quot;id&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;,
                /* The dependencies of this package, an array of Package IDs. */
                &quot;dependencies&quot;: [
                    &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;
                ],
                /* The dependencies of this package. This is an alternative to
                   &quot;dependencies&quot; which contains additional information. In
                   particular, this handles renamed dependencies.
                */
                &quot;deps&quot;: [
                    {
                        /* The name of the dependency's library target.
                           If this is a renamed dependency, this is the new
                           name.
                        */
                        &quot;name&quot;: &quot;bitflags&quot;,
                        /* The Package ID of the dependency. */
                        &quot;pkg&quot;: &quot;bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
                        /* Array of dependency kinds. Added in Cargo 1.40. */
                        &quot;dep_kinds&quot;: [
                            {
                                /* The dependency kind.
                                   &quot;dev&quot;, &quot;build&quot;, or null for a normal dependency.
                                */
                                &quot;kind&quot;: null,
                                /* The target platform for the dependency.
                                   null if not a target dependency.
                                */
                                &quot;target&quot;: &quot;cfg(windows)&quot;
                            }
                        ]
                    }
                ],
                /* Array of features enabled on this package. */
                &quot;features&quot;: [
                    &quot;default&quot;
                ]
            }
        ],
        /* The root package of the workspace.
           This is null if this is a virtual workspace. Otherwise it is
           the Package ID of the root package.
        */
        &quot;root&quot;: &quot;my-package 0.1.0 (path+file:///path/to/my-package)&quot;
    },
    /* The absolute path to the build directory where Cargo places its output. */
    &quot;target_directory&quot;: &quot;/path/to/my-package/target&quot;,
    /* The version of the schema for this metadata structure.
       This will be changed if incompatible changes are ever made.
    */
    &quot;version&quot;: 1,
    /* The absolute path to the root of the workspace. */
    &quot;workspace_root&quot;: &quot;/path/to/my-package&quot;
    /* Workspace metadata.
       This is null if no metadata is specified. */
    &quot;metadata&quot;: {
        &quot;docs&quot;: {
            &quot;rs&quot;: {
                &quot;all-features&quot;: true
            }
        }
    }
}
</code></pre>
<h2><a class="header" href="#options-14" id="options-14">OPTIONS</a></h2>
<h3><a class="header" href="#output-options-9" id="output-options-9">Output Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---no-deps"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-deps"></a><code>--no-deps</code></dt>
<dd class="option-desc">Output information only about the workspace members and don't fetch
dependencies.</dd>
<dt class="option-term" id="option-cargo-metadata---format-version"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---format-version"></a><code>--format-version</code> <em>version</em></dt>
<dd class="option-desc">Specify the version of the output format to use. Currently <code>1</code> is the only
possible value.</dd>
<dt class="option-term" id="option-cargo-metadata---filter-platform"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---filter-platform"></a><code>--filter-platform</code> <em>triple</em></dt>
<dd class="option-desc">This filters the <code>resolve</code> output to only include dependencies for the
given target triple. Without this flag, the resolve includes all targets.</p>
<p>Note that the dependencies listed in the &quot;packages&quot; array still includes all
dependencies. Each package definition is intended to be an unaltered
reproduction of the information within <code>Cargo.toml</code>.</dd>
</dl>
<h3><a class="header" href="#特性选择-9" id="特性选择-9">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-metadata---features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-metadata---all-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-metadata---no-default-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#display-options-13" id="display-options-13">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata--v"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-metadata---verbose"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata--q"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-metadata---quiet"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-metadata---color"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-13" id="manifest-options-13">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---manifest-path"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-metadata---frozen"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-metadata---locked"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-metadata---offline"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-14" id="common-options-14">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata-+toolchain"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-metadata--h"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-metadata---help"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-metadata--Z"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-14" id="环境-14">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-14" id="退出状态-14">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-17" id="examples-17">EXAMPLES</a></h2>
<ol>
<li>
<p>Output JSON about the current package:</p>
<pre><code>cargo metadata --format-version=1
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-15" id="see-also-15">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<h1><a class="header" href="#cargo-pkgid1" id="cargo-pkgid1">cargo-pkgid(1)</a></h1>
<h2><a class="header" href="#name-16" id="name-16">NAME</a></h2>
<p>cargo-pkgid - Print a fully qualified package specification</p>
<h2><a class="header" href="#synopsis-16" id="synopsis-16">SYNOPSIS</a></h2>
<p><code>cargo pkgid</code> [<em>options</em>] [<em>spec</em>]</p>
<h2><a class="header" href="#description-16" id="description-16">DESCRIPTION</a></h2>
<p>Given a <em>spec</em> argument, print out the fully qualified package ID specifier
for a package or dependency in the current workspace. This command will
generate an error if <em>spec</em> is ambiguous as to which package it refers to in
the dependency graph. If no <em>spec</em> is given, then the specifier for the local
package is printed.</p>
<p>This command requires that a lockfile is available and dependencies have been
fetched.</p>
<p>A package specifier consists of a name, version, and source URL. You are
allowed to use partial specifiers to succinctly match a specific package as
long as it matches only one package. The format of a <em>spec</em> can be one of the
following:</p>
<table><thead><tr><th>SPEC Structure</th><th>Example SPEC</th></tr></thead><tbody>
<tr><td><em>name</em></td><td><code>bitflags</code></td></tr>
<tr><td><em>name</em><code>:</code><em>version</em></td><td><code>bitflags:1.0.4</code></td></tr>
<tr><td><em>url</em></td><td><code>https://github.com/rust-lang/cargo</code></td></tr>
<tr><td><em>url</em><code>#</code><em>version</em></td><td><code>https://github.com/rust-lang/cargo#0.33.0</code></td></tr>
<tr><td><em>url</em><code>#</code><em>name</em></td><td><code>https://github.com/rust-lang/crates.io-index#bitflags</code></td></tr>
<tr><td><em>url</em><code>#</code><em>name</em><code>:</code><em>version</em></td><td><code>https://github.com/rust-lang/cargo#crates-io:0.21.0</code></td></tr>
</tbody></table>
<h2><a class="header" href="#options-15" id="options-15">OPTIONS</a></h2>
<h3><a class="header" href="#package-selection-5" id="package-selection-5">Package Selection</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--p"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-pkgid---package"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">Get the package ID for the given package instead of the current package.</dd>
</dl>
<h3><a class="header" href="#display-options-14" id="display-options-14">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--v"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-pkgid---verbose"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid--q"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-pkgid---quiet"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-pkgid---color"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-14" id="manifest-options-14">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid---manifest-path"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-pkgid---frozen"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-pkgid---locked"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-pkgid---offline"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-15" id="common-options-15">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid-+toolchain"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-pkgid--h"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-pkgid---help"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-pkgid--Z"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-15" id="环境-15">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-15" id="退出状态-15">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-18" id="examples-18">EXAMPLES</a></h2>
<ol>
<li>
<p>Retrieve package specification for <code>foo</code> package:</p>
<pre><code>cargo pkgid foo
</code></pre>
</li>
<li>
<p>Retrieve package specification for version 1.0.0 of <code>foo</code>:</p>
<pre><code>cargo pkgid foo:1.0.0
</code></pre>
</li>
<li>
<p>Retrieve package specification for <code>foo</code> from crates.io:</p>
<pre><code>cargo pkgid https://github.com/rust-lang/crates.io-index#foo
</code></pre>
</li>
<li>
<p>Retrieve package specification for <code>foo</code> from a local package:</p>
<pre><code>cargo pkgid file:///path/to/local/package#foo
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-16" id="see-also-16">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<h1><a class="header" href="#cargo-tree1" id="cargo-tree1">cargo-tree(1)</a></h1>
<h2><a class="header" href="#name-17" id="name-17">NAME</a></h2>
<p>cargo-tree - Display a tree visualization of a dependency graph</p>
<h2><a class="header" href="#synopsis-17" id="synopsis-17">SYNOPSIS</a></h2>
<p><code>cargo tree</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-17" id="description-17">DESCRIPTION</a></h2>
<p>This command will display a tree of dependencies to the terminal. An example
of a simple project that depends on the &quot;rand&quot; package:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── rand v0.7.3
    ├── getrandom v0.1.14
    │   ├── cfg-if v0.1.10
    │   └── libc v0.2.68
    ├── libc v0.2.68 (*)
    ├── rand_chacha v0.2.2
    │   ├── ppv-lite86 v0.2.6
    │   └── rand_core v0.5.1
    │       └── getrandom v0.1.14 (*)
    └── rand_core v0.5.1 (*)
[build-dependencies]
└── cc v1.0.50
</code></pre>
<p>Packages marked with <code>(*)</code> have been &quot;de-duplicated&quot;. The dependencies for the
package have already been shown elsewhere in the graph, and so are not
repeated. Use the <code>--no-dedupe</code> option to repeat the duplicates.</p>
<p>The <code>-e</code> flag can be used to select the dependency kinds to display. The
&quot;features&quot; kind changes the output to display the features enabled by
each dependency. For example, <code>cargo tree -e features</code>:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── log feature &quot;serde&quot;
    └── log v0.4.8
        ├── serde v1.0.106
        └── cfg-if feature &quot;default&quot;
            └── cfg-if v0.1.10
</code></pre>
<p>In this tree, <code>myproject</code> depends on <code>log</code> with the <code>serde</code> feature. <code>log</code> in
turn depends on <code>cfg-if</code> with &quot;default&quot; features. When using <code>-e features</code> it
can be helpful to use <code>-i</code> flag to show how the features flow into a package.
See the examples below for more detail.</p>
<h2><a class="header" href="#options-16" id="options-16">OPTIONS</a></h2>
<h3><a class="header" href="#tree-options" id="tree-options">Tree Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--i"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--i"></a><code>-i</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-tree---invert"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---invert"></a><code>--invert</code> <em>spec</em></dt>
<dd class="option-desc">Show the reverse dependencies for the given package. This flag will invert
the tree and display the packages that depend on the given package.</p>
<p>Note that in a workspace, by default it will only display the package's
reverse dependencies inside the tree of the workspace member in the current
directory. The <code>--workspace</code> flag can be used to extend it so that it will
show the package's reverse dependencies across the entire workspace. The <code>-p</code>
flag can be used to display the package's reverse dependencies only with the
subtree of the package given to <code>-p</code>.</dd>
<dt class="option-term" id="option-cargo-tree---prune"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prune"></a><code>--prune</code> <em>spec</em></dt>
<dd class="option-desc">Prune the given package from the display of the dependency tree.</dd>
<dt class="option-term" id="option-cargo-tree---depth"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---depth"></a><code>--depth</code> <em>depth</em></dt>
<dd class="option-desc">Maximum display depth of the dependency tree. A depth of 1 displays the direct
dependencies, for example.</dd>
<dt class="option-term" id="option-cargo-tree---no-dedupe"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-dedupe"></a><code>--no-dedupe</code></dt>
<dd class="option-desc">Do not de-duplicate repeated dependencies. Usually, when a package has already
displayed its dependencies, further occurrences will not re-display its
dependencies, and will include a <code>(*)</code> to indicate it has already been shown.
This flag will cause those duplicates to be repeated.</dd>
<dt class="option-term" id="option-cargo-tree--d"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--d"></a><code>-d</code></dt>
<dt class="option-term" id="option-cargo-tree---duplicates"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---duplicates"></a><code>--duplicates</code></dt>
<dd class="option-desc">Show only dependencies which come in multiple versions (implies <code>--invert</code>).
When used with the <code>-p</code> flag, only shows duplicates within the subtree of the
given package.</p>
<p>It can be beneficial for build times and executable sizes to avoid building
that same package multiple times. This flag can help identify the offending
packages. You can then investigate if the package that depends on the
duplicate with the older version can be updated to the newer version so that
only one instance is built.</dd>
<dt class="option-term" id="option-cargo-tree--e"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--e"></a><code>-e</code> <em>kinds</em></dt>
<dt class="option-term" id="option-cargo-tree---edges"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---edges"></a><code>--edges</code> <em>kinds</em></dt>
<dd class="option-desc">The dependency kinds to display. Takes a comma separated list of values:</p>
<ul>
<li><code>all</code> — Show all edge kinds.</li>
<li><code>normal</code> — Show normal dependencies.</li>
<li><code>build</code> — Show build dependencies.</li>
<li><code>dev</code> — Show development dependencies.</li>
<li><code>features</code> — Show features enabled by each dependency. If this is the only
kind given, then it will automatically include the other dependency kinds.</li>
<li><code>no-normal</code> — Do not include normal dependencies.</li>
<li><code>no-build</code> — Do not include build dependencies.</li>
<li><code>no-dev</code> — Do not include development dependencies.</li>
<li><code>no-proc-macro</code> — Do not include procedural macro dependencies.</li>
</ul>
<p>The <code>normal</code>, <code>build</code>, <code>dev</code>, and <code>all</code> dependency kinds cannot be mixed with
<code>no-normal</code>, <code>no-build</code>, or <code>no-dev</code> dependency kinds.</p>
<p>The default is <code>normal,build,dev</code>.</dd>
<dt class="option-term" id="option-cargo-tree---target"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">Filter dependencies matching the given target-triple. The default is the host
platform. Use the value <code>all</code> to include <em>all</em> targets.</dd>
</dl>
<h3><a class="header" href="#tree-formatting-options" id="tree-formatting-options">Tree Formatting Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---charset"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---charset"></a><code>--charset</code> <em>charset</em></dt>
<dd class="option-desc">Chooses the character set to use for the tree. Valid values are &quot;utf8&quot; or
&quot;ascii&quot;. Default is &quot;utf8&quot;.</dd>
<dt class="option-term" id="option-cargo-tree--f"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--f"></a><code>-f</code> <em>format</em></dt>
<dt class="option-term" id="option-cargo-tree---format"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---format"></a><code>--format</code> <em>format</em></dt>
<dd class="option-desc">Set the format string for each package. The default is &quot;{p}&quot;.</p>
<p>This is an arbitrary string which will be used to display each package. The following
strings will be replaced with the corresponding value:</p>
<ul>
<li><code>{p}</code> — The package name.</li>
<li><code>{l}</code> — The package license.</li>
<li><code>{r}</code> — The package repository URL.</li>
<li><code>{f}</code> — Comma-separated list of package features that are enabled.</li>
<li><code>{lib}</code> — The name, as used in a <code>use</code> statement, of the package's library.</li>
</ul></dd>
<dt class="option-term" id="option-cargo-tree---prefix"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prefix"></a><code>--prefix</code> <em>prefix</em></dt>
<dd class="option-desc">Sets how each line is displayed. The <em>prefix</em> value can be one of:</p>
<ul>
<li><code>indent</code> (default) — Shows each line indented as a tree.</li>
<li><code>depth</code> — Show as a list, with the numeric depth printed before each entry.</li>
<li><code>none</code> — Show as a flat list.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#选择包-7" id="选择包-7">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-tree--p"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-tree---package"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Display指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-tree---workspace"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Display 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-tree---exclude"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#manifest-options-15" id="manifest-options-15">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---manifest-path"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-tree---frozen"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-tree---locked"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-tree---offline"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#特性选择-10" id="特性选择-10">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-tree---features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-tree---all-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-tree---no-default-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#display-options-15" id="display-options-15">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--v"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-tree---verbose"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree--q"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-tree---quiet"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-tree---color"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-16" id="common-options-16">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree-+toolchain"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-tree--h"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-tree---help"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-tree--Z"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-16" id="环境-16">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-16" id="退出状态-16">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-19" id="examples-19">EXAMPLES</a></h2>
<ol>
<li>
<p>Display the tree for the package in the current directory:</p>
<pre><code>cargo tree
</code></pre>
</li>
<li>
<p>Display all the packages that depend on the <code>syn</code> package:</p>
<pre><code>cargo tree -i syn
</code></pre>
</li>
<li>
<p>Show the features enabled on each package:</p>
<pre><code>cargo tree --format &quot;{p} {f}&quot;
</code></pre>
</li>
<li>
<p>Show all packages that are built multiple times. This can happen if multiple
semver-incompatible versions appear in the tree (like 1.0.0 and 2.0.0).</p>
<pre><code>cargo tree -d
</code></pre>
</li>
<li>
<p>Explain why features are enabled for the <code>syn</code> package:</p>
<pre><code>cargo tree -e features -i syn
</code></pre>
<p>The <code>-e features</code> flag is used to show features. The <code>-i</code> flag is used to
invert the graph so that it displays the packages that depend on <code>syn</code>. An
example of what this would display:</p>
<pre><code>syn v1.0.17
├── syn feature &quot;clone-impls&quot;
│   └── syn feature &quot;default&quot;
│       └── rustversion v1.0.2
│           └── rustversion feature &quot;default&quot;
│               └── myproject v0.1.0 (/myproject)
│                   └── myproject feature &quot;default&quot; (command-line)
├── syn feature &quot;default&quot; (*)
├── syn feature &quot;derive&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;full&quot;
│   └── rustversion v1.0.2 (*)
├── syn feature &quot;parsing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;printing&quot;
│   └── syn feature &quot;default&quot; (*)
├── syn feature &quot;proc-macro&quot;
│   └── syn feature &quot;default&quot; (*)
└── syn feature &quot;quote&quot;
    ├── syn feature &quot;printing&quot; (*)
    └── syn feature &quot;proc-macro&quot; (*)
</code></pre>
<p>To read this graph, you can follow the chain for each feature from the root
to see why it is included. For example, the &quot;full&quot; feature is added by the
<code>rustversion</code> crate which is included from <code>myproject</code> (with the default
features), and <code>myproject</code> is the package selected on the command-line. All
of the other <code>syn</code> features are added by the &quot;default&quot; feature (&quot;quote&quot; is
added by &quot;printing&quot; and &quot;proc-macro&quot;, both of which are default features).</p>
<p>If you're having difficulty cross-referencing the de-duplicated <code>(*)</code>
entries, try with the <code>--no-dedupe</code> flag to get the full output.</p>
</li>
</ol>
<h2><a class="header" href="#see-also-17" id="see-also-17">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<h1><a class="header" href="#cargo-update1" id="cargo-update1">cargo-update(1)</a></h1>
<h2><a class="header" href="#name-18" id="name-18">NAME</a></h2>
<p>cargo-update - Update dependencies as recorded in the local lock file</p>
<h2><a class="header" href="#synopsis-18" id="synopsis-18">SYNOPSIS</a></h2>
<p><code>cargo update</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-18" id="description-18">DESCRIPTION</a></h2>
<p>This command will update dependencies in the <code>Cargo.lock</code> file to the latest
version. If the <code>Cargo.lock</code> file does not exist, it will be created with the
latest available versions.</p>
<h2><a class="header" href="#options-17" id="options-17">OPTIONS</a></h2>
<h3><a class="header" href="#update-options" id="update-options">Update Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--p"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-update---package"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Update only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</p>
<p>If packages are specified with the <code>-p</code> flag, then a conservative update of
the lockfile will be performed. This means that only the dependency specified
by SPEC will be updated. Its transitive dependencies will be updated only if
SPEC cannot be updated without updating dependencies.  All other dependencies
will remain locked at their currently recorded versions.</p>
<p>If <code>-p</code> is not specified, all dependencies are updated.</dd>
<dt class="option-term" id="option-cargo-update---aggressive"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---aggressive"></a><code>--aggressive</code></dt>
<dd class="option-desc">When used with <code>-p</code>, dependencies of <em>spec</em> are forced to update as well.
Cannot be used with <code>--precise</code>.</dd>
<dt class="option-term" id="option-cargo-update---precise"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---precise"></a><code>--precise</code> <em>precise</em></dt>
<dd class="option-desc">When used with <code>-p</code>, allows you to specify a specific version number to set
the package to. If the package comes from a git repository, this can be a git
revision (such as a SHA hash or tag).</dd>
<dt class="option-term" id="option-cargo-update--w"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--w"></a><code>-w</code></dt>
<dt class="option-term" id="option-cargo-update---workspace"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Attempt to update only packages defined in the workspace. Other packages
are updated only if they don't already exist in the lockfile. This
option is useful for updating <code>Cargo.lock</code> after you've changed version
numbers in <code>Cargo.toml</code>.</dd>
<dt class="option-term" id="option-cargo-update---dry-run"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Displays what would be updated, but doesn't actually write the lockfile.</dd>
</dl>
<h3><a class="header" href="#display-options-16" id="display-options-16">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--v"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-update---verbose"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update--q"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-update---quiet"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-update---color"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-16" id="manifest-options-16">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update---manifest-path"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-update---frozen"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-update---locked"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-update---offline"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-17" id="common-options-17">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update-+toolchain"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-update--h"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-update---help"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-update--Z"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-17" id="环境-17">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-17" id="退出状态-17">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-20" id="examples-20">EXAMPLES</a></h2>
<ol>
<li>
<p>Update all dependencies in the lockfile:</p>
<pre><code>cargo update
</code></pre>
</li>
<li>
<p>Update only specific dependencies:</p>
<pre><code>cargo update -p foo -p bar
</code></pre>
</li>
<li>
<p>Set a specific dependency to a specific version:</p>
<pre><code>cargo update -p foo --precise 1.2.3
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-18" id="see-also-18">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<h1><a class="header" href="#cargo-vendor1" id="cargo-vendor1">cargo-vendor(1)</a></h1>
<h2><a class="header" href="#name-19" id="name-19">NAME</a></h2>
<p>cargo-vendor - Vendor all dependencies locally</p>
<h2><a class="header" href="#synopsis-19" id="synopsis-19">SYNOPSIS</a></h2>
<p><code>cargo vendor</code> [<em>options</em>] [<em>path</em>]</p>
<h2><a class="header" href="#description-19" id="description-19">DESCRIPTION</a></h2>
<p>This cargo subcommand will vendor all crates.io and git dependencies for a
project into the specified directory at <code>&lt;path&gt;</code>. After this command completes
the vendor directory specified by <code>&lt;path&gt;</code> will contain all remote sources from
dependencies specified. Additional manifests beyond the default one can be
specified with the <code>-s</code> option.</p>
<p>The <code>cargo vendor</code> command will also print out the configuration necessary
to use the vendored sources, which you will need to add to <code>.cargo/config.toml</code>.</p>
<h2><a class="header" href="#options-18" id="options-18">OPTIONS</a></h2>
<h3><a class="header" href="#vendor-options" id="vendor-options">Vendor Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--s"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--s"></a><code>-s</code> <em>manifest</em></dt>
<dt class="option-term" id="option-cargo-vendor---sync"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---sync"></a><code>--sync</code> <em>manifest</em></dt>
<dd class="option-desc">Specify extra <code>Cargo.toml</code> manifests to workspaces which should also be
vendored and synced to the output.</dd>
<dt class="option-term" id="option-cargo-vendor---no-delete"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---no-delete"></a><code>--no-delete</code></dt>
<dd class="option-desc">Don't delete the &quot;vendor&quot; directory when vendoring, but rather keep all
existing contents of the vendor directory</dd>
<dt class="option-term" id="option-cargo-vendor---respect-source-config"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---respect-source-config"></a><code>--respect-source-config</code></dt>
<dd class="option-desc">Instead of ignoring <code>[source]</code> configuration by default in <code>.cargo/config.toml</code>
read it and use it when downloading crates from crates.io, for example</dd>
<dt class="option-term" id="option-cargo-vendor---versioned-dirs"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---versioned-dirs"></a><code>--versioned-dirs</code></dt>
<dd class="option-desc">Normally versions are only added to disambiguate multiple versions of the
same package. This option causes all directories in the &quot;vendor&quot; directory
to be versioned, which makes it easier to track the history of vendored
packages over time, and can help with the performance of re-vendoring when
only a subset of the packages have changed.</dd>
</dl>
<h3><a class="header" href="#manifest-options-17" id="manifest-options-17">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor---manifest-path"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-vendor---frozen"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-vendor---locked"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-vendor---offline"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#display-options-17" id="display-options-17">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--v"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-vendor---verbose"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor--q"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-vendor---quiet"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-vendor---color"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-18" id="common-options-18">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor-+toolchain"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-vendor--h"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-vendor---help"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-vendor--Z"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-18" id="环境-18">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-18" id="退出状态-18">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-21" id="examples-21">EXAMPLES</a></h2>
<ol>
<li>
<p>Vendor all dependencies into a local &quot;vendor&quot; folder</p>
<pre><code>cargo vendor
</code></pre>
</li>
<li>
<p>Vendor all dependencies into a local &quot;third-party/vendor&quot; folder</p>
<pre><code>cargo vendor third-party/vendor
</code></pre>
</li>
<li>
<p>Vendor the current workspace as well as another to &quot;vendor&quot;</p>
<pre><code>cargo vendor -s ../path/to/Cargo.toml
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-19" id="see-also-19">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<h1><a class="header" href="#cargo-verify-project1" id="cargo-verify-project1">cargo-verify-project(1)</a></h1>
<h2><a class="header" href="#name-20" id="name-20">NAME</a></h2>
<p>cargo-verify-project - Check correctness of crate manifest</p>
<h2><a class="header" href="#synopsis-20" id="synopsis-20">SYNOPSIS</a></h2>
<p><code>cargo verify-project</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-20" id="description-20">DESCRIPTION</a></h2>
<p>This command will parse the local manifest and check its validity. It emits a
JSON object with the result. A successful validation will display:</p>
<pre><code>{&quot;success&quot;:&quot;true&quot;}
</code></pre>
<p>An invalid workspace will display:</p>
<pre><code>{&quot;invalid&quot;:&quot;human-readable error message&quot;}
</code></pre>
<h2><a class="header" href="#options-19" id="options-19">OPTIONS</a></h2>
<h3><a class="header" href="#display-options-18" id="display-options-18">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project--v"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-verify-project---verbose"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project--q"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-verify-project---quiet"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-verify-project---color"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#manifest-options-18" id="manifest-options-18">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project---manifest-path"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-verify-project---frozen"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-verify-project---locked"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-verify-project---offline"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#common-options-19" id="common-options-19">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-verify-project-+toolchain"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-verify-project--h"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-verify-project---help"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-verify-project--Z"><a class="option-anchor" href="commands/cargo-verify-project.html#option-cargo-verify-project--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-19" id="环境-19">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#exit-status" id="exit-status">EXIT STATUS</a></h2>
<ul>
<li><code>0</code>: The workspace is OK.</li>
<li><code>1</code>: The workspace is invalid.</li>
</ul>
<h2><a class="header" href="#examples-22" id="examples-22">EXAMPLES</a></h2>
<ol>
<li>
<p>Check the current workspace for errors:</p>
<pre><code>cargo verify-project
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-20" id="see-also-20">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a></p>
<h1><a class="header" href="#package-commands-1" id="package-commands-1">Package Commands</a></h1>
<ul>
<li><a href="commands/cargo-init.html">cargo init</a></li>
<li><a href="commands/cargo-install.html">cargo install</a></li>
<li><a href="commands/cargo-new.html">cargo new</a></li>
<li><a href="commands/cargo-search.html">cargo search</a></li>
<li><a href="commands/cargo-uninstall.html">cargo uninstall</a></li>
</ul>
<h1><a class="header" href="#cargo-init1" id="cargo-init1">cargo-init(1)</a></h1>
<h2><a class="header" href="#name-21" id="name-21">NAME</a></h2>
<p>cargo-init - Create a new Cargo package in an existing directory</p>
<h2><a class="header" href="#synopsis-21" id="synopsis-21">SYNOPSIS</a></h2>
<p><code>cargo init</code> [<em>options</em>] [<em>path</em>]</p>
<h2><a class="header" href="#description-21" id="description-21">DESCRIPTION</a></h2>
<p>This command will create a new Cargo manifest in the current directory. Give a
path as an argument to create in the given directory.</p>
<p>If there are typically-named Rust source files already in the directory, those
will be used. If not, then a sample <code>src/main.rs</code> file will be created, or
<code>src/lib.rs</code> if <code>--lib</code> is passed.</p>
<p>If the directory is not already in a VCS repository, then a new repository
is created (see <code>--vcs</code> below).</p>
<p>See <a href="commands/cargo-new.html">cargo-new(1)</a> for a similar command which will create a new package in
a new directory.</p>
<h2><a class="header" href="#options-20" id="options-20">OPTIONS</a></h2>
<h3><a class="header" href="#init-options" id="init-options">Init Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init---bin"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---bin"></a><code>--bin</code></dt>
<dd class="option-desc">Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-init---lib"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Create a package with a library target (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-init---edition"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">Specify the Rust edition to use. Default is 2021.
Possible values: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-init---name"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">Set the package name. Defaults to the directory name.</dd>
<dt class="option-term" id="option-cargo-init---vcs"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</dd>
<dt class="option-term" id="option-cargo-init---registry"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</dd>
</dl>
<h3><a class="header" href="#display-options-19" id="display-options-19">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init--v"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-init---verbose"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init--q"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-init---quiet"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-init---color"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-20" id="common-options-20">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init-+toolchain"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-init--h"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-init---help"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-init--Z"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-20" id="环境-20">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-19" id="退出状态-19">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-23" id="examples-23">EXAMPLES</a></h2>
<ol>
<li>
<p>Create a binary Cargo package in the current directory:</p>
<pre><code>cargo init
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-21" id="see-also-21">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-new.html">cargo-new(1)</a></p>
<h1><a class="header" href="#cargo-install1" id="cargo-install1">cargo-install(1)</a></h1>
<h2><a class="header" href="#name-22" id="name-22">NAME</a></h2>
<p>cargo-install - Build and install a Rust binary</p>
<h2><a class="header" href="#synopsis-22" id="synopsis-22">SYNOPSIS</a></h2>
<p><code>cargo install</code> [<em>options</em>] <em>crate</em>...<br />
<code>cargo install</code> [<em>options</em>] <code>--path</code> <em>path</em><br />
<code>cargo install</code> [<em>options</em>] <code>--git</code> <em>url</em> [<em>crate</em>...]<br />
<code>cargo install</code> [<em>options</em>] <code>--list</code></p>
<h2><a class="header" href="#description-22" id="description-22">DESCRIPTION</a></h2>
<p>This command manages Cargo's local set of installed binary crates. Only
packages which have executable <code>[[bin]]</code> or <code>[[example]]</code> targets can be
installed, and all executables are installed into the installation root's
<code>bin</code> folder.</p>
<p>The installation root is determined, in order of precedence:</p>
<ul>
<li><code>--root</code> option</li>
<li><code>CARGO_INSTALL_ROOT</code> environment variable</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code> environment variable</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<p>There are multiple sources from which a crate can be installed. The default
location is crates.io but the <code>--git</code>, <code>--path</code>, and <code>--registry</code> flags can
change this source. If the source contains more than one package (such as
crates.io or a git repository with multiple crates) the <em>crate</em> argument is
required to indicate which crate should be installed.</p>
<p>Crates from crates.io can optionally specify the version they wish to install
via the <code>--version</code> flags, and similarly packages from git repositories can
optionally specify the branch, tag, or revision that should be installed. If a
crate has multiple binaries, the <code>--bin</code> argument can selectively install only
one of them, and if you'd rather install examples the <code>--example</code> argument can
be used as well.</p>
<p>If the package is already installed, Cargo will reinstall it if the installed
version does not appear to be up-to-date. If any of the following values
change, then Cargo will reinstall the package:</p>
<ul>
<li>The package version and source.</li>
<li>The set of binary names installed.</li>
<li>The chosen features.</li>
<li>The profile (<code>--profile</code>).</li>
<li>The target (<code>--target</code>).</li>
</ul>
<p>Installing with <code>--path</code> will always build and install, unless there are
conflicting binaries from another package. The <code>--force</code> flag may be used to
force Cargo to always reinstall the package.</p>
<p>If the source is crates.io or <code>--git</code> then by default the crate will be built
in a temporary target directory. To avoid this, the target directory can be
specified by setting the <code>CARGO_TARGET_DIR</code> environment variable to a relative
path. In particular, this can be useful for caching build artifacts on
continuous integration systems.</p>
<p>By default, the <code>Cargo.lock</code> file that is included with the package will be
ignored. This means that Cargo will recompute which versions of dependencies
to use, possibly using newer versions that have been released since the
package was published. The <code>--locked</code> flag can be used to force Cargo to use
the packaged <code>Cargo.lock</code> file if it is available. This may be useful for
ensuring reproducible builds, to use the exact same set of dependencies that
were available when the package was published. It may also be useful if a
newer version of a dependency is published that no longer builds on your
system, or has other problems. The downside to using <code>--locked</code> is that you
will not receive any fixes or updates to any dependency. Note that Cargo did
not start publishing <code>Cargo.lock</code> files until version 1.37, which means
packages published with prior versions will not have a <code>Cargo.lock</code> file
available.</p>
<h2><a class="header" href="#options-21" id="options-21">OPTIONS</a></h2>
<h3><a class="header" href="#install-options" id="install-options">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---vers"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---vers"></a><code>--vers</code> <em>version</em></dt>
<dt class="option-term" id="option-cargo-install---version"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---version"></a><code>--version</code> <em>version</em></dt>
<dd class="option-desc">Specify a version to install. This may be a <a href="commands/../reference/specifying-dependencies.html">version
requirement</a>, like <code>~1.2</code>, to have Cargo
select the newest version from the given requirement. If the version does not
have a requirement operator (such as <code>^</code> or <code>~</code>), then it must be in the form
<em>MAJOR.MINOR.PATCH</em>, and will install exactly that version; it is <em>not</em>
treated as a caret requirement like Cargo dependencies are.</dd>
<dt class="option-term" id="option-cargo-install---git"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---git"></a><code>--git</code> <em>url</em></dt>
<dd class="option-desc">Git URL to install the specified crate from.</dd>
<dt class="option-term" id="option-cargo-install---branch"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---branch"></a><code>--branch</code> <em>branch</em></dt>
<dd class="option-desc">Branch to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---tag"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---tag"></a><code>--tag</code> <em>tag</em></dt>
<dd class="option-desc">Tag to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---rev"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---rev"></a><code>--rev</code> <em>sha</em></dt>
<dd class="option-desc">Specific commit to use when installing from git.</dd>
<dt class="option-term" id="option-cargo-install---path"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---path"></a><code>--path</code> <em>path</em></dt>
<dd class="option-desc">Filesystem path to local crate to install.</dd>
<dt class="option-term" id="option-cargo-install---list"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---list"></a><code>--list</code></dt>
<dd class="option-desc">List all installed packages and their versions.</dd>
<dt class="option-term" id="option-cargo-install--f"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--f"></a><code>-f</code></dt>
<dt class="option-term" id="option-cargo-install---force"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---force"></a><code>--force</code></dt>
<dd class="option-desc">Force overwriting existing crates or binaries. This can be used if a package
has installed a binary with the same name as another package. This is also
useful if something has changed on the system that you want to rebuild with,
such as a newer version of <code>rustc</code>.</dd>
<dt class="option-term" id="option-cargo-install---no-track"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-track"></a><code>--no-track</code></dt>
<dd class="option-desc">By default, Cargo keeps track of the installed packages with a metadata file
stored in the installation root directory. This flag tells Cargo not to use or
create that file. With this flag, Cargo will refuse to overwrite any existing
files unless the <code>--force</code> flag is used. This also disables Cargo's ability to
protect against multiple concurrent invocations of Cargo installing at the
same time.</dd>
<dt class="option-term" id="option-cargo-install---bin"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified binary.</dd>
<dt class="option-term" id="option-cargo-install---bins"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bins"></a><code>--bins</code></dt>
<dd class="option-desc">Install all binaries.</dd>
<dt class="option-term" id="option-cargo-install---example"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---example"></a><code>--example</code> <em>name</em>...</dt>
<dd class="option-desc">Install only the specified example.</dd>
<dt class="option-term" id="option-cargo-install---examples"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---examples"></a><code>--examples</code></dt>
<dd class="option-desc">Install all examples.</dd>
<dt class="option-term" id="option-cargo-install---root"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to install packages into.</dd>
<dt class="option-term" id="option-cargo-install---registry"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
<dt class="option-term" id="option-cargo-install---index"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
</dl>
<h3><a class="header" href="#特性选择-11" id="特性选择-11">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-install---features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-install---all-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-install---no-default-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#compilation-options-9" id="compilation-options-9">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---target"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Install 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-install---target-dir"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下位于该平台临时目录下的一个新的临时文件夹。</p>
<p>当指定 <code>--path</code>标志参数时，若未指定<code>--target-dir</code>，则默认会使用工作区中的<code>target</code>目录。</dd>
<dt class="option-term" id="option-cargo-install---debug"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---debug"></a><code>--debug</code></dt>
<dd class="option-desc">Build with the <code>dev</code> profile instead the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</dd>
<dt class="option-term" id="option-cargo-install---profile"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---profile"></a><code>--profile</code> <em>name</em></dt>
<dd class="option-desc">Install with the given profile.
See the <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</dd>
</dl>
<h3><a class="header" href="#manifest-options-19" id="manifest-options-19">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---frozen"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-install---locked"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-install---offline"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-9" id="miscellaneous-options-9">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--j"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-install---jobs"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h3><a class="header" href="#display-options-20" id="display-options-20">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--v"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-install---verbose"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install--q"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-install---quiet"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---color"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-install---message-format"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---message-format"></a><code>--message-format</code> <em>fmt</em></dt>
<dd class="option-desc">The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the &quot;short&quot; rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc's default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics in
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo's own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul></dd>
</dl>
<h3><a class="header" href="#common-options-21" id="common-options-21">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install-+toolchain"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-install--h"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-install---help"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-install--Z"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-21" id="环境-21">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-20" id="退出状态-20">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-24" id="examples-24">EXAMPLES</a></h2>
<ol>
<li>
<p>Install or upgrade a package from crates.io:</p>
<pre><code>cargo install ripgrep
</code></pre>
</li>
<li>
<p>Install or reinstall the package in the current directory:</p>
<pre><code>cargo install --path .
</code></pre>
</li>
<li>
<p>View the list of installed packages:</p>
<pre><code>cargo install --list
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-22" id="see-also-22">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a>, <a href="commands/cargo-search.html">cargo-search(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h1><a class="header" href="#cargo-new1" id="cargo-new1">cargo-new(1)</a></h1>
<h2><a class="header" href="#name-23" id="name-23">NAME</a></h2>
<p>cargo-new - Create a new Cargo package</p>
<h2><a class="header" href="#synopsis-23" id="synopsis-23">SYNOPSIS</a></h2>
<p><code>cargo new</code> [<em>options</em>] <em>path</em></p>
<h2><a class="header" href="#description-23" id="description-23">DESCRIPTION</a></h2>
<p>This command will create a new Cargo package in the given directory. This
includes a simple template with a <code>Cargo.toml</code> manifest, sample source file,
and a VCS ignore file. If the directory is not already in a VCS repository,
then a new repository is created (see <code>--vcs</code> below).</p>
<p>See <a href="commands/cargo-init.html">cargo-init(1)</a> for a similar command which will create a new manifest
in an existing directory.</p>
<h2><a class="header" href="#options-22" id="options-22">OPTIONS</a></h2>
<h3><a class="header" href="#new-options" id="new-options">New Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new---bin"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---bin"></a><code>--bin</code></dt>
<dd class="option-desc">Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</dd>
<dt class="option-term" id="option-cargo-new---lib"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---lib"></a><code>--lib</code></dt>
<dd class="option-desc">Create a package with a library target (<code>src/lib.rs</code>).</dd>
<dt class="option-term" id="option-cargo-new---edition"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---edition"></a><code>--edition</code> <em>edition</em></dt>
<dd class="option-desc">Specify the Rust edition to use. Default is 2021.
Possible values: 2015, 2018, 2021</dd>
<dt class="option-term" id="option-cargo-new---name"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---name"></a><code>--name</code> <em>name</em></dt>
<dd class="option-desc">Set the package name. Defaults to the directory name.</dd>
<dt class="option-term" id="option-cargo-new---vcs"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---vcs"></a><code>--vcs</code> <em>vcs</em></dt>
<dd class="option-desc">Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</dd>
<dt class="option-term" id="option-cargo-new---registry"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</dd>
</dl>
<h3><a class="header" href="#display-options-21" id="display-options-21">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new--v"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-new---verbose"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-new--q"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-new---quiet"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-new---color"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-22" id="common-options-22">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new-+toolchain"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-new--h"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-new---help"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-new--Z"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-22" id="环境-22">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-21" id="退出状态-21">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-25" id="examples-25">EXAMPLES</a></h2>
<ol>
<li>
<p>Create a binary Cargo package in the given directory:</p>
<pre><code>cargo new foo
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-23" id="see-also-23">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-init.html">cargo-init(1)</a></p>
<h1><a class="header" href="#cargo-search1" id="cargo-search1">cargo-search(1)</a></h1>
<h2><a class="header" href="#name-24" id="name-24">NAME</a></h2>
<p>cargo-search - Search packages in crates.io</p>
<h2><a class="header" href="#synopsis-24" id="synopsis-24">SYNOPSIS</a></h2>
<p><code>cargo search</code> [<em>options</em>] [<em>query</em>...]</p>
<h2><a class="header" href="#description-24" id="description-24">DESCRIPTION</a></h2>
<p>This performs a textual search for crates on <a href="https://crates.io">https://crates.io</a>. The matching
crates will be displayed along with their description in TOML format suitable
for copying into a <code>Cargo.toml</code> manifest.</p>
<h2><a class="header" href="#options-23" id="options-23">OPTIONS</a></h2>
<h3><a class="header" href="#search-options" id="search-options">Search Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search---limit"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---limit"></a><code>--limit</code> <em>limit</em></dt>
<dd class="option-desc">Limit the number of results (default: 10, max: 100).</dd>
<dt class="option-term" id="option-cargo-search---index"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-search---registry"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3><a class="header" href="#display-options-22" id="display-options-22">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search--v"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-search---verbose"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search--q"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-search---quiet"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-search---color"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-23" id="common-options-23">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search-+toolchain"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-search--h"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-search---help"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-search--Z"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-23" id="环境-23">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-22" id="退出状态-22">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-26" id="examples-26">EXAMPLES</a></h2>
<ol>
<li>
<p>Search for a package from crates.io:</p>
<pre><code>cargo search serde
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-24" id="see-also-24">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h1><a class="header" href="#cargo-uninstall1" id="cargo-uninstall1">cargo-uninstall(1)</a></h1>
<h2><a class="header" href="#name-25" id="name-25">NAME</a></h2>
<p>cargo-uninstall - Remove a Rust binary</p>
<h2><a class="header" href="#synopsis-25" id="synopsis-25">SYNOPSIS</a></h2>
<p><code>cargo uninstall</code> [<em>options</em>] [<em>spec</em>...]</p>
<h2><a class="header" href="#description-25" id="description-25">DESCRIPTION</a></h2>
<p>This command removes a package installed with <a href="commands/cargo-install.html">cargo-install(1)</a>. The <em>spec</em>
argument is a package ID specification of the package to remove (see
<a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a>).</p>
<p>By default all binaries are removed for a crate but the <code>--bin</code> and
<code>--example</code> flags can be used to only remove particular binaries.</p>
<p>The installation root is determined, in order of precedence:</p>
<ul>
<li><code>--root</code> option</li>
<li><code>CARGO_INSTALL_ROOT</code> environment variable</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">config value</a></li>
<li><code>CARGO_HOME</code> environment variable</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<h2><a class="header" href="#options-24" id="options-24">OPTIONS</a></h2>
<h3><a class="header" href="#install-options-1" id="install-options-1">Install Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--p"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--p"></a><code>-p</code></dt>
<dt class="option-term" id="option-cargo-uninstall---package"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package to uninstall.</dd>
<dt class="option-term" id="option-cargo-uninstall---bin"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---bin"></a><code>--bin</code> <em>name</em>...</dt>
<dd class="option-desc">Only uninstall the binary <em>name</em>.</dd>
<dt class="option-term" id="option-cargo-uninstall---root"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---root"></a><code>--root</code> <em>dir</em></dt>
<dd class="option-desc">Directory to uninstall packages from.</dd>
</dl>
<h3><a class="header" href="#display-options-23" id="display-options-23">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--v"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-uninstall---verbose"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall--q"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-uninstall---quiet"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-uninstall---color"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-24" id="common-options-24">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall-+toolchain"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-uninstall--h"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-uninstall---help"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-uninstall--Z"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-24" id="环境-24">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-23" id="退出状态-23">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-27" id="examples-27">EXAMPLES</a></h2>
<ol>
<li>
<p>Uninstall a previously installed package.</p>
<pre><code>cargo uninstall ripgrep
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-25" id="see-also-25">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a></p>
<h1><a class="header" href="#publishing-commands-1" id="publishing-commands-1">Publishing Commands</a></h1>
<ul>
<li><a href="commands/cargo-login.html">cargo login</a></li>
<li><a href="commands/cargo-owner.html">cargo owner</a></li>
<li><a href="commands/cargo-package.html">cargo package</a></li>
<li><a href="commands/cargo-publish.html">cargo publish</a></li>
<li><a href="commands/cargo-yank.html">cargo yank</a></li>
</ul>
<h1><a class="header" href="#cargo-login1" id="cargo-login1">cargo-login(1)</a></h1>
<h2><a class="header" href="#name-26" id="name-26">NAME</a></h2>
<p>cargo-login - Save an API token from the registry locally</p>
<h2><a class="header" href="#synopsis-26" id="synopsis-26">SYNOPSIS</a></h2>
<p><code>cargo login</code> [<em>options</em>] [<em>token</em>]</p>
<h2><a class="header" href="#description-26" id="description-26">DESCRIPTION</a></h2>
<p>This command will save the API token to disk so that commands that require
authentication, such as <a href="commands/cargo-publish.html">cargo-publish(1)</a>, will be automatically
authenticated. The token is saved in <code>$CARGO_HOME/credentials.toml</code>. <code>CARGO_HOME</code>
defaults to <code>.cargo</code> in your home directory.</p>
<p>If the <em>token</em> argument is not specified, it will be read from stdin.</p>
<p>The API token for crates.io may be retrieved from <a href="https://crates.io/me">https://crates.io/me</a>.</p>
<p>Take care to keep the token secret, it should not be shared with anyone else.</p>
<h2><a class="header" href="#options-25" id="options-25">OPTIONS</a></h2>
<h3><a class="header" href="#login-options" id="login-options">Login Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login---registry"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3><a class="header" href="#display-options-24" id="display-options-24">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login--v"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-login---verbose"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login--q"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-login---quiet"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-login---color"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-25" id="common-options-25">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login-+toolchain"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-login--h"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-login---help"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-login--Z"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-25" id="环境-25">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-24" id="退出状态-24">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-28" id="examples-28">EXAMPLES</a></h2>
<ol>
<li>
<p>Save the API token to disk:</p>
<pre><code>cargo login
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-26" id="see-also-26">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h1><a class="header" href="#cargo-owner1" id="cargo-owner1">cargo-owner(1)</a></h1>
<h2><a class="header" href="#name-27" id="name-27">NAME</a></h2>
<p>cargo-owner - Manage the owners of a crate on the registry</p>
<h2><a class="header" href="#synopsis-27" id="synopsis-27">SYNOPSIS</a></h2>
<p><code>cargo owner</code> [<em>options</em>] <code>--add</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--remove</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--list</code> [<em>crate</em>]</p>
<h2><a class="header" href="#description-27" id="description-27">DESCRIPTION</a></h2>
<p>This command will modify the owners for a crate on the registry. Owners of a
crate can upload new versions and yank old versions. Non-team owners can also
modify the set of owners, so take care!</p>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>If the crate name is not specified, it will use the package name from the
current directory.</p>
<p>See <a href="commands/../reference/publishing.html#cargo-owner">the reference</a> for more
information about owners and publishing.</p>
<h2><a class="header" href="#options-26" id="options-26">OPTIONS</a></h2>
<h3><a class="header" href="#owner-options" id="owner-options">Owner Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--a"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--a"></a><code>-a</code></dt>
<dt class="option-term" id="option-cargo-owner---add"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---add"></a><code>--add</code> <em>login</em>...</dt>
<dd class="option-desc">Invite the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--r"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--r"></a><code>-r</code></dt>
<dt class="option-term" id="option-cargo-owner---remove"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---remove"></a><code>--remove</code> <em>login</em>...</dt>
<dd class="option-desc">Remove the given user or team as an owner.</dd>
<dt class="option-term" id="option-cargo-owner--l"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-owner---list"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---list"></a><code>--list</code></dt>
<dd class="option-desc">List owners of a crate.</dd>
<dt class="option-term" id="option-cargo-owner---token"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-owner---index"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-owner---registry"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3><a class="header" href="#display-options-25" id="display-options-25">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--v"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-owner---verbose"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner--q"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-owner---quiet"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-owner---color"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-26" id="common-options-26">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner-+toolchain"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-owner--h"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-owner---help"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-owner--Z"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-26" id="环境-26">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-25" id="退出状态-25">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-29" id="examples-29">EXAMPLES</a></h2>
<ol>
<li>
<p>List owners of a package:</p>
<pre><code>cargo owner --list foo
</code></pre>
</li>
<li>
<p>Invite an owner to a package:</p>
<pre><code>cargo owner --add username foo
</code></pre>
</li>
<li>
<p>Remove an owner from a package:</p>
<pre><code>cargo owner --remove username foo
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-27" id="see-also-27">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h1><a class="header" href="#cargo-package1" id="cargo-package1">cargo-package(1)</a></h1>
<h2><a class="header" href="#名称-1" id="名称-1">名称</a></h2>
<p>cargo-package - 将本地包打包为可分发的压缩文件</p>
<h2><a class="header" href="#用法-1" id="用法-1">用法</a></h2>
<p><code>cargo package</code> [<em>options</em>]</p>
<h2><a class="header" href="#描述-1" id="描述-1">描述</a></h2>
<p>此命令会在当前目录创建一个可分发的，压缩过的<code>.crate</code>文件并附带其源代码。文件会存储于
<code>target/package</code>目录中。命令的执行可分为以下步骤：</p>
<ol>
<li>加载当前的工作空间以进行基本的检查。
<ul>
<li>如果不指定依赖的版本，就不能使用路径依赖。Cargo会在发布的包中忽略路径值。但
<code>dev-dependencies</code> 没有这一限制。</li>
</ul>
</li>
<li>创建压缩的<code>.crate</code>文件
<ul>
<li>原始的 <code>Cargo.toml</code>文件会被重写并规范化。</li>
<li>清单中的 <code>[patch]</code>、<code>[replace]</code>、<code>[workspace]</code>段会被移除。</li>
<li>如果包中有可执行的二进制或示例编译目标，则还会包含<code>Cargo.lock</code>文件。如果指定了
<code>--locked</code>标志参数，<a href="commands/cargo-install.html">cargo-install(1)</a>会使用锁文件。</li>
<li>如果可用，会通过<code>.cargo_vcs_info.json</code>文件保存当前版本控制系统的签出哈希值(<strong>Checkout Hash</strong>)。
可通过<code>--allow-dirty</code>标志参数指定不生成该文件。</li>
</ul>
</li>
<li>解压<code>.crate</code>文件并对其进行构建，以验证其确实可以成功构建。
<ul>
<li>这一步会从头开始构建，以确保可以从原始状态构建。可通过指定<code>--no-verify</code>标志参数来跳过这一步。</li>
</ul>
</li>
<li>检查构建脚本是否会修改源代码的文件。</li>
</ol>
<p>包含文件的范围可通过清单中的<code>include</code>和<code>exclude</code>字段来控制。</p>
<p>更多关于打包和发布的细节可参见<a href="commands/../reference/publishing.html">the reference</a></p>
<h3><a class="header" href="#cargo_vcs_infojson-的格式" id="cargo_vcs_infojson-的格式">.cargo_vcs_info.json 的格式</a></h3>
<p>会以下面的格式生成<code>.cargo_vcs_info.json</code>文件。</p>
<pre><code class="language-javascript">{
 &quot;git&quot;: {
   &quot;sha1&quot;: &quot;aac20b6e7e543e6dd4118b246c77225e3a3a1302&quot;
 },
 &quot;path_in_vcs&quot;: &quot;&quot;
}
</code></pre>
<p><code>path_in_vcs</code>会被设置为该软件包关于版本控制仓库的相对路径</p>
<h2><a class="header" href="#可选参数-1" id="可选参数-1">可选参数</a></h2>
<h3><a class="header" href="#打包选项" id="打包选项">打包选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--l"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--l"></a><code>-l</code></dt>
<dt class="option-term" id="option-cargo-package---list"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---list"></a><code>--list</code></dt>
<dd class="option-desc">输出包中包含的文件(不实际进行打包)。</dd>
<dt class="option-term" id="option-cargo-package---no-verify"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">构建包时不进行校验。</dd>
<dt class="option-term" id="option-cargo-package---no-metadata"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-metadata"></a><code>--no-metadata</code></dt>
<dd class="option-desc">忽略 缺少可读的元信息(如描述信息或采用的授权协议) 时产生的警告。</dd>
<dt class="option-term" id="option-cargo-package---allow-dirty"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">允许打包 在版本控制系统中仍有未提交内容 的包。</dd>
</dl>
<h3><a class="header" href="#选择包-8" id="选择包-8">选择包</a></h3>
<p>默认情况下，如果没有指定包，则根据清单文件来选择包(如果没有通过<code>--manifest-path</code>给出清单文件路径，
则基于当前工作目录进行寻找)。如果是某个工作区的根清单，则选中该工作区的默认成员；否则仅选中清
单所定义的那个包。</p>
<p>工作区的默认成员可通过清单中<code>workspace.default-members</code>项来显式指定。如果未指定，则其虚拟
工作区会包含全体工作区成员(等同于传递<code>--workspace</code>标志参数时)，而非虚拟工作区则仅包含根部箱自身。</p>
<dl>
<dt class="option-term" id="option-cargo-package--p"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--p"></a><code>-p</code> <em>spec</em>...</dt>
<dt class="option-term" id="option-cargo-package---package"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---package"></a><code>--package</code> <em>spec</em>...</dt>
<dd class="option-desc">Package指定包. SPEC的格式参见 <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
<dt class="option-term" id="option-cargo-package---workspace"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---workspace"></a><code>--workspace</code></dt>
<dd class="option-desc">Package 工作区中的全体成员.</dd>
<dt class="option-term" id="option-cargo-package---exclude"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---exclude"></a><code>--exclude</code> <em>SPEC</em>...</dt>
<dd class="option-desc">排除指定包。必须与<code>--workspace</code>标志参数共同使用。
此标志参数可多次使用且支持Unix通配符(<code>*</code>, <code>?</code> 和 <code>[]</code>)。不过，为避免shell可能错误地在Cargo获取到
之前就将通配符展开，应在各个模式串两侧使用单引号或双引号。</dd>
</dl>
<h3><a class="header" href="#编译选项" id="编译选项">编译选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---target"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Package 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-package---target-dir"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#特性选择-12" id="特性选择-12">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-package---features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-package---all-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-package---no-default-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#清单选项-1" id="清单选项-1">清单选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---manifest-path"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-package---frozen"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-package---locked"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-package---offline"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#混杂选项" id="混杂选项">混杂选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--j"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-package---jobs"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h3><a class="header" href="#显示选项-1" id="显示选项-1">显示选项</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--v"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-package---verbose"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package--q"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-package---quiet"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-package---color"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-27" id="common-options-27">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package-+toolchain"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-package--h"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-package---help"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-package--Z"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-27" id="环境-27">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-26" id="退出状态-26">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#示例-1" id="示例-1">示例</a></h2>
<ol>
<li>
<p>为当前包创建一个压缩好的<code>.crate</code>文件:</p>
<pre><code> cargo package
</code></pre>
</li>
</ol>
<h2><a class="header" href="#相关-1" id="相关-1">相关</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h1><a class="header" href="#cargo-publish1" id="cargo-publish1">cargo-publish(1)</a></h1>
<h2><a class="header" href="#name-28" id="name-28">NAME</a></h2>
<p>cargo-publish - Upload a package to the registry</p>
<h2><a class="header" href="#synopsis-28" id="synopsis-28">SYNOPSIS</a></h2>
<p><code>cargo publish</code> [<em>options</em>]</p>
<h2><a class="header" href="#description-28" id="description-28">DESCRIPTION</a></h2>
<p>This command will create a distributable, compressed <code>.crate</code> file with the
source code of the package in the current directory and upload it to a
registry. The default registry is <a href="https://crates.io">https://crates.io</a>. This performs the
following steps:</p>
<ol>
<li>Performs a few checks, including:
<ul>
<li>Checks the <code>package.publish</code> key in the manifest for restrictions on
which registries you are allowed to publish to.</li>
</ul>
</li>
<li>Create a <code>.crate</code> file by following the steps in <a href="commands/cargo-package.html">cargo-package(1)</a>.</li>
<li>Upload the crate to the registry. Note that the server will perform
additional checks on the crate.</li>
</ol>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>See <a href="commands/../reference/publishing.html">the reference</a> for more details about
packaging and publishing.</p>
<h2><a class="header" href="#options-27" id="options-27">OPTIONS</a></h2>
<h3><a class="header" href="#publish-options" id="publish-options">Publish Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---dry-run"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---dry-run"></a><code>--dry-run</code></dt>
<dd class="option-desc">Perform all checks without uploading.</dd>
<dt class="option-term" id="option-cargo-publish---token"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-publish---no-verify"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-verify"></a><code>--no-verify</code></dt>
<dd class="option-desc">Don't verify the contents by building them.</dd>
<dt class="option-term" id="option-cargo-publish---allow-dirty"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---allow-dirty"></a><code>--allow-dirty</code></dt>
<dd class="option-desc">Allow working directories with uncommitted VCS changes to be packaged.</dd>
<dt class="option-term" id="option-cargo-publish---index"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-publish---registry"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to publish to. Registry names are defined in <a href="commands/../reference/config.html">Cargo
config files</a>. If not specified, and there is a
<a href="commands/../reference/manifest.html#the-publish-field"><code>package.publish</code></a> field in
<code>Cargo.toml</code> with a single registry, then it will publish to that registry.
Otherwise it will use the default registry, which is defined by the
<a href="commands/../reference/config.html#registrydefault"><code>registry.default</code></a> config key
which defaults to <code>crates-io</code>.</dd>
</dl>
<h3><a class="header" href="#package-selection-6" id="package-selection-6">Package Selection</a></h3>
<p>By default, the package in the current working directory is selected. The <code>-p</code>
flag can be used to choose a different package in a workspace.</p>
<dl>
<dt class="option-term" id="option-cargo-publish--p"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--p"></a><code>-p</code> <em>spec</em></dt>
<dt class="option-term" id="option-cargo-publish---package"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---package"></a><code>--package</code> <em>spec</em></dt>
<dd class="option-desc">The package to publish. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</dd>
</dl>
<h3><a class="header" href="#compilation-options-10" id="compilation-options-10">Compilation Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---target"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target"></a><code>--target</code> <em>triple</em></dt>
<dd class="option-desc">为指定架构执行 Publish 。默认情况下为本机的架构。三元组的格式为
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>。执行 <code>rustc --print target-list</code>
可得到支持的构建目标列表。</p>
<p>也可通过<code>build.target</code>指定(<a href="commands/../reference/config.html">config value</a>)。</p>
<p>注意，指定该标志参数会使Cargo产生的构建工件放在与平常不同的目录下。
详情参见<a href="commands/../guide/build-cache.html">build cache</a></dd>
<dt class="option-term" id="option-cargo-publish---target-dir"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target-dir"></a><code>--target-dir</code> <em>directory</em></dt>
<dd class="option-desc">用于存放生成的工件以及中间文件的目录。也可通过环境变量<code>CARGO_TARGET_DIR</code> 或 
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>指定。</p>
<p>默认情况下为根工作区中的<code>target</code>目录。</dd>
</dl>
<h3><a class="header" href="#特性选择-13" id="特性选择-13">特性选择</a></h3>
<p>可通过传递特性参数来控制启用哪些特性。如果没有给定要使用的特性，
则每个已选择的包都会自动使用<code>default</code>特性。</p>
<p>详见<a href="commands/../reference/features.html#command-line-feature-options">the features documentation</a>。</p>
<dl>
<dt class="option-term" id="option-cargo-publish---features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---features"></a><code>--features</code> <em>features</em></dt>
<dd class="option-desc">传递以空格或者逗号分隔的列表，其中给出要启用的特性。工作区成员的特性可通过<code>包名/特性名</code>的语法启用。
此参数可多次给定，以分别启用给定的特性。</dd>
<dt class="option-term" id="option-cargo-publish---all-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---all-features"></a><code>--all-features</code></dt>
<dd class="option-desc">为给定的包启用全部可用特性</dd>
<dt class="option-term" id="option-cargo-publish---no-default-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-default-features"></a><code>--no-default-features</code></dt>
<dd class="option-desc">不启用给定包的<code>default</code>特性</dd>
</dl>
<h3><a class="header" href="#manifest-options-20" id="manifest-options-20">Manifest Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---manifest-path"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---manifest-path"></a><code>--manifest-path</code> <em>path</em></dt>
<dd class="option-desc">用于指定<code>Cargo.toml</code>文件的路径。默认情况下，Cargo会在当前目录或上级目录中寻找<code>Cargo.toml</code>文件。</dd>
<dt class="option-term" id="option-cargo-publish---frozen"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---frozen"></a><code>--frozen</code></dt>
<dt class="option-term" id="option-cargo-publish---locked"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---locked"></a><code>--locked</code></dt>
<dd class="option-desc">这两个选项用于保证<code>Cargo.lock</code>文件是最新的。如果该锁文件不存在，或者不是最新的，Cargo
会报错退出。其中<code>--frozen</code>选项会阻止Cargo访问网络以检查锁文件是否是最新的。</p>
<p>这些选项，可用于保证<code>Cargo.lock</code>文件是最新的(比如持续集成的构建过程)，
或用于避免联网。</dd>
<dt class="option-term" id="option-cargo-publish---offline"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---offline"></a><code>--offline</code></dt>
<dd class="option-desc">禁止Cargo访问网络。如果不添加此选项，Cargo在需要访问网络但网络不可用的情况下，会报错
并停止工作。添加此选项后，Cargo会尽可能尝试不使用网络来工作。</p>
<p>注意，在此情况下可能会产生与联网状态下不同的依赖解析(<strong>Dependency Resolution</strong>)结果。
Cargo只会使用本地已下载的crate，即便本地的索引副本中表明可能有新版本crate。在离线前下载
所需依赖的方法，参见 <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> 。</p>
<p>也可以通过 <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>指定。</dd>
</dl>
<h3><a class="header" href="#miscellaneous-options-10" id="miscellaneous-options-10">Miscellaneous Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--j"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--j"></a><code>-j</code> <em>N</em></dt>
<dt class="option-term" id="option-cargo-publish---jobs"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---jobs"></a><code>--jobs</code> <em>N</em></dt>
<dd class="option-desc">要并行运行的作业数量。也可通过<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>指定。
默认为CPU数量。</dd>
</dl>
<h3><a class="header" href="#display-options-26" id="display-options-26">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--v"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-publish---verbose"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish--q"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-publish---quiet"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-publish---color"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-28" id="common-options-28">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish-+toolchain"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-publish--h"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-publish---help"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-publish--Z"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-28" id="环境-28">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-27" id="退出状态-27">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-30" id="examples-30">EXAMPLES</a></h2>
<ol>
<li>
<p>Publish the current package:</p>
<pre><code>cargo publish
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-28" id="see-also-28">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a></p>
<h1><a class="header" href="#cargo-yank1" id="cargo-yank1">cargo-yank(1)</a></h1>
<h2><a class="header" href="#name-29" id="name-29">NAME</a></h2>
<p>cargo-yank - Remove a pushed crate from the index</p>
<h2><a class="header" href="#synopsis-29" id="synopsis-29">SYNOPSIS</a></h2>
<p><code>cargo yank</code> [<em>options</em>] <code>--vers</code> <em>version</em> [<em>crate</em>]</p>
<h2><a class="header" href="#description-29" id="description-29">DESCRIPTION</a></h2>
<p>The yank command removes a previously published crate's version from the
server's index. This command does not delete any data, and the crate will
still be available for download via the registry's download link.</p>
<p>Note that existing crates locked to a yanked version will still be able to
download the yanked version to use it. Cargo will, however, not allow any new
crates to be locked to any yanked version.</p>
<p>This command requires you to be authenticated with either the <code>--token</code> option
or using <a href="commands/cargo-login.html">cargo-login(1)</a>.</p>
<p>If the crate name is not specified, it will use the package name from the
current directory.</p>
<h2><a class="header" href="#options-28" id="options-28">OPTIONS</a></h2>
<h3><a class="header" href="#yank-options" id="yank-options">Yank Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank---vers"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---vers"></a><code>--vers</code> <em>version</em></dt>
<dd class="option-desc">The version to yank or un-yank.</dd>
<dt class="option-term" id="option-cargo-yank---undo"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---undo"></a><code>--undo</code></dt>
<dd class="option-desc">Undo a yank, putting a version back into the index.</dd>
<dt class="option-term" id="option-cargo-yank---token"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---token"></a><code>--token</code> <em>token</em></dt>
<dd class="option-desc">API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</dd>
<dt class="option-term" id="option-cargo-yank---index"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---index"></a><code>--index</code> <em>index</em></dt>
<dd class="option-desc">The URL of the registry index to use.</dd>
<dt class="option-term" id="option-cargo-yank---registry"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---registry"></a><code>--registry</code> <em>registry</em></dt>
<dd class="option-desc">Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</dd>
</dl>
<h3><a class="header" href="#display-options-27" id="display-options-27">Display Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank--v"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--v"></a><code>-v</code></dt>
<dt class="option-term" id="option-cargo-yank---verbose"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---verbose"></a><code>--verbose</code></dt>
<dd class="option-desc">启用更加详细的输出。可两次使用来显示&quot;非常详细&quot;的输出，其中包含了诸如 依赖警告 以及 构建脚本输出 等额外的输出内容。
也可通过<code>term.verbose</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank--q"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--q"></a><code>-q</code></dt>
<dt class="option-term" id="option-cargo-yank---quiet"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---quiet"></a><code>--quiet</code></dt>
<dd class="option-desc">不输出Cargo的日志信息。也可通过<code>term.quiet</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
<dt class="option-term" id="option-cargo-yank---color"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---color"></a><code>--color</code> <em>when</em></dt>
<dd class="option-desc">控制输出内容的颜色。有效取值如下：</p>
<ul>
<li><code>auto</code> (默认)：自动检测终端是否支持带颜色的输出。</li>
<li><code>always</code>：总显示带颜色的输出。</li>
<li><code>never</code>：从不显示带颜色的输出。</li>
</ul>
<p>也可通过<code>term.color</code>指定。
<a href="commands/../reference/config.html">config value</a>.</dd>
</dl>
<h3><a class="header" href="#common-options-29" id="common-options-29">Common Options</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank-+toolchain"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank-+toolchain"></a><code>+</code><em>toolchain</em></dt>
<dd class="option-desc">If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</dd>
<dt class="option-term" id="option-cargo-yank--h"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--h"></a><code>-h</code></dt>
<dt class="option-term" id="option-cargo-yank---help"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---help"></a><code>--help</code></dt>
<dd class="option-desc">Prints help information.</dd>
<dt class="option-term" id="option-cargo-yank--Z"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--Z"></a><code>-Z</code> <em>flag</em></dt>
<dd class="option-desc">Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</dd>
</dl>
<h2><a class="header" href="#环境-29" id="环境-29">环境</a></h2>
<p>关于Cargo所读取的环境变量，可参见<a href="commands/../reference/environment-variables.html">the reference</a></p>
<h2><a class="header" href="#退出状态-28" id="退出状态-28">退出状态</a></h2>
<ul>
<li><code>0</code>: Cargo命令执行成功</li>
<li><code>101</code>: Cargo命令未能完成.</li>
</ul>
<h2><a class="header" href="#examples-31" id="examples-31">EXAMPLES</a></h2>
<ol>
<li>
<p>Yank a crate from the index:</p>
<pre><code>cargo yank --vers 1.0.7 foo
</code></pre>
</li>
</ol>
<h2><a class="header" href="#see-also-29" id="see-also-29">SEE ALSO</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<h2><a class="header" href="#常见问题" id="常见问题">常见问题</a></h2>
<h3><a class="header" href="#is-the-plan-to-use-github-as-a-package-repository" id="is-the-plan-to-use-github-as-a-package-repository">Is the plan to use GitHub as a package repository?</a></h3>
<blockquote>
<p>是否有计划，使用 Github 作为一个包库 ？</p>
</blockquote>
<p>不，Cargo 的计划是使用<a href="https://crates.io/">crates.io</a>，像 NPM 或 RuuGuMes 对应 npmjs.org 和 rubygems.org。</p>
<p>我们计划永远（通过些配置）支持 git 存储库作为包的来源，因为它们可以用于早期开发和临时补丁（加了点灵活性），即便人们使用主要使用注册表作为包的来源。</p>
<h3><a class="header" href="#why-build-cratesio-rather-than-use-github-as-a-registry" id="why-build-cratesio-rather-than-use-github-as-a-registry">Why build crates.io rather than use GitHub as a registry?</a></h3>
<blockquote>
<p>为啥，选 crates.io，而不是使用 Github 作为 注册表 ？</p>
</blockquote>
<p>我们认为支持多种下载包的方式非常重要，包括从 GitHub 下载包，并将包复制到包本身.</p>
<p>也就是说，我们认为<a href="https://crates.io/">crates.io</a>提供了许多重要的好处，并且预计其会成为人们在 Cargo 中，下载包的主要方式。</p>
<p>前车之鉴，Node.js 的<a href="https://www.npmjs.org">npm</a>和 Ruby 的<a href="https://bundler.io">bundler</a>都支持中央注册中心模式，和基于 Git 的模式，而大多数包都是通过生态系统中的注册中心下载的，其中重要的少数包是使用基于 git 的包。</p>
<p>使中央注册中心，在其他语言中流行的一些优点包括:</p>
<ul>
<li><strong>可发现性</strong>. 中央注册表提供了查找现有包的简单方式。结合标记(版本)，这也使得注册中心能够提供生态系统的范围信息，例如最流行或最依赖的包的列表.</li>
<li><strong>速度</strong>. 中心注册中心使得可以快速有效地只获取包的元数据，然后只高效地下载已发布的包，而不会出现在存储库中的其他膨胀。这大大提高了依赖性解析和获取的速度。要知道随着依赖关系图的扩展，下载所有的 git 存储库会陷入困境。还要记住的是，并不是每个人都有高速、低延迟的互联网连接.</li>
</ul>
<h3><a class="header" href="#will-cargo-work-with-c-code-or-other-languages" id="will-cargo-work-with-c-code-or-other-languages">Will Cargo work with C code (or other languages)?</a></h3>
<blockquote>
<p>Cargo 可与 C 语言代码(或其他语言)一起工作吗?</p>
</blockquote>
<p>可以的!</p>
<p>Cargo 处理编译 Rust 代码，但我们知道许多 Rust 包与 C 代码都有链接。我们还知道除 Rust 之外，在编译语言方面的工具，已建立了数十年。</p>
<p>我们的解决方案:Cargo 允许一个包可以<a href="./build-scripts.html">指定脚本</a>(用 Rust 编写)，其在调用<code>rustc</code>之前运行。 利用 Rust 实现特定于平台的配置和重构包之间的常见构建功能。</p>
<h3><a class="header" href="#can-cargo-be-used-inside-of-make-or-ninja-or-" id="can-cargo-be-used-inside-of-make-or-ninja-or-">Can Cargo be used inside of <code>make</code> (or <code>ninja</code>, or ...)</a></h3>
<blockquote>
<p>Cargo 能被用在 <code>make</code>(或 <code>ninja</code>或...) 中吗 ?</p>
</blockquote>
<p>当然能。尽管我们希望， Cargo 是作为顶级编译 Rust 包的独立方式，但我们知道有些人希望从其他构建工具调用 Cargo。</p>
<p>我们已将 Cargo 设计成在这些环境中工作良好，并注意错误代码和机器可读输出模式等事项。在这些方面我们还有一些工作要做，但是在传统脚本上下文中使用 Cargo 是我们从一开始就设计的，并且将继续优先考虑。</p>
<h3><a class="header" href="#does-cargo-handle-multi-platform-packages-or-cross-compilation" id="does-cargo-handle-multi-platform-packages-or-cross-compilation">Does Cargo handle multi-platform packages or cross-compilation?</a></h3>
<blockquote>
<p>Cargo 是怎么平衡 多平台或跨平台的包的？</p>
</blockquote>
<p>Rust 本身提供了基于平台，配置代码段的工具。Cargo 也支持<a href="reference/specifying-dependencies.html#platform-specific-dependencies">特定平台依赖关系</a>，未来，我们计划为每个平台<code>Cargo.toml</code>支持更多的配置.</p>
<p>从长远来看，我们正在寻找使用 Cargo 方便地跨编译包的方法.</p>
<h3><a class="header" href="#does-cargo-support-environments-like-production-or-test" id="does-cargo-support-environments-like-production-or-test">Does Cargo support environments, like <code>production</code> or <code>test</code>?</a></h3>
<blockquote>
<p>Cargo 有没支持像<code>production</code> 或 <code>test</code>这样的环境？</p>
</blockquote>
<p>我们通过使用<a href="./manifest.html#the-profile-sections">profiles</a>来支持这样的环境:</p>
<ul>
<li>特定环境标志(像 开发环境的 <code>-g --opt-level=0</code>和生产环境的<code>--opt-level=3</code>)。</li>
<li>特定环境依赖性(像 测试断言 的<code>hamcrest</code>).</li>
<li>特定环境变量 <code>#[cfg]</code></li>
<li>一个<code>cargo test</code>命令</li>
</ul>
<h3><a class="header" href="#does-cargo-work-on-windows" id="does-cargo-work-on-windows">Does Cargo work on Windows?</a></h3>
<blockquote>
<p>Windows 系统 呢，Cargo 能搞吗？</p>
</blockquote>
<p>没问题!</p>
<p>所有提交的 Cargo 都需要通过 Windows 上的本地测试套件。但是，如果你发现一个 Windows 问题，我们认为它就是一个 bug，所以<a href="https://github.com/rust-lang/cargo/issues">请提出一个问题</a>.</p>
<h3><a class="header" href="#why-do-binaries-have-cargolock-in-version-control-but-not-libraries" id="why-do-binaries-have-cargolock-in-version-control-but-not-libraries">Why do binaries have <code>Cargo.lock</code> in version control, but not libraries?</a></h3>
<blockquote>
<p>为啥，输出二进制的 Cargo 项目具有<code>Cargo.lock</code>，而单输出库的，就没有？</p>
</blockquote>
<p>一个<code>Cargo.lock</code>文件的目的，是在于成功构建，能描述'世界'的状态。然后，它就能用来，通过确保编译完全相同的依赖项，就能跨任何机器上构建确定性的包。</p>
<p>这个属性对于，处在依赖链末端的应用程序和包(二进制文件)是最理想的。因此，建议所有二进制文件都在其<code>Cargo.lock</code>内部进行检查.</p>
<p>对于单库来说，情况有些不同。库不仅被库开发人员使用，而且被库的任何下游消费者使用。依赖库的用户不会检查库的<code>Cargo.lock</code>(即使它存在)。正是如此，库<strong>不</strong>应该对库的所有用户进行确定性地重新编译。</p>
<p>如果一个库最终被多个依赖项传递使用，那么很可能只需要该库的一个副本(基于 semver 兼容性的版本)。如果 Cargo 使用了所有的 <strong>依赖项的<code>Cargo.lock</code>文件</strong>，那结果就是，使用库的多个副本，甚至可能存在版本冲突。</p>
<p>换句话说，库为它们的依赖项指定了 semver 版本，但是不用(无法)看到全部内容。只有像二进制文件这样的最终产品才需要有完整的图，来决定应该使用什么版本的依赖。</p>
<h3><a class="header" href="#can-libraries-use--as-a-version-for-their-dependencies" id="can-libraries-use--as-a-version-for-their-dependencies">Can libraries use <code>*</code> as a version for their dependencies?</a></h3>
<blockquote>
<p>作为库的项目，可以使用<code>*</code>作为它们的依赖的版本号吗?</p>
</blockquote>
<p><strong>截至 2016 年 1 月 22 日，<a href="https://crates.io/">crates.io</a>拒绝通配符<code>*</code>依赖约束的所有包(不只是库).</strong></p>
<p>库是<em>可以</em>，但严格来说，他们不应该这样做。<code>*</code>版本要求，说明了&quot;这将适用于任何版本&quot;，而这永远不会是真的。库应该总是指定它们工作的范围，即使它和&quot;每个 1.x.y 版本&quot;一样。</p>
<h3><a class="header" href="#why-cargotoml" id="why-cargotoml">Why <code>Cargo.toml</code>?</a></h3>
<p>作为与 Cargo 最频繁的交互之一，为什么要命名配置文件叫<code>Cargo.toml</code>的问题不时出现。选择领先的大写—<code>C</code>，是为了确保清单与目录清单中的其他类似配置文件组合排序。对文件进行排序时，通常将大写字母放在小写字母之前，确保<code>Makefile</code>和<code>Cargo.toml</code>文件会放在一起。选择<code>.toml</code>结尾是强调文件是<a href="https://github.com/toml-lang/toml">特定的配置文件格式</a>.</p>
<p>Cargo 不允许其他名称(如<code>cargo.toml</code>或<code>Cargofile</code>)，来强调如何如何容易识别 Cargo 仓库。在历史上，许多可能的名称选择都导致了混乱，其中一个选项被选择了，而其他选项就被自然而然地遗忘。</p>
<h3><a class="header" href="#how-can-cargo-work-offline" id="how-can-cargo-work-offline">How can Cargo work offline?</a></h3>
<blockquote>
<p>Cargo 能 离线 工作吗？</p>
</blockquote>
<p>Cargo 通常用于网络访问有限，或没有网络访问的情况，如飞机、CI 环境或嵌入大型生产部署中。当 Cargo 试图从网络获取资源时，用户常常感到惊讶，因频繁出现 Cargo 离线工作的请求。</p>
<p>Cargo 的核心是不会试图访问网络，除非被告知这样做。也就是说，如果没有来自 crates.io、git 存储库或其他网络位置的箱，则 Cargo 永远不会尝试进行网络连接。因此，如果 Cargo 试图接触网络，那是因为它需要获取所需的资源。</p>
<p>Cargo 还非常积极地缓存信息，保持最小化的网络活动量。例如，它将保证<code>cargo build</code>(或类似的)运行到完成，那下一次<code>cargo build</code>保证不接触网络，只要<code>Cargo.toml</code>在此期间还没有被修改。网络的这种回避归结为，已存在<code>Cargo.lock</code>，和在 lock 文件中反映了，箱子的充分缓存。如果这些组件中的任何一个丢失，那么构建的成功就需要它们，并且必须远程获取它们。</p>
<p>对 Rust 1.11.0 打后的 Cargo ，可以看到新的(标志)参数<code>--frozen</code>，这是它不应该接触网络的断言。当传递给 Cargo，如果 Cargo 试图进行网络请求，它将立即返回一个错误。错误应该包括关于为什么进行网络请求(第一个地方），以帮助调试的上下文信息。注意这个标志是<em>不改变 Cargo 的行为</em>，它只是断言 Cargo 不应该触摸网络，这作为上一个命令已完成的保证，可以相同的网络活动是不必的。</p>
<blockquote>
<p>上一个命令，如<code>cargo build</code></p>
</blockquote>
<p>有关版本管理的详细信息，请参阅文档<a href="./source-replacement.html">来源更换</a>.</p>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<ul>
<li>词汇表</li>
</ul>
<h3><a class="header" href="#artifact" id="artifact">Artifact</a></h3>
<ul>
<li>工件</li>
</ul>
<p>一个<em>Artifact</em>是由编译过程创建的文件或文件集。这包括可链接库和可执行二进制文件.</p>
<h3><a class="header" href="#crate" id="crate">Crate</a></h3>
<ul>
<li>箱 (包/库， 又一抽象名)</li>
</ul>
<p>包中的每个目标都是<em>箱</em>。Crates 是库或可执行二进制文件。它可能松散地引用目标的源代码或目标生成的编译工件。一个箱也可以指从注册表中提取的压缩包.</p>
<h3><a class="header" href="#edition" id="edition">Edition</a></h3>
<ul>
<li>版本</li>
</ul>
<p>一个<em>Rust Edition</em>是 Rust 语言的开发里程碑。该<a href="appendix/../reference/manifest.html#the-edition-field-optional">一个包的版本</a>在<code>Cargo.toml</code>清单中指定，各个目标可以指定它们使用的版本。见<a href="https://rust-lang-nursery.github.io/edition-guide/">版本指南</a>欲获得更多信息.</p>
<h3><a class="header" href="#feature" id="feature">Feature</a></h3>
<ul>
<li>特性/特征/功能</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.html#the-features-section"><em>特征</em></a>是一个允许条件编译的命名标志参数。一个特性可以引用可选的依赖项，或者在 一个<code>Cargo.toml</code> 中定义的任意名称，可以键入(使用到)源代码中。</p>
<p>Cargo 有<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.md"><em>不稳定的特征标志</em></a>，这可以用来实现 Cargo 本身的实验行为。Rust 编译器和 Rustdoc 也有自己的不稳定特征标志(参见<a href="https://doc.rust-lang.org/nightly/unstable-book/index.md">不稳定的书</a>和<a href="https://doc.rust-lang.org/nightly/rustdoc/unstable-features.md">Rustdoc 书</a>).</p>
<h3><a class="header" href="#index" id="index">Index</a></h3>
<ul>
<li>索引是注册表中，可搜索的包的列表.</li>
</ul>
<h3><a class="header" href="#lock-file" id="lock-file">Lock file</a></h3>
<ul>
<li>(锁定/锁) 文件</li>
</ul>
<p><code>Cargo.lock</code>，名:<em>锁定文件</em>，是一个文件，用于捕获工作空间或包中使用的每个依赖项的确切版本，它由 Cargo 自动生成。看到<a href="appendix/../cargo-toml-vs-cargo-lock.html">Cargo.toml 与 Cargo.lock</a>.</p>
<h3><a class="header" href="#manifest" id="manifest">Manifest</a></h3>
<ul>
<li>清单/元信息</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.html"><em>清单</em></a>是对包或工作空间的描述，名为<code>Cargo.toml</code>.</p>
<p>一个<a href="appendix/../reference/manifest.html#virtual-manifest"><em>虚拟清单</em></a>是一个<code>Cargo.toml</code>，仅描述工作空间的文件，不包含包。</p>
<h3><a class="header" href="#member" id="member">Member</a></h3>
<ul>
<li>会员/成员</li>
</ul>
<p>一个<em>成员</em>是属于工作空间的一个包.</p>
<h3><a class="header" href="#package" id="package">Package</a></h3>
<ul>
<li>包</li>
</ul>
<p>一个<em>包</em>是源文件和描述包的清单<code>Cargo.toml</code>的集合。包具有名称和版本，用于指定包之间的依赖关系。包中包含多个目标，这些目标是库或可执行二进制文件。</p>
<p>该<em>包根</em>是<code>Cargo.toml</code>清单位于的包的目录。</p>
<p>该<a href="appendix/../reference/pkgid-spec.html"><em>包 ID 规范</em></a>， 要么<em>SPEC</em>，是一个字符串，用于辨识从特定源，引用特定版本的包唯一性。</p>
<h3><a class="header" href="#project" id="project">Project</a></h3>
<ul>
<li>包/项目</li>
</ul>
<p><a href="appendix/glossary.html#package">package</a>的另一个名字.</p>
<h3><a class="header" href="#registry" id="registry">Registry</a></h3>
<ul>
<li>注册表</li>
</ul>
<p>一个<em>注册处</em>是一种服务，包含可下载的包，可以安装或用作包的依赖项.默认注册表是<a href="https://crates.io">crates.io</a>。注册表有一个<em>索引</em>，其中包含所有包装箱的清单，并告诉 Cargo 如何下载所需的箱。</p>
<h3><a class="header" href="#source" id="source">Source</a></h3>
<ul>
<li>源/资源</li>
</ul>
<p>一个<em>源</em>是一个提供程序，包含箱子，这些箱子可当依赖项的包。有几种源:</p>
<ul>
<li><strong>注册表来源</strong>- 见<a href="appendix/glossary.html#registry">注册表</a>.</li>
<li><strong>本地注册表源</strong>- 在文件系统上存储为压缩文件的一组包。看到<a href="appendix/../reference/source-replacement.html#local-registry-sources">本地注册表来源</a>.</li>
<li><strong>目录来源</strong>- 在文件系统上存储为未压缩文件的一组包.看到<a href="appendix/../reference/source-replacement.html#directory-sources">目录来源</a>.</li>
<li><strong>路径来源</strong>- 位于文件系统上的单个包(例如<a href="appendix/../reference/specifying-dependencies.html#specifying-path-dependencies">路径依赖</a>)或一组多个包(如<a href="appendix/../reference/specifying-dependencies.html#overriding-with-local-dependencies">路径覆盖</a>).</li>
<li><strong>Git 来源</strong>- 位于 git 存储库中的包(例如<a href="appendix/../reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git 依赖</a>要么<a href="appendix/../reference/source-replacement.html">git 来源</a>).</li>
</ul>
<p>看到<a href="appendix/../reference/source-replacement.html">来源更换</a>欲获得更多信息.</p>
<h3><a class="header" href="#spec" id="spec">Spec</a></h3>
<ul>
<li>看到<a href="appendix/glossary.html#package">包 ID 规范</a>.</li>
</ul>
<h3><a class="header" href="#target" id="target">Target</a></h3>
<ul>
<li>目标</li>
</ul>
<p><em>Target</em>这个词的意思，取决于具体情况:</p>
<ul>
<li><strong>Cargo 目标</strong> - Cargo 项目会有<em>target</em>，其具有对应将要生成的工件。项目可以包含库，二进制，示例，测试和基准目标。该<a href="appendix/../reference/manifest.html#configuring-a-target">目标列表</a>配置在<code>Cargo.toml</code>清单，通常由源文件的<a href="appendix/../reference/manifest.html#the-project-layout">目录布局</a>自动推断的。</li>
<li><strong>目标架构</strong>- 构建工件的 OS 和机器体系结构，通常称为一个<em>目标</em>。</li>
<li><strong>目标 三元(Triple)</strong>- 三元组是用于指定目标体系结构的特定格式。见<a href="http://clang.llvm.org/docs/CrossCompilation.md#target-triple">clang 文档</a> 了解详情。三元组可以称为 一个<em>目标三元</em>，此为产生的工件的架构，以及<em>主机三元</em>，此为编译器运行的体系结构。可以使用<code>--target</code>命令行选项或<code>build.target</code> [配置选项]指定目标三元组。</li>
<li><strong>目标目录</strong>- Cargo 将所有构建的工件和中间文件放入<em>target</em>目录。默认情况下，这是一个名为<code>target</code>的目录会在工作区根目录，或者包根(如果不使用工作空间)。目录随着<code>--target-dir</code>命令行选项，<code>CARGO_TARGET_DIR</code> <a href="appendix/../reference/environment-variables.html">环境变量</a>， 或者<code>build.target-dir</code>
<a href="appendix/../reference/config.html">配置选项</a>改变而改变.</li>
</ul>
<blockquote>
<p>“target-triple (目标 三元)&quot; 是 编译器的 专用术语，用 “ cpu- vendor- os&quot; 来标识 交叉编译时的 系统类型</p>
</blockquote>
<h3><a class="header" href="#test-targets" id="test-targets">Test Targets</a></h3>
<p>Cargo<em>测试目标</em>生成二进制文件，帮助验证代码的正确操作和正确性。有两种类型的测试工件:</p>
<ul>
<li><strong>单元测试</strong>- 一个<em>单元测试</em>是直接从库或二进制目标编译的可执行二进制文件。它包含库或二进制代码的全部内容，并运行<code>#[test]</code>注释函数，用于验证各个代码单元。</li>
<li><strong>集成测试目标</strong>- 一个<a href="appendix/../reference/manifest.html#integration-tests"><em>集成测试目标</em></a>是一个来自<em>测试目标</em>的可执行的二进制文件，这是一个独特的箱子，其来源位于<code>tests</code>目录或由在<code>Cargo.toml</code>清单里面的<a href="appendix/../reference/manifest.html#configuring-a-target"><code>[[test]]</code>表</a>指定。它旨在仅测试库的公共 API，或执行二进制文件以验证其操作。</li>
</ul>
<h3><a class="header" href="#workspace" id="workspace">Workspace</a></h3>
<ul>
<li>工作区</li>
</ul>
<p>一个<a href="appendix/../reference/manifest.html#the-workspace-section"><em>工作区</em></a>是一个共享公共依赖项解析(具有共享<code>Cargo.lock</code>)，输出目录和各种设置，如配置文件，的一个或多个包的集合。</p>
<p>一个<a href="appendix/../reference/manifest.html#virtual-manifest"><em>虚拟工作区</em></a>是<code>Cargo.toml</code>清单根目录的工作空间， 没有定义包，只列出工作区成员。</p>
<p>该<em>工作区根</em>是工作区的<code>Cargo.toml</code>清单位于的目录.</p>
<h1><a class="header" href="#git-authentication" id="git-authentication">Git Authentication</a></h1>
<p>Cargo supports some forms of authentication when using git dependencies and
registries. This appendix contains some information for setting up git
authentication in a way that works with Cargo.</p>
<p>If you need other authentication methods, the <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>
config value can be set to cause Cargo to execute the <code>git</code> executable to
handle fetching remote repositories instead of using the built-in support.
This can be enabled with the <code>CARGO_NET_GIT_FETCH_WITH_CLI=true</code> environment
variable.</p>
<h2><a class="header" href="#https-authentication" id="https-authentication">HTTPS authentication</a></h2>
<p>HTTPS authentication requires the <a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage"><code>credential.helper</code></a> mechanism. There are
multiple credential helpers, and you specify the one you want to use in your
global git configuration file.</p>
<pre><code class="language-ini"># ~/.gitconfig

[credential]
helper = store
</code></pre>
<p>Cargo does not ask for passwords, so for most helpers you will need to give
the helper the initial username/password before running Cargo. One way to do
this is to run <code>git clone</code> of the private git repo and enter the
username/password.</p>
<blockquote>
<p><strong>Tip:</strong><br>
macOS users may want to consider using the osxkeychain helper.<br>
Windows users may want to consider using the <a href="https://github.com/microsoft/Git-Credential-Manager-Core/">GCM</a> helper.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Windows users will need to make sure that the <code>sh</code> shell is
available in your <code>PATH</code>. This typically is available with the Git for
Windows installation.</p>
</blockquote>
<h2><a class="header" href="#ssh-authentication" id="ssh-authentication">SSH authentication</a></h2>
<p>SSH authentication requires <code>ssh-agent</code> to be running to acquire the SSH key.
Make sure the appropriate environment variables are set up (<code>SSH_AUTH_SOCK</code> on
most Unix-like systems), and that the correct keys are added (with <code>ssh-add</code>).
Windows uses Pageant for SSH authentication.</p>
<blockquote>
<p><strong>Note:</strong> Cargo does not support git's shorthand SSH URLs like
<code>git@example.com/user/repo.git</code>. Use a full SSH URL like
<code>ssh://git@example.com/user/repo.git</code>.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> SSH configuration files (like OpenSSH's <code>~/.ssh/config</code>) are not
used by Cargo's built-in SSH library. More advanced requirements should use
<a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="language.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
