<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust 🦀</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
        data-autoload-cookie-consent-bar="true"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZN78TEJMRW');
</script>


<script>
  (function () {
      // See these pages for details:
      // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
      // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
      let base = "https://google.github.io/comprehensive-rust";
      
      let canonical_href = `${base}/zh-CN/print.md`;
      

      // mdbook gives us a string ending in ".md", we replace it with ".html":
      canonical_href = canonical_href.slice(0, -"md".length) + "html";
      if (canonical_href.endsWith("/index.html")) {
          canonical_href = canonical_href.slice(0, -"index.html".length);
      }

      let link = document.createElement("link");
      link.rel = "canonical";
      link.href = canonical_href;
      document.head.appendChild(link);
  })()
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/svgbob.css">
        
        <link rel="stylesheet" href="theme/css/speaker-notes.css">
        
        <link rel="stylesheet" href="theme/css/language-picker.css">
        
        <link rel="stylesheet" href="theme/css/frontmatter.css">
        

        
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">欢迎来到 Comprehensive Rust 🦀</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> 授课</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> 课程结构</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> 键盘快捷键</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> 翻译</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> 使用 Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> Rust 生态系统</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> 代码示例</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> 在本地运行 Cargo</a></li></ol></li><li class="chapter-item "><li class="part-title">第一天：早上</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> 欢迎</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="welcome-day-1/what-is-rust.html"><strong aria-hidden="true">3.1.</strong> 什么是 Rust？</a></li></ol></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello World!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/small-example.html"><strong aria-hidden="true">4.1.</strong> 简短示例</a></li></ol></li><li class="chapter-item "><a href="why-rust.html"><strong aria-hidden="true">5.</strong> 为什么选择 Rust？</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="why-rust/an-example-in-c.html"><strong aria-hidden="true">5.1.</strong> An Example in C</a></li><li class="chapter-item "><a href="why-rust/compile-time.html"><strong aria-hidden="true">5.2.</strong> 编译期保障</a></li><li class="chapter-item "><a href="why-rust/runtime.html"><strong aria-hidden="true">5.3.</strong> 运行时保障</a></li><li class="chapter-item "><a href="why-rust/modern.html"><strong aria-hidden="true">5.4.</strong> 现代特性</a></li></ol></li><li class="chapter-item "><a href="basic-syntax.html"><strong aria-hidden="true">6.</strong> 基本语法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/scalar-types.html"><strong aria-hidden="true">6.1.</strong> 标量类型</a></li><li class="chapter-item "><a href="basic-syntax/compound-types.html"><strong aria-hidden="true">6.2.</strong> 复合类型</a></li><li class="chapter-item "><a href="basic-syntax/references.html"><strong aria-hidden="true">6.3.</strong> 引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/references-dangling.html"><strong aria-hidden="true">6.3.1.</strong> 悬垂引用</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/slices.html"><strong aria-hidden="true">6.4.</strong> 切片</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/string-slices.html"><strong aria-hidden="true">6.4.1.</strong> String 和 str</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/functions.html"><strong aria-hidden="true">6.5.</strong> 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/rustdoc.html"><strong aria-hidden="true">6.5.1.</strong> Rustdoc</a></li><li class="chapter-item "><a href="basic-syntax/methods.html"><strong aria-hidden="true">6.5.2.</strong> 方法</a></li><li class="chapter-item "><a href="basic-syntax/functions-interlude.html"><strong aria-hidden="true">6.5.3.</strong> 重载</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/day-1/morning.html"><strong aria-hidden="true">7.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/implicit-conversions.html"><strong aria-hidden="true">7.1.</strong> 隐式类型转换</a></li><li class="chapter-item "><a href="exercises/day-1/for-loops.html"><strong aria-hidden="true">7.2.</strong> 数组与 for 循环</a></li></ol></li><li class="chapter-item "><li class="part-title">第 1 天：下午</li><li class="chapter-item "><a href="control-flow.html"><strong aria-hidden="true">8.</strong> 控制流</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/blocks.html"><strong aria-hidden="true">8.1.</strong> 块</a></li><li class="chapter-item "><a href="control-flow/if-expressions.html"><strong aria-hidden="true">8.2.</strong> if 表达式</a></li><li class="chapter-item "><a href="control-flow/for-expressions.html"><strong aria-hidden="true">8.3.</strong> for 表达式</a></li><li class="chapter-item "><a href="control-flow/while-expressions.html"><strong aria-hidden="true">8.4.</strong> while 表达式</a></li><li class="chapter-item "><a href="control-flow/break-continue.html"><strong aria-hidden="true">8.5.</strong> break &amp; continue</a></li><li class="chapter-item "><a href="control-flow/loop-expressions.html"><strong aria-hidden="true">8.6.</strong> loop 表达式</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/variables.html"><strong aria-hidden="true">9.</strong> 变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/type-inference.html"><strong aria-hidden="true">9.1.</strong> 类型推导</a></li><li class="chapter-item "><a href="basic-syntax/static-and-const.html"><strong aria-hidden="true">9.2.</strong> 静态与常量</a></li><li class="chapter-item "><a href="basic-syntax/scopes-shadowing.html"><strong aria-hidden="true">9.3.</strong> 作用域和隐藏 (Shadowing)</a></li></ol></li><li class="chapter-item "><a href="enums.html"><strong aria-hidden="true">10.</strong> 枚举</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enums/variant-payloads.html"><strong aria-hidden="true">10.1.</strong> 变体载荷</a></li><li class="chapter-item "><a href="enums/sizes.html"><strong aria-hidden="true">10.2.</strong> 枚举大小</a></li></ol></li><li class="chapter-item "><a href="control-flow/novel.html"><strong aria-hidden="true">11.</strong> Novel Control Flow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/if-let-expressions.html"><strong aria-hidden="true">11.1.</strong> if let 表达式</a></li><li class="chapter-item "><a href="control-flow/while-let-expressions.html"><strong aria-hidden="true">11.2.</strong> while let 表达式</a></li><li class="chapter-item "><a href="control-flow/match-expressions.html"><strong aria-hidden="true">11.3.</strong> match 表达式</a></li></ol></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">12.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">12.1.</strong> 解构枚举</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">12.2.</strong> 解构结构体</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-arrays.html"><strong aria-hidden="true">12.3.</strong> 解构数组</a></li><li class="chapter-item "><a href="pattern-matching/match-guards.html"><strong aria-hidden="true">12.4.</strong> 匹配守卫</a></li></ol></li><li class="chapter-item "><a href="exercises/day-1/afternoon.html"><strong aria-hidden="true">13.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/luhn.html"><strong aria-hidden="true">13.1.</strong> Luhn 算法</a></li><li class="chapter-item "><a href="exercises/day-1/pattern-matching.html"><strong aria-hidden="true">13.2.</strong> 模式匹配</a></li></ol></li><li class="chapter-item "><li class="part-title">第二天：上午</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">14.</strong> 欢迎</a></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">15.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/stack-vs-heap.html"><strong aria-hidden="true">15.1.</strong> 栈 vs 堆</a></li><li class="chapter-item "><a href="memory-management/stack.html"><strong aria-hidden="true">15.2.</strong> 栈内存</a></li><li class="chapter-item "><a href="memory-management/manual.html"><strong aria-hidden="true">15.3.</strong> 手动内存管理</a></li><li class="chapter-item "><a href="memory-management/scope-based.html"><strong aria-hidden="true">15.4.</strong> 基于作用域的内存管理</a></li><li class="chapter-item "><a href="memory-management/garbage-collection.html"><strong aria-hidden="true">15.5.</strong> 垃圾回收</a></li><li class="chapter-item "><a href="memory-management/rust.html"><strong aria-hidden="true">15.6.</strong> Rust 内存管理</a></li></ol></li><li class="chapter-item "><a href="ownership.html"><strong aria-hidden="true">16.</strong> 所有权</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/move-semantics.html"><strong aria-hidden="true">16.1.</strong> 移动语义</a></li><li class="chapter-item "><a href="ownership/moved-strings-rust.html"><strong aria-hidden="true">16.2.</strong> Rust 中移动的字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/double-free-modern-cpp.html"><strong aria-hidden="true">16.2.1.</strong> 现代 C++ 中的双重释放</a></li></ol></li><li class="chapter-item "><a href="ownership/moves-function-calls.html"><strong aria-hidden="true">16.3.</strong> 函数调用中的移动</a></li><li class="chapter-item "><a href="ownership/copy-clone.html"><strong aria-hidden="true">16.4.</strong> 复制和克隆</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">16.5.</strong> 借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/shared-unique-borrows.html"><strong aria-hidden="true">16.5.1.</strong> 共享和唯一的借用</a></li></ol></li><li class="chapter-item "><a href="ownership/lifetimes.html"><strong aria-hidden="true">16.6.</strong> 生命周期</a></li><li class="chapter-item "><a href="ownership/lifetimes-function-calls.html"><strong aria-hidden="true">16.7.</strong> 函数调用中的生命周期</a></li><li class="chapter-item "><a href="ownership/lifetimes-data-structures.html"><strong aria-hidden="true">16.8.</strong> 数据结构中的生命周期</a></li></ol></li><li class="chapter-item "><a href="structs.html"><strong aria-hidden="true">17.</strong> 结构体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structs/tuple-structs.html"><strong aria-hidden="true">17.1.</strong> 元组结构体</a></li><li class="chapter-item "><a href="structs/field-shorthand.html"><strong aria-hidden="true">17.2.</strong> 字段简写语法</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">18.</strong> 方法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods/receiver.html"><strong aria-hidden="true">18.1.</strong> 方法接收者</a></li><li class="chapter-item "><a href="methods/example.html"><strong aria-hidden="true">18.2.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/morning.html"><strong aria-hidden="true">19.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/book-library.html"><strong aria-hidden="true">19.1.</strong> Storing Books</a></li><li class="chapter-item "><a href="exercises/day-2/health-statistics.html"><strong aria-hidden="true">19.2.</strong> 健康统计</a></li></ol></li><li class="chapter-item "><li class="part-title">第二天：下午</li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">20.</strong> 标准库</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/option-result.html"><strong aria-hidden="true">20.1.</strong> Option 和 Result</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">20.2.</strong> String</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">20.3.</strong> Vec</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">20.4.</strong> 哈希表</a></li><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">20.5.</strong> Box</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box-recursive.html"><strong aria-hidden="true">20.5.1.</strong> 递归数据类型</a></li><li class="chapter-item "><a href="std/box-niche.html"><strong aria-hidden="true">20.5.2.</strong> 小众优化</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">20.6.</strong> Rc</a></li><li class="chapter-item "><a href="std/cell.html"><strong aria-hidden="true">20.7.</strong> Cell/RefCell</a></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">21.</strong> 模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">21.1.</strong> 可见性</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">21.2.</strong> 路径</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">21.3.</strong> 文件系统层级结构</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/afternoon.html"><strong aria-hidden="true">22.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/iterators-and-ownership.html"><strong aria-hidden="true">22.1.</strong> 迭代器和所有权</a></li><li class="chapter-item "><a href="exercises/day-2/strings-iterators.html"><strong aria-hidden="true">22.2.</strong> 字符串和迭代器</a></li></ol></li><li class="chapter-item "><li class="part-title">第三天：上午</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">23.</strong> 欢迎</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">24.</strong> 泛型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/data-types.html"><strong aria-hidden="true">24.1.</strong> 通用数据类型</a></li><li class="chapter-item "><a href="generics/methods.html"><strong aria-hidden="true">24.2.</strong> 泛型方法</a></li><li class="chapter-item "><a href="generics/monomorphization.html"><strong aria-hidden="true">24.3.</strong> 单态化</a></li></ol></li><li class="chapter-item "><a href="traits.html"><strong aria-hidden="true">25.</strong> 特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/trait-objects.html"><strong aria-hidden="true">25.1.</strong> 特征（Trait）对象</a></li><li class="chapter-item "><a href="traits/deriving-traits.html"><strong aria-hidden="true">25.2.</strong> 派生特征</a></li><li class="chapter-item "><a href="traits/default-methods.html"><strong aria-hidden="true">25.3.</strong> 默认方法</a></li><li class="chapter-item "><a href="traits/trait-bounds.html"><strong aria-hidden="true">25.4.</strong> 特征边界</a></li><li class="chapter-item "><a href="traits/impl-trait.html"><strong aria-hidden="true">25.5.</strong> impl Trait</a></li></ol></li><li class="chapter-item "><a href="traits/important-traits.html"><strong aria-hidden="true">26.</strong> 重要特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/iterator.html"><strong aria-hidden="true">26.1.</strong> 迭代器</a></li><li class="chapter-item "><a href="traits/from-iterator.html"><strong aria-hidden="true">26.2.</strong> FromIterator</a></li><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">26.3.</strong> From 和 Into</a></li><li class="chapter-item "><a href="traits/read-write.html"><strong aria-hidden="true">26.4.</strong> 读取和写入</a></li><li class="chapter-item "><a href="traits/drop.html"><strong aria-hidden="true">26.5.</strong> Drop</a></li><li class="chapter-item "><a href="traits/default.html"><strong aria-hidden="true">26.6.</strong> Default</a></li><li class="chapter-item "><a href="traits/operators.html"><strong aria-hidden="true">26.7.</strong> 运算符：Add、Mul...</a></li><li class="chapter-item "><a href="traits/closures.html"><strong aria-hidden="true">26.8.</strong> 闭包：Fn、FnMut、FnOnce</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/morning.html"><strong aria-hidden="true">27.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/simple-gui.html"><strong aria-hidden="true">27.1.</strong> 一个简单的 GUI 库</a></li><li class="chapter-item "><a href="exercises/day-3/points-polygons.html"><strong aria-hidden="true">27.2.</strong> 点和多边形</a></li></ol></li><li class="chapter-item "><li class="part-title">第三天：下午</li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">28.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">28.1.</strong> Panics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panic-unwind.html"><strong aria-hidden="true">28.1.1.</strong> 捕获堆栈展开</a></li></ol></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">28.2.</strong> 结构化错误处理</a></li><li class="chapter-item "><a href="error-handling/try-operator.html"><strong aria-hidden="true">28.3.</strong> 使用 ? 传播错误</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types.html"><strong aria-hidden="true">28.3.1.</strong> 转换错误类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types-example.html"><strong aria-hidden="true">28.3.1.1.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="error-handling/deriving-error-enums.html"><strong aria-hidden="true">28.3.2.</strong> 派生错误枚举</a></li><li class="chapter-item "><a href="error-handling/dynamic-errors.html"><strong aria-hidden="true">28.3.3.</strong> 动态错误类型</a></li><li class="chapter-item "><a href="error-handling/error-contexts.html"><strong aria-hidden="true">28.3.4.</strong> 为错误添加背景信息</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">29.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">29.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="testing/test-modules.html"><strong aria-hidden="true">29.2.</strong> 测试模块</a></li><li class="chapter-item "><a href="testing/doc-tests.html"><strong aria-hidden="true">29.3.</strong> 文档测试</a></li><li class="chapter-item "><a href="testing/integration-tests.html"><strong aria-hidden="true">29.4.</strong> 集成测试</a></li><li class="chapter-item "><a href="testing/useful-crates.html"><strong aria-hidden="true">29.5.</strong> 实用 crate</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">30.</strong> 不安全 Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointers.html"><strong aria-hidden="true">30.1.</strong> 解引用裸指针</a></li><li class="chapter-item "><a href="unsafe/mutable-static-variables.html"><strong aria-hidden="true">30.2.</strong> 可变的静态变量</a></li><li class="chapter-item "><a href="unsafe/unions.html"><strong aria-hidden="true">30.3.</strong> 联合体</a></li><li class="chapter-item "><a href="unsafe/calling-unsafe-functions.html"><strong aria-hidden="true">30.4.</strong> 调用 Unsafe 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/writing-unsafe-functions.html"><strong aria-hidden="true">30.4.1.</strong> 编写 Unsafe 函数</a></li><li class="chapter-item "><a href="unsafe/extern-functions.html"><strong aria-hidden="true">30.4.2.</strong> 外部函数</a></li></ol></li><li class="chapter-item "><a href="unsafe/unsafe-traits.html"><strong aria-hidden="true">30.5.</strong> 实现 Unsafe Trait</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/afternoon.html"><strong aria-hidden="true">31.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/safe-ffi-wrapper.html"><strong aria-hidden="true">31.1.</strong> 安全 FFI 封装容器</a></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">32.</strong> 欢迎</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">33.</strong> 设置</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">34.</strong> 构建规则</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">34.1.</strong> 可执行文件</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">34.2.</strong> 库</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">35.</strong> AIDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/interface.html"><strong aria-hidden="true">35.1.</strong> 接口</a></li><li class="chapter-item "><a href="android/aidl/implementation.html"><strong aria-hidden="true">35.2.</strong> 实现</a></li><li class="chapter-item "><a href="android/aidl/server.html"><strong aria-hidden="true">35.3.</strong> 服务器</a></li><li class="chapter-item "><a href="android/aidl/deploy.html"><strong aria-hidden="true">35.4.</strong> 部署</a></li><li class="chapter-item "><a href="android/aidl/client.html"><strong aria-hidden="true">35.5.</strong> 客户端</a></li><li class="chapter-item "><a href="android/aidl/changing.html"><strong aria-hidden="true">35.6.</strong> 更改 API</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">36.</strong> 日志记录</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">37.</strong> 互操作性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">37.1.</strong> 与 C 语言交互</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">37.1.1.</strong> 使用Bindgen调用C语言</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">37.1.2.</strong> 从C语言调用Rust语言</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">37.2.</strong> 与 C++ 交互</a></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">37.3.</strong> 与 Java 交互</a></li></ol></li><li class="chapter-item "><a href="exercises/android/morning.html"><strong aria-hidden="true">38.</strong> 习题</a></li><li class="chapter-item affix "><li class="part-title">裸机:上午</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">39.</strong> 欢迎</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">40.</strong> no_std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">40.1.</strong> 最小示例</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">40.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">41.</strong> 微控制器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">41.1.</strong> 原始 MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">41.2.</strong> PAC</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">41.3.</strong> HAL crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">41.4.</strong> 板级支持 Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">41.5.</strong> 类型状态模式</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">41.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">41.7.</strong> probe-rs、cargo-embed</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">41.7.1.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">41.8.</strong> 其他项目</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">42.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">42.1.</strong> 罗盘</a></li></ol></li><li class="chapter-item "><li class="part-title">裸机:下午</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">43.</strong> 应用处理器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">43.1.</strong> 准备使用 Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">43.2.</strong> 内嵌汇编</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">43.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">43.4.</strong> 编写 UART 驱动程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">43.4.1.</strong> 更多 trait</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">43.5.</strong> 一个更好的 UART 驱动程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">43.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">43.5.2.</strong> 多个寄存器</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">43.5.3.</strong> 驱动程序</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">43.5.4.</strong> 开始使用</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">43.6.</strong> 日志记录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">43.6.1.</strong> 开始使用</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">43.7.</strong> Exceptions</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">43.8.</strong> 其他项目</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">44.</strong> 实用 crate</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">44.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">44.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">44.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">44.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">44.5.</strong> 转动</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">45.</strong> Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">45.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">46.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">46.1.</strong> RTC驱动</a></li></ol></li><li class="chapter-item "><li class="part-title">并发编程：入门篇</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency.html"><strong aria-hidden="true">47.</strong> 欢迎</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">48.</strong> 线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/scoped-threads.html"><strong aria-hidden="true">48.1.</strong> 范围线程</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">49.</strong> 通道</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">49.1.</strong> 无界通道</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">49.2.</strong> 有界通道</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">50.</strong> Send 和 Sync</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">50.1.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">50.2.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">50.3.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared_state.html"><strong aria-hidden="true">51.</strong> 共享状态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared_state/arc.html"><strong aria-hidden="true">51.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared_state/mutex.html"><strong aria-hidden="true">51.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared_state/example.html"><strong aria-hidden="true">51.3.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/morning.html"><strong aria-hidden="true">52.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers.html"><strong aria-hidden="true">52.1.</strong> 哲学家就餐问题 (Dining philosophers problem)</a></li><li class="chapter-item "><a href="exercises/concurrency/link-checker.html"><strong aria-hidden="true">52.2.</strong> 多线程链接检查器</a></li></ol></li><li class="chapter-item "><li class="part-title">并发：下午</li><li class="chapter-item "><a href="async.html"><strong aria-hidden="true">53.</strong> 异步基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">53.1.</strong> async/await</a></li><li class="chapter-item "><a href="async/futures.html"><strong aria-hidden="true">53.2.</strong> Futures</a></li><li class="chapter-item "><a href="async/runtimes.html"><strong aria-hidden="true">53.3.</strong> Runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/runtimes/tokio.html"><strong aria-hidden="true">53.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="async/tasks.html"><strong aria-hidden="true">53.4.</strong> 任务</a></li><li class="chapter-item "><a href="async/channels.html"><strong aria-hidden="true">53.5.</strong> 异步通道</a></li></ol></li><li class="chapter-item "><a href="async/control-flow.html"><strong aria-hidden="true">54.</strong> 控制流</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/control-flow/join.html"><strong aria-hidden="true">54.1.</strong> 加入</a></li><li class="chapter-item "><a href="async/control-flow/select.html"><strong aria-hidden="true">54.2.</strong> 选择</a></li></ol></li><li class="chapter-item "><a href="async/pitfalls.html"><strong aria-hidden="true">55.</strong> 误区</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/pitfalls/blocking-executor.html"><strong aria-hidden="true">55.1.</strong> 屏蔽执行器</a></li><li class="chapter-item "><a href="async/pitfalls/pin.html"><strong aria-hidden="true">55.2.</strong> 固定</a></li><li class="chapter-item "><a href="async/pitfalls/async-traits.html"><strong aria-hidden="true">55.3.</strong> 异步特质</a></li><li class="chapter-item "><a href="async/pitfalls/cancellation.html"><strong aria-hidden="true">55.4.</strong> Cancellation</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/afternoon.html"><strong aria-hidden="true">56.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers-async.html"><strong aria-hidden="true">56.1.</strong> 哲学家就餐问题 (Dining philosophers problem)</a></li><li class="chapter-item "><a href="exercises/concurrency/chat-app.html"><strong aria-hidden="true">56.2.</strong> 广播聊天应用程序</a></li></ol></li><li class="chapter-item "><li class="part-title">结束语</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">57.</strong> 谢谢！</a></li><li class="chapter-item "><a href="glossary.html"><strong aria-hidden="true">58.</strong> Glossary</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">59.</strong> 其他资源</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">60.</strong> 鸣谢</a></li><li class="chapter-item affix "><li class="part-title">解答</li><li class="spacer"></li><li class="chapter-item "><a href="exercises/solutions.html"><strong aria-hidden="true">61.</strong> 解答</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/solutions-morning.html"><strong aria-hidden="true">61.1.</strong> 第一天上午</a></li><li class="chapter-item "><a href="exercises/day-1/solutions-afternoon.html"><strong aria-hidden="true">61.2.</strong> 第一天下午</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-morning.html"><strong aria-hidden="true">61.3.</strong> 第二天上午</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-afternoon.html"><strong aria-hidden="true">61.4.</strong> 第二天下午</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-morning.html"><strong aria-hidden="true">61.5.</strong> 第三天上午</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-afternoon.html"><strong aria-hidden="true">61.6.</strong> 第三天下午</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">61.7.</strong> 嵌入式 Rust：入门篇</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">61.8.</strong> 嵌入式 Rust：进阶篇</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-morning.html"><strong aria-hidden="true">61.9.</strong> 并发编程：入门篇</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-afternoon.html"><strong aria-hidden="true">61.10.</strong> 并发编程：进阶篇</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Comprehensive Rust 🦀</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (Português do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (한국어)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (Español)</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-CN");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          
                          let full_path_to_root = "../";
                          
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#欢迎来到-comprehensive-rust-" id="欢迎来到-comprehensive-rust-">欢迎来到 Comprehensive Rust 🦀</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="Build workflow" /></a> <a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub contributors" /></a> <a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub stars" /></a></p>
<p>这是由 Android 团队开发的免费 Rust 课程。该课程涵盖了 Rust 的全部范围,从基本语法到高级主题如泛型和错误处理。</p>
<blockquote>
<p>如需查看课程的最新版本,请访问 <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a>。如果您是在其他地方阅读,请查看这个网址了解是否有更新。</p>
</blockquote>
<p>本课程的目标是教授你 Rust。我们假设你对 Rust 一无所知，并希望能够：</p>
<ul>
<li>帮助你全面理解 Rust 的语法和语言。</li>
<li>使你能够修改现有的程序并用 Rust 编写新程序。</li>
<li>展示常见的 Rust 习语。</li>
</ul>
<p>我们将前三天的课程称为<code>Rust 基础知识</code>。</p>
<p>在此基础上,你可以选择深入学习一个或多个专门的主题:</p>
<ul>
<li><a href="android.html">Android</a>：一个半天的课程，介绍如何在 Android 平台开发中使用 Rust（AOSP）。课程内容包括与 C、C++ 和 Java 的互操作性。</li>
<li><a href="bare-metal.html">Bare-metal</a>:为期一天的课程,介绍如何使用 Rust 进行裸机(嵌入式)开发。课程内容涵盖微控制器和应用处理器。</li>
<li><a href="concurrency.html">Concurrency</a>: a whole-day class on concurrency in Rust. We cover both classical concurrency (preemptively scheduling using threads and mutexes) and async/await concurrency (cooperative multitasking using futures).</li>
</ul>
<h2><a class="header" href="#非目标" id="非目标">非目标</a></h2>
<p>Rust 是一门庞大的语言，我们无法在几天内涵盖所有内容。本课程的一些非目标包括：</p>
<ul>
<li>Learning how to develop macros: please see <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Chapter 19.5 in the Rust Book</a> and <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by Example</a> instead.</li>
</ul>
<h2><a class="header" href="#前提假设" id="前提假设">前提假设</a></h2>
<p>The course assumes that you already know how to program. Rust is a statically-typed language and we will sometimes make comparisons with C and C++ to better explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically-typed language such as Python or JavaScript, then you will be able to follow along just fine too.</p>
<details>
<p>This is an example of a <em>speaker note</em>. We will use these to add additional information to the slides. This could be key points which the instructor should cover as well as answers to typical questions which come up in class.</p>
</details><h1><a class="header" href="#授课" id="授课">授课</a></h1>
<blockquote>
<p>本页面适用于课程教师。</p>
</blockquote>
<p>以下是有关 Google 内部授课方式的一些背景信息。</p>
<p>上课时间通常是从上午 10:00 到下午 4:00,中间有 1 小时的午餐休息时间。这样,上午和下午各留了 2.5 小时的上课时间。请注意,这仅是建议:您也可以上午上课 3 小时,让学员有更多的时间进行练习。上课时间较长的缺点是,学员上了整整 6 小时的课,到了下午可能会非常疲倦。</p>
<p>在授课之前，你需要完成以下事项：</p>
<ol>
<li>
<p>熟悉课程资料。我们添加了演讲者备注，借此强调要点（请帮个忙，多多贡献演讲者备注！）。演示幻灯片时，你应确保在弹出式窗口中打开演讲者备注（点击对应的链接，在“演讲者备注”旁边有一个小箭头）。这样，你就可以确保屏幕整洁有序，更好地向全班学员展示课程内容。</p>
</li>
<li>
<p>确定培训日期。由于本课程至少需要三天的时间，因此我们建议你安排两周以上的时间。课程学员曾表示，在每堂课之间留一段间隔会很有帮助，因为这有利于他们吸收我们所提供的所有信息。</p>
</li>
<li>
<p>找一间足以容纳全体线下学员的大教室。我们建议你将课程人数控制在 15-25 人之间。这样，人数足够少，不仅便于学员提问问题，配备的一位教师也有时间答疑解惑。确保教室备有供你和学生使用的“课桌”：你们都需要能够坐下来并操作各自的笔记本电脑。特别是身为教师，你现场要进行大量编码，所以讲台对你来说用处不大。</p>
</li>
<li>
<p>在开课当天，请提前一点到教室，设置好教学设备。我们建议你直接在笔记本电脑上运行 <code>mdbook serve</code> 来演示课程内容（请参阅<a href="https://github.com/google/comprehensive-rust#building">安装说明</a>）。这样可以确保你在切换页面时没有延迟，演示效果更好。当你或课程学员发现拼写错误时，你也可以使用笔记本电脑及时更正。</p>
</li>
<li>
<p>让学员采取小组形式或独立解题。通常，我们会在上午和下午各安排 30-45 分钟的练习时间（包括查看解决方案的时间）。请务必询问学员是否遇到困难，或是否需要任何帮助。如果你看到多位学员遇到同样的问题，请在班级集体进行讲解，并提供相应的解决方案，例如告诉大家在标准库的什么位置可以找到相关信息。</p>
</li>
</ol>
<p>今天的分享就是这些，祝你授课顺利！希望你和我们一样，乐在其中！</p>
<p>欢迎你课后<a href="https://github.com/google/comprehensive-rust/discussions/86">提供反馈</a>，帮助我们不断改进课程。我们非常期待了解哪些方面做得不错，哪些方面还需要改进。同时非常欢迎学生们<a href="https://github.com/google/comprehensive-rust/discussions/100">向我们发送反馈</a>！</p>
<h1><a class="header" href="#课程结构" id="课程结构">课程结构</a></h1>
<blockquote>
<p>本页面适用于课程教师。</p>
</blockquote>
<h2><a class="header" href="#rust-二进制文件" id="rust-二进制文件">Rust 二进制文件</a></h2>
<p>我们会在头三天介绍 <a href="running-the-course/../welcome-day-1.html">Rust 基础知识</a>。这几天的步调会稍快,因为我们要探讨许多层面:</p>
<ul>
<li>第 1 天:Rust 基础知识、语法、控制流、创建和使用值。</li>
<li>Day 2: Memory management, ownership, compound data types, and the standard library.</li>
<li>Day 3: Generics, traits, error handling, testing, and unsafe Rust.</li>
</ul>
<h2><a class="header" href="#深入探究" id="深入探究">深入探究</a></h2>
<p>除了为期 3 天的“Rust 基础知识”课程外，我们还推出了一些专题课程：</p>
<h3><a class="header" href="#rust-in-android" id="rust-in-android">Rust in Android</a></h3>
<p>The <a href="running-the-course/../android.html">Rust in Android</a> deep dive is a half-day course on using Rust for Android platform development. This includes interoperability with C, C++, and Java.</p>
<p>你将需要<a href="https://source.android.com/docs/setup/download/downloading">签出 AOSP</a>。在同一机器上签出<a href="https://github.com/google/comprehensive-rust">课程库</a>， 然后将 <code>src/android/</code> 目录移至所签出的 AOSP 的根目录。这将确保 Android 构建系统能检测到 <code>src/android/</code> 中的 <code>Android.bp</code> 文件。</p>
<p>确保 <code>adb sync</code> 适用于你的模拟器或实际设备， 并使用 <code>src/android/build_all.sh</code> 预构建所有 Android 示例。请阅读脚本， 查看它所运行的命令，并确保这些命令能在你手动运行时正确执行。</p>
<h3><a class="header" href="#bare-metal-rust" id="bare-metal-rust">Bare-Metal Rust</a></h3>
<p>The <a href="running-the-course/../bare-metal.html">Bare-Metal Rust</a> deep dive is a full day class on using Rust for bare-metal (embedded) development. Both microcontrollers and application processors are covered.</p>
<p>对于微控制器部分，你需要提前购买 <a href="https://microbit.org/">BBC micro:bit</a> 第 2 版开发板。每个人都需要安装多个软件包， 具体如<a href="running-the-course/../bare-metal.html">欢迎页面</a>中所述。</p>
<h3><a class="header" href="#欢迎了解-rust-中的并发" id="欢迎了解-rust-中的并发">欢迎了解 Rust 中的并发</a></h3>
<p><code>[深入探究并发](../concurrency.md)</code>课程为期一天,旨在介绍传统并发和 <code>async</code>/<code>await</code> 并发。</p>
<p>你需要设置一个新 crate，下载所需的依赖项， 做好课前准备。然后，你可以将示例复制/粘贴到 <code>src/main.rs</code> 中， 以便对以下代码进行实验：</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<h2><a class="header" href="#课程形式" id="课程形式">课程形式</a></h2>
<p>本课程的互动性非常强， 建议你以问题驱动探索 Rust！</p>
<h1><a class="header" href="#键盘快捷键" id="键盘快捷键">键盘快捷键</a></h1>
<p>mdBook 中有一些实用键盘快捷键：</p>
<ul>
<li><kbd>向左箭头</kbd>：转到上一页。</li>
<li><kbd>向右箭头</kbd>：转到下一页。</li>
<li><kbd>Ctrl + Enter</kbd>：执行具有焦点的代码示例。</li>
<li><kbd>s</kbd>：激活搜索栏。</li>
</ul>
<h1><a class="header" href="#翻译" id="翻译">翻译</a></h1>
<p>一批优秀的志愿者已将本课程翻译成其他语言：</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">巴西葡萄牙语版本</a>译者:<a href="https://github.com/rastringer">@rastringer</a>、<a href="https://github.com/hugojacob">@hugojacob</a>、<a href="https://github.com/joaovicmendes">@joaovicmendes</a> 和 <a href="https://github.com/henrif75">@henrif75</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">韩语版本</a>译者:<a href="https://github.com/keispace">@keispace</a>、<a href="https://github.com/jiyongp">@jiyongp</a> 和 <a href="https://github.com/jooyunghan">@jooyunghan</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/es/">Spanish</a> by <a href="https://github.com/deavid">@deavid</a>.</li>
</ul>
<p>使用右上角的语言选择器切换语言。</p>
<h2><a class="header" href="#未完成的翻译" id="未完成的翻译">未完成的翻译</a></h2>
<p>多数语言版本仍在翻译中。我们会提供最近更新的翻译的链接：</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/bn/">孟加拉语版本</a>译者:<a href="https://github.com/raselmandol">@raselmandol</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-TW/">Chinese (Traditional)</a> by <a href="https://github.com/hueich">@hueich</a>, <a href="https://github.com/victorhsieh">@victorhsieh</a>, <a href="https://github.com/mingyc">@mingyc</a>, and <a href="https://github.com/johnathan79717">@johnathan79717</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/">Chinese (Simplified)</a> by <a href="https://github.com/suetfei">@suetfei</a>, <a href="https://github.com/wnghl">@wnghl</a>, <a href="https://github.com/anlunx">@anlunx</a>, <a href="https://github.com/kongy">@kongy</a>, <a href="https://github.com/noahdragon">@noahdragon</a>, and <a href="https://github.com/superwhd">@superwhd</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">法语版本</a>译者:<a href="https://github.com/KookaS">@KookaS</a> 和 <a href="https://github.com/vcaen">@vcaen</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">德语版本</a>译者:<a href="https://github.com/Throvn">@Throvn</a> 和 <a href="https://github.com/ronaldfw">@ronaldfw</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">日语版本</a>译者:<a href="https://github.com/CoinEZ">@CoinEZ-JPN</a> 和 <a href="https://github.com/momotaro1105">@momotaro1105</a>。</li>
</ul>
<p>如果你想帮助我们,请参阅<a href="htts://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md">我们的说明</a>,了解如何开始翻译。翻译工作将通过<a href="https://github.com/google/comprehensive-rust/issues/282">问题跟踪器</a>.</p>
<h1><a class="header" href="#使用-cargo" id="使用-cargo">使用 Cargo</a></h1>
<p>开始了解 Rust 后，你很快就会遇到 <a href="https://doc.rust-lang.org/cargo/">Cargo</a>，这是 Rust 生态系统中 用于构建和运行 Rust 应用的标准工具。在这里，我们希望 简要介绍一下什么是 Cargo，它如何融入更广泛的生态系统， 以及我们如何在本培训中合理利用 Cargo。</p>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<blockquote>
<p><strong>请按照 <a href="https://rustup.rs/">https://rustup.rs/</a> 上的说明操作。</strong></p>
</blockquote>
<p>这将为你提供 Cargo 构建工具 (<code>cargo</code>)和 Rust 编译器 (<code>rustc</code>)。你还将获得 <code>rustup</code>,这是一个命令行实用程序,你可以用它来安装不同的编译器版本。</p>
<p>After installing Rust, you should configure your editor or IDE to work with Rust. Most editors do this by talking to <a href="https://rust-analyzer.github.io/">rust-analyzer</a>, which provides auto-completion and jump-to-definition functionality for <a href="https://code.visualstudio.com/">VS Code</a>, <a href="https://rust-analyzer.github.io/manual.html#emacs">Emacs</a>, <a href="https://rust-analyzer.github.io/manual.html#vimneovim">Vim/Neovim</a>, and many others. There is also a different IDE available called <a href="https://www.jetbrains.com/rust/">RustRover</a>.</p>
<details>
<ul>
<li>
<p>在 Debian/Ubuntu 上,你也可以通过 <code>apt</code> 安装 Cargo、Rust 源代码和 <a href="https://github.com/rust-lang/rustfmt">Rust 格式设置工具</a>。但是,这样会得到一个过时的 Rust 版本,可能会导致意外的行为。命令如下:</p>
<pre><code class="language-shell">sudo apt install cargo rust-src rustfmt
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#rust-生态系统" id="rust-生态系统">Rust 生态系统</a></h1>
<p>Rust 生态系统由许多工具组成，其中的主要工具包括：</p>
<ul>
<li>
<p><code>rustc</code>：Rust 编译器，可将 <code>.rs</code> 文件转换为二进制文件和其他 中间格式。</p>
</li>
<li>
<p><code>cargo</code>:Rust 依赖项管理器和构建工具。Cargo 知道如何 下载托管在 <a href="https://crates.io">https://crates.io</a> 上的依赖项,并在构建项目时将它们 传递给 <code>rustc</code>。Cargo 还附带一个内置的 测试运行程序,用于执行单元测试。</p>
</li>
<li>
<p><code>rustup</code>：Rust 工具链安装程序和更新程序。发布新版本 Rust 时，此工具用于 安装并更新 <code>rustc</code> 和 <code>cargo</code>。 此外，<code>rustup</code> 还可以下载标准 库的文档。你可以同时安装多个版本的 Rust，并且 <code>rustup</code> 可让你根据需要在这些版本之间切换。</p>
</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>Rust 有一个快速发布时间表，每六周就会发布一次 新版本。新版本保持与 旧版本的向后兼容性，还添加了新功能。</p>
</li>
<li>
<p>共有三个发布阶段：“稳定版”“Beta 版”和“夜间版”。</p>
</li>
<li>
<p>我们会在“夜间版”上测试新功能，每六周将“Beta 版”升级为 “稳定版”。</p>
</li>
<li>
<p>您也可以通过备用的<a href="https://doc.rust-lang.org/cargo/reference/registries.html">注册数据库</a>、git、文件夹等资源来解析依赖项。</p>
</li>
<li>
<p>Rust 也有三个[版本]：当前版本是 Rust 2021。之前的 版本是 Rust 2015 和 Rust 2018。</p>
<ul>
<li>
<p>这些版本支持对语言进行向后不兼容的 更改。</p>
</li>
<li>
<p>为防止破坏代码，你可以自行选择版本： 通过 <code>Cargo.toml</code> 文件为 crate 选择合适的版本。</p>
</li>
<li>
<p>为免分割生态系统，Rust 编译器可以混合使用 为不同版本编写的代码。</p>
</li>
<li>
<p>提及不通过 <code>cargo</code> 而直接使用编译器的情况相当少见（大多数用户从不这样做）。</p>
</li>
<li>
<p>值得注意的是，Cargo 本身就是一个功能强大且全面的工具。它能够实现许多高级功能，包括但不限于：</p>
<ul>
<li>项目/软件包结构</li>
<li>[工作区]</li>
<li>开发依赖项和运行时依赖项管理/缓存</li>
<li>[构建脚本]</li>
<li>[全局安装] ]</li>
<li>它还可以使用子命令插件（例如 <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>）进行扩展。</li>
</ul>
</li>
<li>
<p>如需了解详情，请参阅[ Cargo 官方图书]</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#本培训中的代码示例" id="本培训中的代码示例">本培训中的代码示例</a></h1>
<p>在本培训中，我们将主要通过示例 探索 Rust 语言，这些示例可通过浏览器执行。这能大大简化设置过程， 并确保所有人都能获得一致的体验。</p>
<p>我们仍然建议你安装 Cargo：它有助于你更轻松地完成 练习。在最后一天，我们要做一个更大的练习， 向你展示如何使用依赖项，因此你需要安装 Cargo。</p>
<p>本课程中的代码块是完全交互式的：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>当文本框为 焦点时，你可以使用 <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the text box.</p>
<details>
<p>大多数代码示例都可修改（如上图所示）。少数代码示例 可能会因各种原因而不可修改：</p>
<ul>
<li>
<p>嵌入式 Playground 无法执行单元测试。将代码复制并粘贴 到实际 Playground 中，以演示单元测试。</p>
</li>
<li>
<p>嵌入式 Playground 会在你离开页面后立即 丢失其状态！正因如此，学员应使用本地安装的 Rust 或通过 Playground 解题。</p>
</li>
</ul>
</details><h1><a class="header" href="#使用-cargo-在本地运行代码" id="使用-cargo-在本地运行代码">使用 Cargo 在本地运行代码</a></h1>
<p>如果你想在自己的系统上对代码进行实验， 则需要先安装 Rust。为此，请按照 <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust 图书中的 说明</a>操作。这应会为你提供一个有效的 <code>rustc</code> 和 <code>cargo</code>。在撰写 本文时，最新的 Rust 稳定版具有以下版本号：</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>您也可以使用任何更高版本,因为 Rust 保持向后兼容性。</p>
<p>了解这些信息后，请按照以下步骤从本培训中的 一个示例中构建 Rust 二进制文件：</p>
<ol>
<li>
<p>在你要复制的示例上点击“复制到剪贴板”按钮。</p>
</li>
<li>
<p>使用 <code>cargo new exercise</code> 为你的代码新建一个 <code>exercise/</code> 目录：</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>导航至 <code>exercise/</code> 并使用 <code>cargo run</code> 构建并运行你的二进制文件：</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>将 <code>src/main.rs</code> 中的样板代码替换为你自己的代码。例如， 使用上一页中的示例，将 <code>src/main.rs</code> 改为：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>使用 <code>cargo run</code> 构建并运行你更新后的二进制文件：</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>使用 <code>cargo check</code> 快速检查项目是否存在错误；使用 <code>cargo build</code> 只进行编译，而不运行。你可以在 <code>target/debug/</code> 中找到常规调试 build 的输出。使用 <code>cargo build --release</code> 在 <code>target/release/</code> 中生成经过优化的 发布 build。</p>
</li>
<li>
<p>你可以通过修改 <code>Cargo.toml</code> 为项目添加依赖项。当你 运行 <code>cargo</code> 命令时，系统会自动为你下载和编译缺失 的依赖项。</p>
</li>
</ol>
<details>
<p>尽量鼓励全班学员安装 Cargo 并使用 本地编辑器。这能为他们营造常规 开发环境，让工作变得更加轻松。</p>
</details><h1><a class="header" href="#欢迎来到第一天" id="欢迎来到第一天">欢迎来到第一天</a></h1>
<p>This is the first day of Rust Fundamentals. We will cover a lot of ground today:</p>
<ul>
<li>
<p>Rust 基本语法：变量，标量（scalar）和复合（compound）类型，枚举（enum），结构体（struct），引用，函数和方法。</p>
</li>
<li>
<p>控制流的构造: <code>if</code>, <code>if let</code>, <code>while</code>, <code>while let</code>, <code>break</code>, 和 <code>continue</code>。</p>
</li>
<li>
<p>模式匹配: 解构枚举, 结构体和数组（array）。</p>
</li>
</ul>
<details>
<p>请提醒学生：</p>
<ul>
<li>他们可以随时提问，不需要留到最后。</li>
<li>这个课程本应该是互动的，我们鼓励大家积极讨论。
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e., keep the discussions related to how Rust does things vs some other language.  It can be hard to find the right balance, but err on the side of allowing  discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>有些问题会导致我们提前谈到后面的内容
<ul>
<li>这完全没有问题! 重复是学习的一个重要方法。请记得 这些幻灯片只是一个辅助，你可以选择性地跳过。</li>
</ul>
</li>
</ul>
<p>第一天的主要目标是要谈到著名的 borrow checker，其他方面点到为止。Rust 处理内存的方式是其主要特点，这点我们应该尽早展示给学生。</p>
<p>如果你是在教室里教授此课程，不妨在这里介绍一下时间安排。 这边建议是把每天分成两部分（跟着幻灯片来）：</p>
<ul>
<li>早上：9:00 到 12:00，</li>
<li>下午：13:00 到 16:00。</li>
</ul>
<p>当然你也可以看情况调整时间。但是请务必记得提供休息时间。我们建议每个小时休息一次！</p>
</details><h1><a class="header" href="#什么是-rust" id="什么是-rust">什么是 Rust？</a></h1>
<p>Rust 是一种新的编程语言，它的<a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 版本于 2015 年发布</a>：</p>
<ul>
<li>Rust 是一种静态编译语言，其功能定位与 C++ 相似
<ul>
<li><code>rustc</code> 使用 LLVM 作为它的后端。</li>
</ul>
</li>
<li>Rust 支持多种<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">平台和架构</a>:
<ul>
<li>x86, ARM, WebAssembly, ...</li>
<li>Linux, Mac, Windows, ...</li>
</ul>
</li>
<li>Rust 被广泛用于各种设备中：
<ul>
<li>固件和引导程序，</li>
<li>智能显示器，</li>
<li>手机，</li>
<li>桌面，</li>
<li>服务器。</li>
</ul>
</li>
</ul>
<details>
<p>Rust 和 C++ 适用于类似的场景：</p>
<ul>
<li>极高的灵活性。</li>
<li>高度的控制能力。</li>
<li>Can be scaled down to very constrained devices such as microcontrollers.</li>
<li>没有运行时和垃圾收集。</li>
<li>关注程序可靠性和安全性，而不会牺牲任何性能。</li>
</ul>
</details><h1><a class="header" href="#hello-world" id="hello-world">Hello World!</a></h1>
<p>让我们进入最简单的 Rust 程序，一个经典的 Hello World 程序：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello 🌍!&quot;);
}
</code></pre></pre>
<p>你看到的：</p>
<ul>
<li>函数以 <code>fn</code> 开头。</li>
<li>像 C 和 C++ 一样，块由花括号分隔。</li>
<li><code>main</code> 函数是程序的入口。</li>
<li>Rust 有卫生宏 (hygienic macros)，<code>println!</code> 就是一个例子。</li>
<li>Rust 字符串是 UTF-8 编码的，可以包含任何 Unicode 字符。</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see a ton of it over the next three days so we start small with something familiar.</p>
<p>关键点：</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is imperative and it doesn’t try to reinvent things unless absolutely necessary.</p>
</li>
<li>
<p>Rust 是一种现代编程语言，它完全支持 Unicode 等特性。</p>
</li>
<li>
<p>在需要处理可变数量的参数的情况下，Rust 使用宏（没有函数<a href="basic-syntax/functions-interlude.html">重载</a>）。</p>
</li>
<li>
<p>宏是“卫生的”意味着它们不会意外地捕获它们所在作用域中的标识符。Rust 的宏实际上只是<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">部分卫生</a>。</p>
</li>
<li>
<p>Rust is multi-paradigm. For example, it has powerful <a href="https://doc.rust-lang.org/book/ch17-00-oop.html">object-oriented programming features</a>, and, while it is not a functional language, it includes a range of <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">functional concepts</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#简短示例" id="简短示例">简短示例</a></h1>
<p>以下是一个简短的 Rust 示例程序</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {              // 程序入口
    let mut x: i32 = 6;  // 可变变量绑定
    print!(&quot;{x}&quot;);       // 与 printf 类似的输出宏
    while x != 1 {       // 表达式周围没有括号
        if x % 2 == 0 {  // 与其他语言类似的数值计算
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(&quot; -&gt; {x}&quot;);
    }
    println!();
}
</code></pre></pre>
<details>
<p>这段代码实现了 Collatz 猜想：猜想认为该循环总是会结束，但该猜想还没有被证明。可以编辑代码来尝试不同的输入。</p>
<p>关键点：</p>
<ul>
<li>
<p>说明所有变量的类型都是静态的。尝试删除 <code>i32</code> 来触发类型推断。尝试使用 <code>i8</code> 来触发运行时整数溢出。</p>
</li>
<li>
<p>将 <code>let mut x</code> 改为 <code>let x</code>，讨论出现的编译错误。</p>
</li>
<li>
<p>展示 <code>print!</code> 在参数与格式字符串不匹配时产生的编译错误。</p>
</li>
<li>
<p>展示如何使用 <code>{}</code> 作为占位符，来输出比单个变量更复杂的表达式。</p>
</li>
<li>
<p>向学生展示标准库，展示如何搜索 <code>std::fmt</code>，其中包含用于格式化字符串的微型语言规则。要点是让学生熟悉在标准库中搜索的过程。</p>
<ul>
<li>In a shell <code>rustup doc std::fmt</code> will open a browser on the local std::fmt documentation</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#为什么选择-rust" id="为什么选择-rust">为什么选择 Rust？</a></h1>
<p>Rust 有一些独特的卖点：</p>
<ul>
<li>编译期内存安全。</li>
<li>没有运行时未定义行为。</li>
<li>现代的编程语言特性。</li>
</ul>
<details>
<p>应该问问学生们都使用过哪些语言。根据答案侧重讲解 Rust 的不同特性：</p>
<ul>
<li>
<p>使用过 C 或 C++：Rust 利用”借用检查”消除了一类 <em>运行时错误</em> 。你可以达到堪比 C 和 C++ 的性能，而没有内存不安全的问题。并且你还可以得到些现代的语言构造，比如模式匹配和内置依赖管理。</p>
</li>
<li>
<p>使用过 Java, Go, Python, JavaScript...：你可以得到和这些语言相同的内存安全特性，并拥有类似的使用高级语言的感受。同时你可以得到类似 C 和 C++ 的高速且可预测的执行性能（无垃圾回收机制），以及在需要时对底层硬件的访问。</p>
</li>
</ul>
</details><h1><a class="header" href="#an-example-in-c" id="an-example-in-c">An Example in C</a></h1>
<p>Let’s consider the following “minimum wrong example” program in C:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;

int main(int argc, char* argv[]) {
	char *buf, *filename;
	FILE *fp;
	size_t bytes, len;
	struct stat st;

	switch (argc) {
		case 1:
			printf(&quot;Too few arguments!\n&quot;);
			return 1;

		case 2:
			filename = argv[argc];
			stat(filename, &amp;st);
			len = st.st_size;
			
			buf = (char*)malloc(len);
			if (!buf)
				printf(&quot;malloc failed!\n&quot;, len);
				return 1;

			fp = fopen(filename, &quot;rb&quot;);
			bytes = fread(buf, 1, len, fp);
			if (bytes = st.st_size)
				printf(&quot;%s&quot;, buf);
			else
				printf(&quot;fread failed!\n&quot;);

		case 3:
			printf(&quot;Too many arguments!\n&quot;);
			return 1;
	}

	return 0;
}
</code></pre>
<p>How many bugs do you spot?</p>
<details>
<p>Despite just 29 lines of code, this C example contains serious bugs in at least 11:</p>
<ol>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code> (line 28)</li>
<li>Excess argument to <code>printf</code> (line 23)</li>
<li>File descriptor leak (after line 26)</li>
<li>Forgotten braces in multi-line <code>if</code> (line 22)</li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement (line 32)</li>
<li>Forgotten NUL-termination of the <code>buf</code> string, leading to a buffer overflow (line 29)</li>
<li>Memory leak by not freeing the <code>malloc</code>-allocated buffer (line 21)</li>
<li>Out-of-bounds access (line 17)</li>
<li>Unchecked cases in the <code>switch</code> statement (line 11)</li>
<li>Unchecked return values of <code>stat</code> and <code>fopen</code> (lines 18 and 26)</li>
</ol>
<p><em>Shouldn’t these bugs be obvious even for a C compiler?</em><br />
No, surprisingly this code compiles warning-free at the default warning level, even in the latest GCC version (13.2 as of writing).</p>
<p><em>Isn’t this a highly unrealistic example?</em><br />
Absolutely not, these kind of bugs have lead to serious security vulnerabilities in the past. Some examples:</p>
<ul>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code>: <a href="https://freedom-to-tinker.com/2013/10/09/the-linux-backdoor-attempt-of-2003">The Linux Backdoor Attempt of 2003</a></li>
<li>Forgotten braces in multi-line <code>if</code>: <a href="https://dwheeler.com/essays/apple-goto-fail.html">The Apple goto fail vulnerability</a></li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement: <a href="https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-the-break-that-broke-sudo">The break that broke sudo</a></li>
</ul>
<p><em>How is Rust any better here?</em><br />
Safe Rust makes all of these bugs impossible:</p>
<ol>
<li>Assignments inside an <code>if</code> clause are not supported.</li>
<li>Format strings are checked at compile-time.</li>
<li>Resources are freed at the end of scope via the <code>Drop</code> trait.</li>
<li>All <code>if</code> clauses require braces.</li>
<li><code>match</code> (as the Rust equivalent to <code>switch</code>) does not fall-through, hence you can’t accidentally forget a <code>break</code>.</li>
<li>Buffer slices carry their size and don’t rely on a NUL terminator.</li>
<li>Heap-allocated memory is freed via the <code>Drop</code> trait when the corresponding <code>Box</code> leaves the scope.</li>
<li>Out-of-bounds accesses cause a panic or can be checked via the <code>get</code> method of a slice.</li>
<li><code>match</code> mandates that all cases are handled.</li>
<li>Fallible Rust functions return <code>Result</code> values that need to be unwrapped and thereby checked for success. Additionally, the compiler emits a warning if you miss to check the return value of a function marked with <code>#[must_use]</code>.</li>
</ol>
</details><h1><a class="header" href="#编译期保障" id="编译期保障">编译期保障</a></h1>
<p>编译期静态内存管理：</p>
<ul>
<li>不存在未初始化的变量。</li>
<li>不存在内存泄漏（<em>通常情况下</em>，见注释）。</li>
<li>不存在“双重释放”。</li>
<li>不存在“释放后使用”。</li>
<li>不存在 <code>NULL</code> 指针。</li>
<li>不存在被遗忘的互斥锁。</li>
<li>不存在线程之间的数据竞争。</li>
<li>不存在迭代器失效。</li>
</ul>
<details>
<p>在（安全的）Rust 中也有可能产生内存泄漏。例如：</p>
<ul>
<li>You can use <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to leak a pointer. A use of this could be to get runtime-initialized and runtime-sized static variables</li>
<li>可以使用 <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> 来让编译器“忘记”一个值（即其析构函数不会被执行）。</li>
<li>可以使用 <code>Rc</code> 或 <code>Arc</code> 意外创建一个循环引用（<a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycle</a>）。</li>
<li>实际上，有人认为无限填充一个集合也是一种内存泄漏，Rust 对此没有保护。</li>
</ul>
<p>就本课程而言，“不存在内存泄漏”应理解为“几乎没有 <em>意外</em> 内存泄漏”。</p>
</details><h1><a class="header" href="#运行时保障" id="运行时保障">运行时保障</a></h1>
<p>Rust 没有运行时未定义行为：</p>
<ul>
<li>数组访问有边界检查。</li>
<li>Integer overflow is defined (panic or wrap-around).</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>Integer overflow is defined via the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks"><code>overflow-checks</code></a> compile-time flag. If enabled, the program will panic (a controlled crash of the program), otherwise you get wrap-around semantics. By default, you get panics in debug mode (<code>cargo build</code>) and wrap-around in release mode (<code>cargo build --release</code>).</p>
</li>
<li>
<p>边界检查不能使用编译标志禁用，也不能直接通过 <code>unsafe</code> 关键字禁用。然而， <code>unsafe</code> 允许你调用 <code>slice::get_unchecked</code> 等不做边界检查的函数。</p>
</li>
</ul>
</details><h1><a class="header" href="#现代特性" id="现代特性">现代特性</a></h1>
<p>Rust is built with all the experience gained in the last decades.</p>
<h2><a class="header" href="#语言特性" id="语言特性">语言特性</a></h2>
<ul>
<li>枚举和模式匹配。</li>
<li>泛型。</li>
<li>无额外开销外部函数接口（FFI）。</li>
<li>零成本抽象。</li>
</ul>
<h2><a class="header" href="#工具" id="工具">工具</a></h2>
<ul>
<li>强大的编译器错误提示。</li>
<li>内置依赖管理器。</li>
<li>对测试的内置支持。</li>
<li>优秀的语言服务协议（Language Server Protocol）支持。</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>与 C++ 类似的零成本抽象，意味着你不需要为高级程序语言的结构“付出”更多的内存和 CPU。例如使用 <code>for</code> 循环与使用 <code>.iter().fold()</code> 结构应该会生成大致相同的底层指令。</p>
</li>
<li>
<p>值得一提的是，Rust 的枚举是“代数数据类型”（也叫“和类型”）。它使得类型系统可以表示 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 等结构。</p>
</li>
<li>
<p>提醒学生去阅读编译错误 --- 许多开发者已经习惯去忽略冗长的编译器输出。Rust 编译器会比其它编译器更健谈。它通常会提供 <em>可操作的</em> 反馈，可以直接复制粘贴到代码中。</p>
</li>
<li>
<p>相比 Java, Python 和 Go 等语言，Rust 标准库较为精简。Rust 并没有内置一些你可能认为标准和必要的功能：</p>
<ul>
<li>随机数生成器，可以使用 <a href="https://docs.rs/rand/">rand</a> 替代。</li>
<li>SSL 和 TLS 支持，可以使用 <a href="https://docs.rs/rustls/">rusttls</a> 替代。</li>
<li>JSON 支持，可以使用 <a href="https://docs.rs/serde_json/">serde_json</a> 替代。
Rust 这么做的原因是标准库中的功能是无法去除的，因此该功能必须非常稳定。对于以上例子，Rust 社区仍在寻找最佳解决方案 --- 甚至对一些情况可能没有单一的“最佳解决方案”。
Rust 内置了一个包管理器 Cargo，使得下载和编译第三方 crate 变得简单。这也导致标准库可以更加精简。</li>
</ul>
<p>发现高质量的第三方 crate 也许是一个问题。 <a href="https://lib.rs/">https://lib.rs/</a> 等网站对此问题有所帮助。它能帮你比较 crate 的健康指标，以找到一个高质量并受信任的 crate。</p>
</li>
<li>
<p><a href="https://rust-analyzer.github.io/">rust-analyzer</a> 是一个受到广泛支持的 LSP 实现，被主流的 IDE 和文本编辑器所使用。</p>
</li>
</ul>
</details><h1><a class="header" href="#基本语法" id="基本语法">基本语法</a></h1>
<p>Rust 的许多语法与 C, C++ 和 Java 的语法相似</p>
<ul>
<li>代码块和作用域都是由花括号来界定的。</li>
<li>行内注释以 <code>//</code> 起始，块注释使用 <code>/* ... */</code> 来界定。</li>
<li><code>if</code> 和 <code>while</code> 等关键词作用与以上语言一致。</li>
<li>变量赋值使用 <code>=</code>，值之间比较使用 <code>==</code>。</li>
</ul>
<h1><a class="header" href="#标量类型" id="标量类型">标量类型</a></h1>
<table><thead><tr><th></th><th>类型</th><th>字面量</th></tr></thead><tbody>
<tr><td>有符号整数</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123_i64</code></td></tr>
<tr><td>无符号整数</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10_u16</code></td></tr>
<tr><td>浮点数</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2_f32</code></td></tr>
<tr><td>字符串</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>&quot;two\nlines&quot;</code></td></tr>
<tr><td>Unicode 标量类型</td><td><code>char</code></td><td><code>'a'</code>, <code>'α'</code>, <code>'∞'</code></td></tr>
<tr><td>布尔值</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
<p>各类型占用的空间为：</p>
<ul>
<li><code>iN</code>, <code>uN</code> 和 <code>fN</code> 占用 <em>N</em> 位，</li>
<li><code>isize</code> 和 <code>usize</code> 占用一个指针大小的空间，</li>
<li><code>char</code> is 32 bits wide,</li>
<li><code>bool</code> is 8 bits wide.</li>
</ul>
<details>
<p>上表中还有一些未提及的语法：</p>
<ul>
<li>
<p>原始字符串可在创建 <code>&amp;str</code> 时禁用转义：<code>r&quot;\n&quot; == &quot;\\n&quot;</code>。可以在外层引号两侧添加相同数量的 <code>#</code>，以在字符串中嵌入双引号：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(r#&quot;&lt;a href=&quot;link.html&quot;&gt;link&lt;/a&gt;&quot;#);
    println!(&quot;&lt;a href=\&quot;link.html\&quot;&gt;link&lt;/a&gt;&quot;);
}
</code></pre></pre>
</li>
<li>
<p>字节串可以用于直接创建 <code>&amp;[u8]</code> 类型的值：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, b&quot;abc&quot;);
    println!(&quot;{:?}&quot;, &amp;[97, 98, 99]);
}
</code></pre></pre>
</li>
<li>
<p>All underscores in numbers can be left out, they are for legibility only. So <code>1_000</code> can be written as <code>1000</code> (or <code>10_00</code>), and <code>123_i64</code> can be written as <code>123i64</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#复合类型" id="复合类型">复合类型</a></h1>
<table><thead><tr><th></th><th>类型</th><th>字面量</th></tr></thead><tbody>
<tr><td>数组（Arrays）</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>元组（Tuples）</td><td><code>()</code>, <code>(T,)</code>, <code>(T1, T2)</code>, ...</td><td><code>()</code>, <code>('x',)</code>, <code>('x', 1.2)</code>, ...</td></tr>
</tbody></table>
<p>数组的赋值和访问操作：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {:?}&quot;, a);
}
</code></pre></pre>
<p>元组的赋值和访问操作：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;t.0: {}&quot;, t.0);
    println!(&quot;t.1: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<p>数组：</p>
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant) elements of the same type <code>T</code>. Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and <code>[u8; 4]</code> are considered two different types.</p>
</li>
<li>
<p>我们可以使用字面量来为数组赋值。</p>
</li>
<li>
<p>在主函数中，打印（print）语句使用 <code>?</code> 格式请求调试实现。 使用参数 <code>{}</code> 打印默认输出，<code>{:?}</code> 表示以调试格式输出。 我们也可以不在格式化字符串后面指定变量值，直接使用 <code>{a}</code> 和 <code>{a:?}</code> 进行输出。</p>
</li>
<li>
<p>添加 <code>#</code>, 比如 <code>{a:#?}</code>, 会输出“美观打印（pretty printing）” 格式, 这种格式可能会更加易读。</p>
</li>
</ul>
<p>元组：</p>
<ul>
<li>
<p>和数组一样，元组也具有固定的长度。</p>
</li>
<li>
<p>元组将不同类型的值组成一个复合类型。</p>
</li>
<li>
<p>元组中的字段可以通过英文句号加上值的下标进行访问比如：<code>t.0</code>, <code>t.1</code>。</p>
</li>
<li>
<p>空元组 <code>()</code> 也被称作 “单元（unit）类型”. 它既是一个类型， 也是这种类型的唯一值——也就是说它的类型和它的  值都被表示为 <code>()</code>。它通常用于表示，比如，一个  函数或表达式没有返回值，我们会在后续的幻灯片种见到这种用法。</p>
<ul>
<li>你可以将其理解为你可能在其他编程语言中比较熟悉的  <code>void</code> 类型</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#引用" id="引用">引用</a></h1>
<p>如同 C++ 一样，Rust 也提供了引用类型。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x: i32 = 10;
    let ref_x: &amp;mut i32 = &amp;mut x;
    *ref_x = 20;
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>一些注意事项：</p>
<ul>
<li>就像 C 与 C++ 中的指针一样，对引用 <code>ref_x</code> 进行赋值时，我们必须对其解引用。</li>
<li>Rust 有时会进行自动解引用。比如调用方法 <code>ref_x.count_ones()</code> 时，ref_x 会被解引用。</li>
<li>如果引用值被声明为 <code>mut</code>（可变引用），那么这个引用值可以在它的生命周期内被绑定为不同的值。</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>注意 <code>let mut ref_x: &amp;i32</code> 与 <code>let ref_x: &amp;mut i32</code> 之间的区别。第一条语句声明了一个可变引用，所以我们可以修改这个引用所绑定的值；第二条语句声明了一个指向可变变量的引用。</li>
</ul>
</details><h1><a class="header" href="#悬垂引用" id="悬垂引用">悬垂引用</a></h1>
<p>Rust 会静态地禁止悬垂引用：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}
</code></pre></pre>
<ul>
<li>一个引用被认为是“借用（borrow）”了它指向的值。</li>
<li>Rust 会跟踪所有引用的生命周期，以确保这些值的存活时间足够长。</li>
<li>我们会在讲到所有权（ownership）时详细讨论借用（borrow）。</li>
</ul>
<h1><a class="header" href="#切片" id="切片">切片</a></h1>
<p>切片 (slice) 的作用是提供对集合 (collection) 的视图 (view):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];

    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>切片从被切片的类型中借用 (borrow) 数据。</li>
<li>Question: What happens if you modify <code>a[3]</code> right before printing <code>s</code>?</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust’s range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain ‘alive’ (in scope) for at least as long as our slice. </p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but the answer is that for memory safety reasons you cannot do it through <code>a</code> at this point in the execution, but you can read the data from both <code>a</code> and <code>s</code> safely. It works before you created the slice, and again after the <code>println</code>, when the slice is no longer used. More details will be explained in the borrow checker section.</p>
</li>
</ul>
</details><h1><a class="header" href="#string-vs-str" id="string-vs-str"><code>String</code> vs <code>str</code></a></h1>
<p>现在我们就可以理解 Rust 中的两种字符串类型：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
    
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<p>Rust 术语：</p>
<ul>
<li><code>&amp;str</code> 是一个指向字符串片段的不可变引用。</li>
<li><code>String</code> 是一个可变字符串缓冲区。</li>
</ul>
<details>
<ul>
<li>
<p><code>&amp;str</code> 引入了一个字符串切片，它是一个指向保存在内存块中的 UTF-8 编码字符串数据的不可变引用。   字符串字面量（<code>”Hello”</code>）会保存在程序的二进制文件中。</p>
</li>
<li>
<p>Rust 的 <code>String</code> 类型是一个字节 vector 的封装。和 <code>Vec&lt;T&gt;</code> 一样，它是拥有所有权的。</p>
</li>
<li>
<p>和其他类型一样，<code>String::from()</code> 会从字符串字面量创建一个字符串；<code>String::new()</code> 会创建一个新的空字符串，   之后可以使用 <code>push()</code> 和 <code>push_str()</code> 方法向其中添加字符串数据。</p>
</li>
<li>
<p><code>format!()</code> 宏可以方便地动态生成拥有所有权的字符串。它接受和 <code>println!()</code> 相同的格式规范。</p>
</li>
<li>
<p>你可以通过 <code>&amp;</code> 和可选的范围选择从 <code>String</code> 中借用 <code>&amp;str</code> 切片。</p>
</li>
<li>
<p>对于 C++ 程序员：可以把 <code>&amp;str</code> 当作 C++ 中的 <code>const char*</code>，但是它总是指向内存中的一个有效字符串。   Rust 的 <code>String</code> 大致相当于 C++ 中 <code>std::string</code> （主要区别：它只能包含 UTF-8 编码的字节，   并且永远不会使用小字符串优化（small-string optimization））。</p>
</li>
</ul>
</details><h1><a class="header" href="#函数" id="函数">函数</a></h1>
<p>一个 Rust 版本的著名 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> 面试题：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    print_fizzbuzz_to(20);
}

fn is_divisible(n: u32, divisor: u32) -&gt; bool {
    if divisor == 0 {
        return false;
    }
    n % divisor == 0
}

fn fizzbuzz(n: u32) -&gt; String {
    let fizz = if is_divisible(n, 3) { &quot;fizz&quot; } else { &quot;&quot; };
    let buzz = if is_divisible(n, 5) { &quot;buzz&quot; } else { &quot;&quot; };
    if fizz.is_empty() &amp;&amp; buzz.is_empty() {
        return format!(&quot;{n}&quot;);
    }
    format!(&quot;{fizz}{buzz}&quot;)
}

fn print_fizzbuzz_to(n: u32) {
    for i in 1..=n {
        println!(&quot;{}&quot;, fizzbuzz(i));
    }
}
</code></pre></pre>
<details>
<ul>
<li>我们在 <code>main</code> 中引用了下面编写的一个函数。不需要提前声明或添加头文件。 </li>
<li>类型跟随在声明的参数后（与某些编程语言相反），然后是返回类型。</li>
<li>函数体（或任何块）中的最后一个表达式将成为返回值。只需省略表达式末尾的 <code>;</code> 即可。</li>
<li>有些函数没有返回值，会返回“单元类型（unit type）”<code>()</code>。如果省略了<code>-&gt; ()</code>的返回类型，编译器将会自动推断。</li>
<li><code>print_fizzbuzz_to()</code>函数中<code>for</code>循环的范围表达式（range expression）包含<code>=n</code>，这会导致它包括上限。</li>
</ul>
</details><h1><a class="header" href="#rustdoc" id="rustdoc">Rustdoc</a></h1>
<p>Rust 中的所有语言元素都可以通过特殊的 <code>///</code> 语法进行文档化。</p>
<pre><pre class="playground"><code class="language-rust editable">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
///
/// # Example
/// ```
/// assert!(is_divisible_by(42, 2));
/// ```
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;  // Corner case, early return
    }
    lhs % rhs == 0     // The last expression in a block is the return value
}
</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are automatically documented at <a href="https://docs.rs"><code>docs.rs</code></a> using the <a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is idiomatic to document all public items in an API using this pattern. Code snippets can document usage and will be used as unit tests.</p>
<details>
<ul>
<li>
<p>向学生展示在 <a href="https://docs.rs/rand"><code>docs.rs/rand</code></a> 中为 <code>rand</code> crate 生成的文档。</p>
</li>
<li>
<p>本课程的幻灯片中不包含 rustdoc，这是为了节省空间，但是在实际的代码中，应当编写相关的程序文档。</p>
</li>
<li>
<p>内部文档注释将在稍后（在讲解模块的页面）讨论，这里无需进行说明。</p>
</li>
<li>
<p>Rustdoc comments can contain code snippets that we can run and test using <code>cargo test</code>. We will discuss these tests in the <a href="basic-syntax/../testing/doc-tests.html">Testing section</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#方法" id="方法">方法</a></h1>
<p>方法是与某种类型关联的函数。方法的 <code>self</code> 参数是与其关联类型的一个实例：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn inc_width(&amp;mut self, delta: u32) {
        self.width += delta;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!(&quot;old area: {}&quot;, rect.area());
    rect.inc_width(5);
    println!(&quot;new area: {}&quot;, rect.area());
}
</code></pre></pre>
<ul>
<li>我们将在今天的练习和明天的课程中更深入地学习方法相关的概念。</li>
</ul>
<details>
<ul>
<li>
<p>Add a static method called <code>Rectangle::new</code> and call this from <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn new(width: u32, height: u32) -&gt; Rectangle {
    Rectangle { width, height }
}
</code></pre></pre>
</li>
<li>
<p>While <em>technically</em>, Rust does not have custom constructors, static methods are commonly used to initialize structs (but don’t have to). The actual constructor, <code>Rectangle { width, height }</code>, could be called directly. See the <a href="https://doc.rust-lang.org/nomicon/constructors.html">Rustnomicon</a>.</p>
</li>
<li>
<p>Add a <code>Rectangle::square(width: u32)</code> constructor to illustrate that such static methods can take arbitrary parameters.</p>
</li>
</ul>
</details><h1><a class="header" href="#函数重载" id="函数重载">函数重载</a></h1>
<p>不支持重载：</p>
<ul>
<li>每一个函数都只有一种实现：
<ul>
<li>始终接受固定个数的形参。</li>
<li>始终接受一组形参类型。</li>
</ul>
</li>
<li>不支持提供默认值：
<ul>
<li>实参的数量在所有调用的地方都是一样的。</li>
<li>有时可以用宏（Macro）作为替代。</li>
</ul>
</li>
</ul>
<p>然而，函数形参可以是泛型（generics）：</p>
<pre><pre class="playground"><code class="language-rust editable">fn pick_one&lt;T&gt;(a: T, b: T) -&gt; T {
    if std::process::id() % 2 == 0 { a } else { b }
}

fn main() {
    println!(&quot;coin toss: {}&quot;, pick_one(&quot;heads&quot;, &quot;tails&quot;));
    println!(&quot;cash prize: {}&quot;, pick_one(500, 1000));
}
</code></pre></pre>
<details>
<ul>
<li>标准库中的 <code>Into&lt;T&gt;</code> 通过泛型参数提供了一种具有有限多态性的参数类型。详见之后的章节。</li>
</ul>
</details><h1><a class="header" href="#第一天上午习题" id="第一天上午习题">第一天上午习题</a></h1>
<p>在这些习题中，我们将探索 Rust 的两个部分：</p>
<ul>
<li>
<p>类型之间的隐式转换。</p>
</li>
<li>
<p>数组和 <code>for</code> 循环。</p>
</li>
</ul>
<details>
<p>在解题时要考虑几件事：</p>
<ul>
<li>
<p>最好使用本地安装的 Rust，以实现在编辑器中自动补全。关于安装 Rust 的细节，请参见 [使用 Cargo] 页面。</p>
</li>
<li>
<p>也可以使用 Rust Playground 作为替代。</p>
</li>
</ul>
<p>页面内嵌的代码片段是不可编辑的：因为离开页面后内嵌代码片段中的修改会丢失。</p>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#隐式类型转换" id="隐式类型转换">隐式类型转换</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">与 C++ 不同</a>，Rust 不会自动进行 <em>隐式类型转换</em>。例如，下面的程序中不存在隐式类型转换：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn multiply(x: i16, y: i16) -&gt; i16 {
    x * y
}

fn main() {
    let x: i8 = 15;
    let y: i16 = 1000;

    println!(&quot;{x} * {y} = {}&quot;, multiply(x, y));
}
</code></pre></pre>
<p>Rust 的整数类型都实现了 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a> trait，使得我们可以在它们之间进行转换。<code>From&lt;T&gt;</code> trait 包含 <code>from()</code> 方法，<code>Into&lt;T&gt;</code> trait 包含 <code>into()</code> 方法。类型通过实现这些 trait 来表达它将被如何转换为另一个类型。</p>
<p>标准库中包含 <code>From&lt;i8&gt; for i16</code> 的实现，即我们可以通过调用 <code>i16::from(x)</code> 来将 <code>i8</code> 类型的变量 <code>x</code> 转换为 <code>i16</code>。或者也可以简单地使用 <code>x.into()</code>，因为 <code>From&lt;i8&gt; for i16</code> 的实现会自动创建 <code>Into&lt;i16&gt; for i8</code> 的实现。</p>
<p>这同样也适用于自定义类型的 <code>From</code> 实现，只需实现 <code>From</code> 就可以自动得到对应的 <code>Into</code> 实现。</p>
<ol>
<li>
<p>执行上述程序，并查看对应的编译错误。</p>
</li>
<li>
<p>修改代码，使用 <code>into()</code> 进行类型转换。</p>
</li>
<li>
<p>修改 <code>x</code> 和 <code>y</code> 的类型（例如 <code>f32</code>, <code>bool</code>, <code>i128</code> 等）来了解哪些类型之间可以相互转换。尝试将较小的类型转换为较大的类型和将较大的类型转换为较小的类型。阅读 <a href="https://doc.rust-lang.org/std/convert/trait.From.html">标准库文档</a> 来了解对于你所尝试的两个类型 <code>From&lt;T&gt;</code> 是否已被实现。</p>
</li>
</ol>
<h1><a class="header" href="#数组与-for-循环" id="数组与-for-循环">数组与 <code>for</code> 循环</a></h1>
<p>我们可以这样声明一个数组：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [10, 20, 30];
<span class="boring">}
</span></code></pre></pre>
<p>你可以使用 <code>{:?}</code> 来打印这种数组的调试格式：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [10, 20, 30];
    println!(&quot;array: {array:?}&quot;);
}
</code></pre></pre>
<p>在 Rust 中，可以使用 <code>for</code> 关键词遍历数组和区间等元素：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [10, 20, 30];
    print!(&quot;Iterating over array:&quot;);
    for n in &amp;array {
        print!(&quot; {n}&quot;);
    }
    println!();

    print!(&quot;Iterating over range:&quot;);
    for i in 0..3 {
        print!(&quot; {}&quot;, array[i]);
    }
    println!();
}
</code></pre></pre>
<p>使用以上知识，写一个用易读的格式输出矩阵的 <code>pretty_print</code> 函数，以及一个对矩阵进行转置（将行和列互换）的 <code>transpose</code> 函数：</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7⎤</text><text x="250" y="28" >8⎥</text><text x="250" y="44" >9⎦</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">⎛</text><text x="98" y="12">⎡</text><text x="106" y="12">1</text></g><g><text x="90" y="28">⎜</text><text x="98" y="28">⎢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">⎝</text><text x="98" y="44">⎣</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3⎤</text><text x="154" y="12">⎞</text></g><g><text x="138" y="28">6⎥</text><text x="154" y="28">⎟</text></g><g><text x="138" y="44">9⎦</text><text x="154" y="44">⎠</text></g><g><text x="210" y="12">⎡</text><text x="218" y="12">1</text></g><g><text x="210" y="28">⎢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">⎣</text><text x="218" y="44">3</text></g></svg></div>
<p>硬编码这两个函数，让它们处理 3 × 3 的矩阵。</p>
<p>将下面的代码复制到 <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> 并实现上述函数：</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: 完成你的实现后移除此行。
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    unimplemented!()
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- 这个注释会让 rustfmt 添加一个新行
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h2><a class="header" href="#附加题" id="附加题">附加题</a></h2>
<p>是否可以使用 <code>&amp;[i32]</code> 切片而不是硬编码的 3 × 3 矩阵作为函数的参数和返回类型？例如使用 <code>&amp;[&amp;[i32]]</code> 表示一个二维的切片的切片。为什么这样做是可行或不可行的？</p>
<p>参考 <a href="https://docs.rs/ndarray/"><code>ndarray</code> crate</a> 以了解该功能满足生产环境质量的实现。</p>
<details>
<p>题目解答和附加题的答案在 <a href="exercises/day-1/solutions-morning.html#arrays-and-for-loops">题解</a> 章节中。</p>
<p>The use of the reference <code>&amp;array</code> within <code>for n in &amp;array</code> is a subtle preview of issues of ownership that will come later in the afternoon.</p>
<p>Without the <code>&amp;</code>...</p>
<ul>
<li>The loop would have been one that consumes the array.  This is a change <a href="https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html">introduced in the 2021 Edition</a>.</li>
<li>An implicit array copy would have occurred.  Since <code>i32</code> is a copy type, then <code>[i32; 3]</code> is also a copy type.</li>
</ul>
</details><h1><a class="header" href="#控制流" id="控制流">控制流</a></h1>
<p>正如我们所知，<code>if</code> 是 Rust 中的一个表达式。它用于有条件地 评估两个块中的一个，但这些块可以有一个值， 然后成为 <code>if</code> 表达式的值。其他控制流表达式在 Rust 中也有类似 的运作方式。</p>
<h1><a class="header" href="#块" id="块">块</a></h1>
<p>A block in Rust contains a sequence of expressions. Each block has a value and a type, which are those of the last expression of the block:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = {
        let y = 10;
        println!(&quot;y: {y}&quot;);
        let z = {
            let w = {
                3 + 4
            };
            println!(&quot;w: {w}&quot;);
            y * w
        };
        println!(&quot;z: {z}&quot;);
        z - y
    };
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<p>同样的规则也适用于函数：函数主体的值 是返回值：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn double(x: i32) -&gt; i32 {
    x + x
}

fn main() {
    println!(&quot;double: {}&quot;, double(7));
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>这张幻灯片的重点是说明在 Rust 中，块有类型和值。</li>
<li>你可以通过更改块的最后一行，来展示块值的变化情况。例如，添加/移除分号或使用 <code>return</code>。</li>
</ul>
</details><h1><a class="header" href="#if-表达式" id="if-表达式"><code>if</code> 表达式</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> 表达式</a> 的用法与其他语言中的 <code>if</code> 语句完全一样。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    if x % 2 == 0 {
        x = x / 2;
    } else {
        x = 3 * x + 1;
    }
}
</code></pre></pre>
<p>此外，你还可以将 <code>if</code> 用作一个表达式。每个块的最后一个表达式 将成为 <code>if</code> 表达式的值：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    x = if x % 2 == 0 {
        x / 2
    } else {
        3 * x + 1
    };
}
</code></pre></pre>
<details>
<p>由于 <code>if</code> 是一个表达式且必须有一个特定的类型，因此它的两个分支块必须有相同的类型。考虑在第二个示例中将 <code>;</code> 添加到 <code>x / 2</code> 的后面，看看会出现什么情况。</p>
</details><h1><a class="header" href="#for-循环" id="for-循环"><code>for</code> 循环</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> is closely related to the <a href="control-flow/while-let-expressions.html"><code>while let</code> loop</a>. It will automatically call <code>into_iter()</code> on the expression and then iterate over it:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];

    for x in v {
        println!(&quot;x: {x}&quot;);
    }
    
    for i in (0..10).step_by(2) {
        println!(&quot;i: {i}&quot;);
    }
}
</code></pre></pre>
<p>你可以在此照常使用 <code>break</code> 和 <code>continue</code>。</p>
<details>
<ul>
<li>在这种情况下，索引迭代在 Rust 中并不是一个特殊的语法。</li>
<li><code>(0..10)</code> 是实现 <code>Iterator</code> trait 的范围。</li>
<li><code>step_by</code> 是返回另一个 <code>Iterator</code> 的方法，用于逐一跳过所有其他元素。</li>
<li>修改矢量中的元素并说明编译器错误。将矢量 <code>v</code> 改为可变，并将 for 循环改为 <code>for x in v.iter_mut()</code>。</li>
</ul>
</details><h1><a class="header" href="#while-循环" id="while-循环"><code>while</code> 循环</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> 关键字</a> 的工作方式与其他语言非常相似：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    while x != 1 {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
    }
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#break-和-continue" id="break-和-continue"><code>break</code> 和 <code>continue</code></a></h1>
<ul>
<li>如果你想提前退出循环，请使用 <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>，</li>
<li>如果需要立即启动 下一次迭代，请使用 <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>。</li>
</ul>
<p><code>continue</code> 和 <code>break</code> 都可以选择接受一个标签参数，用来 终止嵌套循环：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();
    'outer: while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
        let mut i = 0;
        while i &lt; x {
            println!(&quot;x: {x}, i: {i}&quot;);
            i += 1;
            if i == 3 {
                break 'outer;
            }
        }
    }
}
</code></pre></pre>
<p>在本示例中，我们会在内循环 3 次迭代后终止外循环。</p>
<h1><a class="header" href="#loop-表达式" id="loop-表达式"><code>loop</code> 表达式</a></h1>
<p>最后是用于创建无限循环的 <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code> 关键字</a> 。</p>
<p>在下例中，你必须 <code>break</code> 或 <code>return</code> 才能停止循环：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    loop {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
        if x == 1 {
            break;
        }
    }
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>用一个值（例如 <code>break 8</code>）来中断 <code>loop</code> 并将其输出。</li>
<li>请注意，<code>loop</code> 是唯一返回有意义的值的循环结构。 这是因为它保证至少被输入一次（与 <code>while</code> 和 <code>for</code> 循环不同）。</li>
</ul>
</details><h1><a class="header" href="#变量" id="变量">变量</a></h1>
<p>Rust 通过静态类型实现了类型安全。变量绑定默认是不可变的：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>由于类型推导，<code>i32</code> 可以省略。随着课程推进，我们会越来越少地看到类型声明。</li>
</ul>
</details><h1><a class="header" href="#类型推导" id="类型推导">类型推导</a></h1>
<p>Rust 会根据变量的使用来确定其类型：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>这张幻灯片演示了 Rust 编译器是如何根据变量声明和用法来推导其类型的。</p>
<p>需要重点强调的是这样声明的变量并非像那种动态类型语言中可以持有任何数据的“任何类型”。这种声明所生成的机器码与明确类型声明完全相同。编译器进行类型推导能够让我们编写更简略的代码。</p>
<p>The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using <code>_</code> as a placeholder:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!(&quot;v: {v:?}&quot;);

    let vv = v.iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();
    println!(&quot;vv: {vv:?}&quot;);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> relies on <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a>, which <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,+S%3E"><code>HashSet</code></a> implements.</p>
</details><h1><a class="header" href="#静态-static-变量和常数-constant-变量" id="静态-static-变量和常数-constant-变量">静态 (Static) 变量和常数 (Constant) 变量</a></h1>
<p>Static and constant variables are two different ways to create globally-scoped values that cannot be moved or reallocated during the execution of the program. </p>
<h2><a class="header" href="#const" id="const"><code>const</code></a></h2>
<p>Constant variables are evaluated at compile time and their values are inlined wherever they are used:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>根据 <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> 这些变量在使用时是内联 (inlined) 的。</p>
<p>Only functions marked <code>const</code> can be called at compile time to generate <code>const</code> values. <code>const</code> functions can however be called at runtime.</p>
<h2><a class="header" href="#static" id="static"><code>static</code></a></h2>
<p>Static variables will live during the whole execution of the program, and therefore will not move:</p>
<pre><pre class="playground"><code class="language-rust editable">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and  embedded code, and the variable lives through the entirety of the program execution. When a globally-scoped value does not have a reason to need object identity, <code>const</code> is generally preferred.</p>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>. Interior mutability is possible through a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or similar. It is also possible to have mutable statics, but they require manual synchronisation so any access to them requires <code>unsafe</code> code. We will look at <a href="basic-syntax/../unsafe/mutable-static-variables.html">mutable statics</a> in the chapter on Unsafe Rust.</p>
<details>
<ul>
<li>值得一提的是，<code>const</code> 在语义上与C++的 <code>constexpr</code> 类似。</li>
<li>另一方面，<code>static</code> 远远更类似于C++中的 <code>const</code> 或可改变的全局变量。</li>
<li><code>static</code> provides object identity: an address in memory and state as required by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
<li>虽然需要使用在运行中求值的常量的情况并不是很常见，但是它是有帮助的，而且比使用静态变量更安全。</li>
<li><code>thread_local</code> data can be created with the macro <code>std::thread_local</code>.</li>
</ul>
<h3><a class="header" href="#properties-table" id="properties-table">Properties table:</a></h3>
<table><thead><tr><th>Property</th><th>Static</th><th>Constant</th></tr></thead><tbody>
<tr><td>Has an address in memory</td><td>Yes</td><td>No (inlined)</td></tr>
<tr><td>Lives for the entire duration of the program</td><td>Yes</td><td>No</td></tr>
<tr><td>Can be mutable</td><td>Yes (unsafe)</td><td>No</td></tr>
<tr><td>Evaluated at compile time</td><td>Yes (initialised at compile time)</td><td>Yes</td></tr>
<tr><td>Inlined wherever it is used</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</details><h1><a class="header" href="#作用域和隐藏-shadowing" id="作用域和隐藏-shadowing">作用域和隐藏 (Shadowing)</a></h1>
<p>你可以隐藏变量，位于外部作用域的变量和 相同作用域的变量都可以：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);

    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>定义: 隐藏和变更 (mutation) 不同，因为在隐藏之后，两个变量都会同时存在于内存的不同位置中。在同一个名字下的两个变量都是可以被使用的，但是你在代码的哪里使用会最终决定你使用哪一个变量。</li>
<li>一个隐藏变量可以具有不同的类型。</li>
<li>隐藏起初看起来会有些晦涩，但是它很便于存 <code>.unwrap()</code> 之后的得到的值。</li>
<li>以下代码说明了为什么在作用域内隐藏一个不可变的变量时，即使是在变量类型没有改变的情况下，编译器也不能简单地重复利用之前的内存位置。</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 1;
    let b = &amp;a;
    let a = a + 1;
    println!(&quot;{a} {b}&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#枚举" id="枚举">枚举</a></h1>
<p><code>enum</code> 关键字允许创建具有几个 不同变体的类型：</p>
<pre><pre class="playground"><code class="language-rust editable">fn generate_random_number() -&gt; i32 {
    // Implementation based on https://xkcd.com/221/
    4  // Chosen by fair dice roll. Guaranteed to be random.
}

#[derive(Debug)]
enum CoinFlip {
    Heads,
    Tails,
}

fn flip_coin() -&gt; CoinFlip {
    let random_number = generate_random_number();
    if random_number % 2 == 0 {
        return CoinFlip::Heads;
    } else {
        return CoinFlip::Tails;
    }
}

fn main() {
    println!(&quot;You got: {:?}&quot;, flip_coin());
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>枚举允许你从一种类型下收集一组值</li>
<li>This page offers an enum type <code>CoinFlip</code> with two variants <code>Heads</code> and <code>Tails</code>. You might note the namespace when using variants.</li>
<li>这可能是比较结构体和枚举的好时机：
<ul>
<li>在这两者中，你可以获得一个不含字段的简单版本（单位结构体），或一个包含不同类型字段的版本（变体载荷）。</li>
<li>在这两者中，关联的函数都在 <code>impl</code> 块中定义。</li>
<li>你甚至可以使用单独的结构体实现枚举的不同变体，但这样一来，如果它们都已在枚举中定义，类型与之前也不一样。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#变体载荷" id="变体载荷">变体载荷</a></h1>
<p>你可以定义更丰富的枚举，其中变体会携带数据。然后，你可以使用 <code>match</code> 语句从每个变体中提取数据：</p>
<pre><pre class="playground"><code class="language-rust editable">enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       =&gt; println!(&quot;page loaded&quot;),
        WebEvent::KeyPress(c)    =&gt; println!(&quot;pressed '{c}'&quot;),
        WebEvent::Click { x, y } =&gt; println!(&quot;clicked at x={x}, y={y}&quot;),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}
</code></pre></pre>
<details>
<ul>
<li>枚举变体中的值只有在被模式匹配后，才可访问。模式将引用绑定到 <code>=&gt;</code> 之后的“match 分支”中的字段。
<ul>
<li>表达式会从上到下与模式匹配。没有像 C 或 C++ 中那样的跳转。</li>
<li>匹配表达式拥有一个值。值是 match 分支中被执行的最后一个表达式。</li>
<li>从顶部开始，查找与该值匹配的模式，然后沿箭头运行代码。一旦找到匹配，我们便会停止。</li>
</ul>
</li>
<li>展示搜索不详尽时会发生的情况。请注意 Rust 编译器的优势，即确认所有情况何时都得到了处理。</li>
<li><code>match</code> 会检查 <code>enum</code> 中的隐藏的判别字段。</li>
<li>可以通过调用 <code>std::mem::discriminant()</code> 来检索判别
<ul>
<li>这很有用，例如如果为结构体实现 <code>PartialEq</code>，比较字段值不会影响等式。</li>
</ul>
</li>
<li><code>WebEvent::Click { ... }</code> 与含顶层 <code>struct Click { ... }</code> 的 <code>WebEvent::Click(Click)</code> 不完全相同。例如，内嵌版本无法实现 trait。</li>
</ul>
</details><h1><a class="header" href="#枚举大小" id="枚举大小">枚举大小</a></h1>
<p>Rust 枚举被紧密地打包，考虑到了对齐的影响，因此存在一些限制：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::any::type_name;
use std::mem::{align_of, size_of};

fn dbg_size&lt;T&gt;() {
    println!(&quot;{}: size {} bytes, align: {} bytes&quot;,
        type_name::&lt;T&gt;(), size_of::&lt;T&gt;(), align_of::&lt;T&gt;());
}

enum Foo {
    A,
    B,
}

fn main() {
    dbg_size::&lt;Foo&gt;();
}
</code></pre></pre>
<ul>
<li>请参阅 <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust 引用</a>。</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>Internally Rust is using a field (discriminant) to keep track of the enum variant.</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[repr(u32)]
enum Bar {
    A,  // 0
    B = 10000,
    C,  // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}
</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2 bytes.</p>
</li>
<li>
<p>Try out other types such as</p>
<ul>
<li><code>dbg_size!(bool)</code>: size 1 bytes, align: 1 bytes,</li>
<li><code>dbg_size!(Option&lt;bool&gt;)</code>: size 1 bytes, align: 1 bytes (niche optimization, see below),</li>
<li><code>dbg_size!(&amp;i32)</code>: size 8 bytes, align: 8 bytes (on a 64-bit machine),</li>
<li><code>dbg_size!(Option&lt;&amp;i32&gt;)</code>: size 8 bytes, align: 8 bytes (null pointer optimization, see below).</li>
</ul>
</li>
<li>
<p>Niche optimization: Rust will merge unused bit patterns for the enum discriminant.</p>
</li>
<li>
<p>Null pointer optimization: For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look like in practice. It’s important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    unsafe {
        println!(&quot;bool:&quot;);
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!(&quot;Option&lt;bool&gt;:&quot;);
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!(&quot;Option&lt;Option&lt;bool&gt;&gt;:&quot;);
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!(&quot;Option&lt;&amp;i32&gt;:&quot;);
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}
</code></pre></pre>
<p>More complex example if you want to discuss what happens when we chain more than 256 <code>Option</code>s together.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#![recursion_limit = &quot;1000&quot;]

use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

// Macro to wrap a value in 2^n Some() where n is the number of &quot;@&quot; signs.
// Increasing the recursion limit is required to evaluate this macro.
macro_rules! many_options {
    ($value:expr) =&gt; { Some($value) };
    ($value:expr, @) =&gt; {
        Some(Some($value))
    };
    ($value:expr, @ $($more:tt)+) =&gt; {
        many_options!(many_options!($value, $($more)+), $($more)+)
    };
}

fn main() {
    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise
    // representation of types.
    unsafe {
        assert_eq!(many_options!(false), Some(false));
        assert_eq!(many_options!(false, @), Some(Some(false)));
        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));

        println!(&quot;Bitwise representation of a chain of 128 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@), u8);
        dbg_bits!(many_options!(true, @@@@@@@), u8);

        println!(&quot;Bitwise representation of a chain of 256 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@@), u16);
        dbg_bits!(many_options!(true, @@@@@@@@), u16);

        println!(&quot;Bitwise representation of a chain of 257 Option's.&quot;);
        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);
        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);
        dbg_bits!(many_options!(None::&lt;bool&gt;, @@@@@@@@), u16);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#novel-control-flow" id="novel-control-flow">Novel Control Flow</a></h1>
<p>Rust has a few control flow constructs which differ from other languages. They are used for pattern matching:</p>
<ul>
<li><code>if let</code> 表达式</li>
<li><code>while let</code> expressions</li>
<li><code>match</code> 表达式</li>
</ul>
<h1><a class="header" href="#if-let-表达式" id="if-let-表达式"><code>if let</code> 表达式</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> 表达式</a> 能让你根据某个值是否与模式相匹配来执行不同的代码：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let arg = std::env::args().next();
    if let Some(value) = arg {
        println!(&quot;Program name: {value}&quot;);
    } else {
        println!(&quot;Missing name?&quot;);
    }
}
</code></pre></pre>
<p>如需详细了解 Rust 中 的模式，请参阅<a href="control-flow/../pattern-matching.html">模式匹配</a>。</p>
<details>
<ul>
<li>
<p>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it more concise than <code>match</code>.</p>
</li>
<li>
<p>使用 <code>Option</code> 时，常见的做法是处理 <code>Some</code> 值。</p>
</li>
<li>
<p>与 <code>match</code> 不同的是，<code>if let</code> 不支持模式匹配的 guard 子句。</p>
</li>
<li>
<p>Since 1.65, a similar <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html">let-else</a> construct allows to do a destructuring assignment, or if it fails, execute a block which is required to abort normal control flow (with <code>panic</code>/<code>return</code>/<code>break</code>/<code>continue</code>):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, second_word_to_upper(&quot;foo bar&quot;));
}
 
fn second_word_to_upper(s: &amp;str) -&gt; Option&lt;String&gt; {
    let mut it = s.split(' ');
    let (Some(_), Some(item)) = (it.next(), it.next()) else {
        return None;
    };
    Some(item.to_uppercase())
}

</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#while-let-循环" id="while-let-循环"><code>while let</code> 循环</a></h1>
<p>与 <code>if let</code> 一样，<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>with let</code></a> 变体会针对一个模式重复测试一个值：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Here the iterator returned by <code>v.into_iter()</code> will return a <code>Option&lt;i32&gt;</code> on every call to <code>next()</code>. It returns <code>Some(x)</code> until it is done, after which it will return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<p>如需详细了解 Rust 中 的模式，请参阅<a href="control-flow/../pattern-matching.html">模式匹配</a>。</p>
<details>
<ul>
<li>指出只要值与模式匹配，<code>while let</code> 循环就会一直进行下去。</li>
<li>你可以使用 if 语句将 <code>while let</code> 循环重写为无限循环，当 <code>iter.next()</code> 没有值可以解封时中断。<code>while let</code> 为上述情况提供了语法糖。</li>
</ul>
</details><h1><a class="header" href="#match-表达式" id="match-表达式"><code>match</code> 表达式</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/match-expr.html"><code>match</code> 关键字</a> 用于将一个值与一个或多个模式进行匹配。从这个意义上讲，它的工作方式 类似于一系列的 <code>if let</code> 表达式：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    match std::env::args().next().as_deref() {
        Some(&quot;cat&quot;) =&gt; println!(&quot;Will do cat things&quot;),
        Some(&quot;ls&quot;)  =&gt; println!(&quot;Will ls some files&quot;),
        Some(&quot;mv&quot;)  =&gt; println!(&quot;Let's move some files&quot;),
        Some(&quot;rm&quot;)  =&gt; println!(&quot;Uh, dangerous!&quot;),
        None        =&gt; println!(&quot;Hmm, no program name?&quot;),
        _           =&gt; println!(&quot;Unknown program name!&quot;),
    }
}
</code></pre></pre>
<p>与 <code>if let</code> 类似，每个匹配分支必须有相同的类型。该类型是块的最后一个 表达式（如有）。在上例中，类型是 <code>()</code>。</p>
<p>如需详细了解 Rust 中 的模式，请参阅<a href="control-flow/../pattern-matching.html">模式匹配</a>。</p>
<details>
<ul>
<li>将 match 表达式保存到一个变量中并输出结果。</li>
<li>移除 <code>.as_deref()</code> 并说明错误。
<ul>
<li><code>std::env::args().next()</code> 会返回  <code>Option&lt;String&gt;</code>，但无法与 <code>String</code> 进行匹配。</li>
<li><code>as_deref()</code> 会将 <code>Option&lt;T&gt;</code> 转换为 <code>Option&lt;&amp;T::Target&gt;</code>。在我们的示例中，这会将 <code>Option&lt;String&gt;</code> 转换为 <code>Option&lt;&amp;str&gt;</code>。</li>
<li>现在，我们可以使用模式匹配来匹配 <code>Option</code> 中的 <code>&amp;str</code>。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#模式匹配" id="模式匹配">模式匹配</a></h1>
<p>使用关键词 <code>match</code> 对一个值进行模式匹配。进行匹配时，会从上至下依次进行比较，并选定第一个匹配成功的结果。</p>
<p>模式 (pattern) 可以是简单的值，其用法类似于 C 与 C++ 中的 <code>switch</code> 。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let input = 'x';

    match input {
        'q'                   =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd' =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'             =&gt; println!(&quot;Number input&quot;),
        _                     =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>模式 <code>_</code> 是外卡 (wildcard) 模式。它可以匹配任何值。</p>
<details>
<p>关键点：</p>
<ul>
<li>You might point out how some specific characters are being used when in a pattern
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around <code>q</code>.</li>
<li>You can demonstrate matching on a reference.</li>
<li>This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.</li>
</ul>
</details><h1><a class="header" href="#解构枚举" id="解构枚举">解构枚举</a></h1>
<p>Patterns can also be used to bind variables to parts of your values. This is how you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm, <code>msg</code> is bound to the error message.</p>
<details>
<p>关键点：</p>
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a <code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints.</li>
</ul>
</details><h1><a class="header" href="#解构结构体" id="解构结构体">解构结构体</a></h1>
<p>You can also destructure <code>structs</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, x = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>Change the literal values in <code>foo</code> to match with the other patterns.</li>
<li>Add a new field to <code>Foo</code> and make changes to the pattern as needed.</li>
<li>The distinction between a capture and a constant expression can be hard to spot. Try changing the <code>2</code> in the second arm to a variable, and see that it subtly doesn’t work. Change it to a <code>const</code> and see it working again.</li>
</ul>
</details><h1><a class="header" href="#解构数组" id="解构数组">解构数组</a></h1>
<p>你可以通过元素匹配来解构数组、元组和切片：</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!(&quot;Tell me about {triple:?}&quot;);
    match triple {
        [0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        [1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _         =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>对未知长度的切片进行解构也可以使用固定长度的模式。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    inspect(&amp;[0, -2, 3]);
    inspect(&amp;[0, -2, 3, 4]);
}

#[rustfmt::skip]
fn inspect(slice: &amp;[i32]) {
    println!(&quot;Tell me about {slice:?}&quot;);
    match slice {
        &amp;[0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        &amp;[1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _          =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
</li>
<li>
<p>使用 <code>_</code> 创建一个新的模式来代表一个元素。</p>
</li>
<li>
<p>向数组中添加更多的值。</p>
</li>
<li>
<p>指出 <code>..</code> 是如何扩展以适应不同数量的元素的。 </p>
</li>
<li>
<p>展示使用模式 <code>[.., b]</code> 和 <code>[a@..,b]</code> 来匹配切片的尾部。</p>
</li>
</ul>
</details><h1><a class="header" href="#匹配守卫" id="匹配守卫">匹配守卫</a></h1>
<p>When matching, you can add a <em>guard</em> to a pattern. This is an arbitrary Boolean expression which will be executed if the pattern matches:</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>Match guards as a separate syntax feature are important and necessary when we wish to concisely express more complex ideas than patterns alone would allow.</li>
<li>They are not the same as separate <code>if</code> expression inside of the match arm. An <code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the match arm is selected. Failing the <code>if</code> condition inside of that block won’t result in other arms of the original <code>match</code> expression being considered.</li>
<li>You can use the variables defined in the pattern in your if expression.</li>
<li>The condition defined in the guard applies to every expression in a pattern with an <code>|</code>.</li>
</ul>
</details><h1><a class="header" href="#day-1-afternoon-exercises" id="day-1-afternoon-exercises">Day 1: Afternoon Exercises</a></h1>
<p>We will look at two things:</p>
<ul>
<li>
<p>The Luhn algorithm,</p>
</li>
<li>
<p>An exercise on pattern matching.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#luhn-算法" id="luhn-算法">Luhn 算法</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to validate credit card numbers. The algorithm takes a string as input and does the following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject number with less than two digits.</p>
</li>
<li>
<p>Moving from <strong>right to left</strong>, double every second digit: for the number <code>1234</code>, we double <code>3</code> and <code>1</code>. For the number <code>98765</code>, we double <code>6</code> and <code>8</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits if the result is greater than 9. So doubling <code>7</code> becomes <code>14</code> which becomes <code>1 + 4 = 5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function.</p>
<p>Try to solve the problem the “simple” way first, using <code>for</code> loops and integers. Then, revisit the solution and try to implement it with iterators.</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn luhn(cc_number: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
    assert!(!luhn(&quot;foo 0 0&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<h1><a class="header" href="#exercise-expression-evaluation" id="exercise-expression-evaluation">Exercise: Expression Evaluation</a></h1>
<p>Let’s write a simple recursive evaluator for arithmetic expressions. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op {
        op: Operation,
        left: Box&lt;Expression&gt;,
        right: Box&lt;Expression&gt;,
    },

    /// A literal value
    Value(i64),
}

/// The result of evaluating an expression.
#[derive(Debug, PartialEq, Eq)]
enum Res {
    /// Evaluation was successful, with the given result.
    Ok(i64),
    /// Evaluation failed, with the given error message.
    Err(String),
}
// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.
use Res::{Err, Ok};

fn eval(e: Expression) -&gt; Res {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Box</code> type here is a smart pointer, and will be covered in detail later in the course. An expression can be “boxed” with <code>Box::new</code> as seen in the tests. To evaluate a boxed expression, use the deref operator to “unbox” it: <code>eval(*boxed_expr)</code>.</p>
<p>Some expressions cannot be evaluated and will return an error. The <code>Res</code> type represents either a successful value or an error with a message. This is very similar to the standard-library <code>Result</code> which we will see later.</p>
<p>Copy and paste the code into the Rust playground, and begin implementing <code>eval</code>. The final product should pass the tests. It may be helpful to use <code>todo!()</code> and get the tests to pass one-by-one.</p>
<p>If you finish early, try writing a test that results in an integer overflow. How could you handle this with <code>Res::Err</code> instead of a panic?</p>
<h1><a class="header" href="#欢迎来到第二天" id="欢迎来到第二天">欢迎来到第二天</a></h1>
<p>现在我们已经了解了相当多的Rust，接下来我们将学习：</p>
<ul>
<li>
<p>内存管理：栈与堆，手动内存管理，基于作用域的内存管理，以及垃圾回收。</p>
</li>
<li>
<p>所有权：移动（move）的语义，复制（copy）和克隆（clone），借用（borrow），以及生命周期。</p>
</li>
<li>
<p>Structs and methods.</p>
</li>
<li>
<p>标准库: <code>字符串（String）</code>, <code>选项（Option）</code> 和 <code>结果（Result）</code>, <code>动态数组（Vec）</code>, <code>散列表（HashMap）</code>, <code>引用计数（Rc）</code> 和 <code>共享引用计数（Arc）</code>。</p>
</li>
<li>
<p>模块: 可见性, 路径和文件系统的层次结构。</p>
</li>
</ul>
<h1><a class="header" href="#内存管理" id="内存管理">内存管理</a></h1>
<p>传统上，语言分为两大类：</p>
<ul>
<li>通过手动内存管理实现完全控制：C、C++、Pascal…</li>
<li>运行时通过自动内存管理实现完全安全：Java、Python、Go、Haskell…</li>
</ul>
<p>Rust 提供了一个全新的组合：</p>
<blockquote>
<p>通过编译时强制执行正确的内存&gt;管理来实现完全控制与安全。</p>
</blockquote>
<p>它通过一个明确的所有权（ownership）概念来实现此目的。</p>
<p>首先，我们回顾一下内存管理的工作原理。</p>
<h1><a class="header" href="#栈与堆" id="栈与堆">栈与堆</a></h1>
<ul>
<li>
<p>栈：局部变量的连续内存区域。</p>
<ul>
<li>值在编译时具有已知的固定大小。</li>
<li>速度极快：只需移动一个栈指针。</li>
<li>易于管理：遵循函数调用规则。</li>
<li>优秀的内存局部性。</li>
</ul>
</li>
<li>
<p>堆：函数调用之外的值的存储。</p>
<ul>
<li>值具有动态大小，具体大小需在运行时确定。</li>
<li>比栈稍慢：需要向系统申请空间。</li>
<li>不保证内存局部性。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#stack-and-heap-example" id="stack-and-heap-example">Stack and Heap Example</a></h1>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="50" y="108" >len</text><text x="178" y="108" >5</text><text x="50" y="124" >capacity</text><text x="178" y="124" >5</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="508" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="308" y1="104" x2="508" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><path d="M 528,24 A 4,4 0,0,1 532,28" class="nofill"></path><line x1="532" y1="28" x2="532" y2="148" class="broken"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><path d="M 532,148 A 4,4 0,0,1 528,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>指出 <code>String</code> 底层由 <code>Vec</code> 实现，因此它具有容量和长度，如果值可变，则可以通过在堆上重新分配存储空间进行增长。</p>
</li>
<li>
<p>如果学员提出相关问题，你可以提及我们不仅能使用[系统分配器]在堆上分配底层内存，还能使用 <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a> 实现自定义分配器</p>
</li>
<li>
<p>我们可以使用 <code>unsafe</code> 代码检查内存布局。不过，你应该指出，这种做法不安全！</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::from(&quot;Hello&quot;);
    s1.push(' ');
    s1.push_str(&quot;world&quot;);
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (ptr, capacity, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!(&quot;ptr = {ptr:#x}, len = {len}, capacity = {capacity}&quot;);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#手动内存管理" id="手动内存管理">手动内存管理</a></h1>
<p>你自己实现堆内存分配和释放。</p>
<p>稍有不慎，这可能会导致崩溃、bug、安全漏洞和内存泄漏。</p>
<h2><a class="header" href="#c-示例" id="c-示例">C++ 示例</a></h2>
<p>你必须对使用 <code>malloc</code> 分配的每个指针调用 <code>free</code>：</p>
<pre><code class="language-c">void foo(size_t n) {
    int* int_array = malloc(n * sizeof(int));
    //
    // ... lots of code
    //
    free(int_array);
}
</code></pre>
<p>Memory is leaked if the function returns early between <code>malloc</code> and <code>free</code>: the pointer is lost and we cannot deallocate the memory. Worse, freeing the pointer twice, or accessing a freed pointer can lead to exploitable security vulnerabilities.</p>
<h1><a class="header" href="#基于作用域的内存管理" id="基于作用域的内存管理">基于作用域的内存管理</a></h1>
<p>构造函数和析构函数让你可以钩入对象的生命周期。</p>
<p>通过将指针封装在对象中，你可以在该对象 被销毁时释放内存。编译器可保证这一点的实现，即使引发了异常也不例外。</p>
<p>这通常称为“资源获取即初始化 (resource acquisition is initialization, RAII)”， 并为你提供智能指针。</p>
<h2><a class="header" href="#c-示例-1" id="c-示例-1">C++ 示例</a></h2>
<pre><code class="language-c++">void say_hello(std::unique_ptr&lt;Person&gt; person) {
  std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; person-&gt;name &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li><code>std::unique_ptr</code> 对象在栈上分配内存，并指向在堆上分配的内存。</li>
<li>在 <code>say_hello</code> 结束时，<code>std::unique_ptr</code> 析构函数将运行。</li>
<li>析构函数释放它所指向的 <code>Person</code> 对象。</li>
</ul>
<p>将所有权传递给函数时，使用特殊的 move 构造函数：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-c++">std::unique_ptr&lt;Person&gt; person = find_person(&quot;Carla&quot;);
say_hello(std::move(person));
</code></pre>
<h1><a class="header" href="#自动内存管理" id="自动内存管理">自动内存管理</a></h1>
<p>自动内存管理是手动和基于作用域的内存管理 的替代方案：</p>
<ul>
<li>程序员从不显式分配或取消分配内存。</li>
<li>垃圾回收器找到未使用的内存，并为程序员将其取消分配。</li>
</ul>
<h2><a class="header" href="#java-示例" id="java-示例">Java 示例</a></h2>
<p><code>sayHello</code> 返回后，<code>person</code> 对象未被取消分配：</p>
<pre><code class="language-java">void sayHello(Person person) {
  System.out.println(&quot;Hello &quot; + person.getName());
}
</code></pre>
<h1><a class="header" href="#rust-中的内存管理" id="rust-中的内存管理">Rust 中的内存管理</a></h1>
<p>Rust 中的内存管理是一种混合模式：</p>
<ul>
<li>像 Java 一样安全又正确，但没有垃圾回收器。</li>
<li>像 C++ 一样基于作用域，但编译器会强制完全遵循规则。</li>
<li>Rust 用户可以根据具体情况选择合适的抽象，有些甚至没有像 C 那样的运行时开销。</li>
</ul>
<p>Rust achieves this by modeling <em>ownership</em> explicitly.</p>
<details>
<ul>
<li>
<p>如果此时被问及如何操作，你可以提及在 Rust 中，这通常由 RAII 封装容器类型（例如 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box</a>、<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a>、<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> 或 <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>）处理。这些类型通过各种方式封装了所有权和内存分配，并防止了 C 中潜在错误的发生。</p>
</li>
<li>
<p>你可能会被问及析构函数，此处 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> trait 是 Rust 等效项。</p>
</li>
</ul>
</details><h1><a class="header" href="#所有权" id="所有权">所有权</a></h1>
<p>所有变量绑定都有一个有效的“作用域”，使用 超出其作用域的变量是错误的：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<ul>
<li>作用域结束时，变量会“被丢弃”，数据会被释放。</li>
<li>析构函数可在此运行以释放资源。</li>
<li>指出变量“拥有”值。</li>
</ul>
<h1><a class="header" href="#移动语义" id="移动语义">移动语义</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>将 <code>s1</code> 赋值给 <code>s2</code>，即转移了所有权。</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>当 <code>s2</code> 离开作用域时，字符串数据被释放。</li>
<li>变量绑定在任一时刻有且“只有”一个值。</li>
</ul>
<details>
<ul>
<li>
<p>指出这与 C++ 中的默认值相反。除非你使用 <code>std::move</code>（并已定义 move 构造函数！），否则 C++ 中的默认值是按值复制的。</p>
</li>
<li>
<p>It is only the ownership that moves. Whether any machine code is generated to manipulate the data itself is a matter of optimization, and such copies are aggressively optimized away.</p>
</li>
<li>
<p>Simple values (such as integers) can be marked <code>Copy</code> (see later slides).</p>
</li>
<li>
<p>在 Rust 中，克隆是显式的（通过使用 <code>clone</code>）。</p>
</li>
</ul>
</details><h1><a class="header" href="#rust-中移动的字符串" id="rust-中移动的字符串">Rust 中移动的字符串</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Rust&quot;);
    let s2: String = s1;
}
</code></pre></pre>
<ul>
<li><code>s1</code> 中的堆数据会被 <code>s2</code> 重复使用。</li>
<li>当 <code>s1</code> 离开作用域时，什么都不会发生（它已被移出）。</li>
</ul>
<p>移动到 <code>s2</code> 中之前：</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<p>移动到 <code>s2</code> 中之后：</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="304"></rect><text x="10" y="12" >栈</text><text x="258" y="12" >堆</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><text x="226" y="44" >:</text><text x="274" y="44" >:</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><text x="498" y="44" >:</text><text x="42" y="60" >s1</text><text x="226" y="76" >:</text><text x="274" y="76" >:</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >4</text><text x="50" y="236" >capacity</text><text x="178" y="236" >4</text><text x="210" y="60" >:</text><text x="258" y="60" >:</text><text x="482" y="60" >:</text><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >（无法访问）</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="32" class="solid"></line></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="32" class="solid"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="32" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="228" y1="80" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><line x1="276" y1="80" x2="276" y2="148" class="broken"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="500" y1="64" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div><h1><a class="header" href="#defensive-copies-in-modern-c" id="defensive-copies-in-modern-c">Defensive Copies in Modern C++</a></h1>
<p>现代 C++ 以不同的方式解决此问题：</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // 复制 s1 中的数据。
</code></pre>
<ul>
<li><code>s1</code> 中的堆数据被复制，<code>s2</code> 获得自己的独立副本。</li>
<li>当 <code>s1</code> 和 <code>s2</code> 离开作用域时，它们会各自释放自己的内存。</li>
</ul>
<p>复制-赋值之前：</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>复制-赋值之后：</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<details>
<p>关键点：</p>
<ul>
<li>
<p>C++ has made a slightly different choice than Rust. Because <code>=</code> copies data, the string data has to be cloned. Otherwise we would get a double-free when either string goes out of scope.</p>
</li>
<li>
<p>C++ also has <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>, which is used to indicate when a value may be moved from. If the example had been <code>s2 = std::move(s1)</code>, no heap allocation would take place. After the move, <code>s1</code> would be in a valid but unspecified state. Unlike Rust, the programmer is allowed to keep using <code>s1</code>.</p>
</li>
<li>
<p>Unlike Rust, <code>=</code> in C++ can run arbitrary code as determined by the type which is being copied or moved.</p>
</li>
</ul>
</details><h1><a class="header" href="#函数调用中的移动" id="函数调用中的移动">函数调用中的移动</a></h1>
<p>你将值传递给函数时，该值会被赋给函数 参数。这就转移了所有权：</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>首次调用 <code>say_hello</code> 时，<code>main</code> 便放弃了 <code>name</code> 的所有权。此后，<code>main</code> 中不能再使用 <code>name</code>。</li>
<li>在 <code>say_hello</code> 函数结束时，系统会释放为 <code>name</code> 分配的堆内存。</li>
<li>如果 <code>main</code> 将 <code>name</code> 作为引用 (<code>&amp;name</code>) 传递过去，且 <code>say_hello</code> 接受作为参数的引用，则可保留所有权。</li>
<li>此外，<code>main</code> 也可以在首次调用时传递 <code>name</code> 的克隆 (<code>name.clone()</code>)。</li>
<li>相较于 C++，Rust 通过将移动语义设为默认值，并强制程序员进行显式克隆，更难以无意中创建副本。</li>
</ul>
</details><h1><a class="header" href="#复制和克隆" id="复制和克隆">复制和克隆</a></h1>
<p>虽然移动语义是默认的，但默认情况下会复制某些类型：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;);
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>这些类型实现了 <code>Copy</code> trait。</p>
<p>你可以选择自己的类型来使用复制语义：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>赋值之后，<code>p1</code> 和 <code>p2</code> 都拥有自己的数据。</li>
<li>我们还可以使用 <code>p1.clone()</code> 显式复制数据。</li>
</ul>
<details>
<p>复制和克隆是两码事：</p>
<ul>
<li>复制是指内存区域的按位复制，不适用于任意对象。</li>
<li>复制不允许自定义逻辑（不同于 C++ 中的复制构造函数）。</li>
<li>克隆是一种更通用的操作，也允许通过实现 <code>Clone</code> trait 来自定义行为。</li>
<li>复制不适用于实现 <code>Drop</code> trait 的类型。</li>
</ul>
<p>在上述示例中，请尝试以下操作：</p>
<ul>
<li>在 <code>struct Point</code> 中添加 <code>String</code> 字段。由于 <code>String</code> 不属于 <code>Copy</code> 类型，因此无法编译。</li>
<li>从 <code>derive</code> 属性中移除 <code>Copy</code>。现在，编译器错误位于 <code>p1</code>的 <code>println!</code> 中。</li>
<li>指出如果你改为克隆 <code>p1</code>，则可按预期运行。</li>
</ul>
<p>如果学员问起 <code>derive</code>，只需说这是一种 在编译时生成 Rust 代码的方法。在这种情况下，系统会生成 <code>Copy</code> 和 <code>Clone</code> trait 的默认实现。</p>
</details><h1><a class="header" href="#借用" id="借用">借用</a></h1>
<p>调用函数时，你可以让 函数“借用”值，而不是转移所有权：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>add</code> 函数“借用”两个点并返回一个新点。</li>
<li>调用方会保留输入的所有权。</li>
</ul>
<details>
<p>关于栈返回的说明：</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/">Playground</a> or look at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the “DEBUG” optimization level, the addresses should change, while they stay the same when changing to the “RELEASE” setting:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>Rust 编译器能够执行返回值优化 (RVO)。</p>
</li>
<li>
<p>In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always perform a simple and efficient <code>memcpy</code> copy.</p>
</li>
</ul>
</details><h1><a class="header" href="#共享和唯一的借用" id="共享和唯一的借用">共享和唯一的借用</a></h1>
<p>Rust 限制了借用值的方式：</p>
<ul>
<li>在任何给定时间，你都可以有一个或多个 <code>&amp;T</code> 值，或者</li>
<li>你可以有且只有一个 <code>&amp;mut T</code> 值。</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>上述代码无法编译，因为 <code>a</code> 同时作为可变值（通过 <code>c</code>）和不可变值（通过 <code>b</code>）被借用。</li>
<li>将<code>b</code> 的 <code>println!</code> 语句移到引入 <code>c</code> 的作用域之前，这段代码就可以编译。</li>
<li>这样更改后，编译器会发现 <code>b</code> 只在通过 <code>c</code> 对 <code>a</code> 进行新可变借用之前使用过。这是借用检查器的一个功能，名为“非词法作用域生命周期”。</li>
</ul>
</details><h1><a class="header" href="#生命周期" id="生命周期">生命周期</a></h1>
<p>借用的值是有“生命周期”的：</p>
<ul>
<li>生命周期可以是隐式的：add(p1: &amp;Point, p2: &amp;Point) -&gt; Point`。</li>
<li>生命周期也可以是显式的：<code>&amp;'a Point</code>、<code>&amp;'document str</code>。</li>
<li>将 <code>&amp;'a Point</code> 读取为“借用的 <code>Point，至少 在 </code>a` 生命周期内有效。</li>
<li>生命周期始终由编译器推断出来：你不能自行 分配生命周期。
<ul>
<li>生命周期注释会创建约束条件；编译器会验证 是否存在有效的解决方案。</li>
</ul>
</li>
<li>Lifetimes for function arguments and return values must be fully specified, but Rust allows lifetimes to be elided in most cases with <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple rules</a>.</li>
</ul>
<h1><a class="header" href="#函数调用中的生命周期" id="函数调用中的生命周期">函数调用中的生命周期</a></h1>
<p>除了借用其参数之外，函数还可以返回借用的值：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3: &amp;Point = left_most(&amp;p1, &amp;p2);
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>'a</code> 是一个泛型形参，由编译器推断出来。</li>
<li>以 <code>'</code> 和 <code>'a</code> 开头的生命周期是典型的默认名称。</li>
<li>将 <code>&amp;'a Point</code> 读取为“借用的 <code>Point，至少 在 </code>a` 生命周期内有效。
<ul>
<li>当参数在不同的作用域时，“至少”部分至关重要。</li>
</ul>
</li>
</ul>
<details>
<p>在上述示例中，请尝试以下操作：</p>
<ul>
<li>
<p>将 <code>p2</code> 和 <code>p3</code> 的声明移至新作用域 (<code>{ ... }</code>)，以产生以下代码：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p3: &amp;Point;
    {
        let p2: Point = Point(20, 20);
        p3 = left_most(&amp;p1, &amp;p2);
    }
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre>
<p>请注意：由于 <code>p3</code> 的生命周期比 <code>p2</code> 长，因此无法编译。</p>
</li>
<li>
<p>重置工作区，然后将函数签名更改为 <code>fn left_most&lt;'a, 'b&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'b Point</code>。这不会被编译，因为 <code>'a</code> 和 <code>'b</code> 生命周期之间的关系不明确。</p>
</li>
<li>
<p>另一种解释方式：</p>
<ul>
<li>对两个值的两个引用被一个函数借用，该函数返回 另一个引用。</li>
<li>它必须是来自这两个输入中的一个（或来自一个全局变量）。</li>
<li>是哪一个呢？编译器需要知道这一点，因此在调用点，返回的引用 的使用时间不会超过引用的来源中的变量。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#数据结构中的生命周期" id="数据结构中的生命周期">数据结构中的生命周期</a></h1>
<p>如果数据类型存储了借用的数据，则必须对其添加生命周期注释：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>在上述示例中，<code>Highlight</code> 注释会强制包含 <code>&amp;str</code> 的底层数据的生命周期至少与使用该数据的任何 <code>Highlight</code> 实例一样长。</li>
<li>如果 <code>text</code> 在 <code>fox</code>（或 <code>dog</code>）的生命周期结束前被消耗，借用检查器将抛出一个错误。</li>
<li>借用数据的类型会迫使用户保留原始数据。这对于创建轻量级视图很有用，但通常会使它们更难使用。</li>
<li>如有可能，让数据结构直接拥有自己的数据。</li>
<li>一些包含多个引用的结构可以有多个生命周期注释。除了结构体本身的生命周期之外，如果需要描述引用之间的生命周期关系，则可能需要这样做。这些都是非常高级的用例。</li>
</ul>
</details><h1><a class="header" href="#结构体" id="结构体">结构体</a></h1>
<p>与 C 和 C++ 一样，Rust 支持自定义结构体：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    peter.age = 28;
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    let jackie = Person {
        name: String::from(&quot;Jackie&quot;),
        ..peter
    };
    println!(&quot;{} is {} years old&quot;, jackie.name, jackie.age);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>Methods are defined in an <code>impl</code> block, which we will see in following slides.</li>
<li>This may be a good time to let people know there are different types of structs. 
<ul>
<li>Zero-sized structs <code>e.g., struct Foo;</code> might be used when implementing a trait on some type but don’t have any data that you want to store in the value itself. </li>
<li>The next slide will introduce Tuple structs, used when the field names are not important.</li>
</ul>
</li>
<li>The syntax <code>..peter</code> allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element.</li>
</ul>
</details><h1><a class="header" href="#元组结构体" id="元组结构体">元组结构体</a></h1>
<p>如果字段名称不重要，您可以使用元组结构体：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>这通常用于单字段封装容器（称为 newtype）：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}

</code></pre></pre>
<details>
<ul>
<li>如需对基元类型中的值的额外信息进行编码，使用 newtype 是一种非常好的方式，例如：
<ul>
<li>数字会以某些单位来衡量：上方示例中为 <code>Newtons</code>。</li>
<li>值在创建时已通过一些验证，因此您不再需要在每次使用时都再次验证它：<code>PhoneNumber(String)</code> 或 <code>OddNumber(u32)</code>。</li>
</ul>
</li>
<li>展示如何通过访问 newtype 中的单个字段，将 <code>f64</code> 值添加到 <code>Newtons</code> 类型。
<ul>
<li>Rust 通常不喜欢不明确的内容，例如自动解封或将布尔值用作整数。</li>
<li>运算符过载在第 3 天（泛型）讨论。</li>
</ul>
</li>
<li>此示例巧妙地引用了<a href="https://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F">火星气候探测者号</a> 的失败事故。</li>
</ul>
</details><h1><a class="header" href="#字段简写语法" id="字段简写语法">字段简写语法</a></h1>
<p>如果您已有名称正确的变量，则可以使用简写形式创建结构体：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let peter = Person::new(String::from(&quot;Peter&quot;), 27);
    println!(&quot;{peter:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>new</code> function could be written using <code>Self</code> as a type, as it is interchangeable with the struct type name</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Person {
    fn new(name: String, age: u8) -&gt; Self {
        Self { name, age }
    }
}
</code></pre></pre>
</li>
<li>
<p>Implement the <code>Default</code> trait for the struct. Define some fields and use the default values for the other fields.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: &quot;Bot&quot;.to_string(),
            age: 0,
        }
    }
}
fn create_default() {
    let tmp = Person {
        ..Person::default()
    };
    let tmp = Person {
        name: &quot;Sam&quot;.to_string(),
        ..Person::default()
    };
}
</code></pre></pre>
</li>
<li>
<p>Methods are defined in the <code>impl</code> block.</p>
</li>
<li>
<p>Use struct update syntax to define a new structure using <code>peter</code>. Note that the variable <code>peter</code> will no longer be accessible afterwards.</p>
</li>
<li>
<p>Use <code>{:#?}</code> when printing structs to request the <code>Debug</code> representation.</p>
</li>
</ul>
</details><h1><a class="header" href="#方法-1" id="方法-1">方法</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn say_hello(&amp;self) {
        println!(&quot;Hello, my name is {}&quot;, self.name);
    }
}

fn main() {
    let peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    peter.say_hello();
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>It can be helpful to introduce methods by comparing them to functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver.
<ul>
<li>Show that it is an abbreviated term for <code>self: Self</code> and perhaps show how the struct name could also be used.</li>
<li>Explain that <code>Self</code> is a type alias for the type the <code>impl</code> block is in and can be used elsewhere in the block.</li>
<li>Note how <code>self</code> is used like other structs and dot notation can be used to refer to individual fields.</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by modifying the code and trying to run say_hello twice.</li>
</ul>
</li>
<li>We describe the distinction between method receivers next.</li>
</ul>
</details><h1><a class="header" href="#方法接收者" id="方法接收者">方法接收者</a></h1>
<p>The <code>&amp;self</code> above indicates that the method borrows the object immutably. There are other possible receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The method becomes the owner of the object. The object will be dropped (deallocated) when the method returns, unless its ownership is explicitly transmitted. Complete ownership does not automatically mean mutability.</li>
<li><code>mut self</code>: same as above, but the method can mutate the object. </li>
<li>No receiver: this becomes a static method on the struct. Typically used to create constructors which are called <code>new</code> by convention.</li>
</ul>
<p>Beyond variants on <code>self</code>, there are also <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a> allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</p>
<details>
<p>Consider emphasizing “shared and immutable” and “unique and mutable”. These constraints always come together in Rust due to borrow checker rules, and <code>self</code> is no exception. It isn’t possible to reference a struct from multiple locations and call a mutating (<code>&amp;mut self</code>) method on it.</p>
</details><h1><a class="header" href="#示例" id="示例">示例</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    fn new(name: &amp;str) -&gt; Race {  // No receiver, a static method
        Race { name: String::from(name), laps: Vec::new() }
    }

    fn add_lap(&amp;mut self, lap: i32) {  // Exclusive borrowed read-write access to self
        self.laps.push(lap);
    }

    fn print_laps(&amp;self) {  // Shared and read-only borrowed access to self
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    fn finish(self) {  // Exclusive ownership of self
        let total = self.laps.iter().sum::&lt;i32&gt;();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>All four methods here use a different method receiver.
<ul>
<li>You can point out how that changes what the function can do with the variable values and if/how it can be used again in <code>main</code>.</li>
<li>You can showcase the error that appears when trying to call <code>finish</code> twice.</li>
</ul>
</li>
<li>Note that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the <code>&amp;</code>, <code>*</code>, <code>muts</code> so that that object matches the method signature.</li>
<li>You might point out that <code>print_laps</code> is using a vector that is iterated over. We describe vectors in more detail in the afternoon. </li>
</ul>
</details><h1><a class="header" href="#第二天上午习题" id="第二天上午习题">第二天上午习题</a></h1>
<p>我们将考虑以下两种场景：</p>
<ul>
<li>
<p>Storing books and querying the collection</p>
</li>
<li>
<p>Keeping track of health statistics for patients</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#storing-books" id="storing-books">Storing Books</a></h1>
<p>We will learn much more about structs and the <code>Vec&lt;T&gt;</code> type tomorrow. For now, you just need to know part of its API:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut vec = vec![10, 20];
    vec.push(30);
    let midpoint = vec.len() / 2;
    println!(&quot;middle value: {}&quot;, vec[midpoint]);
    for item in &amp;vec {
        println!(&quot;item: {item}&quot;);
    }
}
</code></pre></pre>
<p>Use this to model a library’s book collection. Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and update the types to make it compile:</p>
<pre><pre class="playground"><code class="language-rust should_panic">struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Notice how the `self` parameter
// changes type to indicate the method's required level of ownership
// over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {
    fn new() -&gt; Library {
        todo!(&quot;Initialize and return a `Library` value&quot;)
    }

    fn len(&amp;self) -&gt; usize {
        todo!(&quot;Return the length of `self.books`&quot;)
    }

    fn is_empty(&amp;self) -&gt; bool {
        todo!(&quot;Return `true` if `self.books` is empty&quot;)
    }

    fn add_book(&amp;mut self, book: Book) {
        todo!(&quot;Add a new book to `self.books`&quot;)
    }

    fn print_books(&amp;self) {
        todo!(&quot;Iterate over `self.books` and print each book's title and year&quot;)
    }

    fn oldest_book(&amp;self) -&gt; Option&lt;&amp;Book&gt; {
        todo!(&quot;Return a reference to the oldest book (if any)&quot;)
    }
}

fn main() {
    let mut library = Library::new();

    println!(
        &quot;The library is empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));

    println!(
        &quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.print_books();

    match library.oldest_book() {
        Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
        None =&gt; println!(&quot;The library is empty!&quot;),
    }

    println!(&quot;The library has {} books&quot;, library.len());
    library.print_books();
}
</code></pre></pre>
<h1><a class="header" href="#健康统计" id="健康统计">健康统计</a></h1>
<p>你正在实现一个健康监控系统。作为其中的一部分，你需要对用户的健康统计数据进行追踪。</p>
<p><code>User</code> 结构体的定义和 <code>impl</code> 块中一些函数的框架已经给出。你的目标是实现在 <code>impl</code> 块中定义的 <code>User</code> <code>struct</code> 的方法。</p>
<p>将以下代码复制到 <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>，并填充缺失的方法：</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        todo!(&quot;Create a new User instance&quot;)
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        todo!(&quot;Return the user's name&quot;)
    }

    pub fn age(&amp;self) -&gt; u32 {
        todo!(&quot;Return the user's age&quot;)
    }

    pub fn height(&amp;self) -&gt; f32 {
        todo!(&quot;Return the user's height&quot;)
    }

    pub fn doctor_visits(&amp;self) -&gt; u32 {
        todo!(&quot;Return the number of time the user has visited the doctor&quot;)
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        todo!(&quot;Set the user's age&quot;)
    }

    pub fn set_height(&amp;mut self, new_height: f32) {
        todo!(&quot;Set the user's height&quot;)
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        todo!(&quot;Update a user's statistics based on measurements from a visit to the doctor&quot;)
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_height() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.height(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.doctor_visits(), 0);
    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (120, 80),
    });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);

    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (115, 76),
    });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
}
</code></pre></pre>
<h1><a class="header" href="#标准库" id="标准库">标准库</a></h1>
<p>Rust 附带一个标准库，此库有助于建立一个供 Rust 库和程序 使用的常用类型集。这样一来，两个库便可顺畅地搭配运作， 因为它们使用相同的 <code>String</code> 类型。</p>
<p>常见的词汇类型包括：</p>
<ul>
<li>
<p><a href="std/option-result.html"><code>Option</code> 和 <code>Result</code></a> 类型：用于可选值和 <a href="error-handling.html">错误处理</a>。</p>
</li>
<li>
<p><a href="std/string.html"><code>String</code></a>：用于自有数据的默认字符串类型。</p>
</li>
<li>
<p><a href="std/vec.html"><code>Vec</code></a>：标准的可扩展矢量。</p>
</li>
<li>
<p><a href="std/hashmap.html"><code>HashMap</code></a>：采用可配置哈希算法的哈希映射 类型。</p>
</li>
<li>
<p><a href="std/box.html"><code>Box</code></a>：适用于堆分配数据的自有指针。</p>
</li>
<li>
<p><a href="std/rc.html"><code>Rc</code></a>：适用于堆分配数据的共享引用计数指针。</p>
</li>
</ul>
<details>
<ul>
<li>Rust 实际上含有多个层级的标准库，分别是 <code>core</code>、<code>alloc</code> 和 <code>std</code>。</li>
<li><code>core</code> 包括最基本的类型与函数，这些类型与函数不依赖于 <code>libc</code>、分配器 或是否存在操作系统。</li>
<li><code>alloc</code> 包括需要全局堆分配器的类型，例如 <code>Vec</code>、<code>Box</code> 和 <code>Arc</code>。</li>
<li>嵌入式 Rust 应用通常只使用 <code>core</code>，偶尔会使用 <code>alloc</code>。</li>
</ul>
</details><h1><a class="header" href="#option-和-result" id="option-和-result"><code>Option</code> 和 <code>Result</code></a></h1>
<p>这些类型表示可选数据：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let numbers = vec![10, 20, 30];
    let first: Option&lt;&amp;i8&gt; = numbers.first();
    println!(&quot;first: {first:?}&quot;);

    let arr: Result&lt;[i8; 3], Vec&lt;i8&gt;&gt; = numbers.try_into();
    println!(&quot;arr: {arr:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Option</code> 和 <code>Result</code> 的使用范围很广，不局限于标准库。</li>
<li>相较于 <code>&amp;T</code>，<code>Option&lt;&amp;T&gt;</code> 的空间开销为零。</li>
<li><code>Result</code> 是用于实现错误处理的标准类型，我们将在第 3 天的课程中介绍。</li>
<li><code>try_into</code> attempts to convert the vector into a fixed-sized array. This can fail:
<ul>
<li>If the vector has the right size, <code>Result::Ok</code> is returned with the array.</li>
<li>Otherwise, <code>Result::Err</code> is returned with the original vector.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> 是标准堆分配的可扩容 UTF-8 字符串缓冲区：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;🇨🇭&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(),
             s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> 会实现 <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>，这意味着您可以 对 <code>String</code> 调用所有 <code>str</code> 方法。</p>
<details>
<ul>
<li><code>String::new</code> returns a new empty string, use <code>String::with_capacity</code> when you know how much data you want to push to the string.</li>
<li><code>String::len</code> returns the size of the <code>String</code> in bytes (which can be different from its length in characters).</li>
<li><code>String::chars</code> returns an iterator over the actual characters. Note that a <code>char</code> can be different from what a human will consider a “character” due to <a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">grapheme clusters</a>.</li>
<li>When people refer to strings they could either be talking about <code>&amp;str</code> or <code>String</code>.</li>
<li>When a type implements <code>Deref&lt;Target = T&gt;</code>, the compiler will let you transparently call methods from <code>T</code>.
<ul>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it access to <code>str</code>‘s methods.</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and  <code>let s3 = &amp;*s1</code>;.</li>
</ul>
</li>
<li><code>String</code> is implemented as a wrapper around a vector of bytes, many of the operations you see supported on vectors are also supported on <code>String</code>, but with some extra guarantees.</li>
<li>Compare the different ways to index a <code>String</code>:
<ul>
<li>To a character by using <code>s3.chars().nth(i).unwrap()</code> where <code>i</code> is in-bound, out-of-bounds.</li>
<li>To a substring by using <code>s3[0..4]</code>, where that slice is on character boundaries or not.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#vec" id="vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> 是标准的可调整大小堆分配缓冲区：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!(&quot;{v3:?}&quot;);

    // Remove consecutive duplicates.
    v3.dedup();
    println!(&quot;{v3:?}&quot;);
}
</code></pre></pre>
<p><code>Vec</code> 会实现 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>，这意味着您可以对 <code>Vec</code> 调用 slice 方法。</p>
<details>
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored on the heap. This means the amount of data doesn’t need to be  known at compile time. It can grow or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don’t have to specify <code>T</code> explicitly. As always with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</li>
<li><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it supports adding initial elements to the vector.</li>
<li>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds. Alternatively, using <code>get</code> will return an <code>Option</code>. The <code>pop</code> function will remove the last element.</li>
<li>Show iterating over a vector and mutating the value: <code>for e in &amp;mut v { *e += 50; }</code></li>
</ul>
</details><h1><a class="header" href="#hashmap" id="hashmap"><code>HashMap</code></a></h1>
<p>标准的哈希映射，内含针对 HashDoS 攻击的保护措施：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;.to_string(), 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;.to_string(), 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;.to_string(), 303);

    if !page_counts.contains_key(&quot;Les Misérables&quot;) {
        println!(&quot;We know about {} books, but not Les Misérables.&quot;,
                 page_counts.len());
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;)
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        let page_count: &amp;mut i32 = page_counts.entry(book.to_string()).or_insert(0);
        *page_count += 1;
    }

    println!(&quot;{page_counts:#?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>HashMap</code> is not defined in the prelude and needs to be brought into scope.</p>
</li>
<li>
<p>Try the following lines of code. The first line will see if a book is in the hashmap and if not return an alternative value. The second line will insert the alternative value in the hashmap if the book is not found.</p>
<pre><code class="language-rust ignore">  let pc1 = page_counts
      .get(&quot;Harry Potter and the Sorcerer's Stone &quot;)
      .unwrap_or(&amp;336);
  let pc2 = page_counts
      .entry(&quot;The Hunger Games&quot;.to_string())
      .or_insert(374);
</code></pre>
</li>
<li>
<p>Unlike <code>vec!</code>, there is unfortunately no standard <code>hashmap!</code> macro.</p>
<ul>
<li>
<p>Although, since Rust 1.56, HashMap implements <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E"><code>From&lt;[(K, V); N]&gt;</code></a>, which allows us to easily initialize a hash map from a literal array:</p>
<pre><code class="language-rust ignore">  let page_counts = HashMap::from([
    (&quot;Harry Potter and the Sorcerer's Stone&quot;.to_string(), 336),
    (&quot;The Hunger Games&quot;.to_string(), 374),
  ]);
</code></pre>
</li>
</ul>
</li>
<li>
<p>Alternatively HashMap can be built from any <code>Iterator</code> which yields key-value tuples.</p>
</li>
<li>
<p>We are showing <code>HashMap&lt;String, i32&gt;</code>, and avoid using <code>&amp;str</code> as key to make examples easier. Using references in collections can, of course, be done, but it can lead into complications with the borrow checker.</p>
<ul>
<li>Try removing <code>to_string()</code> from the example above and see if it still compiles. Where do you think we might run into issues?</li>
</ul>
</li>
<li>
<p>This type has several “method-specific” return types, such as <code>std::collections::hash_map::Keys</code>. These types often appear in searches of the Rust docs. Show students the docs for this type, and the helpful link back to the <code>keys</code> method.</p>
</li>
</ul>
</details><h1><a class="header" href="#box" id="box"><code>Box</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> 是指向堆上数据的自有指针：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> 会实现 <code>Deref&lt;Target = T&gt;</code>，这意味着您可以<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">直接在 <code>Box&lt;T&gt;</code> 上通过 <code>T</code> 调用相应方法</a>。</p>
<details>
<ul>
<li>在 C++ 中，<code>Box</code> 与 <code>std::unique_ptr</code> 类似，除了它一定会不为 null 以外。</li>
<li>在上面的示例中，因为有 <code>Deref</code>，您甚至可以在 <code>println!</code> 语句中省略 <code>*</code>。</li>
<li>在以下情况下，<code>Box</code> 可能会很实用：
<ul>
<li>在编译时间遇到无法知晓大小的类型，但 Rust 编译器需要知道确切大小。</li>
<li>想要转让大量数据的所有权。为避免在堆栈上复制大量数据，请改为将数据存储在 <code>Box</code> 中的堆上，以便仅移动指针。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#包含递归数据结构的-box" id="包含递归数据结构的-box">包含递归数据结构的 Box</a></h1>
<p>递归数据类型或具有动态大小的数据类型需要使用 <code>Box</code>：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >Cons</text><text x="106" y="92" >1</text><circle cx="148" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >Cons</text><text x="370" y="92" >2</text><circle cx="412" cy="88" r="3" class="nofill"></circle><text x="490" y="92" >Nil</text><line x1="552" y1="80" x2="544" y2="96" class="solid"></line><line x1="560" y1="80" x2="552" y2="96" class="solid"></line><line x1="592" y1="80" x2="584" y2="96" class="solid"></line><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="92" y1="72" x2="92" y2="104" class="solid"></line><line x1="132" y1="72" x2="132" y2="104" class="solid"></line><line x1="172" y1="72" x2="172" y2="104" class="solid"></line><line x1="36" y1="104" x2="172" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="436" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="396" y1="72" x2="396" y2="104" class="solid"></line><line x1="436" y1="72" x2="436" y2="104" class="solid"></line><line x1="300" y1="104" x2="436" y2="104" class="solid"></line></g><g><line x1="476" y1="72" x2="612" y2="72" class="solid"></line><line x1="476" y1="72" x2="476" y2="104" class="solid"></line><line x1="532" y1="72" x2="532" y2="104" class="solid"></line><line x1="572" y1="72" x2="572" y2="104" class="solid"></line><line x1="612" y1="72" x2="612" y2="104" class="solid"></line><line x1="476" y1="104" x2="612" y2="104" class="solid"></line></g><g><line x1="152" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="416" y1="88" x2="464" y2="88" class="solid"></line><polygon points="464,84 472,88 464,92" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="148" class="broken"></line><line x1="632" y1="152" x2="640" y2="152" class="solid"></line><path d="M 644,148 A 4,4 0,0,1 640,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the <code>List</code>, the compiler would not compute a fixed size of the struct in memory (<code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> 大小与一般指针相同，并且只会指向堆中的下一个 <code>List</code> 元素， 因此可以解决这个问题。</p>
</li>
<li>
<p>将 <code>Box</code> 从 List 定义中移除后，画面上会显示编译器错误。如果您看到“Recursive with indirection”错误消息，这是在提示您使用 Box 或其他类型的引用，而不是直接储存值。</p>
</li>
</ul>
</details><h1><a class="header" href="#小众优化" id="小众优化">小众优化</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<p><code>Box</code> 不得为空，因此指针始终有效且非 <code>null</code>。这样， 编译器就可以优化内存布局：</p>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >1</text><circle cx="92" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >2</text><circle cx="356" cy="88" r="3" class="nofill"></circle><line x1="440" y1="80" x2="432" y2="96" class="solid"></line><line x1="448" y1="80" x2="440" y2="96" class="solid"></line><text x="474" y="92" >null</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="116" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="76" y1="72" x2="76" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="36" y1="104" x2="116" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="380" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="340" y1="72" x2="340" y2="104" class="solid"></line><line x1="380" y1="72" x2="380" y2="104" class="solid"></line><line x1="300" y1="104" x2="380" y2="104" class="solid"></line></g><g><line x1="420" y1="72" x2="516" y2="72" class="solid"></line><line x1="420" y1="72" x2="420" y2="104" class="solid"></line><line x1="460" y1="72" x2="460" y2="104" class="solid"></line><line x1="516" y1="72" x2="516" y2="104" class="solid"></line><line x1="420" y1="104" x2="516" y2="104" class="solid"></line></g><g><line x1="96" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="360" y1="88" x2="408" y2="88" class="solid"></line><polygon points="408,84 416,88 408,92" class="filled"></polygon></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="148" class="broken"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><path d="M 628,148 A 4,4 0,0,1 624,152" class="nofill"></path></g></svg></div><h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> 是引用计数的共享指针。如果您需要从多个位置 引用相同的数据，请使用此指针：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let mut a = Rc::new(10);
    let mut b = Rc::clone(&amp;a);

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<ul>
<li>See <a href="std/../concurrency/shared_state/arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>您可以将共享指针_降级_为 <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> 指针， 以便创建之后会被舍弃的循环引用。</li>
</ul>
<details>
<ul>
<li><code>Rc</code> 的计数可确保只要有引用，内含的值就会保持有效。</li>
<li><code>Rc</code> in Rust is like <code>std::shared_ptr</code> in C++.</li>
<li><code>Rc::clone</code> 的成本很低：这个做法会创建指向相同分配的指针，并增加引用计数，而不会产生深层的克隆，排查代码性能问题时通常可以忽略。</li>
<li><code>make_mut</code> 实际上会在必要时克隆内部值（“clone-on-write”），并返回可变的引用。</li>
<li>使用 <code>Rc::strong_count</code> 可查看引用计数。</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to create cycles that will be dropped properly (likely in combination with <code>RefCell</code>, on the next slide).</li>
</ul>
</details><h1><a class="header" href="#cell-and-refcell" id="cell-and-refcell"><code>Cell</code> and <code>RefCell</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> implement what Rust calls <em>interior mutability:</em> mutation of values in an immutable context.</p>
<p><code>Cell</code> is typically used for simple types, as it requires copying or moving values. More complex interior types typically use <code>RefCell</code>, which tracks shared and exclusive references at runtime and panics if they are misused.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug, Default)]
struct Node {
    value: i64,
    children: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(value: i64) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        Rc::new(RefCell::new(Node { value, ..Node::default() }))
    }

    fn sum(&amp;self) -&gt; i64 {
        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::&lt;i64&gt;()
    }
}

fn main() {
    let root = Node::new(1);
    root.borrow_mut().children.push(Node::new(5));
    let subtree = Node::new(10);
    subtree.borrow_mut().children.push(Node::new(11));
    subtree.borrow_mut().children.push(Node::new(12));
    root.borrow_mut().children.push(subtree);

    println!(&quot;graph: {root:#?}&quot;);
    println!(&quot;graph sum: {}&quot;, root.borrow().sum());
}
</code></pre></pre>
<details>
<ul>
<li>If we were using <code>Cell</code> instead of <code>RefCell</code> in this example, we would have to move the <code>Node</code> out of the <code>Rc</code> to push children, then move it back in. This is safe because there’s always one, un-referenced value in the cell, but it’s not ergonomic.</li>
<li>To do anything with a Node, you must call a <code>RefCell</code> method, usually <code>borrow</code> or <code>borrow_mut</code>.</li>
<li>Demonstrate that reference loops can be created by adding <code>root</code> to <code>subtree.children</code> (don’t try to print it!).</li>
<li>To demonstrate a runtime panic, add a <code>fn inc(&amp;mut self)</code> that increments <code>self.value</code> and calls the same method on its children. This will panic in the presence of the reference loop, with <code>thread 'main' panicked at 'already borrowed: BorrowMutError'</code>.</li>
</ul>
</details><h1><a class="header" href="#模块" id="模块">模块</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<details>
<ul>
<li>Packages provide functionality and include a <code>Cargo.toml</code> file that describes how to build a bundle of 1+ crates.</li>
<li>Crates are a tree of modules, where a binary crate creates an executable and a library crate compiles to a library.</li>
<li>Modules define organization, scope, and are the focus of this section.</li>
</ul>
</details><h1><a class="header" href="#可见性" id="可见性">可见性</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
<li>In other words, if an item is visible in module <code>foo</code>, it’s visible in all the descendants of <code>foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<details>
<ul>
<li>Use the <code>pub</code> keyword to make modules public.</li>
</ul>
<p>Additionally, there are advanced <code>pub(...)</code> specifiers to restrict the scope of public visibility.</p>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust Reference</a>.</li>
<li>Configuring <code>pub(crate)</code> visibility is a common pattern.</li>
<li>Less commonly, you can give visibility to a specific path.</li>
<li>In any case, visibility must be granted to an ancestor module (and all of its descendants).</li>
</ul>
</details><h1><a class="header" href="#路径" id="路径">路径</a></h1>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<p>A module can bring symbols from another module into scope with <code>use</code>. You will typically see something like this at the top of each module:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashSet;
use std::mem::transmute;
</code></pre></pre>
<h1><a class="header" href="#文件系统层级结构" id="文件系统层级结构">文件系统层级结构</a></h1>
<p>Omitting the module content will tell Rust to look for it in another file:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">mod garden;
</code></pre></pre>
<p>This tells rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>. Similarly, a <code>garden::vegetables</code> module can be found at <code>src/garden/vegetables.rs</code>.</p>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<p>Modules defined in files can be documented, too, using “inner doc comments”. These document the item that contains them -- in this case, a module.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use seeds::SeedPacket;
pub use garden::Garden;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) { todo!() }

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) { todo!() }
</code></pre></pre>
<details>
<ul>
<li>
<p>Before Rust 2018, modules needed to be located at <code>module/mod.rs</code> instead of <code>module.rs</code>, and this is still a working alternative for editions after 2018.</p>
</li>
<li>
<p>The main reason to introduce <code>filename.rs</code> as alternative to <code>filename/mod.rs</code> was because many files named <code>mod.rs</code> can be hard to distinguish in IDEs.</p>
</li>
<li>
<p>Deeper nesting can use folders, even if the main module is a file:</p>
<pre><code class="language-ignore">src/
├── main.rs
├── top_module.rs
└── top_module/
    └── sub_module.rs
</code></pre>
</li>
<li>
<p>The place rust will look for modules can be changed with a compiler directive:</p>
<pre><code class="language-rust ignore">#[path = &quot;some/path.rs&quot;]
mod some_module;
</code></pre>
<p>This is useful, for example, if you would like to place tests for a module in a file named <code>some_module_test.rs</code>, similar to the convention in Go.</p>
</li>
</ul>
</details><h1><a class="header" href="#第二天下午习题" id="第二天下午习题">第二天下午习题</a></h1>
<p>今天下午的习题将重点关注字符串（string）和迭代器（iterator）。</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#迭代器和所有权" id="迭代器和所有权">迭代器和所有权</a></h1>
<p>The ownership model of Rust affects many APIs. An example of this is the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> traits.</p>
<h2><a class="header" href="#iterator" id="iterator"><code>Iterator</code></a></h2>
<p>Traits are like interfaces: they describe behavior (methods) for a type. The <code>Iterator</code> trait simply says that you can call <code>next</code> until you get <code>None</code> back:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>You use this trait like this:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    println!(&quot;v[0]: {:?}&quot;, iter.next());
    println!(&quot;v[1]: {:?}&quot;, iter.next());
    println!(&quot;v[2]: {:?}&quot;, iter.next());
    println!(&quot;No more items: {:?}&quot;, iter.next());
}
</code></pre></pre>
<p>What is the type returned by the iterator? Test your answer here:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<p>Why is this type used?</p>
<h2><a class="header" href="#intoiterator" id="intoiterator"><code>IntoIterator</code></a></h2>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an iterator. The related trait <code>IntoIterator</code> tells you how to create the iterator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax here means that every implementation of <code>IntoIterator</code> must declare two types:</p>
<ul>
<li><code>Item</code>: the type we iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same <code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>Like before, what  is the type returned by the iterator?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];
    let mut iter = v.into_iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#for-loops" id="for-loops"><code>for</code> Loops</a></h2>
<p>Now that we know both <code>Iterator</code> and <code>IntoIterator</code>, we can build <code>for</code> loops. They call <code>into_iter()</code> on an expression and iterates over the resulting iterator:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];

    for word in &amp;v {
        println!(&quot;word: {word}&quot;);
    }

    for word in v {
        println!(&quot;word: {word}&quot;);
    }
}
</code></pre></pre>
<p>What is the type of <code>word</code> in each loop?</p>
<p>Experiment with the code above and then consult the documentation for <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26&#x27;a+Vec%3CT,+A%3E"><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT,+A%3E"><code>impl IntoIterator for Vec&lt;T&gt;</code></a> to check your answers.</p>
<h1><a class="header" href="#字符串和迭代器" id="字符串和迭代器">字符串和迭代器</a></h1>
<p>In this exercise, you are implementing a routing component of a web server. The server is configured with a number of <em>path prefixes</em> which are matched against <em>request paths</em>. The path prefixes can contain a wildcard character which matches a full segment. See the unit tests below.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests pass. Try avoiding allocating a <code>Vec</code> for your intermediate results:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#welcome-to-day-3" id="welcome-to-day-3">Welcome to Day 3</a></h1>
<p>Today, we will cover some more advanced topics of Rust:</p>
<ul>
<li>
<p>Traits: deriving traits, default methods, and important standard library traits.</p>
</li>
<li>
<p>Generics: generic data types, generic methods, monomorphization, and trait objects.</p>
</li>
<li>
<p>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</p>
</li>
<li>
<p>Testing: unit tests, documentation tests, and integration tests.</p>
</li>
<li>
<p>Unsafe Rust: raw pointers, static variables, unsafe functions, and extern functions.</p>
</li>
</ul>
<h1><a class="header" href="#泛型" id="泛型">泛型</a></h1>
<p>Rust support generics, which lets you abstract algorithms or data structures (such as sorting or a binary tree) over the types used or stored.</p>
<h1><a class="header" href="#通用数据类型" id="通用数据类型">通用数据类型</a></h1>
<p>您可以使用泛型对具体字段类型进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Try declaring a new variable <code>let p = Point { x: 5, y: 10.0 };</code>.</p>
</li>
<li>
<p>Fix the code to allow points that have elements of different types.</p>
</li>
</ul>
</details><h1><a class="header" href="#泛型方法" id="泛型方法">泛型方法</a></h1>
<p>您可以在 <code>impl</code> 块中声明通用类型：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt;(T, T);

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.0  // + 10
    }

    // fn set_x(&amp;mut self, x: T)
}

fn main() {
    let p = Point(5, 10);
    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<details>
<ul>
<li>*问：*为什么 <code>T</code> 在 <code>impl&lt;T&gt; Point&lt;T&gt; {}</code> 中指定了两次？这不是多余的吗？
<ul>
<li>这是因为它是泛型类型的泛型实现部分。它们是独立的泛型内容。</li>
<li>这意味着这些方法是针对所有 <code>T</code> 定义的。</li>
<li>可以编写 <code>impl Point&lt;u32&gt; { .. }</code>。
<ul>
<li><code>Point</code> 依然是一个泛型，并且您可以使用 <code>Point&lt;f64&gt;</code>，但此块中的方法将仅适用于 <code>Point&lt;u32&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#单态化" id="单态化">单态化</a></h1>
<p>泛型代码根据调用位置转换为非泛型代码：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}
</code></pre></pre>
<p>具体行为与您所编写的一样</p>
<pre><pre class="playground"><code class="language-rust editable">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>这是零成本的抽象化处理：您得到的结果不会受到影响，也就是说，与在没有进行抽象化处理的情况下，对数据结构进行手动编码时的结果一样。</p>
<h1><a class="header" href="#特征" id="特征">特征</a></h1>
<p>Rust 让您可以依据特征对类型进行抽象化处理。特征与接口类似：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog { name: String, age: i8 }
struct Cat { lives: i8 } // No name needed, cats won't respond anyway.

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String { format!(&quot;Woof, my name is {}!&quot;, self.name) }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String { String::from(&quot;Miau!&quot;) }
}

fn greet&lt;P: Pet&gt;(pet: &amp;P) {
    println!(&quot;Oh you're a cutie! What's your name? {}&quot;, pet.talk());
}

fn main() {
    let captain_floof = Cat { lives: 9 };
    let fido = Dog { name: String::from(&quot;Fido&quot;), age: 5 };

    greet(&amp;captain_floof);
    greet(&amp;fido);
}
</code></pre></pre>
<h1><a class="header" href="#特征trait对象" id="特征trait对象">特征（Trait）对象</a></h1>
<p>特征（Trait）对象可接受不同类型的值，举例来说，在集合中会是这样：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog { name: String, age: i8 }
struct Cat { lives: i8 } // No name needed, cats won't respond anyway.

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String { format!(&quot;Woof, my name is {}!&quot;, self.name) }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String { String::from(&quot;Miau!&quot;) }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from(&quot;Fido&quot;), age: 5 }),
    ];
    for pet in pets {
        println!(&quot;Hello, who are you? {}&quot;, pet.talk());
    }
}
</code></pre></pre>
<p>以下是分配 <code>pets</code> 后的内存布局：</p>
<div style='width:100%; height:480px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="480"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="480"></rect><rect x="420" y="232" width="184" height="32" class="solid nofill" rx="0"></rect><text x="434" y="252" >&lt;Dog as Pet&gt;::talk</text><rect x="372" y="392" width="184" height="32" class="solid nofill" rx="0"></rect><text x="386" y="412" >&lt;Cat as Pet&gt;::talk</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >pets</text><text x="466" y="76" >F</text><text x="506" y="76" >i</text><text x="546" y="76" >d</text><text x="586" y="76" >o</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><circle cx="324" cy="88" r="3" class="nofill"></circle><circle cx="340" cy="88" r="3" class="nofill"></circle><circle cx="372" cy="88" r="3" class="nofill"></circle><circle cx="388" cy="88" r="3" class="nofill"></circle><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="426" y="124" >data</text><text x="434" y="156" >name</text><circle cx="508" cy="152" r="3" class="nofill"></circle><text x="514" y="156" >,</text><text x="530" y="156" >4,</text><text x="554" y="156" >4</text><text x="434" y="172" >age</text><text x="554" y="172" >5</text><text x="426" y="220" >vtable</text><text x="378" y="300" >data</text><text x="386" y="332" >lives</text><text x="482" y="332" >9</text><text x="378" y="380" >vtable</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><line x1="296" y1="456" x2="304" y2="456" class="solid"></line><line x1="312" y1="456" x2="320" y2="456" class="solid"></line><line x1="328" y1="456" x2="336" y2="456" class="solid"></line><line x1="344" y1="456" x2="352" y2="456" class="solid"></line><line x1="360" y1="456" x2="368" y2="456" class="solid"></line><line x1="376" y1="456" x2="384" y2="456" class="solid"></line><line x1="392" y1="456" x2="400" y2="456" class="solid"></line><line x1="408" y1="456" x2="416" y2="456" class="solid"></line><line x1="424" y1="456" x2="432" y2="456" class="solid"></line><line x1="440" y1="456" x2="448" y2="456" class="solid"></line><line x1="456" y1="456" x2="464" y2="456" class="solid"></line><line x1="472" y1="456" x2="480" y2="456" class="solid"></line><line x1="488" y1="456" x2="496" y2="456" class="solid"></line><line x1="504" y1="456" x2="512" y2="456" class="solid"></line><line x1="520" y1="456" x2="528" y2="456" class="solid"></line><line x1="536" y1="456" x2="544" y2="456" class="solid"></line><line x1="552" y1="456" x2="560" y2="456" class="solid"></line><line x1="568" y1="456" x2="576" y2="456" class="solid"></line><line x1="584" y1="456" x2="592" y2="456" class="solid"></line><line x1="600" y1="456" x2="608" y2="456" class="solid"></line><line x1="616" y1="456" x2="624" y2="456" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="452" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,452 A 4,4 0,0,0 280,456" class="nofill"></path><line x1="280" y1="456" x2="288" y2="456" class="solid"></line></g><g><line x1="452" y1="56" x2="612" y2="56" class="solid"></line><line x1="452" y1="56" x2="452" y2="88" class="solid"></line><line x1="492" y1="56" x2="492" y2="88" class="solid"></line><line x1="532" y1="56" x2="532" y2="88" class="solid"></line><line x1="572" y1="56" x2="572" y2="88" class="solid"></line><line x1="612" y1="56" x2="612" y2="88" class="solid"></line><line x1="452" y1="88" x2="612" y2="88" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="404" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="308" y1="104" x2="404" y2="104" class="solid"></line></g><g><path d="M 432,72 A 4,4 0,0,0 428,76" class="nofill"></path><line x1="428" y1="76" x2="428" y2="100" class="solid"></line><line x1="432" y1="72" x2="440" y2="72" class="solid"></line><polygon points="440,68 448,72 440,76" class="filled"></polygon><path d="M 428,100 A 4,4 0,0,0 432,104" class="nofill"></path><line x1="432" y1="104" x2="504" y2="104" class="solid"></line><path d="M 504,104 A 4,4 0,0,1 508,108" class="nofill"></path><line x1="508" y1="108" x2="508" y2="148" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="324" y1="92" x2="324" y2="404" class="solid"></line><path d="M 324,404 A 4,4 0,0,0 328,408" class="nofill"></path><line x1="328" y1="408" x2="360" y2="408" class="solid"></line><polygon points="360,404 368,408 360,412" class="filled"></polygon></g><g><line x1="340" y1="92" x2="340" y2="324" class="solid"></line><path d="M 340,324 A 4,4 0,0,0 344,328" class="nofill"></path><line x1="344" y1="328" x2="360" y2="328" class="solid"></line><polygon points="360,324 368,328 360,332" class="filled"></polygon></g><g><line x1="372" y1="92" x2="372" y2="244" class="solid"></line><path d="M 372,244 A 4,4 0,0,0 376,248" class="nofill"></path><line x1="376" y1="248" x2="408" y2="248" class="solid"></line><polygon points="408,244 416,248 408,252" class="filled"></polygon></g><g><line x1="388" y1="92" x2="388" y2="148" class="solid"></line><path d="M 388,148 A 4,4 0,0,0 392,152" class="nofill"></path><line x1="392" y1="152" x2="408" y2="152" class="solid"></line><polygon points="408,148 416,152 408,156" class="filled"></polygon></g><g><line x1="420" y1="136" x2="572" y2="136" class="solid"></line><line x1="420" y1="136" x2="420" y2="184" class="solid"></line><line x1="484" y1="136" x2="484" y2="184" class="solid"></line><line x1="572" y1="136" x2="572" y2="184" class="solid"></line><line x1="420" y1="184" x2="572" y2="184" class="solid"></line></g><g><line x1="372" y1="312" x2="500" y2="312" class="solid"></line><line x1="372" y1="312" x2="372" y2="344" class="solid"></line><line x1="436" y1="312" x2="436" y2="344" class="solid"></line><line x1="500" y1="312" x2="500" y2="344" class="solid"></line><line x1="372" y1="344" x2="500" y2="344" class="solid"></line></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="452" class="broken"></line><line x1="632" y1="456" x2="640" y2="456" class="solid"></line><path d="M 644,452 A 4,4 0,0,1 640,456" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>Types that implement a given trait may be of different sizes. This makes it impossible to have things like <code>Vec&lt;dyn Pet&gt;</code> in the example above.</li>
<li><code>dyn Pet</code> is a way to tell the compiler about a dynamically sized type that implements <code>Pet</code>.</li>
<li>In the example, <code>pets</code> is allocated on the stack and the vector data is on the heap. The two vector elements are <em>fat pointers</em>:
<ul>
<li>A fat pointer is a double-width pointer. It has two components: a pointer to the actual object and a pointer to the <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable) for the <code>Pet</code> implementation of that particular object.</li>
<li>The data for the <code>Dog</code> named Fido is the <code>name</code> and <code>age</code> fields. The <code>Cat</code> has a <code>lives</code> field.</li>
</ul>
</li>
<li>Compare these outputs in the above example:
<pre><code class="language-rust ignore">    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Pet&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#派生特征" id="派生特征">派生特征</a></h1>
<p>Rust derive macros work by automatically generating code that implements the specified traits for a data structure.</p>
<p>You can let the compiler derive a number of traits as follows:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Clone, PartialEq, Eq, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default();
    let p2 = p1.clone();
    println!(&quot;Is {:?}\nequal to {:?}?\nThe answer is {}!&quot;, &amp;p1, &amp;p2,
             if p1 == p2 { &quot;yes&quot; } else { &quot;no&quot; });
}
</code></pre></pre>
<h1><a class="header" href="#默认方法" id="默认方法">默认方法</a></h1>
<p>特征可以依照其他特征方法来实现行为：</p>
<pre><pre class="playground"><code class="language-rust editable">trait Equals {
    fn equals(&amp;self, other: &amp;Self) -&gt; bool;
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}

#[derive(Debug)]
struct Centimeter(i16);

impl Equals for Centimeter {
    fn equals(&amp;self, other: &amp;Centimeter) -&gt; bool {
        self.0 == other.0
    }
}

fn main() {
    let a = Centimeter(10);
    let b = Centimeter(20);
    println!(&quot;{a:?} equals {b:?}: {}&quot;, a.equals(&amp;b));
    println!(&quot;{a:?} not_equals {b:?}: {}&quot;, a.not_equals(&amp;b));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods with default implementations can rely on required methods.</p>
</li>
<li>
<p>Move method <code>not_equals</code> to a new trait <code>NotEquals</code>.</p>
</li>
<li>
<p>Make <code>Equals</code> a super trait for <code>NotEquals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">trait NotEquals: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}
</code></pre></pre>
</li>
<li>
<p>Provide a blanket implementation of <code>NotEquals</code> for <code>Equals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">trait NotEquals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool;
}

impl&lt;T&gt; NotEquals for T where T: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}
</code></pre></pre>
<ul>
<li>With the blanket implementation, you no longer need <code>Equals</code> as a super trait for <code>NotEqual</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#特征边界" id="特征边界">特征边界</a></h1>
<p>使用泛型时，您通常会想要利用类型来实现某些特性， 这样才能调用此特征的方法。</p>
<p>您可以使用 <code>T: Trait</code> 或 <code>impl Trait</code> 执行此操作：</p>
<pre><pre class="playground"><code class="language-rust editable">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

// struct NotClonable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);

    let many = add_42_millions(42_i8);
    println!(&quot;{many}&quot;);
    let many_more = add_42_millions(10_000_000);
    println!(&quot;{many_more}&quot;);
}
</code></pre></pre>
<details>
<p>显示 <code>where</code> 子句，学员在阅读代码时会看到它。</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>它会在您有多个形参的情况下整理函数签名。</li>
<li>它具有额外功能，因此也更强大。
<ul>
<li>如果有人提问，便阐明额外功能是指“:”左侧的类别可为任意值，例如 <code>Option&lt;T&gt;</code>。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>与特征边界类似，<code>impl Trait</code> 语法可以在函数实参 和返回值中使用：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Display;

fn get_x(name: impl Display) -&gt; impl Display {
    format!(&quot;Hello {name}&quot;)
}

fn main() {
    let x = get_x(&quot;foo&quot;);
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<ul>
<li><code>impl Trait</code> 让您可使用无法命名的类型。</li>
</ul>
<details>
<p><code>impl Trait</code> 的意义因使用位置而略有不同。</p>
<ul>
<li>
<p>对形参来说，<code>impl Trait</code> 就像是具有特征边界的匿名泛型形参。</p>
</li>
<li>
<p>对返回值类型来说，它则意味着返回值类型就是实现该特征的某具体类型， 无需为该类型命名。如果您不想在公共 API 中公开该具体类型，便可 使用此方法。</p>
<p>在返回位置处进行推断有一定难度。会返回 <code>impl Foo</code> 的函数会挑选 自身返回的具体类型，而不必在来源中写出此信息。会返回 泛型类型（例如 <code>collect&lt;B&gt;() -&gt; B</code>）的函数则可返回符合 <code>B</code> 的任何类型，而调用方可能需要选择一个类型，例如使用 <code>let x: Vec&lt;_&gt; = foo.collect()</code> 或使用以下 Turbofish：<code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>。</p>
</li>
</ul>
<p>这是一个非常棒的示例，因为它使用了两次 <code>impl Display</code>。这有助于说明 此处没有任何项目会强制使用相同的 <code>impl Display</code> 类型。如果我们使用单个 <code>T: Display</code>，它会强制限制输入 <code>T</code> 和返回 <code>T</code> 均为同一类型。 这并不适用于这个特定函数，因为我们预期作为输入的类型可能 不会是 <code>format!</code> 返回的值。如果我们希望通过 <code>: Display</code> 语法执行相同的操作，则需要两个 独立的泛型形参。</p>
</details><h1><a class="header" href="#重要特征" id="重要特征">重要特征</a></h1>
<p>现在，我们来看看 Rust 标准库的一些最常见的特征：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> 和 <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> 用于 <code>for</code> 循环中，</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 用于转换值，</li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> 用于实现 IO。</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>、<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a> 等用于实现运算符重载，</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> 用于定义析构函数。</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> 用于构建相应类型的默认实例。</li>
</ul>
<h1><a class="header" href="#迭代器" id="迭代器">迭代器</a></h1>
<p>您可以自行实现 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> 特征：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Iterator</code> 特征会对集合实现许多常见的函数程序操作， 例如 <code> map</code>filter `<code>和</code>reduce` 等。您可以通过此特征找到有关它们的所有 文档。在 Rust 中，这些函数应生成代码，且生成的代码应与等效命令式实现一样 高效。</p>
</li>
<li>
<p><code>IntoIterator</code> 是迫使 for 循环运作的特征。此特征由集合类型 （例如 <code>Vec&lt;T&gt;</code>）和相关引用（例如 <code>&amp;Vec&lt;T&gt;</code> 和 <code>&amp;[T]</code>）而实现。此外，范围也会实现这项特征。因此， 您可以使用 <code>for i in some_vec { .. }</code> 来遍历某矢量，但 <code>some_vec.next()</code> 不存在。</p>
</li>
</ul>
</details><h1><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> 让您可通过 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> 构建一个集合。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes
        .into_iter()
        .map(|prime| prime * prime)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;prime_squares: {prime_squares:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>Iterator</code> 会实现 <code>fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt;, Self: Sized</code></p>
<p>还有一些实现，让您可执行一些很酷的操作，比如 将 <code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> 转换成 <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>。</p>
</details><h1><a class="header" href="#from-和-into" id="from-和-into"><code>From</code> 和 <code>Into</code></a></h1>
<p>类型会实现 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> 以加快类型转换：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p>实现 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 后，系统会自动实现 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>这就是为什么通常只需实现 <code>From</code>，因为您的类型也会实现 <code>Into</code>。</li>
<li>若要声明某个函数实参输入类型（例如“任何可转换成 <code>String</code> 的类型”），规则便会相反，此时应使用 <code>Into</code>。 您的函数会接受可实现 <code>From</code> 的类型，以及那些仅实现 <code>Into</code> 的类型。</li>
</ul>
</details><h1><a class="header" href="#read-和-write" id="read-和-write"><code>Read</code> 和 <code>Write</code></a></h1>
<p>您可以使用 <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> 对 <code>u8</code> 来源进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>您同样可使用 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> 对 <code>u8</code> 接收器进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {:?}&quot;, buffer);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#drop-特征" id="drop-特征"><code>Drop</code> 特征</a></h1>
<p>用于实现 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> 的值可以指定在超出范围时运行的代码：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Note that <code>std::mem::drop</code> is not the same as <code>std::ops::Drop::drop</code>.</li>
<li>Values are automatically dropped when they go out of scope.</li>
<li>When a value is dropped, if it implements <code>std::ops::Drop</code> then its <code>Drop::drop</code> implementation will be called.</li>
<li>All its fields will then be dropped too, whether or not it implements <code>Drop</code>.</li>
<li><code>std::mem::drop</code> is just an empty function that takes any value. The significance is that it takes ownership of the value, so at the end of its scope it gets dropped. This makes it a convenient way to explicitly drop values earlier than they would otherwise go out of scope.
<ul>
<li>This can be useful for objects that do some work on <code>drop</code>: releasing locks, closing files, etc.</li>
</ul>
</li>
</ul>
<p>讨论点：</p>
<ul>
<li>为什么 <code>Drop::drop</code> 不使用 <code>self</code>？
<ul>
<li>简答：如果这样的话，系统会在代码块结尾 调用 <code>std::mem::drop</code>，进而引发再一次调用 <code>Drop::drop</code>，并引发堆栈 溢出！</li>
</ul>
</li>
<li>尝试用 <code>a.drop()</code> 替换 <code>drop(a)</code>。</li>
</ul>
</details><h1><a class="header" href="#default-特征" id="default-特征"><code>Default</code> 特征</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> 特征会为类型生成默认值。</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self(&quot;John Smith&quot;.into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!(&quot;{default_struct:#?}&quot;);

    let almost_default_struct = Derived {
        y: &quot;Y is set!&quot;.into(),
        ..Derived::default()
    };
    println!(&quot;{almost_default_struct:#?}&quot;);

    let nothing: Option&lt;Derived&gt; = None;
    println!(&quot;{:#?}&quot;, nothing.unwrap_or_default());
}

</code></pre></pre>
<details>
<ul>
<li>系统可以直接实现它，也可以通过 <code>#[derive(Default)]</code> 派生出它。</li>
<li>A derived implementation will produce a value where all fields are set to their default values.
<ul>
<li>这意味着，该结构体中的所有类型也都必须实现 <code>Default</code>。</li>
</ul>
</li>
<li>标准的 Rust 类型通常会以合理的值（例如 <code> 0</code>“” `<code>等）实现</code>Default`。</li>
<li>部分结构体副本可与默认值完美搭配运作。</li>
<li>Rust 标准库了解类型可能会实现 <code>Default</code>，因此提供了便利的使用方式。</li>
<li>the <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a></li>
</ul>
</details><h1><a class="header" href="#addmul-" id="addmul-"><code> Add</code>Mul ``…</a></h1>
<p>运算符重载是通过 <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> 中的特征实现的：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Copy, Clone)]
struct Point { x: i32, y: i32 }

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {x: self.x + other.x, y: self.y + other.y}
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{:?} + {:?} = {:?}&quot;, p1, p2, p1 + p2);
}
</code></pre></pre>
<details>
<p>讨论点：</p>
<ul>
<li>您可以针对 <code>&amp;Point</code> 实现 <code>Add</code>。此做法在哪些情况下可派上用场？
<ul>
<li>回答：<code>Add:add</code> 会耗用 <code>self</code>。如果您的运算符重载对象 （即类型 <code>T</code>）不是 <code>Copy</code>，建议您也为 <code>&amp;T</code> 重载运算符。这可避免调用点上存在不必要的 克隆任务。</li>
</ul>
</li>
<li>为什么 <code>Output</code> 是关联类型？可将它用作该方法的类型形参吗？
<ul>
<li>简答：函数类型形参是由调用方控管，但 <code>Output</code> 这类关联类型则由特征实现人员 控管。</li>
</ul>
</li>
<li>您可以针对两种不同类型实现 <code>Add</code>，例如， <code>impl Add&lt;(i32, i32)&gt; for Point</code> 会向 <code>Point</code> 中添加元组。</li>
</ul>
</details><h1><a class="header" href="#闭包" id="闭包">闭包</a></h1>
<p>闭包或 lambda 表达式具有无法命名的类型。不过，它们会 实现特殊的 <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>， <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 特征：</p>
<pre><pre class="playground"><code class="language-rust editable">fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {
    println!(&quot;Calling function on {input}&quot;);
    func(input)
}

fn main() {
    let add_3 = |x| x + 3;
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 10));
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 20));

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 4));
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 5));

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    println!(&quot;multiply_sum: {}&quot;, apply_with_log(multiply_sum, 3));
}
</code></pre></pre>
<details>
<p><code>Fn</code>（例如 <code>add_3</code>）既不会耗用也不会修改捕获的值，或许 也不会捕获任何值。它可被并发调用多次。</p>
<p><code>FnMut</code>（例如 <code>accumulate</code>）可能会改变捕获的值。您可以多次调用它， 但不能并发调用它。</p>
<p>如果您使用 <code>FnOnce</code>（例如 <code>multiply_sum</code>），或许只能调用它一次。它可能会耗用 所捕获的值。</p>
<p><code>FnMut</code> 是 <code>FnOnce</code> 的子类型。<code>Fn</code> 是 <code>FnMut</code> 和 <code>FnOnce</code> 的子类型。也就是说，您可以在任何 需要调用 <code>FnOnce</code> 的地方使用 <code>FnMut</code>，还可在任何需要调用 <code>FnMut</code> 或 <code>FnOnce</code> 的地方 使用 <code>Fn</code>。</p>
<p>编译器也会推断 <code>Copy</code>（例如针对 <code>add_3</code>）和 <code>Clone</code>（例如 <code>multiply_sum</code>）， 具体取决于闭包捕获的数据。</p>
<p>默认情况下，闭包会依据引用来捕获数据（如果可以的话）。<code>move</code> 关键字则可让闭包依据值 来捕获数据。</p>
<pre><pre class="playground"><code class="language-rust editable">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!(&quot;{} {}&quot;, prefix, name)
}

fn main() {
    let hi = make_greeter(&quot;Hi&quot;.to_string());
    hi(&quot;there&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#day-3-morning-exercises" id="day-3-morning-exercises">Day 3: Morning Exercises</a></h1>
<p>We will design a classical GUI library using traits and trait objects.</p>
<p>We will also look at enum dispatch with an exercise involving points and polygons.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-3/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#drawing-a-simple-gui" id="drawing-a-simple-gui">Drawing A Simple GUI</a></h1>
<p>Let us design a classical GUI library using our new knowledge of traits and trait objects. We’ll only implement the drawing of it (as text) for simplicity.</p>
<p>We will have a number of widgets in our library:</p>
<ul>
<li><code>Window</code>: has a <code>title</code> and contains other widgets.</li>
<li><code>Button</code>: has a <code>label</code>. In reality, it would also take a callback function to allow the program to do something when the button is clicked but we won’t include that since we’re only drawing the GUI.</li>
<li><code>Label</code>: has a <code>label</code>.</li>
</ul>
<p>The widgets will implement a <code>Widget</code> trait, see below.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>, fill in the missing <code>draw_into</code> methods so that you implement the <code>Widget</code> trait:</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button {
            label: Label::new(label),
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;
    )));
    window.draw();
}
</code></pre></pre>
<p>The output of the above program can be something simple like this:</p>
<pre><code class="language-text">========
Rust GUI Demo 1.23
========

This is a small text GUI demo.

| Click me! |
</code></pre>
<p>If you want to draw aligned text, you can use the <a href="https://doc.rust-lang.org/std/fmt/index.html#fillalignment">fill/alignment</a> formatting operators. In particular, notice how you can pad with different characters (here a <code>'/'</code>) and how you can control alignment:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let width = 10;
    println!(&quot;left aligned:  |{:/&lt;width$}|&quot;, &quot;foo&quot;);
    println!(&quot;centered:      |{:/^width$}|&quot;, &quot;foo&quot;);
    println!(&quot;right aligned: |{:/&gt;width$}|&quot;, &quot;foo&quot;);
}
</code></pre></pre>
<p>Using such alignment tricks, you can for example produce output like this:</p>
<pre><code class="language-text">+--------------------------------+
|       Rust GUI Demo 1.23       |
+================================+
| This is a small text GUI demo. |
| +-----------+                  |
| | Click me! |                  |
| +-----------+                  |
+--------------------------------+
</code></pre>
<h1><a class="header" href="#polygon-struct" id="polygon-struct">Polygon Struct</a></h1>
<p>We will create a <code>Polygon</code> struct which contain some points. Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing methods to make the tests pass:</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct Point {
    // add fields
}

impl Point {
    // add methods
}

pub struct Polygon {
    // add fields
}

impl Polygon {
    // add methods
}

pub struct Circle {
    // add fields
}

impl Circle {
    // add methods
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<details>
<p>Since the method signatures are missing from the problem statements, the key part of the exercise is to specify those correctly. You don’t have to modify the tests.</p>
<p>Other interesting parts of the exercise:</p>
<ul>
<li>Derive a <code>Copy</code> trait for some structs, as in tests the methods sometimes don’t borrow their arguments.</li>
<li>Discover that <code>Add</code> trait must be implemented for two objects to be addable via “+”. Note that we do not discuss generics until Day 3.</li>
</ul>
</details><h1><a class="header" href="#错误处理" id="错误处理">错误处理</a></h1>
<p>Rust 中的错误处理是使用显式控制流来进行的：</p>
<ul>
<li>包含错误的函数会在返回类型中列出相关信息。</li>
<li>此规则没有例外。</li>
</ul>
<h1><a class="header" href="#panics" id="panics">Panics</a></h1>
<p>如果运行时发生严重错误，Rust 会触发 panic：</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panic 用于指示不可恢复的意外错误。
<ul>
<li>Panic反映了程序中的 bug 问题。</li>
</ul>
</li>
<li>如果崩溃不可接受，请使用不会触发 panic 的 API（例如 <code>Vec::get</code>）。</li>
</ul>
<h1><a class="header" href="#捕获堆栈展开" id="捕获堆栈展开">捕获堆栈展开</a></h1>
<p>默认情况下，panic 会导致堆栈展开。您可以捕获展开信息：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
}
</code></pre></pre>
<ul>
<li>如果服务器需要持续运行（即使是在请求发生崩溃的情况下）， 此方法十分有用。</li>
<li>如果您在 <code>Cargo.toml</code> 中设置了 <code>panic = 'abort'</code>，此方法不会生效。</li>
</ul>
<h1><a class="header" href="#使用-result-进行结构化错误处理" id="使用-result-进行结构化错误处理">使用 <code>Result</code> 进行结构化错误处理</a></h1>
<p>在前面，我们看到了 <code>Result</code> 枚举。在遇到正常操作产生的预期错误时， 我们常会用到此方法：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs;
use std::io::Read;

fn main() {
    let file = fs::File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            file.read_to_string(&amp;mut contents);
            println!(&quot;Dear diary: {contents}&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>与 <code>Option</code> 方法相同，成功值位于 <code>Result</code> 方法内部， 开发者必须显示提取成功值。因此，建议进行错误检查。在绝不应出现错误的情况下， 可以调用 <code>unwrap()</code> 或 <code>expect()</code> 方法，这也是一种开发者意向信号。</li>
<li>我们建议阅读 <code>Result</code> 文档。虽然课程中不会涉及该文档，但是有必要提到它。 该文档中包含许多便捷的方法和函数，对于函数式编程很有帮助。</li>
</ul>
</details><h1><a class="header" href="#使用--传播错误" id="使用--传播错误">使用 <code>?</code> 传播错误</a></h1>
<p>try 操作符 <code>?</code> 用于将错误返回给调用方。它能把常用命令</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>转换成更简单的命令</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::{fs, io};
use std::io::Read;

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li><code>username</code> 变量可以是 <code>Ok(string)</code> 或 <code>Err(error)</code>。</li>
<li>可以使用 <code>fs::write</code> 调用来测试不同的场景：没有文件、空文件、包含用户名的文件。</li>
<li>The return type of the function has to be compatible with the nested functions it calls. For instance, a function returning a <code>Result&lt;T, Err&gt;</code> can only apply the <code>?</code> operator on a function returning a  <code>Result&lt;AnyT, Err&gt;</code>. It cannot apply the <code>?</code> operator on a function returning an <code>Option&lt;AnyT&gt;</code> or <code>Result&lt;T, OtherErr&gt;</code> unless <code>OtherErr</code> implements <code>From&lt;Err&gt;</code>. Reciprocally, a function returning an <code>Option&lt;T&gt;</code> can only apply the <code>?</code> operator  on a function returning an <code>Option&lt;AnyT&gt;</code>.
<ul>
<li>You can convert incompatible types into one another with the different <code>Option</code> and <code>Result</code> methods  such as <code>Option::ok_or</code>, <code>Result::ok</code>, <code>Result::err</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#转换错误类型" id="转换错误类型">转换错误类型</a></h1>
<p><code>?</code> 的有效展开比前面介绍的内容略微复杂一些：</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>效果等同于</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>此处的 <code>From::from</code> 调用表示，我们尝试将错误类型转换为 函数返回的类型：</p>
<h1><a class="header" href="#转换错误类型-1" id="转换错误类型-1">转换错误类型</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, File};
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;IO error: {e}&quot;),
            Self::EmptyUsername(filename) =&gt; write!(f, &quot;Found no username in {filename}&quot;),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; ReadUsernameError {
        ReadUsernameError::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li><code>username</code> 变量可以是 <code>Ok(string)</code> 或 <code>Err(error)</code>。</li>
<li>可以使用 <code>fs::write</code> 调用来测试不同的场景：没有文件、空文件、包含用户名的文件。</li>
</ul>
<p>It is good practice for all error types that don’t need to be <code>no_std</code> to implement <code>std::error::Error</code>, which requires <code>Debug</code> and <code>Display</code>. The <code>Error</code> crate for <code>core</code> is only available in <a href="https://github.com/rust-lang/rust/issues/103765">nightly</a>, so not fully <code>no_std</code> compatible yet.</p>
<p>It’s generally helpful for them to implement <code>Clone</code> and <code>Eq</code> too where possible, to make life easier for tests and consumers of your library. In this case we can’t easily do so, because <code>io::Error</code> doesn’t implement them.</p>
</details><h1><a class="header" href="#派生错误枚举" id="派生错误枚举">派生错误枚举</a></h1>
<p><a href="https://docs.rs/thiserror/">thiserror</a> crate 是创建错误枚举的常用方法， 就像前一页中提供的示例一样：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::{fs, io};
use std::io::Read;
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;Could not read: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><code>thiserror</code> 的派生宏会自动实现 <code>std::error::Error</code>，并且可以选择性地实现 <code>Display</code> （如果提供了 <code>#[error(...)]</code> 属性）和 <code>From</code>（如果添加了 <code>#[from]</code> 属性）。 此规则也适用于结构体。</p>
<p>但是，此规则不会影响公共 API，对于库而言，这非常理想。</p>
</details><h1><a class="header" href="#动态错误类型" id="动态错误类型">动态错误类型</a></h1>
<p>有时，我们需要允许返回任意类型的错误，但又不想自己手动编写枚举来涵盖所有不同的可能性。 <code>std::error::Error</code> 可以让我们轻松做到这一点。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::fs;
use std::io::Read;
use thiserror::Error;
use std::error::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(EmptyUsernameError(String::from(path)).into());
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p>虽然这可以省却编写代码的麻烦，但也会导致我们无法在程序中以不同的方式正常处理不同的 错误情况。因此，在库的公共 API 中使用 <code>Box&lt;dyn Error&gt;</code> 通常不是一个好主意。 但是对于您只需要在某处显示错误消息的程序来说，这不失为一个 很好的选择。</p>
</details><h1><a class="header" href="#为错误添加背景信息" id="为错误添加背景信息">为错误添加背景信息</a></h1>
<p>广泛使用的 <a href="https://docs.rs/anyhow/">anyhow</a> crate 可以帮助我们为错误添加 背景信息，并减少自定义错误类型的 数量。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::{fs, io};
use std::io::Read;
use anyhow::{Context, Result, bail};

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(&quot;Found no username in {path}&quot;);
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it’s again generally not a good choice for the public API of a library, but is widely used in applications.</li>
<li>Actual error type inside of it can be extracted for examination if necessary.</li>
<li>Functionality provided by <code>anyhow::Result&lt;T&gt;</code> may be familiar to Go developers, as it provides similar usage patterns and ergonomics to <code>(T, error)</code> from Go.</li>
</ul>
</details><h1><a class="header" href="#测试" id="测试">测试</a></h1>
<p>Rust 和 Cargo 随附了一个简单的单元测试框架：</p>
<ul>
<li>
<p>单元测试在您的整个代码中都受支持。</p>
</li>
<li>
<p>您可以通过 <code>tests/</code> 目录来支持集成测试。</p>
</li>
</ul>
<h1><a class="header" href="#单元测试" id="单元测试">单元测试</a></h1>
<p>使用 <code>#[test]</code> 标记单元测试：</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[test]
fn test_empty() {
    assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
}

#[test]
fn test_single_word() {
    assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
}
</code></pre>
<p>使用 <code>cargo test</code> 查找并运行单元测试。</p>
<h1><a class="header" href="#测试模块" id="测试模块">测试模块</a></h1>
<p>单元测试通常会放在嵌套模块中（在 <a href="https://play.rust-lang.org/">Playground</a> 上运行测试）：</p>
<pre><pre class="playground"><code class="language-rust editable">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}
</code></pre></pre>
<ul>
<li>这样一来，您可以对专用帮助程序进行单元测试。</li>
<li>仅当您运行 <code>cargo test</code> 时，<code>#[cfg(test)]</code> 属性才有效。</li>
</ul>
<h1><a class="header" href="#文档测试" id="文档测试">文档测试</a></h1>
<p>Rust 本身就支持文档测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>///</code> 注释中的代码块会自动被视为 Rust 代码。</li>
<li>代码会作为 <code>cargo test</code> 的一部分进行编译和执行。</li>
<li>Adding <code># </code> in the code will hide it from the docs, but will still compile/run it.</li>
<li>在 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a> 上测试上述代码。</li>
</ul>
<h1><a class="header" href="#集成测试" id="集成测试">集成测试</a></h1>
<p>如果您想要以客户的身份测试您的库，请使用集成测试。</p>
<p>在 <code>tests/</code> 下方创建一个 <code>.rs</code> 文件：</p>
<pre><code class="language-rust ignore">use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>这些测试只能使用您的 crate 的公共 API。</p>
<h2><a class="header" href="#用于编写测试的实用-crate" id="用于编写测试的实用-crate">用于编写测试的实用 crate</a></h2>
<p>Rust 仅为编写测试提供基本支持。</p>
<p>下面列出了我们建议在编写测试时使用的一些其他 crate：</p>
<ul>
<li><a href="https://docs.rs/googletest">googletest</a>：遵从 GoogleTest for C++ 传统的综合测试断言库。</li>
<li><a href="https://docs.rs/proptest">proptest</a>：基于属性的测试，适用于 Rust。</li>
<li><a href="https://docs.rs/rstest">rstest</a>：支持固件和参数化测试。</li>
</ul>
<h1><a class="header" href="#不安全-rust" id="不安全-rust">不安全 Rust</a></h1>
<p>Rust 语言包含两个部分：</p>
<ul>
<li>**安全 Rust：**内存安全，没有潜在的未定义行为。</li>
<li>**不安全 Rust：**如果违反了前提条件，可能会触发未定义的行为。</li>
</ul>
<p>本课程中出现的大多为“安全 Rust”，但是了解“不安全 Rust”的定义 非常重要。</p>
<p>不安全的代码通常内容很少而且与其他代码隔离， 其正确性也应得到仔细记录。这类代码通常封装在安全的抽象层中。</p>
<p>不安全 Rust 提供了五种新功能：</p>
<ul>
<li>解引用原始指针。</li>
<li>访问或修改可变的静态变量。</li>
<li>访问 <code>union</code> 字段。</li>
<li>调用 <code>unsafe</code> 函数，包括 <code>extern</code> 函数。</li>
<li>实现 <code>unsafe</code> trait。</li>
</ul>
<p>下面，我们将简要介绍这些不安全功能。如需了解完整详情，请参阅 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">《Rust 手册》第 19.1 章</a> 和 <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>。</p>
<details>
<p>不安全 Rust 并不意味着代码不正确，而是这意味着开发者已停用 编译器的安全功能，必须自行编写正确的 代码。也就是说，编译器不再强制执行 Rust 的内存安全规则。</p>
</details><h1><a class="header" href="#解引用裸指针" id="解引用裸指针">解引用裸指针</a></h1>
<p>创建指针是安全的操作，但解引用指针需要使用 <code>unsafe</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut num = 5;

    let r1 = &amp;mut num as *mut i32;
    let r2 = r1 as *const i32;

    // Safe because r1 and r2 were obtained from references and so are
    // guaranteed to be non-null and properly aligned, the objects underlying
    // the references from which they were obtained are live throughout the
    // whole unsafe block, and they are not accessed either through the
    // references or concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = 10;
        println!(&quot;r2 is: {}&quot;, *r2);
    }
}
</code></pre></pre>
<details>
<p>我们建议（而且 Android Rust 样式指南要求）为每个 <code>unsafe</code> 代码块编写一条注释， 说明该代码块中的代码如何满足其所执行的不安全操作的 安全要求。</p>
<p>对于指针解除引用，这意味着指针必须为 <a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>，即：</p>
<ul>
<li>指针必须为非 null。</li>
<li>指针必须是 <em>dereferenceable</em>（在单个已分配对象的边界内）。</li>
<li>对象不得已取消分配。</li>
<li>不得并发访问相同位置。</li>
<li>如果通过转换引用类型来获取指针，则底层对象必须处于活跃状态， 而且不得使用任何引用来访问内存。</li>
</ul>
<p>在大多数情况下，指针还必须正确对齐。</p>
</details><h1><a class="header" href="#可变的静态变量" id="可变的静态变量">可变的静态变量</a></h1>
<p>读取不可变的静态变量是安全的操作：</p>
<pre><pre class="playground"><code class="language-rust editable">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {HELLO_WORLD}&quot;);
}
</code></pre></pre>
<p>但是，读取和写入可变的静态变量是不安全的，因为这可能会 造成数据争用：</p>
<pre><pre class="playground"><code class="language-rust editable">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    unsafe { COUNTER += inc; }  // Potential data race!
}

fn main() {
    add_to_counter(42);

    unsafe { println!(&quot;COUNTER: {COUNTER}&quot;); }  // Potential data race!
}
</code></pre></pre>
<details>
<p>通常，我们不建议使用可变的静态变量，但在某些情况下，在低层级 <code>no_std</code> 代码中可能需要这样做， 例如实现堆分配器或使用某些 C API。</p>
</details><h1><a class="header" href="#联合体" id="联合体">联合体</a></h1>
<p>联合体与枚举类似，但您需要自行跟踪活跃字段：</p>
<pre><pre class="playground"><code class="language-rust editable">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b });  // Undefined behavior!
}
</code></pre></pre>
<details>
<p>在 Rust 中很少需要用到联合体，因为您通常可以使用枚举。联合体只是偶尔用于 与 C 库 API 进行交互。</p>
<p>如果您只是想将字节重新解释为其他类型，则可能需要使用 <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> 或 安全的封装容器，例如 <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crate。</p>
</details><h1><a class="header" href="#调用-unsafe-函数" id="调用-unsafe-函数">调用 Unsafe 函数</a></h1>
<p>如果函数或方法具有额外的前提条件，您必须遵守这些前提条件来避免未定义的行为， 则可以将该函数或方法标记为 <code>unsafe</code>：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let emojis = &quot;🗻∈🌏&quot;;

    // Safe because the indices are in the correct order, within the bounds of
    // the string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(7..11));
    }

    println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!(&quot;emoji: {}&quot;, unsafe { emojis.get_unchecked(0..3) });
    // println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().map(|_| 1).sum()
}
</code></pre></pre>
<h1><a class="header" href="#编写-unsafe-函数" id="编写-unsafe-函数">编写 Unsafe 函数</a></h1>
<p>如果您自己编写的函数需要满足特定条件以避免未定义的行为， 您可以将这些函数标记为 <code>unsafe</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // Safe because ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<p>实际上，我们不会这样使用指针，因为使用引用可以安全地达到相同的目的。</p>
<p>请注意，在不安全函数中，可以在没有 <code>unsafe</code> 代码块的情况下使用不安全代码。我们可以 使用 <code>#[deny(unsafe_op_in_unsafe_fn)]</code> 来禁止此行为。请尝试添加该命令，看看会出现什么情况。</p>
</details><h1><a class="header" href="#调用外部代码" id="调用外部代码">调用外部代码</a></h1>
<p>基于其他语言的函数可能会违反 Rust 的保证。因此， 调用这类函数是不安全的：</p>
<pre><pre class="playground"><code class="language-rust editable">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // Undefined behavior if abs misbehaves.
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<details>
<p>这个问题通常仅存在于使用指针执行违反 Rust 内存模型的操作的外部函数中。 但一般而言，任何 C 函数都有可能在任意情况下出现未定义行为。</p>
<p>The <code>&quot;C&quot;</code> in this example is the ABI; <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">other ABIs are available too</a>.</p>
</details><h1><a class="header" href="#实现-unsafe-trait" id="实现-unsafe-trait">实现 Unsafe Trait</a></h1>
<p>与函数一样，如果您在实现某个 trait 时必须保证特定条件来避免未定义的行为， 您也可以将该 trait 标记为 <code>unsafe</code>。</p>
<p>例如，<code>zerocopy</code> crate 包含一个不安全的 trait， <a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">大致内容是这样的</a>：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))
        }
    }
}

// Safe because u32 has a defined representation and no padding.
unsafe impl AsBytes for u32 {}
</code></pre></pre>
<details>
<p>在 Rustdoc 中有关 trait 的章节下，有一个标题为 <code># 安全</code> 的部分介绍了 安全实现 trait 的要求。</p>
<p>实际上，与 <code>AsBytes</code> 相关的安全说明远比这里展示的更详尽、更复杂。</p>
<p>内置的 <code>Send</code> 和 <code>Sync</code> trait 都是不安全的。</p>
</details><h1><a class="header" href="#day-3-afternoon-exercises" id="day-3-afternoon-exercises">Day 3: Afternoon Exercises</a></h1>
<p>Let us build a safe wrapper for reading directory content!</p>
<p>For this exercise, we suggest using a local dev environment instead of the Playground. This will allow you to run your binary on your own machine.</p>
<p>To get started, follow the <a href="exercises/day-3/../../cargo/running-locally.html">running locally</a> instructions.</p>
<details>
<p>After looking at the exercise, you can look at the <a href="exercises/day-3/solutions-afternoon.html">solution</a> provided.</p>
</details><h1><a class="header" href="#安全-ffi-封装容器" id="安全-ffi-封装容器">安全 FFI 封装容器</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code> functions you would use from C to read the names of files in a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module. There you find a number of string types which you need for the exercise:</p>
<table><thead><tr><th>类型</th><th>Encoding</th><th>Use</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td><td>UTF-8</td><td>Text processing in Rust</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></td><td>NUL-terminated</td><td>Communicating with C functions</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></td><td>OS-specific</td><td>Communicating with the OS</td></tr>
</tbody></table>
<p>You will convert between all these types:</p>
<ul>
<li><code>&amp;str</code> to <code>CString</code>: you need to allocate space for a trailing <code>\0</code> character,</li>
<li><code>CString</code> to <code>*const i8</code>: you need a pointer to call C functions,</li>
<li><code>*const i8</code> to <code>&amp;CStr</code>: you need something which can find the trailing <code>\0</code> character,</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for “some unknow data”,</li>
<li><code>&amp;[u8]</code> to <code>&amp;OsStr</code>: <code>&amp;OsStr</code> is a step towards <code>OsString</code>, use <a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a> to create it,</li>
<li><code>&amp;OsStr</code> to <code>OsString</code>: you need to clone the data in <code>&amp;OsStr</code> to be able to return it and call <code>readdir</code> again.</li>
</ul>
<p>The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#欢迎来到android-中的rust" id="欢迎来到android-中的rust">欢迎来到Android 中的Rust</a></h1>
<p>Rust 支持Android 的原生平台开发。这意味着您可以在Rust 中编写新的操作系统服务，以及扩展现有服务。</p>
<blockquote>
<p>今天我们会尝试在你自己的项目中调用Rust。 所以试着在你的代码中找一小段来改成Rust。 代码中越少依赖(dependencies)，越少“独特”的类型，越好。比如 一段解析原始字符的代码就很理想。</p>
</blockquote>
<h1><a class="header" href="#设置" id="设置">设置</a></h1>
<p>我们将会使用Android 虚拟设备（Android Virtual Device）来测试我们的代码。 确保你有权限访问一个，或者用以下命令创建一个新的：</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-userdebug
acloud create
</code></pre>
<p>更多细节请参考 <a href="https://source.android.com/docs/setup/start">Android Developer Codelab</a>.</p>
<h1><a class="header" href="#构建规则" id="构建规则">构建规则</a></h1>
<p>Android 构建系统（Soong）通过一系列模块来支持Rust：</p>
<table><thead><tr><th>Module Type</th><th>描述</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>生成一个Rust二进制文件。</td></tr>
<tr><td><code>rust_library</code></td><td>生成一个 Rust 库，并提供 <code>rlib</code> 和 <code>dylib</code> 两种变体。</td></tr>
<tr><td><code>rust_ffi</code></td><td>生成一个可由 <code>cc</code> 模块使用的 Rust C 库，并提供静态和共享两种变体。</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>Produces a <code>proc-macro</code> Rust library. These are analogous to compiler plugins.</td></tr>
<tr><td><code>rust_test</code></td><td>生成使用标准 Rust 测试框架的 Rust 测试二进制文件。</td></tr>
<tr><td><code>rust_fuzz</code></td><td>Produces a Rust fuzz binary leveraging <code>libfuzzer</code>.</td></tr>
<tr><td><code>rust_protobuf</code></td><td>生成源代码并生成为特定 protobuf 提供接口的 Rust 库。</td></tr>
<tr><td><code>rust_bindgen</code></td><td>生成源代码并生成包含 Rust 绑定到 C 库的 Rust 库。</td></tr>
</tbody></table>
<p>下面我们来看看 <code>rust_binary</code> 和 <code>rust_library</code>。</p>
<h1><a class="header" href="#rust-二进制文件-1" id="rust-二进制文件-1">Rust 二进制文件</a></h1>
<p>让我们从一个简单的应用程序开始。在 AOSP 签出的根目录下，创建以下文件：</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust&quot;,
    crate_name: &quot;hello_rust&quot;,
    srcs: [&quot;src/main.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;Hello from Rust!&quot;);
}
</code></pre></pre>
<p>你现在可以构建、推送和运行二进制文件：</p>
<pre><code class="language-shell">m hello_rust
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<h1><a class="header" href="#rust-库" id="rust-库">Rust 库</a></h1>
<p>您可以使用 <code>rust_library</code> 为 Android 创建一个新的 Rust 库。</p>
<p>在这里，我们声明了对两个库的依赖：</p>
<ul>
<li><code>libgreeting</code>, 我们在下面进行了定义，</li>
<li><code>libtextwrap</code>, 一个已经在 <a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a> 中提供的 crate。</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_with_dep&quot;,
    crate_name: &quot;hello_rust_with_dep&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libgreetings&quot;,
        &quot;libtextwrap&quot;,
    ],
    prefer_rlib: true,
}

rust_library {
    name: &quot;libgreetings&quot;,
    crate_name: &quot;greetings&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;{}&quot;, fill(&amp;greeting(&quot;Bob&quot;), 24));
}
</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}, it is very nice to meet you!&quot;)
}
</code></pre>
<p>您可以像之前一样构建、推送和运行二进制文件：</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<h1><a class="header" href="#aidl" id="aidl">AIDL</a></h1>
<p>Rust 支持 <a href="https://developer.android.com/guide/components/aidl">Android 接口定义语言 (AIDL)</a>：</p>
<ul>
<li>Rust 代码可以调用现有的 AIDL 服务器，</li>
<li>您可以在 Rust 中创建新的 AIDL 服务器。</li>
</ul>
<h1><a class="header" href="#aidl-接口" id="aidl-接口">AIDL 接口</a></h1>
<p>您可以使用 AIDL 接口声明您的服务的 API：</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: &quot;com.example.birthdayservice&quot;,
    srcs: [&quot;com/example/birthdayservice/*.aidl&quot;],
    unstable: true,
    backend: {
        rust: { // 默认情况下不启用 Rust 
            enabled: true,
        },
    },
}
</code></pre>
<p>如果供应商分区中的二进制文件使用了您的 AIDL 文件，请添加 <code>vendor_available: true</code>。</p>
<h1><a class="header" href="#服务实现" id="服务实现">服务实现</a></h1>
<p>我们现在可以实现AIDL服务：</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! 实现了 `IBirthdayService` AIDL 接口。
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// `IBirthdayService` 接口的具体实现。
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!(
            &quot;Happy Birthday {name}, congratulations with the {years} years!&quot;
        ))
    }
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libbirthdayservice&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    crate_name: &quot;birthdayservice&quot;,
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
}
</code></pre>
<h1><a class="header" href="#aidl-服务器" id="aidl-服务器">AIDL 服务器</a></h1>
<p>最后，我们可以创建一个暴露服务的服务器：</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! 生日服务。
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// 生日服务的入口。
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect(&quot;Failed to register service&quot;);
    binder::ProcessState::join_thread_pool()
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_server&quot;,
    crate_name: &quot;birthday_server&quot;,
    srcs: [&quot;src/server.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
        &quot;libbirthdayservice&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<h1><a class="header" href="#部署" id="部署">部署</a></h1>
<p>我们现在可以构建、推送和启动服务：</p>
<pre><code class="language-shell">m birthday_server
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>在另一个终端中，检查该服务是否正在运行：</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>您还可以使用 <code>service call</code> 命令调用该服务：</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<h1><a class="header" href="#aidl-客户端" id="aidl-客户端">AIDL 客户端</a></h1>
<p>最后，我们可以为我们的新服务创建一个 Rust 客户端。</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">//! 生日服务。
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// 连接到 BirthdayService。
pub fn connect() -&gt; Result&lt;binder::Strong&lt;dyn IBirthdayService&gt;, binder::StatusCode&gt; {
    binder::get_interface(SERVICE_IDENTIFIER)
}

/// 调用生日服务。
fn main() -&gt; Result&lt;(), binder::Status&gt; {
    let name = std::env::args()
        .nth(1)
        .unwrap_or_else(|| String::from(&quot;Bob&quot;));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!(&quot;{msg}&quot;);
    Ok(())
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_client&quot;,
    crate_name: &quot;birthday_client&quot;,
    srcs: [&quot;src/client.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<p>请注意，客户端不依赖于 <code>libbirthdayservice</code>。</p>
<p>在您的设备上构建、推送并运行客户端：</p>
<pre><code class="language-shell">m birthday_client
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<h1><a class="header" href="#更改-api" id="更改-api">更改 API</a></h1>
<p>让我们扩展API以提供更多功能：我们希望允许客户端指定生日贺卡的行列表：</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<h1><a class="header" href="#日志记录" id="日志记录">日志记录</a></h1>
<p>你应该使用 <code>log</code> crate 来自动记录日志到 <code>logcat</code> （设备上）或 <code>stdout</code>（主机上）：</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_logs&quot;,
    crate_name: &quot;hello_rust_logs&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;liblog_rust&quot;,
        &quot;liblogger&quot;,
    ],
    prefer_rlib: true,
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device(&quot;rust&quot;)
            .with_min_level(log::Level::Trace),
    );
    debug!(&quot;Starting program.&quot;);
    info!(&quot;Things are going fine.&quot;);
    error!(&quot;Something went wrong!&quot;);
}
</code></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m hello_rust_logs
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>日志将会在 <code>adb logcat</code> 中显示：</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<h1><a class="header" href="#互操作性" id="互操作性">互操作性</a></h1>
<p>Rust has excellent support for interoperability with other languages. This means that you can:</p>
<ul>
<li>Call Rust functions from other languages.</li>
<li>Call functions written in other languages from Rust.</li>
</ul>
<p>When you call functions in a foreign language we say that you’re using a <em>foreign function interface</em>, also known as FFI.</p>
<h1><a class="header" href="#interoperability-with-c" id="interoperability-with-c">Interoperability with C</a></h1>
<p>Rust has full support for linking object files with a C calling convention. Similarly, you can export Rust functions and call them from C.</p>
<p>You can do it by hand if you want:</p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    let abs_x = unsafe { abs(x) };
    println!(&quot;{x}, {abs_x}&quot;);
}
</code></pre></pre>
<p>We already saw this in the <a href="android/interoperability/../../exercises/day-3/safe-ffi-wrapper.html">Safe FFI Wrapper exercise</a>.</p>
<blockquote>
<p>This assumes full knowledge of the target platform. Not recommended for production.</p>
</blockquote>
<p>We will look at better options next.</p>
<h1><a class="header" href="#using-bindgen" id="using-bindgen">Using Bindgen</a></h1>
<p>The <a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> tool can auto-generate bindings from a C header file.</p>
<p>First create a small C library:</p>
<p><em>interoperability/bindgen/libbirthday.h</em>:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;libbirthday.h&quot;

void print_card(const card* card) {
  printf(&quot;+--------------\n&quot;);
  printf(&quot;| Happy Birthday %s!\n&quot;, card-&gt;name);
  printf(&quot;| Congratulations with the %i years!\n&quot;, card-&gt;years);
  printf(&quot;+--------------\n&quot;);
}
</code></pre>
<p>Add this to your <code>Android.bp</code> file:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: &quot;libbirthday&quot;,
    srcs: [&quot;libbirthday.c&quot;],
}
</code></pre>
<p>Create a wrapper header file for the library (not strictly needed in this example):</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include &quot;libbirthday.h&quot;
</code></pre>
<p>You can now auto-generate the bindings:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: &quot;libbirthday_bindgen&quot;,
    crate_name: &quot;birthday_bindgen&quot;,
    wrapper_src: &quot;libbirthday_wrapper.h&quot;,
    source_stem: &quot;bindings&quot;,
    static_libs: [&quot;libbirthday&quot;],
}
</code></pre>
<p>Finally, we can use the bindings in our Rust program:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;print_birthday_card&quot;,
    srcs: [&quot;main.rs&quot;],
    rustlibs: [&quot;libbirthday_bindgen&quot;],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new(&quot;Peter&quot;).unwrap();
    let card = card {
        name: name.as_ptr(),
        years: 42,
    };
    unsafe {
        print_card(&amp;card as *const card);
    }
}
</code></pre></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m print_birthday_card
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp&quot;
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>Finally, we can run auto-generated tests to ensure the bindings work:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: &quot;libbirthday_bindgen_test&quot;,
    srcs: [&quot;:libbirthday_bindgen&quot;],
    crate_name: &quot;libbirthday_bindgen_test&quot;,
    test_suites: [&quot;general-tests&quot;],
    auto_gen_config: true,
    clippy_lints: &quot;none&quot;, // Generated file, skip linting
    lints: &quot;none&quot;,
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<h1><a class="header" href="#calling-rust" id="calling-rust">Calling Rust</a></h1>
<p>Exporting Rust functions and types to C is easy:</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
#[no_mangle]
pub extern &quot;C&quot; fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!(&quot;x ({x}) is smallest!&quot;);
    } else {
        println!(&quot;y ({y}) is probably larger than x ({x})&quot;);
    }
}
</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

extern &quot;C&quot; {
void analyze_numbers(int x, int y);
}

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: &quot;libanalyze_ffi&quot;,
    crate_name: &quot;analyze_ffi&quot;,
    srcs: [&quot;analyze.rs&quot;],
    include_dirs: [&quot;.&quot;],
}
</code></pre>
<p>We can now call this from a C binary:</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include &quot;analyze.h&quot;

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: &quot;analyze_numbers&quot;,
    srcs: [&quot;main.c&quot;],
    static_libs: [&quot;libanalyze_ffi&quot;],
}
</code></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m analyze_numbers
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp&quot;
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[no_mangle]</code> disables Rust’s usual name mangling, so the exported symbol will just be the name of the function. You can also use <code>#[export_name = &quot;some_name&quot;]</code> to specify whatever name you want.</p>
</details><h1><a class="header" href="#与-c-交互" id="与-c-交互">与 C++ 交互</a></h1>
<p>The <a href="https://cxx.rs/">CXX crate</a> makes it possible to do safe interoperability between Rust and C++.</p>
<p>The overall approach looks like this:</p>
<img src="android/interoperability/cpp/overview.svg">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for an full example of using this.</p>
<details>
<ul>
<li>
<p>At this point, the instructor should switch to the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a>.</p>
</li>
<li>
<p>Walk the students through the tutorial step by step.</p>
</li>
<li>
<p>Highlight how CXX presents a clean interface without unsafe code in <em>both languages</em>.</p>
</li>
<li>
<p>Show the correspondence between <a href="https://cxx.rs/bindings.html">Rust and C++ types</a>:</p>
<ul>
<li>
<p>Explain how a Rust <code>String</code> cannot map to a C++ <code>std::string</code> (the latter does not uphold the UTF-8 invariant). Show that despite being different types, <code>rust::String</code> in C++ can be easily constructed from a C++ <code>std::string</code>, making it very ergonomic to use.</p>
</li>
<li>
<p>Explain that a Rust function returning <code>Result&lt;T, E&gt;</code> becomes a function which throws a <code>E</code> exception in C++ (and vice versa).</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#interoperability-with-java" id="interoperability-with-java">Interoperability with Java</a></h1>
<p>Java can load shared objects via <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface (JNI)</a>. The <a href="https://docs.rs/jni/"><code>jni</code> crate</a> allows you to create a compatible library.</p>
<p>First, we create a Rust function to export to Java:</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
#[no_mangle]
pub extern &quot;system&quot; fn Java_HelloWorld_hello(
    env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(name).unwrap().into();
    let greeting = format!(&quot;Hello, {input}!&quot;);
    let output = env.new_string(greeting).unwrap();
    output.into_inner()
}
<span class="boring">}
</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: &quot;libhello_jni&quot;,
    crate_name: &quot;hello_jni&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    rustlibs: [&quot;libjni&quot;],
}
</code></pre>
<p>Finally, we can call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary(&quot;hello_jni&quot;);
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;Alice&quot;);
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: &quot;helloworld_jni&quot;,
    srcs: [&quot;HelloWorld.java&quot;],
    main_class: &quot;HelloWorld&quot;,
    required: [&quot;libhello_jni&quot;],
}
</code></pre>
<p>Finally, you can build, sync, and run the binary:</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<h1><a class="header" href="#习题" id="习题">习题</a></h1>
<p>This is a group exercise: We will look at one of the projects you work with and try to integrate some Rust into it. Some suggestions:</p>
<ul>
<li>
<p>Call your AIDL service with a client written in Rust.</p>
</li>
<li>
<p>Move a function from your project to Rust and call it.</p>
</li>
</ul>
<details>
<p>No solution is provided here since this is open-ended: it relies on someone in the class having a piece of code which you can turn in to Rust on the fly.</p>
</details><h1><a class="header" href="#welcome-to-bare-metal-rust" id="welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>This is a standalone one-day course about bare-metal Rust, aimed at people who are familiar with the basics of Rust (perhaps from completing the Comprehensive Rust course), and ideally also have some experience with bare-metal programming in some other language such as C.</p>
<p>Today we will talk about ‘bare-metal’ Rust: running Rust code without an OS underneath us. This will be divided into several parts:</p>
<ul>
<li>What is <code>no_std</code> Rust?</li>
<li>Writing firmware for microcontrollers.</li>
<li>Writing bootloader / kernel code for application processors.</li>
<li>Some useful crates for bare-metal Rust development.</li>
</ul>
<p>For the microcontroller part of the course we will use the <a href="https://microbit.org/">BBC micro:bit</a> v2 as an example. It’s a <a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic nRF51822 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, and an on-board SWD debugger.</p>
<p>To get started, install some tools we’ll need later. On gLinux or Debian:</p>
<pre><code class="language-bash">sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<p>And give users in the <code>plugdev</code> group access to the micro:bit programmer:</p>
<pre><code class="language-bash">echo 'SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0d28&quot;, MODE=&quot;0664&quot;, GROUP=&quot;plugdev&quot;' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>On MacOS:</p>
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
brew install --cask gcc-aarch64-embedded
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<h1><a class="header" href="#no_std" id="no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Slices, <code>&amp;str</code>, <code>CStr</code></li>
<li><code>NonZeroU8</code>...</li>
<li><code>Option</code>, <code>Result</code></li>
<li><code>Display</code>, <code>Debug</code>, <code>write!</code>...</li>
<li><code>Iterator</code></li>
<li><code>panic!</code>, <code>assert_eq!</code>...</li>
<li><code>NonNull</code> and all the usual pointer-related functions</li>
<li><code>Future</code> and <code>async</code>/<code>await</code></li>
<li><code>fence</code>, <code>AtomicBool</code>, <code>AtomicPtr</code>, <code>AtomicU32</code>...</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>, <code>Cow</code>, <code>Arc</code>, <code>Rc</code></li>
<li><code>Vec</code>, <code>BinaryHeap</code>, <code>BtreeMap</code>, <code>LinkedList</code>, <code>VecDeque</code></li>
<li><code>String</code>, <code>CString</code>, <code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Error</code></li>
<li><code>HashMap</code></li>
<li><code>Mutex</code>, <code>Condvar</code>, <code>Barrier</code>, <code>Once</code>, <code>RwLock</code>, <code>mpsc</code></li>
<li><code>File</code> and the rest of <code>fs</code></li>
<li><code>println!</code>, <code>Read</code>, <code>Write</code>, <code>Stdin</code>, <code>Stdout</code> and the rest of <code>io</code></li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>, <code>Child</code>, <code>ExitCode</code></li>
<li><code>spawn</code>, <code>sleep</code> and the rest of <code>thread</code></li>
<li><code>SystemTime</code>, <code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> depends on RNG.</li>
<li><code>std</code> re-exports the contents of both <code>core</code> and <code>alloc</code>.</li>
</ul>
</details><h1><a class="header" href="#a-minimal-no_std-program" id="a-minimal-no_std-program">A minimal <code>no_std</code> program</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>This will compile to an empty binary.</li>
<li><code>std</code> provides a panic handler; without it we must provide our own.</li>
<li>It can also be provided by another crate, such as <code>panic-halt</code>.</li>
<li>Depending on the target, you may need to compile with <code>panic = &quot;abort&quot;</code> to avoid an error about <code>eh_personality</code>.</li>
<li>Note that there is no <code>main</code> or any other entry point; it’s up to you to define your own entry point. This will typically involve a linker script and some assembly code to set things up ready for Rust code to run.</li>
</ul>
</details><h1><a class="header" href="#alloc" id="alloc"><code>alloc</code></a></h1>
<p>To use <code>alloc</code> you must implement a <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">global (heap) allocator</a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // Safe because `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR
            .lock()
            .init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push(&quot;A string&quot;.to_string());
}
</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> is a third-party crate implementing a basic buddy system allocator. Other crates are available, or you can write your own or hook into your existing allocator.</li>
<li>The const parameter of <code>LockedHeap</code> is the max order of the allocator; i.e. in this case it can allocate regions of up to 2**32 bytes.</li>
<li>If any crate in your dependency tree depends on <code>alloc</code> then you must have exactly one global allocator defined in your binary. Usually this is done in the top-level binary crate.</li>
<li><code>extern crate panic_halt as _</code> is necessary to ensure that the <code>panic_halt</code> crate is linked in so we get its panic handler.</li>
<li>This example will build but not run, as it doesn’t have an entry point.</li>
</ul>
</details><h1><a class="header" href="#微控制器" id="微控制器">微控制器</a></h1>
<p>The <code>cortex_m_rt</code> crate provides (among other things) a reset handler for Cortex M microcontrollers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}
</code></pre></pre>
<p>Next we’ll look at how to access peripherals, with increasing levels of abstraction.</p>
<details>
<ul>
<li>The <code>cortex_m_rt::entry</code> macro requires that the function have type <code>fn() -&gt; !</code>, because returning to the reset handler doesn’t make sense.</li>
<li>Run the example with <code>cargo embed --bin minimal</code></li>
</ul>
</details><h1><a class="header" href="#原始-mmio" id="原始-mmio">原始 MMIO</a></h1>
<p>Most microcontrollers access peripherals via memory-mapped IO. Let’s try turning on an LED on our micro:bit:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 to the first row.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details><h1><a class="header" href="#peripheral-access-crates" id="peripheral-access-crates">Peripheral Access Crates</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> generates mostly-safe Rust wrappers for memory-mapped peripherals from <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> files.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>SVD (System View Description) files are XML files typically provided by silicon vendors which describe the memory map of the device.
<ul>
<li>They are organised by peripheral, register, field and value, with names, descriptions, addresses and so on.</li>
<li>SVD files are often buggy and incomplete, so there are various projects which patch the mistakes, add missing details, and publish the generated crates.</li>
</ul>
</li>
<li><code>cortex-m-rt</code> provides the vector table, among other things.</li>
<li>If you <code>cargo install cargo-binutils</code> then you can run <code>cargo objdump --bin pac -- -d --no-show-raw-insn</code> to see the resulting binary.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details><h1><a class="header" href="#hal-crates" id="hal-crates">HAL crates</a></h1>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crates</a> for many microcontrollers provide wrappers around various peripherals. These generally implement traits from <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;
use nrf52833_hal::prelude::*;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> and <code>set_high</code> are methods on the <code>embedded_hal</code> <code>OutputPin</code> trait.</li>
<li>HAL crates exist for many Cortex-M and RISC-V devices, including various STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details><h1><a class="header" href="#board-support-crates" id="board-support-crates">Board support crates</a></h1>
<p>Board support crates provide a further level of wrapping for a specific board for convenience.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use microbit::hal::prelude::*;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>In this case the board support crate is just providing more useful names, and a bit of initialisation.</li>
<li>The crate may also include drivers for some on-board devices outside of the microcontroller itself.
<ul>
<li><code>microbit-v2</code> includes a simple driver for the LED matrix.</li>
</ul>
</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details><h1><a class="header" href="#the-type-state-pattern" id="the-type-state-pattern">The type state pattern</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; = gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>Pins don’t implement <code>Copy</code> or <code>Clone</code>, so only one instance of each can exist. Once a pin is moved out of the port struct nobody else can take it.</li>
<li>Changing the configuration of a pin consumes the old pin instance, so you can’t keep use the old instance afterwards.</li>
<li>The type of a value indicates the state that it is in: e.g. in this case, the configuration state of a GPIO pin. This encodes the state machine into the type system, and ensures that you don’t try to use a pin in a certain way without properly configuring it first. Illegal state transitions are caught at compile time.</li>
<li>You can call <code>is_high</code> on an input pin and <code>set_high</code> on an output pin, but not vice-versa.</li>
<li>Many HAL crates follow this pattern.</li>
</ul>
</details><h1><a class="header" href="#embedded-hal" id="embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits covering common microcontroller peripherals.</p>
<ul>
<li>GPIO</li>
<li>ADC</li>
<li>I2C, SPI, UART, CAN</li>
<li>RNG</li>
<li>Timers</li>
<li>Watchdogs</li>
</ul>
<p>Other crates then implement <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these traits, e.g. an accelerometer driver might need an I2C or SPI bus implementation.</p>
<details>
<ul>
<li>There are implementations for many microcontrollers, as well as other platforms such as Linux on Raspberry Pi.</li>
<li>There is work in progress on an <code>async</code> version of <code>embedded-hal</code>, but it isn’t stable yet.</li>
</ul>
</details><h1><a class="header" href="#probe-rs-cargo-embed" id="probe-rs-cargo-embed"><code>probe-rs</code>, <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> is a handy toolset for embedded debugging, like OpenOCD but better integrated.</p>
<ul>
<li>SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes</li>
<li>GDB stub and Microsoft DAP (Debug Adapter Protocol) server</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> is a cargo subcommand to build and flash binaries, log RTT (Real Time Transfers) output and connect GDB. It’s configured by an <code>Embed.toml</code> file in your project directory.</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> is an Arm standard protocol over USB for an in-circuit debugger to access the CoreSight Debug Access Port of various Arm Cortex processors. It’s what the on-board debugger on the BBC micro:bit uses.</li>
<li>ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is a range from SEGGER.</li>
<li>The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial Wire Debug.</li>
<li>probe-rs is a library which you can integrate into your own tools if you want to.</li>
<li>The <a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft Debug Adapter Protocol</a> lets VSCode and other IDEs debug code running on any supported microcontroller.</li>
<li>cargo-embed is a binary built using the probe-rs library.</li>
<li>RTT (Real Time Transfers) is a mechanism to transfer data between the debug host and the target through a number of ringbuffers.</li>
</ul>
</details><h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p><em>Embed.toml</em>:</p>
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true
</code></pre>
<p>In one terminal under <code>src/bare-metal/microcontrollers/examples/</code>:</p>
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>In another terminal in the same directory:</p>
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<details>
<p>In GDB, try running:</p>
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details><h1><a class="header" href="#other-projects" id="other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>“Real-Time Interrupt-driven Concurrency”</li>
<li>Shared resource management, message passing, task scheduling, timer queue</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit support</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, IPC</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a></li>
<li>Some platforms have <code>std</code> implementations, e.g. <a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>.</li>
</ul>
<details>
<ul>
<li>RTIC can be considered either an RTOS or a concurrency framework.
<ul>
<li>It doesn’t include any HALs.</li>
<li>It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for scheduling rather than a proper kernel.</li>
<li>Cortex-M only.</li>
</ul>
</li>
<li>Google uses TockOS on the Haven microcontroller for Titan security keys.</li>
<li>FreeRTOS is mostly written in C, but there are Rust bindings for writing applications.</li>
</ul>
</details><h1><a class="header" href="#习题-1" id="习题-1">习题</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#罗盘" id="罗盘">罗盘</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port. If you have time, try displaying it on the LEDs somehow too, or use the buttons somehow.</p>
<p>Hints:</p>
<ul>
<li>Check the documentation for the <a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> and <a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crates, as well as the <a href="https://tech.microbit.org/hardware/">micro:bit hardware</a>.</li>
<li>The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.</li>
<li>TWI is another name for I2C, so the I2C master peripheral is called TWIM.</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::blocking::i2c::WriteRead</code> trait. The <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a> struct implements this.</li>
<li>You have a <a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a> struct with fields for the various pins and peripherals.</li>
<li>You can also look at the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 datasheet</a> if you want, but it shouldn’t be necessary for this exercise.</li>
</ul>
<p>Download the <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>compass</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};

#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}
</code></pre></pre>
<p><em>Cargo.toml</em> (you shouldn’t need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;compass&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
cortex-m-rt = &quot;0.7.3&quot;
embedded-hal = &quot;0.2.6&quot;
lsm303agr = &quot;0.2.2&quot;
microbit-v2 = &quot;0.13.0&quot;
panic-halt = &quot;0.2.0&quot;
</code></pre>
<p><em>Embed.toml</em> (you shouldn’t need to change this):</p>
<!-- File Embed.toml -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldn’t need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]
</code></pre>
<p>See the serial output on Linux with:</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>Or on Mac OS something like (the device name may be slightly different):</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>Use Ctrl+A Ctrl+Q to quit picocom.</p>
<h1><a class="header" href="#application-processors" id="application-processors">Application processors</a></h1>
<p>So far we’ve talked about microcontrollers, such as the Arm Cortex-M series. Now let’s try writing something for Cortex-A. For simplicity we’ll just work with QEMU’s aarch64 <a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html">‘virt’</a> board.</p>
<details>
<ul>
<li>Broadly speaking, microcontrollers don’t have an MMU or multiple levels of privilege (exception levels on Arm CPUs, rings on x86), while application processors do.</li>
<li>QEMU supports emulating various different machines or board models for each architecture. The ‘virt’ board doesn’t correspond to any particular real hardware, but is designed purely for virtual machines.</li>
</ul>
</details><h1><a class="header" href="#准备使用-rust" id="准备使用-rust">准备使用 Rust</a></h1>
<p>Before we can start running Rust code, we need to do some initialisation.</p>
<pre><code class="language-armasm">.section .init.entry, &quot;ax&quot;
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to enable MMU and
     * caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then invalidate any
     * potentially stale local TLB entries before they start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed until this
     * has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>This is the same as it would be for C: initialising the processor state, zeroing the BSS, and setting up the stack pointer.
<ul>
<li>The BSS (block starting symbol, for historical reasons) is the part of the object file which containing statically allocated variables which are initialised to zero. They are omitted from the image, to avoid wasting space on zeroes. The compiler assumes that the loader will take care of zeroing them.</li>
</ul>
</li>
<li>The BSS may already be zeroed, depending on how memory is initialised and the image is loaded, but we zero it to be sure.</li>
<li>We need to enable the MMU and cache before reading or writing any memory. If we don’t:
<ul>
<li>Unaligned accesses will fault. We build the Rust code for the <code>aarch64-unknown-none</code> target which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses, so it should be fine in this case, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM is accessing memory directly with the cache disabled, while the host has cacheable aliases to the same memory. Even if the host doesn’t explicitly access the memory, speculative accesses can lead to cache fills, and then changes from one or the other will get lost when the cache is cleaned or the VM enables the cache. (Cache is keyed by physical address, not VA or IPA.)</li>
</ul>
</li>
<li>For simplicity, we just use a hardcoded pagetable (see <code>idmap.S</code>) which identity maps the first 1 GiB of address space for devices, the next 1 GiB for DRAM, and another 1 GiB higher up for more devices. This matches the memory layout that QEMU uses.</li>
<li>We also set up the exception vector (<code>vbar_el1</code>), which we’ll see more about later.</li>
<li>All examples this afternoon assume we will be running at exception level 1 (EL1). If you need to run at a different exception level you’ll need to modify <code>entry.S</code> accordingly.</li>
</ul>
</details><h1><a class="header" href="#inline-assembly" id="inline-assembly">Inline assembly</a></h1>
<p>Sometimes we need to use assembly to do things that aren’t possible with Rust code. For example, to make an HVC (hypervisor call) to tell the firmware to power off the system:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

#[no_mangle]
extern &quot;C&quot; fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // Safe because this only uses the declared registers and doesn't do
    // anything with memory.
    unsafe {
        asm!(&quot;hvc #0&quot;,
            inout(&quot;w0&quot;) PSCI_SYSTEM_OFF =&gt; _,
            inout(&quot;w1&quot;) 0 =&gt; _,
            inout(&quot;w2&quot;) 0 =&gt; _,
            inout(&quot;w3&quot;) 0 =&gt; _,
            inout(&quot;w4&quot;) 0 =&gt; _,
            inout(&quot;w5&quot;) 0 =&gt; _,
            inout(&quot;w6&quot;) 0 =&gt; _,
            inout(&quot;w7&quot;) 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}
</code></pre></pre>
<p>(If you actually want to do this, use the <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crate which has wrappers for all these functions.)</p>
<details>
<ul>
<li>PSCI is the Arm Power State Coordination Interface, a standard set of functions to manage system and CPU power states, among other things. It is implemented by EL3 firmware and hypervisors on many systems.</li>
<li>The <code>0 =&gt; _</code> syntax means initialise the register to 0 before running the inline assembly code, and ignore its contents afterwards. We need to use <code>inout</code> rather than <code>in</code> because the call could potentially clobber the contents of the registers.</li>
<li>This <code>main</code> function needs to be <code>#[no_mangle]</code> and <code>extern &quot;C&quot;</code> because it is called from our entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>–<code>_x3</code> are the values of registers <code>x0</code>–<code>x3</code>, which are conventionally used by the bootloader to pass things like a pointer to the device tree. According to the standard aarch64 calling convention (which is what <code>extern &quot;C&quot;</code> specifies to use), registers <code>x0</code>–<code>x7</code> are used for the first 8 arguments passed to a function, so <code>entry.S</code> doesn’t need to do anything special except make sure it doesn’t change these registers.</li>
<li>Run the example in QEMU with <code>make qemu_psci</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#volatile-memory-access-for-mmio" id="volatile-memory-access-for-mmio">Volatile memory access for MMIO</a></h1>
<ul>
<li>Use <code>pointer::read_volatile</code> and <code>pointer::write_volatile</code>.</li>
<li>Never hold a reference.</li>
<li><code>addr_of!</code> lets you get fields of structs without creating an intermediate reference.</li>
</ul>
<details>
<ul>
<li>Volatile access: read or write operations may have side-effects, so prevent the compiler or hardware from reordering, duplicating or eliding them.
<ul>
<li>Usually if you write and then read, e.g. via a mutable reference, the compiler may assume that the value read is the same as the value just written, and not bother actually reading memory.</li>
</ul>
</li>
<li>Some existing crates for volatile access to hardware do hold references, but this is unsound. Whenever a reference exist, the compiler may choose to dereference it.</li>
<li>Use the <code>addr_of!</code> macro to get struct field pointers from a pointer to the struct.</li>
</ul>
</details><h1><a class="header" href="#lets-write-a-uart-driver" id="lets-write-a-uart-driver">Let’s write a UART driver</a></h1>
<p>The QEMU ‘virt’ machine has a <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UART, so let’s write a driver for that.</p>
<pre><pre class="playground"><code class="language-rust editable">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note that <code>Uart::new</code> is unsafe while the other methods are safe. This is because as long as the caller of <code>Uart::new</code> guarantees that its safety requirements are met (i.e. that there is only ever one instance of the driver for a given UART, and nothing else aliasing its address space), then it is always safe to call <code>write_byte</code> later because we can assume the necessary preconditions.</li>
<li>We could have done it the other way around (making <code>new</code> safe but <code>write_byte</code> unsafe), but that would be much less convenient to use as every place that calls <code>write_byte</code> would need to reason about the safety</li>
<li>This is a common pattern for writing safe wrappers of unsafe code: moving the burden of proof for soundness from a large number of places to a smaller number of places.</li>
</ul>
</details><h1><a class="header" href="#more-traits" id="more-traits">More traits</a></h1>
<p>We derived the <code>Debug</code> trait. It would be useful to implement a few more traits too.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
</code></pre></pre>
<details>
<ul>
<li>Implementing <code>Write</code> lets us use the <code>write!</code> and <code>writeln!</code> macros with our <code>Uart</code> type.</li>
<li>Run the example in QEMU with <code>make qemu_minimal</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#a-better-uart-driver" id="a-better-uart-driver">A better UART driver</a></h1>
<p>The PL011 actually has <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">a bunch more registers</a>, and adding offsets to construct pointers to access them is error-prone and hard to read. Plus, some of them are bit fields which would be nice to access in a structured way.</p>
<table><thead><tr><th>Offset</th><th>Register name</th><th>Width</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
<details>
<ul>
<li>There are also some ID registers which have been omitted for brevity.</li>
</ul>
</details><h1><a class="header" href="#bitflags" id="bitflags">Bitflags</a></h1>
<p>The <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate is useful for working with bitflags.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
</code></pre></pre>
<details>
<ul>
<li>The <code>bitflags!</code> macro creates a newtype something like <code>Flags(u16)</code>, along with a bunch of method implementations to get and set flags.</li>
</ul>
</details><h1><a class="header" href="#multiple-registers" id="multiple-registers">Multiple registers</a></h1>
<p>We can use a struct to represent the memory layout of the UART’s registers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a> tells the compiler to lay the struct fields out in order, following the same rules as C. This is necessary for our struct to have a predictable layout, as default Rust representation allows the compiler to (among other things) reorder fields however it sees fit.</li>
</ul>
</details><h1><a class="header" href="#驱动程序" id="驱动程序">驱动程序</a></h1>
<p>Now let’s use the new <code>Registers</code> struct in our driver.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>addr_of!</code> / <code>addr_of_mut!</code> to get pointers to individual fields without creating an intermediate reference, which would be unsound.</li>
</ul>
</details><h1><a class="header" href="#using-it" id="using-it">Using it</a></h1>
<p>Let’s write a small program using our driver to write to the serial console, and echo incoming bytes.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, &quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;).unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; {}
            }
        }
    }

    writeln!(uart, &quot;Bye!&quot;).unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>As in the <a href="bare-metal/aps/better-uart/../inline-assembly.html">inline assembly</a> example, this <code>main</code> function is called from our entry point code in <code>entry.S</code>. See the speaker notes there for details.</li>
<li>Run the example in QEMU with <code>make qemu</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#日志记录-1" id="日志记录-1">日志记录</a></h1>
<p>It would be nice to be able to use the logging macros from the <a href="https://crates.io/crates/log"><code>log</code></a> crate. We can do this by implementing the <code>Log</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>The unwrap in <code>log</code> is safe because we initialise <code>LOGGER</code> before calling <code>set_logger</code>.</li>
</ul>
</details><h1><a class="header" href="#using-it-1" id="using-it-1">Using it</a></h1>
<p>We need to initialise the logger before we use it.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;);

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>Note that our panic handler can now log details of panics.</li>
<li>Run the example in QEMU with <code>make qemu_logger</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#exceptions" id="exceptions">Exceptions</a></h1>
<p>AArch64 defines an exception vector table with 16 entries, for 4 types of exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). We implement this in assembly to save volatile registers to the stack before calling into Rust code:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    error!(&quot;irq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>EL is exception level; all our examples this afternoon run in EL1.</li>
<li>For simplicity we aren’t distinguishing between SP0 and SPx for the current EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions.</li>
<li>For this example we just log the exception and power down, as we don’t expect any of them to actually happen.</li>
<li>We can think of exception handlers and our main execution context more or less like different threads. <a href="bare-metal/aps/../../concurrency/send-sync.html"><code>Send</code> and <code>Sync</code></a> will control what we can share between them, just like with threads. For example, if we want to share some value between exception handlers and the rest of the program, and it’s <code>Send</code> but not <code>Sync</code>, then we’ll need to wrap it in something like a <code>Mutex</code> and put it in a static.</li>
</ul>
</details><h1><a class="header" href="#other-projects-1" id="other-projects-1">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>“coreboot without the C”</li>
<li>Supports x86, aarch64 and RISC-V.</li>
<li>Relies on LinuxBoot rather than having many drivers itself.</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi OS tutorial</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling, page tables</li>
<li>Some dodginess around cache maintenance and initialisation in Rust, not necessarily a good example to copy for production code.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>Static analysis to determine maximum stack usage.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>The RaspberryPi OS tutorial runs Rust code before the MMU and caches are enabled. This will read and write memory (e.g. the stack). However:
<ul>
<li>Without the MMU and cache, unaligned accesses will fault. It builds with <code>aarch64-unknown-none</code> which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses so it should be alright, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM is accessing memory directly with the cache disabled, while the host has cacheable aliases to the same memory. Even if the host doesn’t explicitly access the memory, speculative accesses can lead to cache fills, and then changes from one or the other will get lost. Again this is alright in this particular case (running directly on the hardware with no hypervisor), but isn’t a good pattern in general.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#实用-crate" id="实用-crate">实用 crate</a></h1>
<p>We’ll go over a few crates which solve some common problems in bare-metal programming.</p>
<h1><a class="header" href="#zerocopy" id="zerocopy"><code>zerocopy</code></a></h1>
<p>The <a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crate (from Fuchsia) provides traits and macros for safely converting between byte sequences and other types.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use zerocopy::AsBytes;

#[repr(u32)]
#[derive(AsBytes, Debug, Default)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(AsBytes, Debug, Default)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}
</code></pre></pre>
<p>This is not suitable for MMIO (as it doesn’t use volatile reads and writes), but can be useful for working with structures shared with hardware e.g. by DMA, or sent over some external interface.</p>
<details>
<ul>
<li><code>FromBytes</code> can be implemented for types for which any byte pattern is valid, and so can safely be converted from an untrusted sequence of bytes.</li>
<li>Attempting to derive <code>FromBytes</code> for these types would fail, because <code>RequestType</code> doesn’t use all possible u32 values as discriminants, so not all byte patterns are valid.</li>
<li><code>zerocopy::byteorder</code> has types for byte-order aware numeric primitives.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/zerocopy-example/</code>. (It won’t run in the Playground because of the crate dependency.)</li>
</ul>
</details><h1><a class="header" href="#aarch64-paging" id="aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>The <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crate lets you create page tables according to the AArch64 Virtual Memory System Architecture.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();
</code></pre></pre>
<details>
<ul>
<li>For now it only supports EL1, but support for other exception levels should be straightforward to add.</li>
<li>This is used in Android for the <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">Protected VM Firmware</a>.</li>
<li>There’s no easy way to run this example, as it needs to run on real hardware or under QEMU.</li>
</ul>
</details><h1><a class="header" href="#buddy_system_allocator" id="buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> is a third-party crate implementing a basic buddy system allocator. It can be used both for <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> implementing <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> so you can use the standard <code>alloc</code> crate (as we saw <a href="bare-metal/useful-crates/../alloc.html">before</a>), or for allocating other address space. For example, we might want to allocate MMIO space for PCI BARs:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect(&quot;Failed to allocate 0x100 byte MMIO region&quot;);
    println!(&quot;Allocated 0x100 byte MMIO region at {:#x}&quot;, bar);
}
</code></pre></pre>
<details>
<ul>
<li>PCI BARs always have alignment equal to their size.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/allocator-example/</code>. (It won’t run in the Playground because of the crate dependency.)</li>
</ul>
</details><h1><a class="header" href="#tinyvec" id="tinyvec"><code>tinyvec</code></a></h1>
<p>Sometimes you want something which can be resized like a <code>Vec</code>, but without heap allocation. <a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> provides this: a vector backed by an array or slice, which could be statically allocated or on the stack, which keeps track of how many elements are used and panics if you try to use more than are allocated.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!(&quot;{numbers:?}&quot;);
    numbers.push(7);
    println!(&quot;{numbers:?}&quot;);
    numbers.remove(1);
    println!(&quot;{numbers:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>tinyvec</code> requires that the element type implement <code>Default</code> for initialisation.</li>
<li>The Rust Playground includes <code>tinyvec</code>, so this example will run fine inline.</li>
</ul>
</details><h1><a class="header" href="#spin" id="spin"><code>spin</code></a></h1>
<p><code>std::sync::Mutex</code> and the other synchronisation primitives from <code>std::sync</code> are not available in <code>core</code> or <code>alloc</code>. How can we manage synchronisation or interior mutability, such as for sharing state between different CPUs?</p>
<p>The <a href="https://crates.io/crates/spin"><code>spin</code></a> crate provides spinlock-based equivalents of many of these primitives.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!(&quot;count: {}&quot;, counter.lock());
    *counter.lock() += 2;
    println!(&quot;count: {}&quot;, counter.lock());
}
</code></pre></pre>
<details>
<ul>
<li>Be careful to avoid deadlock if you take locks in interrupt handlers.</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>, <code>Barrier</code> and <code>Once</code> from <code>std::sync</code>;  and <code>Lazy</code> for lazy initialisation.</li>
<li>The <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate also has some useful types for late initialisation with a slightly different approach to <code>spin::once::Once</code>.</li>
<li>The Rust Playground includes <code>spin</code>, so this example will run fine inline.</li>
</ul>
</details><h1><a class="header" href="#android" id="android">Android</a></h1>
<p>To build a bare-metal Rust binary in AOSP, you need to use a <code>rust_ffi_static</code> Soong rule to build your Rust code, then a <code>cc_binary</code> with a linker script to produce the binary itself, and then a <code>raw_binary</code> to convert the ELF to a raw binary ready to be run.</p>
<pre><code class="language-soong">rust_ffi_static {
    name: &quot;libvmbase_example&quot;,
    defaults: [&quot;vmbase_ffi_defaults&quot;],
    crate_name: &quot;vmbase_example&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libvmbase&quot;,
    ],
}

cc_binary {
    name: &quot;vmbase_example&quot;,
    defaults: [&quot;vmbase_elf_defaults&quot;],
    srcs: [
        &quot;idmap.S&quot;,
    ],
    static_libs: [
        &quot;libvmbase_example&quot;,
    ],
    linker_scripts: [
        &quot;image.ld&quot;,
        &quot;:vmbase_sections&quot;,
    ],
}

raw_binary {
    name: &quot;vmbase_example_bin&quot;,
    stem: &quot;vmbase_example.bin&quot;,
    src: &quot;:vmbase_example&quot;,
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<h1><a class="header" href="#vmbase" id="vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/master/vmbase/">vmbase</a> library provides a linker script and useful defaults for the build rules, along with an entry point, UART console logging and more.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The <code>main!</code> macro marks your main function, to be called from the <code>vmbase</code> entry point.</li>
<li>The <code>vmbase</code> entry point handles console initialisation, and issues a PSCI_SYSTEM_OFF to shutdown the VM if your main function returns.</li>
</ul>
</details><h1><a class="header" href="#习题-2" id="习题-2">习题</a></h1>
<p>We will write a driver for the PL031 real-time clock device.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#rtc-driver" id="rtc-driver">RTC driver</a></h1>
<p>The QEMU aarch64 virt machine has a <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> real-time clock at 0x9010000. For this exercise, you should write a driver for it.</p>
<ol>
<li>Use it to print the current time to the serial console. You can use the <a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate for date/time formatting.</li>
<li>Use the match register and raw interrupt status to busy-wait until a given time, e.g. 3 seconds in the future. (Call <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a> inside the loop.)</li>
<li><em>Extension if you have time:</em> Enable and handle the interrupt generated by the RTC match. You can use the driver provided in the <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate to configure the Arm Generic Interrupt Controller.
<ul>
<li>Use the RTC interrupt, which is wired to the GIC as <code>IntId::spi(2)</code>.</li>
<li>Once the interrupt is enabled, you can put the core to sleep via <code>arm_gic::wfi()</code>, which will cause the core to sleep until it receives an interrupt.</li>
</ul>
</li>
</ol>
<p>Download the <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>rtc</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>src/exceptions.rs</em> (you should only need to change this for the 3rd part of the exercise):</p>
<!-- File src/exceptions.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    trace!(&quot;irq_current&quot;);
    let intid = GicV3::get_and_acknowledge_interrupt().expect(&quot;No pending interrupt&quot;);
    info!(&quot;IRQ {intid:?}&quot;);
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/logger.rs</em> (you shouldn’t need to change this):</p>
<!-- File src/logger.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/pl011.rs</em> (you shouldn’t need to change this):</p>
<!-- File src/pl011.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};
use core::ptr::{addr_of, addr_of_mut};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}
</span></code></pre></pre>
<p><em>Cargo.toml</em> (you shouldn’t need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;rtc&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
arm-gic = &quot;0.1.0&quot;
bitflags = &quot;2.0.0&quot;
chrono = { version = &quot;0.4.24&quot;, default-features = false }
log = &quot;0.4.17&quot;
smccc = &quot;0.1.1&quot;
spin = &quot;0.9.8&quot;

[build-dependencies]
cc = &quot;1.0.73&quot;
</code></pre>
<p><em>build.rs</em> (you shouldn’t need to change this):</p>
<!-- File build.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    #[cfg(target_os = &quot;linux&quot;)]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-linux-gnu&quot;);
    #[cfg(not(target_os = &quot;linux&quot;))]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-none-elf&quot;);

    Build::new()
        .file(&quot;entry.S&quot;)
        .file(&quot;exceptions.S&quot;)
        .file(&quot;idmap.S&quot;)
        .compile(&quot;empty&quot;)
}
</code></pre></pre>
<p><em>entry.S</em> (you shouldn’t need to change this):</p>
<!-- File entry.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, &quot;ax&quot;
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><em>exceptions.S</em> (you shouldn’t need to change this):</p>
<!-- File exceptions.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, &quot;ax&quot;
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><em>idmap.S</em> (you shouldn’t need to change this):</p>
<!-- File idmap.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section &quot;.rodata.idmap&quot;, &quot;a&quot;, %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><em>image.ld</em> (you shouldn’t need to change this):</p>
<!-- File image.ld -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><em>Makefile</em> (you shouldn’t need to change this):</p>
<!-- File Makefile -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

UNAME := $(shell uname -s)
ifeq ($(UNAME),Linux)
	TARGET = aarch64-linux-gnu
else
	TARGET = aarch64-none-elf
endif
OBJCOPY = $(TARGET)-objcopy

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldn’t need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;aarch64-unknown-none&quot;
rustflags = [&quot;-C&quot;, &quot;link-arg=-Timage.ld&quot;]
</code></pre>
<p>Run the code in QEMU with <code>make qemu</code>.</p>
<h1><a class="header" href="#欢迎了解-rust-中的并发-1" id="欢迎了解-rust-中的并发-1">欢迎了解 Rust 中的并发</a></h1>
<p>Rust 完全支持使用带有互斥锁和通道的操作系统线程进行并发。</p>
<p>Rust 类型系统能帮助我们把许多并发bug转换为编译期bug 发挥着重要作用。这通常称为“无畏并发”，因为你可以依靠编译器来确保 运行时的正确性。</p>
<h1><a class="header" href="#线程" id="线程">线程</a></h1>
<p>Rust 线程的运作方式与其他语言中的线程类似：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>线程均为守护程序线程，主线程不会等待这些线程。</li>
<li>线程紧急警报 (panic) 是彼此独立的。
<ul>
<li>紧急警报可以携带载荷，并可以使用 <code>downcast_ref</code> 对载荷进行解压缩。</li>
</ul>
</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>请注意，线程在达到 10 之前就停止了，而主线程并 没有等待。</p>
</li>
<li>
<p>使用 <code>let handle = thread::spawn(...)</code> 和后面的 <code>handle.join()</code> 等待 线程完成。</p>
</li>
<li>
<p>在线程中触发紧急警报，并注意这为何不会影响到 <code>main</code>。</p>
</li>
<li>
<p>使用 <code>handle.join()</code> 的 <code>Result</code> 返回值来获取对紧急警报 载荷的访问权限。现在有必要介绍一下 <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a> 了。</p>
</li>
</ul>
</details><h1><a class="header" href="#范围线程" id="范围线程">范围线程</a></h1>
<p>常规线程不能从它们所处的环境中借用：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<p>不过，你可以使用<a href="https://doc.rust-lang.org/std/thread/fn.scope.html">范围线程</a>来实现此目的：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}
</code></pre></pre>
<details>
<ul>
<li>其原因在于，在 <code>thread::scope</code> 函数完成后，可保证所有线程都已联结在一起，使得线程能够返回借用的数据。</li>
<li>此时须遵守常规 Rust 借用规则：你可以通过一个线程以可变的方式借用，也可以通过任意数量的线程以不可变的方式借用。</li>
</ul>
</details><h1><a class="header" href="#通道" id="通道">通道</a></h1>
<p>Rust 通道（Channel）包含两个部分：<code>Sender&lt;T&gt;</code> 和 <code>Receiver&lt;T&gt;</code>。这两个部分 通过通道进行连接，但你只能看到端点。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> 代表多个生产方，单个使用方。<code>Sender</code> 和 <code>SyncSender</code> 会实现 <code>Clone</code>（因此， 你可以设置多个生产方），但 <code>Receiver</code> 不会实现。</li>
<li><code>send()</code> 和 <code>recv()</code> 会返回 <code>Result</code>。如果它们返回 <code>Err</code>，则表示对应的 <code>Sender</code> 或 <code>Receiver</code> 已被丢弃，且通道已关闭。</li>
</ul>
</details><h1><a class="header" href="#无界通道" id="无界通道">无界通道</a></h1>
<p>你可以使用 <code>mpsc::channel()</code> 获得无边界的异步通道：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#有界通道" id="有界通道">有界通道</a></h1>
<p>With bounded (synchronous) channels, <code>send</code> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Calling <code>send</code> will block the current thread until there is space in the channel for the new message. The thread can be blocked indefinitely if there is nobody who reads from the channel.</li>
<li>A call to <code>send</code> will abort with an error (that is why it returns <code>Result</code>) if the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a “rendezvous channel”. Every send will block the current thread until another thread calls <code>read</code>.</li>
</ul>
</details><h1><a class="header" href="#send-和-sync" id="send-和-sync"><code>Send</code> 和 <code>Sync</code></a></h1>
<p>How does Rust know to forbid shared access across threads? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>：如果跨线程边界移动 <code>T</code> 是安全的，则类型 <code>T</code> 为 <code>Send</code>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>：如果跨线程边界移动 <code>&amp;T</code> 是安全的，则类型 <code>T</code> 为 <code>Sync</code>。</li>
</ul>
<p><code>Send</code> 和 <code>Sync</code> 均为<a href="concurrency/../unsafe/unsafe-traits.html">不安全特征</a>。只要类型仅包含 <code>Send</code> 和 <code>Sync</code> 类型，编译器就会自动为类型派生 这两种特征。你也可以手动实现它们（如果你确定这样 有效的话）。</p>
<details>
<ul>
<li>不妨将这些特征视为类型包含某些线程安全属性的标记。</li>
<li>它们可以在泛型约束中作为常规特征使用。</li>
</ul>
</details><h1><a class="header" href="#send" id="send"><code>Send</code></a></h1>
<blockquote>
<p>如果将 <code>T</code> 值移动到另一个线程是安全的，则类型 <code>T</code> 为 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>。</p>
</blockquote>
<p>将所有权转移到另一个线程的影响是，“析构函数”将在相应线程中 运行。因此，问题在于你何时可以在一个线程中分配某个值，然后在 另一个线程中取消分配该值。</p>
<details>
<p>例如，与 SQLite 库的连接只能通过 单个线程访问。</p>
</details><h1><a class="header" href="#sync" id="sync"><code>Sync</code></a></h1>
<blockquote>
<p>如果同时从多个线程访问 <code>T</code> 值是安全的，则类型 <code>T</code> 为 <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>。</p>
</blockquote>
<p>更准确地说，定义是：</p>
<blockquote>
<p>当且仅当 <code>&amp;T</code> 为 <code>Send</code> 时，<code>T</code> 为 <code>Sync</code></p>
</blockquote>
<details>
<p>该语句实质上是一种简写形式，表示如果某个类型对于共享使用是线程安全的，那么跨线程传递对该类型的引用也是线程安全的。</p>
<p>这是因为如果某个类型为 Sync，则意味着它可以在多个线程之间共享，而不存在数据争用或其他同步问题的风险，因此将其移动到另一个线程是安全的。对该类型的引用同样可以安全地移动到另一个线程，因为它引用的数据可以从任何线程安全地访问。</p>
</details><h1><a class="header" href="#示例-1" id="示例-1">示例</a></h1>
<h2><a class="header" href="#send--sync" id="send--sync"><code>Send + Sync</code></a></h2>
<p>你遇到的类型大都属于 <code>Send + Sync</code>：</p>
<ul>
<li><code>i8</code>、<code>f32</code>、<code>bool</code>、<code>char</code>、<code>&amp;str</code>…</li>
<li><code>(T1, T2)</code>、<code>[T; N]</code>、<code>&amp;[T]</code>、<code>struct { x: T }</code>…</li>
<li><code>String</code>、<code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>…</li>
<li><code>Arc&lt;T&gt;</code>：明确通过原子引用计数实现线程安全。</li>
<li><code>Mutex&lt;T&gt;</code>：明确通过内部锁定实现线程安全。</li>
<li><code>AtomicBool</code>、<code>AtomicU8</code>…：使用特殊的原子指令。</li>
</ul>
<p>当类型参数为 <code>Send + Sync</code> 时，泛型类型通常 为 <code>Send + Sync</code>。</p>
<h2><a class="header" href="#send--sync-1" id="send--sync-1"><code>Send + !Sync</code></a></h2>
<p>这些类型可以移动到其他线程，但它们不是线程安全的。 这通常是由内部可变性造成的：</p>
<ul>
<li><code>mpsc::Sender&lt;T&gt;</code></li>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2><a class="header" href="#send--sync-2" id="send--sync-2"><code>!Send + Sync</code></a></h2>
<p>这些类型是线程安全的，但它们不能移动到另一个线程：</p>
<ul>
<li><code>MutexGuard&lt;T&gt;</code>：使用操作系统级别的原语（必须在创建这些原语的线程上 取消分配）。</li>
</ul>
<h2><a class="header" href="#send--sync-3" id="send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>这些类型不是线程安全的，不能移动到其他线程：</p>
<ul>
<li><code>Rc&lt;T&gt;</code>：每个 <code>Rc&lt;T&gt;</code> 都具有对 <code>RcBox&lt;T&gt;</code> 的引用，其中包含 非原子引用计数。</li>
<li><code>*const T</code>、<code>*mut T</code>：Rust 会假定原始指针可能 在并发方面有特殊的注意事项。</li>
</ul>
<h1><a class="header" href="#共享状态" id="共享状态">共享状态</a></h1>
<p>Rust 使用类型系统来强制同步共享数据。这主要 通过两种类型实现：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>，对 <code>T</code> 进行原子计数：用于处理线程之间的共享，并负责 在最后一个引用被丢弃时取消分配 <code>T</code>。</li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>：确保对 <code>T</code> 值的互斥访问。</li>
</ul>
<h1><a class="header" href="#arc" id="arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> 允许通过 <code>Arc::clone</code> 实现共享只读权限：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::sync::Arc;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Arc</code> 代表“原子引用计数”，它是使用原子操作的 <code>Rc</code> 的 线程安全版本。</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> 在执行原子操作方面有开销，但在此之后，<code>T</code> 便可 随意使用，而没有任何开销。</li>
<li>请警惕引用循环，<code>Arc</code> 不会使用垃圾回收器检测引用循环。
<ul>
<li><code>std::sync::Weak</code> 对此有所帮助。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#互斥器-mutex" id="互斥器-mutex"><code>互斥器 (Mutex)</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> 能够确保互斥，并允许对只读接口 后面的 <code>T</code> 进行可变访问：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>请注意我们如何设置 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> 通用 实现。</p>
<details>
<ul>
<li>Rust 中的互斥器看起来就像只包含一个元素的集合，其中的元素就是受保护的数据。
<ul>
<li>在访问受保护的数据之前不可能忘记获取互斥量。</li>
</ul>
</li>
<li>你可以通过获取锁，从 <code>&amp;Mutex&lt;T&gt;</code> 中获取 <code>&amp;mut T</code>。<code>MutexGuard</code> 能够确保 <code>&amp;mut T</code> 存在的时间不会比持有锁的时间更长。</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff (if and only if) <code>T</code> implements <code>Send</code>.</li>
<li>读写锁版本 - <code>RwLock</code>。</li>
<li>为什么 <code>lock()</code> 会返回 <code>Result</code>？
<ul>
<li>如果持有 <code>Mutex</code> 的线程发生panic，<code>Mutex</code> 便会“中毒”并发出信号， 表明其所保护的数据可能处于不一致状态。对中毒的互斥量调用 <code>lock()</code> 将会失败， 并将显示 <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>。无论如何，你可以对该错误调用 <code>into_inner()</code> 来 恢复数据。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#示例-2" id="示例-2">示例</a></h1>
<p>让我们看看 <code>Arc</code> 和 <code>Mutex</code> 的实际效果：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>可能有用的解决方案：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<p>值得注意的部分：</p>
<ul>
<li><code>Arc</code> 和 <code>Mutex</code> 中都封装了 <code>v</code>，因为它们的关注点是正交的。
<ul>
<li>将 <code>Mutex</code> 封装在 <code>Arc</code> 中是一种在线程之间共享可变状态的常见模式。</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> 必须先克隆为 <code>v2</code>，然后才能移动到另一个线程中。请注意，lambda 签名中添加了 <code>move</code>。</li>
<li>我们引入了块，以尽可能缩小 <code>LockGuard</code> 的作用域。</li>
</ul>
</details><h1><a class="header" href="#习题-3" id="习题-3">习题</a></h1>
<p>Let us practice our new concurrency skills with</p>
<ul>
<li>
<p>Dining philosophers: a classic problem in concurrency.</p>
</li>
<li>
<p>Multi-threaded link checker: a larger project where you’ll use Cargo to download dependencies and then check links in parallel.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#哲学家就餐问题-dining-philosophers-problem" id="哲学家就餐问题-dining-philosophers-problem">哲学家就餐问题 (Dining philosophers problem)</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their own place at the table. There is a fork between each plate. The dish served is a kind of spaghetti which has to be eaten with two forks. Each philosopher can only alternately think and eat. Moreover, a philosopher can only eat their spaghetti when they have both a left and right fork. Thus two forks will only be available when their two nearest neighbors are thinking, not eating. After an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="exercises/concurrency/../../cargo/running-locally.html">Cargo installation</a> for this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}
</code></pre></pre>
<p>You can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<h1><a class="header" href="#多线程链接检查器" id="多线程链接检查器">多线程链接检查器</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should start at a webpage and check that links on the page are valid. It should recursively check other pages on the same domain and keep doing this until all pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. Create a new Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the <code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>You will also need a way to find links. We can use <a href="https://docs.rs/scraper/"><code>scraper</code></a> for that:</p>
<pre><code class="language-shell">cargo add scraper
</code></pre>
<p>Finally, we’ll need some way of handling errors. We use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> for that:</p>
<pre><code class="language-shell">cargo add thiserror
</code></pre>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;link-checker&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>You can now download the start page. Try with a small site such as <code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2><a class="header" href="#任务" id="任务">任务</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the <code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you don’t end up being blocked by the site.</li>
</ul>
<h1><a class="header" href="#async-rust" id="async-rust">Async Rust</a></h1>
<p>“Async” is a concurrency model where multiple tasks are executed concurrently by executing each task until it would block, then switching to another task that is ready to make progress. The model allows running a larger number of tasks on a limited number of threads. This is because the per-task overhead is typically very low and operating systems provide primitives for efficiently identifying I/O that is able to proceed.</p>
<p>Rust’s asynchronous operation is based on “futures”, which represent work that may be completed in the future. Futures are “polled” until they signal that they are complete.</p>
<p>Futures are polled by an async runtime, and several different runtimes are available.</p>
<h2><a class="header" href="#comparisons" id="comparisons">Comparisons</a></h2>
<ul>
<li>
<p>Python has a similar model in its <code>asyncio</code>. However, its <code>Future</code> type is callback-based, and not polled. Async Python programs require a “loop”, similar to a runtime in Rust.</p>
</li>
<li>
<p>JavaScript’s <code>Promise</code> is similar, but again callback-based. The language runtime implements the event loop, so many of the details of Promise resolution are hidden.</p>
</li>
</ul>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>从高层次上看，异步 Rust 代码与“正常”的顺序代码非常类似：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count is: {i}!&quot;);
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>
<p>请注意，这只是一个简单的示例，用于展示语法。其中没有长时间运行的操作或任何真正的并发！</p>
</li>
<li>
<p>异步调用的返回类型是什么？</p>
<ul>
<li>在 <code>main</code> 中使用 <code>let future: () = async_main(10);</code> 来查看类型。</li>
</ul>
</li>
<li>
<p>“async” 关键字是语法糖。编译器会将返回类型替换为 future。</p>
</li>
<li>
<p>你不能将 <code>main</code> 声明为异步函数，除非在编译器中加入额外的指令来告诉它如何使用返回的 future。</p>
</li>
<li>
<p>你需要一个执行器来运行异步代码。<code>block_on</code>会阻塞当前线程，直到提供的future完成为止。 </p>
</li>
<li>
<p><code>.await</code> 会异步地等待另一个操作的完成。与 <code>block_on</code> 不同，<code>.await</code> 不会阻塞当前线程。</p>
</li>
<li>
<p><code>.await</code> 只能在 <code>async</code> 函数（或块，这些稍后会介绍）中使用。 </p>
</li>
</ul>
</details><h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> is a trait, implemented by objects that represent an operation that may not be complete yet. A future can be polled, and <code>poll</code> returns a <a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>An async function returns an <code>impl Future</code>. It’s also possible (but uncommon) to implement <code>Future</code> for your own types. For example, the <code>JoinHandle</code> returned from <code>tokio::spawn</code> implements <code>Future</code> to allow joining to it.</p>
<p>The <code>.await</code> keyword, applied to a Future, causes the current async function to pause until that Future is ready, and then evaluates to its output.</p>
<details>
<ul>
<li>
<p>The <code>Future</code> and <code>Poll</code> types are implemented exactly as shown; click the links to show the implementations in the docs.</p>
</li>
<li>
<p>We will not get to <code>Pin</code> and <code>Context</code>, as we will focus on writing async code, rather than building new async primitives. Briefly:</p>
<ul>
<li>
<p><code>Context</code> allows a Future to schedule itself to be polled again when an event occurs.</p>
</li>
<li>
<p><code>Pin</code> ensures that the Future isn’t moved in memory, so that pointers into that future remain valid. This is required to allow references to remain valid after an <code>.await</code>.</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#runtimes" id="runtimes">Runtimes</a></h1>
<p>A <em>runtime</em> provides support for performing operations asynchronously (a <em>reactor</em>) and is responsible for executing futures (an <em>executor</em>). Rust does not have a “built-in” runtime, but several options are available:</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>: performant, with a well-developed ecosystem of functionality like <a href="https://hyper.rs/">Hyper</a> for HTTP or <a href="https://github.com/hyperium/tonic">Tonic</a> for gRPC.</li>
<li><a href="https://async.rs/">async-std</a>: aims to be a “std for async”, and includes a basic runtime in <code>async::task</code>.</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>: simple and lightweight</li>
</ul>
<p>Several larger applications have their own runtimes. For example, <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a> already has one.</p>
<details>
<ul>
<li>
<p>Note that of the listed runtimes, only Tokio is supported in the Rust playground. The playground also does not permit any I/O, so most interesting async things can’t run in the playground.</p>
</li>
<li>
<p>Futures are “inert” in that they do not do anything (not even start an I/O operation) unless there is an executor polling them. This differs from JS Promises, for example, which will run to completion even if they are never used.</p>
</li>
</ul>
</details><h1><a class="header" href="#tokio" id="tokio">Tokio</a></h1>
<p>Tokio provides: </p>
<ul>
<li>A multi-threaded runtime for executing asynchronous code.</li>
<li>An asynchronous version of the standard library.</li>
<li>A large ecosystem of libraries.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::time;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count in task: {i}!&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 1..5 {
        println!(&quot;Main task: {i}&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>With the <code>tokio::main</code> macro we can now make <code>main</code> async.</p>
</li>
<li>
<p>The <code>spawn</code> function creates a new, concurrent “task”.</p>
</li>
<li>
<p>Note: <code>spawn</code> takes a <code>Future</code>, you don’t call <code>.await</code> on <code>count_to</code>.</p>
</li>
</ul>
<p><strong>Further exploration:</strong></p>
<ul>
<li>
<p>Why does <code>count_to</code> not (usually) get to 10? This is an example of async cancellation. <code>tokio::spawn</code> returns a handle which can be awaited to wait until it finishes.</p>
</li>
<li>
<p>Try <code>count_to(10).await</code> instead of spawning.</p>
</li>
<li>
<p>Try awaiting the task returned from <code>tokio::spawn</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#任务-1" id="任务-1">任务</a></h1>
<p>Rust has a task system, which is a form of lightweight threading.</p>
<p>A task has a single top-level future which the executor polls to make progress. That future may have one or more nested futures that its <code>poll</code> method polls, corresponding loosely to a call stack. Concurrency within a task is possible by polling multiple child futures, such as racing a timer and an I/O operation.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:6142&quot;).await?;
	println!(&quot;listening on port 6142&quot;);

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!(&quot;connection from {addr:?}&quot;);

        tokio::spawn(async move {
            if let Err(e) = socket.write_all(b&quot;Who are you?\n&quot;).await {
                println!(&quot;socket error: {e:?}&quot;);
                return;
            }

            let mut buf = vec![0; 1024];
            let reply = match socket.read(&amp;mut buf).await {
                Ok(n) =&gt; {
                    let name = std::str::from_utf8(&amp;buf[..n]).unwrap().trim();
                    format!(&quot;Thanks for dialing in, {name}!\n&quot;)
                }
                Err(e) =&gt; {
                    println!(&quot;socket error: {e:?}&quot;);
                    return;
                }
            };

            if let Err(e) = socket.write_all(reply.as_bytes()).await {
                println!(&quot;socket error: {e:?}&quot;);
            }
        });
    }
}
</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>Ask students to visualize what the state of the example server would be with a few connected clients. What tasks exist? What are their Futures?</p>
</li>
<li>
<p>This is the first time we’ve seen an <code>async</code> block. This is similar to a closure, but does not take any arguments. Its return value is a Future, similar to an <code>async fn</code>. </p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using <code>?</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#异步通道" id="异步通道">异步通道</a></h1>
<p>Several crates have support for asynchronous channels. For instance <code>tokio</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc::{self, Receiver};

async fn ping_handler(mut input: Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!(&quot;Received {count} pings so far.&quot;);
    }

    println!(&quot;ping_handler complete&quot;);
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect(&quot;Failed to send ping.&quot;);
        println!(&quot;Sent {} pings so far.&quot;, i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect(&quot;Something went wrong in ping handler task.&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Change the channel size to <code>3</code> and see how it affects the execution.</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the <a href="async/concurrency/channels.html">morning class</a>.</p>
</li>
<li>
<p>Try removing the <code>std::mem::drop</code> call. What happens? Why?</p>
</li>
<li>
<p>The <a href="https://docs.rs/flume/latest/flume/">Flume</a> crate has channels that implement both <code>sync</code> and <code>async</code> <code>send</code> and <code>recv</code>. This can be convenient for complex applications with both IO and heavy CPU processing tasks.</p>
</li>
<li>
<p>What makes working with <code>async</code> channels preferable is the ability to combine them with other <code>future</code>s to combine them and create complex control flow.</p>
</li>
</ul>
</details><h1><a class="header" href="#futures-control-flow" id="futures-control-flow">Futures Control Flow</a></h1>
<p>Futures can be combined together to produce concurrent compute flow graphs. We have already seen tasks, that function as independent threads of execution.</p>
<ul>
<li><a href="async/control-flow/join.html">Join</a></li>
<li><a href="async/control-flow/select.html">Select</a></li>
</ul>
<h1><a class="header" href="#加入" id="加入">加入</a></h1>
<p>A join operation waits until all of a set of futures are ready, and returns a collection of their results. This is similar to <code>Promise.all</code> in JavaScript or <code>asyncio.gather</code> in Python.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        &quot;https://google.com&quot;,
        &quot;https://httpbin.org/ip&quot;,
        &quot;https://play.rust-lang.org/&quot;,
        &quot;BAD_URL&quot;,
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(&quot;{:?}&quot;, page_sizes_dict);
}
</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>For multiple futures of disjoint types, you can use <code>std::future::join!</code> but you must know how many futures you will have at compile time. This is currently in the <code>futures</code> crate, soon to be stabilised in <code>std::future</code>.</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would cause your program to stall. </p>
</li>
<li>
<p>You can also combine <code>join_all</code> with <code>join!</code> for instance to join all requests to an http service as well as a database query. Try adding a <code>tokio::time::sleep</code> to the future, using <code>futures::join!</code>. This is not a timeout (that requires <code>select!</code>, explained in the next chapter), but demonstrates <code>join!</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#选择" id="选择">选择</a></h1>
<p>A select operation waits until any of a set of futures is ready, and responds to that future’s result. In JavaScript, this is similar to <code>Promise.race</code>. In Python, it compares to <code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>.</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each of the form <code>pattern = future =&gt; statement</code>. When the <code>future</code> is ready, the <code>statement</code> is executed with the variables in <code>pattern</code> bound to the <code>future</code>‘s result.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc::{self, Receiver};
use tokio::time::{sleep, Duration};

#[derive(Debug, PartialEq)]
enum Animal {
    Cat { name: String },
    Dog { name: String },
}

async fn first_animal_to_finish_race(
    mut cat_rcv: Receiver&lt;String&gt;,
    mut dog_rcv: Receiver&lt;String&gt;,
) -&gt; Option&lt;Animal&gt; {
    tokio::select! {
        cat_name = cat_rcv.recv() =&gt; Some(Animal::Cat { name: cat_name? }),
        dog_name = dog_rcv.recv() =&gt; Some(Animal::Dog { name: dog_name? })
    }
}

#[tokio::main]
async fn main() {
    let (cat_sender, cat_receiver) = mpsc::channel(32);
    let (dog_sender, dog_receiver) = mpsc::channel(32);
    tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        cat_sender
            .send(String::from(&quot;Felix&quot;))
            .await
            .expect(&quot;Failed to send cat.&quot;);
    });
    tokio::spawn(async move {
        sleep(Duration::from_millis(50)).await;
        dog_sender
            .send(String::from(&quot;Rex&quot;))
            .await
            .expect(&quot;Failed to send dog.&quot;);
    });

    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)
        .await
        .expect(&quot;Failed to receive winner&quot;);

    println!(&quot;Winner is {winner:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>In this example, we have a race between a cat and a dog. <code>first_animal_to_finish_race</code> listens to both channels and will pick whichever arrives first. Since the dog takes 50ms, it wins against the cat that take 500ms.</p>
</li>
<li>
<p>You can use <code>oneshot</code> channels in this example as the channels are supposed to receive only one <code>send</code>.</p>
</li>
<li>
<p>Try adding a deadline to the race, demonstrating selecting different sorts of futures.</p>
</li>
<li>
<p>Note that <code>select!</code> drops unmatched branches, which cancels their futures. It is easiest to use when every execution of <code>select!</code> creates new futures.</p>
<ul>
<li>An alternative is to pass <code>&amp;mut future</code> instead of the future itself, but this can lead to issues, further discussed in the pinning slide.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#pitfalls-of-asyncawait" id="pitfalls-of-asyncawait">Pitfalls of async/await</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent asynchronous programming. However, the async/await model in Rust also comes with its share of pitfalls and footguns. We illustrate some of them in this chapter:</p>
<ul>
<li><a href="async/pitfalls/blocking-executor.html">Blocking the Executor</a></li>
<li><a href="async/pitfalls/pin.html">Pin</a></li>
<li><a href="async/pitfalls/async-traits.html">Async Traits</a></li>
<li><a href="async/pitfalls/cancellation.html">Cancellation</a></li>
</ul>
<h1><a class="header" href="#blocking-the-executor" id="blocking-the-executor">Blocking the executor</a></h1>
<p>Most async runtimes only allow IO tasks to run concurrently. This means that CPU blocking tasks will block the executor and prevent other tasks from being executed. An easy workaround is to use async equivalent methods where possible.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        &quot;future {id} slept for {duration_ms}ms, finished after {}ms&quot;,
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Run the code and see that the sleeps happen consecutively rather than concurrently.</p>
</li>
<li>
<p>The <code>&quot;current_thread&quot;</code> flavor puts all tasks on a single thread. This makes the effect more obvious, but the bug is still present in the multi-threaded flavor.</p>
</li>
<li>
<p>Switch the <code>std::thread::sleep</code> to <code>tokio::time::sleep</code> and await its result.</p>
</li>
<li>
<p>Another fix would be to <code>tokio::task::spawn_blocking</code> which spawns an actual thread and transforms its handle into a future without blocking the executor.</p>
</li>
<li>
<p>You should not think of tasks as OS threads. They do not map 1 to 1 and most executors will allow many tasks to run on a single OS thread. This is particularly problematic when interacting with other libraries via FFI, where that library might depend on thread-local storage or map to specific OS threads (e.g., CUDA). Prefer <code>tokio::task::spawn_blocking</code> in such situations.</p>
</li>
<li>
<p>Use sync mutexes with care. Holding a mutex over an <code>.await</code> may cause another task to block, and that task may be running on the same thread.</p>
</li>
</ul>
</details><h1><a class="header" href="#固定" id="固定">固定</a></h1>
<p>When you await a future, all local variables (that would ordinarily be stored on a stack frame) are instead stored in the Future for the current async block. If your future has pointers to data on the stack, those pointers might get invalidated. This is unsafe.</p>
<p>Therefore, you must guarantee that the addresses your future points to don’t change. That is why we need to <code>pin</code> futures. Using the same future repeatedly in a <code>select!</code> often leads to issues with pinned values.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect(&quot;failed to send response&quot;);
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work {
            input,
            respond_on: tx,
        })
        .await
        .expect(&quot;failed to send on work queue&quot;);
    rx.await.expect(&quot;failed waiting for response&quot;)
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!(&quot;work result for iteration {i}: {resp}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>You may recognize this as an example of the actor pattern. Actors typically call <code>select!</code> in a loop.</p>
</li>
<li>
<p>This serves as a summation of a few of the previous lessons, so take your time with it.</p>
<ul>
<li>
<p>Naively add a <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code> to the <code>select!</code>. This will never execute. Why?</p>
</li>
<li>
<p>Instead, add a <code>timeout_fut</code> containing that future outside of the <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This still doesn’t work. Follow the compiler errors, adding <code>&amp;mut</code> to the <code>timeout_fut</code> in the <code>select!</code> to work around the move, then using <code>Box::pin</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every iteration (a fused future would help with this). Update to reset <code>timeout_fut</code> every time it expires.</p>
</li>
</ul>
</li>
<li>
<p>Box allocates on the heap. In some cases, <code>std::pin::pin!</code> (only recently stabilized, with older code often using <code>tokio::pin!</code>) is also an option, but that is difficult to use for a future that is reassigned.</p>
</li>
<li>
<p>Another alternative is to not use <code>pin</code> at all but spawn another task that will send to a <code>oneshot</code> channel every 100ms.</p>
</li>
</ul>
</details><h1><a class="header" href="#异步特质" id="异步特质">异步特质</a></h1>
<p>Async methods in traits are not yet supported in the stable channel (<a href="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html">An experimental feature exists in nightly and should be stabilized in the mid term.</a>)</p>
<p>The crate <a href="https://docs.rs/async-trait/latest/async_trait/">async_trait</a> provides a workaround through a macro:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;, n_times: usize) {
    for _ in 0..n_times {
        println!(&quot;running all sleepers..&quot;);
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!(&quot;slept for {}ms&quot;, start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}
</code></pre></pre>
<details>  
<ul>
<li>
<p><code>async_trait</code> is easy to use, but note that it’s using heap allocations to achieve this. This heap allocation has performance overhead.</p>
</li>
<li>
<p>对于 <code>async trait</code> 的语言支持中的挑战是深入  Rust的，并且可能不值得深入描述。如果您对深入了解感兴趣，Niko Matsakis 在<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">这篇文章</a>中对它们做了很好的解释。</p>
</li>
<li>
<p>尝试创建一个新的 sleeper 结构，使其随机休眠一段时间，并将其添加到 Vec 中。</p>
</li>
</ul>
</details><h1><a class="header" href="#cancellation" id="cancellation">Cancellation</a></h1>
<p>Dropping a future implies it can never be polled again. This is called <em>cancellation</em> and it can occur at any <code>await</code> point. Care is needed to ensure the system works correctly even when futures are cancelled. For example, it shouldn’t deadlock or lose data.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io::{self, ErrorKind};
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None)
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; std::io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy(&quot;hi\nthere\n&quot;.to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!(&quot;tick!&quot;),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!(&quot;{}&quot;, l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The compiler doesn’t help with cancellation-safety. You need to read API documentation and consider what state your <code>async fn</code> holds.</p>
</li>
<li>
<p>Unlike <code>panic</code> and <code>?</code>, cancellation is part of normal control flow (vs error-handling).</p>
</li>
<li>
<p>The example loses parts of the string.</p>
<ul>
<li>
<p>Whenever the <code>tick()</code> branch finishes first, <code>next()</code> and its <code>buf</code> are dropped.</p>
</li>
<li>
<p><code>LinesReader</code> can be made cancellation-safe by making <code>buf</code> part of the struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a> is cancellation-safe because it keeps track of whether a tick has been ‘delivered’.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a> is cancellation-safe because it either returns or doesn’t read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a> is similar to the example and <em>isn’t</em> cancellation-safe. See its documentation for details and alternatives.</p>
</li>
</ul>
</details><h1><a class="header" href="#习题-4" id="习题-4">习题</a></h1>
<p>为了练习您的异步 Rust 技能，我们再次为您提供了两个练习：</p>
<ul>
<li>
<p>哲学家进餐：我们已经在上午看到了这个问题。这次你将使用异步 Rust 来实现它。</p>
</li>
<li>
<p>广播聊天应用：这是一个更大的项目，允许您尝试更高级的异步Rust功能。</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#哲学家进餐---异步" id="哲学家进餐---异步">哲学家进餐 - 异步</a></h1>
<p>查看<a href="exercises/concurrency/dining-philosophers.html">哲学家进餐</a>以获取问题的描述。</p>
<p>与之前一样，您需要一个本地的 <a href="exercises/concurrency/../../cargo/running-locally.html">Cargo 安装</a>来进行这个练习。将下面的代码复制到一个名为 <code>src/main.rs</code> 的文件中，填写空白部分，并测试确保 <code>cargo run</code> 不会死锁：</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<p>因为这次您正在使用异步Rust，您将需要一个 <code>tokio</code> 依赖。您可以使用以下的 <code>Cargo.toml</code>：</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers-async-dine&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tokio = {version = &quot;1.26.0&quot;, features = [&quot;sync&quot;, &quot;time&quot;, &quot;macros&quot;, &quot;rt-multi-thread&quot;]}
</code></pre>
<p>另外，请注意，这次您必须使用来自 <code>tokio</code> 包的 <code>Mutex</code> 和 <code>mpsc</code> 模块。</p>
<details>
<ul>
<li>您可以使您的实现为单线程吗？</li>
</ul>
</details><h1><a class="header" href="#广播聊天应用程序" id="广播聊天应用程序">广播聊天应用程序</a></h1>
<p>在本练习中，我们想要使用我们的新知识来实现一个广播聊天应用。我们有一个聊天服务器，客户端连接到该服务器并发布他们的消息。客户端从标准输入读取用户消息，并将其发送到服务器。聊天服务器将收到的每条消息广播给所有客户端。</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and <a href="https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/"><code>tokio_websockets</code></a> for the communication between the client and the server.</p>
<p>创建一个新的 Cargo 项目并添加以下依赖：</p>
<p><em>Cargo.toml</em>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;chat-async&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
futures-util = { version = &quot;0.3.28&quot;, features = [&quot;sink&quot;] }
http = &quot;0.2.9&quot;
tokio = { version = &quot;1.28.1&quot;, features = [&quot;full&quot;] }
tokio-websockets = { version = &quot;0.4.0&quot;, features = [&quot;client&quot;, &quot;fastrand&quot;, &quot;server&quot;, &quot;sha1_smol&quot;] }
</code></pre>
<h2><a class="header" href="#所需的api" id="所需的api">所需的API</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and <a href="https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the API. </p>
<ul>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next">StreamExt::next()</a> implemented by <code>WebsocketStream</code>: for asynchronously reading messages from a Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> 由<code>WebsocketStream</code>实现：用于在Websocket流上异步发送消息。</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages from the standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>：用于订阅广播频道。</li>
</ul>
<h2><a class="header" href="#两个可执行文件" id="两个可执行文件">两个可执行文件</a></h2>
<p>通常在一个Cargo项目中，你只能有一个二进制文件，和一个<code>src/main.rs</code>文件。在这个项目中，我们需要两个二进制文件。一个用于客户端，另一个用于服务器。你可能会考虑将它们制作成两个单独的Cargo项目，但我们将它们放在一个包含两个二进制文件的Cargo项目中。为了使这个工作，客户端和服务器的代码应该放在<code>src/bin</code>下（参见<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">文档</a>）。</p>
<p>将以下服务器和客户端代码分别复制到 <code>src/bin/server.rs</code> 和 <code>src/bin/client.rs</code> 中。您的任务是按照下面的描述完成这些文件。</p>
<p><em>src/bin/server.rs</em>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}
</code></pre></pre>
<h2><a class="header" href="#运行可执行文件" id="运行可执行文件">运行可执行文件</a></h2>
<p>使用以下命令运行服务器：</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2><a class="header" href="#任务-2" id="任务-2">任务</a></h2>
<ul>
<li>在 <code>src/bin/server.rs</code> 中实现 <code>handle_connection</code> 函数。
<ul>
<li>提示：使用 <code>tokio::select!</code> 在一个连续的循环中并发执行两个任务。一个任务从客户端接收消息并广播它们。另一个任务将服务器接收到的消息发送给客户端。</li>
</ul>
</li>
<li>完成 <code>src/bin/client.rs</code> 中的 <code>main</code> 函数。
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently performing two tasks: (1) reading user messages from standard input and sending them to the server, and (2) receiving messages from the server, and displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all clients, but the sender of the message.</li>
</ul>
<h1><a class="header" href="#谢谢" id="谢谢">谢谢！</a></h1>
<p><em>Thank you for taking Comprehensive Rust 🦀!</em> We hope you enjoyed it and that it was useful.</p>
<p>We’ve had a lot of fun putting the course together. The course is not perfect, so if you spotted any mistakes or have ideas for improvements, please get in <a href="https://github.com/google/comprehensive-rust/discussions">contact with us on GitHub</a>. We would love to hear from you.</p>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>The following is a glossary which aims to give a short definition of many Rust terms. For translations, this also serves to connect the term back to the English original.</p>
<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>
<!--
Translators: please add the English term in italic after your translated term.
Also, please keep the hard line breaks to ensure a nice formatting.
-->
<ul>
<li>allocate:<br />
Dynamic memory allocation on <a href="memory-management/stack-vs-heap.html">the heap</a>.</li>
<li>argument:</li>
<li>Bare-metal Rust: See <a href="bare-metal.html">Bare-metal Rust</a>.</li>
<li>block:<br />
See <a href="control-flow/blocks.html">Blocks</a> and <em>scope</em>.</li>
<li>borrow:<br />
See <a href="ownership/borrowing.html">Borrowing</a>.</li>
<li>borrow checker:<br />
The part of the Rust compiler which checks that all borrows are valid.</li>
<li>brace:<br />
<code>{</code> and <code>}</code>. Also called <em>curly brace</em>, they delimit <em>blocks</em>.</li>
<li>build:</li>
<li>call:</li>
<li>channel:<br />
Used to safely pass messages <a href="concurrency/channels.html">between threads</a>.</li>
<li>Comprehensive Rust 🦀:<br />
The courses here are jointly called Comprehensive Rust 🦀.</li>
<li>concurrency:</li>
<li>Concurrency in Rust:<br />
See <a href="concurrency.html">Concurrency in Rust</a>.</li>
<li>constant:</li>
<li>control flow:</li>
<li>crash:</li>
<li>enumeration:</li>
<li>error:</li>
<li>error handling:</li>
<li>exercise:</li>
<li>function:</li>
<li>garbage collector:</li>
<li>generics:</li>
<li>immutable:</li>
<li>integration test:</li>
<li>keyword:</li>
<li>library:</li>
<li>macro:</li>
<li>main function:</li>
<li>match:</li>
<li>memory leak:</li>
<li>method:</li>
<li>module:</li>
<li>move:</li>
<li>mutable:</li>
<li>ownership:</li>
<li>panic:</li>
<li>parameter:</li>
<li>pattern:</li>
<li>payload:</li>
<li>program:</li>
<li>programming language:</li>
<li>receiver:</li>
<li>reference counting:</li>
<li>return:</li>
<li>Rust:</li>
<li>Rust Fundamentals:<br />
Days 1 to 3 of this course.</li>
<li>Rust in Android:<br />
See <a href="android.html">Rust in Android</a>.</li>
<li>safe:</li>
<li>scope:</li>
<li>standard library:</li>
<li>static:</li>
<li>string:</li>
<li>struct:</li>
<li>test:</li>
<li>thread:</li>
<li>thread safety:</li>
<li>trait:</li>
<li>type:</li>
<li>type inference:</li>
<li>undefined behavior:</li>
<li>union:</li>
<li>unit test:</li>
<li>unsafe:</li>
<li>variable:\</li>
</ul>
<h1><a class="header" href="#其他-rust-资源" id="其他-rust-资源">其他 Rust 资源</a></h1>
<p>Rust 社区已经创造了丰富的高质量免费资源在线提供。</p>
<h2><a class="header" href="#官方文档" id="官方文档">官方文档</a></h2>
<p>Rust 项目提供了许多资源。这些资源涵盖了 Rust 的一般内容：</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>: the canonical free book about Rust. Covers the language in detail and includes a few projects for people to build.</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>: covers the Rust syntax via a series of examples which showcase different constructs. Sometimes includes small exercises where you are asked to expand on the code in the examples.</li>
<li><a href="https://doc.rust-lang.org/std/">Rust Standard Library</a>: full documentation of the standard library for Rust.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust Reference</a>: an incomplete book which describes the Rust grammar and memory model.</li>
</ul>
<p>More specialized guides hosted on the official Rust site:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>: covers unsafe Rust, including working with raw pointers and interfacing with other languages (FFI).</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>: covers the new asynchronous programming model which was introduced after the Rust Book was written.</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">The Embedded Rust Book</a>: an introduction to using Rust on embedded devices without an operating system.</li>
</ul>
<h2><a class="header" href="#非官方学习资料" id="非官方学习资料">非官方学习资料</a></h2>
<p>其他 Rust 指南和教程的小选集：</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way</a>: covers Rust from the perspective of low-level C programmers.</li>
<li><a href="https://docs.opentitan.org/doc/ug/rust_for_c/">Rust for Embedded C Programmers</a>: covers Rust from the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionals</a>: covers the syntax of Rust using side-by-side comparisons with other languages such as C, C++, Java, JavaScript, and Python.</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism</a>: 100+ exercises to help you learn Rust.</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching Material</a>: a series of small presentations covering both basic and advanced part of the Rust language. Other topics such as WebAssembly, and async/await are also covered.</li>
<li><a href="https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/">Beginner’s Series to Rust</a> and <a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Take your first steps with Rust</a>: two Rust guides aimed at new developers. The first is a set of 35 videos and the second is a set of 11 modules which covers Rust syntax and basic constructs.</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>: in-depth exploration of Rust’s memory management rules, through implementing a few different types of list structures.</li>
</ul>
<p>Please see the <a href="https://lborb.github.io/book/">Little Book of Rust Books</a> for even more Rust books.</p>
<h1><a class="header" href="#鸣谢" id="鸣谢">鸣谢</a></h1>
<p>本课中的资料以众多优秀的 Rust 文档资源为基础。 如需查看实用资源的完整列表， 请参阅关于<a href="other-resources.html">其他资源</a>的页面。</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0 license, please see <a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for details.</p>
<h2><a class="header" href="#rust-示例" id="rust-示例">Rust 示例</a></h2>
<p>部分示例和练习复制并 改编自<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>。如需了解详情（包括许可 条款），请参阅 <code>third_party/rust-by-example/</code> 目录。</p>
<h2><a class="header" href="#rust-on-exercism" id="rust-on-exercism">Rust on Exercism</a></h2>
<p>部分练习复制并 改编自 <a href="https://exercism.org/tracks/rust">Rust on Exercism</a>。如需了解详情（包括许可 条款），请参阅 <code>third_party/rust-on-exercism/</code> 目录。</p>
<h2><a class="header" href="#cxx" id="cxx">CXX</a></h2>
<p>“<a href="android/interoperability/cpp.html">与 C++ 的互操作性</a>”部分引用了一张 来自 <a href="https://cxx.rs/">CXX</a> 的图片。如需了解详情（包括许可条款）， 请参阅 <code>third_party/cxx/</code> 目录。</p>
<h2><a class="header" href="#an-example-in-c-1" id="an-example-in-c-1">An Example in C</a></h2>
<p>The <a href="why-rust/an-example-in-c.html">Why Rust? - An Example in C</a> section has been taken from the presentation slides of <a href="https://colinfinck.de/Master_Thesis_Colin_Finck.pdf">Colin Finck’s Master Thesis</a>. It has been relicensed under the terms of the Apache 2.0 license for this course by the author.</p>
<h1><a class="header" href="#解答" id="解答">解答</a></h1>
<p>您将在下面的页面找到练习的解答。</p>
<p>欢迎您在 <a href="https://github.com/google/comprehensive-rust/discussions">GitHub</a> 上提问关于解决方案的问题。如果您有与此处呈现的不同或更好的解决方案，请告诉我们。</p>
<h1><a class="header" href="#第一天上午的练习" id="第一天上午的练习">第一天上午的练习</a></h1>
<h2><a class="header" href="#数组与-for-循环-1" id="数组与-for-循环-1">数组与 <code>for</code> 循环</a></h2>
<p>(<a href="exercises/day-1/for-loops.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    for row in matrix {
        println!(&quot;{row:?}&quot;);
    }
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h3><a class="header" href="#附加问题" id="附加问题">附加问题</a></h3>
<p>这需要更高级的概念。看起来，我们可以使用切片的切片（<code>&amp;[&amp;[i32]]</code>）作为输入类型来进行转置，从而使我们的函数能够处理任意大小的矩阵。然而，这很快就会崩溃：返回类型不能是 <code>&amp;[&amp;[i32]]</code>，因为它需要拥有您返回的数据。</p>
<p>您可以尝试使用类似 <code>Vec&lt;Vec&lt;i32&gt;&gt;</code> 的方式，但这也无法直接工作：从 <code>Vec&lt;Vec&lt;i32&gt;&gt;</code> 转换为 <code>&amp;[&amp;[i32]]</code> 很困难，因此您现在也不能轻松使用 <code>pretty_print</code>。</p>
<p>Once we get to traits and generics, we’ll be able to use the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>std::convert::AsRef</code></a> trait to abstract over anything that can be referenced as a slice.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::AsRef;
use std::fmt::Debug;

fn pretty_print&lt;T, Line, Matrix&gt;(matrix: Matrix)
where
    T: Debug,
    // A line references a slice of items
    Line: AsRef&lt;[T]&gt;,
    // A matrix references a slice of lines
    Matrix: AsRef&lt;[Line]&gt;
{
    for row in matrix.as_ref() {
        println!(&quot;{:?}&quot;, row.as_ref());
    }
}

fn main() {
    // &amp;[&amp;[i32]]
    pretty_print(&amp;[&amp;[1, 2, 3], &amp;[4, 5, 6], &amp;[7, 8, 9]]);
    // [[&amp;str; 2]; 2]
    pretty_print([[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]);
    // Vec&lt;Vec&lt;i32&gt;&gt;
    pretty_print(vec![vec![1, 2], vec![3, 4]]);
}
</code></pre></pre>
<p>此外，类型本身不会强制要求子切片具有相同的长度，因此这样的变量可能包含一个无效的矩阵。</p>
<h1><a class="header" href="#第一天下午的练习" id="第一天下午的练习">第一天下午的练习</a></h1>
<h2><a class="header" href="#luhn-算法-1" id="luhn-算法-1">Luhn 算法</a></h2>
<p>(<a href="exercises/day-1/luhn.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut digits_seen = 0;
    let mut sum = 0;
    for (i, ch) in cc_number.chars().rev().filter(|&amp;ch| ch != ' ').enumerate() {
        match ch.to_digit(10) {
            Some(d) =&gt; {
                sum += if i % 2 == 1 {
                    let dd = d * 2;
                    dd / 10 + dd % 10
                } else {
                    d
                };
                digits_seen += 1;
            }
            None =&gt; return false,
        }
    }

    if digits_seen &lt; 2 {
        return false;
    }

    sum % 10 == 0
}

fn main() {
    let cc_number = &quot;1234 5678 1234 5670&quot;;
    println!(
        &quot;Is {cc_number} a valid credit card number? {}&quot;,
        if luhn(cc_number) { &quot;yes&quot; } else { &quot;no&quot; }
    );
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
    assert!(!luhn(&quot;foo 0 0&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h2>
<pre><pre class="playground"><code class="language-rust">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op {
        op: Operation,
        left: Box&lt;Expression&gt;,
        right: Box&lt;Expression&gt;,
    },

    /// A literal value
    Value(i64),
}

/// The result of evaluating an expression.
#[derive(Debug, PartialEq, Eq)]
enum Res {
    /// Evaluation was successful, with the given result.
    Ok(i64),
    /// Evaluation failed, with the given error message.
    Err(String),
}
// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.
use Res::{Err, Ok};

fn eval(e: Expression) -&gt; Res {
    match e {
        Expression::Op { op, left, right } =&gt; {
            let left = match eval(*left) {
                Ok(v) =&gt; v,
                Err(msg) =&gt; return Err(msg),
            };
            let right = match eval(*right) {
                Ok(v) =&gt; v,
                Err(msg) =&gt; return Err(msg),
            };
            Ok(match op {
                Operation::Add =&gt; left + right,
                Operation::Sub =&gt; left - right,
                Operation::Mul =&gt; left * right,
                Operation::Div =&gt; {
                    if right == 0 {
                        return Err(String::from(&quot;division by zero&quot;));
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) =&gt; Ok(v),
    }
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
fn main() {
    let expr = Expression::Op {
        op: Operation::Sub,
        left: Box::new(Expression::Value(20)),
        right: Box::new(Expression::Value(10)),
    };
    println!(&quot;expr: {:?}&quot;, expr);
    println!(&quot;result: {:?}&quot;, eval(expr));
}
</code></pre></pre>
<h1><a class="header" href="#第二天上午的练习" id="第二天上午的练习">第二天上午的练习</a></h1>
<h2><a class="header" href="#设计一个库" id="设计一个库">设计一个库</a></h2>
<p>(<a href="exercises/day-2/book-library.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Notice how the `self` parameter
// changes type to indicate the method's required level of ownership
// over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {

    fn new() -&gt; Library {
        Library { books: Vec::new() }
    }

    fn len(&amp;self) -&gt; usize {
        self.books.len()
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.books.is_empty()
    }

    fn add_book(&amp;mut self, book: Book) {
        self.books.push(book)
    }

    fn print_books(&amp;self) {
        for book in &amp;self.books {
            println!(&quot;{}, published in {}&quot;, book.title, book.year);
        }
    }

    fn oldest_book(&amp;self) -&gt; Option&lt;&amp;Book&gt; {
        // Using a closure and a built-in method:
        // self.books.iter().min_by_key(|book| book.year)

        // Longer hand-written solution:
        let mut oldest: Option&lt;&amp;Book&gt; = None;
        for book in self.books.iter() {
            if oldest.is_none() || book.year &lt; oldest.unwrap().year {
                oldest = Some(book);
            }
        }

        oldest
    }
}

fn main() {
    let mut library = Library::new();

    println!(
        &quot;The library is empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));

    println!(
        &quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.print_books();

    match library.oldest_book() {
        Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
        None =&gt; println!(&quot;The library is empty!&quot;),
    }

    println!(&quot;The library has {} books&quot;, library.len());
    library.print_books();
}

#[test]
fn test_library_len() {
    let mut library = Library::new();
    assert_eq!(library.len(), 0);
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(library.len(), 2);
    assert!(!library.is_empty());
}

#[test]
fn test_library_is_empty() {
    let mut library = Library::new();
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert!(!library.is_empty());
}

#[test]
fn test_library_print_books() {
    let mut library = Library::new();
    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    // We could try and capture stdout, but let us just call the
    // method to start with.
    library.print_books();
}

#[test]
fn test_library_oldest_book() {
    let mut library = Library::new();
    assert!(library.oldest_book().is_none());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Lord of the Rings&quot;)
    );

    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Alice's Adventures in Wonderland&quot;)
    );
}
</code></pre></pre>
<h2><a class="header" href="#健康统计-1" id="健康统计-1">健康统计</a></h2>
<p>(<a href="exercises/day-2/health-statistics.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust">pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self {
            name,
            age,
            height,
            visit_count: 0,
            last_blood_pressure: None,
        }
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    pub fn age(&amp;self) -&gt; u32 {
        self.age
    }

    pub fn height(&amp;self) -&gt; f32 {
        self.height
    }

    pub fn doctor_visits(&amp;self) -&gt; u32 {
        self.visit_count as u32
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        self.age = new_age
    }

    pub fn set_height(&amp;mut self, new_height: f32) {
        self.height = new_height
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &amp;self.name,
            visit_count: self.visit_count as u32,
            height_change: measurements.height - self.height,
            blood_pressure_change: match self.last_blood_pressure {
                Some(lbp) =&gt; Some((
                    bp.0 as i32 - lbp.0 as i32,
                    bp.1 as i32 - lbp.1 as i32
                )),
                None =&gt; None,
            }
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_height() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.height(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.doctor_visits(), 0);
    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (120, 80),
    });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);

    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (115, 76),
    });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
}
</code></pre></pre>
<h1><a class="header" href="#第二天下午的练习" id="第二天下午的练习">第二天下午的练习</a></h1>
<h2><a class="header" href="#字符串和迭代器-1" id="字符串和迭代器-1">字符串和迭代器</a></h2>
<p>(<a href="exercises/day-2/strings-iterators.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {

    let mut request_segments = request_path.split('/');

    for prefix_segment in prefix.split('/') {
        let Some(request_segment) = request_segments.next() else {
            return false;
        };
        if request_segment != prefix_segment &amp;&amp; prefix_segment != &quot;*&quot; {
            return false;
        }
    }
    true

    // Alternatively, Iterator::zip() lets us iterate simultaneously over prefix
    // and request segments. The zip() iterator is finished as soon as one of
    // the source iterators is finished, but we need to iterate over all request
    // segments. A neat trick that makes zip() work is to use map() and chain()
    // to produce an iterator that returns Some(str) for each pattern segments,
    // and then returns None indefinitely.
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#第三天上午的练习" id="第三天上午的练习">第三天上午的练习</a></h1>
<h2><a class="header" href="#drawing-a-simple-gui-1" id="drawing-a-simple-gui-1">Drawing A Simple GUI</a></h2>
<p>(<a href="exercises/day-3/simple-gui.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button {
            label: Label::new(label),
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}


impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        self.label
            .lines()
            .map(|line| line.chars().count())
            .max()
            .unwrap_or(0)
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;
    )));
    window.draw();
}
</code></pre></pre>
<h2><a class="header" href="#点和多边形" id="点和多边形">点和多边形</a></h2>
<p>(<a href="exercises/day-3/points-polygons.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Point {
    x: i32,
    y: i32,
}

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }

    pub fn magnitude(self) -&gt; f64 {
        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()
    }

    pub fn dist(self, other: Point) -&gt; f64 {
        (self - other).magnitude()
    }
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Sub for Point {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

pub struct Polygon {
    points: Vec&lt;Point&gt;,
}

impl Polygon {
    pub fn new() -&gt; Polygon {
        Polygon { points: Vec::new() }
    }

    pub fn add_point(&amp;mut self, point: Point) {
        self.points.push(point);
    }

    pub fn left_most_point(&amp;self) -&gt; Option&lt;Point&gt; {
        self.points.iter().min_by_key(|p| p.x).copied()
    }

    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Point&gt; {
        self.points.iter()
    }

    pub fn length(&amp;self) -&gt; f64 {
        if self.points.is_empty() {
            return 0.0;
        }

        let mut result = 0.0;
        let mut last_point = self.points[0];
        for point in &amp;self.points[1..] {
            result += last_point.dist(*point);
            last_point = *point;
        }
        result += last_point.dist(self.points[0]);
        result
        // Alternatively, Iterator::zip() lets us iterate over the points as pairs
        // but we need to pair each point with the next one, and the last point
        // with the first point. The zip() iterator is finished as soon as one of 
        // the source iterators is finished, a neat trick is to combine Iterator::cycle
        // with Iterator::skip to create the second iterator for the zip and using map 
        // and sum to calculate the total length.
    }
}

pub struct Circle {
    center: Point,
    radius: i32,
}

impl Circle {
    pub fn new(center: Point, radius: i32) -&gt; Circle {
        Circle { center, radius }
    }

    pub fn circumference(&amp;self) -&gt; f64 {
        2.0 * std::f64::consts::PI * f64::from(self.radius)
    }

    pub fn dist(&amp;self, other: &amp;Self) -&gt; f64 {
        self.center.dist(other.center)
    }
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

impl From&lt;Polygon&gt; for Shape {
    fn from(poly: Polygon) -&gt; Self {
        Shape::Polygon(poly)
    }
}

impl From&lt;Circle&gt; for Shape {
    fn from(circle: Circle) -&gt; Self {
        Shape::Circle(circle)
    }
}

impl Shape {
    pub fn perimeter(&amp;self) -&gt; f64 {
        match self {
            Shape::Polygon(poly) =&gt; poly.length(),
            Shape::Circle(circle) =&gt; circle.circumference(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#第三天下午的练习" id="第三天下午的练习">第三天下午的练习</a></h1>
<h2><a class="header" href="#安全-ffi-封装容器-1" id="安全-ffi-封装容器-1">安全 FFI 封装容器</a></h2>
<p>(<a href="exercises/day-3/safe-ffi-wrapper.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust">mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        let path = CString::new(path).map_err(|err| format!(&quot;Invalid path: {err}&quot;))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!(&quot;Could not open {:?}&quot;, path))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        if !self.dir.is_null() {
            // SAFETY: self.dir is not NULL.
            if unsafe { ffi::closedir(self.dir) } != 0 {
                panic!(&quot;Could not close {:?}&quot;, self.path);
            }
        }
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new(&quot;no-such-directory&quot;);
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join(&quot;foo.txt&quot;), &quot;The Foo Diaries\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;bar.png&quot;), &quot;&lt;PNG&gt;\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;crab.rs&quot;), &quot;//! Crab\n&quot;)?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;, &quot;bar.png&quot;, &quot;crab.rs&quot;, &quot;foo.txt&quot;]);
        Ok(())
    }
}
</code></pre></pre>
<h1><a class="header" href="#bare-metal-rust-morning-exercise" id="bare-metal-rust-morning-exercise">Bare Metal Rust Morning Exercise</a></h1>
<h2><a class="header" href="#罗盘-1" id="罗盘-1">罗盘</a></h2>
<p>(<a href="exercises/bare-metal/compass.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use core::cmp::{max, min};
use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};
use microbit::display::blocking::Display;
use microbit::hal::prelude::*;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::Timer;
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    writeln!(serial, &quot;Setting up IMU...&quot;).unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();
    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        while !(imu.mag_status().unwrap().xyz_new_data
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data)
        {}
        let compass_reading = imu.mag_data().unwrap();
        let accelerometer_reading = imu.accel_data().unwrap();
        writeln!(
            serial,
            &quot;{},{},{}\t{},{},{}&quot;,
            compass_reading.x,
            compass_reading.y,
            compass_reading.z,
            accelerometer_reading.x,
            accelerometer_reading.y,
            accelerometer_reading.z,
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(
        min_out + range_out * (value - min_in) / range_in,
        min_out,
        max_out,
    )
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}
</code></pre></pre>
<h1><a class="header" href="#嵌入式-rust进阶篇" id="嵌入式-rust进阶篇">嵌入式 Rust：进阶篇</a></h1>
<h2><a class="header" href="#rtc-driver-1" id="rtc-driver-1">RTC driver</a></h2>
<p>(<a href="exercises/bare-metal/rtc.html">返回练习</a>)</p>
<p><em>main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,
    // and nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!(&quot;RTC: {time}&quot;);

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>pl031.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::{addr_of, addr_of_mut};

#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#并发编程上午练习" id="并发编程上午练习">并发编程：上午练习</a></h1>
<h2><a class="header" href="#哲学家就餐问题-dining-philosophers-problem-1" id="哲学家就餐问题-dining-philosophers-problem-1">哲学家就餐问题 (Dining philosophers problem)</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        println!(&quot;{} is trying to eat&quot;, &amp;self.name);
        let left = self.left_fork.lock().unwrap();
        let right = self.right_fork.lock().unwrap();

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!(&quot;{thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#link-checker" id="link-checker">Link Checker</a></h2>
<p>(<a href="exercises/concurrency/link-checker.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};

use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState {
            domain: start_url.domain().unwrap().to_string(),
            visited_pages,
        }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning true if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!(&quot;Got crawling error: {:#}&quot;, error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let bad_urls = check_links(start_url);
    println!(&quot;Bad URLs: {:#?}&quot;, bad_urls);
}
</code></pre></pre>
<h1><a class="header" href="#并发编程下午练习" id="并发编程下午练习">并发编程：下午练习</a></h1>
<h2><a class="header" href="#哲学家进餐---异步-1" id="哲学家进餐---异步-1">哲学家进餐 - 异步</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers-async.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: Sender&lt;String&gt;,
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Pick up forks...
        let _first_lock = self.left_fork.lock().await;
        // Add a delay before picking the second fork to allow the execution
        // to transfer to another task
        time::sleep(time::Duration::from_millis(1)).await;
        let _second_lock = self.right_fork.lock().await;

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;

        // The locks are dropped here
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let left_fork = Arc::clone(&amp;forks[i]);
            let right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            // To avoid a deadlock, we have to break the symmetry
            // somewhere. This will swap the forks without deinitializing
            // either of them.
            if i  == 0 {
                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });

    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!(&quot;Here is a thought: {thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#广播聊天应用程序-1" id="广播聊天应用程序-1">广播聊天应用程序</a></h2>
<p>(<a href="exercises/concurrency/chat-app.html">back to exercise</a>)</p>
<p><em>src/bin/server.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    ws_stream
        .send(Message::text(&quot;Welcome to chat! Type a message&quot;.into()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From client {addr:?} {text:?}&quot;);
                            bcast_tx.send(text.into())?;
                        }
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From server: {}&quot;, text);
                        }
                    },
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script>
            window.playground_line_numbers = true;
        </script>
        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        

        
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        
        <script src="theme/speaker-notes.js"></script>
        

        
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </div>
    </body>
</html>
