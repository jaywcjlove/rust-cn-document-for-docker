<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust 🦀</title>
        
        <meta name="robots" content="noindex">
        
        


        <!-- Custom HTML head -->
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
        data-autoload-cookie-consent-bar="true"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZN78TEJMRW');
</script>


<script>
  (function () {
      // See these pages for details:
      // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
      // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
      let base = "https://google.github.io/comprehensive-rust";
      
      let canonical_href = `${base}/zh-CN/print.md`;
      

      // mdbook gives us a string ending in ".md", we replace it with ".html":
      canonical_href = canonical_href.slice(0, -"md".length) + "html";
      if (canonical_href.endsWith("/index.html")) {
          canonical_href = canonical_href.slice(0, -"index.html".length);
      }

      let link = document.createElement("link");
      link.rel = "canonical";
      link.href = canonical_href;
      document.head.appendChild(link);
  })()
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/svgbob.css">
        
        <link rel="stylesheet" href="theme/css/redbox.css">
        
        <link rel="stylesheet" href="theme/css/speaker-notes.css">
        
        <link rel="stylesheet" href="theme/css/language-picker.css">
        
        <link rel="stylesheet" href="theme/css/rtl.css">
        

        
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">欢迎来到 Comprehensive Rust 🦀</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> 授课</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> 课程结构</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> 键盘快捷键</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> 翻译</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> 使用 Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> Rust 生态系统</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> 代码示例</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> 在本地运行 Cargo</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">第一天：上午</li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> 欢迎</a></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello, World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/what-is-rust.html"><strong aria-hidden="true">4.1.</strong> 什么是 Rust？</a></li><li class="chapter-item "><a href="hello-world/benefits.html"><strong aria-hidden="true">4.2.</strong> Rust 的优势</a></li><li class="chapter-item "><a href="hello-world/playground.html"><strong aria-hidden="true">4.3.</strong> Playground</a></li></ol></li><li class="chapter-item "><a href="types-and-values.html"><strong aria-hidden="true">5.</strong> 类型和值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/hello-world.html"><strong aria-hidden="true">5.1.</strong> Hello, World</a></li><li class="chapter-item "><a href="types-and-values/variables.html"><strong aria-hidden="true">5.2.</strong> 变量</a></li><li class="chapter-item "><a href="types-and-values/values.html"><strong aria-hidden="true">5.3.</strong> 值</a></li><li class="chapter-item "><a href="types-and-values/arithmetic.html"><strong aria-hidden="true">5.4.</strong> 算术</a></li><li class="chapter-item "><a href="types-and-values/inference.html"><strong aria-hidden="true">5.5.</strong> 类型推导</a></li><li class="chapter-item "><a href="types-and-values/exercise.html"><strong aria-hidden="true">5.6.</strong> 练习：Fibonacci</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/solution.html"><strong aria-hidden="true">5.6.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="control-flow-basics.html"><strong aria-hidden="true">6.</strong> 控制流基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/if.html"><strong aria-hidden="true">6.1.</strong> if 表达式</a></li><li class="chapter-item "><a href="control-flow-basics/loops.html"><strong aria-hidden="true">6.2.</strong> 循环控制</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/loops/for.html"><strong aria-hidden="true">6.2.1.</strong> for</a></li><li class="chapter-item "><a href="control-flow-basics/loops/loop.html"><strong aria-hidden="true">6.2.2.</strong> loop</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/break-continue.html"><strong aria-hidden="true">6.3.</strong> break 和 continue</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/break-continue/labels.html"><strong aria-hidden="true">6.3.1.</strong> Labels</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes.html"><strong aria-hidden="true">6.4.</strong> 代码块和作用域</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes/scopes.html"><strong aria-hidden="true">6.4.1.</strong> 作用域和遮蔽（Shadowing）</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/functions.html"><strong aria-hidden="true">6.5.</strong> 函数</a></li><li class="chapter-item "><a href="control-flow-basics/macros.html"><strong aria-hidden="true">6.6.</strong> 宏</a></li><li class="chapter-item "><a href="control-flow-basics/exercise.html"><strong aria-hidden="true">6.7.</strong> 练习：考拉兹序列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/solution.html"><strong aria-hidden="true">6.7.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第一天：下午</li><li class="chapter-item "><a href="welcome-day-1-afternoon.html"><strong aria-hidden="true">7.</strong> 欢迎</a></li><li class="chapter-item "><a href="tuples-and-arrays.html"><strong aria-hidden="true">8.</strong> 元组和数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/arrays.html"><strong aria-hidden="true">8.1.</strong> 数组（Arrays）</a></li><li class="chapter-item "><a href="tuples-and-arrays/tuples.html"><strong aria-hidden="true">8.2.</strong> 元组（Tuples）</a></li><li class="chapter-item "><a href="tuples-and-arrays/iteration.html"><strong aria-hidden="true">8.3.</strong> 数组迭代</a></li><li class="chapter-item "><a href="tuples-and-arrays/destructuring.html"><strong aria-hidden="true">8.4.</strong> 解构</a></li><li class="chapter-item "><a href="tuples-and-arrays/exercise.html"><strong aria-hidden="true">8.5.</strong> 练习：嵌套数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/solution.html"><strong aria-hidden="true">8.5.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="references.html"><strong aria-hidden="true">9.</strong> 引用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/shared.html"><strong aria-hidden="true">9.1.</strong> 共享引用</a></li><li class="chapter-item "><a href="references/exclusive.html"><strong aria-hidden="true">9.2.</strong> 独占引用</a></li><li class="chapter-item "><a href="references/slices.html"><strong aria-hidden="true">9.3.</strong> 切片</a></li><li class="chapter-item "><a href="references/strings.html"><strong aria-hidden="true">9.4.</strong> 字符串</a></li><li class="chapter-item "><a href="references/exercise.html"><strong aria-hidden="true">9.5.</strong> 练习：几何图形</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/solution.html"><strong aria-hidden="true">9.5.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="user-defined-types.html"><strong aria-hidden="true">10.</strong> 用户定义的类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/named-structs.html"><strong aria-hidden="true">10.1.</strong> 结构体</a></li><li class="chapter-item "><a href="user-defined-types/tuple-structs.html"><strong aria-hidden="true">10.2.</strong> 元组结构体</a></li><li class="chapter-item "><a href="user-defined-types/enums.html"><strong aria-hidden="true">10.3.</strong> 枚举</a></li><li class="chapter-item "><a href="user-defined-types/const.html"><strong aria-hidden="true">10.4.</strong> 常量</a></li><li class="chapter-item "><a href="user-defined-types/static.html"><strong aria-hidden="true">10.5.</strong> static</a></li><li class="chapter-item "><a href="user-defined-types/aliases.html"><strong aria-hidden="true">10.6.</strong> 类型别名</a></li><li class="chapter-item "><a href="user-defined-types/exercise.html"><strong aria-hidden="true">10.7.</strong> 练习：电梯事件</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/solution.html"><strong aria-hidden="true">10.7.1.</strong> 解答</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第二天：上午</li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">11.</strong> 欢迎</a></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">12.</strong> 模式匹配</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/match.html"><strong aria-hidden="true">12.1.</strong> Matching Values</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">12.2.</strong> Destructuring Structs</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">12.3.</strong> Destructuring Enums</a></li><li class="chapter-item "><a href="pattern-matching/let-control-flow.html"><strong aria-hidden="true">12.4.</strong> let 控制流</a></li><li class="chapter-item "><a href="pattern-matching/exercise.html"><strong aria-hidden="true">12.5.</strong> 练习：表达式求值</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/solution.html"><strong aria-hidden="true">12.5.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="methods-and-traits.html"><strong aria-hidden="true">13.</strong> 方法和特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/methods.html"><strong aria-hidden="true">13.1.</strong> 方法</a></li><li class="chapter-item "><a href="methods-and-traits/traits.html"><strong aria-hidden="true">13.2.</strong> 特征（Trait）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/traits/implementing.html"><strong aria-hidden="true">13.2.1.</strong> 实现 Unsafe Trait</a></li><li class="chapter-item "><a href="methods-and-traits/traits/supertraits.html"><strong aria-hidden="true">13.2.2.</strong> 更多 trait</a></li><li class="chapter-item "><a href="methods-and-traits/traits/associated-types.html"><strong aria-hidden="true">13.2.3.</strong> 共享类型</a></li></ol></li><li class="chapter-item "><a href="methods-and-traits/deriving.html"><strong aria-hidden="true">13.3.</strong> 派生特征</a></li><li class="chapter-item "><a href="methods-and-traits/exercise.html"><strong aria-hidden="true">13.4.</strong> 练习：通用日志</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/solution.html"><strong aria-hidden="true">13.4.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第二天：下午</li><li class="chapter-item "><a href="welcome-day-2-afternoon.html"><strong aria-hidden="true">14.</strong> 欢迎</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">15.</strong> 泛型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/generic-functions.html"><strong aria-hidden="true">15.1.</strong> 泛型函数</a></li><li class="chapter-item "><a href="generics/generic-data.html"><strong aria-hidden="true">15.2.</strong> 泛型类型</a></li><li class="chapter-item "><a href="generics/generic-traits.html"><strong aria-hidden="true">15.3.</strong> 泛型</a></li><li class="chapter-item "><a href="generics/trait-bounds.html"><strong aria-hidden="true">15.4.</strong> 特征边界</a></li><li class="chapter-item "><a href="generics/impl-trait.html"><strong aria-hidden="true">15.5.</strong> impl Trait</a></li><li class="chapter-item "><a href="generics/dyn-trait.html"><strong aria-hidden="true">15.6.</strong> dyn Trait</a></li><li class="chapter-item "><a href="generics/exercise.html"><strong aria-hidden="true">15.7.</strong> 练习：通用 min 函数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/solution.html"><strong aria-hidden="true">15.7.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-types.html"><strong aria-hidden="true">16.</strong> 标准库类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/std.html"><strong aria-hidden="true">16.1.</strong> 标准库</a></li><li class="chapter-item "><a href="std-types/docs.html"><strong aria-hidden="true">16.2.</strong> 文档</a></li><li class="chapter-item "><a href="std-types/option.html"><strong aria-hidden="true">16.3.</strong> Option</a></li><li class="chapter-item "><a href="std-types/result.html"><strong aria-hidden="true">16.4.</strong> Result</a></li><li class="chapter-item "><a href="std-types/string.html"><strong aria-hidden="true">16.5.</strong> String</a></li><li class="chapter-item "><a href="std-types/vec.html"><strong aria-hidden="true">16.6.</strong> Vec</a></li><li class="chapter-item "><a href="std-types/hashmap.html"><strong aria-hidden="true">16.7.</strong> HashMap</a></li><li class="chapter-item "><a href="std-types/exercise.html"><strong aria-hidden="true">16.8.</strong> 练习：计数器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/solution.html"><strong aria-hidden="true">16.8.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-traits.html"><strong aria-hidden="true">17.</strong> 标准库特征</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/comparisons.html"><strong aria-hidden="true">17.1.</strong> 比较</a></li><li class="chapter-item "><a href="std-traits/operators.html"><strong aria-hidden="true">17.2.</strong> 运算符</a></li><li class="chapter-item "><a href="std-traits/from-and-into.html"><strong aria-hidden="true">17.3.</strong> From 和 Into</a></li><li class="chapter-item "><a href="std-traits/casting.html"><strong aria-hidden="true">17.4.</strong> 类型转换</a></li><li class="chapter-item "><a href="std-traits/read-and-write.html"><strong aria-hidden="true">17.5.</strong> Read 和 Write</a></li><li class="chapter-item "><a href="std-traits/default.html"><strong aria-hidden="true">17.6.</strong> Default，结构体更新语法</a></li><li class="chapter-item "><a href="std-traits/closures.html"><strong aria-hidden="true">17.7.</strong> 闭包</a></li><li class="chapter-item "><a href="std-traits/exercise.html"><strong aria-hidden="true">17.8.</strong> 练习：ROT13</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/solution.html"><strong aria-hidden="true">17.8.1.</strong> 解答</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第三天：上午</li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">18.</strong> 欢迎</a></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">19.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/review.html"><strong aria-hidden="true">19.1.</strong> 回顾：程序的内存分配</a></li><li class="chapter-item "><a href="memory-management/approaches.html"><strong aria-hidden="true">19.2.</strong> 内存管理方法</a></li><li class="chapter-item "><a href="memory-management/ownership.html"><strong aria-hidden="true">19.3.</strong> 所有权</a></li><li class="chapter-item "><a href="memory-management/move.html"><strong aria-hidden="true">19.4.</strong> 移动语义</a></li><li class="chapter-item "><a href="memory-management/clone.html"><strong aria-hidden="true">19.5.</strong> Clone</a></li><li class="chapter-item "><a href="memory-management/copy-types.html"><strong aria-hidden="true">19.6.</strong> 复合类型</a></li><li class="chapter-item "><a href="memory-management/drop.html"><strong aria-hidden="true">19.7.</strong> Drop</a></li><li class="chapter-item "><a href="memory-management/exercise.html"><strong aria-hidden="true">19.8.</strong> 练习：构建器类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/solution.html"><strong aria-hidden="true">19.8.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="smart-pointers.html"><strong aria-hidden="true">20.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">20.1.</strong> Box<T></a></li><li class="chapter-item "><a href="smart-pointers/rc.html"><strong aria-hidden="true">20.2.</strong> Rc</a></li><li class="chapter-item "><a href="smart-pointers/trait-objects.html"><strong aria-hidden="true">20.3.</strong> Owned Trait Objects</a></li><li class="chapter-item "><a href="smart-pointers/exercise.html"><strong aria-hidden="true">20.4.</strong> 练习：二叉树</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/solution.html"><strong aria-hidden="true">20.4.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第三天：下午</li><li class="chapter-item "><a href="welcome-day-3-afternoon.html"><strong aria-hidden="true">21.</strong> 欢迎</a></li><li class="chapter-item "><a href="borrowing.html"><strong aria-hidden="true">22.</strong> 借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/shared.html"><strong aria-hidden="true">22.1.</strong> 借用值</a></li><li class="chapter-item "><a href="borrowing/borrowck.html"><strong aria-hidden="true">22.2.</strong> 借用检查</a></li><li class="chapter-item "><a href="borrowing/examples.html"><strong aria-hidden="true">22.3.</strong> Borrow Errors</a></li><li class="chapter-item "><a href="borrowing/interior-mutability.html"><strong aria-hidden="true">22.4.</strong> 内部可变性</a></li><li class="chapter-item "><a href="borrowing/exercise.html"><strong aria-hidden="true">22.5.</strong> 练习：健康统计</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/solution.html"><strong aria-hidden="true">22.5.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="lifetimes.html"><strong aria-hidden="true">23.</strong> 结构体生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/lifetime-annotations.html"><strong aria-hidden="true">23.1.</strong> 生命周期注解</a></li><li class="chapter-item "><a href="lifetimes/lifetime-elision.html"><strong aria-hidden="true">23.2.</strong> 生命周期省略</a></li><li class="chapter-item "><a href="lifetimes/struct-lifetimes.html"><strong aria-hidden="true">23.3.</strong> 结构体生命周期</a></li><li class="chapter-item "><a href="lifetimes/exercise.html"><strong aria-hidden="true">23.4.</strong> 练习：Protobuf 解析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/solution.html"><strong aria-hidden="true">23.4.1.</strong> 解答</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第四天：上午</li><li class="chapter-item "><a href="welcome-day-4.html"><strong aria-hidden="true">24.</strong> 欢迎</a></li><li class="chapter-item "><a href="iterators.html"><strong aria-hidden="true">25.</strong> 迭代器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/iterator.html"><strong aria-hidden="true">25.1.</strong> Iterator</a></li><li class="chapter-item "><a href="iterators/intoiterator.html"><strong aria-hidden="true">25.2.</strong> IntoIterator</a></li><li class="chapter-item "><a href="iterators/fromiterator.html"><strong aria-hidden="true">25.3.</strong> FromIterator</a></li><li class="chapter-item "><a href="iterators/exercise.html"><strong aria-hidden="true">25.4.</strong> 练习：迭代器方法链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/solution.html"><strong aria-hidden="true">25.4.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">26.</strong> 模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/modules.html"><strong aria-hidden="true">26.1.</strong> 模块</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">26.2.</strong> 文件系统层级结构</a></li><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">26.3.</strong> 可见性</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">26.4.</strong> use、super、self</a></li><li class="chapter-item "><a href="modules/exercise.html"><strong aria-hidden="true">26.5.</strong> 练习：面向 GUI 库的模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/solution.html"><strong aria-hidden="true">26.5.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">27.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">27.1.</strong> 测试模块</a></li><li class="chapter-item "><a href="testing/other.html"><strong aria-hidden="true">27.2.</strong> 其他类型的测试</a></li><li class="chapter-item "><a href="testing/lints.html"><strong aria-hidden="true">27.3.</strong> 编译器 Lint 和 Clippy</a></li><li class="chapter-item "><a href="testing/exercise.html"><strong aria-hidden="true">27.4.</strong> 练习：卢恩算法</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/solution.html"><strong aria-hidden="true">27.4.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">第四天：下午</li><li class="chapter-item "><a href="welcome-day-4-afternoon.html"><strong aria-hidden="true">28.</strong> 欢迎</a></li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">29.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">29.1.</strong> Panics</a></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">29.2.</strong> Result</a></li><li class="chapter-item "><a href="error-handling/try.html"><strong aria-hidden="true">29.3.</strong> 尝试运算符</a></li><li class="chapter-item "><a href="error-handling/try-conversions.html"><strong aria-hidden="true">29.4.</strong> 尝试转换</a></li><li class="chapter-item "><a href="error-handling/error.html"><strong aria-hidden="true">29.5.</strong> Error 特征</a></li><li class="chapter-item "><a href="error-handling/thiserror.html"><strong aria-hidden="true">29.6.</strong> thiserror</a></li><li class="chapter-item "><a href="error-handling/anyhow.html"><strong aria-hidden="true">29.7.</strong> anyhow</a></li><li class="chapter-item "><a href="error-handling/exercise.html"><strong aria-hidden="true">29.8.</strong> 练习：使用 Result 进行重写</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/solution.html"><strong aria-hidden="true">29.8.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><a href="unsafe-rust.html"><strong aria-hidden="true">30.</strong> 不安全 Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/unsafe.html"><strong aria-hidden="true">30.1.</strong> Unsafe</a></li><li class="chapter-item "><a href="unsafe-rust/dereferencing.html"><strong aria-hidden="true">30.2.</strong> 解引用裸指针</a></li><li class="chapter-item "><a href="unsafe-rust/mutable-static.html"><strong aria-hidden="true">30.3.</strong> 可变的静态变量</a></li><li class="chapter-item "><a href="unsafe-rust/unions.html"><strong aria-hidden="true">30.4.</strong> 联合体</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-functions.html"><strong aria-hidden="true">30.5.</strong> Unsafe 函数</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-traits.html"><strong aria-hidden="true">30.6.</strong> Unsafe 特征</a></li><li class="chapter-item "><a href="unsafe-rust/exercise.html"><strong aria-hidden="true">30.7.</strong> 练习：FFI 封装容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/solution.html"><strong aria-hidden="true">30.7.1.</strong> 解答</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">31.</strong> 欢迎</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">32.</strong> 设置</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">33.</strong> 构建规则</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">33.1.</strong> 可执行文件</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">33.2.</strong> 库</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">34.</strong> AIDL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/birthday-service.html"><strong aria-hidden="true">34.1.</strong> /** Birthday service interface. */</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/example-service/interface.html"><strong aria-hidden="true">34.1.1.</strong> 接口</a></li><li class="chapter-item "><a href="android/aidl/example-service/service-bindings.html"><strong aria-hidden="true">34.1.2.</strong> Service API</a></li><li class="chapter-item "><a href="android/aidl/example-service/service.html"><strong aria-hidden="true">34.1.3.</strong> 服务器</a></li><li class="chapter-item "><a href="android/aidl/example-service/server.html"><strong aria-hidden="true">34.1.4.</strong> 服务器</a></li><li class="chapter-item "><a href="android/aidl/example-service/deploy.html"><strong aria-hidden="true">34.1.5.</strong> 部署</a></li><li class="chapter-item "><a href="android/aidl/example-service/client.html"><strong aria-hidden="true">34.1.6.</strong> 客户端</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-definition.html"><strong aria-hidden="true">34.1.7.</strong> 更改 API</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-implementation.html"><strong aria-hidden="true">34.1.8.</strong> 实现</a></li></ol></li><li class="chapter-item "><a href="android/aidl/types.html"><strong aria-hidden="true">34.2.</strong> 类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/types/primitives.html"><strong aria-hidden="true">34.2.1.</strong> Primitive Types</a></li><li class="chapter-item "><a href="android/aidl/types/arrays.html"><strong aria-hidden="true">34.2.2.</strong> 数组（Arrays）</a></li><li class="chapter-item "><a href="android/aidl/types/objects.html"><strong aria-hidden="true">34.2.3.</strong> 特征对象</a></li><li class="chapter-item "><a href="android/aidl/types/parcelables.html"><strong aria-hidden="true">34.2.4.</strong> 变量</a></li><li class="chapter-item "><a href="android/aidl/types/file-descriptor.html"><strong aria-hidden="true">34.2.5.</strong> Sending Files</a></li></ol></li></ol></li><li class="chapter-item "><a href="android/testing.html"><strong aria-hidden="true">35.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/testing/googletest.html"><strong aria-hidden="true">35.1.</strong> GoogleTest</a></li><li class="chapter-item "><a href="android/testing/mocking.html"><strong aria-hidden="true">35.2.</strong> 模拟</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">36.</strong> 日志记录</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">37.</strong> 互操作性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">37.1.</strong> 与 C 语言交互</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">37.1.1.</strong> 使用 Bindgen 调用 C 语言</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">37.1.2.</strong> 从 C 语言调用 Rust 语言</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">37.2.</strong> 与 C++ 交互</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/cpp/bridge.html"><strong aria-hidden="true">37.2.1.</strong> 桥接模块</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-bridge.html"><strong aria-hidden="true">37.2.2.</strong> Rust 桥接</a></li><li class="chapter-item "><a href="android/interoperability/cpp/generated-cpp.html"><strong aria-hidden="true">37.2.3.</strong> 生成的 C++ 代码</a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-bridge.html"><strong aria-hidden="true">37.2.4.</strong> C++ 桥接</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-types.html"><strong aria-hidden="true">37.2.5.</strong> 共享类型</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-enums.html"><strong aria-hidden="true">37.2.6.</strong> 共享枚举</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-result.html"><strong aria-hidden="true">37.2.7.</strong> Rust 错误处理</a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-exception.html"><strong aria-hidden="true">37.2.8.</strong> C++ 错误处理</a></li><li class="chapter-item "><a href="android/interoperability/cpp/type-mapping.html"><strong aria-hidden="true">37.2.9.</strong> 其他类型</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-cpp.html"><strong aria-hidden="true">37.2.10.</strong> 为 Android 构建：C++</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-cpp-genrules.html"><strong aria-hidden="true">37.2.11.</strong> 为 Android 构建：Genrule</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-rust.html"><strong aria-hidden="true">37.2.12.</strong> 为 Android 构建：Rust</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">37.3.</strong> 与 Java 交互</a></li></ol></li><li class="chapter-item "><li class="part-title">Chromium</li><li class="spacer"></li><li class="chapter-item "><a href="chromium.html"><strong aria-hidden="true">38.</strong> 欢迎</a></li><li class="chapter-item "><a href="chromium/setup.html"><strong aria-hidden="true">39.</strong> 设置</a></li><li class="chapter-item "><a href="chromium/cargo.html"><strong aria-hidden="true">40.</strong> Chromium 和 Cargo 的生态对比</a></li><li class="chapter-item "><a href="chromium/policy.html"><strong aria-hidden="true">41.</strong> 政策</a></li><li class="chapter-item "><a href="chromium/build-rules.html"><strong aria-hidden="true">42.</strong> 构建规则</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/build-rules/unsafe.html"><strong aria-hidden="true">42.1.</strong> 不安全代码</a></li><li class="chapter-item "><a href="chromium/build-rules/depending.html"><strong aria-hidden="true">42.2.</strong> 在 Chromium C++ 中导入 Rust 代码</a></li><li class="chapter-item "><a href="chromium/build-rules/vscode.html"><strong aria-hidden="true">42.3.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="exercises/chromium/build-rules.html"><strong aria-hidden="true">42.4.</strong> 练习</a></li></ol></li><li class="chapter-item "><a href="chromium/testing.html"><strong aria-hidden="true">43.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/testing/rust-gtest-interop.html"><strong aria-hidden="true">43.1.</strong> rust_gtest_interop 库</a></li><li class="chapter-item "><a href="chromium/testing/build-gn.html"><strong aria-hidden="true">43.2.</strong> Rust 测试的 GN 规则</a></li><li class="chapter-item "><a href="chromium/testing/chromium-import-macro.html"><strong aria-hidden="true">43.3.</strong> chromium::import! 宏</a></li><li class="chapter-item "><a href="exercises/chromium/testing.html"><strong aria-hidden="true">43.4.</strong> 练习</a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp.html"><strong aria-hidden="true">44.</strong> 与 C++ 的互操作性</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/example-bindings.html"><strong aria-hidden="true">44.1.</strong> 绑定示例</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/limitations-of-cxx.html"><strong aria-hidden="true">44.2.</strong> CXX 的局限性</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling.html"><strong aria-hidden="true">44.3.</strong> CXX 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-qr.html"><strong aria-hidden="true">44.3.1.</strong> 错误处理：QR 码示例</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-png.html"><strong aria-hidden="true">44.3.2.</strong> 错误处理：PNG 示例</a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/using-cxx-in-chromium.html"><strong aria-hidden="true">44.4.</strong> 在 Chromium 中使用 CXX</a></li><li class="chapter-item "><a href="exercises/chromium/interoperability-with-cpp.html"><strong aria-hidden="true">44.5.</strong> 练习</a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates.html"><strong aria-hidden="true">45.</strong> 添加第三方 Crate</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-cargo-toml.html"><strong aria-hidden="true">45.1.</strong> 配置 Cargo.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-gnrt-config-toml.html"><strong aria-hidden="true">45.2.</strong> 配置 gnrt_config.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/downloading-crates.html"><strong aria-hidden="true">45.3.</strong> 下载 Crate</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/generating-gn-build-rules.html"><strong aria-hidden="true">45.4.</strong> 生成 gn 构建规则</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems.html"><strong aria-hidden="true">45.5.</strong> 解决问题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.html"><strong aria-hidden="true">45.5.1.</strong> 构建用于生成代码的脚本</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.html"><strong aria-hidden="true">45.5.2.</strong> 构建用于构建 C++ 或执行任意操作的脚本</a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/depending-on-a-crate.html"><strong aria-hidden="true">45.6.</strong> 依赖于 Crate</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/reviews-and-audits.html"><strong aria-hidden="true">45.7.</strong> 审查和审核</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/checking-in.html"><strong aria-hidden="true">45.8.</strong> 提交到 Chromium 源代码</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/keeping-up-to-date.html"><strong aria-hidden="true">45.9.</strong> 及时更新 Crate</a></li><li class="chapter-item "><a href="exercises/chromium/third-party.html"><strong aria-hidden="true">45.10.</strong> 练习</a></li></ol></li><li class="chapter-item "><a href="exercises/chromium/bringing-it-together.html"><strong aria-hidden="true">46.</strong> 综合应用练习</a></li><li class="chapter-item "><a href="exercises/chromium/solutions.html"><strong aria-hidden="true">47.</strong> 练习解答</a></li><li class="chapter-item affix "><li class="part-title">裸机：上午</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">48.</strong> 欢迎</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">49.</strong> no_std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">49.1.</strong> 最小示例</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">49.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">50.</strong> 微控制器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">50.1.</strong> 原始 MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">50.2.</strong> PAC</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">50.3.</strong> HAL Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">50.4.</strong> 板级支持 Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">50.5.</strong> 类型状态模式</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">50.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">50.7.</strong> probe-rs 和 cargo-embed</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">50.7.1.</strong> 调试</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">50.8.</strong> 其他项目</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">51.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">51.1.</strong> 罗盘</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">51.2.</strong> 解答</a></li></ol></li><li class="chapter-item "><li class="part-title">裸机：下午</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">52.</strong> 应用处理器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">52.1.</strong> 准备使用 Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">52.2.</strong> 内联汇编</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">52.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">52.4.</strong> 编写 UART 驱动程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">52.4.1.</strong> 更多特征</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">52.5.</strong> 优化 UART 驱动程序</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">52.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">52.5.2.</strong> 多寄存器</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">52.5.3.</strong> 驱动程序</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">52.5.4.</strong> 开始使用</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">52.6.</strong> 日志记录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">52.6.1.</strong> 开始使用</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">52.7.</strong> 异常</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">52.8.</strong> 其他项目</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">53.</strong> 实用 Crate</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">53.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">53.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">53.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">53.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">53.5.</strong> spin</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">54.</strong> Bare-Metal on Android</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">54.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">55.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">55.1.</strong> RTC 驱动</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">55.2.</strong> 解答</a></li></ol></li><li class="chapter-item "><li class="part-title">并发：上午</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency/welcome.html"><strong aria-hidden="true">56.</strong> 欢迎</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">57.</strong> 线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/threads/plain.html"><strong aria-hidden="true">57.1.</strong> Plain Threads</a></li><li class="chapter-item "><a href="concurrency/threads/scoped.html"><strong aria-hidden="true">57.2.</strong> 范围线程</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">58.</strong> 通道</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/senders-receivers.html"><strong aria-hidden="true">58.1.</strong> Senders and Receivers</a></li><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">58.2.</strong> 无界通道</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">58.3.</strong> 有界通道</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">59.</strong> Send 和 Sync</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/marker-traits.html"><strong aria-hidden="true">59.1.</strong> Marker Traits</a></li><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">59.2.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">59.3.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">59.4.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared-state.html"><strong aria-hidden="true">60.</strong> 共享状态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared-state/arc.html"><strong aria-hidden="true">60.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared-state/mutex.html"><strong aria-hidden="true">60.2.</strong> 互斥器（Mutex）</a></li><li class="chapter-item "><a href="concurrency/shared-state/example.html"><strong aria-hidden="true">60.3.</strong> 示例</a></li></ol></li><li class="chapter-item "><a href="concurrency/sync-exercises.html"><strong aria-hidden="true">61.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/sync-exercises/dining-philosophers.html"><strong aria-hidden="true">61.1.</strong> 哲学家就餐问题</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/link-checker.html"><strong aria-hidden="true">61.2.</strong> 多线程链接检查器</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/solutions.html"><strong aria-hidden="true">61.3.</strong> 解答</a></li></ol></li><li class="chapter-item "><li class="part-title">并发：下午</li><li class="chapter-item "><a href="concurrency/welcome-async.html"><strong aria-hidden="true">62.</strong> 欢迎</a></li><li class="chapter-item "><a href="concurrency/async.html"><strong aria-hidden="true">63.</strong> 异步基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/async-await.html"><strong aria-hidden="true">63.1.</strong> async/await</a></li><li class="chapter-item "><a href="concurrency/async/futures.html"><strong aria-hidden="true">63.2.</strong> Futures</a></li><li class="chapter-item "><a href="concurrency/async/runtimes.html"><strong aria-hidden="true">63.3.</strong> Runtimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/runtimes/tokio.html"><strong aria-hidden="true">63.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="concurrency/async/tasks.html"><strong aria-hidden="true">63.4.</strong> 任务</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-control-flow.html"><strong aria-hidden="true">64.</strong> Channels and Control Flow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-control-flow/channels.html"><strong aria-hidden="true">64.1.</strong> 异步通道</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/join.html"><strong aria-hidden="true">64.2.</strong> 加入</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/select.html"><strong aria-hidden="true">64.3.</strong> 选择</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-pitfalls.html"><strong aria-hidden="true">65.</strong> 误区</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-pitfalls/blocking-executor.html"><strong aria-hidden="true">65.1.</strong> 阻塞执行器</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/pin.html"><strong aria-hidden="true">65.2.</strong> Pin</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/async-traits.html"><strong aria-hidden="true">65.3.</strong> 异步特征</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/cancellation.html"><strong aria-hidden="true">65.4.</strong> 消除</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-exercises.html"><strong aria-hidden="true">66.</strong> 习题</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-exercises/dining-philosophers.html"><strong aria-hidden="true">66.1.</strong> 哲学家就餐问题</a></li><li class="chapter-item "><a href="concurrency/async-exercises/chat-app.html"><strong aria-hidden="true">66.2.</strong> 广播聊天应用</a></li><li class="chapter-item "><a href="concurrency/async-exercises/solutions.html"><strong aria-hidden="true">66.3.</strong> 解答</a></li></ol></li><li class="chapter-item "><li class="part-title">结束语</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">67.</strong> 谢谢！</a></li><li class="chapter-item "><a href="glossary.html"><strong aria-hidden="true">68.</strong> 词汇表</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">69.</strong> 其他资源</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">70.</strong> 鸣谢</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Comprehensive Rust 🦀</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (Português do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-CN">Chinese Simplified (汉语)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-TW">Chinese Traditional (漢語)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (日本語)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (한국어)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fa">Farsi (فارسی)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (Español)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="uk">Ukrainian (українська)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-CN");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          
                          let full_path_to_root = "../";
                          
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#欢迎来到-comprehensive-rust-" id="欢迎来到-comprehensive-rust-">欢迎来到 Comprehensive Rust 🦀</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="构建工作流" /></a> <a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub 贡献者" /></a> <a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub 星标" /></a></p>
<p>这是一门由 Android 团队开发的免费 Rust 课程。课程涵盖了 Rust 的全部内容，从基本语法到泛型和错误处理等高级主题。</p>
<blockquote>
<p>如需查看课程的最新版本，请访问 <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a>。如果您在其他地方阅读，请在那里查看更新。</p>
<p>The course is available in other languages. Select your preferred language in the top right corner of the page or check the <a href="running-the-course/translations.html">Translations</a> page for a list of all available translations.</p>
<p>The course is also available <a href="comprehensive-rust.pdf">as a PDF</a>.</p>
</blockquote>
<p>本课程的目标是教会你使用 Rust。假设你对 Rust 一无所知，本课程可以：</p>
<ul>
<li>帮助你全面理解 Rust 的语法和语言。</li>
<li>让你可以用 Rust 修改现有程序和编写新程序。</li>
<li>为你展示常见的 Rust 习惯用法。</li>
</ul>
<p>我们将前四天的课程称为“Rust 基础”。</p>
<p>在此基础上，你可以选择深入研究一个或多个专门的主题：</p>
<ul>
<li><a href="android.html">Android</a>：为期半天的课程，介绍如何在 Android 平台开发中使用 Rust（AOSP）。课程内容包括与 C、C++ 和 Java 的互操作性。</li>
<li><a href="chromium.html">Chromium</a>：为期半天的课程，介绍如何在基于 Chromium 的浏览器中使用 Rust。课程内容包括与 C++ 的互操作性以及如何在 Chromium 中加入第三方 crate。</li>
<li><a href="bare-metal.html">裸机</a>：为期一天的课程，介绍如何使用 Rust 进行裸机（嵌入式）开发。课程内容涵盖微控制器和应用处理器。</li>
<li><a href="concurrency/welcome.html">Concurrency</a>: a whole-day class on concurrency in Rust. We cover both classical concurrency (preemptively scheduling using threads and mutexes) and async/await concurrency (cooperative multitasking using futures).</li>
</ul>
<h2><a class="header" href="#非目标" id="非目标">非目标</a></h2>
<p>Rust 是一门庞大的语言，短短几天的课程无法覆盖其全部内容。本课程不包括以下内容：</p>
<ul>
<li>学习如何开发宏：请参阅 <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Rust Book 的第 19.5 章</a> 和 <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by Examples 对应章节</a>。</li>
</ul>
<h2><a class="header" href="#学习前提" id="学习前提">学习前提</a></h2>
<p>本课程假设你已经具备编程知识。Rust 是一种静态类型语言，本课程有时会将其与 C 和 C++ 进行比较，以便更好地解释或对比 Rust 的设计。</p>
<p>如果你会使用 Python 或 JavaScript 等动态类型语言编程，那么你也能够很好地跟上进度。</p>
<details>
<p>这是演讲者备注（<em>Speaker Notes</em>）的示例。页面中使用它来为幻灯片添加备注信息，其内容包括讲师应涉及的要点，以及对课堂上可能出现的典型问题的回答。</p>
</details>
<h1><a class="header" href="#授课" id="授课">授课</a></h1>
<blockquote>
<p>本页供课程讲师使用。</p>
</blockquote>
<p>以下是有关 Google 内部开展课程的一些相关背景。</p>
<p>上课时间通常是从上午 9:00 到下午 4:00，中间有 1 小时的午餐休息时间。这样上午和下午就各有 3 小时上课时间。上下午上课时间段内都有多次休息时间和学生做练习的时间。</p>
<p>在授课之前，你需要完成以下事项：</p>
<ol>
<li>
<p>熟悉课程资料。页面提供了演讲者注释以突出重点（请帮忙多多贡献演讲者备注！）。演讲时，请确保在弹出窗口中打开演讲者笔记（点击“演讲者笔记”旁边带小箭头的链接）。这样就可以确保屏幕整洁有序，更好地向全班学员展示课程内容。</p>
</li>
<li>
<p>决定培训日期。由于课程为期四天，建议将时间安排在两周内。课程学员曾表示，他们认为在课程保留一些间隙有助于更好地进行理解。</p>
</li>
<li>
<p>找一间足以容纳全体线下学员的教室。建议的班级人数为 15-25 人。这样少的人数可以让大家能够更轻松地提问，也可以让仅有一位的讲师有足够时间回答问题。确保教室里有讲师和学生用的桌子，并能够坐下来使用笔记本电脑。特别地，讲师需要进行大量的现场编码工作，因此讲台是不需要的。</p>
</li>
<li>
<p>课程当天，请提早到教室进行准备。建议直接在笔记本电脑上运行 <code>mdbook serve</code> 来演示课程内容（请参阅<a href="https://github.com/google/comprehensive-rust#building">安装说明</a>）。这样可以确保在更换页面时不会出现延迟，演示效果更好。使用笔记本运行还可以在发现错别字时及时更正。</p>
</li>
<li>
<p>让学员自己或以小组为单位解决练习问题。通常在上午和下午各安排 30-45 分钟的练习时间（包括查看解答的时间）。请务必询问学员是否遇到困难，或是否需要任何帮助。如果有多位学员遇到同样的问题，则在班级内进行讲解，并提供相应的解决方案，例如告诉大家在标准库的什么位置可以找到相关信息。</p>
</li>
</ol>
<p>以上就是全部事项，祝你授课顺利！希望你能像我们一样享受其中的乐趣！</p>
<p>欢迎你在课后 <a href="https://github.com/google/comprehensive-rust/discussions/86">提供反馈</a>，以帮助我们不断改进课程。我们非常期待了解哪些方面做得不错，哪些方面还需要改进。同时非常欢迎学生们 <a href="https://github.com/google/comprehensive-rust/discussions/100">向我们发送反馈</a>！</p>
<h1><a class="header" href="#课程结构" id="课程结构">课程结构</a></h1>
<blockquote>
<p>本页供课程讲师使用。</p>
</blockquote>
<h2><a class="header" href="#rust-基础" id="rust-基础">Rust 基础</a></h2>
<p>前四天的内容是 <a href="running-the-course/../welcome-day-1.html">Rust 基础</a>。这几天的课程节奏很快，内容也很丰富！</p>
<p>{{%course outline Fundamentals}}</p>
<h2><a class="header" href="#深入探究" id="深入探究">深入探究</a></h2>
<p>除了为期四天的“Rust 基础”课程外，还有一些专业课题提供：</p>
<h3><a class="header" href="#android-中的-rust" id="android-中的-rust">Android 中的 Rust</a></h3>
<p>深入探究 <a href="running-the-course/../android.html">Android 中的 Rust</a> 课程为期半天，旨在介绍如何使用 Rust 进行 Android 平台开发。其中包括与 C、C++ 和 Java 的互操作性。</p>
<p>你需要 <a href="https://source.android.com/docs/setup/download/downloading">检出 AOSP</a>。在同一机器上检出 <a href="https://github.com/google/comprehensive-rust">课程库</a>， 然后将 <code>src/android/</code> 目录移至所检出的 AOSP 的根目录。这将确保 Android 构建系统能检测到 <code>src/android/</code> 中的 <code>Android.bp</code> 文件。</p>
<p>确保 <code>adb sync</code> 适用于你的模拟器或实际设备， 并使用 <code>src/android/build_all.sh</code> 预构建所有 Android 示例。请阅读脚本， 查看它所运行的命令，并确保这些命令能在你手动运行时正确执行。</p>
<h3><a class="header" href="#chromium-中的-rust" id="chromium-中的-rust">Chromium 中的 Rust</a></h3>
<p>深入探究 <a href="running-the-course/../chromium.html">Chromium 中的 Rust</a> 课程为期半天，旨在介绍 Chromium 浏览器中 Rust 的使用。课程内容包括在 Chromium 的 <code>gn</code> 编译系统中使用 Rust，引入第三方 crate，以及与 C++ 的互操作性。</p>
<p>您需要能够构建 Chromium。为了提高速度，建议使用调试、组件 <a href="running-the-course/../chromium/setup.html">构建方式</a>，其他构建方式也可以使用。确保所构建的 Chromium 浏览器可以正常运行。</p>
<h3><a class="header" href="#裸机-rust" id="裸机-rust">裸机 Rust</a></h3>
<p>深入探究 <a href="running-the-course/../bare-metal.html">裸机 Rust</a> 课程为期一天，旨在介绍如何使用 Rust 进行裸机（嵌入式）开发。其中涵盖了微控制器和应用处理器。</p>
<p>对于微控制器部分，需要提前购买 <a href="https://microbit.org/">BBC micro:bit</a> v2 开发板。每个人都需要安装多个软件包， 具体如 <a href="running-the-course/../bare-metal.html">欢迎页面</a> 中所述。</p>
<h3><a class="header" href="#rust-中的并发" id="rust-中的并发">Rust 中的并发</a></h3>
<p>The <a href="running-the-course/../concurrency/welcome.html">Concurrency in Rust</a> deep dive is a full day class on classical as well as <code>async</code>/<code>await</code> concurrency.</p>
<p>你需要设置一个新 crate，下载所需的依赖项， 做好课前准备。然后，你可以将示例复制/粘贴到 <code>src/main.rs</code> 中， 以便对以下代码进行实验：</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<p>{{%course outline Concurrency}}</p>
<h2><a class="header" href="#课程形式" id="课程形式">课程形式</a></h2>
<p>本课程的互动性非常强， 建议你以问题驱动探索 Rust！</p>
<h1><a class="header" href="#键盘快捷键" id="键盘快捷键">键盘快捷键</a></h1>
<p>mdBook 中有一些实用键盘快捷键：</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<h1><a class="header" href="#翻译" id="翻译">翻译</a></h1>
<p>一批优秀的志愿者已将本课程翻译成其他语言：</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">巴西葡萄牙语版本</a> 译者：<a href="https://github.com/rastringer">@rastringer</a>、<a href="https://github.com/hugojacob">@hugojacob</a>、<a href="https://github.com/joaovicmendes">@joaovicmendes</a> 和 <a href="https://github.com/henrif75">@henrif75</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/">Chinese (Simplified)</a> by <a href="https://github.com/suetfei">@suetfei</a>, <a href="https://github.com/wnghl">@wnghl</a>, <a href="https://github.com/anlunx">@anlunx</a>, <a href="https://github.com/kongy">@kongy</a>, <a href="https://github.com/noahdragon">@noahdragon</a>, <a href="https://github.com/superwhd">@superwhd</a>, @SketchK, and <a href="https://github.com/nodmp">@nodmp</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-TW/">繁体中文版本</a> 译者：<a href="https://github.com/hueich">@hueich</a>、<a href="https://github.com/victorhsieh">@victorhsieh</a>、<a href="https://github.com/mingyc">@mingyc</a>、<a href="https://github.com/kuanhungchen">@kuanhungchen</a> 和 <a href="https://github.com/johnathan79717">@johnathan79717</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/fa/">Farsi</a> by <a href="https://github.com/DannyRavi">@DannyRavi</a>, <a href="https://github.com/javad-jafari">@javad-jafari</a>, <a href="https://github.com/alix1383">@Alix1383</a>, <a href="https://github.com/moaminsharifi">@moaminsharifi</a> , <a href="https://github.com/hamidrezakp">@hamidrezakp</a> and <a href="https://github.com/mehrad77">@mehrad77</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">Japanese</a> by <a href="https://github.com/CoinEZ">@CoinEZ-JPN</a>, <a href="https://github.com/momotaro1105">@momotaro1105</a>, <a href="https://github.com/HidenoriKobayashi">@HidenoriKobayashi</a> and <a href="https://github.com/kantasv">@kantasv</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">Korean</a> by <a href="https://github.com/keispace">@keispace</a>, <a href="https://github.com/jiyongp">@jiyongp</a>, <a href="https://github.com/jooyunghan">@jooyunghan</a>, and <a href="https://github.com/namhyung">@namhyung</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/es/">西班牙语版本</a> 译者：<a href="https://github.com/deavid">@deavid</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/uk/">Ukrainian</a> by <a href="https://github.com/git-user-cpp">@git-user-cpp</a>, <a href="https://github.com/yaremam">@yaremam</a> and <a href="https://github.com/reta">@reta</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fa/">Farsi</a> by <a href="https://github.com/DannyRavi">@DannyRavi</a>, <a href="https://github.com/javad-jafari">@javad-jafari</a>, <a href="https://github.com/alix1383">@Alix1383</a>, <a href="https://github.com/moaminsharifi">@moaminsharifi</a>, <a href="https://github.com/hamidrezakp">@hamidrezakp</a> and <a href="https://github.com/mehrad77">@mehrad77</a>.</li>
</ul>
<p>使用右上角的语言选择器切换语言。</p>
<h2><a class="header" href="#未完成的翻译" id="未完成的翻译">未完成的翻译</a></h2>
<p>还有很多语言版本仍在翻译中。以下是最近更新的翻译版本的链接：</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/ar/">Arabic</a> by <a href="https://github.com/younies">@younies</a></li>
<li><a href="https://google.github.io/comprehensive-rust/bn/">孟加拉语版本</a> 译者：<a href="https://github.com/raselmandol">@raselmandol</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">French</a> by <a href="https://github.com/KookaS">@KookaS</a>, <a href="https://github.com/vcaen">@vcaen</a> and <a href="https://github.com/AdrienBaudemont">@AdrienBaudemont</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">德语版本</a> 译者：<a href="https://github.com/Throvn">@Throvn</a> 和 <a href="https://github.com/ronaldfw">@ronaldfw</a>。</li>
<li><a href="https://google.github.io/comprehensive-rust/it/">意大利语版本</a> 译者：<a href="https://github.com/henrythebuilder">@henrythebuilder</a> 和 <a href="https://github.com/detro">@detro</a>。</li>
</ul>
<p>The full list of translations with their current status is also available either <a href="https://google.github.io/comprehensive-rust/translation-report.html">as of their last update</a> or <a href="https://google.github.io/comprehensive-rust/synced-translation-report.html">synced to the latest version of the course</a>.</p>
<p>如果你想协助翻译，请参阅 <a href="https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md">翻译说明</a>，了解如何开始翻译工作。翻译工作可通过 <a href="https://github.com/google/comprehensive-rust/issues/282">此议题</a> 追踪。</p>
<h1><a class="header" href="#使用-cargo" id="使用-cargo">使用 Cargo</a></h1>
<p>开始了解 Rust 后，你很快就会遇到 <a href="https://doc.rust-lang.org/cargo/">Cargo</a>，这是 Rust 生态系统中用于构建和运行 Rust 应用的标准工具。在这里，我们想简要介绍一下什么是 Cargo、它如何融入更广泛的生态系统， 以及我们如何在本培训中合理利用 Cargo。</p>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<blockquote>
<p><strong>请按照 <a href="https://rustup.rs/">https://rustup.rs/</a> 上的说明操作。</strong></p>
</blockquote>
<p>这将为你提供 Cargo 构建工具 (<code>cargo</code>)和 Rust 编译器 (<code>rustc</code>)。你还将获得 <code>rustup</code>，这是一个命令行实用程序,你可以用它来安装不同的编译器版本。</p>
<p>安装 Rust 之后，你应当配置你的编辑器或 IDE 以开始使用 Rust。大多数编辑器使用了 <a href="https://rust-analyzer.github.io/">rust-analyzer</a>。它为 <a href="https://code.visualstudio.com/">VS Code</a>、<a href="https://rust-analyzer.github.io/manual.html#emacs">Emacs</a>、<a href="https://rust-analyzer.github.io/manual.html#vimneovim">Vim/Neovim</a> 及其他许多编辑器提供了自动补全及定义跳转的功能。同样也可以使用 <a href="https://www.jetbrains.com/rust/">RustRover</a> IDE。</p>
<details>
<ul>
<li>
<p>On Debian/Ubuntu, you can also install Cargo, the Rust source and the <a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> via <code>apt</code>. However, this gets you an outdated Rust version and may lead to unexpected behavior. The command would be:</p>
<pre><code class="language-shell">sudo apt install cargo rust-src rustfmt
</code></pre>
</li>
<li>
<p>On macOS, you can use <a href="https://brew.sh/">Homebrew</a> to install Rust, but this may provide an outdated version. Therefore, it is recommended to install Rust from the official site.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust-生态系统" id="rust-生态系统">Rust 生态系统</a></h1>
<p>Rust 生态系统由许多工具组成，主要包括：</p>
<ul>
<li>
<p><code>rustc</code>：Rust 编译器，可将 <code>.rs</code> 文件转换为二进制文件和其他中间格式。</p>
</li>
<li>
<p><code>cargo</code>：Rust 依赖项管理器和构建工具。Cargo 知道如何下载托管在 <a href="https://crates.io">https://crates.io</a> 上的依赖项,并在构建项目时将它们传递给 <code>rustc</code>。Cargo 还附带一个内置的测试运行程序，用于执行单元测试。</p>
</li>
<li>
<p><code>rustup</code>：Rust 工具链安装和更新工具。当 Rust 发布新版本时，此工具用于安装并更新 <code>rustc</code> 和 <code>cargo</code>。 此外，<code>rustup</code> 还可以下载标准库的文档。可以同时安装多个版本的 Rust，<code>rustup</code> 会根据需要让你在这些版本之间切换。</p>
</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>
<p>Rust 有一个快速发布时间表，每六周就会发布一次新版本。新版本保持与旧版本的向后兼容性，并添加新功能。</p>
</li>
<li>
<p>共有三个发布阶段：“稳定版（stable）”、“测试版（beta）”和“夜间版（nightly）”。</p>
</li>
<li>
<p>新功能会先在“夜间版”上测试，“测试版”会每六周转为“稳定版”。</p>
</li>
<li>
<p>依赖关系也可以通过其他 <a href="https://doc.rust-lang.org/cargo/reference/registries.html">registry</a>、git 及文件夹等解析。</p>
</li>
<li>
<p>Rust 区分 <a href="https://doc.rust-lang.org/edition-guide/">版本（edition）</a>：当前版本是 Rust 2021。之前的版本是 Rust 2015 和 Rust 2018。</p>
<ul>
<li>
<p>这些版本支持对语言进行向后不兼容的更改。</p>
</li>
<li>
<p>为防止破坏代码，版本是可选的： 通过 <code>Cargo.toml</code> 文件为 crate 选择合适的版本。</p>
</li>
<li>
<p>为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。</p>
</li>
<li>
<p>请注意，不借助 <code>cargo</code> 直接使用编译器的情况相当少见（大多数用户从不这样做）。</p>
</li>
<li>
<p>值得一提的是，Cargo 本身就是一个功能强大且全面的工具。它能够实现许多高级功能，包括但不限于：</p>
<ul>
<li>项目/软件包结构</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">工作区</a></li>
<li>开发依赖和运行时依赖管理/缓存</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">构建脚本</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">全局安装</a></li>
<li>它还可以使用子命令插件（例如 <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>）进行扩展。</li>
</ul>
</li>
<li>
<p>详情请参阅 <a href="https://doc.rust-lang.org/cargo/">官方 Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#本培训中的代码示例" id="本培训中的代码示例">本培训中的代码示例</a></h1>
<p>在本培训中，我们将主要通过示例探索 Rust 语言，这些示例可以通过浏览器执行。这能大大简化配置过程， 并确保所有人都能获得一致的体验。</p>
<p>我们仍然建议你安装 Cargo：它有助于你更轻松地完成练习。在最后一天，我们要做一个综合的练习， 向你展示如何使用依赖项，因此你需要安装 Cargo。</p>
<p>本课程中的代码块是完全交互式的：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the text box.</p>
<details>
<p>如上所示，大多数代码示例都可修改。少数代码示例可能会因以下原因而不可修改：</p>
<ul>
<li>
<p>嵌入的 Playground 无法执行单元测试。将代码复制并粘贴到实际 Playground 中，以演示单元测试。</p>
</li>
<li>
<p>嵌入的 Playground 会在离开页面后丢失编辑状态！因此，学员应使用本地安装的 Rust 或通过 Playground 解题。</p>
</li>
</ul>
</details>
<h1><a class="header" href="#使用-cargo-在本地运行代码" id="使用-cargo-在本地运行代码">使用 Cargo 在本地运行代码</a></h1>
<p>如果你想在自己的系统上进行代码实验， 则需要先安装 Rust。为此，请按照 <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust Book 中的说明</a> 操作。这应会为你提供一个有效的 <code>rustc</code> 和 <code>cargo</code>。在撰写本文时，最新的 Rust 稳定版是以下的版本号：</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>你也可以使用任何更高版本，因为 Rust 保持向后兼容性。</p>
<p>了解这些信息后，请按照以下步骤从本培训中的一个示例中构建 Rust 二进制文件：</p>
<ol>
<li>
<p>在你要复制的示例上点击“复制到剪贴板（Copy to clipboard）”按钮。</p>
</li>
<li>
<p>使用 <code>cargo new exercise</code> 为代码新建一个 <code>exercise/</code> 目录：</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>转到 <code>exercise/</code> 并使用 <code>cargo run</code> 构建并运行二进制文件：</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>将 <code>src/main.rs</code> 中的样板代码替换为自己的代码。例如， 使用上一页中的示例，将 <code>src/main.rs</code> 改为：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>使用 <code>cargo run</code> 构建并运行更新后的二进制文件：</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>使用 <code>cargo check</code> 快速检查项目是否存在错误；使用 <code>cargo build</code> 只进行编译，而不运行。你可以在 <code>target/debug/</code> 中找到常规调试 build 的输出。使用 <code>cargo build --release</code> 在 <code>target/release/</code> 中生成经过优化的 发布 build。</p>
</li>
<li>
<p>可以通过修改 <code>Cargo.toml</code> 为项目添加依赖项。当运行 <code>cargo</code> 命令时，系统会自动下载和编译缺失的依赖项。</p>
</li>
</ol>
<details>
<p>尽量鼓励全班学员安装 Cargo 并使用本地编辑器。这能使他们拥有常规的开发环境，让工作变得更加轻松。</p>
</details>
<h1><a class="header" href="#欢迎来到第一天" id="欢迎来到第一天">欢迎来到第一天</a></h1>
<p>今天是学习 Comprehensive Rust 的第一天。我们会涉及很多内容：</p>
<ul>
<li>Rust 基本语法：变量、标量（scalar）和复合（compound）类型、枚举（Enum）、结构体（struct）、引用、函数和方法。</li>
<li>Types and type inference.</li>
<li>控制流结构：循环、条件语句等。</li>
<li>用户定义的类型：结构体和枚举。</li>
<li>模式匹配：解构枚举、结构体和数组（array）。</li>
</ul>
<h2><a class="header" href="#时间表" id="时间表">时间表</a></h2>
<p>{{%session outline}}</p>
<details>
<p>请提醒学生：</p>
<ul>
<li>他们可以随时提问，不需要留到最后。</li>
<li>这个课程本应该是互动的，我们鼓励大家积极讨论。
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e., keep the discussions related to how Rust does things vs some other language. It can be hard to find the right balance, but err on the side of allowing discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>有些问题会导致我们提前谈到后面的内容。
<ul>
<li>这完全没有问题！重复是学习的一个重要方法。请记住，这些幻灯片只是一种辅助，你可以选择性地跳过。</li>
</ul>
</li>
</ul>
<p>第一天的目标是展示 Rust 中与其他编程语言有明显相似之处的 “基础”内容。Rust 中更高级复杂的内容将在后续几天中逐步介绍。</p>
<p>如果您是在教室里授课，则这是一个好时机，可对课程时间表进行讲解。请注意，每节课结束之后会有练习内容，然后是休息时间。安排在休息结束后讲解练习内容的解答。为了确保课程按时间表进行，此处所列时间仅供参考。请按需进行灵活调整！</p>
</details><h1><a class="header" href="#hello-world" id="hello-world">Hello, World</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#什么是-rust" id="什么是-rust">什么是 Rust？</a></h1>
<p>Rust 是一门新的编程语言，它的<a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 版本于 2015 年发布</a>：</p>
<ul>
<li>Rust 是一门静态编译语言，其功能定位与 C++ 相似
<ul>
<li><code>rustc</code> 使用 LLVM 作为它的后端。</li>
</ul>
</li>
<li>Rust 支持多种<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">平台和架构</a>:
<ul>
<li>x86、ARM、WebAssembly......</li>
<li>Linux、Mac、Windows......</li>
</ul>
</li>
<li>Rust 被广泛用于各种设备中：
<ul>
<li>固件和引导程序，</li>
<li>智能显示器，</li>
<li>手机，</li>
<li>桌面，</li>
<li>服务器。</li>
</ul>
</li>
</ul>
<details>
<p>Rust 和 C++ 适用于类似的场景：</p>
<ul>
<li>极高的灵活性。</li>
<li>高度的控制能力。</li>
<li>能够在资源匮乏的设备（如手机）上运行。</li>
<li>没有运行时和垃圾收集。</li>
<li>关注程序可靠性和安全性，而不会牺牲任何性能。</li>
</ul>
</details>
<h1><a class="header" href="#rust-的优势" id="rust-的优势">Rust 的优势</a></h1>
<p>Rust 有一些独特的卖点：</p>
<ul>
<li>
<p><em>编译时内存安全</em>：在编译时可防止所有类内存 bug</p>
<ul>
<li>不存在未初始化的变量。</li>
<li>不存在“双重释放”。</li>
<li>不存在“释放后使用”。</li>
<li>不存在 <code>NULL</code> 指针。</li>
<li>不存在被遗忘的互斥锁。</li>
<li>不存在线程之间的数据竞争。</li>
<li>不存在迭代器失效。</li>
</ul>
</li>
<li>
<p><em>没有未定义的运行时行为</em>：每个 Rust 语句的行为都有明确定义</p>
<ul>
<li>数组访问有边界检查。</li>
<li>整数溢出有明确定义（panic 或回绕）。</li>
</ul>
</li>
<li>
<p><em>现代语言功能</em>：具有与高级语言一样丰富且人性化的表达能力</p>
<ul>
<li>枚举和模式匹配。</li>
<li>泛型。</li>
<li>无额外开销的外部函数接口（FFI）。</li>
<li>零成本抽象。</li>
<li>强大的编译器错误提示。</li>
<li>内置依赖管理器。</li>
<li>对测试的内置支持。</li>
<li>优秀的语言服务协议（Language Server Protocol）支持。</li>
</ul>
</li>
</ul>
<details>
<p>不用在这里占用过多时间。所有这些要点均会在后面进行详细讲解。</p>
<p>应该问问学生们都使用过哪些语言。根据答案侧重讲解 Rust 的不同特性：</p>
<ul>
<li>
<p>使用过 C 或 C++：Rust 利用借用检查消除了一类 <em>运行时错误</em> 。你可以达到堪比 C 和 C++ 的性能，而没有内存不安全的问题。并且你还可以得到些现代的语言构造，比如模式匹配和内置依赖管理。</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript...: You get the same memory safety as in those languages, plus a similar high-level language feeling. In addition you get fast and predictable performance like C and C++ (no garbage collector) as well as access to low-level hardware (should you need it).</p>
</li>
</ul>
</details><h1><a class="header" href="#playground" id="playground">Playground</a></h1>
<p>The <a href="https://play.rust-lang.org/">Rust Playground</a> provides an easy way to run short Rust programs, and is the basis for the examples and exercises in this course. Try running the &quot;hello-world&quot; program it starts with. It comes with a few handy features:</p>
<ul>
<li>
<p>在 &quot;Tools&quot; 下，使用 <code>rustfmt</code> 选项以 &quot;standard&quot; 方式设置代码格式。</p>
</li>
<li>
<p>Rust 具有两个用于生成代码的主要 “配置文件”：调试（进行额外运行时检查、较少优化）和发布（较少运行时检查，进行大量优化）。可以在顶部的 &quot;Debug&quot; 下访问这些内容。</p>
</li>
<li>
<p>如果感兴趣，您可以使用 &quot;...&quot; 下的 &quot;ASM&quot; 查看生成的汇编代码。</p>
</li>
</ul>
<details>
<p>As students head into the break, encourage them to open up the playground and experiment a little. Encourage them to keep the tab open and try things out during the rest of the course. This is particularly helpful for advanced students who want to know more about Rust's optimizations or generated assembly.</p>
</details><h1><a class="header" href="#类型和值" id="类型和值">类型和值</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#hello-world-1" id="hello-world-1">Hello, World</a></h1>
<p>让我们进入最简单的 Rust 程序，一个经典的 Hello World 程序：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello 🌍!&quot;);
}
</code></pre></pre>
<p>你看到的：</p>
<ul>
<li>函数以 <code>fn</code> 开头。</li>
<li>像 C 和 C++ 一样，块由花括号分隔。</li>
<li><code>main</code> 函数是程序的入口点。</li>
<li>Rust 有卫生宏 (hygienic macros)，<code>println!</code> 就是一个例子。</li>
<li>Rust 字符串是 UTF-8 编码的，可以包含任何 Unicode 字符。</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see a ton of it over the next four days so we start small with something familiar.</p>
<p>关键点：</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is imperative and it doesn't try to reinvent things unless absolutely necessary.</p>
</li>
<li>
<p>Rust 是一门现代编程语言，它完全支持 Unicode 等特性。</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of arguments (no function <a href="types-and-values/../control-flow-basics/functions.html">overloading</a>).</p>
</li>
<li>
<p>宏是“卫生的”，这意味着它们不会意外地捕获它们所在作用域中的标识符。实际上，Rust 的宏只是<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">部分卫生</a>。</p>
</li>
<li>
<p>Rust 是多范式编程语言。例如，它具有强大的<a href="https://doc.rust-lang.org/book/ch17-00-oop.html">面向对象的编程功能</a>，虽然它不是函数式语言，但包括一系列的<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">函数概念</a>。</p>
</li>
</ul>
</details><h1><a class="header" href="#变量" id="变量">变量</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are made with <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>取消备注 <code>x = 20</code>，以证明变量默认是不可变的。添加 <code>mut</code> 关键字以允许进行更改。</p>
</li>
<li>
<p>这里的 <code>i32</code> 是变量的类型。编译时必须已知类型，但在很多情况下，由于具有类型推理功能（稍后介绍），程序员可以忽略这一点。</p>
</li>
</ul>
</details><h1><a class="header" href="#值" id="值">值</a></h1>
<p>以下是一些基本的内置类型以及每种类型的字面量值的语法。</p>
<table><thead><tr><th></th><th>类型</th><th>字面量</th></tr></thead><tbody>
<tr><td>有符号整数</td><td><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>isize</code></td><td><code>-10</code>、<code>0</code>、<code>1_000</code>、<code>123_i64</code></td></tr>
<tr><td>无符号整数</td><td><code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></td><td><code>0</code>、<code>123</code>、<code>10_u16</code></td></tr>
<tr><td>浮点数</td><td><code>f32</code>、<code>f64</code></td><td><code>3.14</code>、<code>-10.0e20</code>、<code>2_f32</code></td></tr>
<tr><td>Unicode 标量类型</td><td><code>char</code></td><td><code>'a'</code>、<code>'α'</code>、<code>'∞'</code></td></tr>
<tr><td>布尔值</td><td><code>bool</code></td><td><code>true</code>、<code>false</code></td></tr>
</tbody></table>
<p>各类型占用的空间为：</p>
<ul>
<li><code>iN</code>, <code>uN</code> 和 <code>fN</code> 占用 <em>N</em> 位，</li>
<li><code>isize</code> 和 <code>usize</code> 占用一个指针大小的空间，</li>
<li><code>char</code> 占用 32 位空间，</li>
<li><code>bool</code> 占用 8 位空间。</li>
</ul>
<details>
<p>上表中还有一些未提及的语法：</p>
<ul>
<li>数字中的所有下划线均可忽略，它们只是为了方便辨识。因此，<code>1_000</code> 可以写为 <code>1000</code>（或 <code>10_00</code>），而 <code>123_i64</code> 可以写为 <code>123i64</code>。</li>
</ul>
</details><h1><a class="header" href="#算术" id="算术">算术</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn interproduct(a: i32, b: i32, c: i32) -&gt; i32 {
    return a * b + b * c + c * a;
}

fn main() {
    println!(&quot;result: {}&quot;, interproduct(120, 100, 248));
}
</code></pre></pre>
<details>
<p>这是我们第一次看到除 <code>main</code> 之外的函数，不过其含义应该很明确：它接受三个整数，然后返回一个整数。稍后会对这些函数进行详细介绍。</p>
<p>算术和优先级均与其他语言极为相似。</p>
<p>What about integer overflow? In C and C++ overflow of <em>signed</em> integers is actually undefined, and might do unknown things at runtime. In Rust, it's defined.</p>
<p>Change the <code>i32</code>'s to <code>i16</code> to see an integer overflow, which panics (checked) in a debug build and wraps in a release build. There are other options, such as overflowing, saturating, and carrying. These are accessed with method syntax, e.g., <code>(a * b).saturating_add(b * c).saturating_add(c * a)</code>.</p>
<p>事实上，编译器会检测常量表达式的溢出情况，这便是为何该示例需要单独的函数。</p>
</details><h1><a class="header" href="#类型推导" id="类型推导">类型推导</a></h1>
<p>Rust 会根据变量的使用来确定其类型：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>这张幻灯片演示了 Rust 编译器是如何根据变量声明和用法来推导其类型的。</p>
<p>需要重点强调的是这样声明的变量并非像那种动态类型语言中可以持有任何数据的“任何类型”。这种声明所生成的机器码与明确类型声明完全相同。编译器进行类型推导能够让我们编写更简略的代码。</p>
<p>当整数字面量的类型不受限制时，Rust 默认为 <code>i32</code>。这在错误消息中有时显示为 <code>{integer}</code>。同样，浮点字面量默认为 <code>f64</code>。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    let x = 3.14;
    let y = 20;
    assert_eq!(x, y);
    // ERROR: no implementation for `{float} == {integer}`
}
</code></pre></pre>
</details><h1><a class="header" href="#练习fibonacci" id="练习fibonacci">练习：Fibonacci</a></h1>
<p>The Fibonacci sequence begins with <code>[0,1]</code>. For n&gt;1, the n'th Fibonacci number is calculated recursively as the sum of the n-1'th and n-2'th Fibonacci numbers.</p>
<p>Write a function <code>fib(n)</code> that calculates the n'th Fibonacci number. When will this function panic?</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        // The base case.
        todo!(&quot;Implement this&quot;)
    } else {
        // The recursive case.
        todo!(&quot;Implement this&quot;)
    }
}

fn main() {
    let n = 20;
    println!(&quot;fib({n}) = {}&quot;, fib(n));
}
</code></pre></pre>
<h1><a class="header" href="#解答" id="解答">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

fn main() {
    let n = 20;
    println!(&quot;fib({n}) = {}&quot;, fib(n));
}
</code></pre></pre>
<h1><a class="header" href="#控制流基础" id="控制流基础">控制流基础</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#if-表达式" id="if-表达式"><code>if</code> 表达式</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> 表达式</a> 的用法与其他语言中的 <code>if</code> 语句完全一样。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 10;
    if x == 0 {
        println!(&quot;zero!&quot;);
    } else if x &lt; 100 {
        println!(&quot;biggish&quot;);
    } else {
        println!(&quot;huge&quot;);
    }
}
</code></pre></pre>
<p>此外，你还可以将 <code>if</code> 用作一个表达式。每个块的最后一个表达式 将成为 <code>if</code> 表达式的值：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 10;
    let size = if x &lt; 20 { &quot;small&quot; } else { &quot;large&quot; };
    println!(&quot;number size: {}&quot;, size);
}
</code></pre></pre>
<details>
<p>Because <code>if</code> is an expression and must have a particular type, both of its branch blocks must have the same type. Show what happens if you add <code>;</code> after <code>&quot;small&quot;</code> in the second example.</p>
<p>An <code>if</code> expression should be used in the same way as the other expressions. For example, when it is used in a <code>let</code> statement, the statement must be terminated with a <code>;</code> as well. Remove the <code>;</code> before <code>println!</code> to see the compiler error.</p>
</details><h1><a class="header" href="#循环控制" id="循环控制">循环控制</a></h1>
<p>Rust 中有三个循环关键字：<code>while</code>、<code>loop</code> 和 <code>for</code>：</p>
<h2><a class="header" href="#while" id="while"><code>while</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> keyword</a> works much like in other languages, executing the loop body as long as the condition is true.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 200;
    while x &gt;= 10 {
        x = x / 2;
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#for" id="for"><code>for</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> iterates over ranges of values or the items in a collection:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    for x in 1..5 {
        println!(&quot;x: {x}&quot;);
    }

    for elem in [1, 2, 3, 4, 5] {
        println!(&quot;elem: {elem}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Under the hood <code>for</code> loops use a concept called &quot;iterators&quot; to handle iterating over different kinds of ranges/collections. Iterators will be discussed in more detail later.</li>
<li>Note that the first <code>for</code> loop only iterates to <code>4</code>. Show the <code>1..=5</code> syntax for an inclusive range.</li>
</ul>
</details>
<h1><a class="header" href="#loop" id="loop"><code>loop</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.loop.html"><code>loop</code> statement</a> just loops forever, until a <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        println!(&quot;{i}&quot;);
        if i &gt; 100 {
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#break-和-continue" id="break-和-continue"><code>break</code> 和 <code>continue</code></a></h1>
<p>如果需要立即启动 下一次迭代，请使用 <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>。</p>
<p>If you want to exit any kind of loop early, use <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>. With <code>loop</code>, this can take an optional expression that becomes the value of the <code>loop</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        if i &gt; 5 {
            break;
        }
        if i % 2 == 0 {
            continue;
        }
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<details>
<p>Note that <code>loop</code> is the only looping construct which can return a non-trivial value. This is because it's guaranteed to only return at a <code>break</code> statement (unlike <code>while</code> and <code>for</code> loops, which can also return when the condition fails).</p>
</details><h1><a class="header" href="#labels" id="labels">Labels</a></h1>
<p><code>continue</code> 和 <code>break</code> 都可以选择接受一个标签参数，用来 终止嵌套循环：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = [[5, 6, 7], [8, 9, 10], [21, 15, 32]];
    let mut elements_searched = 0;
    let target_value = 10;
    'outer: for i in 0..=2 {
        for j in 0..=2 {
            elements_searched += 1;
            if s[i][j] == target_value {
                break 'outer;
            }
        }
    }
    print!(&quot;elements searched: {elements_searched}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Labeled break also works on arbitrary blocks, e.g.
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'label: {
    break 'label;
    println!(&quot;This line gets skipped&quot;);
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</details>
<h1><a class="header" href="#代码块和作用域" id="代码块和作用域">代码块和作用域</a></h1>
<h2><a class="header" href="#块" id="块">块</a></h2>
<p>A block in Rust contains a sequence of expressions, enclosed by braces <code>{}</code>. Each block has a value and a type, which are those of the last expression of the block:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let z = 13;
    let x = {
        let y = 10;
        println!(&quot;y: {y}&quot;);
        z - y
    };
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<details>
<ul>
<li>你可以通过更改块的最后一行，来展示块值的变化情况。例如，添加/移除分号或使用 <code>return</code>。</li>
</ul>
</details><h1><a class="header" href="#作用域和遮蔽shadowing" id="作用域和遮蔽shadowing">作用域和遮蔽（Shadowing）</a></h1>
<p>变量的作用域仅限于封闭代码块内。</p>
<p>你可以隐藏变量，位于外部作用域的变量和 相同作用域的变量都可以：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);
    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Show that a variable's scope is limited by adding a <code>b</code> in the inner block in the last example, and then trying to access it outside that block.</li>
<li>Shadowing is different from mutation, because after shadowing both variables' memory locations exist at the same time. Both are available under the same name, depending where you use it in the code.</li>
<li>A shadowing variable can have a different type.</li>
<li>隐藏起初看起来会有些晦涩，但是它很便于存 <code>.unwrap()</code> 之后的得到的值。</li>
</ul>
</details>
<h1><a class="header" href="#函数" id="函数">函数</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn gcd(a: u32, b: u32) -&gt; u32 {
    if b &gt; 0 {
        gcd(b, a % b)
    } else {
        a
    }
}

fn main() {
    println!(&quot;gcd: {}&quot;, gcd(143, 52));
}
</code></pre></pre>
<details>
<ul>
<li>类型跟随在声明的参数后（与某些编程语言相反），然后是返回类型。</li>
<li>The last expression in a function body (or any block) becomes the return value. Simply omit the <code>;</code> at the end of the expression. The <code>return</code> keyword can be used for early return, but the &quot;bare value&quot; form is idiomatic at the end of a function (refactor <code>gcd</code> to use a <code>return</code>).</li>
<li>Some functions have no return value, and return the 'unit type', <code>()</code>. The compiler will infer this if the return type is omitted.</li>
<li>Overloading is not supported -- each function has a single implementation.
<ul>
<li>始终采用固定数量的参数。不支持默认参数。宏可用于支持可变函数。</li>
<li>Always takes a single set of parameter types. These types can be generic, which will be covered later.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#宏" id="宏">宏</a></h1>
<p>宏在编译过程中会扩展为 Rust 代码，并且可以接受可变数量的参数。它们以 <code>!</code> 结尾来进行区分。Rust 标准库包含各种有用的宏。</p>
<ul>
<li><code>println!(format, ..)</code> prints a line to standard output, applying formatting described in <a href="https://doc.rust-lang.org/std/fmt/index.html"><code>std::fmt</code></a>.</li>
<li><code>format!(format, ..)</code> 的用法与 <code>println!</code> 类似，但它以字符串形式返回结果。</li>
<li><code>dbg!(expression)</code> 会记录表达式的值并返回该值。</li>
<li><code>todo!()</code> 用于标记尚未实现的代码段。如果执行该代码段，则会触发 panic。</li>
<li><code>unreachable!()</code> 用于标记无法访问的代码段。如果执行该代码段，则会触发 panic。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn factorial(n: u32) -&gt; u32 {
    let mut product = 1;
    for i in 1..=n {
        product *= dbg!(i);
    }
    product
}

fn fizzbuzz(n: u32) -&gt; u32 {
    todo!()
}

fn main() {
    let n = 4;
    println!(&quot;{n}! = {}&quot;, factorial(n));
}
</code></pre></pre>
<details>
<p>这一节的要点是介绍这些常见的便捷功能以及如何使用它们。而为何将它们定义为宏以及它们可以扩展为什么内容，并不是特别关键。</p>
<p>本课程不会介绍如何定义宏，但在后续部分会介绍派生宏的用法。</p>
</details><h1><a class="header" href="#练习考拉兹序列" id="练习考拉兹序列">练习：考拉兹序列</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Sequence</a> is defined as follows, for an arbitrary n<sub>1</sub> greater than zero:</p>
<ul>
<li>If <em>n<sub>i</sub></em> is 1, then the sequence terminates at <em>n<sub>i</sub></em>.</li>
<li>If <em>n<sub>i</sub></em> is even, then <em>n<sub>i+1</sub> = n<sub>i</sub> / 2</em>.</li>
<li>If <em>n<sub>i</sub></em> is odd, then <em>n<sub>i+1</sub> = 3 * n<sub>i</sub> + 1</em>.</li>
</ul>
<p>For example, beginning with <em>n<sub>1</sub></em> = 3:</p>
<ul>
<li>3 is odd, so <em>n<sub>2</sub></em> = 3 * 3 + 1 = 10;</li>
<li>10 is even, so <em>n<sub>3</sub></em> = 10 / 2 = 5;</li>
<li>5 is odd, so <em>n<sub>4</sub></em> = 3 * 5 + 1 = 16;</li>
<li>16 is even, so <em>n<sub>5</sub></em> = 16 / 2 = 8;</li>
<li>8 is even, so <em>n<sub>6</sub></em> = 8 / 2 = 4;</li>
<li>4 is even, so <em>n<sub>7</sub></em> = 4 / 2 = 2;</li>
<li>2 is even, so <em>n<sub>8</sub></em> = 1; and</li>
<li>序列终止。</li>
</ul>
<p>编写一个函数，用于计算给定初始 <code>n</code> 的考拉兹序列的长度。</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
  todo!(&quot;Implement this&quot;)
}

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}

fn main() {
    println!(&quot;Length: {}&quot;, collatz_length(11));
}
</code></pre></pre>
<h1><a class="header" href="#解答-1" id="解答-1">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
    let mut len = 1;
    while n &gt; 1 {
        n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };
        len += 1;
    }
    len
}

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}

fn main() {
    println!(&quot;Length: {}&quot;, collatz_length(11));
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back" id="welcome-back">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#元组和数组" id="元组和数组">元组和数组</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#数组arrays" id="数组arrays">数组（Arrays）</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {a:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant) elements of the same type <code>T</code>. Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and <code>[u8; 4]</code> are considered two different types. Slices, which have a size determined at runtime, are covered later.</p>
</li>
<li>
<p>请尝试访问出界数组元素。系统会在运行时检查数组访问。Rust 通常会通过优化消除这些检查，以及使用不安全的 Rust 来避免这些检查。</p>
</li>
<li>
<p>我们可以使用字面量来为数组赋值。</p>
</li>
<li>
<p>The <code>println!</code> macro asks for the debug implementation with the <code>?</code> format parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. Types such as integers and strings implement the default output, but arrays only implement the debug output. This means that we must use debug output here.</p>
</li>
<li>
<p>添加 <code>#</code>，比如 <code>{a:#?}</code>，会输出“美观打印（pretty printing）” 格式，这种格式可能会更加易读。</p>
</li>
</ul>
</details><h1><a class="header" href="#元组tuples" id="元组tuples">元组（Tuples）</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;t.0: {}&quot;, t.0);
    println!(&quot;t.1: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>和数组一样，元组也具有固定的长度。</p>
</li>
<li>
<p>元组将不同类型的值组成一个复合类型。</p>
</li>
<li>
<p>元组中的字段可以通过英文句号加上值的下标进行访问比如：<code>t.0</code>, <code>t.1</code>。</p>
</li>
<li>
<p>The empty tuple <code>()</code> is referred to as the &quot;unit type&quot; and signifies absence of a return value, akin to <code>void</code> in other languages.</p>
</li>
</ul>
</details><h1><a class="header" href="#数组迭代" id="数组迭代">数组迭代</a></h1>
<p><code>for</code> 语句支持对数组进行迭代（但不支持元组）。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19];
    for prime in primes {
        for i in 2..prime {
            assert_ne!(prime % i, 0);
        }
    }
}
</code></pre></pre>
<details>
<p>此功能使用了 <code>IntoIterator</code> trait，但我们还没有讲到它。</p>
<p>The <code>assert_ne!</code> macro is new here. There are also <code>assert_eq!</code> and <code>assert!</code> macros. These are always checked, while debug-only variants like <code>debug_assert!</code> compile to nothing in release builds.</p>
</details><h1><a class="header" href="#解构" id="解构">解构</a></h1>
<p>When working with tuples and other structured values it's common to want to extract the inner values into local variables. This can be done manually by directly accessing the inner values:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_tuple(tuple: (i32, i32)) {
    let left = tuple.0;
    let right = tuple.1;
    println!(&quot;left: {left}, right: {right}&quot;);
}
</code></pre></pre>
<p>However, Rust also supports using pattern matching to destructure a larger value into its constituent parts:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_tuple(tuple: (i32, i32)) {
    let (left, right) = tuple;
    println!(&quot;left: {left}, right: {right}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The patterns used here are &quot;irrefutable&quot;, meaning that the compiler can statically verify that the value on the right of <code>=</code> has the same structure as the pattern.</li>
<li>A variable name is an irrefutable pattern that always matches any value, hence why we can also use <code>let</code> to declare a single variable.</li>
<li>Rust also supports using patterns in conditionals, allowing for equality comparison and destructuring to happen at the same time. This form of pattern matching will be discussed in more detail later.</li>
<li>Edit the examples above to show the compiler error when the pattern doesn't match the value being matched on.</li>
</ul>
</details><h1><a class="header" href="#练习嵌套数组" id="练习嵌套数组">练习：嵌套数组</a></h1>
<p>数组可以包含其他数组：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
<span class="boring">}
</span></code></pre></pre>
<p>What is the type of this variable?</p>
<p>Use an array such as the above to write a function <code>transpose</code> which will transpose a matrix (turn rows into columns):</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7⎤</text><text x="250" y="28" >8⎥</text><text x="250" y="44" >9⎦</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">⎛</text><text x="98" y="12">⎡</text><text x="106" y="12">1</text></g><g><text x="90" y="28">⎜</text><text x="98" y="28">⎢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">⎝</text><text x="98" y="44">⎣</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3⎤</text><text x="154" y="12">⎞</text></g><g><text x="138" y="28">6⎥</text><text x="154" y="28">⎟</text></g><g><text x="138" y="44">9⎦</text><text x="154" y="44">⎠</text></g><g><text x="210" y="12">⎡</text><text x="218" y="12">1</text></g><g><text x="210" y="28">⎢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">⎣</text><text x="218" y="44">3</text></g></svg></div>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function. This function only operates on 3x3 matrices.</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix: {:#?}&quot;, matrix);
    let transposed = transpose(matrix);
    println!(&quot;transposed: {:#?}&quot;, transposed);
}
</code></pre></pre>
<h1><a class="header" href="#解答-2" id="解答-2">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    result
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix: {:#?}&quot;, matrix);
    let transposed = transpose(matrix);
    println!(&quot;transposed: {:#?}&quot;, transposed);
}
</code></pre></pre>
<h1><a class="header" href="#引用" id="引用">引用</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#共享引用" id="共享引用">共享引用</a></h1>
<p>A reference provides a way to access another value without taking ownership of the value, and is also called &quot;borrowing&quot;. Shared references are read-only, and the referenced data cannot change.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 'A';
    let b = 'B';
    let mut r: &amp;char = &amp;a;
    println!(&quot;r: {}&quot;, *r);
    r = &amp;b;
    println!(&quot;r: {}&quot;, *r);
}
</code></pre></pre>
<p>对类型 <code>T</code> 的共享引用表示为 <code>&amp;T</code>。可以使用 <code>&amp;</code> 运算符创建引用值。<code>*</code> 运算符会 “解引用”某个引用，并得到该引用值。</p>
<p>Rust 会静态禁止悬垂引用：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn x_axis(x: &amp;i32) -&gt; &amp;(i32, i32) {
    let point = (*x, 0);
    return &amp;point;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>References can never be null in Rust, so null checking is not necessary.</p>
</li>
<li>
<p>引用被称为 “借用”了其所引用的值，这对于不熟悉指针的学生来说是一个很好的模型：代码可以通过引用来访问值，但原始变量仍然保有对该值的 “所有权”。本课程会在第 3 天详细介绍所有权。</p>
</li>
<li>
<p>引用是以指针的形式实现的，其关键优势在于它们可以比其所指的内容小得多。熟悉 C 或 C++ 的学生会将引用视为指针。本课程的后续部分将介绍 Rust 如何防止因使用原始指针而导致的内存安全 bug。</p>
</li>
<li>
<p>Rust 不会自动为您创建引用，必须始终使用 <code>&amp;</code> 符号。</p>
</li>
<li>
<p>Rust will auto-dereference in some cases, in particular when invoking methods (try <code>r.is_ascii()</code>). There is no need for an <code>-&gt;</code> operator like in C++.</p>
</li>
<li>
<p>在本例中，<code>r</code> 是可变的，因此可以为其重新赋值 (<code>r = &amp;b</code>)。请注意，这会重新绑定 <code>r</code>，使其引用其他内容。这与 C++ 不同，在 C++ 中为引用赋值会更改引用的值。</p>
</li>
<li>
<p>共享引用不允许修改其所引用的值，即使该值是可变的。请尝试 <code>*r = 'X'</code>。</p>
</li>
<li>
<p>Rust 会跟踪所有引用的生命周期，以确保它们存在足够长的时间。在安全的 Rust 中不会出现悬空引用。<code>x_axis</code> 会返回对 <code>point</code> 的引用，但 <code>point</code> 会在该函数返回时取消分配，因此不会进行编译。</p>
</li>
<li>
<p>我们会在讲到所有权（ownership）时详细讨论借用（borrow）。</p>
</li>
</ul>
</details><h1><a class="header" href="#独占引用" id="独占引用">独占引用</a></h1>
<p>独占引用（也称为可变引用）允许更改其所引用的值。它们的类型为 <code>&amp;mut T</code>。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut point = (1, 2);
    let x_coord = &amp;mut point.0;
    *x_coord = 20;
    println!(&quot;point: {point:?}&quot;);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>
<p>“独占模式”表示只有此引用可用于访问该值。在独占引用存在期间，不允许同时存在其他引用（无论是共享引用还是独占引用），并且无法访问引用的值。请尝试在 <code>x_coord</code> 处于活动状态时创建 <code>&amp;point.0</code> 或更改 <code>point.0</code>。</p>
</li>
<li>
<p>Be sure to note the difference between <code>let mut x_coord: &amp;i32</code> and <code>let x_coord: &amp;mut i32</code>. The first one represents a shared reference which can be bound to different values, while the second represents an exclusive reference to a mutable value.</p>
</li>
</ul>
</details><h1><a class="header" href="#切片" id="切片">切片</a></h1>
<p>切片 (slice) 的作用是提供对集合 (collection) 的视图 (view):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];

    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>切片从被切片的类型中借用 (borrow) 数据。</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rust’s range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain 'alive' (in scope) for at least as long as our slice.</p>
</li>
</ul>
</details><!-- NOTES:
Including `&str` as a way of representing a slice of valid utf-8
-->
<h1><a class="header" href="#字符串" id="字符串">字符串</a></h1>
<p>现在我们就可以理解 Rust 中的两种字符串类型：</p>
<ul>
<li><code>&amp;str</code> is a slice of UTF-8 encoded bytes, similar to <code>&amp;[u8]</code>.</li>
<li><code>String</code> is an owned buffer of UTF-8 encoded bytes, similar to <code>Vec&lt;T&gt;</code>.</li>
</ul>
<!-- Avoid using fixed integers when slicing since this breaks
translations. Using the length of s1 and s2 is safe. -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);

    let s3: &amp;str = &amp;s2[s2.len() - s1.len()..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8 encoded string data stored in a block of memory. String literals (<code>&quot;Hello&quot;</code>), are stored in the program’s binary.</p>
</li>
<li>
<p>Rust's <code>String</code> type is a wrapper around a vector of bytes. As with a <code>Vec&lt;T&gt;</code>, it is owned.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string literal; <code>String::new()</code> creates a new empty string, to which string data can be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from dynamic values. It accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range selection. If you select a byte range that is not aligned to character boundaries, the expression will panic. The <code>chars</code> iterator iterates over characters and is preferred over trying to get character boundaries right.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>std::string_view</code> from C++, but the one that always points to a valid string in memory. Rust <code>String</code> is a rough equivalent of <code>std::string</code> from C++ (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
<li>
<p>Byte strings literals allow you to create a <code>&amp;[u8]</code> value directly:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, b&quot;abc&quot;);
    println!(&quot;{:?}&quot;, &amp;[97, 98, 99]);
}
</code></pre></pre>
</li>
<li>
<p>原始字符串可在创建 <code>&amp;str</code> 时禁用转义：<code>r&quot;\n&quot; == &quot;\\n&quot;</code>。可以在外层引号两侧添加相同数量的 <code>#</code>，以在字符串中嵌入双引号：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(r#&quot;&lt;a href=&quot;link.html&quot;&gt;link&lt;/a&gt;&quot;#);
    println!(&quot;&lt;a href=\&quot;link.html\&quot;&gt;link&lt;/a&gt;&quot;);
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#练习几何图形" id="练习几何图形">练习：几何图形</a></h1>
<p>我们将为三维几何图形创建几个实用函数，将点表示为 <code>[f64;3]</code>。函数签名由您自行确定。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// Calculate the magnitude of a vector by summing the squares of its coordinates
// and taking the square root. Use the `sqrt()` method to calculate the square
// root, like `v.sqrt()`.


fn magnitude(...) -&gt; f64 {
    todo!()
}

// Normalize a vector by calculating its magnitude and dividing all of its
// coordinates by that magnitude.


fn normalize(...) {
    todo!()
}

// Use the following `main` to test your work.

fn main() {
    println!(&quot;Magnitude of a unit vector: {}&quot;, magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!(&quot;Magnitude of {v:?}: {}&quot;, magnitude(&amp;v));
    normalize(&amp;mut v);
    println!(&quot;Magnitude of {v:?} after normalization: {}&quot;, magnitude(&amp;v));
}
</code></pre></pre>
<h1><a class="header" href="#解答-3" id="解答-3">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Calculate the magnitude of the given vector.
fn magnitude(vector: &amp;[f64; 3]) -&gt; f64 {
    let mut mag_squared = 0.0;
    for coord in vector {
        mag_squared += coord * coord;
    }
    mag_squared.sqrt()
}

/// Change the magnitude of the vector to 1.0 without changing its direction.
fn normalize(vector: &amp;mut [f64; 3]) {
    let mag = magnitude(vector);
    for item in vector {
        *item /= mag;
    }
}

fn main() {
    println!(&quot;Magnitude of a unit vector: {}&quot;, magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!(&quot;Magnitude of {v:?}: {}&quot;, magnitude(&amp;v));
    normalize(&amp;mut v);
    println!(&quot;Magnitude of {v:?} after normalization: {}&quot;, magnitude(&amp;v));
}
</code></pre></pre>
<h1><a class="header" href="#用户定义的类型" id="用户定义的类型">用户定义的类型</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#结构体" id="结构体">结构体</a></h1>
<p>与 C 和 C++ 一样，Rust 支持自定义结构体：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    name: String,
    age: u8,
}

fn describe(person: &amp;Person) {
    println!(&quot;{} is {} years old&quot;, person.name, person.age);
}

fn main() {
    let mut peter = Person { name: String::from(&quot;Peter&quot;), age: 27 };
    describe(&amp;peter);

    peter.age = 28;
    describe(&amp;peter);

    let name = String::from(&quot;Avery&quot;);
    let age = 39;
    let avery = Person { name, age };
    describe(&amp;avery);

    let jackie = Person { name: String::from(&quot;Jackie&quot;), ..avery };
    describe(&amp;jackie);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>结构体的运作方式与使用 C 或 C++ 时类似。
<ul>
<li>不需要 typedef 即可定义类型，这与使用 C++ 类似，但与使用 C 不同。</li>
<li>与使用 C++ 不同的是，结构体之间没有继承关系。</li>
</ul>
</li>
<li>This may be a good time to let people know there are different types of structs.
<ul>
<li>Zero-sized structs (e.g. <code>struct Foo;</code>) might be used when implementing a trait on some type but don’t have any data that you want to store in the value itself.</li>
<li>下一张幻灯片将介绍元组结构体，当字段名称不重要时使用。</li>
</ul>
</li>
<li>If you already have variables with the right names, then you can create the struct using a shorthand.</li>
<li>The syntax <code>..avery</code> allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element.</li>
</ul>
</details><!-- NOTES:
Tuple structs, newtype wrappers, unit-like structs, including initialization syntax
-->
<h1><a class="header" href="#元组结构体" id="元组结构体">元组结构体</a></h1>
<p>如果字段名称不重要，您可以使用元组结构体：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>这通常用于单字段封装容器（称为 newtype）：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}
</code></pre></pre>
<details>
<ul>
<li>如需对基元类型中的值的额外信息进行编码，使用 newtype 是一种非常好的方式，例如：
<ul>
<li>数字会以某些单位来衡量：上方示例中为 <code>Newtons</code>。</li>
<li>The value passed some validation when it was created, so you no longer have to validate it again at every use: <code>PhoneNumber(String)</code> or <code>OddNumber(u32)</code>.</li>
</ul>
</li>
<li>展示如何通过访问 newtype 中的单个字段，将 <code>f64</code> 值添加到 <code>Newtons</code> 类型。
<ul>
<li>Rust 通常不喜欢不明确的内容，例如自动解封或将布尔值用作整数。</li>
<li>运算符过载在第 3 天（泛型）讨论。</li>
</ul>
</li>
<li>此示例巧妙地引用了<a href="https://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F">火星气候探测者号</a> 的失败事故。</li>
</ul>
</details><h1><a class="header" href="#枚举" id="枚举">枚举</a></h1>
<p><code>enum</code> 关键字允许创建具有几个 不同变体的类型：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum Direction {
    Left,
    Right,
}

#[derive(Debug)]
enum PlayerMove {
    Pass,                        // Simple variant
    Run(Direction),              // Tuple variant
    Teleport { x: u32, y: u32 }, // Struct variant
}

fn main() {
    let player_move: PlayerMove = PlayerMove::Run(Direction::Left);
    println!(&quot;On this turn: {player_move:?}&quot;);
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type.</li>
<li><code>Direction</code> is a type with variants. There are two values of <code>Direction</code>: <code>Direction::Left</code> and <code>Direction::Right</code>.</li>
<li><code>PlayerMove</code> is a type with three variants. In addition to the payloads, Rust will store a discriminant so that it knows at runtime which variant is in a <code>PlayerMove</code> value.</li>
<li>This might be a good time to compare structs and enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads).</li>
<li>You could even implement the different variants of an enum with separate structs but then they wouldn’t be the same type as they would if they were all defined in an enum.</li>
</ul>
</li>
<li>Rust 使用最小的空间来存储判标识。
<ul>
<li>
<p>如有必要，它会存储所需最小大小的整数</p>
</li>
<li>
<p>如果允许的变体值未涵盖所有位模式，则它将使用无效的位模式对判别标识进行编码（“小众优化”）。例如，<code>Option&lt;&amp;u8&gt;</code> 存储的要么是指向整数的指针，要么是 <code>None</code> 变体的 <code>NULL</code> 值。</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[repr(u32)]
enum Bar {
    A, // 0
    B = 10000,
    C, // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}
</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2 bytes.</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#探索更多" id="探索更多">探索更多</a></h2>
<p>Rust 具有多种优化措施，可以减少枚举占用的空间。</p>
<ul>
<li>
<p>Null pointer optimization: For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look like in practice. It's important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    unsafe {
        println!(&quot;bool:&quot;);
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!(&quot;Option&lt;bool&gt;:&quot;);
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!(&quot;Option&lt;Option&lt;bool&gt;&gt;:&quot;);
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!(&quot;Option&lt;&amp;i32&gt;:&quot;);
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#const" id="const"><code>const</code></a></h1>
<p>Constants are evaluated at compile time and their values are inlined wherever they are used:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>根据 <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> 这些变量在使用时是内联 (inlined) 的。</p>
<p>在编译时只能调用标记为“const”的函数以生成“const”值。不过，可在运行时调用“const”函数。</p>
<details>
<ul>
<li>Mention that <code>const</code> behaves semantically similar to C++'s <code>constexpr</code></li>
<li>虽然需要使用在运行中求值的常量的情况并不是很常见，但是它是有帮助的，而且比使用静态变量更安全。</li>
</ul>
</details>
<h1><a class="header" href="#static" id="static"><code>static</code></a></h1>
<p>静态变量在程序的整个执行过程中始终有效，因此不会移动：</p>
<pre><pre class="playground"><code class="language-rust editable">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location. This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution. When a globally-scoped value does not have a reason to need object identity, <code>const</code> is generally preferred.</p>
<details>
<ul>
<li><code>static</code> is similar to mutable global variables in C++.</li>
<li><code>static</code> provides object identity: an address in memory and state as required by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
</ul>
<h1><a class="header" href="#探索更多-1" id="探索更多-1">探索更多</a></h1>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>. Interior mutability is possible through a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or similar.</p>
<p>Thread-local data can be created with the macro <code>std::thread_local</code>.</p>
</details>
<h1><a class="header" href="#类型别名" id="类型别名">类型别名</a></h1>
<p>类型别名为另一种类型创建名称。这两种类型可以互换使用。</p>
<pre><pre class="playground"><code class="language-rust editable">enum CarryableConcreteItem {
    Left,
    Right,
}

type Item = CarryableConcreteItem;

// Aliases are more useful with long, complex types:
use std::cell::RefCell;
use std::sync::{Arc, RwLock};
type PlayerInventory = RwLock&lt;Vec&lt;Arc&lt;RefCell&lt;Item&gt;&gt;&gt;&gt;;
</code></pre></pre>
<details>
<p>C 语言程序员会认为这类似于 <code>typedef</code>。</p>
</details><h1><a class="header" href="#练习电梯事件" id="练习电梯事件">练习：电梯事件</a></h1>
<p>我们将创建一个数据结构来表示电梯控制系统中的事件。您可以自行定义用于构造各种事件的类型和函数。使用 <code>#[derive(Debug)]</code> 以允许通过 <code>{:?}</code> 设置类型格式。</p>
<p>This exercise only requires creating and populating data structures so that <code>main</code> runs without errors. The next part of the course will cover getting data out of these structures.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    // TODO: add required variants
}

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    todo!()
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    todo!()
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    todo!()
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    todo!()
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    todo!()
}

fn main() {
    println!(
        &quot;A ground floor passenger has pressed the up button: {:?}&quot;,
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!(&quot;The car has arrived on the ground floor: {:?}&quot;, car_arrived(0));
    println!(&quot;The car door opened: {:?}&quot;, car_door_opened());
    println!(
        &quot;A passenger has pressed the 3rd floor button: {:?}&quot;,
        car_floor_button_pressed(3)
    );
    println!(&quot;The car door closed: {:?}&quot;, car_door_closed());
    println!(&quot;The car has arrived on the 3rd floor: {:?}&quot;, car_arrived(3));
}
</code></pre></pre>
<h1><a class="header" href="#解答-4" id="解答-4">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    /// A button was pressed.
    ButtonPressed(Button),

    /// The car has arrived at the given floor.
    CarArrived(Floor),

    /// The car's doors have opened.
    CarDoorOpened,

    /// The car's doors have closed.
    CarDoorClosed,
}

/// A floor is represented as an integer.
type Floor = i32;

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// A user-accessible button.
#[derive(Debug)]
enum Button {
    /// A button in the elevator lobby on the given floor.
    LobbyCall(Direction, Floor),

    /// A floor button within the car.
    CarFloor(Floor),
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    Event::CarArrived(floor)
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    Event::CarDoorOpened
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    Event::CarDoorClosed
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    Event::ButtonPressed(Button::LobbyCall(dir, floor))
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    Event::ButtonPressed(Button::CarFloor(floor))
}

fn main() {
    println!(
        &quot;A ground floor passenger has pressed the up button: {:?}&quot;,
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!(&quot;The car has arrived on the ground floor: {:?}&quot;, car_arrived(0));
    println!(&quot;The car door opened: {:?}&quot;, car_door_opened());
    println!(
        &quot;A passenger has pressed the 3rd floor button: {:?}&quot;,
        car_floor_button_pressed(3)
    );
    println!(&quot;The car door closed: {:?}&quot;, car_door_closed());
    println!(&quot;The car has arrived on the 3rd floor: {:?}&quot;, car_arrived(3));
}
</code></pre></pre>
<h1><a class="header" href="#欢迎来到第二天" id="欢迎来到第二天">欢迎来到第二天</a></h1>
<p>Now that we have seen a fair amount of Rust, today will focus on Rust's type system:</p>
<ul>
<li>Pattern matching: extracting data from structures.</li>
<li>方法：将函数与类型相关联。</li>
<li>特征：多个类型所共有的行为。</li>
<li>泛型：对其他类型进行类型参数化。</li>
<li>标准库类型和特征：探索 Rust 丰富的标准库。</li>
</ul>
<h2><a class="header" href="#时间表-1" id="时间表-1">时间表</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#模式匹配" id="模式匹配">模式匹配</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#matching-values" id="matching-values">Matching Values</a></h1>
<p>The <code>match</code> keyword lets you match a value against one or more <em>patterns</em>. The comparisons are done from top to bottom and the first match wins.</p>
<p>模式（pattern）可以是简单的值，其用法类似于 C 与 C++ 中的 <code>switch</code> 。</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let input = 'x';
    match input {
        'q'                       =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd'     =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'                 =&gt; println!(&quot;Number input&quot;),
        key if key.is_lowercase() =&gt; println!(&quot;Lowercase: {key}&quot;),
        _                         =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value. The expressions <em>must</em> be exhaustive, meaning that it covers every possibility, so <code>_</code> is often used as the final catch-all case.</p>
<p>Match can be used as an expression. Just like <code>if</code>, each match arm must have the same type. The type is the last expression of the block, if any. In the example above, the type is <code>()</code>.</p>
<p>模式中的变量（本例中为 <code>key</code>）将创建一个可在匹配分支内使用的绑定。</p>
<p>只有当条件为真时，保护语句才能使分支匹配成功。</p>
<details>
<p>关键点：</p>
<ul>
<li>
<p>You might point out how some specific characters are being used when in a pattern</p>
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li>“_”是通配符</li>
</ul>
</li>
<li>
<p>有些想法比模式本身所允许的程度更加复杂，如果我们希望简要地表达这些想法，就必须把匹配守卫视为独立的语法功能。</p>
</li>
<li>
<p>它们与匹配分支中的单独“if”表达式不同。选择匹配分支后，分支块内（在“=&gt;”之后）会出现“if”表达式。如果该分支块内的“if”条件失败，系统不会考虑原始“match”表达式的其他分支。</p>
</li>
<li>
<p>只要表达式在包含“|”的模式中，就会适用守卫定义的条件。</p>
</li>
</ul>
<h1><a class="header" href="#more-to-explore" id="more-to-explore">More To Explore</a></h1>
<ul>
<li>
<p>Another piece of pattern syntax you can show students is the <code>@</code> syntax which binds a part of a pattern to a variable. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt = Some(123);
match opt {
    outer @ Some(inner) =&gt; {
        println!(&quot;outer: {outer:?}, inner: {inner}&quot;);
    }
    None =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example <code>inner</code> has the value 123 which it pulled from the <code>Option</code> via destructuring, <code>outer</code> captures the entire <code>Some(inner)</code> expression, so it contains the full <code>Option::Some(123)</code>. This is rarely used but can be useful in more complex patterns.</p>
</li>
</ul>
</details><h1><a class="header" href="#结构体-1" id="结构体-1">结构体</a></h1>
<p>Like tuples, Struct can also be destructured by matching:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, x = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>更改“foo”中的字面量值以与其他模式相匹配。</li>
<li>向“Foo”添加一个新字段，并根据需要更改模式。</li>
<li>捕获和常量表达式之间的区别可能很难发现。尝试将第二个分支中的“2”更改为一个变量，可以看到它几乎无法运作了。将它更改为“const”，可以看到它又正常运作了。</li>
</ul>
</details><h1><a class="header" href="#枚举-1" id="枚举-1">枚举</a></h1>
<p>Like tuples, enums can also be destructured by matching:</p>
<p>模式还可用于将变量绑定到值的某些部分。这是您检查类型结构的方式。我们先从简单的“enum”类型开始：</p>
<pre><pre class="playground"><code class="language-rust editable">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>在这里，我们使用了分支来解构“Result”值。在第一个分支中，“half”被绑定到“Ok”变体中的值。在第二个分支中，“msg”被绑定到错误消息。</p>
<details>
<ul>
<li>“if”/“else”表达式将返回一个枚举，该枚举之后会使用“match”进行解封装。</li>
<li>您可以尝试在枚举定义中添加第三个变体，并在运行代码时显示错误。指出代码现在有哪些地方还不详尽，并说明编译器会如何尝试给予提示。</li>
<li>The values in the enum variants can only be accessed after being pattern matched.</li>
<li>Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler provides by confirming when all cases are handled.</li>
</ul>
</details><h1><a class="header" href="#let-控制流" id="let-控制流">let 控制流</a></h1>
<p>Rust 有几个与其他语言不同的控制流结构。它们用于模式匹配：</p>
<ul>
<li><code>if let</code> 表达式</li>
<li><code>let else</code> expressions</li>
<li><code>while let</code> expressions</li>
</ul>
<h1><a class="header" href="#if-let-表达式" id="if-let-表达式"><code>if let</code> 表达式</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> 表达式</a> 能让你根据某个值是否与模式相匹配来执行不同的代码：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Duration;

fn sleep_for(secs: f32) {
    if let Ok(duration) = Duration::try_from_secs_f32(secs) {
        std::thread::sleep(duration);
        println!(&quot;slept for {duration:?}&quot;);
    }
}

fn main() {
    sleep_for(-10.0);
    sleep_for(0.8);
}
</code></pre></pre>
<h1><a class="header" href="#let-else-expressions" id="let-else-expressions"><code>let else</code> expressions</a></h1>
<p>如需了解匹配模式并从函数返回的常见情况，请使用 <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let else</code></a>。&quot;else&quot; 分支必须执行不同的结束方式（例如，<code>return</code>、<code>break</code> 或 <code>panic</code>，但不能直接执行到代码块的末尾）。</p>
<pre><pre class="playground"><code class="language-rust editable">fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    if let Some(s) = maybe_string {
        if let Some(first_byte_char) = s.chars().next() {
            if let Some(digit) = first_byte_char.to_digit(16) {
                Ok(digit)
            } else {
                return Err(String::from(&quot;not a hex digit&quot;));
            }
        } else {
            return Err(String::from(&quot;got empty string&quot;));
        }
    } else {
        return Err(String::from(&quot;got None&quot;));
    }
}

fn main() {
    println!(&quot;result: {:?}&quot;, hex_or_die_trying(Some(String::from(&quot;foo&quot;))));
}
</code></pre></pre>
<p>与 <code>if let</code> 一样，<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> 变体会针对一个模式重复测试一个值：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut name = String::from(&quot;Comprehensive Rust 🦀&quot;);
    while let Some(c) = name.pop() {
        println!(&quot;character: {c}&quot;);
    }
    // (There are more efficient ways to reverse a string!)
}
</code></pre></pre>
<p>Here <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.pop"><code>String::pop</code></a> returns <code>Some(c)</code> until the string is empty, after which it will return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<details>
<h2><a class="header" href="#if-let" id="if-let">if-let</a></h2>
<ul>
<li>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it more concise than <code>match</code>.</li>
<li>使用 <code>Option</code> 时，常见的做法是处理 <code>Some</code> 值。</li>
<li>与 <code>match</code> 不同的是，<code>if let</code> 不支持模式匹配的 guard 子句。</li>
</ul>
<h2><a class="header" href="#let-else" id="let-else">let-else</a></h2>
<p><code>if-let</code>s can pile up, as shown. The <code>let-else</code> construct supports flattening this nested code. Rewrite the awkward version for students, so they can see the transformation.</p>
<p>重写后的版本为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    let Some(s) = maybe_string else {
        return Err(String::from(&quot;got None&quot;));
    };

    let Some(first_byte_char) = s.chars().next() else {
        return Err(String::from(&quot;got empty string&quot;));
    };

    let Some(digit) = first_byte_char.to_digit(16) else {
        return Err(String::from(&quot;not a hex digit&quot;));
    };

    return Ok(digit);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#while-let" id="while-let">while-let</a></h1>
<ul>
<li>指出只要值与模式匹配，<code>while let</code> 循环就会一直进行下去。</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if statement that breaks when there is no value to unwrap for <code>name.pop()</code>. The <code>while let</code> provides syntactic sugar for the above scenario.</li>
</ul>
</details><h1><a class="header" href="#练习表达式求值" id="练习表达式求值">练习：表达式求值</a></h1>
<p>Let's write a simple recursive evaluator for arithmetic expressions.</p>
<p>An example of a small arithmetic expression could be <code>10 + 20</code>, which evaluates to <code>30</code>. We can represent the expression as a tree:</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:128px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="280" height="128"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="280" height="128"></rect><rect x="100" y="8" width="64" height="32" class="solid nofill" rx="4"></rect><text x="130" y="28" >+</text><rect x="4" y="72" width="72" height="32" class="solid nofill" rx="4"></rect><text x="34" y="92" >10</text><rect x="196" y="72" width="72" height="32" class="solid nofill" rx="4"></rect><text x="226" y="92" >20</text><g><path d="M 40,24 A 4,4 0,0,0 36,28" class="nofill"></path><line x1="36" y1="28" x2="36" y2="52" class="solid"></line><line x1="40" y1="24" x2="88" y2="24" class="solid"></line><polygon points="32,52 40,52 36,64" class="filled"></polygon></g><g><line x1="176" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="52" class="solid"></line><polygon points="224,52 232,52 228,64" class="filled"></polygon></g></svg></div>
<p>A bigger and more complex expression would be <code>(10 * 9) + ((3 - 4) * 5)</code>, which evaluate to <code>85</code>. We represent this as a much bigger tree:</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:256px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="256"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="256"></rect><rect x="244" y="8" width="48" height="32" class="solid nofill" rx="4"></rect><text x="266" y="28" >+</text><rect x="76" y="72" width="48" height="32" class="solid nofill" rx="4"></rect><text x="98" y="92" >*</text><rect x="412" y="72" width="48" height="32" class="solid nofill" rx="4"></rect><text x="434" y="92" >*</text><rect x="4" y="136" width="56" height="32" class="solid nofill" rx="4"></rect><text x="26" y="156" >10</text><rect x="148" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="170" y="156" >9</text><rect x="340" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="362" y="156" >-</text><rect x="484" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="506" y="156" >5</text><rect x="268" y="200" width="48" height="32" class="solid nofill" rx="4"></rect><text x="290" y="220" >3</text><rect x="412" y="200" width="48" height="32" class="solid nofill" rx="4"></rect><text x="434" y="220" >4</text><g><path d="M 104,24 A 4,4 0,0,0 100,28" class="nofill"></path><line x1="100" y1="28" x2="100" y2="52" class="solid"></line><line x1="104" y1="24" x2="232" y2="24" class="solid"></line><polygon points="96,52 104,52 100,64" class="filled"></polygon></g><g><line x1="304" y1="24" x2="432" y2="24" class="solid"></line><path d="M 432,24 A 4,4 0,0,1 436,28" class="nofill"></path><line x1="436" y1="28" x2="436" y2="52" class="solid"></line><polygon points="432,52 440,52 436,64" class="filled"></polygon></g><g><path d="M 32,88 A 4,4 0,0,0 28,92" class="nofill"></path><line x1="28" y1="92" x2="28" y2="116" class="solid"></line><line x1="32" y1="88" x2="64" y2="88" class="solid"></line><polygon points="24,116 32,116 28,128" class="filled"></polygon></g><g><line x1="136" y1="88" x2="168" y2="88" class="solid"></line><path d="M 168,88 A 4,4 0,0,1 172,92" class="nofill"></path><line x1="172" y1="92" x2="172" y2="116" class="solid"></line><polygon points="168,116 176,116 172,128" class="filled"></polygon></g><g><path d="M 368,88 A 4,4 0,0,0 364,92" class="nofill"></path><line x1="364" y1="92" x2="364" y2="116" class="solid"></line><line x1="368" y1="88" x2="400" y2="88" class="solid"></line><polygon points="360,116 368,116 364,128" class="filled"></polygon></g><g><line x1="472" y1="88" x2="504" y2="88" class="solid"></line><path d="M 504,88 A 4,4 0,0,1 508,92" class="nofill"></path><line x1="508" y1="92" x2="508" y2="116" class="solid"></line><polygon points="504,116 512,116 508,128" class="filled"></polygon></g><g><path d="M 296,152 A 4,4 0,0,0 292,156" class="nofill"></path><line x1="292" y1="156" x2="292" y2="180" class="solid"></line><line x1="296" y1="152" x2="328" y2="152" class="solid"></line><polygon points="288,180 296,180 292,192" class="filled"></polygon></g><g><line x1="400" y1="152" x2="432" y2="152" class="solid"></line><path d="M 432,152 A 4,4 0,0,1 436,156" class="nofill"></path><line x1="436" y1="156" x2="436" y2="180" class="solid"></line><polygon points="432,180 440,180 436,192" class="filled"></polygon></g></svg></div>
<p>In code, we will represent the tree with two types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Box</code> type here is a smart pointer, and will be covered in detail later in the course. An expression can be &quot;boxed&quot; with <code>Box::new</code> as seen in the tests. To evaluate a boxed expression, use the deref operator (<code>*</code>) to &quot;unbox&quot; it: <code>eval(*boxed_expr)</code>.</p>
<p>Some expressions cannot be evaluated and will return an error. The standard <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;Value, String&gt;</code></a> type is an enum that represents either a successful value (<code>Ok(Value)</code>) or an error (<code>Err(String)</code>). We will cover this type in detail later.</p>
<p>将代码复制粘贴到 Rust Playground，然后开始实现 <code>eval</code>。最终结果应能通过测试。使用 <code>todo!()</code> 并使测试逐个通过可能会很有帮助。您还可以使用 <code>#[ignore]</code> 暂时跳过测试：</p>
<pre><code class="language-none">#[test]
#[ignore]
fn test_value() { .. }
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_zeros() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Mul,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#解答-5" id="解答-5">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    match e {
        Expression::Op { op, left, right } =&gt; {
            let left = match eval(*left) {
                Ok(v) =&gt; v,
                Err(e) =&gt; return Err(e),
            };
            let right = match eval(*right) {
                Ok(v) =&gt; v,
                Err(e) =&gt; return Err(e),
            };
            Ok(match op {
                Operation::Add =&gt; left + right,
                Operation::Sub =&gt; left - right,
                Operation::Mul =&gt; left * right,
                Operation::Div =&gt; {
                    if right == 0 {
                        return Err(String::from(&quot;division by zero&quot;));
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) =&gt; Ok(v),
    }
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_zeros() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Mul,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}

fn main() {
    let expr = Expression::Op {
        op: Operation::Sub,
        left: Box::new(Expression::Value(20)),
        right: Box::new(Expression::Value(10)),
    };
    println!(&quot;expr: {expr:?}&quot;);
    println!(&quot;result: {:?}&quot;, eval(expr));
}
</code></pre></pre>
<h1><a class="header" href="#方法和特征" id="方法和特征">方法和特征</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#方法" id="方法">方法</a></h1>
<p>Rust 允许您将函数与新类型相关联。您可以使用“impl”块来执行此操作：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    // No receiver, a static method
    fn new(name: &amp;str) -&gt; Self {
        Self { name: String::from(name), laps: Vec::new() }
    }

    // Exclusive borrowed read-write access to self
    fn add_lap(&amp;mut self, lap: i32) {
        self.laps.push(lap);
    }

    // Shared and read-only borrowed access to self
    fn print_laps(&amp;self) {
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    // Exclusive ownership of self (covered later)
    fn finish(self) {
        let total: i32 = self.laps.iter().sum();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<p>The <code>self</code> arguments specify the &quot;receiver&quot; - the object the method acts on. There are several common receivers for a method:</p>
<ul>
<li>“&amp;self”：使用不可变的共享引用从调用方借用对象。之后可以再次使用该对象。</li>
<li>“&amp;mut self”：使用唯一的可变引用从调用方借用对象。之后可以再次使用该对象。</li>
<li>“self”：获取对象的所有权并将其从调用方移出。该方法会成为对象的所有者。除非明确转移对象的所有权，否则在该方法返回时，对象将被丢弃（取消分配）。具备完全所有权，不自动等同于具备可变性。</li>
<li><code>mut self</code>: same as above, but the method can mutate the object.</li>
<li>无接收器：这将变为结构体上的静态方法。通常用于创建构造函数，按惯例被称为“new”。</li>
</ul>
<details>
<p>关键点：</p>
<ul>
<li>引入方法时，将方法与函数进行比较会很有帮助。
<ul>
<li>在某种类型（例如结构体或枚举）的实例上调用方法，第一个参数将该实例表示为“self”。</li>
<li>开发者可能会选择使用方法，以便利用方法接收器语法并让方法更有条理。通过使用方法，我们可以将所有实现代码保存在一个可预测的位置。</li>
</ul>
</li>
<li>指出关键字“self”的用法，它是一种方法接收器。
<ul>
<li>显示它是“self: Self”的缩写术语，或许要显示结构体名称的可能用法。</li>
<li>说明“Self”是“impl”块所属类型的类型别名，可以在块中的其他位置使用。</li>
<li>指出“self”的使用方式与其他结构体一样，并且可以使用点表示法来指代各个字段。</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by trying to run <code>finish</code> twice.</li>
<li>Beyond variants on <code>self</code>, there are also <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a> allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#特征trait" id="特征trait">特征（Trait）</a></h1>
<p>Rust 让您可以依据特征对类型进行抽象化处理。特征与接口类似：</p>
<pre><pre class="playground"><code class="language-rust editable">trait Pet {
    /// Return a sentence from this pet.
    fn talk(&amp;self) -&gt; String;

    /// Print a string to the terminal greeting this pet.
    fn greet(&amp;self);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>trait 定义了类型实现该 trait 所必须具备的一些方法。</p>
</li>
<li>
<p>In the &quot;Generics&quot; segment, next, we will see how to build functionality that is generic over all types implementing a trait.</p>
</li>
</ul>
</details><h1><a class="header" href="#实现-unsafe-trait" id="实现-unsafe-trait">实现 Unsafe Trait</a></h1>
<pre><pre class="playground"><code class="language-rust editable">trait Pet {
    fn talk(&amp;self) -&gt; String;

    fn greet(&amp;self) {
        println!(&quot;Oh you're a cutie! What's your name? {}&quot;, self.talk());
    }
}

struct Dog {
    name: String,
    age: i8,
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

fn main() {
    let fido = Dog { name: String::from(&quot;Fido&quot;), age: 5 };
    fido.greet();
}
</code></pre></pre>
<details>
<ul>
<li>
<p>To implement <code>Trait</code> for <code>Type</code>, you use an <code>impl Trait for Type { .. }</code> block.</p>
</li>
<li>
<p>Unlike Go interfaces, just having matching methods is not enough: a <code>Cat</code> type with a <code>talk()</code> method would not automatically satisfy <code>Pet</code> unless it is in an <code>impl Pet</code> block.</p>
</li>
<li>
<p>Traits may provide default implementations of some methods. Default implementations can rely on all the methods of the trait. In this case, <code>greet</code> is provided, and relies on <code>talk</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#更多-trait" id="更多-trait">更多 trait</a></h1>
<p>A trait can require that types implementing it also implement other traits, called <em>supertraits</em>. Here, any type implementing <code>Pet</code> must implement <code>Animal</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">trait Animal {
    fn leg_count(&amp;self) -&gt; u32;
}

trait Pet: Animal {
    fn name(&amp;self) -&gt; String;
}

struct Dog(String);

impl Animal for Dog {
    fn leg_count(&amp;self) -&gt; u32 {
        4
    }
}

impl Pet for Dog {
    fn name(&amp;self) -&gt; String {
        self.0.clone()
    }
}

fn main() {
    let puppy = Dog(String::from(&quot;Rex&quot;));
    println!(&quot;{} has {} legs&quot;, puppy.name(), puppy.leg_count());
}
</code></pre></pre>
<details>
<p>This is sometimes called &quot;trait inheritance&quot; but students should not expect this to behave like OO inheritance. It just specifies an additional requirement on implementations of a trait.</p>
</details>
<h1><a class="header" href="#共享类型" id="共享类型">共享类型</a></h1>
<p>Associated types are placeholder types which are supplied by the trait implementation.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Meters(i32);
#[derive(Debug)]
struct MetersSquared(i32);

trait Multiply {
    type Output;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output;
}

impl Multiply for Meters {
    type Output = MetersSquared;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output {
        MetersSquared(self.0 * other.0)
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Meters(10).multiply(&amp;Meters(20)));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Associated types are sometimes also called &quot;output types&quot;. The key observation is that the implementer, not the caller, chooses this type.</p>
</li>
<li>
<p>Many standard library traits have associated types, including arithmetic operators and <code>Iterator</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#派生特征" id="派生特征">派生特征</a></h1>
<p>系统可以自动为您的自定义类型实现支持的 trait，如下所示：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Clone, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default(); // Default trait adds `default` constructor.
    let mut p2 = p1.clone(); // Clone trait adds `clone` method.
    p2.name = String::from(&quot;EldurScrollz&quot;);
    // Debug trait adds support for printing with `{:?}`.
    println!(&quot;{p1:?} vs. {p2:?}&quot;);
}
</code></pre></pre>
<details>
<p>派生功能是通过宏实现的，并且许多 crate 提供有用的派生宏，以添加实用功能。例如，<code>serde</code> 可以使用 <code>#[derive(Serialize)]</code> 为结构体派生序列化支持。</p>
</details><h1><a class="header" href="#exercise-logger-trait" id="exercise-logger-trait">Exercise: Logger Trait</a></h1>
<p>Let's design a simple logging utility, using a trait <code>Logger</code> with a <code>log</code> method. Code which might log its progress can then take an <code>&amp;impl Logger</code>. In testing, this might put messages in the test logfile, while in a production build it would send messages to a log server.</p>
<p>However, the <code>StdoutLogger</code> given below logs all messages, regardless of verbosity. Your task is to write a <code>VerbosityFilter</code> type that will ignore messages above a maximum verbosity.</p>
<p>This is a common pattern: a struct wrapping a trait implementation and implementing that same trait, adding behavior in the process. What other kinds of wrappers might be useful in a logging utility?</p>
<pre><pre class="playground"><code class="language-rust compile_fail">pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: &amp;str);
}

struct StdoutLogger;

impl Logger for StdoutLogger {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        println!(&quot;verbosity={verbosity}: {message}&quot;);
    }
}

// TODO: Define and implement `VerbosityFilter`.

fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StdoutLogger };
    logger.log(5, &quot;FYI&quot;);
    logger.log(2, &quot;Uhoh&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#解答-6" id="解答-6">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: &amp;str);
}

struct StdoutLogger;

impl Logger for StdoutLogger {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        println!(&quot;verbosity={verbosity}: {message}&quot;);
    }
}

/// Only log messages up to the given verbosity level.
struct VerbosityFilter {
    max_verbosity: u8,
    inner: StdoutLogger,
}

impl Logger for VerbosityFilter {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        if verbosity &lt;= self.max_verbosity {
            self.inner.log(verbosity, message);
        }
    }
}

fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StdoutLogger };
    logger.log(5, &quot;FYI&quot;);
    logger.log(2, &quot;Uhoh&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-1" id="welcome-back-1">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#泛型" id="泛型">泛型</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#泛型函数" id="泛型函数">泛型函数</a></h1>
<p>Rust supports generics, which lets you abstract algorithms or data structures (such as sorting or a binary tree) over the types used or stored.</p>
<pre><pre class="playground"><code class="language-rust editable">/// Pick `even` or `odd` depending on the value of `n`.
fn pick&lt;T&gt;(n: i32, even: T, odd: T) -&gt; T {
    if n % 2 == 0 {
        even
    } else {
        odd
    }
}

fn main() {
    println!(&quot;picked a number: {:?}&quot;, pick(97, 222, 333));
    println!(&quot;picked a string: {:?}&quot;, pick(28, &quot;dog&quot;, &quot;cat&quot;));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Rust 会根据参数类型和返回值推理出 T 的类型。</p>
</li>
<li>
<p>In this example we only use the primitive types <code>i32</code> and <code>&amp;str</code> for <code>T</code>, but we can use any type here, including user-defined types:</p>
<pre><code class="language-rust ignore">struct Foo {
    val: u8,
}

pick(123, Foo { val: 7 }, Foo { val: 456 });
</code></pre>
</li>
<li>
<p>这与 C++ 模板类似，但 Rust 会立即编译部分通用函数，因此该函数必须对所有符合约束条件的类型都有效。例如，请尝试修改 <code>pick</code> 函数，如果 <code>n == 0</code>，则返回 <code>even + odd</code>。即使仅使用带有整数的“pick”实例化，Rust 仍会将其视为无效。C++ 可让您做到这一点。</p>
</li>
<li>
<p>Generic code is turned into non-generic code based on the call sites. This is a zero-cost abstraction: you get exactly the same result as if you had hand-coded the data structures without the abstraction.</p>
</li>
</ul>
</details><h1><a class="header" href="#泛型类型" id="泛型类型">泛型类型</a></h1>
<p>您可以使用泛型对具体字段类型进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn coords(&amp;self) -&gt; (&amp;T, &amp;T) {
        (&amp;self.x, &amp;self.y)
    }

    fn set_x(&amp;mut self, x: T) {
        self.x = x;
    }
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
    println!(&quot;coords: {:?}&quot;, integer.coords());
}
</code></pre></pre>
<details>
<ul>
<li>
<p>*问：*为什么 <code>T</code> 在 <code>impl&lt;T&gt; Point&lt;T&gt; {}</code> 中指定了两次？这不是多余的吗？</p>
<ul>
<li>这是因为它是泛型类型的泛型实现部分。它们是独立的泛型内容。</li>
<li>这意味着这些方法是针对所有 <code>T</code> 定义的。</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>.
<ul>
<li><code>Point</code> 依然是一个泛型，并且您可以使用 <code>Point&lt;f64&gt;</code>，但此块中的方法将仅适用于 <code>Point&lt;u32&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>请尝试声明一个新变量 <code>let p = Point { x: 5, y: 10.0 };</code>。通过使用两种类型变量（例如 <code>T</code> 和 <code>U</code>），更新代码以允许具有不同类型元素的点。</p>
</li>
</ul>
</details><h1><a class="header" href="#泛型-1" id="泛型-1">泛型</a></h1>
<p>Traits can also be generic, just like types and functions. A trait's parameters get concrete types when it is used.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Foo(String);

impl From&lt;u32&gt; for Foo {
    fn from(from: u32) -&gt; Foo {
        Foo(format!(&quot;Converted from integer: {from}&quot;))
    }
}

impl From&lt;bool&gt; for Foo {
    fn from(from: bool) -&gt; Foo {
        Foo(format!(&quot;Converted from bool: {from}&quot;))
    }
}

fn main() {
    let from_int = Foo::from(123);
    let from_bool = Foo::from(true);
    println!(&quot;{from_int:?}, {from_bool:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>From</code> trait will be covered later in the course, but its <a href="https://doc.rust-lang.org/std/convert/trait.From.html">definition in the <code>std</code> docs</a> is simple.</p>
</li>
<li>
<p>Implementations of the trait do not need to cover all possible type parameters. Here, <code>Foo::from(&quot;hello&quot;)</code> would not compile because there is no <code>From&lt;&amp;str&gt;</code> implementation for <code>Foo</code>.</p>
</li>
<li>
<p>Generic traits take types as &quot;input&quot;, while associated types are a kind of &quot;output&quot; type. A trait can have multiple implementations for different input types.</p>
</li>
<li>
<p>In fact, Rust requires that at most one implementation of a trait match for any type T. Unlike some other languages, Rust has no heuristic for choosing the &quot;most specific&quot; match. There is work on adding this support, called <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#特征边界" id="特征边界">特征边界</a></h1>
<p>使用泛型时，您通常会想要利用类型来实现某些特性， 这样才能调用此特征的方法。</p>
<p>You can do this with <code>T: Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// struct NotCloneable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Try making a <code>NonCloneable</code> and passing it to <code>duplicate</code>.</p>
</li>
<li>
<p>当需要多个 trait 时，请使用 <code>+</code> 将它们连接起来。</p>
</li>
<li>
<p>显示 <code>where</code> 子句，学员在阅读代码时会看到它。</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>它会在您有多个形参的情况下整理函数签名。</li>
<li>它具有额外功能，因此也更强大。
<ul>
<li>如果有人提问，便阐明额外功能是指“:”左侧的类别可为任意值，例如 <code>Option&lt;T&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>请注意，Rust 尚不支持专精领域认证。例如，根据原始 <code>duplicate</code> 函数，添加专精领域认证的 <code>Duplicate(a: u32)</code> 是无效的。</p>
</li>
</ul>
</details><h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>与特征边界类似，<code>impl Trait</code> 语法可以在函数形参 和返回值中使用：</p>
<pre><pre class="playground"><code class="language-rust editable">// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

fn pair_of(x: u32) -&gt; impl std::fmt::Debug {
    (x + 1, x - 1)
}

fn main() {
    let many = add_42_millions(42_i8);
    println!(&quot;{many}&quot;);
    let many_more = add_42_millions(10_000_000);
    println!(&quot;{many_more}&quot;);
    let debuggable = pair_of(27);
    println!(&quot;debuggable: {debuggable:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>impl Trait</code> allows you to work with types which you cannot name. The meaning of <code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>
<p>对形参来说，<code>impl Trait</code> 就像是具有特征边界的匿名泛型形参。</p>
</li>
<li>
<p>对返回值类型来说，它则意味着返回值类型就是实现该特征的某具体类型， 无需为该类型命名。如果您不想在公共 API 中公开该具体类型，便可 使用此方法。</p>
<p>在返回位置处进行推断有一定难度。会返回 <code>impl Foo</code> 的函数会挑选 自身返回的具体类型，而不必在来源中写出此信息。会返回 泛型类型（例如 <code>collect&lt;B&gt;() -&gt; B</code>）的函数则可返回符合 <code>B</code> 的任何类型，而调用方可能需要选择一个类型，例如使用 <code>let x: Vec&lt;_&gt; = foo.collect()</code> 或使用以下 Turbofish：<code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>。</p>
</li>
</ul>
<p><code>debuggable</code> 是什么类型？尝试输入 <code>let debuggable: () = ..</code>，查看会显示什么错误消息。</p>
</details><h1><a class="header" href="#dyn-trait" id="dyn-trait"><code>dyn Trait</code></a></h1>
<p>In addition to using traits for static dispatch via generics, Rust also supports using them for type-erased, dynamic dispatch via trait objects:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from(&quot;Miau!&quot;)
    }
}

// Uses generics and static dispatch.
fn generic(pet: &amp;impl Pet) {
    println!(&quot;Hello, who are you? {}&quot;, pet.talk());
}

// Uses type-erasure and dynamic dispatch.
fn dynamic(pet: &amp;dyn Pet) {
    println!(&quot;Hello, who are you? {}&quot;, pet.talk());
}

fn main() {
    let cat = Cat { lives: 9 };
    let dog = Dog { name: String::from(&quot;Fido&quot;), age: 5 };

    generic(&amp;cat);
    generic(&amp;dog);

    dynamic(&amp;cat);
    dynamic(&amp;dog);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Generics, including <code>impl Trait</code>, use monomorphization to create a specialized instance of the function for each different type that the generic is instantiated with. This means that calling a trait method from within a generic function still uses static dispatch, as the compiler has full type information and can resolve which type's trait implementation to use.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, it instead uses dynamic dispatch through a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable). This means that there's a single version of <code>fn dynamic</code> that is used regardless of what type of <code>Pet</code> is passed in.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, the trait object needs to be behind some kind of indirection. In this case it's a reference, though smart pointer types like <code>Box</code> can also be used (this will be demonstrated on day 3).</p>
</li>
<li>
<p>At runtime, a <code>&amp;dyn Pet</code> is represented as a &quot;fat pointer&quot;, i.e. a pair of two pointers: One pointer points to the concrete object that implements <code>Pet</code>, and the other points to the vtable for the trait implementation for that type. When calling the <code>talk</code> method on <code>&amp;dyn Pet</code> the compiler looks up the function pointer for <code>talk</code> in the vtable and then invokes the function, passing the pointer to the <code>Dog</code> or <code>Cat</code> into that function. The compiler doesn't need to know the concrete type of the <code>Pet</code> in order to do this.</p>
</li>
<li>
<p>A <code>dyn Trait</code> is considered to be &quot;type-erased&quot;, because we no longer have compile-time knowledge of what the concrete type is.</p>
</li>
</ul>
</details><h1><a class="header" href="#练习通用-min-函数" id="练习通用-min-函数">练习：通用 <code>min</code> 函数</a></h1>
<p>In this short exercise, you will implement a generic <code>min</code> function that determines the minimum of two values, using the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::cmp::Ordering;

// TODO: implement the `min` function used in `main`.

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min(&quot;hello&quot;, &quot;goodbye&quot;), &quot;goodbye&quot;);
    assert_eq!(min(&quot;bat&quot;, &quot;armadillo&quot;), &quot;armadillo&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Show students the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait and <a href="https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html"><code>Ordering</code></a> enum.</li>
</ul>
</details>
<h1><a class="header" href="#解答-7" id="解答-7">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;

fn min&lt;T: Ord&gt;(l: T, r: T) -&gt; T {
    match l.cmp(&amp;r) {
        Ordering::Less | Ordering::Equal =&gt; l,
        Ordering::Greater =&gt; r,
    }
}

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min(&quot;hello&quot;, &quot;goodbye&quot;), &quot;goodbye&quot;);
    assert_eq!(min(&quot;bat&quot;, &quot;armadillo&quot;), &quot;armadillo&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#标准库类型" id="标准库类型">标准库类型</a></h1>
<p>{{%segment outline}}</p>
<details>
<p>对于本部分的每张幻灯片，请花些时间仔细阅读文档页面，重点了解一些较为常用的方法。</p>
</details>
<h1><a class="header" href="#标准库" id="标准库">标准库</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types used by Rust libraries and programs. This way, two libraries can work together smoothly because they both use the same <code>String</code> type.</p>
<p>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>.</p>
<ul>
<li><code>core</code> includes the most basic types and functions that don't depend on <code>libc</code>, allocator or even the presence of an operating system.</li>
<li><code>alloc</code> 包括需要全局堆分配器的类型，例如 <code>Vec</code>、<code>Box</code> 和 <code>Arc</code>。</li>
<li>嵌入式 Rust 应用通常只使用 <code>core</code>，偶尔会使用 <code>alloc</code>。</li>
</ul>
<h1><a class="header" href="#文档" id="文档">文档</a></h1>
<p>Rust comes with extensive documentation. For example:</p>
<ul>
<li>All of the details about <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html">loops</a>.</li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.u8.html">'u8'</a> 等基元类型。</li>
<li>Standard library types like <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a>.</li>
</ul>
<p>Use <code>rustup doc --std</code> or <a href="https://std.rs">https://std.rs</a> to view the documentation.</p>
<p>事实上，您可以为自己的代码编写文档：</p>
<pre><pre class="playground"><code class="language-rust editable">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;
    }
    lhs % rhs == 0
}
</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are automatically documented at <a href="https://docs.rs"><code>docs.rs</code></a> using the <a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is idiomatic to document all public items in an API using this pattern.</p>
<p>如需从项内（例如在模块内）为项编写文档，请使用 <code>//!</code> 或 <code>/*! .. */</code>，这称为“内部文档注释”：</p>
<pre><pre class="playground"><code class="language-rust editable">//! This module contains functionality relating to divisibility of integers.
</code></pre></pre>
<details>
<ul>
<li>Show students the generated docs for the <code>rand</code> crate at <a href="https://docs.rs/rand">https://docs.rs/rand</a>.</li>
</ul>
</details><h1><a class="header" href="#option" id="option">Option</a></h1>
<p>我们已经了解了 <code>Option&lt;T&gt;</code> 的一些用法。它可以存储“T”类型的值，或者不存储任何值。例如，<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.find">'String::find'</a> 会返回 <code>Option&lt;usize&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let name = &quot;Löwe 老虎 Léopard Gepardi&quot;;
    let mut position: Option&lt;usize&gt; = name.find('é');
    println!(&quot;find returned {position:?}&quot;);
    assert_eq!(position.unwrap(), 14);
    position = name.find('Z');
    println!(&quot;find returned {position:?}&quot;);
    assert_eq!(position.expect(&quot;Character not found&quot;), 0);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Option</code> is widely used, not just in the standard library.</p>
</li>
<li>
<p><code>unwrap</code> 会返回 <code>Option</code> 或 panic 中的值。<code>expect</code> 方法与此类似，但其使用错误消息。</p>
<ul>
<li>出现 None 时您或许会恐慌，但不能 “无意中”忘记检查是否为 None 的情况。</li>
<li>在草拟阶段的编程中，频繁使用 <code>unwrap</code>/<code>expect</code> 进行处理十分常见，但在正式版代码时，通常以更为妥当的方式处理 <code>None</code> 的情况。</li>
</ul>
</li>
<li>
<p>The &quot;niche optimization&quot; means that <code>Option&lt;T&gt;</code> often has the same size in memory as <code>T</code>, if there is some representation that is not a valid value of T. For example, a reference cannot be NULL, so <code>Option&lt;&amp;T&gt;</code> automatically uses NULL to represent the <code>None</code> variant, and thus can be stored in the same memory as <code>&amp;T</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#result" id="result">Result</a></h1>
<p><code>Result</code> is similar to <code>Option</code>, but indicates the success or failure of an operation, each with a different enum variant. It is generic: <code>Result&lt;T, E&gt;</code> where <code>T</code> is used in the <code>Ok</code> variant and <code>E</code> appears in the <code>Err</code> variant.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!(&quot;Dear diary: {contents} ({bytes} bytes)&quot;);
            } else {
                println!(&quot;Could not read file content&quot;);
            }
        }
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>与 <code>Option</code> 方法相同，成功值位于 <code>Result</code> 方法内部， 开发者必须显示提取成功值。因此，建议进行错误检查。在绝不应出现错误的情况下， 可以调用 <code>unwrap()</code> 或 <code>expect()</code> 方法，这也是一种开发者意向信号。</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is worth mentioning. It contains a lot of convenience methods and functions that help functional-style programming.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see on Day 4.</li>
</ul>
</details><h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a growable UTF-8 encoded string:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;🇨🇭&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(), s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> 会实现 <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>，这意味着您可以 对 <code>String</code> 调用所有 <code>str</code> 方法。</p>
<details>
<ul>
<li>“String::new”会返回一个新的空字符串，如果您知道自己想要推送到字符串的数据量，请使用“String::with_capacity”。</li>
<li>“String::len”会返回“String”的大小（以字节为单位，可能不同于以字符为单位的长度）。</li>
<li>“String::chars”会针对实际字符返回一个迭代器。请注意，由于<a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">字素簇</a>，“char”可能与人们所认为的“字符”有所不同。</li>
<li>当人们提到字符串时，可能是指“&amp;str”或“String”。</li>
<li>当某个类型实现“Deref&lt;Target = T&gt;”时，编译器会让您以公开透明方式从“T”调用方法。
<ul>
<li>我们尚未讨论过 <code>Deref</code> trait，所以本部分目前主要介绍文档中边栏的结构。</li>
<li>“String”会实现“Deref&lt;Target = str&gt;”，后者可公开透明地授予其访问“str”方法的权限。</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and <code>let s3 = &amp;*s1;</code>.</li>
</ul>
</li>
<li>“String”是作为字节矢量的封装容器实现的，矢量上支持的许多操作在“String”上也受支持，但有一些额外保证。</li>
<li>比较将“String”编入索引的不同方式：
<ul>
<li>使用“s3.chars().nth(i).unwrap()”转换为字符，其中“i”代表是否出界。</li>
<li>通过使用“s3[0..4]”转换为子字符串，其中该 Slice 在或不在字符边界上。</li>
</ul>
</li>
<li>Many types can be converted to a string with the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>to_string</code></a> method. This trait is automatically implemented for all types that implement <code>Display</code>, so anything that can be formatted can also be converted to a string.</li>
</ul>
</details><h1><a class="header" href="#vec" id="vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> 是标准的可调整大小堆分配缓冲区：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!(&quot;{v3:?}&quot;);

    // Remove consecutive duplicates.
    v3.dedup();
    println!(&quot;{v3:?}&quot;);
}
</code></pre></pre>
<p><code>Vec</code> 会实现 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>，这意味着您可以对 <code>Vec</code> 调用 slice 方法。</p>
<details>
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored on the heap. This means the amount of data doesn't need to be known at compile time. It can grow or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don't have to specify <code>T</code> explicitly. As always with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</li>
<li>“vec![...]”是用来代替“Vec::new()”的规范化宏，它支持向矢量添加初始元素。</li>
<li>如需将矢量编入索引，您可以使用“[’ ‘]”方法，但如果超出边界，矢量将会 panic。此外，使用“get”将返回“Option”。“pop”函数会移除最后一个元素。</li>
<li>Slices are covered on day 3. For now, students only need to know that a value of type <code>Vec</code> gives access to all of the documented slice methods, too.</li>
</ul>
</details><h1><a class="header" href="#hashmap" id="hashmap"><code>HashMap</code></a></h1>
<p>标准的哈希映射，内含针对 HashDoS 攻击的保护措施：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;, 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;, 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;, 303);

    if !page_counts.contains_key(&quot;Les Misérables&quot;) {
        println!(
            &quot;We know about {} books, but not Les Misérables.&quot;,
            page_counts.len()
        );
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;),
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        let page_count: &amp;mut i32 = page_counts.entry(book).or_insert(0);
        *page_count += 1;
    }

    println!(&quot;{page_counts:#?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>“HashMap”未在序言中定义，因此需要纳入范围中。</p>
</li>
<li>
<p>请尝试使用以下代码行。第一行将查看图书是否在 hashmap 中；如果不在，则返回替代值。如果未找到图书，第二行会在 hashmap 中插入替代值。</p>
<pre><code class="language-rust ignore">let pc1 = page_counts
    .get(&quot;Harry Potter and the Sorcerer's Stone&quot;)
    .unwrap_or(&amp;336);
let pc2 = page_counts
    .entry(&quot;The Hunger Games&quot;)
    .or_insert(374);
</code></pre>
</li>
<li>
<p>遗憾的是，与“vec!”不同，不存在标准的“hashmap!”宏。</p>
<ul>
<li>
<p>不过，从 Rust 1.56 开始，HashMap 实现了<a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E">“From&lt;[(K, V); N]&gt;”</a>，让我们能够轻松地从字面量数组初始化哈希映射：</p>
<pre><code class="language-rust ignore">let page_counts = HashMap::from([
  (&quot;Harry Potter and the Sorcerer's Stone&quot;.to_string(), 336),
  (&quot;The Hunger Games&quot;.to_string(), 374),
]);
</code></pre>
</li>
</ul>
</li>
<li>
<p>或者，HashMap 也可以基于任何可生成键-值元组的“Iterator”进行构建。</p>
</li>
<li>
<p>此类型具有几种特定于方法的返回值类型，例如“std::collections::hash_map::Keys”。这些类型通常会出现在 Rust 文档的搜索结果中。向学员展示此类型的文档，以及指向“keys”方法的实用链接。</p>
</li>
</ul>
</details><h1><a class="header" href="#练习计数器" id="练习计数器">练习：计数器</a></h1>
<p>在本练习中，您将学习一个非常简单的数据结构，并将其变成泛型的。该结构使用 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>std::collections::HashMap</code></a> 来跟踪已经出现过的值以及每个值出现的次数。</p>
<p><code>Counter</code> 的初始版本经过硬编码，仅适用于 <code>u32</code> 值。使结构体及其方法可用于所跟踪的值类型，以便 <code>Counter</code> 能够跟踪任何类型的值。</p>
<p>如果提前完成操作，请尝试使用 <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry"><code>entry</code></a> 方法将哈希查找次数减半，从而实现 <code>count</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust compile_fail editable">use std::collections::HashMap;

/// Counter counts the number of times each value of type T has been seen.
struct Counter {
    values: HashMap&lt;u32, u64&gt;,
}

impl Counter {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter {
            values: HashMap::new(),
        }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: u32) {
        if self.values.contains_key(&amp;value) {
            *self.values.get_mut(&amp;value).unwrap() += 1;
        } else {
            self.values.insert(value, 1);
        }
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: u32) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!(&quot;saw {} values equal to {}&quot;, ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count(&quot;apple&quot;);
    strctr.count(&quot;orange&quot;);
    strctr.count(&quot;apple&quot;);
    println!(&quot;got {} apples&quot;, strctr.times_seen(&quot;apple&quot;));
}
</code></pre></pre>
<h1><a class="header" href="#解答-8" id="解答-8">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;
use std::hash::Hash;

/// Counter counts the number of times each value of type T has been seen.
struct Counter&lt;T&gt; {
    values: HashMap&lt;T, u64&gt;,
}

impl&lt;T: Eq + Hash&gt; Counter&lt;T&gt; {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter { values: HashMap::new() }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: T) {
        *self.values.entry(value).or_default() += 1;
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: T) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!(&quot;saw {} values equal to {}&quot;, ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count(&quot;apple&quot;);
    strctr.count(&quot;orange&quot;);
    strctr.count(&quot;apple&quot;);
    println!(&quot;got {} apples&quot;, strctr.times_seen(&quot;apple&quot;));
}
</code></pre></pre>
<h1><a class="header" href="#标准库特征" id="标准库特征">标准库特征</a></h1>
<p>{{%segment outline}}</p>
<details>
<p>与标准库类型一样，请花些时间仔细阅读每个 trait 的文档。</p>
<p>此部分内容较长。中途可休息一下。</p>
</details>
<h1><a class="header" href="#比较" id="比较">比较</a></h1>
<p>这些 trait 支持在值之间进行比较。对于包含实现这些 trait 的字段，可以派生所有这些 trait。</p>
<h2><a class="header" href="#partialeq-and-eq" id="partialeq-and-eq"><code>PartialEq</code> and <code>Eq</code></a></h2>
<p><code>PartialEq</code> 指部分等价关系，其中包含必需的方法 <code>eq</code> 和提供的方法 <code>ne</code>。<code>==</code> 和 <code>!=</code> 运算符会调用这些方法。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq for Key {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.id == other.id
    }
}
</code></pre></pre>
<p><code>Eq</code> is a full equivalence relation (reflexive, symmetric, and transitive) and implies <code>PartialEq</code>. Functions that require full equivalence will use <code>Eq</code> as a trait bound.</p>
<h2><a class="header" href="#partialord-and-ord" id="partialord-and-ord"><code>PartialOrd</code> and <code>Ord</code></a></h2>
<p><code>PartialOrd</code> 定义了使用 <code>partial_cmp</code> 方法的部分排序。它用于实现 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 和 <code>&gt;</code> 运算符。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;
#[derive(Eq, PartialEq)]
struct Citation {
    author: String,
    year: u32,
}
impl PartialOrd for Citation {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        match self.author.partial_cmp(&amp;other.author) {
            Some(Ordering::Equal) =&gt; self.year.partial_cmp(&amp;other.year),
            author_ord =&gt; author_ord,
        }
    }
}
</code></pre></pre>
<p><code>Ord</code> 是总排序，其中 <code>cmp</code> 返回 <code>Ordering</code>。</p>
<details>
<p><code>PartialEq</code> 可以在不同类型之间实现，但 <code>Eq</code> 不能，因为它具有自反性：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq&lt;u32&gt; for Key {
    fn eq(&amp;self, other: &amp;u32) -&gt; bool {
        self.id == *other
    }
}
</code></pre></pre>
<p>在实践中，派生这些 trait 很常见，但很少会实现它们。</p>
</details><h1><a class="header" href="#运算符" id="运算符">运算符</a></h1>
<p>运算符重载是通过 <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> 中的特征实现的：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{p1:?} + {p2:?} = {:?}&quot;, p1 + p2);
}
</code></pre></pre>
<details>
<p>讨论点：</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful?
<ul>
<li>回答：<code>Add:add</code> 会耗用 <code>self</code>。如果您的运算符重载对象 （即类型 <code>T</code>）不是 <code>Copy</code>，建议您也为 <code>&amp;T</code> 重载运算符。这可避免调用点上存在不必要的 克隆任务。</li>
</ul>
</li>
<li>为什么 <code>Output</code> 是关联类型？可将它用作该方法的类型形参吗？
<ul>
<li>Short answer: Function type parameters are controlled by the caller, but associated types (like <code>Output</code>) are controlled by the implementer of a trait.</li>
</ul>
</li>
<li>您可以针对两种不同类型实现 <code>Add</code>，例如， <code>impl Add&lt;(i32, i32)&gt; for Point</code> 会向 <code>Point</code> 中添加元组。</li>
</ul>
<p>The <code>Not</code> trait (<code>!</code> operator) is notable because it does not &quot;boolify&quot; like the same operator in C-family languages; instead, for integer types it negates each bit of the number, which arithmetically is equivalent to subtracting it from -1: <code>!5 == -6</code>.</p>
</details>
<h1><a class="header" href="#from-和-into" id="from-和-into"><code>From</code> 和 <code>Into</code></a></h1>
<p>Types implement <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> to facilitate type conversions. Unlike <code>as</code>, these traits correspond to lossless, infallible conversions.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123_i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p>实现 <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> 后，系统会自动实现 <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123_i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>这就是为什么通常只需实现 <code>From</code>，因为您的类型也会实现 <code>Into</code>。</li>
<li>若要声明某个函数实参输入类型（例如“任何可转换成 <code>String</code> 的类型”），规则便会相反，此时应使用 <code>Into</code>。 您的函数会接受可实现 <code>From</code> 的类型，以及那些仅实现 <code>Into</code> 的类型。</li>
</ul>
</details>
<h1><a class="header" href="#类型转换" id="类型转换">类型转换</a></h1>
<p>Rust 没有隐式类型转换，但支持使用 <code>as</code> 进行显式转换。转换写法通常和 C 语言的写法相一致。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let value: i64 = 1000;
    println!(&quot;as u16: {}&quot;, value as u16);
    println!(&quot;as i16: {}&quot;, value as i16);
    println!(&quot;as u8: {}&quot;, value as u8);
}
</code></pre></pre>
<p>使用 <code>as</code> 的结果在 Rust 中 <em>始终</em> 定义明确，并且在不同平台上保持一致。这可能和您对于更改符号或转换为更小类型的直观理解不一样。为清晰起见，请查看文档和注释。</p>
<p>使用 <code>as</code> 进行类型转换是一种快捷好用但容易出错的方法，也在未来进行代码更新时，比如改变了类型或类型范围时会导致潜伏的 Bug。 类型转换最好是用于明确是要进行无条件截取（比如截取低位的 <code>u64</code> 为 <code>u32</code>，忽略高位的数值）。</p>
<p>对于绝对不会出错的转换（比如 <code>u32</code> 转 <code>u64</code>），相比 <code>as</code>，更推荐用 <code>From</code> 或 <code>Into</code> 以肯定该转换是不会出错的。对于可能出错的转换，如果你想对这些不能成功转换的情况有不同处理方案时，可以考虑 <code>TryFrom</code> 和 <code>TryInto</code>。</p>
<details>
<p>请在这张幻灯片之后休息一下。</p>
<p><code>as</code> 类似于 C++ 静态类型转换。通常不建议在可能丢失数据的情况下使用 <code>as</code>，或者至少应该添加说明性注释。</p>
<p>会经常遇到的是，将整数类型转换为 <code>usize</code> 以用作索引。</p>
</details><h1><a class="header" href="#read-和-write" id="read-和-write"><code>Read</code> 和 <code>Write</code></a></h1>
<p>您可以使用 <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> 和 <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> 对 <code>u8</code> 来源进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>您同样可使用 <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> 对 <code>u8</code> 接收器进行抽象化处理：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {buffer:?}&quot;);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#default-特征" id="default-特征"><code>Default</code> 特征</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> 特征会为类型生成默认值。</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self(&quot;John Smith&quot;.into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!(&quot;{default_struct:#?}&quot;);

    let almost_default_struct =
        Derived { y: &quot;Y is set!&quot;.into(), ..Derived::default() };
    println!(&quot;{almost_default_struct:#?}&quot;);

    let nothing: Option&lt;Derived&gt; = None;
    println!(&quot;{:#?}&quot;, nothing.unwrap_or_default());
}
</code></pre></pre>
<details>
<ul>
<li>系统可以直接实现它，也可以通过 <code>#[derive(Default)]</code> 派生出它。</li>
<li>A derived implementation will produce a value where all fields are set to their default values.
<ul>
<li>这意味着，该结构体中的所有类型也都必须实现 <code>Default</code>。</li>
</ul>
</li>
<li>标准的 Rust 类型通常会以合理的值（例如 <code> 0</code>&quot;&quot; `<code>等）实现</code>Default`。</li>
<li>The partial struct initialization works nicely with default.</li>
<li>The Rust standard library is aware that types can implement <code>Default</code> and provides convenience methods that use it.</li>
<li>The <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a>.</li>
</ul>
</details>
<h1><a class="header" href="#闭包" id="闭包">闭包</a></h1>
<p>闭包或 lambda 表达式具有无法命名的类型。不过，它们会 实现特殊的 <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>， <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> 和 <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 特征：</p>
<pre><pre class="playground"><code class="language-rust editable">fn apply_and_log(func: impl FnOnce(i32) -&gt; i32, func_name: &amp;str, input: i32) {
    println!(&quot;Calling {func_name}({input}): {}&quot;, func(input))
}

fn main() {
    let n = 3;
    let add_3 = |x| x + n;
    apply_and_log(&amp;add_3, &quot;add_3&quot;, 10);
    apply_and_log(&amp;add_3, &quot;add_3&quot;, 20);

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, 4);
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, 5);

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    apply_and_log(multiply_sum, &quot;multiply_sum&quot;, 3);
}
</code></pre></pre>
<details>
<p>An <code>Fn</code> (e.g. <code>add_3</code>) neither consumes nor mutates captured values. It can be called needing only a shared reference to the closure, which means the closure can be executed repeatedly and even concurrently.</p>
<p>An <code>FnMut</code> (e.g. <code>accumulate</code>) might mutate captured values. The closure object is accessed via exclusive reference, so it can be called repeatedly but not concurrently.</p>
<p>If you have an <code>FnOnce</code> (e.g. <code>multiply_sum</code>), you may only call it once. Doing so consumes the closure and any values captured by move.</p>
<p><code>FnMut</code> 是 <code>FnOnce</code> 的子类型。<code>Fn</code> 是 <code>FnMut</code> 和 <code>FnOnce</code> 的子类型。也就是说，您可以在任何 需要调用 <code>FnOnce</code> 的地方使用 <code>FnMut</code>，还可在任何需要调用 <code>FnMut</code> 或 <code>FnOnce</code> 的地方 使用 <code>Fn</code>。</p>
<p>When you define a function that takes a closure, you should take <code>FnOnce</code> if you can (i.e. you call it once), or <code>FnMut</code> else, and last <code>Fn</code>. This allows the most flexibility for the caller.</p>
<p>In contrast, when you have a closure, the most flexible you can have is <code>Fn</code> (which can be passed to a consumer of any of the 3 closure traits), then <code>FnMut</code>, and lastly <code>FnOnce</code>.</p>
<p>The compiler also infers <code>Copy</code> (e.g. for <code>add_3</code>) and <code>Clone</code> (e.g. <code>multiply_sum</code>), depending on what the closure captures. Function pointers (references to <code>fn</code> items) implement <code>Copy</code> and <code>Fn</code>.</p>
<p>By default, closures will capture each variable from an outer scope by the least demanding form of access they can (by shared reference if possible, then exclusive reference, then by move). The <code>move</code> keyword forces capture by value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!(&quot;{} {}&quot;, prefix, name);
}

fn main() {
    let hi = make_greeter(&quot;Hi&quot;.to_string());
    hi(&quot;Greg&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#练习rot13" id="练习rot13">练习：ROT13</a></h1>
<p>在此示例中，您将实现经典的 <a href="https://en.wikipedia.org/wiki/ROT13">“ROT13”加密</a>。将此代码复制到 Playground，并实现缺失的位。请仅旋转 ASCII 字母字符，以确保结果仍为有效的 UTF-8 编码字符。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

// Implement the `Read` trait for `RotDecoder`.

fn main() {
    let mut rot =
        RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!(&quot;{}&quot;, result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, &quot;To get to the other side!&quot;);
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}
</code></pre></pre>
<p>如果将两个 <code>RotDecoder</code> 实例链接在一起，每个实例旋转 13 个字符，会发生什么情况？</p>
<h1><a class="header" href="#解答-9" id="解答-9">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

impl&lt;R: Read&gt; Read for RotDecoder&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
        let size = self.input.read(buf)?;
        for b in &amp;mut buf[..size] {
            if b.is_ascii_alphabetic() {
                let base = if b.is_ascii_uppercase() { 'A' } else { 'a' } as u8;
                *b = (*b - base + self.rot) % 26 + base;
            }
        }
        Ok(size)
    }
}

fn main() {
    let mut rot =
        RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!(&quot;{}&quot;, result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, &quot;To get to the other side!&quot;);
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#欢迎参加第-3-天的课程" id="欢迎参加第-3-天的课程">欢迎参加第 3 天的课程</a></h1>
<p>今日内容：</p>
<ul>
<li>内存管理、生命周期和借用检查器：Rust 如何确保内存安全。</li>
<li>智能指针：标准库指针类型。</li>
</ul>
<h2><a class="header" href="#时间表-2" id="时间表-2">时间表</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#内存管理" id="内存管理">内存管理</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#回顾程序的内存分配" id="回顾程序的内存分配">回顾：程序的内存分配</a></h1>
<p>程序通过以下两种方式分配内存：</p>
<ul>
<li>
<p>栈：局部变量的连续内存区域。</p>
<ul>
<li>值在编译时具有已知的固定大小。</li>
<li>速度极快：只需移动一个栈指针。</li>
<li>易于管理：遵循函数调用规则。</li>
<li>优秀的内存局部性。</li>
</ul>
</li>
<li>
<p>堆：函数调用之外的值的存储。</p>
<ul>
<li>值具有动态大小，具体大小需在运行时确定。</li>
<li>比栈稍慢：需要向系统申请空间。</li>
<li>不保证内存局部性。</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#示例" id="示例">示例</a></h2>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><text x="282" y="28" >Heap</text><line x1="296" y1="40" x2="304" y2="40" class="solid"></line><line x1="312" y1="40" x2="320" y2="40" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >capacity</text><text x="178" y="92" >5</text><text x="50" y="108" >ptr</text><circle cx="180" cy="104" r="3" class="nofill"></circle><text x="322" y="108" >H</text><text x="362" y="108" >e</text><text x="402" y="108" >l</text><text x="442" y="108" >l</text><text x="482" y="108" >o</text><text x="50" y="124" >len</text><text x="178" y="124" >5</text><line x1="328" y1="40" x2="336" y2="40" class="solid"></line><line x1="344" y1="40" x2="352" y2="40" class="solid"></line><line x1="360" y1="40" x2="368" y2="40" class="solid"></line><line x1="376" y1="40" x2="384" y2="40" class="solid"></line><line x1="392" y1="40" x2="400" y2="40" class="solid"></line><line x1="408" y1="40" x2="416" y2="40" class="solid"></line><line x1="424" y1="40" x2="432" y2="40" class="solid"></line><line x1="440" y1="40" x2="448" y2="40" class="solid"></line><line x1="456" y1="40" x2="464" y2="40" class="solid"></line><line x1="472" y1="40" x2="480" y2="40" class="solid"></line><line x1="488" y1="40" x2="496" y2="40" class="solid"></line><line x1="504" y1="40" x2="512" y2="40" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="168" x2="304" y2="168" class="solid"></line><line x1="312" y1="168" x2="320" y2="168" class="solid"></line><line x1="328" y1="168" x2="336" y2="168" class="solid"></line><line x1="344" y1="168" x2="352" y2="168" class="solid"></line><line x1="360" y1="168" x2="368" y2="168" class="solid"></line><line x1="376" y1="168" x2="384" y2="168" class="solid"></line><line x1="392" y1="168" x2="400" y2="168" class="solid"></line><line x1="408" y1="168" x2="416" y2="168" class="solid"></line><line x1="424" y1="168" x2="432" y2="168" class="solid"></line><line x1="440" y1="168" x2="448" y2="168" class="solid"></line><line x1="456" y1="168" x2="464" y2="168" class="solid"></line><line x1="472" y1="168" x2="480" y2="168" class="solid"></line><line x1="488" y1="168" x2="496" y2="168" class="solid"></line><line x1="504" y1="168" x2="512" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,40 A 4,4 0,0,0 276,44" class="nofill"></path><line x1="276" y1="44" x2="276" y2="164" class="broken"></line><line x1="280" y1="40" x2="288" y2="40" class="solid"></line><path d="M 276,164 A 4,4 0,0,0 280,168" class="nofill"></path><line x1="280" y1="168" x2="288" y2="168" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="88" x2="508" y2="88" class="solid"></line><line x1="308" y1="88" x2="308" y2="120" class="solid"></line><line x1="348" y1="88" x2="348" y2="120" class="solid"></line><line x1="388" y1="88" x2="388" y2="120" class="solid"></line><line x1="428" y1="88" x2="428" y2="120" class="solid"></line><line x1="468" y1="88" x2="468" y2="120" class="solid"></line><line x1="508" y1="88" x2="508" y2="120" class="solid"></line><line x1="308" y1="120" x2="508" y2="120" class="solid"></line></g><g><line x1="184" y1="104" x2="296" y2="104" class="solid"></line><polygon points="296,100 304,104 296,108" class="filled"></polygon></g><g><line x1="520" y1="40" x2="528" y2="40" class="solid"></line><path d="M 528,40 A 4,4 0,0,1 532,44" class="nofill"></path><line x1="532" y1="44" x2="532" y2="164" class="broken"></line><line x1="520" y1="168" x2="528" y2="168" class="solid"></line><path d="M 532,164 A 4,4 0,0,1 528,168" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>指出 <code>String</code> 底层由 <code>Vec</code> 实现，因此它具有容量和长度，如果值可变，则可以通过在堆上重新分配存储空间进行增长。</p>
</li>
<li>
<p>如果学员提出相关问题，你可以提及我们不仅能使用[系统分配器]在堆上分配底层内存，还能使用 <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a> 实现自定义分配器</p>
</li>
</ul>
<h2><a class="header" href="#探索更多-2" id="探索更多-2">探索更多</a></h2>
<p>We can inspect the memory layout with <code>unsafe</code> Rust. However, you should point out that this is rightfully unsafe!</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::from(&quot;Hello&quot;);
    s1.push(' ');
    s1.push_str(&quot;world&quot;);
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!(&quot;capacity = {capacity}, ptr = {ptr:#x}, len = {len}&quot;);
    }
}
</code></pre></pre>
</details>
<h1><a class="header" href="#内存管理方法" id="内存管理方法">内存管理方法</a></h1>
<p>传统上，语言分为两大类：</p>
<ul>
<li>通过手动内存管理实现完全控制：C、C++、Pascal…
<ul>
<li>程序员决定何时分配或释放堆内存。</li>
<li>程序员必须确定指针是否仍指向有效内存。</li>
<li>研究表明，程序员难免会犯错。</li>
</ul>
</li>
<li>运行时通过自动内存管理实现完全安全：Java、Python、Go、Haskell…
<ul>
<li>运行时系统可确保在内存无法被引用之前，不会释放该内存。</li>
<li>Typically implemented with reference counting or garbage collection.</li>
</ul>
</li>
</ul>
<p>Rust 提供了一个全新的组合：</p>
<blockquote>
<p>通过编译时强制执行正确的内存&gt;管理来实现完全控制与安全。</p>
</blockquote>
<p>它通过一个明确的所有权（ownership）概念来实现此目的。</p>
<details>
<p>本幻灯片旨在帮助学习其他语言的学生更好地了解 Rust。</p>
<ul>
<li>
<p>C 语言必须使用 <code>malloc</code> 和 <code>free</code> 函数手动管理堆。常见错误包括忘记调用 <code>free</code>、针对同一指针多次调用它，或在释放某指针所指向的内存后解引用它。</p>
</li>
<li>
<p>C++ 具有智能指针（<code>unique_ptr</code>、<code>shared_ptr</code>）等工具，可以利用与调用析构函数相关的语言保证来确保在函数返回时释放内存。这些工具仍然很容易被滥用并导致与 C 语言类似的 bug。</p>
</li>
<li>
<p>Java、Go 和 Python 依赖垃圾回收器来识别无法再访问的内存并将其舍弃。这保证可对所有指针进行解引用操作，从而消除了释放后使用等各类 bug。但是，垃圾回收 (GC) 会产生运行时成本，并且很难进行适当调优。</p>
</li>
</ul>
<p>在许多情况下，Rust 的所有权和借用模型可以实现 C 语言的性能，能够精确地在所需位置执行分配和释放操作，且为零成本。它还提供类似于 C++ 智能指针的工具。必要时，它还提供引用计数等其他选项，甚至还有第三方 crate 可以支持运行时垃圾回收（本课程中不作介绍）。</p>
</details><h1><a class="header" href="#所有权" id="所有权">所有权</a></h1>
<p>所有变量绑定都有一个有效的“作用域”，使用 超出其作用域的变量是错误的：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<p>We say that the variable <em>owns</em> the value. Every Rust value has precisely one owner at all times.</p>
<p>At the end of the scope, the variable is <em>dropped</em> and the data is freed. A destructor can run here to free up resources.</p>
<details>
<p>熟悉垃圾回收实现的学生知道，垃圾回收器从一组 “根”开始查找所有可访问内存。Rust 的 “单一所有者”原则与此类似。</p>
</details><h1><a class="header" href="#移动语义" id="移动语义">移动语义</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>将 <code>s1</code> 赋值给 <code>s2</code>，即转移了所有权。</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>当 <code>s2</code> 离开作用域时，字符串数据被释放。</li>
</ul>
<p>移动到 <code>s2</code> 中之前：</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>移动到 <code>s2</code> 中之后：</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >6</text><text x="50" y="236" >capacity</text><text x="178" y="236" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>你将值传递给函数时，该值会被赋给函数 参数。这就转移了所有权：</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>指出这与 C++ 中的默认值相反。除非你使用 <code>std::move</code>（并已定义 move 构造函数！），否则 C++ 中的默认值是按值复制的。</p>
</li>
<li>
<p>只有所有权发生了转移。是否会生成任何机器码来操控数据本身是一个优化方面的问题，系统会主动优化此类副本。</p>
</li>
<li>
<p>简单的值（例如整数）可以标记为“Copy”（请看后续幻灯片）。</p>
</li>
<li>
<p>在 Rust 中，克隆是显式的（通过使用 <code>clone</code>）。</p>
</li>
</ul>
<p>在 <code>say_hello</code> 示例中：</p>
<ul>
<li>首次调用 <code>say_hello</code> 时，<code>main</code> 便放弃了 <code>name</code> 的所有权。此后，<code>main</code> 中不能再使用 <code>name</code>。</li>
<li>在 <code>say_hello</code> 函数结束时，系统会释放为 <code>name</code> 分配的堆内存。</li>
<li>如果 <code>main</code> 将 <code>name</code> 作为引用 (<code>&amp;name</code>) 传递过去，且 <code>say_hello</code> 接受作为参数的引用，则可保留所有权。</li>
<li>此外，<code>main</code> 也可以在首次调用时传递 <code>name</code> 的克隆 (<code>name.clone()</code>)。</li>
<li>相较于 C++，Rust 通过将移动语义设为默认值，并强制程序员进行显式克隆，更难以无意中创建副本。</li>
</ul>
<h1><a class="header" href="#探索更多-3" id="探索更多-3">探索更多</a></h1>
<h2><a class="header" href="#defensive-copies-in-modern-c" id="defensive-copies-in-modern-c">Defensive Copies in Modern C++</a></h2>
<p>现代 C++ 以不同的方式解决此问题：</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li><code>s1</code> 中的堆数据被复制，<code>s2</code> 获得自己的独立副本。</li>
<li>当 <code>s1</code> 和 <code>s2</code> 离开作用域时，它们会各自释放自己的内存。</li>
</ul>
<p>复制-赋值之前：</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>复制-赋值之后：</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<p>关键点：</p>
<ul>
<li>
<p>C++ 做出了与 Rust 略有不同的选择。由于“=”会复制数据，因此必须克隆字符串数据。否则，当任一字符串超出范围时，便会出现二次释放。</p>
</li>
<li>
<p>C++ 还包含<a href="https://en.cppreference.com/w/cpp/utility/move">“std::move”</a>，它用于指示何时可以移动某个值。如果示例为“s2 = std::move(s1)”，则不会发生堆分配。移动后，“s1”将处于有效但未指定的状态。与 Rust 不同，程序员可以继续使用“s1”。</p>
</li>
<li>
<p>与 Rust 不同，使用 C++ 时，“=”可以运行任意代码，具体取决于要复制或移动的类型。</p>
</li>
</ul>
</details><h1><a class="header" href="#clone" id="clone">Clone</a></h1>
<p>有时，<em>如需</em> 复制某个值。<code>Clone</code> 特征 可以完成此操作。</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name.clone());
    say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The idea of <code>Clone</code> is to make it easy to spot where heap allocations are occurring. Look for <code>.clone()</code> and a few others like <code>vec!</code> or <code>Box::new</code>.</p>
</li>
<li>
<p>通常的做法是，先使用 “克隆操作”解决借用检查器问题，在后续通过优化消除这些克隆操作。</p>
</li>
<li>
<p><code>clone</code> generally performs a deep copy of the value, meaning that if you e.g. clone an array, all of the elements of the array are cloned as well.</p>
</li>
<li>
<p>The behavior for <code>clone</code> is user-defined, so it can perform custom cloning logic if needed.</p>
</li>
</ul>
</details><h1><a class="header" href="#复合类型" id="复合类型">复合类型</a></h1>
<p>虽然移动语义是默认的，但默认情况下会复制某些类型：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;); // would not be accessible if not Copy
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>这些类型实现了 <code>Copy</code> trait。</p>
<p>你可以选择自己的类型来使用复制语义：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>赋值之后，<code>p1</code> 和 <code>p2</code> 都拥有自己的数据。</li>
<li>我们还可以使用 <code>p1.clone()</code> 显式复制数据。</li>
</ul>
<details>
<p>复制和克隆是两码事：</p>
<ul>
<li>复制是指内存区域的按位复制，不适用于任意对象。</li>
<li>复制不允许自定义逻辑（不同于 C++ 中的复制构造函数）。</li>
<li>克隆是一种更通用的操作，也允许通过实现 <code>Clone</code> trait 来自定义行为。</li>
<li>复制不适用于实现 <code>Drop</code> trait 的类型。</li>
</ul>
<p>在上述示例中，请尝试以下操作：</p>
<ul>
<li>在 <code>struct Point</code> 中添加 <code>String</code> 字段。由于 <code>String</code> 不属于 <code>Copy</code> 类型，因此无法编译。</li>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the <code>println!</code> for <code>p1</code>.</li>
<li>指出如果你改为克隆 <code>p1</code>，则可按预期运行。</li>
</ul>
<h1><a class="header" href="#探索更多-4" id="探索更多-4">探索更多</a></h1>
<ul>
<li>Shared references are <code>Copy</code>/<code>Clone</code>, mutable references are not. This is because Rust requires that mutable references be exclusive, so while it's valid to make a copy of a shared reference, creating a copy of a mutable reference would violate Rust's borrowing rules.</li>
</ul>
</details><h1><a class="header" href="#drop-特征" id="drop-特征"><code>Drop</code> 特征</a></h1>
<p>用于实现 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> 的值可以指定在超出范围时运行的代码：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>请注意，<code>std::mem::drop</code> 与 <code>std::ops::Drop::drop</code> 不同。</li>
<li>当值超出范围时，系统会自动将其删除。</li>
<li>丢弃某个值时，如果该值实现了 <code>std::ops::Drop</code>，则会调用其 <code>Drop::drop</code> 实现。</li>
<li>然后，该值所有字段也会被丢弃，无论其是否实现了 <code>Drop</code>。</li>
<li><code>std::mem::drop</code> 只是一个采用任何值的空函数。重要的是它获得了值的所有权，因此在其作用域结束时便会被丢弃。如此您可以轻松提前明确地丢弃值，而不必等到值超过范围的时候。
<ul>
<li>这对于通过 <code>drop</code> 执行任务的对象来说非常有用，例如释放锁、关闭文件等。</li>
</ul>
</li>
</ul>
<p>讨论点：</p>
<ul>
<li>为什么 <code>Drop::drop</code> 不使用 <code>self</code>？
<ul>
<li>简答：如果这样的话，系统会在代码块结尾 调用 <code>std::mem::drop</code>，进而引发再一次调用 <code>Drop::drop</code>，并引发堆栈 溢出！</li>
</ul>
</li>
<li>尝试用 <code>a.drop()</code> 替换 <code>drop(a)</code>。</li>
</ul>
</details>
<h1><a class="header" href="#练习构建器类型" id="练习构建器类型">练习：构建器类型</a></h1>
<p>在此示例中，我们将实现一个拥有全部数据所有权的复杂数据类型。我们将使用 “构建器模式”来支持逐步构建新值，通过便捷函数来实现。</p>
<p>填补缺失的内容。</p>
<pre><pre class="playground"><code class="language-rust should_panic editable">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        todo!(&quot;1&quot;)
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        todo!(&quot;2&quot;)
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        todo!(&quot;3&quot;)
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        todo!(&quot;4&quot;)
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        todo!(&quot;5&quot;)
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new(&quot;base64&quot;).version(&quot;0.13&quot;).build();
    println!(&quot;base64: {base64:?}&quot;);
    let log =
        PackageBuilder::new(&quot;log&quot;).version(&quot;0.4&quot;).language(Language::Rust).build();
    println!(&quot;log: {log:?}&quot;);
    let serde = PackageBuilder::new(&quot;serde&quot;)
        .authors(vec![&quot;djmitche&quot;.into()])
        .version(String::from(&quot;4.0&quot;))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!(&quot;serde: {serde:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#解答-10" id="解答-10">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        Dependency {
            name: self.name.clone(),
            version_expression: self.version.clone(),
        }
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        Self(Package {
            name: name.into(),
            version: &quot;0.1&quot;.into(),
            authors: vec![],
            dependencies: vec![],
            language: None,
        })
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        self.0.authors = authors;
        self
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        self.0.dependencies.push(dependency);
        self
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        self.0.language = Some(language);
        self
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new(&quot;base64&quot;).version(&quot;0.13&quot;).build();
    println!(&quot;base64: {base64:?}&quot;);
    let log =
        PackageBuilder::new(&quot;log&quot;).version(&quot;0.4&quot;).language(Language::Rust).build();
    println!(&quot;log: {log:?}&quot;);
    let serde = PackageBuilder::new(&quot;serde&quot;)
        .authors(vec![&quot;djmitche&quot;.into()])
        .version(String::from(&quot;4.0&quot;))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!(&quot;serde: {serde:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#智能指针" id="智能指针">智能指针</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> 是指向堆上数据的自有指针：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> 会实现 <code>Deref&lt;Target = T&gt;</code>，这意味着您可以<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">直接在 <code>Box&lt;T&gt;</code> 上通过 <code>T</code> 调用相应方法</a>。</p>
<p>Recursive data types or data types with dynamic sizes cannot be stored inline without a pointer indirection. <code>Box</code> accomplishes that indirection:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    /// A non-empty list: first element and the rest of the list.
    Element(T, Box&lt;List&lt;T&gt;&gt;),
    /// An empty list.
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; =
        List::Element(1, Box::new(List::Element(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="696" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="696" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="236" y1="28" x2="236" y2="148" class="broken"></line><text x="42" y="60" >list</text><text x="50" y="92" >Element</text><text x="130" y="92" >1</text><circle cx="172" cy="88" r="3" class="nofill"></circle><text x="338" y="92" >Element</text><text x="418" y="92" >2</text><circle cx="460" cy="88" r="3" class="nofill"></circle><text x="538" y="92" >Nil</text><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="608" y1="80" x2="600" y2="96" class="solid"></line><line x1="640" y1="80" x2="632" y2="96" class="solid"></line><line x1="648" y1="80" x2="640" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="304" y1="24" x2="312" y2="24" class="solid"></line><line x1="320" y1="24" x2="328" y2="24" class="solid"></line><line x1="336" y1="24" x2="344" y2="24" class="solid"></line><line x1="352" y1="24" x2="360" y2="24" class="solid"></line><line x1="368" y1="24" x2="376" y2="24" class="solid"></line><line x1="384" y1="24" x2="392" y2="24" class="solid"></line><line x1="400" y1="24" x2="408" y2="24" class="solid"></line><line x1="416" y1="24" x2="424" y2="24" class="solid"></line><line x1="432" y1="24" x2="440" y2="24" class="solid"></line><line x1="448" y1="24" x2="456" y2="24" class="solid"></line><line x1="464" y1="24" x2="472" y2="24" class="solid"></line><line x1="480" y1="24" x2="488" y2="24" class="solid"></line><line x1="496" y1="24" x2="504" y2="24" class="solid"></line><line x1="512" y1="24" x2="520" y2="24" class="solid"></line><line x1="528" y1="24" x2="536" y2="24" class="solid"></line><line x1="544" y1="24" x2="552" y2="24" class="solid"></line><line x1="560" y1="24" x2="568" y2="24" class="solid"></line><line x1="576" y1="24" x2="584" y2="24" class="solid"></line><line x1="592" y1="24" x2="600" y2="24" class="solid"></line><line x1="608" y1="24" x2="616" y2="24" class="solid"></line><line x1="624" y1="24" x2="632" y2="24" class="solid"></line><line x1="640" y1="24" x2="648" y2="24" class="solid"></line><line x1="656" y1="24" x2="664" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="304" y1="152" x2="312" y2="152" class="solid"></line><line x1="320" y1="152" x2="328" y2="152" class="solid"></line><line x1="336" y1="152" x2="344" y2="152" class="solid"></line><line x1="352" y1="152" x2="360" y2="152" class="solid"></line><line x1="368" y1="152" x2="376" y2="152" class="solid"></line><line x1="384" y1="152" x2="392" y2="152" class="solid"></line><line x1="400" y1="152" x2="408" y2="152" class="solid"></line><line x1="416" y1="152" x2="424" y2="152" class="solid"></line><line x1="432" y1="152" x2="440" y2="152" class="solid"></line><line x1="448" y1="152" x2="456" y2="152" class="solid"></line><line x1="464" y1="152" x2="472" y2="152" class="solid"></line><line x1="480" y1="152" x2="488" y2="152" class="solid"></line><line x1="496" y1="152" x2="504" y2="152" class="solid"></line><line x1="512" y1="152" x2="520" y2="152" class="solid"></line><line x1="528" y1="152" x2="536" y2="152" class="solid"></line><line x1="544" y1="152" x2="552" y2="152" class="solid"></line><line x1="560" y1="152" x2="568" y2="152" class="solid"></line><line x1="576" y1="152" x2="584" y2="152" class="solid"></line><line x1="592" y1="152" x2="600" y2="152" class="solid"></line><line x1="608" y1="152" x2="616" y2="152" class="solid"></line><line x1="624" y1="152" x2="632" y2="152" class="solid"></line><line x1="640" y1="152" x2="648" y2="152" class="solid"></line><line x1="656" y1="152" x2="664" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><path d="M 288,24 A 4,4 0,0,0 284,28" class="nofill"></path><line x1="284" y1="28" x2="284" y2="148" class="broken"></line><line x1="288" y1="24" x2="296" y2="24" class="solid"></line><path d="M 284,148 A 4,4 0,0,0 288,152" class="nofill"></path><line x1="288" y1="152" x2="296" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="156" y1="72" x2="156" y2="104" class="solid"></line><line x1="196" y1="72" x2="196" y2="104" class="solid"></line><line x1="36" y1="104" x2="196" y2="104" class="solid"></line></g><g><line x1="324" y1="72" x2="484" y2="72" class="solid"></line><line x1="324" y1="72" x2="324" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="444" y1="72" x2="444" y2="104" class="solid"></line><line x1="484" y1="72" x2="484" y2="104" class="solid"></line><line x1="324" y1="104" x2="484" y2="104" class="solid"></line></g><g><line x1="524" y1="72" x2="660" y2="72" class="solid"></line><line x1="524" y1="72" x2="524" y2="104" class="solid"></line><line x1="580" y1="72" x2="580" y2="104" class="solid"></line><line x1="620" y1="72" x2="620" y2="104" class="solid"></line><line x1="660" y1="72" x2="660" y2="104" class="solid"></line><line x1="524" y1="104" x2="660" y2="104" class="solid"></line></g><g><line x1="176" y1="88" x2="312" y2="88" class="solid"></line><polygon points="312,84 320,88 312,92" class="filled"></polygon></g><g><line x1="464" y1="88" x2="512" y2="88" class="solid"></line><polygon points="512,84 520,88 512,92" class="filled"></polygon></g><g><line x1="672" y1="24" x2="680" y2="24" class="solid"></line><path d="M 680,24 A 4,4 0,0,1 684,28" class="nofill"></path><line x1="684" y1="28" x2="684" y2="148" class="broken"></line><line x1="672" y1="152" x2="680" y2="152" class="solid"></line><path d="M 684,148 A 4,4 0,0,1 680,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p><code>Box</code> is like <code>std::unique_ptr</code> in C++, except that it's guaranteed to be not null.</p>
</li>
<li>
<p>在以下情况下，<code>Box</code> 可能会很实用：</p>
<ul>
<li>have a type whose size can't be known at compile time, but the Rust compiler wants to know an exact size.</li>
<li>想要转让大量数据的所有权。为避免在堆栈上复制大量数据，请改为将数据存储在 <code>Box</code> 中的堆上，以便仅移动指针。</li>
</ul>
</li>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the <code>List</code>, the compiler would not be able to compute a fixed size for the struct in memory (the <code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> 大小与一般指针相同，并且只会指向堆中的下一个 <code>List</code> 元素， 因此可以解决这个问题。</p>
</li>
<li>
<p>Remove the <code>Box</code> in the List definition and show the compiler error. We get the message &quot;recursive without indirection&quot;, because for data recursion, we have to use indirection, a <code>Box</code> or reference of some kind, instead of storing the value directly.</p>
</li>
<li>
<p>Though <code>Box</code> looks like <code>std::unique_ptr</code> in C++, it cannot be empty/null. This makes <code>Box</code> one of the types that allow the compiler to optimize storage of some enums (the &quot;niche optimization&quot;).</p>
</li>
</ul>
</details><h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> 是引用计数的共享指针。如果您需要从多个位置 引用相同的数据，请使用此指针：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&amp;a);

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<ul>
<li>See <a href="smart-pointers/../concurrency/shared-state/arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>您可以将共享指针_降级_为 <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> 指针， 以便创建之后会被舍弃的循环引用。</li>
</ul>
<details>
<ul>
<li><code>Rc</code> 的计数可确保只要有引用，内含的值就会保持有效。</li>
<li>Rust 中的“Rc”与 C++ 中的“std::shared_ptr”类似。</li>
<li><code>Rc::clone</code> 的成本很低：这个做法会创建指向相同分配的指针，并增加引用计数，而不会产生深层的克隆，排查代码性能问题时通常可以忽略。</li>
<li><code>make_mut</code> 实际上会在必要时克隆内部值（“clone-on-write”），并返回可变的引用。</li>
<li>使用 <code>Rc::strong_count</code> 可查看引用计数。</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to create cycles that will be dropped properly (likely in combination with <code>RefCell</code>).</li>
</ul>
</details><h1><a class="header" href="#owned-trait-objects" id="owned-trait-objects">Owned Trait Objects</a></h1>
<p>We previously saw how trait objects can be used with references, e.g <code>&amp;dyn Pet</code>. However, we can also use trait objects with smart pointers like <code>Box</code> to create an owned trait object: <code>Box&lt;dyn Pet&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from(&quot;Miau!&quot;)
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from(&quot;Fido&quot;), age: 5 }),
    ];
    for pet in pets {
        println!(&quot;Hello, who are you? {}&quot;, pet.talk());
    }
}
</code></pre></pre>
<p>以下是分配 <code>pets</code> 后的内存布局：</p>
<div style='width:100%; height:480px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="480"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="480"></rect><rect x="428" y="328" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="348" >&lt;Dog as Pet&gt;::talk</text><rect x="428" y="392" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="412" >&lt;Cat as Pet&gt;::talk</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="482" y="76" >F</text><text x="522" y="76" >i</text><text x="562" y="76" >d</text><text x="602" y="76" >o</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >lives</text><text x="410" y="92" >9</text><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="466" y="156" >data:</text><text x="474" y="188" >name</text><circle cx="548" cy="184" r="3" class="nofill"></circle><text x="554" y="188" >,</text><text x="570" y="188" >4,</text><text x="594" y="188" >4</text><circle cx="324" cy="200" r="3" class="nofill"></circle><circle cx="340" cy="200" r="3" class="nofill"></circle><circle cx="372" cy="200" r="3" class="nofill"></circle><circle cx="388" cy="200" r="3" class="nofill"></circle><text x="474" y="204" >age</text><text x="594" y="204" >5</text><line x1="424" y1="296" x2="432" y2="296" class="solid"></line><line x1="440" y1="296" x2="448" y2="296" class="solid"></line><line x1="456" y1="296" x2="464" y2="296" class="solid"></line><line x1="472" y1="296" x2="480" y2="296" class="solid"></line><text x="434" y="316" >vtable</text><text x="434" y="380" >vtable</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><line x1="296" y1="248" x2="304" y2="248" class="solid"></line><line x1="336" y1="248" x2="344" y2="248" class="solid"></line><line x1="352" y1="248" x2="360" y2="248" class="solid"></line><line x1="392" y1="248" x2="400" y2="248" class="solid"></line><line x1="408" y1="248" x2="416" y2="248" class="solid"></line><line x1="424" y1="248" x2="432" y2="248" class="solid"></line><line x1="440" y1="248" x2="448" y2="248" class="solid"></line><line x1="456" y1="248" x2="464" y2="248" class="solid"></line><line x1="472" y1="248" x2="480" y2="248" class="solid"></line><line x1="488" y1="248" x2="496" y2="248" class="solid"></line><line x1="504" y1="248" x2="512" y2="248" class="solid"></line><line x1="520" y1="248" x2="528" y2="248" class="solid"></line><line x1="536" y1="248" x2="544" y2="248" class="solid"></line><line x1="552" y1="248" x2="560" y2="248" class="solid"></line><line x1="568" y1="248" x2="576" y2="248" class="solid"></line><line x1="584" y1="248" x2="592" y2="248" class="solid"></line><line x1="600" y1="248" x2="608" y2="248" class="solid"></line><line x1="616" y1="248" x2="624" y2="248" class="solid"></line><line x1="296" y1="296" x2="304" y2="296" class="solid"></line><line x1="336" y1="296" x2="344" y2="296" class="solid"></line><line x1="352" y1="296" x2="360" y2="296" class="solid"></line><line x1="392" y1="296" x2="400" y2="296" class="solid"></line><line x1="408" y1="296" x2="416" y2="296" class="solid"></line><line x1="488" y1="296" x2="496" y2="296" class="solid"></line><line x1="504" y1="296" x2="512" y2="296" class="solid"></line><line x1="520" y1="296" x2="528" y2="296" class="solid"></line><line x1="536" y1="296" x2="544" y2="296" class="solid"></line><line x1="552" y1="296" x2="560" y2="296" class="solid"></line><line x1="568" y1="296" x2="576" y2="296" class="solid"></line><line x1="584" y1="296" x2="592" y2="296" class="solid"></line><line x1="600" y1="296" x2="608" y2="296" class="solid"></line><line x1="616" y1="296" x2="624" y2="296" class="solid"></line><line x1="296" y1="456" x2="304" y2="456" class="solid"></line><line x1="312" y1="456" x2="320" y2="456" class="solid"></line><line x1="328" y1="456" x2="336" y2="456" class="solid"></line><line x1="344" y1="456" x2="352" y2="456" class="solid"></line><line x1="360" y1="456" x2="368" y2="456" class="solid"></line><line x1="376" y1="456" x2="384" y2="456" class="solid"></line><line x1="392" y1="456" x2="400" y2="456" class="solid"></line><line x1="408" y1="456" x2="416" y2="456" class="solid"></line><line x1="424" y1="456" x2="432" y2="456" class="solid"></line><line x1="440" y1="456" x2="448" y2="456" class="solid"></line><line x1="456" y1="456" x2="464" y2="456" class="solid"></line><line x1="472" y1="456" x2="480" y2="456" class="solid"></line><line x1="488" y1="456" x2="496" y2="456" class="solid"></line><line x1="504" y1="456" x2="512" y2="456" class="solid"></line><line x1="520" y1="456" x2="528" y2="456" class="solid"></line><line x1="536" y1="456" x2="544" y2="456" class="solid"></line><line x1="552" y1="456" x2="560" y2="456" class="solid"></line><line x1="568" y1="456" x2="576" y2="456" class="solid"></line><line x1="584" y1="456" x2="592" y2="456" class="solid"></line><line x1="600" y1="456" x2="608" y2="456" class="solid"></line><line x1="616" y1="456" x2="624" y2="456" class="solid"></line><text x="42" y="60" >pets: Vec&lt;dyn Pet&gt;</text><text x="306" y="60" >data: Cat</text><text x="506" y="156" >Dog</text><text x="554" y="284" >Program text</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="244" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,244 A 4,4 0,0,0 280,248" class="nofill"></path><line x1="280" y1="248" x2="288" y2="248" class="solid"></line></g><g><line x1="468" y1="56" x2="628" y2="56" class="solid"></line><line x1="468" y1="56" x2="468" y2="88" class="solid"></line><line x1="508" y1="56" x2="508" y2="88" class="solid"></line><line x1="548" y1="56" x2="548" y2="88" class="solid"></line><line x1="588" y1="56" x2="588" y2="88" class="solid"></line><line x1="628" y1="56" x2="628" y2="88" class="solid"></line><line x1="468" y1="88" x2="628" y2="88" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="300" y1="72" x2="428" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="364" y1="72" x2="364" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="300" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="248" y2="88" class="solid"></line><path d="M 248,88 A 4,4 0,0,1 252,92" class="nofill"></path><line x1="252" y1="92" x2="252" y2="196" class="solid"></line><path d="M 252,196 A 4,4 0,0,0 256,200" class="nofill"></path><line x1="256" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><polygon points="480,108 484,96 488,108" class="filled"></polygon><line x1="484" y1="108" x2="484" y2="132" class="solid"></line><path d="M 484,132 A 4,4 0,0,0 488,136" class="nofill"></path><line x1="488" y1="136" x2="544" y2="136" class="solid"></line><path d="M 544,136 A 4,4 0,0,1 548,140" class="nofill"></path><line x1="548" y1="140" x2="548" y2="180" class="solid"></line></g><g><polygon points="336,124 340,112 344,124" class="filled"></polygon><line x1="340" y1="124" x2="340" y2="196" class="solid"></line></g><g><line x1="460" y1="168" x2="612" y2="168" class="solid"></line><line x1="460" y1="168" x2="460" y2="216" class="solid"></line><line x1="524" y1="168" x2="524" y2="216" class="solid"></line><line x1="612" y1="168" x2="612" y2="216" class="solid"></line><line x1="460" y1="216" x2="612" y2="216" class="solid"></line></g><g><line x1="308" y1="184" x2="404" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="356" y1="184" x2="356" y2="216" class="solid"></line><line x1="404" y1="184" x2="404" y2="216" class="solid"></line><line x1="308" y1="216" x2="404" y2="216" class="solid"></line></g><g><line x1="324" y1="204" x2="324" y2="404" class="solid"></line><line x1="312" y1="248" x2="324" y2="248" class="solid"></line><line x1="312" y1="296" x2="324" y2="296" class="solid"></line><path d="M 324,404 A 4,4 0,0,0 328,408" class="nofill"></path><line x1="328" y1="408" x2="416" y2="408" class="solid"></line><polygon points="416,404 424,408 416,412" class="filled"></polygon></g><g><line x1="372" y1="204" x2="372" y2="340" class="solid"></line><line x1="372" y1="248" x2="384" y2="248" class="solid"></line><line x1="372" y1="296" x2="384" y2="296" class="solid"></line><path d="M 372,340 A 4,4 0,0,0 376,344" class="nofill"></path><line x1="376" y1="344" x2="416" y2="344" class="solid"></line><polygon points="416,340 424,344 416,348" class="filled"></polygon></g><g><line x1="392" y1="200" x2="448" y2="200" class="solid"></line><polygon points="448,196 456,200 448,204" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="244" class="broken"></line><line x1="632" y1="248" x2="640" y2="248" class="solid"></line><path d="M 644,244 A 4,4 0,0,1 640,248" class="nofill"></path></g><g><path d="M 280,296 A 4,4 0,0,0 276,300" class="nofill"></path><line x1="276" y1="300" x2="276" y2="452" class="broken"></line><line x1="280" y1="296" x2="288" y2="296" class="solid"></line><path d="M 276,452 A 4,4 0,0,0 280,456" class="nofill"></path><line x1="280" y1="456" x2="288" y2="456" class="solid"></line></g><g><line x1="632" y1="296" x2="640" y2="296" class="solid"></line><path d="M 640,296 A 4,4 0,0,1 644,300" class="nofill"></path><line x1="644" y1="300" x2="644" y2="452" class="broken"></line><line x1="632" y1="456" x2="640" y2="456" class="solid"></line><path d="M 644,452 A 4,4 0,0,1 640,456" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>实现给定 trait 的类型可能大小不同。因此，上例中不可能具有像 <code>Vec&lt;dyn Pet&gt;</code> 这样的项。</li>
<li>可通过“dyn Pet”这个方法向编译器告知实现“Pet”的动态大小类型。</li>
<li>在本例中，<code>pets</code> 在栈上分配内存，矢量数据存储在堆上。这两个矢量元素是 <em>胖指针</em>：
<ul>
<li>胖指针属于全角指针。它包含两个部分：指向实际对象的指针，以及指向该特定对象的 <code>Pet</code> 实现的 <a href="https://en.wikipedia.org/wiki/Virtual_method_table">虚拟方法表</a> (vtable) 的指针。</li>
<li><code>Dog</code>（名为 Fido）类型的数据是 <code>name</code> 和 <code>age</code> 字段。<code>Cat</code> 类型包含一个 <code>lives</code> 字段。</li>
</ul>
</li>
<li>比较上述示例中的这些输出：
<pre><code class="language-rust ignore">println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Pet&gt;());
println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#练习二叉树" id="练习二叉树">练习：二叉树</a></h1>
<p>二元树是一种树型数据结构，其中每个节点都有两个子节点（左侧和右侧）。我们将创建一个树状结构，其中每个节点存储一个值。对于给定的节点 N，N 的左侧子树中的所有节点都包含较小的值，而 N 的右侧子树中的所有节点都将包含较大的值。</p>
<p>实现以下类型，以便通过指定的测试。</p>
<p>额外提示：对按顺序返回值的二元树实现迭代器。</p>
<pre><code class="language-rust editable ignore">/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

// Implement `new`, `insert`, `len`, and `has` for `Subtree`.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}
</code></pre>
<h1><a class="header" href="#解答-11" id="解答-11">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;

/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

impl&lt;T: Ord&gt; Subtree&lt;T&gt; {
    fn new() -&gt; Self {
        Self(None)
    }

    fn insert(&amp;mut self, value: T) {
        match &amp;mut self.0 {
            None =&gt; self.0 = Some(Box::new(Node::new(value))),
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.insert(value),
                Ordering::Equal =&gt; {}
                Ordering::Greater =&gt; n.right.insert(value),
            },
        }
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        match &amp;self.0 {
            None =&gt; false,
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.has(value),
                Ordering::Equal =&gt; true,
                Ordering::Greater =&gt; n.right.has(value),
            },
        }
    }

    fn len(&amp;self) -&gt; usize {
        match &amp;self.0 {
            None =&gt; 0,
            Some(n) =&gt; 1 + n.left.len() + n.right.len(),
        }
    }
}

impl&lt;T: Ord&gt; Node&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, left: Subtree::new(), right: Subtree::new() }
    }
}

fn main() {
    let mut tree = BinaryTree::new();
    tree.insert(&quot;foo&quot;);
    assert_eq!(tree.len(), 1);
    tree.insert(&quot;bar&quot;);
    assert!(tree.has(&amp;&quot;foo&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-2" id="welcome-back-2">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#借用" id="借用">借用</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#借用值" id="借用值">借用值</a></h1>
<p>As we saw before, instead of transferring ownership when calling a function, you can let a function <em>borrow</em> the value:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>add</code> 函数“借用”两个点并返回一个新点。</li>
<li>调用方会保留输入的所有权。</li>
</ul>
<details>
<p>此幻灯片是对第 1 天引用材料的回顾，并稍作了扩展，添加了函数参数和返回值。</p>
<h1><a class="header" href="#探索更多-5" id="探索更多-5">探索更多</a></h1>
<p>Notes on stack returns and inlining:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation, by inlining the call to add into main. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0cb13be1c05d7e3446686ad9947c4671">Playground</a> or look at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the &quot;DEBUG&quot; optimization level, the addresses should change, while they stay the same when changing to the &quot;RELEASE&quot; setting:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do automatic inlining, that can be disabled on a function level with <code>#[inline(never)]</code>.</p>
</li>
<li>
<p>Once disabled, the printed address will change on all optimization levels. Looking at Godbolt or Playground, one can see that in this case, the return of the value depends on the ABI, e.g. on amd64 the two i32 that is making up the point will be returned in 2 registers (eax and edx).</p>
</li>
</ul>
</details>
<h1><a class="header" href="#借用检查" id="借用检查">借用检查</a></h1>
<p>Rust's <em>borrow checker</em> puts constraints on the ways you can borrow values. For a given value, at any time:</p>
<ul>
<li>You can have one or more shared references to the value, <em>or</em></li>
<li>You can have exactly one exclusive reference to the value.</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>请注意，要求是相冲突的引用不能 <em>同时存在</em>。而引用的解引用位置无关紧要。</li>
<li>上述代码无法编译，因为 <code>a</code> 同时作为可变值（通过 <code>c</code>）和不可变值（通过 <code>b</code>）被借用。</li>
<li>将<code>b</code> 的 <code>println!</code> 语句移到引入 <code>c</code> 的作用域之前，这段代码就可以编译。</li>
<li>这样更改后，编译器会发现 <code>b</code> 只在通过 <code>c</code> 对 <code>a</code> 进行新可变借用之前使用过。这是借用检查器的一个功能，名为“非词法作用域生命周期”。</li>
<li>The exclusive reference constraint is quite strong. Rust uses it to ensure that data races do not occur. Rust also <em>relies</em> on this constraint to optimize code. For example, a value behind a shared reference can be safely cached in a register for the lifetime of that reference.</li>
<li>借用检查器专用于处理许多常见模式，例如同时对结构体中的不同字段进行独占引用。但在某些情况下，它并不能完全 “领会”您的意图，这往往会导致 “与借用检查器进行一番斗争”。</li>
</ul>
</details><h1><a class="header" href="#borrow-errors" id="borrow-errors">Borrow Errors</a></h1>
<p>As a concrete example of how these borrowing rules prevent memory errors, consider the case of modifying a collection while there are references to its elements:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    let elem = &amp;vec[2];
    vec.push(6);
    println!(&quot;{elem}&quot;);
}
</code></pre></pre>
<p>Similarly, consider the case of iterator invalidation:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    for elem in &amp;vec {
        vec.push(elem * 2);
    }
}
</code></pre></pre>
<details>
<ul>
<li>In both of these cases, modifying the collection by pushing new elements into it can potentially invalidate existing references to the collection's elements if the collection has to reallocate.</li>
</ul>
</details><h1><a class="header" href="#内部可变性" id="内部可变性">内部可变性</a></h1>
<p>In some situations, it's necessary to modify data behind a shared (read-only) reference. For example, a shared data structure might have an internal cache, and wish to update that cache from read-only methods.</p>
<p>The &quot;interior mutability&quot; pattern allows exclusive (mutable) access behind a shared reference. The standard library provides several ways to do this, all while still ensuring safety, typically by performing a runtime check.</p>
<h2><a class="header" href="#cell" id="cell"><code>Cell</code></a></h2>
<p><code>Cell</code> wraps a value and allows getting or setting the value using only a shared reference to the <code>Cell</code>. However, it does not allow any references to the inner value. Since there are no references, borrowing rules cannot be broken.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::Cell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = Cell::new(5);

    cell.set(123);
    println!(&quot;{}&quot;, cell.get());
}
</code></pre></pre>
<h2><a class="header" href="#refcell" id="refcell"><code>RefCell</code></a></h2>
<p><code>RefCell</code> allows accessing and mutating a wrapped value by providing alternative types <code>Ref</code> and <code>RefMut</code> that emulate <code>&amp;T</code>/<code>&amp;mut T</code> without actually being Rust references.</p>
<p>These types perform dynamic checks using a counter in the <code>RefCell</code> to prevent existence of a <code>RefMut</code> alongside another <code>Ref</code>/<code>RefMut</code>.</p>
<p>By implementing <code>Deref</code> (and <code>DerefMut</code> for <code>RefMut</code>), these types allow calling methods on the inner value without allowing references to escape.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = RefCell::new(5);

    {
        let mut cell_ref = cell.borrow_mut();
        *cell_ref = 123;

        // This triggers an error at runtime.
        // let other = cell.borrow();
        // println!(&quot;{}&quot;, *other);
    }

    println!(&quot;{cell:?}&quot;);
}
</code></pre></pre>
<details>
<p>The main thing to take away from this slide is that Rust provides <em>safe</em> ways to modify data behind a shared reference. There are a variety of ways to ensure that safety, and <code>RefCell</code> and <code>Cell</code> are two of them.</p>
<ul>
<li>
<p><code>RefCell</code> enforces Rust's usual borrowing rules (either multiple shared references or a single exclusive reference) with a runtime check. In this case, all borrows are very short and never overlap, so the checks always succeed.</p>
<ul>
<li>The extra block in the <code>RefCell</code> example is to end the borrow created by the call to <code>borrow_mut</code> before we print the cell. Trying to print a borrowed <code>RefCell</code> just shows the message <code>&quot;{borrowed}&quot;</code>.</li>
</ul>
</li>
<li>
<p><code>Cell</code> is a simpler means to ensure safety: it has a <code>set</code> method that takes <code>&amp;self</code>. This needs no runtime check, but requires moving values, which can have its own cost.</p>
</li>
<li>
<p>Both <code>RefCell</code> and <code>Cell</code> are <code>!Sync</code>, which means <code>&amp;RefCell</code> and <code>&amp;Cell</code> can't be passed between threads. This prevents two threads trying to access the cell at once.</p>
</li>
</ul>
</details><h1><a class="header" href="#练习健康统计" id="练习健康统计">练习：健康统计</a></h1>
<p>你正在实现一个健康监控系统。作为其中的一部分，你需要对用户的健康统计数据进行追踪。</p>
<p>You'll start with a stubbed function in an <code>impl</code> block as well as a <code>User</code> struct definition. Your goal is to implement the stubbed out method on the <code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing method:</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]


#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        todo!(&quot;Update a user's statistics based on measurements from a visit to the doctor&quot;)
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}
</code></pre></pre>
<h1><a class="header" href="#解答-12" id="解答-12">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">
#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &amp;self.name,
            visit_count: self.visit_count as u32,
            height_change: measurements.height - self.height,
            blood_pressure_change: match self.last_blood_pressure {
                Some(lbp) =&gt; {
                    Some((bp.0 as i32 - lbp.0 as i32, bp.1 as i32 - lbp.1 as i32))
                }
                None =&gt; None,
            },
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}
</code></pre></pre>
<h1><a class="header" href="#结构体生命周期" id="结构体生命周期">结构体生命周期</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#生命周期注解" id="生命周期注解">生命周期注解</a></h1>
<p>A reference has a <em>lifetime</em>, which must not &quot;outlive&quot; the value it refers to. This is verified by the borrow checker.</p>
<p>The lifetime can be implicit - this is what we have seen so far. Lifetimes can also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>. Lifetimes start with <code>'</code> and <code>'a</code> is a typical default name. Read <code>&amp;'a Point</code> as &quot;a borrowed <code>Point</code> which is valid for at least the lifetime <code>a</code>&quot;.</p>
<p>Lifetimes are always inferred by the compiler: you cannot assign a lifetime yourself. Explicit lifetime annotations create constraints where there is ambiguity; the compiler verifies that there is a valid solution.</p>
<p>当考虑向函数传递值和从函数返回值时，生命周期会变得更加复杂。</p>
<!-- The multi-line formatting by rustfmt in left_most is apparently
     intentional: https://github.com/rust-lang/rustfmt/issues/1908 -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[derive(Debug)]
struct Point(i32, i32);

fn left_most(p1: &amp;Point, p2: &amp;Point) -&gt; &amp;Point {
    if p1.0 &lt; p2.0 {
        p1
    } else {
        p2
    }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3 = left_most(&amp;p1, &amp;p2); // What is the lifetime of p3?
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre></pre>
<details>
<p>In this example, the compiler does not know what lifetime to infer for <code>p3</code>. Looking inside the function body shows that it can only safely assume that <code>p3</code>'s lifetime is the shorter of <code>p1</code> and <code>p2</code>. But just like types, Rust requires explicit annotations of lifetimes on function arguments and return values.</p>
<p>将 <code>'a</code> 适当添加到 <code>left_most</code> 中：</p>
<pre><code class="language-rust ignore">fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
</code></pre>
<p>这表示.，“假设 p1 和 p2 的存在时间都比 <code>'a</code> 更长，则返回值至少在 <code>'a</code> 内有效”。</p>
<p>在一般情况下，可以省略生命周期，如下一张幻灯片中所述。</p>
</details><h1><a class="header" href="#函数调用中的生命周期" id="函数调用中的生命周期">函数调用中的生命周期</a></h1>
<p>Lifetimes for function arguments and return values must be fully specified, but Rust allows lifetimes to be elided in most cases with <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple rules</a>. This is not inference -- it is just a syntactic shorthand.</p>
<ul>
<li>每个没有生命周期注解的参数都会添加一个生命周期注解。</li>
<li>如果只有一个参数生命周期，则将其赋予所有未加注解的返回值。</li>
<li>如果有多个参数生命周期，但第一个是用于 <code>self</code> 的，则将该生命周期赋予所有未加注解的返回值。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn cab_distance(p1: &amp;Point, p2: &amp;Point) -&gt; i32 {
    (p1.0 - p2.0).abs() + (p1.1 - p2.1).abs()
}

fn nearest&lt;'a&gt;(points: &amp;'a [Point], query: &amp;Point) -&gt; Option&lt;&amp;'a Point&gt; {
    let mut nearest = None;
    for p in points {
        if let Some((_, nearest_dist)) = nearest {
            let dist = cab_distance(p, query);
            if dist &lt; nearest_dist {
                nearest = Some((p, dist));
            }
        } else {
            nearest = Some((p, cab_distance(p, query)));
        };
    }
    nearest.map(|(p, _)| p)
}

fn main() {
    let points = &amp;[Point(1, 0), Point(1, 0), Point(-1, 0), Point(0, -1)];
    println!(&quot;{:?}&quot;, nearest(points, &amp;Point(0, 2)));
}
</code></pre></pre>
<details>
<p>在此示例中，<code>cab_distance</code> 被轻易省略掉了。</p>
<p><code>nearest</code> 函数提供了另一个函数示例，该函数的参数中包含多个引用，需要显式注解。</p>
<p>请尝试将签名调整为 “谎报”了返回的生命周期：</p>
<pre><code class="language-rust ignore">fn nearest&lt;'a, 'q&gt;(points: &amp;'a [Point], query: &amp;'q Point) -&gt; Option&lt;&amp;'q Point&gt; {
</code></pre>
<p>This won't compile, demonstrating that the annotations are checked for validity by the compiler. Note that this is not the case for raw pointers (unsafe), and this is a common source of errors with unsafe Rust.</p>
<p>Students may ask when to use lifetimes. Rust borrows <em>always</em> have lifetimes. Most of the time, elision and type inference mean these don't need to be written out. In more complicated cases, lifetime annotations can help resolve ambiguity. Often, especially when prototyping, it's easier to just work with owned data by cloning values where necessary.</p>
</details><h1><a class="header" href="#数据结构中的生命周期" id="数据结构中的生命周期">数据结构中的生命周期</a></h1>
<p>如果数据类型存储了借用的数据，则必须对其添加生命周期注释：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>在上述示例中，<code>Highlight</code> 注释会强制包含 <code>&amp;str</code> 的底层数据的生命周期至少与使用该数据的任何 <code>Highlight</code> 实例一样长。</li>
<li>如果 <code>text</code> 在 <code>fox</code>（或 <code>dog</code>）的生命周期结束前被消耗，借用检查器将抛出一个错误。</li>
<li>借用数据的类型会迫使用户保留原始数据。这对于创建轻量级视图很有用，但通常会使它们更难使用。</li>
<li>如有可能，让数据结构直接拥有自己的数据。</li>
<li>一些包含多个引用的结构可以有多个生命周期注释。除了结构体本身的生命周期之外，如果需要描述引用之间的生命周期关系，则可能需要这样做。这些都是非常高级的用例。</li>
</ul>
</details><h1><a class="header" href="#练习protobuf-解析" id="练习protobuf-解析">练习：Protobuf 解析</a></h1>
<p>在本练习中，您将为 <a href="https://protobuf.dev/programming-guides/encoding/">protobuf 二进制编码</a> 构建一个解析器。别担心，其实非常简单！这展示了一种常见的解析模式，即传递数据 slice。底层数据本身永远不会被复制。</p>
<p>如要完整解析 protobuf 消息，需要知道字段的类型（按字段编号编入索引）。这通常会在 <code>proto</code> 文件中提供。在本练习中，我们将把这些信息编码成处理每个字段所调用的函数中的 <code>match</code> 语句。</p>
<p>我们将使用以下 proto：</p>
<pre><code class="language-proto">message PhoneNumber {
  optional string number = 1;
  optional string type = 2;
}

message Person {
  optional string name = 1;
  optional int32 id = 2;
  repeated PhoneNumber phones = 3;
}
</code></pre>
<p>proto 消息被编码为连续的一系列字段。每个字段都通过 “标签”后面紧跟值的形式来实现。标签包含一个字段编号（例如<code>Person</code> 消息的 <code>id</code> 字段的值为 <code>2</code>）和线型（用于定义应如何从字节流确定载荷）。</p>
<p>整数（包括标签）使用名为 VARINT 的可变长度编码表示。幸运的是，下面为您提供了 <code>parse_varint</code> 的定义。该指定代码还定义了一些回调，用于处理 <code>Person</code> 和 <code>PhoneNumber</code> 字段，并将消息解析为对这些回调的一系列调用。</p>
<p>What remains for you is to implement the <code>parse_field</code> function and the <code>ProtoMessage</code> trait for <code>Person</code> and <code>PhoneNumber</code>.</p>
<!-- compile_fail because the stubbed out code has type inference errors. -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// A wire type as seen on the wire.
enum WireType {
    /// Varint WireType 表明该值为单个 VARINT。
    Varint,
    /// The I64 WireType indicates that the value is precisely 8 bytes in
    /// little-endian order containing a 64-bit signed integer or double type.
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    // The I32 WireType indicates that the value is precisely 4 bytes in
    // little-endian order containing a 32-bit signed integer or float type.
    //I32,  -- not needed for this exercise
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    //I32(i32),  -- not needed for this exercise
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            //5 =&gt; WireType::I32,  -- not needed for this exercise
            _ =&gt; panic!(&quot;Invalid wire type: {value}&quot;),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_str(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected string to be a `Len` field&quot;);
        };
        std::str::from_utf8(data).expect(&quot;Invalid string&quot;)
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected bytes to be a `Len` field&quot;);
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!(&quot;Expected `u64` to be a `Varint` field&quot;);
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!(&quot;Not enough bytes for varint&quot;);
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!(&quot;Too many bytes for varint&quot;);
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}


/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        _ =&gt; todo!(&quot;Based on the wire type, build a Field, consuming as many bytes as necessary.&quot;)
    };
    todo!(&quot;Return the field, and any un-consumed bytes.&quot;)
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

// TODO: Implement ProtoMessage for Person and PhoneNumber.

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!(&quot;{:#?}&quot;, person);
}
</code></pre></pre>
<details>
<ul>
<li>In this exercise there are various cases where protobuf parsing might fail, e.g. if you try to parse an <code>i32</code> when there are fewer than 4 bytes left in the data buffer. In normal Rust code we'd handle this with the <code>Result</code> enum, but for simplicity in this exercise we panic if any errors are encountered. On day 4 we'll cover error handling in Rust in more detail.</li>
</ul>
</details><h1><a class="header" href="#解答-13" id="解答-13">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// A wire type as seen on the wire.
enum WireType {
    /// Varint WireType 表明该值为单个 VARINT。
    Varint,
    /// The I64 WireType indicates that the value is precisely 8 bytes in
    /// little-endian order containing a 64-bit signed integer or double type.
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    // The I32 WireType indicates that the value is precisely 4 bytes in
    // little-endian order containing a 32-bit signed integer or float type.
    //I32,  -- not needed for this exercise
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    //I32(i32),  -- not needed for this exercise
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            //5 =&gt; WireType::I32,  -- not needed for this exercise
            _ =&gt; panic!(&quot;Invalid wire type: {value}&quot;),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_str(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected string to be a `Len` field&quot;);
        };
        std::str::from_utf8(data).expect(&quot;Invalid string&quot;)
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected bytes to be a `Len` field&quot;);
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!(&quot;Expected `u64` to be a `Varint` field&quot;);
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!(&quot;Not enough bytes for varint&quot;);
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!(&quot;Too many bytes for varint&quot;);
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}

/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        WireType::Varint =&gt; {
            let (value, remainder) = parse_varint(remainder);
            (FieldValue::Varint(value), remainder)
        }
        WireType::Len =&gt; {
            let (len, remainder) = parse_varint(remainder);
            let len: usize = len.try_into().expect(&quot;len not a valid `usize`&quot;);
            if remainder.len() &lt; len {
                panic!(&quot;Unexpected EOF&quot;);
            }
            let (value, remainder) = remainder.split_at(len);
            (FieldValue::Len(value), remainder)
        }
    };
    (Field { field_num, value: fieldvalue }, remainder)
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(PartialEq)]
#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(PartialEq)]
#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for Person&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.name = field.value.as_str(),
            2 =&gt; self.id = field.value.as_u64(),
            3 =&gt; self.phone.push(parse_message(field.value.as_bytes())),
            _ =&gt; {} // skip everything else
        }
    }
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for PhoneNumber&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.number = field.value.as_str(),
            2 =&gt; self.type_ = field.value.as_str(),
            _ =&gt; {} // skip everything else
        }
    }
}

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!(&quot;{:#?}&quot;, person);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_id() {
        let person_id: Person = parse_message(&amp;[0x10, 0x2a]);
        assert_eq!(person_id, Person { name: &quot;&quot;, id: 42, phone: vec![] });
    }

    #[test]
    fn test_name() {
        let person_name: Person = parse_message(&amp;[
            0x0a, 0x0e, 0x62, 0x65, 0x61, 0x75, 0x74, 0x69, 0x66, 0x75, 0x6c, 0x20,
            0x6e, 0x61, 0x6d, 0x65,
        ]);
        assert_eq!(
            person_name,
            Person { name: &quot;beautiful name&quot;, id: 0, phone: vec![] }
        );
    }

    #[test]
    fn test_just_person() {
        let person_name_id: Person =
            parse_message(&amp;[0x0a, 0x04, 0x45, 0x76, 0x61, 0x6e, 0x10, 0x16]);
        assert_eq!(person_name_id, Person { name: &quot;Evan&quot;, id: 22, phone: vec![] });
    }

    #[test]
    fn test_phone() {
        let phone: Person = parse_message(&amp;[
            0x0a, 0x00, 0x10, 0x00, 0x1a, 0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x33,
            0x34, 0x2d, 0x37, 0x37, 0x37, 0x2d, 0x39, 0x30, 0x39, 0x30, 0x12, 0x04,
            0x68, 0x6f, 0x6d, 0x65,
        ]);
        assert_eq!(
            phone,
            Person {
                name: &quot;&quot;,
                id: 0,
                phone: vec![PhoneNumber { number: &quot;+1234-777-9090&quot;, type_: &quot;home&quot; },],
            }
        );
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-to-day-4" id="welcome-to-day-4">Welcome to Day 4</a></h1>
<p>Today we will cover topics relating to building large-scale software in Rust:</p>
<ul>
<li>迭代器：深入了解 <code>Iterator</code> 特征。</li>
<li>模块和可见性。</li>
<li>Testing.</li>
<li>错误处理：panic、“Result”和 try 运算符“?”。</li>
<li>不安全 Rust：当无法用安全 Rust 表达您的意图时，则可将其作为应急方法。</li>
</ul>
<h2><a class="header" href="#时间表-3" id="时间表-3">时间表</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#迭代器" id="迭代器">迭代器</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#iterator" id="iterator"><code>Iterator</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">'Iterator'</a> trait 支持迭代集合中的值。它需要用到 <code>next</code> 方法，并提供很多方法。许多标准库类型均能实现 <code>Iterator</code>，您也可以自行实现：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations over collections (e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait where you can find all the documentation about them. In Rust these functions should produce the code as efficient as equivalent imperative implementations.</p>
</li>
<li>
<p><code>IntoIterator</code> 是迫使 for 循环运作的特征。此特征由集合类型 （例如 <code>Vec&lt;T&gt;</code>）和相关引用（例如 <code>&amp;Vec&lt;T&gt;</code> 和 <code>&amp;[T]</code>）而实现。此外，范围也会实现这项特征。因此， 您可以使用 <code>for i in some_vec { .. }</code> 来遍历某矢量，但 <code>some_vec.next()</code> 不存在。</p>
</li>
</ul>
</details>
<h1><a class="header" href="#intoiterator" id="intoiterator"><code>IntoIterator</code></a></h1>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an iterator. The related trait <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> defines how to create an iterator for a type. It is used automatically by the <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Grid {
    x_coords: Vec&lt;u32&gt;,
    y_coords: Vec&lt;u32&gt;,
}

impl IntoIterator for Grid {
    type Item = (u32, u32);
    type IntoIter = GridIter;
    fn into_iter(self) -&gt; GridIter {
        GridIter { grid: self, i: 0, j: 0 }
    }
}

struct GridIter {
    grid: Grid,
    i: usize,
    j: usize,
}

impl Iterator for GridIter {
    type Item = (u32, u32);

    fn next(&amp;mut self) -&gt; Option&lt;(u32, u32)&gt; {
        if self.i &gt;= self.grid.x_coords.len() {
            self.i = 0;
            self.j += 1;
            if self.j &gt;= self.grid.y_coords.len() {
                return None;
            }
        }
        let res = Some((self.grid.x_coords[self.i], self.grid.y_coords[self.j]));
        self.i += 1;
        res
    }
}

fn main() {
    let grid = Grid { x_coords: vec![3, 5, 7, 9], y_coords: vec![10, 20, 30, 40] };
    for (x, y) in grid {
        println!(&quot;point = {x}, {y}&quot;);
    }
}
</code></pre></pre>
<details>
<p>Click through to the docs for <code>IntoIterator</code>. Every implementation of <code>IntoIterator</code> must declare two types:</p>
<ul>
<li><code>Item</code>: the type to iterate over, such as <code>i8</code>,</li>
<li>“IntoIter”：“into_iter”方法返回的“Iterator”类型。</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same <code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>此示例对 x 坐标和 y 坐标的所有组合进行了迭代。</p>
<p>请尝试在 <code>main</code> 中对网格进行两次迭代。为什么会失败？请注意，<code>IntoIterator::into_iter</code> 获得了 <code>self</code> 的所有权。</p>
<p>如要解决此问题，请为 <code>&amp;Grid</code> 实现 <code>IntoIterator</code>，并在 <code>GridIter</code> 中存储对 <code>Grid</code> 的引用。</p>
<p>对于标准库类型，可能会出现同样的问题：<code>for e in some_vector</code> 将获得<code> some_vector</code> 的所有权，并迭代该矢量中的自有元素。请改用 <code>for e in &amp;some_vector</code> 来迭代 <code>some_vector</code> 的元素的引用。</p>
</details><h1><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> 让您可通过 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> 构建一个集合。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes.into_iter().map(|p| p * p).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;prime_squares: {prime_squares:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>Iterator</code> implements</p>
<pre><code class="language-rust ignore">fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized
</code></pre>
<p>可以通过两种方式为此方法指定 <code>B</code>：</p>
<ul>
<li>With the &quot;turbofish&quot;: <code>some_iterator.collect::&lt;COLLECTION_TYPE&gt;()</code>, as shown. The <code>_</code> shorthand used here lets Rust infer the type of the <code>Vec</code> elements.</li>
<li>使用类型推理功能时：<code>let prime_squares: Vec&lt;_&gt; = some_iterator.collect()</code>。将示例重写成使用这种形式。</li>
</ul>
<p>There are basic implementations of <code>FromIterator</code> for <code>Vec</code>, <code>HashMap</code>, etc. There are also more specialized implementations which let you do cool things like convert an <code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
</details>
<h1><a class="header" href="#练习迭代器方法链" id="练习迭代器方法链">练习：迭代器方法链</a></h1>
<p>In this exercise, you will need to find and use some of the provided methods in the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait to implement a complex calculation.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests pass. Use an iterator expression and <code>collect</code> the result to construct the return value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    unimplemented!()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#解答-14" id="解答-14">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let a = (&amp;values).into_iter();
    let b = (&amp;values).into_iter().cycle().skip(offset);
    a.zip(b).map(|(a, b)| *b - *a).collect()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#模块" id="模块">模块</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#模块-1" id="模块-1">模块</a></h1>
<p>我们已看了“impl”块如何让我们将函数的命名空间建为一种类型。</p>
<p>同样，“mod”让我们可为类型和函数建立命名空间：</p>
<pre><pre class="playground"><code class="language-rust editable">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<details>
<ul>
<li>包提供功能，并包含一个描述如何构建包含 1 个以上 crate 的捆绑包的“Cargo.toml”文件。</li>
<li>crate 是一种模块树，其中的二进制 crate 会创建一个可执行文件，而库 crate 会编译为库。</li>
<li>模块定义了组织和范围，并且是本部分的重点。</li>
</ul>
</details><h1><a class="header" href="#文件系统层级结构" id="文件系统层级结构">文件系统层级结构</a></h1>
<p>如果省略模块内容，则会指示 Rust 在另一个文件中查找：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">mod garden;
</code></pre></pre>
<p>This tells Rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>. Similarly, a <code>garden::vegetables</code> module can be found at <code>src/garden/vegetables.rs</code>.</p>
<p>“crate”根目录位于：</p>
<ul>
<li>“src/lib.rs”（对于库 crate）</li>
<li>“src/main.rs”（对于二进制文件 crate）</li>
</ul>
<p>也可以使用“内部文档注释”对文件中定义的模块进行记录。这些用于记录包含它们的项（在本例中为模块）。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use garden::Garden;
pub use seeds::SeedPacket;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) {
    todo!()
}

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) {
    todo!()
}
</code></pre></pre>
<details>
<ul>
<li>
<p>在 Rust 2018 之前的版本中，模块需要位于“module/mod.rs”而非“module.rs”中，对于 2018 年之后的版本而言，这仍是有效的替代方案。</p>
</li>
<li>
<p>引入“filename.rs”来替代“filename/mod.rs”的主要原因是，许多名为“mod.rs”的文件在 IDE 中可能难以区分。</p>
</li>
<li>
<p>即使主模块是文件，更深层的嵌套也可以使用文件夹：</p>
<pre><code class="language-ignore">src/
├── main.rs
├── top_module.rs
└── top_module/
    └── sub_module.rs
</code></pre>
</li>
<li>
<p>Rust 寻找模块的位置可通过编译器指令更改：</p>
<pre><code class="language-rust ignore">#[path = &quot;some/path.rs&quot;]
mod some_module;
</code></pre>
<p>例如，如果您想将某个模块的测试放在名为“some_module_test.rs”的文件中（类似于 Go 中的惯例），这样做很有用。</p>
</li>
</ul>
</details><h1><a class="header" href="#可见性" id="可见性">可见性</a></h1>
<p>模块是一种隐私边界：</p>
<ul>
<li>默认情况下，模块项是私有的（隐藏实现详情）。</li>
<li>父项和同级子项始终可见。</li>
<li>换言之，如果某个项在模块“foo”中可见，那么该项在“foo”的所有后代中均可见。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<details>
<ul>
<li>使用“pub”关键字将模块设为公开。</li>
</ul>
<p>此外，您还可以使用高级“pub(...)”说明符来限制公开可见的范围。</p>
<ul>
<li>请参阅 <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust 参考</a>。</li>
<li>配置“pub(crate)”可见性是一种常见模式。</li>
<li>您可以为特定路径授予可见性，这种情况不太常见。</li>
<li>在任何情况下，都必须向祖先模块（及其所有后代）授予可见性。</li>
</ul>
</details><h1><a class="header" href="#usesuperself" id="usesuperself">use、super、self</a></h1>
<p>一个模块可以使用“use”将另一个模块的符号全部纳入。您通常在每个模块的顶部会看到如下内容：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashSet;
use std::process::abort;
</code></pre></pre>
<h2><a class="header" href="#路径" id="路径">路径</a></h2>
<p>路径解析如下：</p>
<ol>
<li>
<p>作为相对路径：</p>
<ul>
<li><code>foo</code> 或 <code>self::foo</code> 是指当前模块中的 <code>foo</code>，</li>
<li>“super::foo”是指父模块中的“foo”。</li>
</ul>
</li>
<li>
<p>作为绝对路径：</p>
<ul>
<li><code>crate::foo</code> 是指当前 crate 的根中的 <code>foo</code>，</li>
<li>“bar::foo”是指“bar”crate 中的“foo”。</li>
</ul>
</li>
</ol>
<details>
<ul>
<li>
<p>通常使用较短的路径来 “重新导出”符号。例如，crate 中的顶层 <code>lib.rs</code> 文件可能会</p>
<pre><code class="language-rust ignore">mod storage;

pub use storage::disk::DiskStorage;
pub use storage::network::NetworkStorage;
</code></pre>
<p>通过便捷的短路径，使得 <code>DiskStorage</code> 和 <code>NetworkStorage</code> 可供其他 crate 使用。</p>
</li>
<li>
<p>在大多数情况下，只有模块中显示的项才需通过 <code>use</code> 引入。不过，即使实现该 trait 的类型已处于作用域内，如要调用该 trait 的任何方法，仍需将该 trait 引入到作用域内。例如，如需对实现 <code>Read</code> trait 的类型使用 <code>read_to_string</code> 方法，您需要使用 <code>use std::io::Read</code> 引入。</p>
</li>
<li>
<p><code>use</code> 语句可以包含通配符：<code>use std::io::*</code>。但不推荐这种做法，因为不清楚导入了哪些项，并且这些内容可能会随时间而变化。</p>
</li>
</ul>
</details><h1><a class="header" href="#练习面向-gui-库的模块" id="练习面向-gui-库的模块">练习：面向 GUI 库的模块</a></h1>
<p>In this exercise, you will reorganize a small GUI Library implementation. This library defines a <code>Widget</code> trait and a few implementations of that trait, as well as a <code>main</code> function.</p>
<p>It is typical to put each type or set of closely-related types into its own module, so each widget type should get its own module.</p>
<h2><a class="header" href="#cargo-setup" id="cargo-setup">Cargo Setup</a></h2>
<p>Rust Playground 仅支持一个文件，因此您需要在本地文件系统上创建一个 Cargo 项目：</p>
<pre><code class="language-shell">cargo init gui-modules
cd gui-modules
cargo run
</code></pre>
<p>Edit the resulting <code>src/main.rs</code> to add <code>mod</code> statements, and add additional files in the <code>src</code> directory.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>Here's the single-module implementation of the GUI library:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: Change draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use the
        // ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(&quot;Click me!&quot;)));
    window.draw();
}
</code></pre></pre>
<details>
<p>鼓励学生按照自己认为合适的方式划分代码，并熟悉必需的 <code>mod</code>、<code>use</code> 和 <code>pub</code> 声明。之后，讨论哪些组织方式最符合惯例。</p>
</details><h1><a class="header" href="#解答-15" id="解答-15">解答</a></h1>
<!--
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
-->
<pre><code class="language-ignore">src
├── main.rs
├── widgets
│   ├── button.rs
│   ├── label.rs
│   └── window.rs
└── widgets.rs
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets.rs ----
mod button;
mod label;
mod window;

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub use button::Button;
pub use label::Label;
pub use window::Window;
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/label.rs ----
use super::Widget;

pub struct Label {
    label: String,
}

impl Label {
    pub fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Label-width
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    // ANCHOR: Label-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Label-draw_into
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/button.rs ----
use super::{Label, Widget};

pub struct Button {
    label: Label,
}

impl Button {
    pub fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Button-width
        self.label.width() + 8 // add a bit of padding
    }

    // ANCHOR: Button-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Button-draw_into
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/window.rs ----
use super::Widget;

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    pub fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    pub fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Window-width
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    // ANCHOR: Window-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Window-draw_into
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/main.rs ----
mod widgets;

use widgets::Widget;

fn main() {
    let mut window = widgets::Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window
        .add_widget(Box::new(widgets::Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(widgets::Button::new(&quot;Click me!&quot;)));
    window.draw();
}
</code></pre>
<h1><a class="header" href="#测试" id="测试">测试</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#单元测试" id="单元测试">单元测试</a></h1>
<p>Rust 和 Cargo 随附了一个简单的单元测试框架：</p>
<ul>
<li>
<p>单元测试在您的整个代码中都受支持。</p>
</li>
<li>
<p>您可以通过 <code>tests/</code> 目录来支持集成测试。</p>
</li>
</ul>
<p>Tests are marked with <code>#[test]</code>. Unit tests are often put in a nested <code>tests</code> module, using <code>#[cfg(test)]</code> to conditionally compile them only when building tests.</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty() {
        assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
    }

    #[test]
    fn test_single_word() {
        assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
    }

    #[test]
    fn test_multiple_words() {
        assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
    }
}
</code></pre>
<ul>
<li>这样一来，您可以对专用帮助程序进行单元测试。</li>
<li>仅当您运行 <code>cargo test</code> 时，<code>#[cfg(test)]</code> 属性才有效。</li>
</ul>
<details>
<p>在 Playground 中运行测试显示测试结果。</p>
</details><h1><a class="header" href="#其他类型的测试" id="其他类型的测试">其他类型的测试</a></h1>
<h2><a class="header" href="#集成测试" id="集成测试">集成测试</a></h2>
<p>如果您想要以客户的身份测试您的库，请使用集成测试。</p>
<p>在 <code>tests/</code> 下方创建一个 <code>.rs</code> 文件：</p>
<pre><code class="language-rust ignore">// tests/my_library.rs
use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>这些测试只能使用您的 crate 的公共 API。</p>
<h2><a class="header" href="#文档测试" id="文档测试">文档测试</a></h2>
<p>Rust 本身就支持文档测试：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>///</code> 注释中的代码块会自动被视为 Rust 代码。</li>
<li>代码会作为 <code>cargo test</code> 的一部分进行编译和执行。</li>
<li>Adding <code>#</code> in the code will hide it from the docs, but will still compile/run it.</li>
<li>在 <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a> 上测试上述代码。</li>
</ul>
<h1><a class="header" href="#编译器-lint-和-clippy" id="编译器-lint-和-clippy">编译器 Lint 和 Clippy</a></h1>
<p>Rust 编译器会生成出色的错误消息，并提供实用的内置 lint 功能。<a href="https://doc.rust-lang.org/clippy/">Clippy</a> 提供了更多 lint 功能，采用按组分类方式，并可按项目灵活启用。</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[deny(clippy::cast_possible_truncation)]
fn main() {
    let x = 3;
    while (x &lt; 70000) {
        x *= 2;
    }
    println!(&quot;X probably fits in a u16, right? {}&quot;, x as u16);
}
</code></pre></pre>
<details>
<p>运行代码示例并检查错误消息。此处还会显示一些 lint，但是一旦完成代码编译，就不会再显示这些 lint。切换到 Playground 网站以显示这些 lint。</p>
<p>解析完 lint 之后，请在 Playground 网站上运行 <code>clippy</code>，以显示 clippy 警告。Clippy 提供了大量的 lint 文档，并且在不断添加新的 lint（包括默认拒绝 lint）。</p>
<p>请注意，带有 <code>help: ...</code> 的错误或警告可以通过 <code>cargo Fix</code> 或编辑器进行修复。</p>
</details><h1><a class="header" href="#练习卢恩算法" id="练习卢恩算法">练习：卢恩算法</a></h1>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95">卢恩算法</a>用于验证信用卡号。该算法将字符串作为输入内容，并执行以下操作来验证信用卡号：</p>
<ul>
<li>
<p>Ignore all spaces. Reject numbers with fewer than two digits.</p>
</li>
<li>
<p>从<strong>右到左</strong>，将偶数位的数字乘二。对于数字“1234”，我们将“3”和“1”乘二；对于数字“98765”，将“6”和“8”乘二。</p>
</li>
<li>
<p>将一个数字乘二后，如果结果大于 9，则将每位数字相加。因此，将“7”乘二得“14”，然后“1 + 4 = 5”。</p>
</li>
<li>
<p>将所有未乘二和已乘二的数字相加。</p>
</li>
<li>
<p>如果总和以“0”结尾，则信用卡号有效。</p>
</li>
</ul>
<p>The provided code provides a buggy implementation of the luhn algorithm, along with two basic unit tests that confirm that most of the algorithm is implemented correctly.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and write additional tests to uncover bugs in the provided implementation, fixing any bugs you find.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn(&quot;4263 9826 4026 9299&quot;));
        assert!(luhn(&quot;4539 3195 0343 6467&quot;));
        assert!(luhn(&quot;7992 7398 713&quot;));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
        assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
        assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#解答-16" id="解答-16">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">// This is the buggy version that appears in the problem.
#[cfg(never)]
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

// This is the solution and passes all of the tests below.
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;
    let mut digits = 0;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            digits += 1;
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else if c.is_whitespace() {
            // New: accept whitespace.
            continue;
        } else {
            // New: reject all other characters.
            return false;
        }
    }

    // New: check that we have at least two digits
    digits &gt;= 2 &amp;&amp; sum % 10 == 0
}

fn main() {
    let cc_number = &quot;1234 5678 1234 5670&quot;;
    println!(
        &quot;Is {cc_number} a valid credit card number? {}&quot;,
        if luhn(cc_number) { &quot;yes&quot; } else { &quot;no&quot; }
    );
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn(&quot;4263 9826 4026 9299&quot;));
        assert!(luhn(&quot;4539 3195 0343 6467&quot;));
        assert!(luhn(&quot;7992 7398 713&quot;));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
        assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
        assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
    }

    #[test]
    fn test_non_digit_cc_number() {
        assert!(!luhn(&quot;foo&quot;));
        assert!(!luhn(&quot;foo 0 0&quot;));
    }

    #[test]
    fn test_empty_cc_number() {
        assert!(!luhn(&quot;&quot;));
        assert!(!luhn(&quot; &quot;));
        assert!(!luhn(&quot;  &quot;));
        assert!(!luhn(&quot;    &quot;));
    }

    #[test]
    fn test_single_digit_cc_number() {
        assert!(!luhn(&quot;0&quot;));
    }

    #[test]
    fn test_two_digit_cc_number() {
        assert!(luhn(&quot; 0 0 &quot;));
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-3" id="welcome-back-3">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#错误处理" id="错误处理">错误处理</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#panics" id="panics">Panics</a></h1>
<p>Rust 通过 “panic”机制处理严重错误。</p>
<p>如果运行时发生严重错误，Rust 会触发 panic：</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panic 用于指示不可恢复的意外错误。
<ul>
<li>Panic反映了程序中的 bug 问题。</li>
<li>运行时失败（例如边界检查失败）可能会触发 panic</li>
<li>断言（例如 <code>assert!</code>）在失败时会触发 panic</li>
<li>针对特定用途的 panic 可以使用 <code>panic!</code> 宏。</li>
</ul>
</li>
<li>使用 panic 会 “展开”堆栈，并丢弃对应的值，就像函数已经返回一样。</li>
<li>如果崩溃不可接受，请使用不会触发 panic 的 API（例如 <code>Vec::get</code>）。</li>
</ul>
<details>
<p>默认情况下，panic 会导致堆栈展开。您可以捕获展开信息：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| &quot;No problem here!&quot;);
    println!(&quot;{result:?}&quot;);

    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    println!(&quot;{result:?}&quot;);
}
</code></pre></pre>
<ul>
<li>捕获异常；请勿尝试使用 <code>catch_unwind</code> 实现异常！</li>
<li>如果服务器需要持续运行（即使是在请求发生崩溃的情况下）， 此方法十分有用。</li>
<li>如果您在 <code>Cargo.toml</code> 中设置了 <code>panic = 'abort'</code>，此方法不会生效。</li>
</ul>
</details><h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>Our primary mechanism for error handling in Rust is the <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> enum, which we briefly saw when discussing standard library types.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!(&quot;Dear diary: {contents} ({bytes} bytes)&quot;);
            } else {
                println!(&quot;Could not read file content&quot;);
            }
        }
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Result</code> has two variants: <code>Ok</code> which contains the success value, and <code>Err</code> which contains an error value of some kind.</p>
</li>
<li>
<p>Whether or not a function can produce an error is encoded in the function's type signature by having the function return a <code>Result</code> value.</p>
</li>
<li>
<p>Like with <code>Option</code>, there is no way to forget to handle an error: You cannot access either the success value or the error value without first pattern matching on the <code>Result</code> to check which variant you have. Methods like <code>unwrap</code> make it easier to write quick-and-dirty code that doesn't do robust error handling, but means that you can always see in your source code where proper error handling is being skipped.</p>
</li>
</ul>
<h1><a class="header" href="#探索更多-6" id="探索更多-6">探索更多</a></h1>
<p>It may be helpful to compare error handling in Rust to error handling conventions that students may be familiar with from other programming languages.</p>
<h2><a class="header" href="#异常" id="异常">异常</a></h2>
<ul>
<li>
<p>Many languages use exceptions, e.g. C++, Java, Python.</p>
</li>
<li>
<p>In most languages with exceptions, whether or not a function can throw an exception is not visible as part of its type signature. This generally means that you can't tell when calling a function if it may throw an exception or not.</p>
</li>
<li>
<p>Exceptions generally unwind the call stack, propagating upward until a <code>try</code> block is reached. An error originating deep in the call stack may impact an unrelated function further up.</p>
</li>
</ul>
<h2><a class="header" href="#error-numbers" id="error-numbers">Error Numbers</a></h2>
<ul>
<li>
<p>Some languages have functions return an error number (or some other error value) separately from the successful return value of the function. Examples include C and Go.</p>
</li>
<li>
<p>Depending on the language it may be possible to forget to check the error value, in which case you may be accessing an uninitialized or otherwise invalid success value.</p>
</li>
</ul>
</details><h1><a class="header" href="#尝试运算符" id="尝试运算符">尝试运算符</a></h1>
<p>Runtime errors like connection-refused or file-not-found are handled with the <code>Result</code> type, but matching this type on every call can be cumbersome. The try-operator <code>?</code> is used to return errors to the caller. It lets you turn the common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>转换成更简单的命令</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::Read;
use std::{fs, io};

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>简化 <code>read_username</code> 函数以使用 <code>?</code>。</p>
<p>关键点：</p>
<ul>
<li><code>username</code> 变量可以是 <code>Ok(string)</code> 或 <code>Err(error)</code>。</li>
<li>可以使用 <code>fs::write</code> 调用来测试不同的场景：没有文件、空文件、包含用户名的文件。</li>
<li>Note that <code>main</code> can return a <code>Result&lt;(), E&gt;</code> as long as it implements <code>std::process::Termination</code>. In practice, this means that <code>E</code> implements <code>Debug</code>. The executable will print the <code>Err</code> variant and return a nonzero exit status on error.</li>
</ul>
</details><h1><a class="header" href="#尝试转换" id="尝试转换">尝试转换</a></h1>
<p><code>?</code> 的有效展开比前面介绍的内容略微复杂一些：</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>效果等同于</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the type returned by the function. This makes it easy to encapsulate errors into higher-level errors.</p>
<h2><a class="header" href="#示例-1" id="示例-1">示例</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::io::Read;
use std::{fmt, fs, io};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl fmt::Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;I/O error: {e}&quot;),
            Self::EmptyUsername(path) =&gt; write!(f, &quot;Found no username in {path}&quot;),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; Self {
        Self::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //std::fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>The <code>?</code> operator must return a value compatible with the return type of the function. For <code>Result</code>, it means that the error types have to be compatible. A function that returns <code>Result&lt;T, ErrorOuter&gt;</code> can only use <code>?</code> on a value of type <code>Result&lt;U, ErrorInner&gt;</code> if <code>ErrorOuter</code> and <code>ErrorInner</code> are the same type or if <code>ErrorOuter</code> implements <code>From&lt;ErrorInner&gt;</code>.</p>
<p><code>From</code> 实现的常见替代方案是 <code>Result::map_err</code>，尤其是只在一个位置进行转换时。</p>
<p>There is no compatibility requirement for <code>Option</code>. A function returning <code>Option&lt;T&gt;</code> can use the <code>?</code> operator on <code>Option&lt;U&gt;</code> for arbitrary <code>T</code> and <code>U</code> types.</p>
<p>A function that returns <code>Result</code> cannot use <code>?</code> on <code>Option</code> and vice versa. However, <code>Option::ok_or</code> converts <code>Option</code> to <code>Result</code> whereas <code>Result::ok</code> turns <code>Result</code> into <code>Option</code>.</p>
</details><h1><a class="header" href="#动态错误类型" id="动态错误类型">动态错误类型</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our own enum covering all the different possibilities. The <code>std::error::Error</code> trait makes it easy to create a trait object that can contain any error.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::fs;
use std::io::Read;

fn read_count(path: &amp;str) -&gt; Result&lt;i32, Box&lt;dyn Error&gt;&gt; {
    let mut count_str = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut count_str)?;
    let count: i32 = count_str.parse()?;
    Ok(count)
}

fn main() {
    fs::write(&quot;count.dat&quot;, &quot;1i3&quot;).unwrap();
    match read_count(&quot;count.dat&quot;) {
        Ok(count) =&gt; println!(&quot;Count: {count}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><code>read_count</code> 函数可以返回 <code>std::io::Error</code>（通过文件操作）或 <code>std::num::ParseIntError</code>（通过 <code>String::parse</code>）。</p>
<p>Boxing errors saves on code, but gives up the ability to cleanly handle different error cases differently in the program. As such it's generally not a good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a library, but it can be a good option in a program where you just want to display the error message somewhere.</p>
<p>Make sure to implement the <code>std::error::Error</code> trait when defining a custom error type so it can be boxed.</p>
</details><h1><a class="header" href="#thiserror" id="thiserror"><code>thiserror</code></a></h1>
<p>The <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> crate provides macros to help avoid boilerplate when defining error types. It provides derive macros that assist in implementing <code>From&lt;T&gt;</code>, <code>Display</code>, and the <code>Error</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io::Read;
use std::{fs, io};
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;I/O error: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>The <code>Error</code> derive macro is provided by <code>thiserror</code>, and has lots of useful attributes to help define error types in a compact way.</li>
<li>The message from <code>#[error]</code> is used to derive the <code>Display</code> trait.</li>
<li>Note that the (<code>thiserror::</code>)<code>Error</code> derive macro, while it has the effect of implementing the (<code>std::error::</code>)<code>Error</code> trait, is not the same this; traits and macros do not share a namespace.</li>
</ul>
</details><h1><a class="header" href="#anyhow" id="anyhow"><code>anyhow</code></a></h1>
<p>The <a href="https://docs.rs/anyhow/"><code>anyhow</code></a> crate provides a rich error type with support for carrying additional contextual information, which can be used to provide a semantic trace of what the program was doing leading up to the error.</p>
<p>This can be combined with the convenience macros from <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> to avoid writing out trait impls explicitly for custom error types.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::{bail, Context, Result};
use std::fs;
use std::io::Read;
use thiserror::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(EmptyUsernameError(path.to_string()));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it's again generally not a good choice for the public API of a library, but is widely used in applications.</li>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li>Functionality provided by <code>anyhow::Error</code> may be familiar to Go developers, as it provides similar behavior to the Go <code>error</code> type and <code>Result&lt;T, anyhow::Error&gt;</code> is much like a Go <code>(T, error)</code> (with the convention that only one element of the pair is meaningful).</li>
<li><code>anyhow::Context</code> is a trait implemented for the standard <code>Result</code> and <code>Option</code> types. <code>use anyhow::Context</code> is necessary to enable <code>.context()</code> and <code>.with_context()</code> on those types.</li>
</ul>
<h1><a class="header" href="#探索更多-7" id="探索更多-7">探索更多</a></h1>
<ul>
<li><code>anyhow::Error</code> has support for downcasting, much like <code>std::any::Any</code>; the specific error type stored inside can be extracted for examination if desired with <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast"><code>Error::downcast</code></a>.</li>
</ul>
</details><h1><a class="header" href="#练习使用-result-进行重写" id="练习使用-result-进行重写">练习：使用 Result 进行重写</a></h1>
<p>The following implements a very simple parser for an expression language. However, it handles errors by panicking. Rewrite it to instead use idiomatic error handling and propagate errors to a return from <code>main</code>. Feel free to use <a href="https://docs.rs/thiserror"><code>thiserror</code></a> and <a href="https://docs.rs/anyhow"><code>anyhow</code></a>.</p>
<blockquote>
<p><strong>Hint:</strong> start by fixing error handling in the <code>parse</code> function. Once that is working correctly, update <code>Tokenizer</code> to implement <code>Iterator&lt;Item=Result&lt;Token, TokenizerError&gt;&gt;</code> and handle that in the parser.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Token;

    fn next(&amp;mut self) -&gt; Option&lt;Token&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(self.collect_number(c)),
            'a'..='z' =&gt; Some(self.collect_identifier(c)),
            '+' =&gt; Some(Token::Operator(Op::Add)),
            '-' =&gt; Some(Token::Operator(Op::Sub)),
            _ =&gt; panic!(&quot;Unexpected character {c}&quot;),
        }
    }
}

fn parse(input: &amp;str) -&gt; Expression {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(tokens: &amp;mut Tokenizer&lt;'a&gt;) -&gt; Expression {
        let Some(tok) = tokens.next() else {
            panic!(&quot;Unexpected end of input&quot;);
        };
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse().expect(&quot;Invalid 32-bit integer&quot;);
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; panic!(&quot;Unexpected token {tok:?}&quot;),
        };
        // Look ahead to parse a binary operation if present.
        match tokens.next() {
            None =&gt; expr,
            Some(Token::Operator(op)) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)),
            ),
            Some(tok) =&gt; panic!(&quot;Unexpected token {tok:?}&quot;),
        }
    }

    parse_expr(&amp;mut tokens)
}

fn main() {
    let expr = parse(&quot;10+foo+20-30&quot;);
    println!(&quot;{expr:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#解答-17" id="解答-17">解答</a></h1>
<!-- compile_fail because `mdbook test` does not allow use of `thiserror` -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use thiserror::Error;
use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

#[derive(Debug, Error)]
enum TokenizerError {
    #[error(&quot;Unexpected character '{0}' in input&quot;)]
    UnexpectedCharacter(char),
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Result&lt;Token, TokenizerError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Token, TokenizerError&gt;&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(Ok(self.collect_number(c))),
            'a'..='z' | '_' =&gt; Some(Ok(self.collect_identifier(c))),
            '+' =&gt; Some(Ok(Token::Operator(Op::Add))),
            '-' =&gt; Some(Ok(Token::Operator(Op::Sub))),
            _ =&gt; Some(Err(TokenizerError::UnexpectedCharacter(c))),
        }
    }
}

#[derive(Debug, Error)]
enum ParserError {
    #[error(&quot;Tokenizer error: {0}&quot;)]
    TokenizerError(#[from] TokenizerError),
    #[error(&quot;Unexpected end of input&quot;)]
    UnexpectedEOF,
    #[error(&quot;Unexpected token {0:?}&quot;)]
    UnexpectedToken(Token),
    #[error(&quot;Invalid number&quot;)]
    InvalidNumber(#[from] std::num::ParseIntError),
}

fn parse(input: &amp;str) -&gt; Result&lt;Expression, ParserError&gt; {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(
        tokens: &amp;mut Tokenizer&lt;'a&gt;,
    ) -&gt; Result&lt;Expression, ParserError&gt; {
        let tok = tokens.next().ok_or(ParserError::UnexpectedEOF)??;
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse()?;
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        };
        // Look ahead to parse a binary operation if present.
        Ok(match tokens.next() {
            None =&gt; expr,
            Some(Ok(Token::Operator(op))) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)?),
            ),
            Some(Err(e)) =&gt; return Err(e.into()),
            Some(Ok(tok)) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        })
    }

    parse_expr(&amp;mut tokens)
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let expr = parse(&quot;10+foo+20-30&quot;)?;
    println!(&quot;{expr:?}&quot;);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#不安全-rust" id="不安全-rust">不安全 Rust</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#不安全-rust-1" id="不安全-rust-1">不安全 Rust</a></h1>
<p>Rust 语言包含两个部分：</p>
<ul>
<li>**安全 Rust：**内存安全，没有潜在的未定义行为。</li>
<li>**不安全 Rust：**如果违反了前提条件，可能会触发未定义的行为。</li>
</ul>
<p>We saw mostly safe Rust in this course, but it's important to know what Unsafe Rust is.</p>
<p>不安全的代码通常内容很少而且与其他代码隔离， 其正确性也应得到仔细记录。这类代码通常封装在安全的抽象层中。</p>
<p>不安全 Rust 提供了五种新功能：</p>
<ul>
<li>解引用原始指针。</li>
<li>访问或修改可变的静态变量。</li>
<li>访问 <code>union</code> 字段。</li>
<li>调用 <code>unsafe</code> 函数，包括 <code>extern</code> 函数。</li>
<li>实现 <code>unsafe</code> trait。</li>
</ul>
<p>下面，我们将简要介绍这些不安全功能。如需了解完整详情，请参阅 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">《Rust 手册》第 19.1 章</a> 和 <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>。</p>
<details>
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have turned off some compiler safety features and have to write correct code by themselves. It means the compiler no longer enforces Rust's memory-safety rules.</p>
</details><h1><a class="header" href="#解引用裸指针" id="解引用裸指针">解引用裸指针</a></h1>
<p>创建指针是安全的操作，但解引用指针需要使用 <code>unsafe</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from(&quot;careful!&quot;);

    let r1 = &amp;raw mut s;
    let r2 = r1 as *const String;

    // SAFETY: r1 and r2 were obtained from references and so are guaranteed to
    // be non-null and properly aligned, the objects underlying the references
    // from which they were obtained are live throughout the whole unsafe
    // block, and they are not accessed either through the references or
    // concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = String::from(&quot;uhoh&quot;);
        println!(&quot;r2 is: {}&quot;, *r2);
    }

    // NOT SAFE. DO NOT DO THIS.
    /*
    let r3: &amp;String = unsafe { &amp;*r1 };
    drop(s);
    println!(&quot;r3 is: {}&quot;, *r3);
    */
}
</code></pre></pre>
<details>
<p>我们建议（而且 Android Rust 样式指南要求）为每个 <code>unsafe</code> 代码块编写一条注释， 说明该代码块中的代码如何满足其所执行的不安全操作的 安全要求。</p>
<p>对于指针解除引用，这意味着指针必须为 <a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>，即：</p>
<ul>
<li>指针必须为非 null。</li>
<li>指针必须是 <em>dereferenceable</em>（在单个已分配对象的边界内）。</li>
<li>对象不得已取消分配。</li>
<li>不得并发访问相同位置。</li>
<li>如果通过转换引用类型来获取指针，则底层对象必须处于活跃状态， 而且不得使用任何引用来访问内存。</li>
</ul>
<p>在大多数情况下，指针还必须正确对齐。</p>
<p>The &quot;NOT SAFE&quot; section gives an example of a common kind of UB bug: <code>*r1</code> has the <code>'static</code> lifetime, so <code>r3</code> has type <code>&amp;'static String</code>, and thus outlives <code>s</code>. Creating a reference from a pointer requires <em>great care</em>.</p>
</details><h1><a class="header" href="#可变的静态变量" id="可变的静态变量">可变的静态变量</a></h1>
<p>读取不可变的静态变量是安全的操作：</p>
<pre><pre class="playground"><code class="language-rust editable">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {HELLO_WORLD}&quot;);
}
</code></pre></pre>
<p>但是，读取和写入可变的静态变量是不安全的，因为这可能会 造成数据争用：</p>
<pre><pre class="playground"><code class="language-rust editable">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_counter(42);

    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        println!(&quot;COUNTER: {COUNTER}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>此处的程序是安全的，因为它是单线程的。不过，Rust 编译器比较保守，会做出最坏的假设。请尝试移除 <code>unsafe</code>，看看编译器如何解释从多个线程中修改静态变量是一种未定义的行为。</p>
</li>
<li>
<p>通常，我们不建议使用可变的静态变量，但在某些情况下，在低层级 <code>no_std</code> 代码中可能需要这样做， 例如实现堆分配器或使用某些 C API。</p>
</li>
</ul>
</details><h1><a class="header" href="#联合体" id="联合体">联合体</a></h1>
<p>联合体与枚举类似，但您需要自行跟踪活跃字段：</p>
<pre><pre class="playground"><code class="language-rust editable">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b }); // Undefined behavior!
}
</code></pre></pre>
<details>
<p>在 Rust 中很少需要用到联合体，因为您通常可以使用枚举。联合体只是偶尔用于 与 C 库 API 进行交互。</p>
<p>如果您只是想将字节重新解释为其他类型，则可能需要使用 <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> 或 安全的封装容器，例如 <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crate。</p>
</details><h1><a class="header" href="#unsafe-函数" id="unsafe-函数">Unsafe 函数</a></h1>
<h2><a class="header" href="#调用-unsafe-函数" id="调用-unsafe-函数">调用 Unsafe 函数</a></h2>
<p>如果函数或方法具有额外的前提条件，您必须遵守这些前提条件来避免未定义的行为， 则可以将该函数或方法标记为 <code>unsafe</code>：</p>
<pre><pre class="playground"><code class="language-rust editable">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    let emojis = &quot;🗻∈🌏&quot;;

    // SAFETY: The indices are in the correct order, within the bounds of the
    // string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(7..11));
    }

    println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // SAFETY: `abs` doesn't deal with pointers and doesn't have any safety
    // requirements.
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!(&quot;emoji: {}&quot;, unsafe { emojis.get_unchecked(0..3) });
    // println!(&quot;char count: {}&quot;, count_chars(unsafe {
    // emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().count()
}
</code></pre></pre>
<h2><a class="header" href="#编写-unsafe-函数" id="编写-unsafe-函数">编写 Unsafe 函数</a></h2>
<p>如果您自己编写的函数需要满足特定条件以避免未定义的行为， 您可以将这些函数标记为 <code>unsafe</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // SAFETY: ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<h2><a class="header" href="#调用-unsafe-函数-1" id="调用-unsafe-函数-1">调用 Unsafe 函数</a></h2>
<p><code>get_unchecked</code>, like most <code>_unchecked</code> functions, is unsafe, because it can create UB if the range is incorrect. <code>abs</code> is unsafe for a different reason: it is an external function (FFI). Calling external functions is usually only a problem when those functions do things with pointers which might violate Rust's memory model, but in general any C function might have undefined behaviour under any arbitrary circumstances.</p>
<p>本例中的“C”是 ABI；<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">也可以使用其他 ABI</a>。</p>
<h2><a class="header" href="#编写-unsafe-函数-1" id="编写-unsafe-函数-1">编写 Unsafe 函数</a></h2>
<p>We wouldn't actually use pointers for a <code>swap</code> function - it can be done safely with references.</p>
<p>Note that unsafe code is allowed within an unsafe function without an <code>unsafe</code> block. We can prohibit this with <code>#[deny(unsafe_op_in_unsafe_fn)]</code>. Try adding it and see what happens. This will likely change in a future Rust edition.</p>
</details><h1><a class="header" href="#实现-unsafe-trait-1" id="实现-unsafe-trait-1">实现 Unsafe Trait</a></h1>
<p>与函数一样，如果您在实现某个 trait 时必须保证特定条件来避免未定义的行为， 您也可以将该 trait 标记为 <code>unsafe</code>。</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks <a href="https://docs.rs/zerocopy/latest/zerocopy/trait.IntoBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::{mem, slice};

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait IntoBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        let len = mem::size_of_val(self);
        unsafe { slice::from_raw_parts((&amp;raw const self).cast::&lt;u8&gt;(), len) }
    }
}

// SAFETY: `u32` has a defined representation and no padding.
unsafe impl IntoBytes for u32 {}
</code></pre></pre>
<details>
<p>在 Rustdoc 中有关 trait 的章节下，有一个标题为 <code># 安全</code> 的部分介绍了 安全实现 trait 的要求。</p>
<p>The actual safety section for <code>IntoBytes</code> is rather longer and more complicated.</p>
<p>内置的 <code>Send</code> 和 <code>Sync</code> trait 都是不安全的。</p>
</details><h1><a class="header" href="#安全-ffi-封装容器" id="安全-ffi-封装容器">安全 FFI 封装容器</a></h1>
<p>Rust 为通过 <em>外部函数接口</em> (FFI) 调用函数提供了出色的支持。我们将使用它为 <code>libc</code> 函数构建一个安全封装容器，用于从 C 代码中读取目录中的文件名称。</p>
<p>建议您参考以下手册页面：</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>您还需要浏览<a href="https://doc.rust-lang.org/std/ffi/">“std::ffi”</a>模块。在下方，您会发现完成这个练习所需的多种字符串类型：</p>
<table><thead><tr><th>类型</th><th>编码</th><th>使用</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html">“str”</a>和<a href="https://doc.rust-lang.org/std/string/struct.String.html">“String”</a></td><td>UTF-8</td><td>用 Rust 进行文本处理</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html">“CStr”</a>和<a href="https://doc.rust-lang.org/std/ffi/struct.CString.html">“CString”</a></td><td>以空字符结尾</td><td>与 C 函数通信</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">“OsStr”</a>和<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">“OsString”</a></td><td>特定于操作系统</td><td>与操作系统通信</td></tr>
</tbody></table>
<p>您将在以下所有类型之间进行转换：</p>
<ul>
<li>将 <code>&amp;str</code> 转换为 <code>CString</code>：您需要为尾随 <code>\0</code> 字符分配空格，</li>
<li>将 <code>CString</code> 转换为 <code>\*const i8</code> ：您需要一个指针来调用 C 函数，</li>
<li>将 <code>\*const i8</code> 转换为 <code>&amp;CStr</code> ：您需要一些能够找到尾随 <code>\0</code> 字符的内容，</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for &quot;some unknown data&quot;,</li>
<li>将 <code>&amp;\[u8\]</code> 转换为 <code>&amp;OsStr</code> ：<code>&amp;OsStr</code> 是向 <code>OsString</code> 迈进的一步，请使用<a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a>来创建它，</li>
<li>将“&amp;OsStr”转换为“OsString”：您需要克隆“&amp;OsStr”中的数据，以便能够返回它并再次调用“readdir”。</li>
</ul>
<p><a href="https://doc.rust-lang.org/nomicon/ffi.html">秘典</a> 中也有一个关于 FFI 的非常实用的章节。</p>
<p>将以下代码复制到 <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>，并填入缺少的函数和方法：</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    unsafe extern &quot;C&quot; {
        pub unsafe fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub unsafe fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#解答-18" id="解答-18">解答</a></h1>
<pre><pre class="playground"><code class="language-rust editable">mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    unsafe extern &quot;C&quot; {
        pub unsafe fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub unsafe fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        let path =
            CString::new(path).map_err(|err| format!(&quot;Invalid path: {err}&quot;))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!(&quot;Could not open {path:?}&quot;))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        // SAFETY: self.dir is never NULL.
        if unsafe { ffi::closedir(self.dir) } != 0 {
            panic!(&quot;Could not close {:?}&quot;, self.path);
        }
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new(&quot;no-such-directory&quot;);
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join(&quot;foo.txt&quot;), &quot;The Foo Diaries\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;bar.png&quot;), &quot;&lt;PNG&gt;\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;crab.rs&quot;), &quot;//! Crab\n&quot;)?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;, &quot;bar.png&quot;, &quot;crab.rs&quot;, &quot;foo.txt&quot;]);
        Ok(())
    }
}
</code></pre></pre>
<h1><a class="header" href="#欢迎来到android-中的rust" id="欢迎来到android-中的rust">欢迎来到Android 中的Rust</a></h1>
<p>Rust is supported for system software on Android. This means that you can write new services, libraries, drivers or even firmware in Rust (or improve existing code as needed).</p>
<details>
<p>鉴于 Android 中越来越多地使用 Rust，演讲者可能会提到以下任何一项：</p>
<ul>
<li>
<p>Service example: <a href="https://security.googleblog.com/2022/07/dns-over-http3-in-android.html">DNS over HTTP</a>.</p>
</li>
<li>
<p>Libraries: <a href="https://crosvm.dev/book/appendix/rutabaga_gfx.html">Rutabaga Virtual Graphics Interface</a>.</p>
</li>
<li>
<p>Kernel Drivers: <a href="https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/">Binder</a>.</p>
</li>
<li>
<p>Firmware: <a href="https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html">pKVM firmware</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#设置" id="设置">设置</a></h1>
<p>We will be using a Cuttlefish Android Virtual Device to test our code. Make sure you have access to one or create a new one with:</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-trunk_staging-userdebug
acloud create
</code></pre>
<p>更多细节请参考 <a href="https://source.android.com/docs/setup/start">Android Developer Codelab</a>.</p>
<p>The code on the following pages can be found in the <a href="https://github.com/google/comprehensive-rust/tree/main/src/android"><code>src/android/</code> directory</a> of the course material. Please <code>git clone</code> the repository to follow along.</p>
<details>
<p>关键点：</p>
<ul>
<li>
<p>Cuttlefish is a reference Android device designed to work on generic Linux desktops. MacOS support is also planned.</p>
</li>
<li>
<p>Cuttlefish 系统映像会保持媲美真实设备的高保真度，是运行许多 Rust 用例的理想模拟器。</p>
</li>
</ul>
</details>
<h1><a class="header" href="#构建规则" id="构建规则">构建规则</a></h1>
<p>Android 构建系统（Soong）通过一系列模块来支持Rust：</p>
<table><thead><tr><th>Module Type</th><th>描述</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>Produces a Rust binary.</td></tr>
<tr><td><code>rust_library</code></td><td>生成一个 Rust 库，并提供 <code>rlib</code> 和 <code>dylib</code> 两种变体。</td></tr>
<tr><td><code>rust_ffi</code></td><td>生成一个可由 <code>cc</code> 模块使用的 Rust C 库，并提供静态和共享两种变体。</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>生成“proc-macro”Rust 库。这些宏与编译器插件类似。</td></tr>
<tr><td><code>rust_test</code></td><td>生成使用标准 Rust 测试框架的 Rust 测试二进制文件。</td></tr>
<tr><td><code>rust_fuzz</code></td><td>生成使用 <code>libfuzzer</code> 的 Rust 模糊测试二进制文件。</td></tr>
<tr><td><code>rust_protobuf</code></td><td>生成源代码并生成为特定 protobuf 提供接口的 Rust 库。</td></tr>
<tr><td><code>rust_bindgen</code></td><td>生成源代码并生成包含 Rust 绑定到 C 库的 Rust 库。</td></tr>
</tbody></table>
<p>下面我们来看看 <code>rust_binary</code> 和 <code>rust_library</code>。</p>
<details>
<p>演讲者可能会提及其他内容：</p>
<ul>
<li>
<p>Cargo 未针对多语言代码库进行优化，并且从互联网下载软件包。</p>
</li>
<li>
<p>For compliance and performance, Android must have crates in-tree. It must also interop with C/C++/Java code. Soong fills that gap.</p>
</li>
<li>
<p>Soong has many similarities to <a href="https://bazel.build/">Bazel</a>, which is the open-source variant of Blaze (used in google3).</p>
</li>
<li>
<p>趣味小知识：《星际迷航》中的数据是 Soong 类型的 Android。</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust-二进制文件" id="rust-二进制文件">Rust 二进制文件</a></h1>
<p>让我们从一个简单的应用程序开始。在 AOSP 签出的根目录下，创建以下文件：</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust&quot;,
    crate_name: &quot;hello_rust&quot;,
    srcs: [&quot;src/main.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;Hello from Rust!&quot;);
}
</code></pre></pre>
<p>你现在可以构建、推送和运行二进制文件：</p>
<pre><code class="language-shell">m hello_rust
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<h1><a class="header" href="#rust-库" id="rust-库">Rust 库</a></h1>
<p>您可以使用 <code>rust_library</code> 为 Android 创建一个新的 Rust 库。</p>
<p>在这里，我们声明了对两个库的依赖：</p>
<ul>
<li><code>libgreeting</code>, 我们在下面进行了定义，</li>
<li><code>libtextwrap</code>, 一个已经在 <a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a> 中提供的 crate。</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_with_dep&quot;,
    crate_name: &quot;hello_rust_with_dep&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libgreetings&quot;,
        &quot;libtextwrap&quot;,
    ],
    prefer_rlib: true, // Need this to avoid dynamic link error.
}

rust_library {
    name: &quot;libgreetings&quot;,
    crate_name: &quot;greetings&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;{}&quot;, fill(&amp;greeting(&quot;Bob&quot;), 24));
}
</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}, it is very nice to meet you!&quot;)
}
</code></pre>
<p>您可以像之前一样构建、推送和运行二进制文件：</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<h1><a class="header" href="#aidl" id="aidl">AIDL</a></h1>
<p>Rust 支持 <a href="https://developer.android.com/guide/components/aidl">Android 接口定义语言 (AIDL)</a>：</p>
<ul>
<li>Rust 代码可以调用现有的 AIDL 服务器，</li>
<li>您可以在 Rust 中创建新的 AIDL 服务器。</li>
</ul>
<h1><a class="header" href="#-birthday-service-interface-" id="-birthday-service-interface-">/** Birthday service interface. */</a></h1>
<p>To illustrate how to use Rust with Binder, we're going to walk through the process of creating a Binder interface. We're then going to both implement the described service and write client code that talks to that service.</p>
<h1><a class="header" href="#aidl-接口" id="aidl-接口">AIDL 接口</a></h1>
<p>您可以使用 AIDL 接口声明您的服务的 API：</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: &quot;com.example.birthdayservice&quot;,
    srcs: [&quot;com/example/birthdayservice/*.aidl&quot;],
    unstable: true,
    backend: {
        rust: { // Rust is not enabled by default
            enabled: true,
        },
    },
}
</code></pre>
<details>
<ul>
<li>Note that the directory structure under the <code>aidl/</code> directory needs to match the package name used in the AIDL file, i.e. the package is <code>com.example.birthdayservice</code> and the file is at <code>aidl/com/example/IBirthdayService.aidl</code>.</li>
</ul>
</details>
<h1><a class="header" href="#generated-service-api" id="generated-service-api">Generated Service API</a></h1>
<p>Binder generates a trait corresponding to the interface definition. trait to talk to the service.</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>Generated trait</em>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt;;
}
</code></pre>
<p>Your service will need to implement this trait, and your client will use this trait to talk to the service.</p>
<details>
<ul>
<li>The generated bindings can be found at <code>out/soong/.intermediates/&lt;path to module&gt;/</code>.</li>
<li>Point out how the generated function signature, specifically the argument and return types, correspond the interface definition.
<ul>
<li><code>String</code> for an argument results in a different Rust type than <code>String</code> as a return type.</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#服务实现" id="服务实现">服务实现</a></h1>
<p>我们现在可以实现AIDL服务：</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// The `IBirthdayService` implementation.
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!(&quot;Happy Birthday {name}, congratulations with the {years} years!&quot;))
    }
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libbirthdayservice&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    crate_name: &quot;birthdayservice&quot;,
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
}
</code></pre>
<details>
<ul>
<li>Point out the path to the generated <code>IBirthdayService</code> trait, and explain why each of the segments is necessary.</li>
<li>TODO: What does the <code>binder::Interface</code> trait do? Are there methods to override? Where source?</li>
</ul>
</details>
<h1><a class="header" href="#aidl-服务器" id="aidl-服务器">AIDL 服务器</a></h1>
<p>最后，我们可以创建一个暴露服务的服务器：</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! Birthday service.
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Entry point for birthday service.
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect(&quot;Failed to register service&quot;);
    binder::ProcessState::join_thread_pool();
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_server&quot;,
    crate_name: &quot;birthday_server&quot;,
    srcs: [&quot;src/server.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
        &quot;libbirthdayservice&quot;,
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<details>
<p>The process for taking a user-defined service implementation (in this case the <code>BirthdayService</code> type, which implements the <code>IBirthdayService</code>) and starting it as a Binder service has multiple steps, and may appear more complicated than students are used to if they've used Binder from C++ or another language. Explain to students why each step is necessary.</p>
<ol>
<li>Create an instance of your service type (<code>BirthdayService</code>).</li>
<li>Wrap the service object in corresponding <code>Bn*</code> type (<code>BnBirthdayService</code> in this case). This type is generated by Binder and provides the common Binder functionality that would be provided by the <code>BnBinder</code> base class in C++. We don't have inheritance in Rust, so instead we use composition, putting our <code>BirthdayService</code> within the generated <code>BnBinderService</code>.</li>
<li>Call <code>add_service</code>, giving it a service identifier and your service object (the <code>BnBirthdayService</code> object in the example).</li>
<li>Call <code>join_thread_pool</code> to add the current thread to Binder's thread pool and start listening for connections.</li>
</ol>
</details>
<h1><a class="header" href="#部署" id="部署">部署</a></h1>
<p>我们现在可以构建、推送和启动服务：</p>
<pre><code class="language-shell">m birthday_server
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_server&quot; /data/local/tmp
adb root
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>在另一个终端中，检查该服务是否正在运行：</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>您还可以使用 <code>service call</code> 命令调用该服务：</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<h1><a class="header" href="#aidl-客户端" id="aidl-客户端">AIDL 客户端</a></h1>
<p>最后，我们可以为我们的新服务创建一个 Rust 客户端。</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Call the birthday service.
fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let name = std::env::args().nth(1).unwrap_or_else(|| String::from(&quot;Bob&quot;));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = binder::get_interface::&lt;dyn IBirthdayService&gt;(SERVICE_IDENTIFIER)
        .map_err(|_| &quot;Failed to connect to BirthdayService&quot;)?;

    // Call the service.
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!(&quot;{msg}&quot;);
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_client&quot;,
    crate_name: &quot;birthday_client&quot;,
    srcs: [&quot;src/client.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<p>请注意，客户端不依赖于 <code>libbirthdayservice</code>。</p>
<p>在您的设备上构建、推送并运行客户端：</p>
<pre><code class="language-shell">m birthday_client
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_client&quot; /data/local/tmp
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<details>
<ul>
<li><code>Strong&lt;dyn IBirthdayService&gt;</code> is the trait object representing the service that the client has connected to.
<ul>
<li><code>Strong</code> is a custom smart pointer type for Binder. It handles both an in-process ref count for the service trait object, and the global Binder ref count that tracks how many processes have a reference to the object.</li>
<li>Note that the trait object that the client uses to talk to the service uses the exact same trait that the server implements. For a given Binder interface, there is a single Rust trait generated that both client and server use.</li>
</ul>
</li>
<li>Use the same service identifier used when registering the service. This should ideally be defined in a common crate that both the client and server can depend on.</li>
</ul>
</details>
<h1><a class="header" href="#更改-api" id="更改-api">更改 API</a></h1>
<p>让我们扩展API以提供更多功能：我们希望允许客户端指定生日贺卡的行列表：</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<p>This results in an updated trait definition for <code>IBirthdayService</code>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt;;
}
</code></pre>
<details>
<ul>
<li>Note how the <code>String[]</code> in the AIDL definition is translated as a <code>&amp;[String]</code> in Rust, i.e. that idiomatic Rust types are used in the generated bindings wherever possible:
<ul>
<li><code>in</code> array arguments are translated to slices.</li>
<li><code>out</code> and <code>inout</code> args are translated to <code>&amp;mut Vec&lt;T&gt;</code>.</li>
<li>Return values are translated to returning a <code>Vec&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#updating-client-and-service" id="updating-client-and-service">Updating Client and Service</a></h1>
<p>Update the client and server code to account for the new API.</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt; {
        let mut msg = format!(
            &quot;Happy Birthday {name}, congratulations with the {years} years!&quot;,
        );

        for line in text {
            msg.push('\n');
            msg.push_str(line);
        }

        Ok(msg)
    }
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">let msg = service.wishHappyBirthday(
    &amp;name,
    years,
    &amp;[
        String::from(&quot;Habby birfday to yuuuuu&quot;),
        String::from(&quot;And also: many more&quot;),
    ],
)?;
</code></pre>
<details>
<ul>
<li>TODO: Move code snippets into project files where they'll actually be built?</li>
</ul>
</details>
<h1><a class="header" href="#working-with-aidl-types" id="working-with-aidl-types">Working With AIDL Types</a></h1>
<p>AIDL types translate into the appropriate idiomatic Rust type:</p>
<ul>
<li>Primitive types map (mostly) to idiomatic Rust types.</li>
<li>Collection types like slices, <code>Vec</code>s and string types are supported.</li>
<li>References to AIDL objects and file handles can be sent between clients and services.</li>
<li>File handles and parcelables are fully supported.</li>
</ul>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>Primitive types map (mostly) idiomatically:</p>
<table><thead><tr><th>AIDL Type</th><th>Rust Type</th><th>Note</th></tr></thead><tbody>
<tr><td><code>boolean</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>byte</code></td><td><code>i8</code></td><td>Note that bytes are signed.</td></tr>
<tr><td><code>char</code></td><td><code>u16</code></td><td>Note the usage of <code>u16</code>, NOT <code>u32</code>.</td></tr>
<tr><td><code>int</code></td><td><code>i32</code></td><td></td></tr>
<tr><td><code>long</code></td><td><code>i64</code></td><td></td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td><td></td></tr>
<tr><td><code>double</code></td><td><code>f64</code></td><td></td></tr>
<tr><td>String</td><td>String</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#数组arrays-1" id="数组arrays-1">数组（Arrays）</a></h1>
<p>The array types (<code>T[]</code>, <code>byte[]</code>, and <code>List&lt;T&gt;</code>) get translated to the appropriate Rust array type depending on how they are used in the function signature:</p>
<table><thead><tr><th>Position</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><code>in</code> argument</td><td><code>&amp;[T]</code></td></tr>
<tr><td><code>out</code>/<code>inout</code> argument</td><td><code>&amp;mut Vec&lt;T&gt;</code></td></tr>
<tr><td>Return</td><td><code>Vec&lt;T&gt;</code></td></tr>
</tbody></table>
<details>
<ul>
<li>In Android 13 or higher, fixed-size arrays are supported, i.e. <code>T[N]</code> becomes <code>[T; N]</code>. Fixed-size arrays can have multiple dimensions (e.g. <code>int[3][4]</code>). In the Java backend, fixed-size arrays are represented as array types.</li>
<li>Arrays in parcelable fields always get translated to <code>Vec&lt;T&gt;</code>.</li>
</ul>
</details>
<h1><a class="header" href="#特征对象" id="特征对象">特征对象</a></h1>
<p>AIDL objects can be sent either as a concrete AIDL type or as the type-erased <code>IBinder</code> interface:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

interface IBirthdayInfoProvider {
    String name();
    int years();
}
</code></pre>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">import com.example.birthdayservice.IBirthdayInfoProvider;

interface IBirthdayService {
    /** The same thing, but using a binder object. */
    String wishWithProvider(IBirthdayInfoProvider provider);

    /** The same thing, but using `IBinder`. */
    String wishWithErasedProvider(IBinder provider);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">/// Rust struct implementing the `IBirthdayInfoProvider` interface.
struct InfoProvider {
    name: String,
    age: u8,
}

impl binder::Interface for InfoProvider {}

impl IBirthdayInfoProvider for InfoProvider {
    fn name(&amp;self) -&gt; binder::Result&lt;String&gt; {
        Ok(self.name.clone())
    }

    fn years(&amp;self) -&gt; binder::Result&lt;i32&gt; {
        Ok(self.age as i32)
    }
}

fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    // Create a binder object for the `IBirthdayInfoProvider` interface.
    let provider = BnBirthdayInfoProvider::new_binder(
        InfoProvider { name: name.clone(), age: years as u8 },
        BinderFeatures::default(),
    );

    // Send the binder object to the service.
    service.wishWithProvider(&amp;provider)?;

    // Perform the same operation but passing the provider as an `SpIBinder`.
    service.wishWithErasedProvider(&amp;provider.as_binder())?;
}
</code></pre>
<details>
<ul>
<li>Note the usage of <code>BnBirthdayInfoProvider</code>. This serves the same purpose as <code>BnBirthdayService</code> that we saw previously.</li>
</ul>
</details>
<h1><a class="header" href="#变量-1" id="变量-1">变量</a></h1>
<p>Binder for Rust supports sending parcelables directly:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

parcelable BirthdayInfo {
    String name;
    int years;
}
</code></pre>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">import com.example.birthdayservice.BirthdayInfo;

interface IBirthdayService {
    /** The same thing, but with a parcelable. */
    String wishWithInfo(in BirthdayInfo info);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    let info = BirthdayInfo { name: &quot;Alice&quot;.into(), years: 123 };
    service.wishWithInfo(&amp;info)?;
}
</code></pre>
<h1><a class="header" href="#sending-files" id="sending-files">Sending Files</a></h1>
<p>Files can be sent between Binder clients/servers using the <code>ParcelFileDescriptor</code> type:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">interface IBirthdayService {
    /** The same thing, but loads info from a file. */
    String wishFromFile(in ParcelFileDescriptor infoFile);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    // Open a file and put the birthday info in it.
    let mut file = File::create(&quot;/data/local/tmp/birthday.info&quot;).unwrap();
    writeln!(file, &quot;{name}&quot;)?;
    writeln!(file, &quot;{years}&quot;)?;

    // Create a `ParcelFileDescriptor` from the file and send it.
    let file = ParcelFileDescriptor::new(file);
    service.wishFromFile(&amp;file)?;
}
</code></pre>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishFromFile(
        &amp;self,
        info_file: &amp;ParcelFileDescriptor,
    ) -&gt; binder::Result&lt;String&gt; {
        // Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps
        // an `OwnedFd`, which can be cloned and then used to create a `File`
        // object.
        let mut info_file = info_file
            .as_ref()
            .try_clone()
            .map(File::from)
            .expect(&quot;Invalid file handle&quot;);

        let mut contents = String::new();
        info_file.read_to_string(&amp;mut contents).unwrap();

        let mut lines = contents.lines();
        let name = lines.next().unwrap();
        let years: i32 = lines.next().unwrap().parse().unwrap();

        Ok(format!(&quot;Happy Birthday {name}, congratulations with the {years} years!&quot;))
    }
}
</code></pre>
<details>
<ul>
<li><code>ParcelFileDescriptor</code> wraps an <code>OwnedFd</code>, and so can be created from a <code>File</code> (or any other type that wraps an <code>OwnedFd</code>), and can be used to create a new <code>File</code> handle on the other side.</li>
<li>Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and UNIX sockets.</li>
</ul>
</details>
<h1><a class="header" href="#testing-in-android" id="testing-in-android">Testing in Android</a></h1>
<p>Building on <a href="android/../testing.html">Testing</a>, we will now look at how unit tests work in AOSP. Use the <code>rust_test</code> module for your unit tests:</p>
<p><em>testing/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libleftpad&quot;,
    crate_name: &quot;leftpad&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}

rust_test {
    name: &quot;libleftpad_test&quot;,
    crate_name: &quot;leftpad_test&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    host_supported: true,
    test_suites: [&quot;general-tests&quot;],
}
</code></pre>
<p><em>testing/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Left-padding library.

/// Left-pad `s` to `width`.
pub fn leftpad(s: &amp;str, width: usize) -&gt; String {
    format!(&quot;{s:&gt;width$}&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn short_string() {
        assert_eq!(leftpad(&quot;foo&quot;, 5), &quot;  foo&quot;);
    }

    #[test]
    fn long_string() {
        assert_eq!(leftpad(&quot;foobar&quot;, 6), &quot;foobar&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can now run the test with</p>
<pre><code class="language-shell">atest --host libleftpad_test
</code></pre>
<p>The output looks like this:</p>
<pre><code class="language-text">INFO: Elapsed time: 2.666s, Critical Path: 2.40s
INFO: 3 processes: 2 internal, 1 linux-sandbox.
INFO: Build completed successfully, 3 total actions
//comprehensive-rust-android/testing:libleftpad_test_host            PASSED in 2.3s
    PASSED  libleftpad_test.tests::long_string (0.0s)
    PASSED  libleftpad_test.tests::short_string (0.0s)
Test cases: finished with 2 passing and 0 failing out of 2 test cases
</code></pre>
<p>Notice how you only mention the root of the library crate. Tests are found recursively in nested modules.</p>
<h1><a class="header" href="#googletest" id="googletest">GoogleTest</a></h1>
<p>The <a href="https://docs.rs/googletest/">GoogleTest</a> crate allows for flexible test assertions using <em>matchers</em>:</p>
<pre><code class="language-rust ignore">use googletest::prelude::*;

#[googletest::test]
fn test_elements_are() {
    let value = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
    expect_that!(value, elements_are!(eq(&amp;&quot;foo&quot;), lt(&amp;&quot;xyz&quot;), starts_with(&quot;b&quot;)));
}
</code></pre>
<p>如果我们将最后一个元素更改为 <code>&quot;!&quot;</code>，测试将失败，并会提供详细的错误消息来指出错误的位置：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">---- test_elements_are stdout ----
Value of: value
Expected: has elements:
  0. is equal to &quot;foo&quot;
  1. is less than &quot;xyz&quot;
  2. starts with prefix &quot;!&quot;
Actual: [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;],
  where element #2 is &quot;baz&quot;, which does not start with &quot;!&quot;
  at src/testing/googletest.rs:6:5
Error: See failure output above
</code></pre>
<details>
<ul>
<li>
<p>GoogleTest 不是 Rust Playground 的一部分，因此您需要在本地环境中运行此示例。使用 <code>cargo add googletest</code> 快速将其添加到现有 Cargo 项目中。</p>
</li>
<li>
<p><code>use googletest::prelude::*;</code> 行会导入一些 <a href="https://docs.rs/googletest/latest/googletest/prelude/index.html">常用的宏和类型</a>。</p>
</li>
<li>
<p>This just scratches the surface, there are many builtin matchers. Consider going through the first chapter of <a href="https://rust-exercises.com/advanced-testing/">&quot;Advanced testing for Rust applications&quot;</a>, a self-guided Rust course: it provides a guided introduction to the library, with exercises to help you get comfortable with <code>googletest</code> macros, its matchers and its overall philosophy.</p>
</li>
<li>
<p>A particularly nice feature is that mismatches in multi-line strings are shown as a diff:</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_multiline_string_diff() {
    let haiku = &quot;Memory safety found,\n\
                 Rust's strong typing guides the way,\n\
                 Secure code you'll write.&quot;;
    assert_that!(
        haiku,
        eq(&quot;Memory safety found,\n\
            Rust's silly humor guides the way,\n\
            Secure code you'll write.&quot;)
    );
}
</code></pre>
<p>显示用颜色标识的差异（此处未显示颜色）：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">    Value of: haiku
Expected: is equal to &quot;Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write.&quot;
Actual: &quot;Memory safety found,\nRust's strong typing guides the way,\nSecure code you'll write.&quot;,
  which isn't equal to &quot;Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write.&quot;
Difference(-actual / +expected):
 Memory safety found,
-Rust's strong typing guides the way,
+Rust's silly humor guides the way,
 Secure code you'll write.
  at src/testing/googletest.rs:17:5
</code></pre>
<ul>
<li>crate 是 <a href="https://google.github.io/googletest/">适用于 C++ 的 GoogleTest</a> 的 Rust 移植版。</li>
</ul>
</details><h1><a class="header" href="#模拟" id="模拟">模拟</a></h1>
<p>对于模拟，<a href="https://docs.rs/mockall/">Mockall</a> 是一个广泛使用的库。您需要重构代码才能使用 trait，然后便可很快地对其进行模拟：</p>
<pre><code class="language-rust ignore">use std::time::Duration;

#[mockall::automock]
pub trait Pet {
    fn is_hungry(&amp;self, since_last_meal: Duration) -&gt; bool;
}

#[test]
fn test_robot_dog() {
    let mut mock_dog = MockPet::new();
    mock_dog.expect_is_hungry().return_const(true);
    assert_eq!(mock_dog.is_hungry(Duration::from_secs(10)), true);
}
</code></pre>
<details>
<ul>
<li>
<p>Mockall is the recommended mocking library in Android (AOSP). There are other <a href="https://crates.io/keywords/mock">mocking libraries available on crates.io</a>, in particular in the area of mocking HTTP services. The other mocking libraries work in a similar fashion as Mockall, meaning that they make it easy to get a mock implementation of a given trait.</p>
</li>
<li>
<p>请注意，模拟在某种程度上具有 <em>争议性</em>：借助模拟，您可以将测试与其依赖项完全隔离。最立竿见影的是，测试作业会更快且更稳定。另一方面，模拟对象的配置可能出现错误，并返回与真实依赖项不同的输出。</p>
<p>建议您尽可能使用真实依赖项。例如，许多数据库都支持您配置内存后端。这意味着，您可以在测试中获得正确的功能行为，而且测试速度会很快并会自动清理。</p>
<p>同样，许多 Web 框架都支持您启动进程内服务器，该服务器会绑定到 <code>localhost</code> 上的随机端口。相比模拟框架，请始终优先选择这种方式，因为这有助于您在真实环境中测试代码。</p>
</li>
<li>
<p>Mockall 不是 Rust Playground 的一部分，因此您需要在本地环境中运行此示例。使用 <code>cargo add mockall</code> 快速将 Mockall 添加到现有 Cargo 项目中。</p>
</li>
<li>
<p>Mockall 具有更多功能。具体而言，您可以设置基于传递参数的预期值。在这里，我们使用该功能来模拟一只猫，它在上次被喂食的 3 小时后会感到饥饿：</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_robot_cat() {
    let mut mock_cat = MockPet::new();
    mock_cat
        .expect_is_hungry()
        .with(mockall::predicate::gt(Duration::from_secs(3 * 3600)))
        .return_const(true);
    mock_cat.expect_is_hungry().return_const(false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(1 * 3600)), false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(5 * 3600)), true);
}
</code></pre>
<ul>
<li>您可以使用 <code>.times(n)</code> 将调用模拟方法的次数限制为 <code>n</code>，如果不满足此条件，模拟对象被释放时会自动 panic。</li>
</ul>
</details><h1><a class="header" href="#日志记录" id="日志记录">日志记录</a></h1>
<p>你应该使用 <code>log</code> crate 来自动记录日志到 <code>logcat</code> （设备上）或 <code>stdout</code>（主机上）：</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_logs&quot;,
    crate_name: &quot;hello_rust_logs&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;liblog_rust&quot;,
        &quot;liblogger&quot;,
    ],
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device(&quot;rust&quot;)
            .with_max_level(log::LevelFilter::Trace),
    );
    debug!(&quot;Starting program.&quot;);
    info!(&quot;Things are going fine.&quot;);
    error!(&quot;Something went wrong!&quot;);
}
</code></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m hello_rust_logs
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>日志将会在 <code>adb logcat</code> 中显示：</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<details>
<ul>
<li>The logger implementation in <code>liblogger</code> is only needed in the final binary, if you're logging from a library you only need the <code>log</code> facade crate.</li>
</ul>
</details>
<h1><a class="header" href="#互操作性" id="互操作性">互操作性</a></h1>
<p>Rust 对于与其他编程语言的互操作性有着出色的支持。这意味着您可以：</p>
<ul>
<li>从其他语言调用 Rust 函数。</li>
<li>从 Rust 调用用其他语言编写的函数。</li>
</ul>
<p>当您从外部语言调用函数时，我们称之为使用 <strong>外部函数接口</strong>（<em>Foreign Function Interface</em>， FFI）。</p>
<h1><a class="header" href="#与-c-的互操作性" id="与-c-的互操作性">与 C 的互操作性</a></h1>
<p>Rust 对使用 C 调用约定链接目标文件提供了完整的支持。同样地，你可以导出 Rust 函数并从 C 中调用它们。</p>
<p>如果你愿意的话，你可以手工完成它：</p>
<pre><pre class="playground"><code class="language-rust">unsafe extern &quot;C&quot; {
    safe fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    let abs_x = abs(x);
    println!(&quot;{x}, {abs_x}&quot;);
}
</code></pre></pre>
<p>We already saw this in the <a href="android/interoperability/../../unsafe-rust/exercise.html">Safe FFI Wrapper exercise</a>.</p>
<blockquote>
<p>这假设对目标平台拥有充分的了解，不建议用于生产环境。</p>
</blockquote>
<p>接下来我们将探讨更好的选择。</p>
<h1><a class="header" href="#使用-bindgen" id="使用-bindgen">使用 Bindgen</a></h1>
<p><a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> 工具可以自动生成 C 头文件的绑定代码。</p>
<p>首先创建一个小型的 C 语言库：</p>
<p>interoperability/bindgen/libbirthday.h:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;libbirthday.h&quot;

void print_card(const card* card) {
  printf(&quot;+--------------\n&quot;);
  printf(&quot;| Happy Birthday %s!\n&quot;, card-&gt;name);
  printf(&quot;| Congratulations with the %i years!\n&quot;, card-&gt;years);
  printf(&quot;+--------------\n&quot;);
}
</code></pre>
<p>将该库添加到你的 <code>Android.bp</code> 文件中：</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: &quot;libbirthday&quot;,
    srcs: [&quot;libbirthday.c&quot;],
}
</code></pre>
<p>为该库创建一个包装头文件（在此示例中不是必需的）：</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include &quot;libbirthday.h&quot;
</code></pre>
<p>您现在可以自动生成绑定代码：</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: &quot;libbirthday_bindgen&quot;,
    crate_name: &quot;birthday_bindgen&quot;,
    wrapper_src: &quot;libbirthday_wrapper.h&quot;,
    source_stem: &quot;bindings&quot;,
    static_libs: [&quot;libbirthday&quot;],
}
</code></pre>
<p>最后，我们可以在 Rust 程序中使用这些绑定：</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;print_birthday_card&quot;,
    srcs: [&quot;main.rs&quot;],
    rustlibs: [&quot;libbirthday_bindgen&quot;],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new(&quot;Peter&quot;).unwrap();
    let card = card { name: name.as_ptr(), years: 42 };
    // SAFETY: The pointer we pass is valid because it came from a Rust
    // reference, and the `name` it contains refers to `name` above which also
    // remains valid. `print_card` doesn't store either pointer to use later
    // after it returns.
    unsafe {
        print_card(&amp;card as *const card);
    }
}
</code></pre></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m print_birthday_card
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card&quot; /data/local/tmp
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>最后，我们可以运行自动生成的测试来确保绑定代码正常工作：</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: &quot;libbirthday_bindgen_test&quot;,
    srcs: [&quot;:libbirthday_bindgen&quot;],
    crate_name: &quot;libbirthday_bindgen_test&quot;,
    test_suites: [&quot;general-tests&quot;],
    auto_gen_config: true,
    clippy_lints: &quot;none&quot;, // Generated file, skip linting
    lints: &quot;none&quot;,
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<h1><a class="header" href="#调用-rust" id="调用-rust">调用 Rust</a></h1>
<p>将 Rust 函数和类型导出到 C 很简单：</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;C&quot; fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!(&quot;x ({x}) is smallest!&quot;);
    } else {
        println!(&quot;y ({y}) is probably larger than x ({x})&quot;);
    }
}
</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

void analyze_numbers(int x, int y);

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: &quot;libanalyze_ffi&quot;,
    crate_name: &quot;analyze_ffi&quot;,
    srcs: [&quot;analyze.rs&quot;],
    include_dirs: [&quot;.&quot;],
}
</code></pre>
<p>我们现在可以从一个 C 二进制文件中调用它：</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include &quot;analyze.h&quot;

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: &quot;analyze_numbers&quot;,
    srcs: [&quot;main.c&quot;],
    static_libs: [&quot;libanalyze_ffi&quot;],
}
</code></pre>
<p>在你的设备上构建，推送，并运行二进制文件 ：</p>
<pre><code class="language-shell">m analyze_numbers
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers&quot; /data/local/tmp
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[unsafe(no_mangle)]</code> disables Rust's usual name mangling, so the exported symbol will just be the name of the function. You can also use <code>#[unsafe(export_name = &quot;some_name&quot;)]</code> to specify whatever name you want.</p>
</details>
<h1><a class="header" href="#与-c-交互" id="与-c-交互">与 C++ 交互</a></h1>
<p><a href="https://cxx.rs/">CXX crate</a> 使得在 Rust 和 C++ 之间进行安全的互操作成为可能。</p>
<p>整体的方法如下：</p>
<img src="android/interoperability/cpp/overview.svg">
<h1><a class="header" href="#桥接模块" id="桥接模块">桥接模块</a></h1>
<p>CXX依赖于提供的函数签名说明，这些签名会在不用语言之间进行交互使用。您可以在带有 <code>#[cxx::bridge]</code> 属性宏注解的 Rust 模块中使用 extern 代码块提供此说明。</p>
<pre><code class="language-rust ignore">#[allow(unsafe_op_in_unsafe_fn)]
#[cxx::bridge(namespace = &quot;org::blobstore&quot;)]
mod ffi {
    // Shared structs with fields visible to both languages.
    struct BlobMetadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    // C++ types and signatures exposed to Rust.
    unsafe extern &quot;C++&quot; {
        include!(&quot;include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}
</code></pre>
<details>
<ul>
<li>桥接通常在您的 crate 内的 <code>ffi</code> 模块中声明。</li>
<li>根据在桥接模块中进行的声明，CXX 将生成匹配的 Rust 和 C++ 类型/函数定义，以便将这些内容公开给这两种语言。</li>
<li>如需查看生成的 Rust 代码，请使用 <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> 查看展开后的 proc 宏。对于大多数示例，您可以使用 <code>cargo expand ::ffi</code> 来仅展开 <code>ffi</code> 模块（但这不适用于 Android 项目）。</li>
<li>如需查看生成的 C++ 代码，请在 <code>target/cxxbridge</code> 中查找。</li>
</ul>
</details>
<h1><a class="header" href="#rust-bridge-declarations" id="rust-bridge-declarations">Rust Bridge Declarations</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        type MyType; // Opaque type
        fn foo(&amp;self); // Method on `MyType`
        fn bar() -&gt; Box&lt;MyType&gt;; // Free function
    }
}

struct MyType(i32);

impl MyType {
    fn foo(&amp;self) {
        println!(&quot;{}&quot;, self.0);
    }
}

fn bar() -&gt; Box&lt;MyType&gt; {
    Box::new(MyType(123))
}
</code></pre>
<details>
<ul>
<li><code>extern &quot;Rust&quot;</code> 中声明的内容引用了父级模块中作用域内的内容。</li>
<li>CXX 代码生成器使用 <code>extern &quot;Rust&quot;</code> 部分生成包含相应 C++ 声明的 C++ 头文件。生成的头文件与包含桥接的 Rust 源文件的路径相同，但文件扩展名为 .rs.h。</li>
</ul>
</details>
<h1><a class="header" href="#生成的-c-代码" id="生成的-c-代码">生成的 C++ 代码</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }
}
</code></pre>
<p>大致生成以下 C++：</p>
<pre><code class="language-cpp">struct MultiBuf final : public ::rust::Opaque {
  ~MultiBuf() = delete;

private:
  friend ::rust::layout;
  struct layout {
    static ::std::size_t size() noexcept;
    static ::std::size_t align() noexcept;
  };
};

::rust::Slice&lt;::std::uint8_t const&gt; next_chunk(::org::blobstore::MultiBuf &amp;buf) noexcept;
</code></pre>
<h1><a class="header" href="#c-桥接声明" id="c-桥接声明">C++ 桥接声明</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // C++ types and signatures exposed to Rust.
    unsafe extern &quot;C++&quot; {
        include!(&quot;include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}
</code></pre>
<p>大致生成以下 Rust：</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct BlobstoreClient {
    _private: ::cxx::private::Opaque,
}

pub fn new_blobstore_client() -&gt; ::cxx::UniquePtr&lt;BlobstoreClient&gt; {
    extern &quot;C&quot; {
        #[link_name = &quot;org$blobstore$cxxbridge1$new_blobstore_client&quot;]
        fn __new_blobstore_client() -&gt; *mut BlobstoreClient;
    }
    unsafe { ::cxx::UniquePtr::from_raw(__new_blobstore_client()) }
}

impl BlobstoreClient {
    pub fn put(&amp;self, parts: &amp;mut MultiBuf) -&gt; u64 {
        extern &quot;C&quot; {
            #[link_name = &quot;org$blobstore$cxxbridge1$BlobstoreClient$put&quot;]
            fn __put(
                _: &amp;BlobstoreClient,
                parts: *mut ::cxx::core::ffi::c_void,
            ) -&gt; u64;
        }
        unsafe {
            __put(self, parts as *mut MultiBuf as *mut ::cxx::core::ffi::c_void)
        }
    }
}

// ...
</code></pre>
<details>
<ul>
<li>程序员无需承诺他们输入的签名准确无误。CXX 会执行静态断言，确认签名与 C++ 中声明的内容完全一致。</li>
<li>借助 <code>unsafe extern</code> 代码块，您可以声明可从 Rust 安全调用的 C++ 函数。</li>
</ul>
</details>
<h1><a class="header" href="#共享类型-1" id="共享类型-1">共享类型</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    #[derive(Clone, Debug, Hash)]
    struct PlayingCard {
        suit: Suit,
        value: u8,  // A=1, J=11, Q=12, K=13
    }

    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
</code></pre>
<details>
<ul>
<li>仅支持类似 C 函数（单元）的枚举。</li>
<li>共享类型的 <code>#[derive()]</code> 支持有限数量的 trait。系统还会针对 C++ 代码生成相应的功能，例如，如果您派生了 <code>Hash</code>，还会为相应的 C++ 类型生成 <code>std::hash</code> 实现。</li>
</ul>
</details>
<h1><a class="header" href="#共享枚举" id="共享枚举">共享枚举</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
</code></pre>
<p>Generated Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct Suit {
    pub repr: u8,
}

#[allow(non_upper_case_globals)]
impl Suit {
    pub const Clubs: Self = Suit { repr: 0 };
    pub const Diamonds: Self = Suit { repr: 1 };
    pub const Hearts: Self = Suit { repr: 2 };
    pub const Spades: Self = Suit { repr: 3 };
}
<span class="boring">}
</span></code></pre></pre>
<p>Generated C++:</p>
<pre><code class="language-c++">enum class Suit : uint8_t {
  Clubs = 0,
  Diamonds = 1,
  Hearts = 2,
  Spades = 3,
};
</code></pre>
<details>
<ul>
<li>在 Rust 端，为共享枚举生成的代码实际上是封装数值的结构体。这是因为在 C++ 中，枚举类存储与所有已列变体不同的值不属于 UB，而 Rust 表示法需要具有相同的行为。</li>
</ul>
</details>
<h1><a class="header" href="#rust-错误处理" id="rust-错误处理">Rust 错误处理</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn fallible(depth: usize) -&gt; anyhow::Result&lt;String&gt; {
    if depth == 0 {
        return Err(anyhow::Error::msg(&quot;fallible1 requires depth &gt; 0&quot;));
    }

    Ok(&quot;Success!&quot;.into())
}
</code></pre>
<details>
<ul>
<li>在 C++ 方面，返回 <code>Result</code> 的 Rust 函数会被翻译为异常。</li>
<li>抛出的异常始终是 <code>rust::Error</code> 类型，该类型主要用于提供获取错误消息字符串的方法。错误消息将由错误类型的 <code>Display</code> impl 提供。</li>
<li>当 panic 从 Rust 展开到 C++ 时，会始终导致进程立即终止。</li>
</ul>
</details>
<h1><a class="header" href="#c-错误处理" id="c-错误处理">C++ 错误处理</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    unsafe extern &quot;C++&quot; {
        include!(&quot;example/include/example.h&quot;);
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn main() {
    if let Err(err) = ffi::fallible(99) {
        eprintln!(&quot;Error: {}&quot;, err);
        process::exit(1);
    }
}
</code></pre>
<details>
<ul>
<li>声明用于返回 <code>Result</code> 的 C++ 函数将捕获 C++ 端抛出的任何异常，并将其作为 <code>Err</code> 值返回给调用 Rust 函数。</li>
<li>如果外部 “C++”函数抛出l了异常，但 CXX 桥接中未声明该函数用于返回 <code>Result</code>，则程序会调用 C++ 的 <code>std::terminate</code>。此行为等同于通过 C++ 函数 <code>nowithout</code> 抛出了相同的异常。</li>
</ul>
</details>
<h1><a class="header" href="#其他类型" id="其他类型">其他类型</a></h1>
<table><thead><tr><th>Rust Type</th><th>C++ Type</th></tr></thead><tbody>
<tr><td>String</td><td><code>rust::String</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>rust::Str</code></td></tr>
<tr><td><code>CxxString</code></td><td><code>std::string</code></td></tr>
<tr><td><code>&amp;[T]</code>/<code>&amp;mut [T]</code></td><td><code>rust::Slice</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>rust::Box&lt;T&gt;</code></td></tr>
<tr><td><code>UniquePtr&lt;T&gt;</code></td><td><code>std::unique_ptr&lt;T&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>rust::Vec&lt;T&gt;</code></td></tr>
<tr><td><code>CxxVector&lt;T&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td></tr>
</tbody></table>
<details>
<ul>
<li>这些类型可用于共享结构体的字段以及外部函数的参数和返回结果。</li>
<li>请注意，Rust 的 <code>String</code> 不会直接映射到 <code>std::string</code>。导致这种情况的原因有以下几种：
<ul>
<li><code>std::string</code> 不遵循 <code>String</code> 所需的 UTF-8 不变性。</li>
<li>这两种类型的内存布局不同，因此无法直接在语言之间进行传递。</li>
<li><code>std::string</code> 需要与 Rust 的移动语义不匹配的 move 构造函数，因此 <code>std::string</code> 无法按值传递给 Rust。</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android" id="building-in-android">Building in Android</a></h1>
<p>创建 <code>cc_library_static</code> 以构建 C++ 库，包括 CXX 生成的头文件和源文件。</p>
<pre><code class="language-javascript">cc_library_static {
    name: &quot;libcxx_test_cpp&quot;,
    srcs: [&quot;cxx_test.cpp&quot;],
    generated_headers: [
        &quot;cxx-bridge-header&quot;,
        &quot;libcxx_test_bridge_header&quot;
    ],
    generated_sources: [&quot;libcxx_test_bridge_code&quot;],
}
</code></pre>
<details>
<ul>
<li>指出 <code>libcxx_test_bridge_header</code> 和 <code>libcxx_test_bridge_code</code> 是 CXX 生成的 C++ 绑定的依赖项。我们将在下一张幻灯片中介绍具体的设置方法。</li>
<li>请注意，您还需要依靠 <code>cxx-bridge-header</code> 库才能提取常见的 CXX 定义。</li>
<li>如需了解如何在 Android 中使用 CXX 的完整文档，请参阅 <a href="https://source.android.com/docs/setup/build/rust/building-rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx">Android 文档</a>。建议您与全班同学分享该链接，以便学生知道日后可以在哪里找到这些说明。</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android-1" id="building-in-android-1">Building in Android</a></h1>
<p>创建两个 genrule：一个用于生成 CXX 头文件，另一个用于生成 CXX 源文件。然后，这些内容会被用作 <code>cc_library_static</code> 的输入。</p>
<pre><code class="language-javascript">// Generate a C++ header containing the C++ bindings
// to the Rust exported functions in lib.rs.
genrule {
    name: &quot;libcxx_test_bridge_header&quot;,
    tools: [&quot;cxxbridge&quot;],
    cmd: &quot;$(location cxxbridge) $(in) --header &gt; $(out)&quot;,
    srcs: [&quot;lib.rs&quot;],
    out: [&quot;lib.rs.h&quot;],
}

// Generate the C++ code that Rust calls into.
genrule {
    name: &quot;libcxx_test_bridge_code&quot;,
    tools: [&quot;cxxbridge&quot;],
    cmd: &quot;$(location cxxbridge) $(in) &gt; $(out)&quot;,
    srcs: [&quot;lib.rs&quot;],
    out: [&quot;lib.rs.cc&quot;],
}
</code></pre>
<details>
<ul>
<li><code>cxxbridge</code> 工具是一款独立工具，用于生成桥接模块的 C++ 端。它包含在 Android 中，并作为 Soong 工具提供。</li>
<li>按照惯例，如果您的 Rust 源文件是 <code>lib.rs</code>，则头文件将命名为 <code>lib.rs.h</code>，源文件将命名为 <code>lib.rs.cc</code>。不过，系统并不强制执行此命名惯例。</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android-2" id="building-in-android-2">Building in Android</a></h1>
<p>创建一个依赖于 <code>libcxx</code> 和 <code>cc_library_static</code> 的 <code>rust_binary</code>。</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;cxx_test&quot;,
    srcs: [&quot;lib.rs&quot;],
    rustlibs: [&quot;libcxx&quot;],
    static_libs: [&quot;libcxx_test_cpp&quot;],
}
</code></pre>
<h1><a class="header" href="#与-java-的互操作性" id="与-java-的互操作性">与 Java 的互操作性</a></h1>
<p>Java可以通过 <a href="https://en.wikipedia.org/wiki/Java_Native_Interface"> Java 本地接口 (JNI)</a> 加载共享对象。<a href="https://docs.rs/jni/"><code>jni</code> crate</a> 允许您创建一个兼容的库。</p>
<p>首先，我们创建一个可以导出到 Java 的 Rust 函数：</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;system&quot; fn Java_HelloWorld_hello(
    mut env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(&amp;name).unwrap().into();
    let greeting = format!(&quot;Hello, {input}!&quot;);
    let output = env.new_string(greeting).unwrap();
    output.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: &quot;libhello_jni&quot;,
    crate_name: &quot;hello_jni&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    rustlibs: [&quot;libjni&quot;],
}
</code></pre>
<p>We then call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary(&quot;hello_jni&quot;);
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;Alice&quot;);
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: &quot;helloworld_jni&quot;,
    srcs: [&quot;HelloWorld.java&quot;],
    main_class: &quot;HelloWorld&quot;,
    required: [&quot;libhello_jni&quot;],
}
</code></pre>
<p>最后，您可以构建、同步和运行二进制文件：</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<h1><a class="header" href="#welcome-to-rust-in-chromium" id="welcome-to-rust-in-chromium">Welcome to Rust in Chromium</a></h1>
<p>Chromium 中的第三方库支持 Rust，并使用第一方粘合代码连接 Rust 和现有 Chromium C++ 代码。</p>
<blockquote>
<p>今天，我们将调用 Rust 对字符串进行一些有趣的操作。如果您的代码中某个部分是用于向用户展示 UTF8 字符串，那么可以在代码库中的对应部分按照这个步骤来操作，而不一定要在我们所讨论的确切部分。</p>
</blockquote>
<h1><a class="header" href="#设置-1" id="设置-1">设置</a></h1>
<p>请确保您可以构建并运行 Chromium。只要您的代码较新（提交位置始于 1223636，对应于 2023 年 11 月），则可在任何平台和任何一组 build 标志下运行。</p>
<pre><code class="language-shell">gn gen out/Debug
autoninja -C out/Debug chrome
out/Debug/chrome # or on Mac, out/Debug/Chromium.app/Contents/MacOS/Chromium
</code></pre>
<p>（建议使用调试 build 组件，以缩短迭代时间。这是默认值！）</p>
<p>如果您不具备这点，请参阅 <a href="https://www.chromium.org/developers/how-tos/get-the-code/">如何构建 Chromium</a>。注意：设置 build Chromium 需要花些时间。</p>
<p>此外，我们还建议您安装 Visual Studio 代码。</p>
<h1><a class="header" href="#about-the-exercises" id="about-the-exercises">About the exercises</a></h1>
<p>本课程的这一部分包含一系列练习，它们之间是相辅相成的。我们将在整个课程中进行这些练习，而不仅仅是在最后阶段完成。如果您没有时间完成某个部分，也无需担心：可以在下一阶段赶上进度。</p>
<h1><a class="header" href="#chromium-和-cargo-的生态对比" id="chromium-和-cargo-的生态对比">Chromium 和 Cargo 的生态对比</a></h1>
<p>The Rust community typically uses <code>cargo</code> and libraries from <a href="https://crates.io/">crates.io</a>. Chromium is built using <code>gn</code> and <code>ninja</code> and a curated set of dependencies.</p>
<p>使用 Rust 编写代码时，您可以选择：</p>
<ul>
<li>借助 <code>//build/rust/*.gni</code> 模板（例如 <code>rust_static_library</code>，我们稍后会介绍）使用 <code>gn</code> 和 <code>ninja</code>。该操作会使用经过审核的 Chromium 工具链和 crate。</li>
<li>使用 <code>cargo</code>，但 <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Using-cargo">仅限于经过审核的 Chromium 工具链和 crate</a></li>
<li>使用 <code>cargo</code>，信任 <a href="https://rustup.rs/">工具链</a> 和/或 <a href="https://crates.io/">从互联网下载的 crate</a></li>
</ul>
<p>From here on we'll be focusing on <code>gn</code> and <code>ninja</code>, because this is how Rust code can be built into the Chromium browser. At the same time, Cargo is an important part of the Rust ecosystem and you should keep it in your toolbox.</p>
<h2><a class="header" href="#mini-exercise" id="mini-exercise">Mini exercise</a></h2>
<p>分成各个小组开展以下活动：</p>
<ul>
<li>思考 <code>cargo</code> 在哪些场景下具有优势，并评估这些场景的风险状况。</li>
<li>讨论在使用 <code>gn</code> 和 <code>ninja</code> 以及离线 <code>cargo</code> 等时，需要信任哪些工具、库和人群。</li>
</ul>
<details>
<p>Ask students to avoid peeking at the speaker notes before completing the exercise. Assuming folks taking the course are physically together, ask them to discuss in small groups of 3-4 people.</p>
<p>与第一部分练习相关的备注/提示（“Cargo 可能具有优势的场景”）：</p>
<ul>
<li>
<p>It's fantastic that when writing a tool, or prototyping a part of Chromium, one has access to the rich ecosystem of crates.io libraries. There is a crate for almost anything and they are usually quite pleasant to use. (<code>clap</code> for command-line parsing, <code>serde</code> for serializing/deserializing to/from various formats, <code>itertools</code> for working with iterators, etc.).</p>
<ul>
<li>借助 <code>cargo</code>，您便可以轻松试用库（只需向 `Cargo.toml`` 添加一行代码然后开始编写即可）</li>
<li>不妨比较下 CPAN 是如何帮助 <code>perl</code> 成为热门之选的。或者与 <code>python</code> + <code>pip</code> 进行比较。</li>
</ul>
</li>
<li>
<p>Development experience is made really nice not only by core Rust tools (e.g. using <code>rustup</code> to switch to a different <code>rustc</code> version when testing a crate that needs to work on nightly, current stable, and older stable) but also by an ecosystem of third-party tools (e.g. Mozilla provides <code>cargo vet</code> for streamlining and sharing security audits; <code>criterion</code> crate gives a streamlined way to run benchmarks).</p>
<ul>
<li>借助 <code>cargo</code>，您可通过 <code>cargo install --locked cargo-vet</code> 轻松添加工具。</li>
<li>不妨与 Chrome 扩展程序或 VScode 扩展程序进行比较。</li>
</ul>
</li>
<li>
<p>以下是一些适合选用 <code>cargo</code>，较为宽泛的通用项目示例：</p>
<ul>
<li>Perhaps surprisingly, Rust is becoming increasingly popular in the industry for writing command line tools. The breadth and ergonomics of libraries is comparable to Python, while being more robust (thanks to the rich typesystem) and running faster (as a compiled, rather than interpreted language).</li>
<li>如要加入 Rust 生态系统，必须使用 Cargo 等标准 Rust 工具。如果希望库获得外部贡献，并且能够用于除 Chromium 之外（例如用于 Bazel 或 Android/Soong 构建环境）的项目，则应该使用 Cargo。</li>
</ul>
</li>
<li>
<p>基于 <code>cargo</code>\ 的 Chromium 相关项目示例：</p>
<ul>
<li><code>serde_json_lenient</code>（已在 Google 的其他部分进行了实验，结果是能使 PR 性能得到提升）</li>
<li>字体库（例如 <code>font-types</code>）</li>
<li><code>gnrt</code> 工具（我们将在本课程稍后的部分中加以介绍）使用 <code>clap</code> 进行命令行解析，使用 <code>toml</code> 处理配置文件。
<ul>
<li>Disclaimer: a unique reason for using <code>cargo</code> was unavailability of <code>gn</code> when building and bootstrapping Rust standard library when building Rust toolchain.</li>
<li><code>run_gnrt.py</code> uses Chromium's copy of <code>cargo</code> and <code>rustc</code>. <code>gnrt</code> depends on third-party libraries downloaded from the internet, but <code>run_gnrt.py</code> asks <code>cargo</code> that only <code>--locked</code> content is allowed via <code>Cargo.lock</code>.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>学生可将以下内容认定为隐式信任或明确信任：</p>
<ul>
<li><code>rustc</code>（Rust 编译器）则依赖于 LLVM 库、Clang 编译器、“rustc”源代码（从 GitHub 获取，并由 Rust 编译器团队审核）、为引导而下载的二进制 Rust 编译器</li>
<li><code>rustup</code>（值得注意的是，<code>rustup</code> 是在 https://github.com/rust-lang/ 保护下组织开发的，与 <code>rustc</code> 相同。）</li>
<li><code>cargo</code>、<code>rustfmt</code> 等</li>
<li>各种内部基础架构（用于构建 <code>rustc</code> 的聊天机器人、用于将预构建工具链分发给 Chromium 工程师的系统等。）</li>
<li><code>cargo Audit</code>、<code>cargo vet</code> 等 Cargo 工具</li>
<li>包含到 <code>//third_party/rust</code> 的 Rust 库（由 security@chromium.org 进行审核）</li>
<li>其他 Rust 库（一些小众但很受欢迎又常用的库）</li>
</ul>
</details>
<h1><a class="header" href="#chromium-rust-政策" id="chromium-rust-政策">Chromium Rust 政策</a></h1>
<p>Chromium 尚不支持使用第一方 Rust，除非是经过 <a href="https://source.chromium.org/chromium/chromium/src/+/main:ATL_OWNERS">区域技术主管</a> 批准的特殊情况。</p>
<p>有关 Chromium 的第三方库政策，请参阅 <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#rust">此处</a>。根据该这些政策，在很多情况下允许将 Rust 作为第三方库使用，包括无论是在性能还是安全方面，它们都是理想之选。</p>
<p>鲜少有 Rust 库会直接公开 C/C++ API，这意味着几乎所有此类库都需要使用少量的第一方粘合代码。</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="208"></rect><rect x="20" y="88" width="128" height="64" class="solid nofill" rx="0"></rect><circle cx="100" cy="120" r="3" class="nofill"></circle><rect x="276" y="88" width="136" height="64" class="solid nofill" rx="0"></rect><circle cx="396" cy="120" r="3" class="nofill"></circle><rect x="500" y="88" width="112" height="64" class="solid nofill" rx="0"></rect><text x="258" y="12" >Rust</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><text x="498" y="60" >Existing</text><text x="498" y="76" >crate</text><text x="178" y="140" >Language</text><text x="426" y="140" >Crate</text><text x="178" y="156" >boundary</text><text x="426" y="156" >API</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><text x="18" y="60" >Existing</text><text x="90" y="60" >Chromium</text><text x="282" y="60" >Chromium</text><text x="354" y="60" >Rust</text><text x="570" y="60" >Rust</text><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="280" y1="184" x2="288" y2="184" class="solid"></line><line x1="296" y1="184" x2="304" y2="184" class="solid"></line><line x1="312" y1="184" x2="320" y2="184" class="solid"></line><line x1="328" y1="184" x2="336" y2="184" class="solid"></line><line x1="344" y1="184" x2="352" y2="184" class="solid"></line><line x1="360" y1="184" x2="368" y2="184" class="solid"></line><line x1="376" y1="184" x2="384" y2="184" class="solid"></line><line x1="392" y1="184" x2="400" y2="184" class="solid"></line><line x1="408" y1="184" x2="416" y2="184" class="solid"></line><line x1="424" y1="184" x2="432" y2="184" class="solid"></line><line x1="440" y1="184" x2="448" y2="184" class="solid"></line><line x1="456" y1="184" x2="464" y2="184" class="solid"></line><line x1="472" y1="184" x2="480" y2="184" class="solid"></line><line x1="488" y1="184" x2="496" y2="184" class="solid"></line><line x1="504" y1="184" x2="512" y2="184" class="solid"></line><line x1="520" y1="184" x2="528" y2="184" class="solid"></line><line x1="536" y1="184" x2="544" y2="184" class="solid"></line><line x1="552" y1="184" x2="560" y2="184" class="solid"></line><line x1="568" y1="184" x2="576" y2="184" class="solid"></line><line x1="584" y1="184" x2="592" y2="184" class="solid"></line><line x1="600" y1="184" x2="608" y2="184" class="solid"></line><text x="2" y="12" >C++</text><text x="18" y="76" >C++</text><text x="282" y="76" >wrapper</text><g><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><path d="M 160,24 A 4,4 0,0,1 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="180" class="broken"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><path d="M 164,180 A 4,4 0,0,1 160,184" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="180" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,180 A 4,4 0,0,0 264,184" class="nofill"></path><line x1="264" y1="184" x2="272" y2="184" class="solid"></line></g><g><line x1="104" y1="120" x2="288" y2="120" class="solid"></line><polygon points="288,116 296,120 288,124" class="filled"></polygon></g><g><line x1="400" y1="120" x2="520" y2="120" class="solid"></line><polygon points="520,116 528,120 520,124" class="filled"></polygon></g><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="180" class="broken"></line><line x1="616" y1="184" x2="624" y2="184" class="solid"></line><path d="M 628,180 A 4,4 0,0,1 624,184" class="nofill"></path></g></svg></div>
<blockquote>
<p>特定第三方 crate 的第一方 Rust 粘合代码通常应放在 <code>third_party/rust/&lt;crate&gt;/&lt;version&gt;/wrapper</code> 目录中。</p>
</blockquote>
<p>因此，今天的课程将重点介绍以下内容：</p>
<ul>
<li>引入第三方 Rust 库 (&quot;crates&quot;)</li>
<li>编写粘合代码，以便能够从 Chromium C++ 中使用这些 crate。</li>
</ul>
<p>如果此政策随时间而发生变化，则本课程也会随之更新。</p>
<h1><a class="header" href="#build-rules" id="build-rules">Build rules</a></h1>
<p>Rust 代码通常使用 <code>cargo</code> 构建而成。为提高效率，Chromium 使用 <code>gn</code> 和 <code>ninja</code> 进行构建，其静态规则支持实现最大程度的并行处理。Rust 也不例外。</p>
<h2><a class="header" href="#adding-rust-code-to-chromium" id="adding-rust-code-to-chromium">Adding Rust code to Chromium</a></h2>
<p>在一些现有的 Chromium <code>BUILD.gn</code> 文件中，声明 <code>rust_static_library</code>：</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
}
</code></pre>
<p>您还可以在其他 Rust 目标上添加 <code>deps</code>。稍后，我们通过该操作来使用第三方代码。</p>
<details>
<p>您必须 <em>同时</em> 指定 crate 根目录 <em>和</em> 完整的源代码列表。<code>crate_root</code> 是供 Rust 编译器使用的文件，表示编译单元的根文件，通常为 <code>lib.rs</code>。<code>sources</code> 是所有源文件的完整列表，<code>ninja</code> 需要用它来确定何时该进行重新构建。</p>
<p>（在 Rust 中，并不存在所谓的 Rust <code>source_set</code>，因为整个 crate 就是一个编译单元。<code>static_library</code> 是最小的单元。）</p>
<p>学生可能会疑惑为何我们需要 gn 模板，而不使用 <a href="https://gn.googlesource.com/gn/+/main/docs/reference.md#func_static_library">gn 内置的 Rust 静态库支持</a> 进行操作。原因是此模板支持 CXX 互操作性、各项 Rust 功能以及单元测试，我们稍后便会用到其中的一些功能。</p>
</details>
<h1><a class="header" href="#including-unsafe-rust-code" id="including-unsafe-rust-code">Including <code>unsafe</code> Rust Code</a></h1>
<p>默认情况下，禁止在 <code>rust_static_library</code> 中使用不安全的 Rust 代码，因为此类代码无法编译。如需使用不安全的 Rust 代码，请将 <code>allow_unsafe = true</code> 添加到 gn 目标中。（在本课程的稍后部分，我们将介绍在哪些情形下必须这样做。）</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [
    &quot;lib.rs&quot;,
    &quot;hippopotamus.rs&quot;
  ]
  allow_unsafe = true
}
</code></pre>
<h1><a class="header" href="#在-chromium-c-中导入-rust-代码" id="在-chromium-c-中导入-rust-代码">在 Chromium C++ 中导入 Rust 代码</a></h1>
<p>只需将上述目标添加到某些 Chromium C++ 目标的 <code>deps</code> 中即可。</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
}

# or source_set, static_library etc.
component(&quot;preexisting_cpp&quot;) {
  deps = [ &quot;:my_rust_lib&quot; ]
}
</code></pre>
<details>
We'll see that this relationship only works if the Rust code exposes plain C APIs
which can be called from C++, or if we use a C++/Rust interop tool.
</details>
<h1><a class="header" href="#visual-studio-code" id="visual-studio-code">Visual Studio Code</a></h1>
<p>在 Rust 代码中，通常会省略类型，这使得拥有强大的 IDE 甚至比 C++ 更为有用。Visual Studio Code 非常适用于在 Chromium 中处理 Rust 代码。如需使用此功能，</p>
<ul>
<li>请确保您的 VSCode 安装了 <code>rust-analyzer</code> 扩展程序，而不是较早版本的 Rust 支持插件。</li>
<li><code>gn gen out/Debug --export-rust-project</code>（或输出目录的等效项）</li>
<li><code>In -s out/Debug/rust-project.json rust-project.json</code></li>
</ul>
<img src="chromium/build-rules/vscode.png" style="border: 1px solid black;" alt="Example screenshot from VSCode">
<details>
<p>如果受众群体对 IDE 持有怀疑态度，不妨演示下 rust-analyzer 的部分代码注解和探索功能，或许能让他们改观。</p>
<p>以下步骤可能会对演示有所帮助（但您也可以选用一段最为熟悉的 Chromium 相关 Rust 代码）：</p>
<ul>
<li>打开 <code>components/qr_code_generator/qr_code_generator_ffi_glue.rs</code></li>
<li>将光标置于 `qr_code_generator_ffi_glue.rs 中的 <code>QrCode::new</code> 调用（大约第 26 行）上</li>
<li>Demo <strong>show documentation</strong> (typical bindings: vscode = ctrl k i; vim/CoC = K).</li>
<li>Demo <strong>go to definition</strong> (typical bindings: vscode = F12; vim/CoC = g d). (This will take you to <code>//third_party/rust/.../qr_code-.../src/lib.rs</code>.)</li>
<li>演示 <strong>outline</strong> 并前往 <code>QrCode::with_bits</code> 方法（大约第 164 行；大纲位于 vscode 中的文件资源管理器窗格中；典型绑定：vim/CoC = space o）</li>
<li>Demo <strong>type annotations</strong> (there are quite a few nice examples in the <code>QrCode::with_bits</code> method)</li>
</ul>
<p>值得注意的是，修改 <code>BUILD.gn</code> 文件后，需要重新运行 <code>gn gen ... --export-rust-project</code>（我们将在本课程的练习中多次执行该操作）。</p>
</details>
<h1><a class="header" href="#build-rules-exercise" id="build-rules-exercise">Build rules exercise</a></h1>
<p>在 Chromium build 中，向 <code>//ui/base/BUILD.gn</code> 添加新的 Rust 目标，其中包含：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;C&quot; fn hello_from_rust() {
    println!(&quot;Hello from Rust!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Important</strong>: note that <code>no_mangle</code> here is considered a type of unsafety by the Rust compiler, so you'll need to allow unsafe code in your <code>gn</code> target.</p>
<p>将这个新的 Rust 目标添加为 <code>//ui/base:base</code> 的依赖项。在 <code>ui/base/resource/resource_bundle.cc</code> 顶部声明此函数（稍后，我们将介绍如何通过绑定生成工具来自动执行此操作）：</p>
<pre><code class="language-cpp">extern &quot;C&quot; void hello_from_rust();
</code></pre>
<p>从 <code>ui/base/resource/resource_bundle.cc</code> 中的某个位置调用此函数，我们建议在从 <code>ResourceBundle::MaybeMangleLocalizedString</code> 的顶部调用此函数。构建并运行 Chromium，并确保多次显示 &quot;Hello from Rust!&quot;。</p>
<p>如果您使用 VSCode，现在就请设置 Rust，以便其能在 VSCode 中正常运行。这对后续练习会很有帮助。如果操作成功，则可使用右键点击 <code>println!</code> 上的 &quot;Go to definition&quot;。</p>
<h2><a class="header" href="#如何获取帮助" id="如何获取帮助">如何获取帮助</a></h2>
<ul>
<li>适用于 [<code>rust_static_library</code> gn 模板] 的选项 (https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16)</li>
<li>Information about <a href="https://doc.rust-lang.org/beta/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a></li>
<li>关于 [<code>extern &quot;C&quot;</code>] 的详细信息 (https://doc.rust-lang.org/std/keyword.extern.html)</li>
<li>关于 gn 的 [<code>--export-rust-project</code>] 开关的详细信息 (https://gn.googlesource.com/gn/+/main/docs/reference.md#compilation-database)</li>
<li><a href="https://code.visualstudio.com/docs/languages/rust">如何在 VSCode 中安装 rust-analyzer</a></li>
</ul>
<details>
It's really important that students get this running, because future exercises
will build on it.
<p>此示例很独特，因为其归根结底是最通用的互操作语言，即 C 语言。C++ 和 Rust 本身都可以声明和调用 C ABI 函数。在本课程的稍后部分，我们会直接将 C++ 和 Rust 关联起来。</p>
<p><code>allow_unsafe = true</code> is required here because <code>#[unsafe(no_mangle)]</code> might allow Rust to generate two functions with the same name, and Rust can no longer guarantee that the right one is called.</p>
<p>如果需要纯 Rust 可执行文件，也可以使用 <code>rust_executable</code> gn 模板执行此操作。</p>
</details>
<h1><a class="header" href="#测试-1" id="测试-1">测试</a></h1>
<p>Rust community typically authors unit tests in a module placed in the same source file as the code being tested. This was covered <a href="chromium/../testing.html">earlier</a> in the course and looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn my_test() {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Chromium we place unit tests in a separate source file and we continue to follow this practice for Rust --- this makes tests consistently discoverable and helps to avoid rebuilding <code>.rs</code> files a second time (in the <code>test</code> configuration).</p>
<p>This results in the following options for testing Rust code in Chromium:</p>
<ul>
<li>Native Rust tests (i.e. <code>#[test]</code>). Discouraged outside of <code>//third_party/rust</code>.</li>
<li><code>gtest</code> tests authored in C++ and exercising Rust via FFI calls. Sufficient when Rust code is just a thin FFI layer and the existing unit tests provide sufficient coverage for the feature.</li>
<li><code>gtest</code> tests authored in Rust and using the crate under test through its public API (using <code>pub mod for_testing { ... }</code> if needed). This is the subject of the next few slides.</li>
</ul>
<details>
<p>Mention that native Rust tests of third-party crates should eventually be exercised by Chromium bots. (Such testing is needed rarely --- only after adding or updating third-party crates.)</p>
<p>Some examples may help illustrate when C++ <code>gtest</code> vs Rust <code>gtest</code> should be used:</p>
<ul>
<li>
<p>QR has very little functionality in the first-party Rust layer (it's just a thin FFI glue) and therefore uses the existing C++ unit tests for testing both the C++ and the Rust implementation (parameterizing the tests so they enable or disable Rust using a <code>ScopedFeatureList</code>).</p>
</li>
<li>
<p>Hypothetical/WIP PNG integration may need to implement memory-safe implementation of pixel transformations that are provided by <code>libpng</code> but missing in the <code>png</code> crate - e.g. RGBA =&gt; BGRA, or gamma correction. Such functionality may benefit from separate tests authored in Rust.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust_gtest_interop-库" id="rust_gtest_interop-库"><code>rust_gtest_interop</code> 库</a></h1>
<p>The <a href="https://chromium.googlesource.com/chromium/src/+/main/testing/rust_gtest_interop/README.md"><code>rust_gtest_interop</code></a> library provides a way to:</p>
<ul>
<li>Use a Rust function as a <code>gtest</code> testcase (using the <code>#[gtest(...)]</code> attribute)</li>
<li>Use <code>expect_eq!</code> and similar macros (similar to <code>assert_eq!</code> but not panicking and not terminating the test when the assertion fails).</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">use rust_gtest_interop::prelude::*;

#[gtest(MyRustTestSuite, MyAdditionTest)]
fn test_addition() {
    expect_eq!(2 + 2, 4);
}
</code></pre>
<h1><a class="header" href="#rust-测试的-gn-规则" id="rust-测试的-gn-规则">Rust 测试的 GN 规则</a></h1>
<p>The simplest way to build Rust <code>gtest</code> tests is to add them to an existing test binary that already contains tests authored in C++. For example:</p>
<pre><code class="language-gn">test(&quot;ui_base_unittests&quot;) {
  ...
  sources += [ &quot;my_rust_lib_unittest.rs&quot; ]
  deps += [ &quot;:my_rust_lib&quot; ]
}
</code></pre>
<p>Authoring Rust tests in a separate <code>static_library</code> also works, but requires manually declaring the dependency on the support libraries:</p>
<pre><code class="language-gn">rust_static_library(&quot;my_rust_lib_unittests&quot;) {
  testonly = true
  is_gtest_unittests = true
  crate_root = &quot;my_rust_lib_unittest.rs&quot;
  sources = [ &quot;my_rust_lib_unittest.rs&quot; ]
  deps = [
    &quot;:my_rust_lib&quot;,
    &quot;//testing/rust_gtest_interop&quot;,
  ]
}

test(&quot;ui_base_unittests&quot;) {
  ...
  deps += [ &quot;:my_rust_lib_unittests&quot; ]
}
</code></pre>
<h1><a class="header" href="#chromiumimport-宏" id="chromiumimport-宏"><code>chromium::import!</code> 宏</a></h1>
<p>After adding <code>:my_rust_lib</code> to GN <code>deps</code>, we still need to learn how to import and use <code>my_rust_lib</code> from <code>my_rust_lib_unittest.rs</code>. We haven't provided an explicit <code>crate_name</code> for <code>my_rust_lib</code> so its crate name is computed based on the full target path and name. Fortunately we can avoid working with such an unwieldy name by using the <code>chromium::import!</code> macro from the automatically-imported <code>chromium</code> crate:</p>
<pre><code class="language-rust ignore">chromium::import! {
    &quot;//ui/base:my_rust_lib&quot;;
}

use my_rust_lib::my_function_under_test;
</code></pre>
<p>Under the covers the macro expands to something similar to:</p>
<pre><code class="language-rust ignore">extern crate ui_sbase_cmy_urust_ulib as my_rust_lib;

use my_rust_lib::my_function_under_test;
</code></pre>
<p>More information can be found in <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:third_party&amp;ss=chromium%2Fchromium%2Fsrc">the doc comment</a> of the <code>chromium::import</code> macro.</p>
<details>
<p><code>rust_static_library</code> supports specifying an explicit name via <code>crate_name</code> property, but doing this is discouraged. And it is discouraged because the crate name has to be globally unique. crates.io guarantees uniqueness of its crate names so <code>cargo_crate</code> GN targets (generated by the <code>gnrt</code> tool covered in a later section) use short crate names.</p>
</details>
<h1><a class="header" href="#testing-exercise" id="testing-exercise">Testing exercise</a></h1>
<p>Time for another exercise!</p>
<p>In your Chromium build:</p>
<ul>
<li>Add a testable function next to <code>hello_from_rust</code>. Some suggestions: adding two integers received as arguments, computing the nth Fibonacci number, summing integers in a slice, etc.</li>
<li>Add a separate <code>..._unittest.rs</code> file with a test for the new function.</li>
<li>Add the new tests to <code>BUILD.gn</code>.</li>
<li>Build the tests, run them, and verify that the new test works.</li>
</ul>
<h1><a class="header" href="#与-c-的互操作性-1" id="与-c-的互操作性-1">与 C++ 的互操作性</a></h1>
<p>Rust 社区提供了多种 C++/Rust 互操作选项，并且一直在不断开发新工具。目前，Chromium 使用一种名为 CXX 的工具。</p>
<p>您可以使用接口定义语言（与 Rust 极为相似）描述整个语言边界，然后 CXX 工具会据此生成 Rust 和 C++ 函数及类型的声明。</p>
<img src="chromium/../android/interoperability/cpp/overview.svg" alt="Overview diagram of cxx, showing that the same interface definition is used to create both C++ and Rust side code which then communicate via a lowest common denominator C API">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for a full example of using this.</p>
<details>
<p>请仔细研究这个图表。解释背后的原理和您之前所做的完全相同。说明自动执行这一流程具有以下好处：</p>
<ul>
<li>使用该工具可保证 C++ 端和 Rust 端相匹配（例如，如果 <code>#[cxx::bridge]</code> 与实际的 C++ 或 Rust 定义不匹配，则会出现编译错误。但使用不同步的手动绑定，可能会导致未定义行为）</li>
<li>该工具还可自动生成 FFI thunk（即小型但可兼容 C-ABI 的自由函数），以便适应非 C 语言特性（例如，启用对 Rust 或 C++ 方法的 FFI 调用；而手动实现绑定一般需要自行编写这种顶级的自由函数）</li>
<li>该工具和库可以处理一系列核心类型，例如：
<ul>
<li><code>&amp;[T]</code> 可以跨 FFI 边界进行传递，即使它无法保证任何特定的 ABI 或内存布局一致无误。进行手动绑定时，必须手动解构 <code>std::span&lt;T&gt;</code> / <code>&amp;[T]</code>，并根据指针和长度进行重新构建，但这很容易出错，因为每种语言对于空 slice 的表示方式略有不同</li>
<li>系统对 <code>std::unique_ptr&lt;T&gt;</code>、<code>std::shared_ptr&lt;T&gt;</code> 和/或 <code>Box</code> 等智能指针提供原生支持。如果使用手动绑定，则必须传递可兼容 C-ABI 的原始指针，这会增加生命周期和内存安全风险。</li>
<li><code>rust::String</code> 和 <code>CxxString</code> 类型能够识别并处理不同语言之间在字符串表示方面的差异（例如，<code>rust::String::lossy</code> 可以通过非 UTF8 输入构建 Rust 字符串；<code>rust::String::c_str</code> 可以为字符串加上 NUL 终止符）。</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#绑定示例" id="绑定示例">绑定示例</a></h1>
<p>CXX requires that the whole C++/Rust boundary is declared in <code>cxx::bridge</code> modules inside <code>.rs</code> source code.</p>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    unsafe extern &quot;C++&quot; {
        include!(&quot;example/include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: &amp;BlobstoreClient, buf: &amp;mut MultiBuf) -&gt; Result&lt;u64&gt;;
    }
}

// Definitions of Rust types and functions go here
</code></pre>
<details>
<p>指出：</p>
<ul>
<li>Although this looks like a regular Rust <code>mod</code>, the <code>#[cxx::bridge]</code> procedural macro does complex things to it. The generated code is quite a bit more sophisticated - though this does still result in a <code>mod</code> called <code>ffi</code> in your code.</li>
<li>Native support for C++'s <code>std::unique_ptr</code> in Rust</li>
<li>Native support for Rust slices in C++</li>
<li>从 C++ 调用 Rust，并使用 Rust 类型（顶部位置）</li>
<li>从 Rust 调用 C++，并使用 C++ 类型（底部位置）</li>
</ul>
<p><strong>常见误解</strong>：这 <em>看似</em> Rust 在解析 C++ 头文件，其实具有误导性。Rust 不会对此头文件进行解释，只是在生成的 C++ 代码中添加 <code>#include</code>，以便于 C++ 编译器 使用。</p>
</details>
<h2><a class="header" href="#cxx-的局限性" id="cxx-的局限性">CXX 的局限性</a></h2>
<p>By far the most useful page when using CXX is the <a href="https://cxx.rs/bindings.html">type reference</a>.</p>
<p>CXX 基本适用于以下情况：</p>
<ul>
<li>您的 Rust-C++ 接口非常简单，可以声明其中的全部内容。</li>
<li>目前，您只使用了 CXX 提供原生支持的类型，例如 <code>std::unique_ptr</code>、<code>std::string</code>、<code>&amp;[u8]</code> 等。</li>
</ul>
<p>这样具有很多局限性，例如缺少对 Rust 的 <code>Option</code> 类型的支持。</p>
<p>由于这些局限，我们在 Chromium 中只能将 Rust 用于隔离紧密的 “叶节点”，而无法用于任意的 Rust-C++ 互操作。当您打算在 Chromium 中探索 Rust 的应用场景时，推荐先从拟定针对语言边界的 CXX 绑定入手，以查看该语言边界是否足够简单明了。</p>
<details>
In addition, right now, Rust code in one component cannot depend on Rust
code in another, due to linking details in our component build. That's another
reason to restrict Rust to use in leaf nodes.
<p>此外，还应讨论使用 CXX 时的其他一些困难之处，例如：</p>
<ul>
<li>其根据 C++ 异常来进行错误处理（下一张幻灯片中将加以介绍）</li>
<li>函数指针使用起来很不方便。</li>
</ul>
</details>
<h1><a class="header" href="#cxx-错误处理" id="cxx-错误处理">CXX 错误处理</a></h1>
<p>CXX's <a href="https://cxx.rs/binding/result.html">support for <code>Result&lt;T,E&gt;</code></a> relies on C++ exceptions, so we can't use that in Chromium. Alternatives:</p>
<ul>
<li>
<p>The <code>T</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned via out parameters (e.g. via <code>&amp;mut T</code>). This requires that <code>T</code> can be passed across the FFI boundary - for example <code>T</code> has to be:
<ul>
<li>A primitive type (like <code>u32</code> or <code>usize</code>)</li>
<li>A type natively supported by <code>cxx</code> (like <code>UniquePtr&lt;T&gt;</code>) that has a suitable default value to use in a failure case (<em>unlike</em> <code>Box&lt;T&gt;</code>).</li>
</ul>
</li>
<li>Retained on the Rust side, and exposed via reference. This may be needed when <code>T</code> is a Rust type, which cannot be passed across the FFI boundary, and cannot be stored in <code>UniquePtr&lt;T&gt;</code>.</li>
</ul>
</li>
<li>
<p>The <code>E</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned as a boolean (e.g. <code>true</code> representing success, and <code>false</code> representing failure)</li>
<li>Preserving error details is in theory possible, but so far hasn't been needed in practice.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#cxx-error-handling-qr-example" id="cxx-error-handling-qr-example">CXX Error Handling: QR Example</a></h1>
<p>The QR code generator is <a href="https://source.chromium.org/chromium/chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue.rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca">an example</a> where a boolean is used to communicate success vs failure, and where the successful result can be passed across the FFI boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = &quot;qr_code_generator&quot;)]
mod ffi {
    extern &quot;Rust&quot; {
        fn generate_qr_code_using_rust(
            data: &amp;[u8],
            min_version: i16,
            out_pixels: Pin&lt;&amp;mut CxxVector&lt;u8&gt;&gt;,
            out_qr_size: &amp;mut usize,
        ) -&gt; bool;
    }
}
</code></pre>
<details>
<p>Students may be curious about the semantics of the <code>out_qr_size</code> output. This is not the size of the vector, but the size of the QR code (and admittedly it is a bit redundant - this is the square root of the size of the vector).</p>
<p>It may be worth pointing out the importance of initializing <code>out_qr_size</code> before calling into the Rust function. Creation of a Rust reference that points to uninitialized memory results in Undefined Behavior (unlike in C++, when only the act of dereferencing such memory results in UB).</p>
<p>If students ask about <code>Pin</code>, then explain why CXX needs it for mutable references to C++ data: the answer is that C++ data can’t be moved around like Rust data, because it may contain self-referential pointers.</p>
</details>
<h1><a class="header" href="#cxx-error-handling-png-example" id="cxx-error-handling-png-example">CXX Error Handling: PNG Example</a></h1>
<p>A prototype of a PNG decoder illustrates what can be done when the successful result cannot be passed across the FFI boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = &quot;gfx::rust_bindings&quot;)]
mod ffi {
    extern &quot;Rust&quot; {
        /// This returns an FFI-friendly equivalent of `Result&lt;PngReader&lt;'a&gt;,
        /// ()&gt;`.
        fn new_png_reader&lt;'a&gt;(input: &amp;'a [u8]) -&gt; Box&lt;ResultOfPngReader&lt;'a&gt;&gt;;

        /// C++ bindings for the `crate::png::ResultOfPngReader` type.
        type ResultOfPngReader&lt;'a&gt;;
        fn is_err(self: &amp;ResultOfPngReader) -&gt; bool;
        fn unwrap_as_mut&lt;'a, 'b&gt;(
            self: &amp;'b mut ResultOfPngReader&lt;'a&gt;,
        ) -&gt; &amp;'b mut PngReader&lt;'a&gt;;

        /// C++ bindings for the `crate::png::PngReader` type.
        type PngReader&lt;'a&gt;;
        fn height(self: &amp;PngReader) -&gt; u32;
        fn width(self: &amp;PngReader) -&gt; u32;
        fn read_rgba8(self: &amp;mut PngReader, output: &amp;mut [u8]) -&gt; bool;
    }
}
</code></pre>
<details>
<p><code>PngReader</code> and <code>ResultOfPngReader</code> are Rust types --- objects of these types cannot cross the FFI boundary without indirection of a <code>Box&lt;T&gt;</code>. We can't have an <code>out_parameter: &amp;mut PngReader</code>, because CXX doesn't allow C++ to store Rust objects by value.</p>
<p>This example illustrates that even though CXX doesn't support arbitrary generics nor templates, we can still pass them across the FFI boundary by manually specializing / monomorphizing them into a non-generic type. In the example <code>ResultOfPngReader</code> is a non-generic type that forwards into appropriate methods of <code>Result&lt;T, E&gt;</code> (e.g. into <code>is_err</code>, <code>unwrap</code>, and/or <code>as_mut</code>).</p>
</details>
<h2><a class="header" href="#using-cxx-in-chromium" id="using-cxx-in-chromium">Using cxx in Chromium</a></h2>
<p>在 Chromium 中，针对每个需要使用 Rust 的叶节点，我们定义独立的 <code>#[cxx::bridge] mod</code>。通常，每个 <code>rust_static_library</code> 都有对应的定义。只需将</p>
<pre><code class="language-gn">cxx_bindings = [ &quot;my_rust_file.rs&quot; ]
   # list of files containing #[cxx::bridge], not all source files
allow_unsafe = true
</code></pre>
<p>添加到您现有的 <code>rust_static_library</code> 以及 <code>crate_root</code> 和 <code>sources</code> 的目标中。</p>
<p>C++ 头文件会在合理的位置生成，因此您只需</p>
<pre><code class="language-cpp">#include &quot;ui/base/my_rust_file.rs.h&quot;
</code></pre>
<p>您会发现，<code>//base</code> 中提供了一些实用函数，可将 Chromium C++ 类型与 CXX Rust 类型相互转换，例如 <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;l=21"><code>SpanToRustSlice</code></a>。</p>
<details>
<p>学生可能会问：为什么我们仍然需要 <code>allow_unsafe = true</code>？</p>
<p>总的来说，按照常规 Rust 标准，没有任何 C/C++ 代码是 “安全”的。在 Rust 中来回调用 C/C++ 可能会对内存执行任意操作，并危及 Rust 自身数据布局的安全性。如果 C/C++ 互操作性中出现 <em>过多</em> 的 <code>unsafe</code> 关键字，可能会损害此类关键字的信噪比，并且 <a href="https://steveklabnik.com/writing/the-cxx-debate">存在争议</a>。但严格地说，将任何外部代码引入 Rust 二进制文件可能会导致 Rust 中出现意外行为。</p>
<p>The narrow answer lies in the diagram at the top of <a href="chromium/interoperability-with-cpp/../interoperability-with-cpp.html">this page</a> --- behind the scenes, CXX generates Rust <code>unsafe</code> and <code>extern &quot;C&quot;</code> functions just like we did manually in the previous section.</p>
</details>
<h1><a class="header" href="#exercise-interoperability-with-c" id="exercise-interoperability-with-c">Exercise: Interoperability with C++</a></h1>
<h2><a class="header" href="#第一部分" id="第一部分">第一部分</a></h2>
<ul>
<li>在您之前创建的 Rust 文件中，添加 <code>#[cxx::bridge]</code> 来指定一个将从 C++ 调用的函数（名为 <code>hello_from_rust</code>），该函数不接受任何参数也不返回任何值。</li>
<li>Modify your previous <code>hello_from_rust</code> function to remove <code>extern &quot;C&quot;</code> and <code>#[unsafe(no_mangle)]</code>. This is now just a standard Rust function.</li>
<li>请修改 <code>gn</code> 目标以构建这些绑定。</li>
<li>在 C++ 代码中，移除 <code>hello_from_rust</code> 的正向声明，然后添加生成的头文件。</li>
<li>Build and run!</li>
</ul>
<h2><a class="header" href="#第二部分" id="第二部分">第二部分</a></h2>
<p>建议尝试操作一下 CXX。这有助于您更好地理解 Rust 在Chromium 中的灵活性。</p>
<p>Some things to try:</p>
<ul>
<li>从 Rust 回调到 C++。您需要执行以下操作：
<ul>
<li>创建一个附加头文件，且您可以从 <code>cxx::bridge</code> 对其进行 <code>include!</code> 操作。您需要在这个新的头文件中声明要调用的 C++ 函数。</li>
<li>创建一个 <code>unsafe</code> 代码块，用于调用此类函数，也可以在 <code>#[cxx::bridge]</code> 中指定 <code>unsafe</code> 关键字，<a href="https://cxx.rs/extern-c++.html#functions-and-member-functions">如此处所述</a>。</li>
<li>您可能还需要添加 <code>#include &quot;third_party/rust/cxx/v1/crate/include/cxx.h&quot;</code></li>
</ul>
</li>
<li>将 C++ 字符串从 C++ 传递到 Rust。</li>
<li>将对 C++ 对象的引用传递到 Rust。</li>
<li>刻意让 Rust 函数签名与 <code>#[cxx::bridge]</code> 不匹配，并逐渐熟悉所看到的错误信息。</li>
<li>刻意让 C++ 函数签名与 <code>#[cxx::bridge]</code> 不匹配，并适应您看到的错误。</li>
<li>将某个类型的 <code>std::unique_ptr</code> 从 C++ 传递到 Rust，以便 Rust 拥有某个 C++ 对象的所有权。</li>
<li>创建一个 Rust 对象并将其传递到 C++，以便 C++ 拥有它的所有权。（提示：您需要使用 <code>Box</code>）。</li>
<li>声明调用某个 C++ 类型的方法。从 Rust 调用它们。</li>
<li>声明调用某个 Rust 类型的方法。从 C++ 调用它们。</li>
</ul>
<h2><a class="header" href="#第三部分" id="第三部分">第三部分</a></h2>
<p>现在，您已经了解了 CXX 互操作性的优势和局限，请思考几个 Rust 在 Chromium 中的应用场景，其中接口要足够简单构思该如何定义该接口。</p>
<h2><a class="header" href="#如何获取帮助-1" id="如何获取帮助-1">如何获取帮助</a></h2>
<ul>
<li>The <a href="https://cxx.rs/bindings.html"><code>cxx</code> binding reference</a></li>
<li><a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16"><code>rust_static_library</code> gn 模板</a></li>
</ul>
<details>
As students explore Part Two, they're bound to have lots of questions about how
to achieve these things, and also how CXX works behind the scenes.
<p>您可能会遇到以下问题：</p>
<ul>
<li>当我用类型 Y 初始化类型 X 的变量时，出现了初始化问题，其中 X 和 Y 都是函数类型。这是因为您的 C++ 函数实现与 <code>cxx::bridge</code> 中的声明并不完全一致。</li>
<li>我好像能随意将 C++ 引用转换为 Rust 引用。这样不会导致 UB 风险吗？对于 CXX 的_不透明_类型，答案为否，因为它们的大小为零。对于 CXX 的基本类型，确实_有可能_导致 UB，但鉴于 CXX 的设计策略，要构建能导致这种情况的示例颇为困难。</li>
</ul>
</details>
<h1><a class="header" href="#添加第三方-crate" id="添加第三方-crate">添加第三方 Crate</a></h1>
<p>Rust 库被称为 <code>crate</code>，可在 <a href="https://crates.io">crates.io</a> 中找到。Rust 的 crate 之间非常容易相互依赖。事实证明，他们确实如此！</p>
<table><thead><tr><th>属性</th><th>C++ library</th><th>Rust crate</th></tr></thead><tbody>
<tr><td>Build system</td><td>很多</td><td>保持一致：<code>Cargo.toml</code></td></tr>
<tr><td>典型库的大小</td><td>大</td><td>小</td></tr>
<tr><td>传递依赖项</td><td>很少</td><td>很多</td></tr>
</tbody></table>
<p>对于 Chromium 工程师来说，这种依赖关系具有以下利弊：</p>
<ul>
<li>所有 crate 都使用共同的构建系统，这样我们就可以自动将其收录到 Chromium 中...</li>
<li>...但是，crate 通常具有传递依赖项，因此可能需要引入多个库。</li>
</ul>
<p>我们将讨论以下内容：</p>
<ul>
<li>如何将 crate 添加到 Chromium 源代码树中</li>
<li>如何为其制定 <code>gn</code> 构建规则</li>
<li>如何审核其源代码以确保足够的安全性。</li>
</ul>
<details>
All of the things in the table on this slide are generalizations, and
counter-examples can be found. But in general it's important for students
to understand that most Rust code depends on other Rust libraries, because
it's easy to do so, and that this has both benefits and costs.
</details>
<h1><a class="header" href="#配置-cargotom-文件以添加-crate" id="配置-cargotom-文件以添加-crate">配置 <code>Cargo.tom</code> 文件以添加 crate</a></h1>
<p>Chromium 具有一组集中管理的直接 crate 依赖项。这些依赖项通过单独的 <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo.toml"><code>Cargo.toml</code></a> 文件进行管理：</p>
<pre><code class="language-toml">[dependencies]
bitflags = &quot;1&quot;
cfg-if = &quot;1&quot;
cxx = &quot;1&quot;
# lots more...
</code></pre>
<p>与任何其他 <code>Cargo.toml</code> 一样，您可以指定 <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">有关依赖项的更多详细信息</a>。最常见的是，您需要指定要在 crate 中启用的 <code>features</code>。</p>
<p>向 Chromium 中添加 crate 时，通常需要在附加文件 <code>gnrt_config.toml</code> 中提供一些额外的信息，我们将在下文中加以介绍。</p>
<h1><a class="header" href="#配置-gnrt_configtoml" id="配置-gnrt_configtoml">配置 <code>gnrt_config.toml</code></a></h1>
<p>与 <code>Cargo.toml</code> 一起使用的是 <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config.toml"><code>gnrt_config.toml</code></a>。此文件包含 Chromium 专用扩展程序，可用于处理 crate。</p>
<p>如果添加新的 crate，至少要明确指定 <code>group</code>。可以为以下选项之一：</p>
<pre><code class="language-toml">#   'safe': The library satisfies the rule-of-2 and can be used in any process.
#   'sandbox': The library does not satisfy the rule-of-2 and must be used in
#              a sandboxed process such as the renderer or a utility process.
#   'test': The library is only used in tests.
</code></pre>
<p>例如：</p>
<pre><code class="language-toml">[crate.my-new-crate]
group = 'test' # only used in test code
</code></pre>
<p>根据 crate 源代码布局，您可能还需要使用此文件指定其 <code>LICENSE</code> 文件的所在位置。</p>
<p>稍后，我们将介绍需要在此文件中配置的其他内容，以便能够解决问题。</p>
<h1><a class="header" href="#下载-crate" id="下载-crate">下载 Crate</a></h1>
<p>有一款名为 <code>gnrt</code> 的工具，具有下载 crate 以及生成 <code>BUILD.gn</code> 规则的功能。</p>
<p>首先，按如下所示下载所需的 crate：</p>
<pre><code class="language-shell">cd chromium/src
vpython3 tools/crates/run_gnrt.py -- vendor
</code></pre>
<blockquote>
<p>虽然 <code>gnrt</code> 工具是 Chromium 源代码的一部分，但通过运行此命令，您可以从 <code>crates.io</code> 下载并运行其依赖项。有关该安全决策的讨论，请参阅 <a href="chromium/adding-third-party-crates/../cargo.html">前面的部分</a>。</p>
</blockquote>
<p>运行此 <code>vendor</code> 命令可能会下载以下内容：</p>
<ul>
<li>Your crate</li>
<li>直接依赖项和传递依赖项</li>
<li><code>cargo</code> 要求的其他 crate 的新版本，用于解析 Chromium 所需的全部 crate。</li>
</ul>
<p>Chromium 会修复一些 crate 的补丁，并将其保存在 <code>//third_party/rust/chromium_crates_io/patches</code> 中。系统会自动重新应用这些补丁，但如果补丁应用失败，您可能需要进行手动操作。</p>
<h1><a class="header" href="#生成-gn-构建规则" id="生成-gn-构建规则">生成 <code>gn</code> 构建规则</a></h1>
<p>下载 crate 后，按如下方式生成 <code>BUILD.gn</code> 文件：</p>
<pre><code class="language-shell">vpython3 tools/crates/run_gnrt.py -- gen
</code></pre>
<p>现在，运行 <code>git status</code>。您应该会看到：</p>
<ul>
<li><code>third_party/rust/chromium_crates_io/vendor</code> 中至少包含一个新的 crate 源代码</li>
<li><code>third_party/rust/&lt;crate name&gt;/v&lt;major semver version&gt;</code> 中至少包含一个新的 <code>BUILD.gn</code></li>
<li>相应的 <code>README.chromium</code></li>
</ul>
<p>The &quot;major semver version&quot; is a <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Rust &quot;semver&quot; version number</a>.</p>
<p>请仔细观察，尤其是 <code>third_party/rust</code> 中生成的内容。</p>
<details>
<p>浅谈下 semver，特别是在 Chromium 中，它支持使用多个不兼容的 crate 版本。虽然在 Cargo 生态系统中不鼓励这种方式，但在某些情况下却是必要的。</p>
</detail>
<h1><a class="header" href="#解决问题" id="解决问题">解决问题</a></h1>
<p>如果构建失败，可能是 <code>build.rs</code> 文件所致：这些程序在构建过程中执行了任意操作。这与 <code>gn</code> 和 <code>ninja</code> 的设计完全不相符，它们旨在实现静态、确定性的构建规则，以最大限度地提高构建的并行性和可重复性。</p>
<p>系统支持自动进行某些 <code>build.rs</code> 操作；而有些需要进行额外的处理：</p>
<table><thead><tr><th>构建脚本效果</th><th>我们的 gn 模板均支持</th><th>您需要完成的工作</th></tr></thead><tbody>
<tr><td>检查 rustc 版本以配置启用和停用功能</td><td>是</td><td>无</td></tr>
<tr><td>检查平台或 CPU 以配置启用和停用功能</td><td>是</td><td>无</td></tr>
<tr><td>Generating code</td><td>是</td><td>是的，在 <code>gnrt_config.toml</code> 中指定</td></tr>
<tr><td>构建 C/C++</td><td>否</td><td>进行补丁修复</td></tr>
<tr><td>Arbitrary other actions</td><td>否</td><td>进行补丁修复</td></tr>
</tbody></table>
<p>幸运的是，大多数 crate 不包含构建脚本，而且大多数的构建脚本只执行前两项操作。</p>
<h1><a class="header" href="#构建用于生成代码的脚本" id="构建用于生成代码的脚本">构建用于生成代码的脚本</a></h1>
<p>如果 <code>ninja</code> 提示有文件缺失，请检查 <code>build.rs</code>，确认其是否写入了源代码文件。</p>
<p>如果是，请修改 <a href="chromium/adding-third-party-crates/resolving-problems/../configuring-gnrt-config-toml.html"><code>gnrt_config.toml</code></a>，将 <code>build-script-outputs</code> 添加到 crate。如果这是一个传递依赖项（即 Chromium 代码不应直接依赖的依赖项），还要添加 <code>allow-first-party-usage=false</code>。该文件中已经提供了若干示例：</p>
<pre><code class="language-toml">[crate.unicode-linebreak]
allow-first-party-usage = false
build-script-outputs = [&quot;tables.rs&quot;]
</code></pre>
<p>现在，请重新运行 <a href="chromium/adding-third-party-crates/resolving-problems/../generating-gn-build-rules.html"><code>gnrt.py -- gen</code></a>，重新生成 <code>BUILD.gn</code> 文件，以通知 ninja 此特定输出文件将被用作后续构建步骤的输入。</p>
<h1><a class="header" href="#构建用于构建-c-或执行任意操作的脚本" id="构建用于构建-c-或执行任意操作的脚本">构建用于构建 C++ 或执行任意操作的脚本</a></h1>
<p>有些 crate 使用 <a href="https://crates.io/crates/cc"><code>cc</code></a> crate 来构建和关联 C/C++ 库。其他 crate 会在其构建脚本中使用 <a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> 解析 C/C++。Chromium 环境中不支持进行这些操作，因为我们的 gn、ninja 和 LLVM 构建系统在表达构建操作之间的关系方面具有非常严格具体的要求。</p>
<p>因此，您可以选择：</p>
<ul>
<li>避开这些 crate</li>
<li>对 crate 应用补丁。</li>
</ul>
<p>补丁应保存在 <code>third_party/rust/chromium_crates_io/patches/&lt;crate&gt;</code> 中，请参阅 <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/patches/cxx/">面向 <code>cxx</code> crate 的补丁</a> 中的示例。每当 <code>gnrt</code> 升级该 crate 时，将会自动应用补丁文件。</p>
<h1><a class="header" href="#依赖于-crate" id="依赖于-crate">依赖于 Crate</a></h1>
<p>添加第三方 crate 并生成构建规则后，就可轻松使用该 crate。请找到 <code>rust_static_library</code> 目标，并在 crate 中的 <code>:lib</code> 目标上添加 <code>dep</code>。</p>
<p>Specifically,</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="528" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="528" height="64"></rect><rect x="172" y="8" width="104" height="32" class="solid nofill" rx="0"></rect><text x="186" y="28" >crate</text><text x="234" y="28" >name</text><rect x="332" y="8" width="184" height="32" class="solid nofill" rx="0"></rect><text x="346" y="28" >major</text><text x="394" y="28" >semver</text><text x="450" y="28" >version</text><text x="2" y="28" >//third_party/rust</text><text x="290" y="28" >/v</text><text x="530" y="28" >:lib</text></svg></div>
<p>例如：</p>
<pre><code class="language-gn">rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
  deps = [ &quot;//third_party/rust/example_rust_crate/v1:lib&quot; ]
}
</code></pre>
<h1><a class="header" href="#auditing-third-party-crates" id="auditing-third-party-crates">Auditing Third Party Crates</a></h1>
<p>添加新库须遵守 Chromium 的标准 <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review">政策</a>，当然也要遵守安全审核标准。您可能不仅要引入单个 crate，而且还要引入传递依赖项，因此可能需要审核大量代码。另一方面，安全的 Rust 代码可能产生的副作用有限。应如何对其进行审核？</p>
<p>随着时间的推移，Chromium 计划逐步采用以 <a href="https://mozilla.github.io/cargo-vet/">cargo vet</a> 为核心的处理流程。</p>
<p>与此同时，每当添加新的 crate 时，我们都会检查以下内容：</p>
<ul>
<li>了解每个 crate 的用途。crate 之间存在什么关系？如果每个 crate 的构建系统都包含 <code>build.rs</code> 或过程宏，请确定它们的用途。它们能否与 Chromium 的正常构建方式相兼容。</li>
<li>检查每个 crate 是否得到合理维护。</li>
<li>使用 <code>cd third-party/rust/chromium_crates_io; cargo review</code> 检查已知漏洞（首先需要运行 <code>cargo install cargo-audit</code>，令人意外的是，这个过程中需要从互联网下载大量的依赖项 <a href="chromium/adding-third-party-crates/../cargo.html">2</a>）</li>
<li>确保所有 <code>unsafe</code> 代码都符合 <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-in-safe-languages">两大规则</a> 的要求</li>
<li>检查是否使用了 <code>fs</code> 或 <code>net</code> API</li>
<li>尽可能地仔细阅读所有代码，查找任何可能属于恶意插入，稍显异常的地方。（但现实中，您不可能做到百无遗漏，因为代码量通常太庞大了。）</li>
</ul>
<p>以下只是一些指导建议，请与 <code>security@chromium.org</code> 的审核者合租，共同找出能够确保 crate 安全的正确方法。</p>
<h1><a class="header" href="#checking-crates-into-chromium-source-code" id="checking-crates-into-chromium-source-code">Checking Crates into Chromium Source Code</a></h1>
<p><code>git status</code> 应显示以下内容：</p>
<ul>
<li><code>//third_party/rust/chromium_crates_io</code> 中的 crate 代码</li>
<li><code>//third_party/rust/&lt;crate&gt;/&lt;version&gt;</code> 中的元数据（<code>BUILD.gn</code> 和 <code>README.chromium</code>）</li>
</ul>
<p>此外，请在后面的位置添加 <code>OWNERS</code> 文件。</p>
<p>您应将所有这些内容，以及对 <code>Cargo.toml</code> 和 <code>gnrt_config.toml</code> 的更改一起提交到 Chromium 仓库中。</p>
<p><strong>重要提示</strong>：您需要使用 <code>git add -f</code> 命令，否则 <code>.gitignore</code> 文件可能会导致某些文件被跳过。</p>
<p>在此过程中，您可能会发现由于使用了非包容性语言，导致提交前检查失败。这是因为 Rust crate 数据往往包含 git 分支的名称，而许多项目仍然在使用非包容性术语。因此，您需要运行以下命令：</p>
<pre><code class="language-shell">infra/update_inclusive_language_presubmit_exempt_dirs.sh &gt; infra/inclusive_language_presubmit_exempt_dirs.txt
git add -p infra/inclusive_language_presubmit_exempt_dirs.txt # add whatever changes are yours
</code></pre>
<h1><a class="header" href="#及时更新-crate" id="及时更新-crate">及时更新 Crate</a></h1>
<p>作为任何第三方 Chromium 依赖项的所有者，您 <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners">应使用任何安全修复程序，确保该依赖项处于最新状态</a>。我们希望能够尽快实现对 Rust crate 自动执行此操作，但目前仍由您负责执行，就像对待任何其他第三方依赖项一样。</p>
<h1><a class="header" href="#练习" id="练习">练习</a></h1>
<p>将 <a href="https://crates.io/crates/uwuify">uwuify</a> 添加到 Chromium，以停用 crate 的 <a href="https://doc.rust-lang.org/cargo/reference/features.html#the-default-feature">默认功能</a>。假设该 crate 会交付 Chromium 时被使用，但不会用于处理不可信的输入内容。</p>
<p>（在下一个练习中，我们将使用 Chromium 中的 uwuify；但您也可以跳过这一步，现在就开始此操作。或者，您可以创建一个使用 <code>uwuify</code> 的新 <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_executable.gni"><code>rust_executable</code> 目标</a>。</p>
<details>
<p>Students will need to download lots of transitive dependencies.</p>
<p>The total crates needed are:</p>
<ul>
<li><code>instant</code>,</li>
<li><code>lock_api</code>,</li>
<li><code>parking_lot</code>,</li>
<li><code>parking_lot_core</code>,</li>
<li><code>redox_syscall</code>,</li>
<li><code>scopeguard</code>,</li>
<li><code>smallvec</code>, and</li>
<li><code>uwuify</code>.</li>
</ul>
<p>If students are downloading even more than that, they probably forgot to turn off the default features.</p>
<p>Thanks to <a href="https://github.com/Daniel-Liu-c0deb0t">Daniel Liu</a> for this crate!</p>
</details>
<h1><a class="header" href="#bringing-it-together-----exercise" id="bringing-it-together-----exercise">Bringing It Together --- Exercise</a></h1>
<p>在本练习中，您将运用之前所学的全部知识，添加一项全新的 Chromium 功能。</p>
<h2><a class="header" href="#the-brief-from-product-management" id="the-brief-from-product-management">The Brief from Product Management</a></h2>
<p>在偏僻的热带雨林中，发现住着一群小精灵。我们务必尽快创建一款精灵版 Chromium，交付给他们。</p>
<p>要求是将 Chromium 的所有界面字符串翻译为精灵语。</p>
<p>由于时间紧迫，无法等待准确的翻译。但幸运的是，精灵语与英语非常接近，然后我们发现有一个 Rust crate 可以执行此翻译任务。</p>
<p>事实上，您已经 <a href="https://crates.io/crates/uwuify">在上一个练习中导入了该 crate</a>。</p>
<p>（显然，对 Chrome 进行准确恰当的翻译，需要做到极度细致和全力以赴。请勿交付此产品！）</p>
<h2><a class="header" href="#步骤" id="步骤">步骤</a></h2>
<p>修改 <code>ResourceBundle::MaybeMangleLocalizedString</code>，在显示之前对所有字符串进行 uwu 处理。在这个特殊的 Chromium 版本中，无论 <code>mangle_localized_strings_</code> 的设置如何，都应该始终执行此操作。</p>
<p>如果您正确完成了这些练习中的所有操作，那么恭喜您已经成功创建了一款精灵版 Chrome！</p>
<img src="exercises/chromium/chwomium.png" alt="Chromium UI screenshot with uwu language">
<details>
Students will likely need some hints here. Hints include:
<ul>
<li>UTF16 与 UTF8。学生应注意，Rust 字符串始终采用 UTF8 编码，它们可能会决定在 C++ 端使用 <code>base::UTF16ToUTF8</code> 进行转换，然后再进行反向转换。</li>
<li>如果学生决定在 Rust 端进行转换，则需要考虑使用 <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a> 方法，同时注意错误处理，并确定哪些 <a href="https://cxx.rs/binding/slice.html">CXX 支持的类型可以传输大量 u16s</a>。</li>
<li>学生可以通过多种方式设计 C++/Rust 边界，例如按值传递和返回字符串，或对字符串采取可变引用。如果使用可变引用，CXX 可能会提示学生需要使用 <a href="https://doc.rust-lang.org/std/pin/"><code>Pin</code></a> 方法。您可能需要解释“Pin”的用途，以及为何 CXX 需要它来对 C++ 数据进行可变引用：原因是 C++ 数据无法像 Rust 数据那样自由移动，它可能包含自引用指针。</li>
<li>对于包含 <code>ResourceBundle::MaybeMangleLocalizedString</code> 的 C++ 目标，需要依赖于 <code>rust_static_library</code> 目标。学生可能已经执行了此操作。</li>
<li><code>rust_static_library</code> 目标需要依赖于 <code>//third_party/rust/uwuify/v0_2:lib</code>。</li>
</ul>
</details>
<h1><a class="header" href="#练习解答" id="练习解答">练习解答</a></h1>
<p>Solutions to the Chromium exercises can be found in <a href="https://chromium-review.googlesource.com/c/chromium/src/+/5096560">this series of CLs</a>.</p>
<h1><a class="header" href="#welcome-to-bare-metal-rust" id="welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>这是单独为裸机 Rust 开设的课程，为期一天，主要面向熟悉 Rust 基础知识的人员（例如已学完 Comprehensive Rust），最好也有一些使用其他语言（例如 C）进行裸机编程的经验。</p>
<p>今天，我们将探讨 <code>bare-metal</code> Rust：即在没有操作系统支持的情况下运行 Rust 代码。该部分主要分为以下内容：</p>
<ul>
<li>什么是 <code>no_std</code> Rust？</li>
<li>编写微控制器固件。</li>
<li>为应用处理器编写引导加载程序 / 内核代码。</li>
<li>有助于裸机 Rust 开发的一些实用 crate。</li>
</ul>
<p>For the microcontroller part of the course we will use the <a href="https://microbit.org/">BBC micro:bit</a> v2 as an example. It's a <a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic nRF52833 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, and an on-board SWD debugger.</p>
<p>首先，请安装我们稍后需要用到的一些工具。在 gLinux 或 Debian 上：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">sudo apt install gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<p>然后，向 <code>plugdev</code> 组中的用户授予 micro:bit 编程器的访问权限：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">echo 'SUBSYSTEM==&quot;hidraw&quot;, ATTRS{idVendor}==&quot;0d28&quot;, MODE=&quot;0660&quot;, GROUP=&quot;logindev&quot;, TAG+=&quot;uaccess&quot;' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>在 MacOS 上：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<h1><a class="header" href="#no_std" id="no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Slice、<code>&amp;str</code>、<code>CStr</code></li>
<li><code>NonZeroU8</code>...</li>
<li><code>Option</code>、<code>Result</code></li>
<li><code>Display</code>、<code>Debug</code>、<code>write!</code>...</li>
<li><code>Iterator</code></li>
<li><code>Error</code></li>
<li><code>panic!</code>、<code>assert_eq!</code>...</li>
<li><code>NonNull</code> 和所有常见的指针相关函数</li>
<li><code>Future</code> 和 <code>async</code>/<code>await</code></li>
<li><code>fence</code>、<code>AtomicBool</code>、<code>AtomicPtr</code>、<code>AtomicU32</code>...</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>、<code>Cow</code>、<code>Arc</code>、<code>Rc</code></li>
<li><code>Vec</code>、<code>BinaryHeap</code>、<code>BtreeMap</code>、<code>LinkedList</code>、<code>VecDeque</code></li>
<li><code>String</code>、<code>CString</code>、<code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>HashMap</code></li>
<li><code>Mutex</code>、<code>Condvar</code>、<code>Barrier</code>、<code>Once</code>、<code>RwLock</code>、<code>mpsc</code></li>
<li><code>File</code> 和 <code>fs</code> 的其余部分</li>
<li><code>println!</code>、<code>Read</code>、<code>Write</code>、<code>Stdin</code>、<code>Stdout</code> 以及 <code>io</code> 的其余部分</li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>、<code>Child</code>、<code>ExitCode</code></li>
<li><code>spawn</code>、<code>sleep</code> 和 <code>thread</code> 的其余部分</li>
<li><code>SystemTime</code>、<code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> 依赖于 RNG。</li>
<li><code>std</code> 会重新导出 <code>core</code> 和 <code>alloc</code> 的内容。</li>
</ul>
</details>
<h1><a class="header" href="#极小的-no_std-程序" id="极小的-no_std-程序">极小的 <code>no_std</code> 程序</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>这将编译为空二进制文件。</li>
<li><code>std</code> 提供了一个 panic 处理程序；如果没有它，我们就必须自行提供。</li>
<li>其他 crate（例如 <code>panic-halt</code>）也可以提供该处理程序。</li>
<li>根据目标不同，可能需要使用 <code>panic = &quot;abort&quot;</code> 进行编译，以避免出现与 <code>eh_personality</code> 相关的错误。</li>
<li>请注意，未提供 <code>main</code> 函数或任何其他入口点；您可以自行定义入口点。通常需要使用链接器脚本和一些汇编代码进行设置工作，以便 Rust 代码能够顺利运行。</li>
</ul>
</details>
<h1><a class="header" href="#alloc" id="alloc"><code>alloc</code></a></h1>
<p>如需使用 <code>alloc</code>，您必须实现 <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">全局（堆）分配器</a>。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // SAFETY: `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR.lock().init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push(&quot;A string&quot;.to_string());
}
</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> 是第三方 crate，用于实现基本伙伴系统分配器。还可以使用其他 crate，或者自行编写 crate，或者接入现有分配器。</li>
<li><code>LockedHeap</code> 的常量参数是分配器的最大阶数；即在本例中，它可以最多分配 2**32 字节大小的区域。</li>
<li>如果依赖项树中的所有 crate 都依赖于 <code>alloc</code>，则您必须在二进制文件中明确定义一个全局分配器。通常，在顶级二进制 crate 中完成此操作。</li>
<li>为了确保能够成功关联 <code>panic_halt</code> crate，以便我们获取其 panic 处理程序，必须使用 <code>extern crate panic_halt as _</code> 方法。</li>
<li>我们可以构建该示例，但由于没有入口点，无法运行。</li>
</ul>
</details>
<h1><a class="header" href="#微控制器" id="微控制器">微控制器</a></h1>
<p><code>cortex_m_rt</code> crate 提供针对 Cortex M 微控制器的重置处理程序（以及其他内容）。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}
</code></pre></pre>
<p>接下来，我们看看随着抽象层级的不断提升，该如何访问外围设备。</p>
<details>
<ul>
<li><code>cortex_m_rt::entry</code> 宏要求函数的类型为 <code>fn() -&gt; !</code>，因为返回重置处理程序会毫无意义。</li>
<li>使用 <code>cargo embed --bin minimum</code> 运行该示例</li>
</ul>
</details>
<h1><a class="header" href="#原始-mmio" id="原始-mmio">原始 MMIO</a></h1>
<p>大多数微控制器通过内存映射 IO 访问外围设备。现在试着开启 micro:bit 上的 LED 指示灯：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>将 GPIO 0 的引脚 21 连接到 LED 矩阵的第一列，将引脚 28 连接到第一行。</li>
</ul>
<p>使用以下命令运行该示例：</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details>
<h1><a class="header" href="#外围设备访问-crate" id="外围设备访问-crate">外围设备访问 crate</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> 使用 <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> 文件为内存映射外围设备生成了大部分安全的 Rust 封装容器。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>SVD（系统视图描述）文件通常是由芯片供应商提供的 XML 文件，用于描述设备的内存映射。
<ul>
<li>这些文件按照外围设备、寄存器、字段和值进行组织分类，其中包含名称、内容描述、地址等信息。</li>
<li>由于 SVD 文件常常存在错误和不完整的情况，因此有许多项目会修复这些错误，补充缺失的相关信息，并发布生成的 crate。</li>
</ul>
</li>
<li><code>cortex-m-rt</code> 提供矢量表以及其他功能。</li>
<li>如果您使用 <code>cargo install cargo-binutils</code>，则可以运行 <code>cargo objdump --bin pac -- -d --no-show-raw-insn</code>，查看生成的二进制文件。</li>
</ul>
<p>使用以下命令运行该示例：</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details>
<h1><a class="header" href="#hal-crates" id="hal-crates">HAL crates</a></h1>
<p>许多微控制器的 <a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crate</a> 为各种外围设备提供了封装容器。通常，这些封装容器可以实现 <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> 中的各种 trait。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> 和 <code>set_high</code> 是 <code>embedded_hal</code> <code>OutputPin</code> trait 上的方法。</li>
<li>HAL crate 被广泛用于许多 Cortex-M 和 RISC-V 设备，包括各种 STM32、GD32、nRF、NXP、MSP430、AVR 和 PIC 微控制器。</li>
</ul>
<p>使用以下命令运行该示例：</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details>
<h1><a class="header" href="#board-support-crates" id="board-support-crates">Board support crates</a></h1>
<p>为了方便使用，板级支持 crate 为特定开发板提供了更高级别的封装功能。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>在本例中，该板级支持 crate 仅提供了一些实用的名称和初始化功能。</li>
<li>除微控制器以外，该 crate 还包含一些可用于板载设备的驱动程序。
<ul>
<li><code>microbit-v2</code> 包含一个可用于 LED 矩阵的简单驱动程序。</li>
</ul>
</li>
</ul>
<p>使用以下命令运行该示例：</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details>
<h1><a class="header" href="#类型状态模式" id="类型状态模式">类型状态模式</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let mut pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; =
        gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>引脚无法实现 <code>Copy</code> 或 <code>Clone</code>，因此，每个引脚只能存在一个实例。一旦某个引脚从端口结构体移出，任何人都无法再使用它。</li>
<li>更改引脚的配置会使旧的引脚实例失效，因此您无法再继续使用旧实例。</li>
<li>值的类型表示其所处状态：例如，在本例中，表示 GPIO 引脚的配置状态。通过这种方式，可将状态机编码成类型系统，并确保在未正确完成引脚配置之前，不会尝试以某种方式使用引脚。编译时捕获了非法状态转换。</li>
<li>您可以在输入引脚上调用 <code>is_high</code>，在输出引脚上调用 <code>set_high</code>，反之则不行。</li>
<li>许多 HAL crate 都遵循此模式。</li>
</ul>
</details>
<h1><a class="header" href="#embedded-hal" id="embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits covering common microcontroller peripherals:</p>
<ul>
<li>GPIO</li>
<li>PWM</li>
<li>Delay timers</li>
<li>I2C and SPI buses and devices</li>
</ul>
<p>Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken out into <a href="https://crates.io/crates/embedded-io"><code>embedded-io</code></a>, <a href="https://crates.io/crates/embedded-can"><code>embedded-can</code></a> and <a href="https://crates.io/crates/rand_core"><code>rand_core</code></a> respectively.</p>
<p>Other crates then implement <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these traits, e.g. an accelerometer driver might need an I2C or SPI device instance.</p>
<details>
<ul>
<li>The traits cover using the peripherals but not initialising or configuring them, as initialisation and configuration is usually highly platform-specific.</li>
<li>还有适用于许多微控制器以及其他平台（例如 Raspberry Pi 上的 Linux）的实现。</li>
<li><a href="https://crates.io/crates/embedded-hal-async"><code>embedded-hal-async</code></a> provides async versions of the traits.</li>
<li><a href="https://crates.io/crates/embedded-hal-nb"><code>embedded-hal-nb</code></a> provides another approach to non-blocking I/O, based on the <a href="https://crates.io/crates/nb"><code>nb</code></a> crate.</li>
</ul>
</details>
<h1><a class="header" href="#probe-rs-和-cargo-embed" id="probe-rs-和-cargo-embed"><code>probe-rs</code> 和 <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> 是一个方便的嵌入式调试工具集，跟 OpenOCD 较为相似，但集成度更高。</p>
<ul>
<li>通过 CMSIS-DAP、ST-Link 和 J-Link 探针实现 SWD（串行调试）和 JTAG</li>
<li>GDB 桩和 Microsoft DAP（调试适配器协议）服务器</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> 是一个 cargo 子命令，用于构建和刷写二进制文件、记录 RTT（实时传输）输出以及连接 GDB。您可通过项目目录中的 <code>Embed.toml</code> 文件对其进行配置。</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> 是一项基于 USB 的 Arm 标准协议，使得电路内调试程序能够接入各种 Arm Cortex 处理器的 CoreSight 调试访问端口。BBC micro:bit 的板载调试程序所使用的便是此协议。</li>
<li>ST-Link 属于 ST Microelectronics 产品系列，J-Link 是 SEGGER 系列。</li>
<li>调试访问端口通常为 5 针 JTAG 接口或 2 针串行线调试接口。</li>
<li>probe-rs 是一个库，如有需要，可以将其集成到您的工具中。</li>
<li>借助 <a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft 调试适配器协议</a>，VSCode 和其他 IDE 可以调试任何受支持的微控制器上运行的代码。</li>
<li>cargo-embed 是使用 probe-rs 库构建的二进制文件。</li>
<li>RTT（实时传输）是一种通过多个环形缓冲区，在调试主机和目标之间进行数据传输的机制。</li>
</ul>
</details>
<h1><a class="header" href="#调试" id="调试">调试</a></h1>
<p><em>Embed.toml</em>:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true
</code></pre>
<p>在 <code>src/bare-metal/microcontrollers/examples/</code> 目录下某个终端中：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>在同一目录下的另一个终端中：</p>
<p>在 gLinux 或 Debian 上：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<p>在 MacOS 上：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">arm-none-eabi-gdb target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<details>
<p>在 GDB 中，请尝试运行以下命令：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details>
<h1><a class="header" href="#other-projects" id="other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>&quot;Real-Time Interrupt-driven Concurrency&quot;.</li>
<li>Shared resource management, message passing, task scheduling, timer queue.</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB.</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit support.</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, IPC.</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a>.</li>
</ul>
<p>有些平台可以实现 <code>std</code>，例如 <a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>。</p>
<details>
<ul>
<li>RTIC 可被视为 RTOS 或并发框架，
<ul>
<li>但不包含任何 HAL。</li>
<li>它使用 Cortex-M NVIC（嵌套虚拟中断控制器）进行调度，而不是选用适合的内核。</li>
<li>仅限 Cortex-M。</li>
</ul>
</li>
<li>Google 在 Haven 微控制器上使用 TockOS 作为 Titan 安全密钥的操作系统。</li>
<li>FreeRTOS 主要使用 C 语言编写，但也提供了专用于编写应用的 Rust 绑定。</li>
</ul>
</details>
<h1><a class="header" href="#习题" id="习题">习题</a></h1>
<p>我们将从 I2C 罗盘读取方向，并将读数记录到串行端口。</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-morning.html">solutions</a> provided.</p>
</details>
<h1><a class="header" href="#罗盘" id="罗盘">罗盘</a></h1>
<p>我们将从 I2C 罗盘读取方向，并将读数记录到串行端口。如有时间，请尝试通过 LED 灯亮起的方式，或者使用按钮来显示方向。</p>
<p>提示：</p>
<ul>
<li>请参阅 <a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> 和 <a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crate，以及 <a href="https://tech.microbit.org/hardware/">micro:bit 硬件</a> 相关文档。</li>
<li>LSM303AGR 惯性测量装置与内部 I2C 总线相连接。</li>
<li>TWI 是 I2C 的别称，因此 I2C 主外围设备称为 TWIM。</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::i2c::I2c</code> trait. The <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a> struct implements this.</li>
<li>您拥有一个 <a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a> 结构体，其中包含各种引脚和外围设备的字段。</li>
<li>如有需要，您还可以查看 <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 数据表</a>，但对本练习来说这不是必需的。</li>
</ul>
<p>下载 <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">练习模板</a> 并在 <code>compass</code> 目录中查找以下文件。</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::{Delay, uarte::{Baudrate, Parity, Uarte}}, Board};

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}
</code></pre></pre>
<p><em>Cargo.toml</em>（无需对此进行更改）：</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;compass&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
cortex-m-rt = &quot;0.7.5&quot;
embedded-hal = &quot;1.0.0&quot;
lsm303agr = &quot;1.1.0&quot;
microbit-v2 = &quot;0.15.1&quot;
panic-halt = &quot;1.0.0&quot;
</code></pre>
<p><em>Embed.toml</em>（无需对此进行更改）：</p>
<!-- File Embed.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><em>.cargo/config.toml</em>（无需对此进行更改）：</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]
</code></pre>
<p>运行以下命令查看 Linux 上的串行输出：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>或者在 Mac OS 上，如下所示（设备名称可能略有不同）：</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>使用 Ctrl+A Ctrl+Q 退出 picocom。</p>
<h1><a class="header" href="#裸机-rust-上午练习" id="裸机-rust-上午练习">裸机 Rust 上午练习</a></h1>
<h2><a class="header" href="#罗盘-1" id="罗盘-1">罗盘</a></h2>
<p>(<a href="exercises/bare-metal/compass.html">返回练习</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use core::cmp::{max, min};
use embedded_hal::digital::InputPin;
use lsm303agr::{
    AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate,
};
use microbit::display::blocking::Display;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::{Delay, Timer};
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    writeln!(serial, &quot;Setting up IMU...&quot;).unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_mode_and_odr(
        &amp;mut delay,
        MagMode::HighResolution,
        MagOutputDataRate::Hz50,
    )
    .unwrap();
    imu.set_accel_mode_and_odr(
        &amp;mut delay,
        AccelMode::Normal,
        AccelOutputDataRate::Hz50,
    )
    .unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        while !(imu.mag_status().unwrap().xyz_new_data()
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data())
        {}
        let compass_reading = imu.magnetic_field().unwrap();
        let accelerometer_reading = imu.acceleration().unwrap();
        writeln!(
            serial,
            &quot;{},{},{}\t{},{},{}&quot;,
            compass_reading.x_nt(),
            compass_reading.y_nt(),
            compass_reading.z_nt(),
            accelerometer_reading.x_mg(),
            accelerometer_reading.y_mg(),
            accelerometer_reading.z_mg(),
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
                scale(compass_reading.y_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs
        // on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(min_out + range_out * (value - min_in) / range_in, min_out, max_out)
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}
</code></pre></pre>
<h1><a class="header" href="#应用处理器" id="应用处理器">应用处理器</a></h1>
<p>到目前为止，我们已经讨论了微控制器，例如 Arm Cortex-M 系列。现在，尝试为 Cortex-A 编写一些代码。为简单起见，我们只使用 QEMU 的 aarch64 <a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html"><code>virt</code></a> 开发板 进行编写。</p>
<details>
<ul>
<li>一般来说，微控制器不具备 MMU 或多级特权（例如，Arm CPU 中的异常级别，x86 中的铃声级别）的功能，而应用处理器则具备这些功能。</li>
<li>QEMU 支持针对每种架构模拟不同的机器或板级模型。“虚拟”开发板并不适用于任何特定的真实硬件，而是专为虚拟机设计的。</li>
</ul>
</details><h1><a class="header" href="#准备使用-rust" id="准备使用-rust">准备使用 Rust</a></h1>
<p>在开始运行 Rust 代码之前，我们需要进行一些初始化设置。</p>
<pre><code class="language-armasm">.section .init.entry, &quot;ax&quot;
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to
     * enable MMU and caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then
     * invalidate any potentially stale local TLB entries before they
     * start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed
     * until this has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>这与 C 语言的情况相同：初始化处理器状态，将 BSS 清零，然后设置堆栈指针。
<ul>
<li>BSS（由于历史原因，称为代码块起始符）属于对象文件的一部分，其中包含静态分配的变量，这些变量被初始化为零。图像中省略了这些符号，以避免因存储零值而占用过多空间。编译器假定加载器会负责将它们清零。</li>
</ul>
</li>
<li>BSS 可能已经被清零，具体取决于内存的初始化方式以及图像的加载方式，但为了确保起见，我们会将其手动清零。</li>
<li>我们需要先启用 MMU 和缓存功能，然后才能读取或写入任何内存。否则：
<ul>
<li>非对齐访问将会出错。我们为 <code>aarch64-unknown-none</code> 目标构建 Rust 代码，该目标会设置 <code>+Strict-align</code> 以防止编译器生成非对齐访问，因此在本例中应该没有问题，但一般情况下并不一定如此。</li>
<li>如果是在虚拟机中运行该命令，可能会导致缓存一致性问题。问题在于，虚拟机是在禁用缓存的情况下直接访问内存，而主机具有同一内存的缓存别名。即使主机并没有明确访问该内存，推测性访问仍然会导致缓存被填充，然后在清除缓存或虚拟机启用缓存时，任何一方对于该内存进行的更改就会丢失。（使用物理地址来键控缓存，而 VA 或 IPA。）</li>
</ul>
</li>
<li>为简单起见，我们只使用硬编码的分页表（请参阅 <code>dmap.S</code>），其通过身份映射将前一个 1 GiB 的地址空间用于设备，紧接着的 1 GiB 用于 DRAM，然后在更高位置预留了 1 GiB 给其他设备。这与 QEMU 使用的内存布局一致。</li>
<li>我们还设置了异常矢量 (<code>vbar_el1</code>)，稍后会对此进行详细介绍。</li>
<li>今天下午的所有示例都假定我们将在异常级别 1 (EL1) 下运行。如果您需要在其他异常级别下运行，则需要修改相应的 <code>entry.S</code>。</li>
</ul>
</details>
<h1><a class="header" href="#内嵌汇编" id="内嵌汇编">内嵌汇编</a></h1>
<p>有时，如果无法通过 Rust 代码实现某些操作，我们就需要使用汇编来解决。例如，如需发出 HVC（Hypervisor 调用）来指示固件关闭系统，请使用以下命令：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // SAFETY: this only uses the declared registers and doesn't do anything
    // with memory.
    unsafe {
        asm!(&quot;hvc #0&quot;,
            inout(&quot;w0&quot;) PSCI_SYSTEM_OFF =&gt; _,
            inout(&quot;w1&quot;) 0 =&gt; _,
            inout(&quot;w2&quot;) 0 =&gt; _,
            inout(&quot;w3&quot;) 0 =&gt; _,
            inout(&quot;w4&quot;) 0 =&gt; _,
            inout(&quot;w5&quot;) 0 =&gt; _,
            inout(&quot;w6&quot;) 0 =&gt; _,
            inout(&quot;w7&quot;) 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}
</code></pre></pre>
<p>（如果确实想要这样做，请使用 <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crate，其中包含适用于所有这些函数的封装容器。）</p>
<details>
<ul>
<li>PSCI 是 Arm 电源状态协调接口，为一组标准函数，用于管理系统和 CPU 电源状态等。在许多系统中，通过 EL3 固件和 Hypervisor 来实现该函数。</li>
<li><code>0 =&gt; _</code> 语法表示在运行内嵌汇编代码之前将寄存器初始化为 0，并在之后忽略寄存器中的内容。我们需要使用 <code>inout</code> 而非 <code>in</code>，因为该调用操作可能会破坏寄存器中的内容。</li>
<li>This <code>main</code> function needs to be <code>#[unsafe(no_mangle)]</code> and <code>extern &quot;C&quot;</code> because it is called from our entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>–<code>_x3</code> 表示寄存器 <code>x0</code>-<code>x3</code> 的值，引导加载程序通常使用这些值来传递各种内容（例如将指针传递到设备树）。根据标准的 aarch64 调用规范（<code>extern &quot;C&quot;</code>指定使用此规范），需要使用寄存器 <code>x0</code>-<code>x7</code> 将前 8 个参数传递给函数，因此 <code>entry.S</code> 无需执行任何特殊操作，只要确保不会更改这些寄存器。</li>
<li>在 QEMU 中，使用 <code>src/bare-metal/aps/examples</code> 目录下的 <code>make qemu_psci</code> 运行该示例。</li>
</ul>
</details>
<h1><a class="header" href="#mmio-的易失性内存访问" id="mmio-的易失性内存访问">MMIO 的易失性内存访问</a></h1>
<ul>
<li>Use <a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.read_volatile"><code>pointer::read_volatile</code></a> and <a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.write_volatile"><code>pointer::write_volatile</code></a>.</li>
<li>切勿提及引用。</li>
<li>Use <code>&amp;raw</code> to get fields of structs without creating an intermediate reference.</li>
</ul>
<details>
<ul>
<li>易失性访问：执行读取或写入操作可能会产生副作用，因此应阻止编译器或硬件对这些操作进行重新排序、复制或省略。
<ul>
<li>通常情况下，如果您先写入操作，紧接着进行读取操作（例如通过可变引用），则编译器可能会认为读取的值是最新写入的值，就不再执行实际的内存读取过程。</li>
</ul>
</li>
<li>虽然在对硬件进行易失性访问时，一些 crate 确实会提及引用，但这很不安全。只要存在引用，编译器就会选择对其进行解引用操作。</li>
<li>Use <code>&amp;raw</code> to get struct field pointers from a pointer to the struct.</li>
<li>For compatibility with old versions of Rust you can use the <a href="https://doc.rust-lang.org/stable/core/ptr/macro.addr_of.html"><code>addr_of!</code></a> macro instead.</li>
</ul>
</details>
<h1><a class="header" href="#编写-uart-驱动程序" id="编写-uart-驱动程序">编写 UART 驱动程序</a></h1>
<p>QEMU “虚拟机”具有 <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UART，现在为其编写驱动程序。</p>
<pre><pre class="playground"><code class="language-rust editable">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>请注意，使用 <code>Uart::new</code> 方法不安全，而其他方法则安全。原因在于，只要 <code>Uart::new</code> 的调用方保证满足其安全要求（即所指定的 UART 只有一个驱动程序实例，且没有其他内容与其地址空间存在重叠），那么后续调用 <code>write_byte</code> 始终是安全的，因为我们假定需要满足的前提条件。</li>
<li>我们也可以采用相反的方式（即确保 <code>new</code> 安全，但 <code>write_byte</code> 不安全），不过这样会很不方便，因为每当调用 <code>write_byte</code> 时都需要推断是否安全。</li>
<li>这是安全地封装不安全代码时常见的策略：即在少数调用代码的地方进行安全验证，而不是在很多地方进行。</li>
</ul>
</details>
<h1><a class="header" href="#更多-trait-1" id="更多-trait-1">更多 trait</a></h1>
<p>已经派生了 <code>Debug</code> trait。如果再实现更多 trait，会大有帮助。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// SAFETY: `Uart` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
</code></pre></pre>
<details>
<ul>
<li>通过实现 <code>Write</code>，我们可以将 <code>write!</code> 和 <code>writeln!</code> 宏与 <code>Uart</code> 类型搭配使用。</li>
<li>在 QEMU 中，使用 <code>src/bare-metal/aps/examples</code> 目录下的 <code>make qemu_minimal</code> 运行该示例。</li>
</ul>
</details>
<h1><a class="header" href="#更好的-uart-驱动程序" id="更好的-uart-驱动程序">更好的 UART 驱动程序</a></h1>
<p>事实上，PL011 具有 <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">很多额外的寄存器</a>，但通过添加偏移量构建指针的方式来访问这些寄存器，既容易出错又难以读取。此外，其中有些寄存器是位字段，非常便于以结构化方式访问。</p>
<table><thead><tr><th>偏移</th><th>寄存器名称</th><th>宽度</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
<details>
<ul>
<li>为简洁起见，我们省略了一些 ID 寄存器。</li>
</ul>
</details>
<h1><a class="header" href="#bitflags" id="bitflags">Bitflags</a></h1>
<p><a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate 非常适用于处理 bitflag。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>bitflags!</code> 宏会创建类似于 <code>Flags(u16)</code> 的新类型，以及一系列用于获取和设置标记的方法实现。</li>
</ul>
</details>
<h1><a class="header" href="#多个寄存器" id="多个寄存器">多个寄存器</a></h1>
<p>我们可以使用结构体来表示 UART 寄存器的内存布局。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
</code></pre></pre>
<details>
<ul>
<li>通过运行 <a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a> 命令，指示编译器按顺序布置结构体字段，遵循与 C 语言相同的规则。这是确保结构体具有可预测布局的必要条件，因为默认的 Rust 表示法允许编译器（以及其他内容）按照其认为合适的方式重新排列字段。</li>
</ul>
</details>
<h1><a class="header" href="#驱动程序" id="驱动程序">驱动程序</a></h1>
<p>现在将新的 <code>Registers</code> 结构体用于我们的驱动程序。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            (&amp;raw mut (*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { (&amp;raw const (*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).fr).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>&amp;raw const</code> / <code>&amp;raw mut</code> to get pointers to individual fields without creating an intermediate reference, which would be unsound.</li>
</ul>
</details>
<h1><a class="header" href="#开始使用" id="开始使用">开始使用</a></h1>
<p>使用驱动程序编写一个小程序，将数据写入串行控制台，并回显传入的字节。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, &quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;).unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; continue,
            }
        }
    }

    writeln!(uart, &quot;\n\nBye!&quot;).unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>与 <a href="bare-metal/aps/better-uart/../inline-assembly.html">内嵌汇编</a> 示例一样，从 <code>entry.S</code> 中的入口点代码调用此 <code>main</code> 函数。如需了解详情，请参阅演讲者备注。</li>
<li>在 QEMU 中，使用 <code>src/bare-metal/aps/examples</code> 目录下的 <code>make qemu</code> 运行该示例。</li>
</ul>
</details>
<h1><a class="header" href="#日志记录-1" id="日志记录-1">日志记录</a></h1>
<p>最好能够使用 <a href="https://crates.io/crates/log"><code>log</code></a> crate 中的日志记录宏。可以通过实现“Log”trait 来做到这一点。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>使用 <code>log</code> 进行解封装是安全的，因为我们会在调用 <code>set_logger</code> 之前初始化 <code>LOGGER</code>。</li>
</ul>
</details>
<h1><a class="header" href="#开始使用-1" id="开始使用-1">开始使用</a></h1>
<p>需要先初始化日志记录器，然后才能使用它。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;);

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>请注意，panic 紧急处理程序现在可以记录各类 panic 详细信息。</li>
<li>在 QEMU 中，使用 <code>src/bare-metal/aps/examples</code> 目录下的 <code>make qemu_logger</code> 运行该示例。</li>
</ul>
</details>
<h1><a class="header" href="#异常-1" id="异常-1">异常</a></h1>
<p>AArch64 定义了一个包含 16 个条目的异常矢量表，适用于处理 4 种状态（当前 EL 使用 SP0，当前 EL 使用 SPx，较低 EL 使用 AArch64，较低 EL 使用 AArch32）下的 4 种异常（同步、IRQ、FIQ、SError）。可以通过汇编方式实现这一操作，以便在调用 Rust 代码之前将易失性寄存器保存到堆栈：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    error!(&quot;irq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>EL 指异常级别；我们今天下午的所有示例都在 EL1 级别下运行。</li>
<li>为简单起见，我们没有区分当前 EL 异常中的 SP0 和 SPx，也没有区分较低 EL 异常中的 AArch32 和 AArch64。</li>
<li>在本示例中，只需记录异常并进行关机操作，因为预计不会发生任何此类异常。</li>
<li>我们可以将异常处理程序和主执行上下文视为不同的线程。通过 <a href="bare-metal/aps/../../concurrency/send-sync.html"><code>Send</code> 和 <code>Sync</code></a> 控制它们之间可以共享的内容，就像使用线程进行共享一样。例如，如果想在异常处理程序和程序的其余部分之间共享某个值，并且使用 <code>Send</code> 而非 <code>Sync</code>，则需要将该值封装在诸如 <code>Mutex</code> 之类的内容中，并放入静态变量。</li>
</ul>
</details>
<h1><a class="header" href="#other-projects-1" id="other-projects-1">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>&quot;coreboot without the C&quot;.</li>
<li>支持 x86、aarch64 和 RISC-V。</li>
<li>依赖于 LinuxBoot，而不是许多驱动程序本身。</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi 操作系统教程</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling, page tables.</li>
<li>在 Rust 中，有些用于处理缓存维护和初始化的方法并不安全，不适宜照搬到正式版代码中。</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>使用静态分析来确定堆栈用量上限。</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>在 RaspberryPi 操作系统教程中，先运行 Rust 代码然后启用 MMU 和缓存。此操作会读取和写入内存（例如堆栈）。不过：
<ul>
<li>如果不启用 MMU 和缓存，非对齐访问将会出错。它使用 <code>aarch64-unknown-none</code> 进行构建，后者会设置 <code>+strict-align</code> 以防止编译器生成非对齐访问，因此应该没有问题，但一般情况下并不一定如此。</li>
<li>如果是在虚拟机中运行该命令，可能会导致缓存一致性问题。问题在于，虚拟机是在禁用缓存的情况下直接访问内存，而主机具有同一内存的缓存别名。即使主机并没有明确访问该内存，推测性访问仍然会导致缓存被填充，然后任何一方对于该内存进行的更改就会丢失。再次强调，尽管在此特定示例中（即在硬件上直接运行且无 Hypervisor）这种做法是可行的，但总的来说，这并非一种良好策略。</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#useful-crates" id="useful-crates">Useful crates</a></h1>
<p>接下来介绍几个 crate，用于解决裸机编程中的一些常见问题。</p>
<h1><a class="header" href="#zerocopy" id="zerocopy"><code>zerocopy</code></a></h1>
<p><a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crate（源自 Fuchsia）提供了 trait 和宏，用于确保在字节序列和其他类型之间进行安全转换。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use zerocopy::{Immutable, IntoBytes};

#[repr(u32)]
#[derive(Debug, Default, Immutable, IntoBytes)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(Debug, Default, Immutable, IntoBytes)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}
</code></pre></pre>
<p>这不适用于 MMIO（因为它不使用易失性读取和写入），但在与硬件共享的结构（例如通过 DMA 传输或发送到外部接口）中进行操作时会很有用。</p>
<details>
<ul>
<li>对于可以接受任何字节模式的类型，都可以实现 <code>FromBytes</code>方法，因此可以对不受信任的字节序列进行安全转换。</li>
<li>如果尝试为这些类型派生 <code>FromBytes</code>，都将会失败，因为 <code>RequestType</code> 不会将所有可能的 u32 值用作判别标识，所以并非所有的字节模式都有效。</li>
<li><code>zerocopy::byteorder</code> 提供了适用于字节顺序感知的数字基元类型。</li>
<li>使用 <code>src/bare-metal/useful-crates/zerocopy-example/</code> 目录下的 <code>cargo run</code> 运行该示例。（由于存在 crate 依赖项，无法在 Playground 中运行该示例。）</li>
</ul>
</details>
<h1><a class="header" href="#aarch64-paging" id="aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>借助 <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crate，您可根据 AArch64 虚拟内存系统架构创建分页表。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();
</code></pre></pre>
<details>
<ul>
<li>目前，该方法仅支持 EL1 级别，但也可以直接添加对其他异常级别的支持。</li>
<li>在 Android 中，该方法适用于 <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">受保护的虚拟机固件</a>。</li>
<li>由于此示例需要在真实硬件上或在 QEMU 中运行，因此没有简单的运行方法可用。</li>
</ul>
</details>
<h1><a class="header" href="#buddy_system_allocator" id="buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> 是第三方 crate，用于实现基本伙伴系统分配器。同时，也可将其用于 <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> 以实现 <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>，这样便可以使用标准的 <code>alloc</code> crate（正如在 <a href="bare-metal/useful-crates/../alloc.html">之前部分</a> 中所示），或者用于分配其他地址空间。例如，我们可能需要为 PCI BAR 分配 MMIO 空间：</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect(&quot;Failed to allocate 0x100 byte MMIO region&quot;);
    println!(&quot;Allocated 0x100 byte MMIO region at {:#x}&quot;, bar);
}
</code></pre></pre>
<details>
<ul>
<li>PCI BAR 的对齐方式始终与其大小相等。</li>
<li>使用 <code>src/bare-metal/useful-crates/allocator-example/</code> 目录下的 <code>cargo run</code> 运行该示例。（由于存在 crate 依赖项，无法在 Playground 中运行该示例。）</li>
</ul>
</details>
<h1><a class="header" href="#tinyvec" id="tinyvec"><code>tinyvec</code></a></h1>
<p>有时，需要一些像 <code>Vec</code> 一样能够调整大小的特性，但无需进行堆分配。<a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> 提供了以下特性：由数组或 slice 支持的矢量，该矢量支持进行静态分配或堆分配；用于跟踪使用的元素数量，如果元素使用量超过了分配额度，则会出现 panic。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!(&quot;{numbers:?}&quot;);
    numbers.push(7);
    println!(&quot;{numbers:?}&quot;);
    numbers.remove(1);
    println!(&quot;{numbers:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>根据 <code>tinyvec</code>要求，元素类型需实现初始化 <code>Default</code>。</li>
<li>Rust Playground 中包含 <code>tinyvec</code>，因此本示例将以内嵌方式正常运行。</li>
</ul>
</details>
<h1><a class="header" href="#spin" id="spin"><code>spin</code></a></h1>
<p>在 <code>core</code> 或 <code>alloc</code> 中无法使用 <code>std::sync::Mutex</code> 和 <code>std::sync</code> 中的其他同步基元。那么该如何管理同步或内部可变性，例如在不同 CPU 之间共享状态？</p>
<p><a href="https://crates.io/crates/spin"><code>spin</code></a> crate 为许多基元提供了基于自旋锁的等效方法。</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!(&quot;count: {}&quot;, counter.lock());
    *counter.lock() += 2;
    println!(&quot;count: {}&quot;, counter.lock());
}
</code></pre></pre>
<details>
<ul>
<li>在中断处理程序中进行锁定操作时，请注意避免出现死锁的情况。</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>, <code>Barrier</code> and <code>Once</code> from <code>std::sync</code>; and <code>Lazy</code> for lazy initialisation.</li>
<li><a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate 也提供了一些适用于延迟初始化的实用类型，它们与 <code>spin::once::Once</code> 所用方法略有不同。</li>
<li>Rust Playground 中包含 <code>spin</code>，因此本示例将以内嵌方式正常运行。</li>
</ul>
</details>
<h1><a class="header" href="#bare-metal-on-android" id="bare-metal-on-android">Bare-Metal on Android</a></h1>
<p>如需在 AOSP 中构建裸机 Rust 二进制文件，应使用 <code>rust_ffi_static</code> Soong 规则来构建 Rust 代码，然后通过 <code>cc_binary</code> 和链接器脚本生成二进制文件本身，再使用 <code>raw_binary</code> 将 ELF 转换为可以正常运行的原始二进制文件。</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-soong">rust_ffi_static {
    name: &quot;libvmbase_example&quot;,
    defaults: [&quot;vmbase_ffi_defaults&quot;],
    crate_name: &quot;vmbase_example&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libvmbase&quot;,
    ],
}

cc_binary {
    name: &quot;vmbase_example&quot;,
    defaults: [&quot;vmbase_elf_defaults&quot;],
    srcs: [
        &quot;idmap.S&quot;,
    ],
    static_libs: [
        &quot;libvmbase_example&quot;,
    ],
    linker_scripts: [
        &quot;image.ld&quot;,
        &quot;:vmbase_sections&quot;,
    ],
}

raw_binary {
    name: &quot;vmbase_example_bin&quot;,
    stem: &quot;vmbase_example.bin&quot;,
    src: &quot;:vmbase_example&quot;,
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<h1><a class="header" href="#vmbase" id="vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/main/libs/libvmbase/">vmbase</a> library provides a linker script and useful defaults for the build rules, along with an entry point, UART console logging and more.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>main!</code> 宏用于标记需从 <code>vmbase</code> 入口点调用的 main 函数。</li>
<li><code>vmbase</code> 入口点用于处理控制台初始化，并在 main 函数返回时发送 PSCI_SYSTEM_OFF 命令以关闭虚拟机。</li>
</ul>
</details>
<h1><a class="header" href="#习题-1" id="习题-1">习题</a></h1>
<p>我们将为 PL031 实时时钟设备编写驱动程序。</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<h1><a class="header" href="#rtc-驱动程序" id="rtc-驱动程序">RTC 驱动程序</a></h1>
<p>QEMU aarch64 虚拟机在 0x9010000 地址处 配备了 <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> 实时时钟。对于本练习，应该为其编写驱动程序。</p>
<ol>
<li>使用该时钟可将当前时间输出到串行控制台。您可以使用 <a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate 设置日期/时间格式。</li>
<li>通过匹配寄存器和原始中断状态，使得系统在某段指定的时间内一直进行繁忙等待（例如 3 秒后）。（在循环操作中调用 <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a>。）</li>
<li>_进行扩展（如有时间）：_启用并处理由 RTC 匹配产生的中断。可以使用 <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate 中提供的驱动程序来配置 Arm 通用中断控制器。
<ul>
<li>请使用 RTC 中断，将其作为 <code>IntId::spi(2)</code> 连接到 GIC。</li>
<li>启用中断后，可以通过 <code>arm_gic::wfi()</code> 让核心进入休眠状态，直到它收到中断信号。</li>
</ul>
</li>
</ol>
<p>下载 <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">练习模板</a> 并在 <code>rtc</code> 目录中查找以下文件。</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>src/exceptions.rs</em>（只需在本练习的第 3 部分更改此项）：</p>
<!-- File src/exceptions.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    trace!(&quot;irq_current&quot;);
    let intid =
        GicV3::get_and_acknowledge_interrupt().expect(&quot;No pending interrupt&quot;);
    info!(&quot;IRQ {intid:?}&quot;);
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/logger.rs</em>（无需对此进行更改）：</p>
<!-- File src/logger.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/pl011.rs</em>（无需对此进行更改）：</p>
<!-- File src/pl011.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            (&amp;raw mut (*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { (&amp;raw const (*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}
</span></code></pre></pre>
<p><em>Cargo.toml</em>（无需对此进行更改）：</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;rtc&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
arm-gic = &quot;0.1.2&quot;
bitflags = &quot;2.6.0&quot;
chrono = { version = &quot;0.4.38&quot;, default-features = false }
log = &quot;0.4.22&quot;
smccc = &quot;0.1.1&quot;
spin = &quot;0.9.8&quot;

[build-dependencies]
cc = &quot;1.2.2&quot;
</code></pre>
<p><em>build.rs</em>（无需对此进行更改）：</p>
<!-- File build.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-none-elf&quot;);
    env::set_var(&quot;CC&quot;, &quot;clang&quot;);

    Build::new()
        .file(&quot;entry.S&quot;)
        .file(&quot;exceptions.S&quot;)
        .file(&quot;idmap.S&quot;)
        .compile(&quot;empty&quot;)
}
</code></pre></pre>
<p><em>entry.S</em>（无需对此进行更改）：</p>
<!-- File entry.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, &quot;ax&quot;
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><em>exceptions.S</em>（无需对此进行更改）：</p>
<!-- File exceptions.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, &quot;ax&quot;
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><em>idmap.S</em>（无需对此进行更改）</p>
<!-- File idmap.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section &quot;.rodata.idmap&quot;, &quot;a&quot;, %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><em>image.ld</em>（无需对此进行更改）：</p>
<!-- File image.ld -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><em>Makefile</em>（无需对此进行更改）：</p>
<!-- File Makefile -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	cargo objcopy -- -O binary $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><em>.cargo/config.toml</em>（无需对此进行更改）：</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = &quot;aarch64-unknown-none&quot;
rustflags = [&quot;-C&quot;, &quot;link-arg=-Timage.ld&quot;]
</code></pre>
<p>使用 <code>make qemu</code> 在 QEMU 中运行代码。</p>
<h1><a class="header" href="#嵌入式-rust进阶篇" id="嵌入式-rust进阶篇">嵌入式 Rust：进阶篇</a></h1>
<h2><a class="header" href="#rtc-驱动程序-1" id="rtc-驱动程序-1">RTC 驱动程序</a></h2>
<p>(<a href="exercises/bare-metal/rtc.html">返回练习</a>)</p>
<p><em>main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and
    // nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!(&quot;RTC: {time}&quot;);

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!(&quot;Waiting for {}&quot;, Utc.timestamp_opt(target.into(), 0).unwrap());
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!(&quot;Waiting for {}&quot;, Utc.timestamp_opt(target.into(), 0).unwrap());
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>pl031.rs</em>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { (&amp;raw const (*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { (&amp;raw const (*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).icr).write_volatile(0x01) }
    }
}

// SAFETY: `Rtc` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#欢迎了解-rust-中的并发" id="欢迎了解-rust-中的并发">欢迎了解 Rust 中的并发</a></h1>
<p>Rust 完全支持使用带有互斥锁和通道的操作系统线程进行并发。</p>
<p>Rust 类型系统能帮助我们把许多并发bug转换为编译期bug 发挥着重要作用。这通常称为“无畏并发”，因为你可以依靠编译器来确保 运行时的正确性。</p>
<h2><a class="header" href="#时间表-4" id="时间表-4">时间表</a></h2>
<p>{{%session outline}}</p>
<details>
<ul>
<li>Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc.</li>
<li>The type system gives us safety for concurrency without any special features.</li>
<li>The same tools that help with &quot;concurrent&quot; access in a single thread (e.g., a called function that might mutate an argument or save references to it to read later) save us from multi-threading issues.</li>
</ul>
</details><h1><a class="header" href="#线程" id="线程">线程</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#plain-threads" id="plain-threads">Plain Threads</a></h1>
<p>Rust 线程的运作方式与其他语言中的线程类似：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 0..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 0..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>Spawning new threads does not automatically delay program termination at the end of <code>main</code>.</li>
<li>线程紧急警报 (panic) 是彼此独立的。
<ul>
<li>Panics can carry a payload, which can be unpacked with <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>Any::downcast_ref</code></a>.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>
<p>Run the example.</p>
<ul>
<li>5ms timing is loose enough that main and spawned threads stay mostly in lockstep.</li>
<li>Notice that the program ends before the spawned thread reaches 10!</li>
<li>This is because <code>main</code> ends the program and spawned threads do not make it persist.
<ul>
<li>Compare to <code>pthreads</code>/C++ <code>std::thread</code>/<code>boost::thread</code> if desired.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How do we wait around for the spawned thread to complete?</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a> returns a <code>JoinHandle</code>. Look at the docs.</p>
<ul>
<li><code>JoinHandle</code> has a <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> method that blocks.</li>
</ul>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for the thread to finish and have the program count all the way to 10.</p>
</li>
<li>
<p>Now what if we want to return a value?</p>
</li>
<li>
<p>Look at docs again:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>'s closure returns <code>T</code></li>
<li><code>JoinHandle</code> <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> returns <code>thread::Result&lt;T&gt;</code></li>
</ul>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the returned value.</p>
</li>
<li>
<p>Ok, what about the other case?</p>
<ul>
<li>Trigger a panic in the thread. Note that this doesn't panic <code>main</code>.</li>
<li>Access the panic payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</li>
</ul>
</li>
<li>
<p>Now we can return values from threads! What about taking inputs?</p>
<ul>
<li>Capture something by reference in the thread closure.</li>
<li>An error message indicates we must move it.</li>
<li>Move it in, see we can compute and then return a derived value.</li>
</ul>
</li>
<li>
<p>If we want to borrow?</p>
<ul>
<li>Main kills child threads when it returns, but another function would just return and leave them running.</li>
<li>That would be stack use-after-return, which violates memory safety!</li>
<li>How do we avoid this? See next slide.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#范围线程" id="范围线程">范围线程</a></h1>
<p>常规线程不能从它们所处的环境中借用：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<p>不过，你可以使用<a href="https://doc.rust-lang.org/std/thread/fn.scope.html">范围线程</a>来实现此目的：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<details>
<ul>
<li>其原因在于，在 <code>thread::scope</code> 函数完成后，可保证所有线程都已联结在一起，使得线程能够返回借用的数据。</li>
<li>此时须遵守常规 Rust 借用规则：你可以通过一个线程以可变的方式借用，也可以通过任意数量的线程以不可变的方式借用。</li>
</ul>
</details><h1><a class="header" href="#通道" id="通道">通道</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#senders-and-receivers" id="senders-and-receivers">Senders and Receivers</a></h1>
<p>Rust channels have two parts: a <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender&lt;T&gt;</code></a> and a <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html"><code>Receiver&lt;T&gt;</code></a>. The two parts are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>mpsc</code></a> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code> implement <code>Clone</code> (so you can make multiple producers) but <code>Receiver</code> does not.</li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send"><code>send()</code></a> and <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv()</code></a> return <code>Result</code>. If they return <code>Err</code>, it means the counterpart <code>Sender</code> or <code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details>
<h1><a class="header" href="#无界通道" id="无界通道">无界通道</a></h1>
<p>You get an unbounded and asynchronous channel with <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#有界通道" id="有界通道">有界通道</a></h1>
<p>With bounded (synchronous) channels, <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.SyncSender.html#method.send"><code>send()</code></a> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Calling <code>send()</code> will block the current thread until there is space in the channel for the new message. The thread can be blocked indefinitely if there is nobody who reads from the channel.</li>
<li>A call to <code>send()</code> will abort with an error (that is why it returns <code>Result</code>) if the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a &quot;rendezvous channel&quot;. Every send will block the current thread until another thread calls <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv()</code></a>.</li>
</ul>
</details>
<h1><a class="header" href="#send-和-sync" id="send-和-sync"><code>Send</code> 和 <code>Sync</code></a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#marker-traits" id="marker-traits">Marker Traits</a></h1>
<p>How does Rust know to forbid shared access across threads? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>：如果跨线程边界移动 <code>T</code> 是安全的，则类型 <code>T</code> 为 <code>Send</code>。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>：如果跨线程边界移动 <code>&amp;T</code> 是安全的，则类型 <code>T</code> 为 <code>Sync</code>。</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="concurrency/send-sync/../../unsafe-rust/unsafe-traits.html">unsafe traits</a>. The compiler will automatically derive them for your types as long as they only contain <code>Send</code> and <code>Sync</code> types. You can also implement them manually when you know it is valid.</p>
<details>
<ul>
<li>不妨将这些特征视为类型包含某些线程安全属性的标记。</li>
<li>它们可以在泛型约束中作为常规特征使用。</li>
</ul>
</details><h1><a class="header" href="#send" id="send"><code>Send</code></a></h1>
<blockquote>
<p>如果将 <code>T</code> 值移动到另一个线程是安全的，则类型 <code>T</code> 为 <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>。</p>
</blockquote>
<p>将所有权转移到另一个线程的影响是，“析构函数”将在相应线程中 运行。因此，问题在于你何时可以在一个线程中分配某个值，然后在 另一个线程中取消分配该值。</p>
<details>
<p>例如，与 SQLite 库的连接只能通过 单个线程访问。</p>
</details><h1><a class="header" href="#sync" id="sync"><code>Sync</code></a></h1>
<blockquote>
<p>如果同时从多个线程访问 <code>T</code> 值是安全的，则类型 <code>T</code> 为 <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>。</p>
</blockquote>
<p>更准确地说，定义是：</p>
<blockquote>
<p>当且仅当 <code>&amp;T</code> 为 <code>Send</code> 时，<code>T</code> 为 <code>Sync</code></p>
</blockquote>
<details>
<p>该语句实质上是一种简写形式，表示如果某个类型对于共享使用是线程安全的，那么跨线程传递对该类型的引用也是线程安全的。</p>
<p>这是因为如果某个类型为 Sync，则意味着它可以在多个线程之间共享，而不存在数据争用或其他同步问题的风险，因此将其移动到另一个线程是安全的。对该类型的引用同样可以安全地移动到另一个线程，因为它引用的数据可以从任何线程安全地访问。</p>
</details><h1><a class="header" href="#示例-2" id="示例-2">示例</a></h1>
<h2><a class="header" href="#send--sync" id="send--sync"><code>Send + Sync</code></a></h2>
<p>你遇到的类型大都属于 <code>Send + Sync</code>：</p>
<ul>
<li><code>i8</code>、<code>f32</code>、<code>bool</code>、<code>char</code>、<code>&amp;str</code>…</li>
<li><code>(T1, T2)</code>、<code>[T; N]</code>、<code>&amp;[T]</code>、<code>struct { x: T }</code>…</li>
<li><code>String</code>、<code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>…</li>
<li><code>Arc&lt;T&gt;</code>：明确通过原子引用计数实现线程安全。</li>
<li><code>Mutex&lt;T&gt;</code>：明确通过内部锁定实现线程安全。</li>
<li><code>mpsc::Sender&lt;T&gt;</code>: As of 1.72.0.</li>
<li><code>AtomicBool</code>、<code>AtomicU8</code>…：使用特殊的原子指令。</li>
</ul>
<p>当类型参数为 <code>Send + Sync</code> 时，泛型类型通常 为 <code>Send + Sync</code>。</p>
<h2><a class="header" href="#send--sync-1" id="send--sync-1"><code>Send + !Sync</code></a></h2>
<p>这些类型可以移动到其他线程，但它们不是线程安全的。 这通常是由内部可变性造成的：</p>
<ul>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2><a class="header" href="#send--sync-2" id="send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are safe to access (via shared references) from multiple threads, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T: Sync&gt;</code>: Uses OS level primitives which must be deallocated on the thread which created them. However, an already-locked mutex can have its guarded variable read by any thread with which the guard is shared.</li>
</ul>
<h2><a class="header" href="#send--sync-3" id="send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>这些类型不是线程安全的，不能移动到其他线程：</p>
<ul>
<li><code>Rc&lt;T&gt;</code>：每个 <code>Rc&lt;T&gt;</code> 都具有对 <code>RcBox&lt;T&gt;</code> 的引用，其中包含 非原子引用计数。</li>
<li><code>*const T</code>、<code>*mut T</code>：Rust 会假定原始指针可能 在并发方面有特殊的注意事项。</li>
</ul>
<h1><a class="header" href="#共享状态" id="共享状态">共享状态</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#arc" id="arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> 允许通过 <code>Arc::clone</code> 实现共享只读权限：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Arc;
use std::thread;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 0..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Arc</code> 代表“原子引用计数”，它是使用原子操作的 <code>Rc</code> 的 线程安全版本。</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> 在执行原子操作方面有开销，但在此之后，<code>T</code> 便可 随意使用，而没有任何开销。</li>
<li>请警惕引用循环，<code>Arc</code> 不会使用垃圾回收器检测引用循环。
<ul>
<li><code>std::sync::Weak</code> 对此有所帮助。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#互斥器mutex" id="互斥器mutex">互斥器（<code>Mutex</code>）</a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code> behind a read-only interface (another form of <a href="concurrency/shared-state/../../borrowing/interior-mutability.html">interior mutability</a>):</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>请注意我们如何设置 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> 通用 实现。</p>
<details>
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element --- the protected data.
<ul>
<li>在访问受保护的数据之前不可能忘记获取互斥量。</li>
</ul>
</li>
<li>你可以通过获取锁，从 <code>&amp;Mutex&lt;T&gt;</code> 中获取 <code>&amp;mut T</code>。<code>MutexGuard</code> 能够确保 <code>&amp;mut T</code> 存在的时间不会比持有锁的时间更长。</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements <code>Send</code>.</li>
<li>A read-write lock counterpart: <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>?
<ul>
<li>如果持有 <code>Mutex</code> 的线程发生panic，<code>Mutex</code> 便会“中毒”并发出信号， 表明其所保护的数据可能处于不一致状态。对中毒的互斥量调用 <code>lock()</code> 将会失败， 并将显示 <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>。无论如何，你可以对该错误调用 <code>into_inner()</code> 来 恢复数据。</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#示例-3" id="示例-3">示例</a></h1>
<p>让我们看看 <code>Arc</code> 和 <code>Mutex</code> 的实际效果：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>可能有用的解决方案：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<p>值得注意的部分：</p>
<ul>
<li><code>Arc</code> 和 <code>Mutex</code> 中都封装了 <code>v</code>，因为它们的关注点是正交的。
<ul>
<li>将 <code>Mutex</code> 封装在 <code>Arc</code> 中是一种在线程之间共享可变状态的常见模式。</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> 必须先克隆为 <code>v2</code>，然后才能移动到另一个线程中。请注意，lambda 签名中添加了 <code>move</code>。</li>
<li>我们引入了块，以尽可能缩小 <code>LockGuard</code> 的作用域。</li>
</ul>
</details><h1><a class="header" href="#习题-2" id="习题-2">习题</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#哲学家就餐问题" id="哲学家就餐问题">哲学家就餐问题</a></h1>
<p>哲学家用餐示例是一个典型的并发问题：</p>
<blockquote>
<p>五位哲学家在同一桌子上用餐。每位哲学家在桌前都有自己的座位。每个盘子之间都有一把叉子。上的菜品是一种意大利面，需要用两把叉子才能吃。每位哲学家只能交替进行思考和用餐。此外，只有当哲学家们同时拿到左边和右边的叉子才能吃这个意大利面。因此，只有当两旁坐着的人在思考，而非在吃面时，他们才能使用两把叉子。每位哲学家吃完饭后，就会放下手中的两把叉子。</p>
</blockquote>
<p>在本练习中，需要使用本地 <a href="concurrency/sync-exercises/../../cargo/running-locally.html">Cargo 安装</a>。将以下代码复制到名为 <code>src/main.rs</code> 的文件中，并填写空白的地方，然后测试 <code>cargo run</code> 不会死锁：</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}
</code></pre></pre>
<p>您可以使用以下 <code>Cargo.toml</code>：</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<h1><a class="header" href="#多线程链接检查器" id="多线程链接检查器">多线程链接检查器</a></h1>
<p>运用掌握的新知识创建一个多线程链接检查工具。应先从网页入手，并检查网页上的链接是否有效。该工具应以递归方式检查同一网域中的其他网页，并且一直执行此操作，直到所有网页都通过验证。</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. You will also need a way to find links, we can use <a href="https://docs.rs/scraper/"><code>scraper</code></a>. Finally, we'll need some way of handling errors, we will use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a>.</p>
<p>Create a new Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
cargo add scraper
cargo add thiserror
</code></pre>
<blockquote>
<p>如果 <code>cargo add</code> 操作失败并显示 <code>error: no such subcommand</code>，请手动修改 <code>Cargo.toml</code> 文件。添加下面列出的依赖项。</p>
</blockquote>
<p><code>cargo add</code> 调用会将 <code>Cargo.toml</code> 文件更新为如下所示：</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;link-checker&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>您现在可以下载初始页了。请尝试使用一个小网站，例如 <code>https://www.google.org/</code>。</p>
<p>您的 <code>src/main.rs</code> 文件应如下所示：</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>使用以下命令运行 <code>src/main.rs</code> 中的代码</p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2><a class="header" href="#任务" id="任务">任务</a></h2>
<ul>
<li>通过线程并行检查链接：将要检查的网址发送到某个通道，然后使用多个线程并行检查这些网址。</li>
<li>您可以对此进行扩展，以递归方式从 <code>www.google.org</code> 网域的所有网页中提取链接。设置网页上限（例如 100 个），以免被网站屏蔽。</li>
</ul>
<h1><a class="header" href="#解答-19" id="解答-19">解答</a></h1>
<h2><a class="header" href="#哲学家就餐问题-1" id="哲学家就餐问题-1">哲学家就餐问题</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        println!(&quot;{} is trying to eat&quot;, &amp;self.name);
        let _left = self.left_fork.lock().unwrap();
        let _right = self.right_fork.lock().unwrap();

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

fn main() {
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!(&quot;{thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#link-checker" id="link-checker">Link Checker</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;

use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState { domain: start_url.domain().unwrap().to_string(), visited_pages }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning false if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!(&quot;Got crawling error: {:#}&quot;, error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let bad_urls = check_links(start_url);
    println!(&quot;Bad URLs: {:#?}&quot;, bad_urls);
}
</code></pre></pre>
<h1><a class="header" href="#欢迎" id="欢迎">欢迎</a></h1>
<p>“异步”是一种并发模型，可以同时执行多个任务。具体做法是逐个执行任务直至阻塞，然后切换到另一项可以继续进行的任务。该模型支持在有限数量的线程上运行更多任务。原因在于，每个任务的开销通常很低，并且操作系统提供了基元来高效识别能够执行的 I/O 任务。</p>
<p>Rust 的异步操作基于 &quot;Futures&quot; 来实现，即表示未来可能完成的工作。系统会对这些 Future 进行 “轮询”，直到显示全部已完成。</p>
<p>由异步运行时对这些 Future 进行轮询，并且有多种不同的运行时可供选择。</p>
<h2><a class="header" href="#比较-1" id="比较-1">比较</a></h2>
<ul>
<li>
<p>Python 的 <code>asyncio</code> 中也有类似的模型。不过，其 <code>Future</code> 类型基于回调的实现方式，而非通过轮询。使用异步 Python 程序需要类似于 Rust 中运行时的 “循环” 进行管理。</p>
</li>
<li>
<p>JavaScript 的 <code>Promise</code> 与之类似，但同样基于回调的实现方式。语言运行时实现了事件循环，因此许多与 Promise 解析相关的细节被隐藏起来。</p>
</li>
</ul>
<h2><a class="header" href="#时间表-5" id="时间表-5">时间表</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#异步基础" id="异步基础">异步基础</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>从高层次上看，异步 Rust 代码与“正常”的顺序代码非常类似：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 0..count {
        println!(&quot;Count is: {i}!&quot;);
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}
</code></pre></pre>
<details>
<p>关键点：</p>
<ul>
<li>
<p>请注意，这只是一个简单的示例，用于展示语法。其中没有长时间运行的操作或任何真正的并发！</p>
</li>
<li>
<p>The &quot;async&quot; keyword is syntactic sugar. The compiler replaces the return type with a future.</p>
</li>
<li>
<p>你不能将 <code>main</code> 声明为异步函数，除非在编译器中加入额外的指令来告诉它如何使用返回的 future。</p>
</li>
<li>
<p>You need an executor to run async code. <code>block_on</code> blocks the current thread until the provided future has run to completion.</p>
</li>
<li>
<p><code>.await</code> 会异步地等待另一个操作的完成。与 <code>block_on</code> 不同，<code>.await</code> 不会阻塞当前线程。</p>
</li>
<li>
<p><code>.await</code> can only be used inside an <code>async</code> function (or block; these are introduced later).</p>
</li>
</ul>
</details><h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> 是一种 trait，由表示尚未完成的操作的对象所实现。可以轮询 Future，并且 <code>poll</code> 会返回 一个 <a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a> 对象。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>异步函数会返回 <code>impl Future</code>。对于自定义的类型，也可以实现 <code>Future</code>（但不常见）。例如，从 <code>tokio::spawn</code> 返回的 <code>JoinHandle</code> 会实现 <code>Future</code>，以允许加入该任务。</p>
<p>在 Future 中使用 <code>.await</code> 关键字会导致当前异步函数暂停，直到该 Future 准备就绪，然后计算其输出。</p>
<details>
<ul>
<li>
<p><code>Future</code> 和 <code>Poll</code> 类型的实现完全如下所示：请点击链接查看文档中的实现。</p>
</li>
<li>
<p>我们的重点在于编写异步代码，而不是构建新的异步基元，因此不会涉及 <code>Pin</code> 和 <code>Context</code>。简言之：</p>
<ul>
<li>
<p>通过 <code>Context</code>，Future 在事件发生时可自行安排重新进行轮询。</p>
</li>
<li>
<p><code>Pin</code> 确保 Future 不会移到内存中，以便指向该 Future 的指针仍然有效。为了确保使用 <code>.await</code> 之后引用依然有效，必须执行此操作。</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#runtimes" id="runtimes">Runtimes</a></h1>
<p><em>运行时</em> 支持异步执行操作（即 _反应器），并负责执行 Future （即 _执行器）。Rust 没有 “内置”运行时，但有以下几个选项可供选择：</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>：性能出色，拥有成熟的功能生态系统，例如适用于 HTTP 的 <a href="https://hyper.rs/">Hyper</a> 或 适用于 gRPC 的 <a href="https://github.com/hyperium/tonic">Tonic</a>。</li>
<li><a href="https://async.rs/">async-std</a>：旨在成为 “异步编程的标准库”，并在 <code>async::task</code> 中包含基本运行时。</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>：简单且轻量</li>
</ul>
<p>有些大型应用具有自己的运行时。例如，<a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a> 已有一个运行时。</p>
<details>
<ul>
<li>
<p>请注意，在列出的运行时中，Rust Playground 仅支持 Tokio。该 Playground 也不支持任何 I/O 操作，因此大多数有趣的异步操作无法在该平台上运行。</p>
</li>
<li>
<p>Future 是 “惯性”的，除非有执行程序对其进行轮询，否则它们不会执行任何操作（甚至不会启动 I/O 操作）。这与 JS promise 不同，例如，后者即使从未使用也会完成运行过程。</p>
</li>
</ul>
</details><h1><a class="header" href="#tokio" id="tokio">Tokio</a></h1>
<p>Tokio provides:</p>
<ul>
<li>用于执行异步代码的多线程运行时。</li>
<li>An asynchronous version of the standard library.</li>
<li>庞大的库生态系统。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::time;

async fn count_to(count: i32) {
    for i in 0..count {
        println!(&quot;Count in task: {i}!&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 0..5 {
        println!(&quot;Main task: {i}&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>借助 <code>tokio::main</code> 宏，我们现在可以将 <code>main</code> 设为异步函数。</p>
</li>
<li>
<p><code>spawn</code> 函数会创建新的并发 “任务”。</p>
</li>
<li>
<p>注意：<code>spawn</code> 使用 <code>Future</code> 方法实现，而不是对 <code>count_to</code> 调用 <code>.await</code>。</p>
</li>
</ul>
<p><strong>深入探索</strong>：</p>
<ul>
<li>
<p>为何 <code>count_to</code> 通常无法计数到 10？这是一个异步取消的示例。<code>tokio::spawn</code> 会返回一个句柄，可以等待该句柄直至其代表的任务执行完毕。</p>
</li>
<li>
<p>尝试使用 <code>count_to(10).await</code>，而不是派生方法。</p>
</li>
<li>
<p>尝试等待 <code>tokio::spawn</code> 返回的任务执行完毕。</p>
</li>
</ul>
</details>
<h1><a class="header" href="#任务-1" id="任务-1">任务</a></h1>
<p>Rust 有一个任务系统，这是一种轻量级线程处理形式。</p>
<p>每个任务只有一个顶级 Future，执行器会对此进行轮询来推进任务进度。该 Future 可能包含一个或多个嵌套的 Future，可以通过其 <code>poll</code> 方法对它们进行轮询，类似于调用堆栈。可以通过轮询多个子 Future（例如争用定时器和 I/O 操作）在任务内部实现并发操作。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:0&quot;).await?;
    println!(&quot;listening on port {}&quot;, listener.local_addr()?.port());

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!(&quot;connection from {addr:?}&quot;);

        tokio::spawn(async move {
            socket.write_all(b&quot;Who are you?\n&quot;).await.expect(&quot;socket error&quot;);

            let mut buf = vec![0; 1024];
            let name_size = socket.read(&amp;mut buf).await.expect(&quot;socket error&quot;);
            let name = std::str::from_utf8(&amp;buf[..name_size]).unwrap().trim();
            let reply = format!(&quot;Thanks for dialing in, {name}!\n&quot;);
            socket.write_all(reply.as_bytes()).await.expect(&quot;socket error&quot;);
        });
    }
}
</code></pre></pre>
<details>
<p>将此示例复制到准备好的 <code>src/main.rs</code> 文件中，并从该文件运行它。</p>
<p>请尝试使用像 <a href="https://www.unix.com/man-page/linux/1/nc/">nc</a> 或 <a href="https://www.unix.com/man-page/linux/1/telnet/">telnet</a> 这样的 TCP 连接工具进行连接。</p>
<ul>
<li>
<p>让学生想象一下，当连接多个客户端时，示例服务器会达到怎样的状态。存在哪些任务？具有哪些 Future？</p>
</li>
<li>
<p>This is the first time we've seen an <code>async</code> block. This is similar to a closure, but does not take any arguments. Its return value is a Future, similar to an <code>async fn</code>.</p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using <code>?</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#channels-and-control-flow" id="channels-and-control-flow">Channels and Control Flow</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#异步通道" id="异步通道">异步通道</a></h1>
<p>有些 crate 支持使用异步通道。例如 <code>tokio</code>：</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc;

async fn ping_handler(mut input: mpsc::Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!(&quot;Received {count} pings so far.&quot;);
    }

    println!(&quot;ping_handler complete&quot;);
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect(&quot;Failed to send ping.&quot;);
        println!(&quot;Sent {} pings so far.&quot;, i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect(&quot;Something went wrong in ping handler task.&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>将通道大小更改为 <code>3</code>，然后看看对操作执行会有什么影响。</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the <a href="concurrency/async-control-flow/../channels.html">morning class</a>.</p>
</li>
<li>
<p>尝试移除 <code>std::mem::drop</code> 调用。会出现什么情况？这是为什么？</p>
</li>
<li>
<p><a href="https://docs.rs/flume/latest/flume/">Flume</a> crate 包含可以同时实现 <code>sync</code>、<code>async</code> <code>send</code> 和 <code>recv</code> 的渠道，为涉及 IO 和大量 CPU 处理任务的复杂应用提供了极大便利。</p>
</li>
<li>
<p>使用 <code>async</code> 通道的优势在于，我们能够将它们与其他 <code>future</code> 结合起来，从而创建复杂的控制流。</p>
</li>
</ul>
</details><h1><a class="header" href="#加入" id="加入">加入</a></h1>
<p>联接操作会等待一组 Future 全部就绪，然后返回它们的结果集合。这类似于 JavaScript 中的 <code>Promise.al</code> 或 Python 中的 <code>asyncio.gather</code>。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        &quot;https://google.com&quot;,
        &quot;https://httpbin.org/ip&quot;,
        &quot;https://play.rust-lang.org/&quot;,
        &quot;BAD_URL&quot;,
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(&quot;{page_sizes_dict:?}&quot;);
}
</code></pre></pre>
<details>
<p>将此示例复制到准备好的 <code>src/main.rs</code> 文件中，并从该文件运行它。</p>
<ul>
<li>
<p>对于多个类型不相交的 Future，可以使用 <code>std::future::join!</code> 进行处理，但必须要确定在编译时 Future 的数量。目前，可在 <code>futures</code> crate 中使用该功能，但很快也会在 <code>std::future</code> 中正式发布。</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would cause your program to stall.</p>
</li>
<li>
<p>还可以将 <code>join_all</code> 与 <code>join!</code> 结合使用，并行处理所有对 http 服务的请求和数据库查询。尝试使用 <code>futures::join!</code> 将 <code>tokio::time::sleep</code> 添加到 Future 中。这不是一个超时操作（其需要使用 <code>select!</code>，下一章会详细介绍），而是展示了 <code>join!</code> 的使用方式。</p>
</li>
</ul>
</details><h1><a class="header" href="#选择" id="选择">选择</a></h1>
<p>选择操作会等待一组 Future 中的任意一个就绪，并对 Future 产生的结果进行响应。在 JavaScript 中，该操作类似于 <code>Promise.race</code>。在 Python 中，它相当于 <code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>。</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each of the form <code>pattern = future =&gt; statement</code>. When a <code>future</code> is ready, its return value is destructured by the <code>pattern</code>. The <code>statement</code> is then run with the resulting variables. The <code>statement</code> result becomes the result of the <code>select!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let listener = tokio::spawn(async move {
        tokio::select! {
            Some(msg) = rx.recv() =&gt; println!(&quot;got: {msg}&quot;),
            _ = sleep(Duration::from_millis(50)) =&gt; println!(&quot;timeout&quot;),
        };
    });
    sleep(Duration::from_millis(10)).await;
    tx.send(String::from(&quot;Hello!&quot;)).await.expect(&quot;Failed to send greeting&quot;);

    listener.await.expect(&quot;Listener failed&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>listener</code> async block here is a common form: wait for some async event, or for a timeout. Change the <code>sleep</code> to sleep longer to see it fail. Why does the <code>send</code> also fail in this situation?</p>
</li>
<li>
<p><code>select!</code> is also often used in a loop in &quot;actor&quot; architectures, where a task reacts to events in a loop. That has some pitfalls, which will be discussed in the next segment.</p>
</li>
</ul>
</details><h1><a class="header" href="#误区" id="误区">误区</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent asynchronous programming. However, the async/await model in Rust also comes with its share of pitfalls and footguns. We illustrate some of them in this chapter.</p>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#阻塞执行器" id="阻塞执行器">阻塞执行器</a></h1>
<p>大多数异步运行时支持并发运行 IO 任务。这意味着 CPU 的阻塞性任务会阻塞执行器，并阻止执行其他任务。最简单的方法是，尽可能使用异步等效方法。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        &quot;future {id} slept for {duration_ms}ms, finished after {}ms&quot;,
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>运行该代码，您会发现休眠操作是连续发生的，而不是并发进行的。</p>
</li>
<li>
<p><code>&quot;current_thread&quot;</code> 变种将所有任务放在单个线程上。这样做效果会更明显，但 bug 仍然存在于多线程变种中。</p>
</li>
<li>
<p>将 <code>std::thread::sleep</code> 切换为 <code>tokio::time::sleep</code>，并等待结果。</p>
</li>
<li>
<p>另一个修复方案是 <code>tokio::task::spawn_blocking</code>，其会生成实际线程并将句柄转换为 Future，且不会阻塞执行器。</p>
</li>
<li>
<p>不应将任务视为操作系统线程。它们之间并非一对一的映射关系，并且大多数执行器都支持在单个操作系统线程上运行多个任务。尤其是通过 FFI 与其他库交互时，会更容易出现问题，因为在 FFI 中，因为该库可能依赖于线程本地存储或映射到特定的操作系统线程（例如，CUDA）。在这些情况下，首选 <code>tokio::task::spawn_blocking</code>。</p>
</li>
<li>
<p>请谨慎使用同步互斥操作。对 <code>.await</code> 一直执行互斥操作能会导致另一个任务阻塞，并且该任务可能与其在同一线程上运行。</p>
</li>
</ul>
</details><h1><a class="header" href="#pin" id="pin"><code>Pin</code></a></h1>
<p>Async blocks and functions return types implementing the <code>Future</code> trait. The type returned is the result of a compiler transformation which turns local variables into data stored inside the future.</p>
<p>Some of those variables can hold pointers to other local variables. Because of that, the future should never be moved to a different memory location, as it would invalidate those pointers.</p>
<p>To prevent moving the future type in memory, it can only be polled through a pinned pointer. <code>Pin</code> is a wrapper around a reference that disallows all operations that would move the instance it points to into a different memory location.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect(&quot;failed to send response&quot;);
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work { input, respond_on: tx })
        .await
        .expect(&quot;failed to send on work queue&quot;);
    rx.await.expect(&quot;failed waiting for response&quot;)
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!(&quot;work result for iteration {i}: {resp}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>您可能认为这是执行器模式的一个示例。执行器通常会循环调用 <code>select!</code>。</p>
</li>
<li>
<p>本部分是对前面几节课的总结，因此请多花时间用心学习。</p>
<ul>
<li>
<p>只是单纯地在 <code>select!</code> 中添加 <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code>，该行代码将不会执行任何操作。这是为什么？</p>
</li>
<li>
<p>请改为在 <code>loop</code> 外部添加包含该 Future 的 <code>timeout_fut</code>：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>这仍然不起作用。根据编译器提示的错误，通过向 <code>select!</code> 中的 <code>timeout_fut</code> 添加 <code>&amp;mut</code> 解决移动问题，然后使用 <code>Box::pin</code>：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every iteration (a fused future would help with this). Update to reset <code>timeout_fut</code> every time it expires:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        _ = &amp;mut timeout_fut =&gt; {
            println!(..);
            timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Box 在堆上进行分配。在某些情况下，也可以选择使用 <code>std::pin::pin!</code>（最近才正式发布，较旧的代码通常使用 <code>tokio::pin!</code>），但对于重新分配的 Future，使用此功能较为困难。</p>
</li>
<li>
<p>另一种替代方案是完全不使用 <code>pin</code>，而是生成另一个任务，该任务每隔 100 毫秒就会发送到 <code>oneshot</code> 通道。</p>
</li>
<li>
<p>Data that contains pointers to itself is called self-referential. Normally, the Rust borrow checker would prevent self-referential data from being moved, as the references cannot outlive the data they point to. However, the code transformation for async blocks and functions is not verified by the borrow checker.</p>
</li>
<li>
<p><code>Pin</code> is a wrapper around a reference. An object cannot be moved from its place using a pinned pointer. However, it can still be moved through an unpinned pointer.</p>
</li>
<li>
<p>The <code>poll</code> method of the <code>Future</code> trait uses <code>Pin&lt;&amp;mut Self&gt;</code> instead of <code>&amp;mut Self</code> to refer to the instance. That's why it can only be called on a pinned pointer.</p>
</li>
</ul>
</details><h1><a class="header" href="#异步特征" id="异步特征">异步特征</a></h1>
<p>Async methods in traits are were stabilized in the 1.75 release. This required support for using return-position <code>impl Trait</code> in traits, as the desugaring for <code>async fn</code> includes <code>-&gt; impl Future&lt;Output = ...&gt;</code>.</p>
<p>However, even with the native support, there are some pitfalls around <code>async fn</code>:</p>
<ul>
<li>
<p>Return-position <code>impl Trait</code> captures all in-scope lifetimes (so some patterns of borrowing cannot be expressed).</p>
</li>
<li>
<p>Async traits cannot be used with <a href="concurrency/async-pitfalls/../../smart-pointers/trait-objects.html">trait objects</a> (<code>dyn Trait</code> support).</p>
</li>
</ul>
<p>The <a href="https://docs.rs/async-trait/">async_trait</a> crate provides a workaround for <code>dyn</code> support through a macro, with some caveats:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(
    sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;,
    n_times: usize,
) {
    for _ in 0..n_times {
        println!(&quot;Running all sleepers...&quot;);
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!(&quot;Slept for {} ms&quot;, start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>async_trait</code> 易于使用，但请注意，它通过堆分配来实现这一点。这种堆分配会产生性能开销。</p>
</li>
<li>
<p>The challenges in language support for <code>async trait</code> are too deep to describe in-depth in this class. See <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">this blog post</a> by Niko Matsakis if you are interested in digging deeper. See also these keywords:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/types/impl-trait.html#abstract-return-types">RPIT</a>: short for <a href="concurrency/async-pitfalls/../../generics/impl-trait.html">return-position <code>impl Trait</code></a>.</li>
<li><a href="https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html">RPITIT</a>: short for return-position <code>impl Trait</code> in trait (RPIT in trait).</li>
</ul>
</li>
<li>
<p>Try creating a new sleeper struct that will sleep for a random amount of time and adding it to the <code>Vec</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#消除" id="消除">消除</a></h1>
<p>丢弃 Future 意味着无法再对其进行轮询。这称为 <em>取消</em>，在任何 <code>await</code> 点都可能发生。请务必小心谨慎，确保即使 Future 任务被取消，系统也能正常运行。例如，系统不应死锁或丢失数据。</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io;
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None);
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy(&quot;hi\nthere\n&quot;.to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!(&quot;tick!&quot;),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!(&quot;{}&quot;, l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>
<p>编译器无法确保取消操作的安全性。您需要阅读 API 文档，并考虑 <code>async fn</code> 所持状态。</p>
</li>
<li>
<p>与 <code>panic</code> 和 <code>?</code> 不同，取消属于正常控制流的一部分（而非错误处理）。</p>
</li>
<li>
<p>该示例丢失了字符串的某些部分。</p>
<ul>
<li>
<p>每当 <code>tick()</code> 分支先完成操作时，<code>next() 及其 </code>buf` 均会被丢弃。</p>
</li>
<li>
<p>通过将 <code>buf</code> 整合到结构体中，`LinesReader 可以确保取消操作的安全性：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a> is cancellation-safe because it keeps track of whether a tick has been 'delivered'.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a> is cancellation-safe because it either returns or doesn't read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a> is similar to the example and <em>isn't</em> cancellation-safe. See its documentation for details and alternatives.</p>
</li>
</ul>
</details><h1><a class="header" href="#习题-3" id="习题-3">习题</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#dining-philosophers-----async" id="dining-philosophers-----async">Dining Philosophers --- Async</a></h1>
<p>See <a href="concurrency/async-exercises/../sync-exercises/dining-philosophers.html">dining philosophers</a> for a description of the problem.</p>
<p>As before, you will need a local <a href="concurrency/async-exercises/../../cargo/running-locally.html">Cargo installation</a> for this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<p>因为这次您正在使用异步Rust，您将需要一个 <code>tokio</code> 依赖。您可以使用以下的 <code>Cargo.toml</code>：</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers-async-dine&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tokio = { version = &quot;1.26.0&quot;, features = [&quot;sync&quot;, &quot;time&quot;, &quot;macros&quot;, &quot;rt-multi-thread&quot;] }
</code></pre>
<p>另外，请注意，这次您必须使用来自 <code>tokio</code> 包的 <code>Mutex</code> 和 <code>mpsc</code> 模块。</p>
<details>
<ul>
<li>Can you make your implementation single-threaded?</li>
</ul>
</details><h1><a class="header" href="#广播聊天应用" id="广播聊天应用">广播聊天应用</a></h1>
<p>在本练习中，我们想要使用我们的新知识来实现一个广播聊天应用。我们有一个聊天服务器，客户端连接到该服务器并发布他们的消息。客户端从标准输入读取用户消息，并将其发送到服务器。聊天服务器将收到的每条消息广播给所有客户端。</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and <a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a> for the communication between the client and the server.</p>
<p>创建一个新的 Cargo 项目并添加以下依赖：</p>
<p><em>Cargo.toml</em>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;chat-async&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
futures-util = { version = &quot;0.3.31&quot;, features = [&quot;sink&quot;] }
http = &quot;1.1.0&quot;
tokio = { version = &quot;1.41.1&quot;, features = [&quot;full&quot;] }
tokio-websockets = { version = &quot;0.10.1&quot;, features = [&quot;client&quot;, &quot;fastrand&quot;, &quot;server&quot;, &quot;sha1_smol&quot;] }
</code></pre>
<h2><a class="header" href="#所需的api" id="所需的api">所需的API</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and <a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the API.</p>
<ul>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next">StreamExt::next()</a> implemented by <code>WebSocketStream</code>: for asynchronously reading messages from a Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> implemented by <code>WebSocketStream</code>: for asynchronously sending messages on a Websocket Stream.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages from the standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>：用于订阅广播频道。</li>
</ul>
<h2><a class="header" href="#两个可执行文件" id="两个可执行文件">两个可执行文件</a></h2>
<p>Normally in a Cargo project, you can have only one binary, and one <code>src/main.rs</code> file. In this project, we need two binaries. One for the client, and one for the server. You could potentially make them two separate Cargo projects, but we are going to put them in a single Cargo project with two binaries. For this to work, the client and the server code should go under <code>src/bin</code> (see the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">documentation</a>).</p>
<p>Copy the following server and client code into <code>src/bin/server.rs</code> and <code>src/bin/client.rs</code>, respectively. Your task is to complete these files as described below.</p>
<p><em>src/bin/server.rs</em>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}
</code></pre></pre>
<h2><a class="header" href="#运行可执行文件" id="运行可执行文件">运行可执行文件</a></h2>
<p>Run the server with:</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2><a class="header" href="#任务-2" id="任务-2">任务</a></h2>
<ul>
<li>在 <code>src/bin/server.rs</code> 中实现 <code>handle_connection</code> 函数。
<ul>
<li>提示：使用 <code>tokio::select!</code> 在一个连续的循环中并发执行两个任务。一个任务从客户端接收消息并广播它们。另一个任务将服务器接收到的消息发送给客户端。</li>
</ul>
</li>
<li>完成 <code>src/bin/client.rs</code> 中的 <code>main</code> 函数。
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently performing two tasks: (1) reading user messages from standard input and sending them to the server, and (2) receiving messages from the server, and displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all clients, but the sender of the message.</li>
</ul>
<h1><a class="header" href="#解答-20" id="解答-20">解答</a></h1>
<h2><a class="header" href="#dining-philosophers-----async-1" id="dining-philosophers-----async-1">Dining Philosophers --- Async</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::Sender&lt;String&gt;,
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        // Pick up forks...
        let _left_fork = self.left_fork.lock().await;
        let _right_fork = self.right_fork.lock().await;

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;

        // The locks are dropped here
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let mut left_fork = Arc::clone(&amp;forks[i]);
            let mut right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            if i == PHILOSOPHERS.len() - 1 {
                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });
    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!(&quot;Here is a thought: {thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#广播聊天应用-1" id="广播聊天应用-1">广播聊天应用</a></h2>
<p><em>src/bin/server.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    ws_stream
        .send(Message::text(&quot;Welcome to chat! Type a message&quot;.to_string()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From client {addr:?} {text:?}&quot;);
                            bcast_tx.send(text.into())?;
                        }
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From server: {}&quot;, text);
                        }
                    },
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#谢谢" id="谢谢">谢谢！</a></h1>
<p><em>Thank you for taking Comprehensive Rust 🦀!</em> We hope you enjoyed it and that it was useful.</p>
<p>组织这门课程让我们收获了很多乐趣。本课程并非完美无缺，因此，如果您发现任何错误或有任何改进建议，请<a href="https://github.com/google/comprehensive-rust/discussions">在 GitHub 上与我们联系</a>。我们期待收到您的宝贵意见。</p>
<!-- i18n:comment Please keep { #glossary } untranslated. -->
<h1><a class="header" href="#词汇表--glossary-" id="词汇表--glossary-">词汇表 { #glossary }</a></h1>
<p>本页面的词汇表提供了许多 Rust 术语的简要定义。同时提供翻译版本和英语原文的对应。</p>
<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>
<!-- i18n:comment Please add the English term in italic after your -->
<!-- i18n:comment translated term. Also, please keep the hard line -->
<!-- i18n:comment breaks to ensure a nice formatting. -->
<ul>
<li>allocate:<br />
Dynamic memory allocation on <a href="memory-management/review.html">the heap</a>.</li>
<li>参数（argument）：<br />
传入某个函数或方法中的信息。</li>
<li>associated type:<br />
A type associated with a specific trait. Useful for defining the relationship between types.</li>
<li>裸机 Rust（Bare-metal Rust）：<br />
底层 Rust 开发方式，通常部署于没有操作系统的系统。请参阅 <a href="bare-metal.html">裸机 Rust</a>。</li>
<li>block:<br />
See <a href="control-flow-basics/blocks-and-scopes.html">Blocks</a> and <em>scope</em>.</li>
<li>borrow:<br />
See <a href="borrowing/shared.html">Borrowing</a>.</li>
<li>借用检查器（borrow checker）：<br />
Rust 编译器的一部分，用于检查所有借用操作是否有效。</li>
<li>大括号（brace）：<br />
<code>{</code> 和 <code>}</code>。也称为 <strong>花括号</strong>，用于分隔 <strong>代码块</strong>。</li>
<li>构建（build）：<br />
将源代码转换为可执行代码或可用程序的过程。</li>
<li>调用（call）：<br />
调用或执行某个函数或方法。</li>
<li>通道（channel）：<br />
用于安全地 <a href="concurrency/channels.html">在线程之间</a> 传递消息。</li>
<li>Comprehensive Rust 🦀：<br />
本课程统称为 Comprehensive Rust 🦀。</li>
<li>并发（concurrency）：<br />
同时执行多个任务或进程。</li>
<li>Concurrency in Rust:<br />
See <a href="concurrency/welcome.html">Concurrency in Rust</a>.</li>
<li>常量（constant）：<br />
在程序执行期间不会改变的值。</li>
<li>控制流（control flow）：<br />
程序中各个语句或指令的执行顺序。</li>
<li>崩溃（crash）：<br />
程序出现意外的、未处理的故障或终止。</li>
<li>枚举（enumeration）：<br />
一种用于保存多个已命名常量中的一个的数据类型，可能还有一个相关的元组或结构体。</li>
<li>错误（error）：<br />
与预期行为存在偏差的意外情况或结果。</li>
<li>错误处理（error handling）：<br />
对程序执行期间发生的错误进行管理和响应的过程。</li>
<li>练习（exercise）：<br />
专为练习和测试编程技能而设计的任务或问题。</li>
<li>函数（function）：<br />
用于执行特定任务且可重复使用的代码块。</li>
<li>垃圾回收器（garbage collector）：<br />
一种自动释放不再使用的对象所占内存的机制。</li>
<li>泛型（generics）：<br />
这项功能支持使用类型占位符编写代码，支持对不同数据类型的代码进行重复使用。</li>
<li>不可变（immutable）：<br />
创建后无法再进行更改。</li>
<li>集成测试（integration test）：<br />
一种验证系统不同部分或组件之间交互的测试类型。</li>
<li>关键字（keyword）：<br />
编程语言中的保留字，具有特定含义且不能用作标识符。</li>
<li>库（library）：<br />
程序可以使用的一组预编译例程或代码。</li>
<li>宏（macro）：<br />
Rust 宏可通过名称中的 <code>!</code> 符号识别。当普通函数无法满足需求时，可以使用宏。一个典型示例是 <code>format!</code>，其接受可变数量的参数，但 Rust 函数不支持这种类型。</li>
<li><code>main</code> 函数（<code>main</code> function）：<br />
Rust 程序从 <code>main</code> 函数开始执行。</li>
<li>匹配（match）：<br />
Rust 中的控制流结构，允许对表达式的值进行模式匹配。</li>
<li>内存泄漏（memory leak）：<br />
程序无法释放不再不要的内存的情况，会导致内存用量不断增加。</li>
<li>方法（method）：<br />
与 Rust 中的某个对象或类型相关联的函数。</li>
<li>模块（module）：<br />
Rust 中用于归纳整理代码的命名空间，其中包含函数、类型或特性等定义。</li>
<li>移动（move）：<br />
在 Rust 中，将值的所有权从一个变量转移到另一个变量。</li>
<li>可变（mutable）：<br />
Rust 中的一个属性，支持在声明变量后对其进行修改。</li>
<li>所有权（ownership）：<br />
Rust 中的概念，用于定义代码中的哪一部分负责管理与值关联的内存。</li>
<li>panic：<br />
Rust 中导致程序终止且不可恢复的错误情况。</li>
<li>参数（parameter）：<br />
在调用函数或方法时传入函数或方法的值。</li>
<li>模式（pattern）：<br />
Rust 中可与表达式匹配的值、字面量或结构的组合。</li>
<li>载荷（payload）：<br />
消息、事件或数据结构所携带的数据或信息。</li>
<li>程序（program）：<br />
计算机为执行特定任务或解决特定问题而执行的一组指令。</li>
<li>编程语言（programming language）：<br />
用于向计算机传递指令的正式系统，例如 Rust。</li>
<li>接收器（receiver）：<br />
Rust 方法中的首个参数，表示正在调用该方法的实例。</li>
<li>引用计数（reference counting）：<br />
一种内存管理方法，可以跟踪某个对象的引用数量，并在计数为零时释放该对象。</li>
<li>返回（return）：<br />
Rust 中的一个关键字，用于表示从函数返回的值。</li>
<li>Rust：<br />
一种系统编程语言，专注于安全性、性能和并发性。</li>
<li>Rust 基础（Rust Fundamentals）：<br />
本课程第 1 天到第 4 天的内容。</li>
<li>Android 中的 Rust（Rust in Android）：<br />
请参阅 <a href="android.html">Android 中的 Rust</a>.</li>
<li>Chromium 中的 Rust（Rust in Chromium）:<br />
请参阅 <a href="chromium.html">Chromium 中的 Rust</a>.</li>
<li>安全（safe）：<br />
指代码遵循 Rust 的所有权和借用规则，以防止出现与内存相关的错误。</li>
<li>作用域（scope）：<br />
程序中变量有效且可使用的区域。</li>
<li>标准库（standard library）：<br />
Rust 中提供基本功能的一系列模块。</li>
<li>静态（static）：<br />
Rust 中的关键字，用于定义具有 <code>'static</code> 生命周期的静态变量或项。</li>
<li>string:<br />
A data type storing textual data. See <a href="references/strings.html">Strings</a> for more.</li>
<li>结构体（struct）：<br />
Rust 中的复合数据类型，可将不同类型的变量归到同一名称下。</li>
<li>测试（test）：<br />
Rust 中的模块，其中包含用于测试其他函数是否正确的函数。</li>
<li>线程（thread）：<br />
程序中的单独执行顺序，支持并发执行。</li>
<li>线程安全（thread safety）：<br />
一种程序属性，用于确保多线程环境中的行为正确无误。</li>
<li>特征（trait）：<br />
用于定义未知类型的一系列方法，为在 Rust 中实现多态性提供了方法。</li>
<li>特征约束（trait bound）:<br />
一种可以要求类型实现一些感兴趣的特性的抽象。</li>
<li>元组（tuple）：<br />
包含不同类型变量的复合数据类型。元组的字段没有名称，需要通过序号访问。</li>
<li>类型（type）：<br />
一种分类方式，用于指定可以对 Rust 中特定类型的值执行哪些操作。</li>
<li>类型推导（type inference）：<br />
Rust 编译器能够推断变量或表达式的类型。</li>
<li>未定义行为（undefined behavior）：<br />
Rust 中未指定结果的操作或条件，通常会导致不可预测的程序行为。</li>
<li>联合体（union）：<br />
一种数据类型，可以存储不同类型的值，但一次只能保存一个值。</li>
<li>单元测试（unit test）：<br />
Rust 内置了运行小型单元测试和大型集成测试的支持功能。请参阅 <a href="testing/unit-tests.html">单元测试</a>。</li>
<li>单元类型（unit type）:<br />
不保存数据的类型，写为没有成员的元组。</li>
<li>unsafe:<br />
The subset of Rust which allows you to trigger <em>undefined behavior</em>. See <a href="unsafe-rust/unsafe.html">Unsafe Rust</a>.</li>
<li>变量（variable）：<br />
用于存储数据的内存位置。变量在 <strong>作用域</strong> 内有效。</li>
</ul>
<h1><a class="header" href="#其他-rust-资源" id="其他-rust-资源">其他 Rust 资源</a></h1>
<p>Rust 社区已经创造了丰富的高质量免费资源在线提供。</p>
<h2><a class="header" href="#官方文档" id="官方文档">官方文档</a></h2>
<p>Rust 项目提供了许多资源。这些资源涵盖了 Rust 的一般内容：</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust 程序设计语言</a>：一部有关 Rust 的免费权威图书。书中详细介绍了该语言，并包含一些可供读者构建的项目。</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">通过例子学 Rust</a>：通过一系列展示不同结构的示例介绍 Rust 语法。有时会包括一些小练习，会要求您充分地阐述示例中的代码。</li>
<li><a href="https://doc.rust-lang.org/std/">Rust 标准库</a>：Rust 标准库的完整文档。</li>
<li><a href="https://doc.rust-lang.org/reference/">Rust 参考手册</a>：一本未完成的书，介绍了 Rust 语法和内存模型。</li>
</ul>
<p>Rust 官方网站上有更多专业指南：</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">Rust 秘典</a>：介绍了不安全 Rust，包括使用原始指针以及与其他语言 (FFI) 交互。</li>
<li><a href="https://rust-lang.github.io/async-book/">Rust 中的异步编程</a>：介绍了在《Rust 程序设计语言》成书后引入的新异步编程模型。</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">嵌入式 Rust 之书</a>：介绍如何在没有操作系统的嵌入式设备上使用 Rust。</li>
</ul>
<h2><a class="header" href="#非官方学习资料" id="非官方学习资料">非官方学习资料</a></h2>
<p>其他 Rust 指南和教程的小选集：</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way（以危险的方式学 Rust）</a>：从低级 C 语言程序员的角度介绍 Rust。</li>
<li><a href="https://opentitan.org/book/doc/rust_for_c_devs.html">Rust for Embedded C Programmers</a>: covers Rust from the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionals（面向专业人士的 Rust）</a>：通过与其他语言（例如 C、C++、Java、JavaScript 和 Python）进行并排比较，介绍 Rust 的语法。</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism（在 Exercism 上学 Rust）</a>：100 多项练习助您学习 Rust。</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching Material</a>：一系列小演示文稿，涵盖 Rust 语言的基础知识和高级部分。还涵盖了 WebAssembly 和 async/await 等其他主题。</li>
<li><a href="https://rust-exercises.com/advanced-testing/">Advanced testing for Rust applications</a>: a self-paced workshop that goes beyond Rust's built-in testing framework. It covers <code>googletest</code>, snapshot testing, mocking as well as how to write your own custom test harness.</li>
<li><a href="https://docs.microsoft.com/zh-cn/shows/beginners-series-to-rust/">面向 Rust 的初学者系列</a>和<a href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">使用 Rust 迈出第一步</a>：两个面向新手开发者的 Rust 指南。第一个指南包含 35 个视频，第二个指南包含 11 个模块，内容涵盖 Rust 语法和基本结构。</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">通过大量的链表学习Rust</a>：通过实现几种不同类型的列表结构，深入探索 Rust 的内存管理规则。</li>
</ul>
<p>如需更多 Rust 图书，请查看 <a href="https://lborb.github.io/book/">Rust 小册</a>。</p>
<h1><a class="header" href="#鸣谢" id="鸣谢">鸣谢</a></h1>
<p>本课中的资料以众多优秀的 Rust 文档资源为基础。 如需查看实用资源的完整列表， 请参阅关于<a href="other-resources.html">其他资源</a>的页面。</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0 license, please see <a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for details.</p>
<h2><a class="header" href="#rust-示例" id="rust-示例">Rust 示例</a></h2>
<p>部分示例和练习复制并 改编自<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>。如需了解详情（包括许可 条款），请参阅 <code>third_party/rust-by-example/</code> 目录。</p>
<h2><a class="header" href="#rust-on-exercism" id="rust-on-exercism">Rust on Exercism</a></h2>
<p>部分练习复制并 改编自 <a href="https://exercism.org/tracks/rust">Rust on Exercism</a>。如需了解详情（包括许可 条款），请参阅 <code>third_party/rust-on-exercism/</code> 目录。</p>
<h2><a class="header" href="#cxx" id="cxx">CXX</a></h2>
<p>“<a href="android/interoperability/cpp.html">与 C++ 的互操作性</a>”部分引用了一张 来自 <a href="https://cxx.rs/">CXX</a> 的图片。如需了解详情（包括许可条款）， 请参阅 <code>third_party/cxx/</code> 目录。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script>
            window.playground_line_numbers = true;
        </script>
        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        

        
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        
        <script src="theme/speaker-notes.js"></script>
        

        
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </div>
    </body>
</html>
