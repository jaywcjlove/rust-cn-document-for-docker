<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust ğŸ¦€</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
        data-autoload-cookie-consent-bar="true"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZN78TEJMRW');
</script>


<script>
  (function () {
      // See these pages for details:
      // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
      // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
      let base = "https://google.github.io/comprehensive-rust";
      
      let canonical_href = `${base}/zh-CN/print.md`;
      

      // mdbook gives us a string ending in ".md", we replace it with ".html":
      canonical_href = canonical_href.slice(0, -"md".length) + "html";
      if (canonical_href.endsWith("/index.html")) {
          canonical_href = canonical_href.slice(0, -"index.html".length);
      }

      let link = document.createElement("link");
      link.rel = "canonical";
      link.href = canonical_href;
      document.head.appendChild(link);
  })()
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/svgbob.css">
        
        <link rel="stylesheet" href="theme/css/speaker-notes.css">
        
        <link rel="stylesheet" href="theme/css/language-picker.css">
        
        <link rel="stylesheet" href="theme/css/frontmatter.css">
        

        
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">æ¬¢è¿æ¥åˆ° Comprehensive Rust ğŸ¦€</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> æˆè¯¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> è¯¾ç¨‹ç»“æ„</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> é”®ç›˜å¿«æ·é”®</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> ç¿»è¯‘</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> ä½¿ç”¨ Cargo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> Rust ç”Ÿæ€ç³»ç»Ÿ</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> ä»£ç ç¤ºä¾‹</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> åœ¨æœ¬åœ°è¿è¡Œ Cargo</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸€å¤©ï¼šæ—©ä¸Š</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> æ¬¢è¿</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="welcome-day-1/what-is-rust.html"><strong aria-hidden="true">3.1.</strong> ä»€ä¹ˆæ˜¯ Rustï¼Ÿ</a></li></ol></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello World!</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/small-example.html"><strong aria-hidden="true">4.1.</strong> ç®€çŸ­ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="why-rust.html"><strong aria-hidden="true">5.</strong> ä¸ºä»€ä¹ˆé€‰æ‹© Rustï¼Ÿ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="why-rust/an-example-in-c.html"><strong aria-hidden="true">5.1.</strong> An Example in C</a></li><li class="chapter-item "><a href="why-rust/compile-time.html"><strong aria-hidden="true">5.2.</strong> ç¼–è¯‘æœŸä¿éšœ</a></li><li class="chapter-item "><a href="why-rust/runtime.html"><strong aria-hidden="true">5.3.</strong> è¿è¡Œæ—¶ä¿éšœ</a></li><li class="chapter-item "><a href="why-rust/modern.html"><strong aria-hidden="true">5.4.</strong> ç°ä»£ç‰¹æ€§</a></li></ol></li><li class="chapter-item "><a href="basic-syntax.html"><strong aria-hidden="true">6.</strong> åŸºæœ¬è¯­æ³•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/scalar-types.html"><strong aria-hidden="true">6.1.</strong> æ ‡é‡ç±»å‹</a></li><li class="chapter-item "><a href="basic-syntax/compound-types.html"><strong aria-hidden="true">6.2.</strong> å¤åˆç±»å‹</a></li><li class="chapter-item "><a href="basic-syntax/references.html"><strong aria-hidden="true">6.3.</strong> å¼•ç”¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/references-dangling.html"><strong aria-hidden="true">6.3.1.</strong> æ‚¬å‚å¼•ç”¨</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/slices.html"><strong aria-hidden="true">6.4.</strong> åˆ‡ç‰‡</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/string-slices.html"><strong aria-hidden="true">6.4.1.</strong> String å’Œ str</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/functions.html"><strong aria-hidden="true">6.5.</strong> å‡½æ•°</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/rustdoc.html"><strong aria-hidden="true">6.5.1.</strong> Rustdoc</a></li><li class="chapter-item "><a href="basic-syntax/methods.html"><strong aria-hidden="true">6.5.2.</strong> æ–¹æ³•</a></li><li class="chapter-item "><a href="basic-syntax/functions-interlude.html"><strong aria-hidden="true">6.5.3.</strong> é‡è½½</a></li></ol></li></ol></li><li class="chapter-item "><a href="exercises/day-1/morning.html"><strong aria-hidden="true">7.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/implicit-conversions.html"><strong aria-hidden="true">7.1.</strong> éšå¼ç±»å‹è½¬æ¢</a></li><li class="chapter-item "><a href="exercises/day-1/for-loops.html"><strong aria-hidden="true">7.2.</strong> æ•°ç»„ä¸ for å¾ªç¯</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ 1 å¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="control-flow.html"><strong aria-hidden="true">8.</strong> æ§åˆ¶æµ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/blocks.html"><strong aria-hidden="true">8.1.</strong> å—</a></li><li class="chapter-item "><a href="control-flow/if-expressions.html"><strong aria-hidden="true">8.2.</strong> if è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow/for-expressions.html"><strong aria-hidden="true">8.3.</strong> for è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow/while-expressions.html"><strong aria-hidden="true">8.4.</strong> while è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow/break-continue.html"><strong aria-hidden="true">8.5.</strong> break &amp; continue</a></li><li class="chapter-item "><a href="control-flow/loop-expressions.html"><strong aria-hidden="true">8.6.</strong> loop è¡¨è¾¾å¼</a></li></ol></li><li class="chapter-item "><a href="basic-syntax/variables.html"><strong aria-hidden="true">9.</strong> å˜é‡</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-syntax/type-inference.html"><strong aria-hidden="true">9.1.</strong> ç±»å‹æ¨å¯¼</a></li><li class="chapter-item "><a href="basic-syntax/static-and-const.html"><strong aria-hidden="true">9.2.</strong> é™æ€ä¸å¸¸é‡</a></li><li class="chapter-item "><a href="basic-syntax/scopes-shadowing.html"><strong aria-hidden="true">9.3.</strong> ä½œç”¨åŸŸå’Œéšè— (Shadowing)</a></li></ol></li><li class="chapter-item "><a href="enums.html"><strong aria-hidden="true">10.</strong> æšä¸¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="enums/variant-payloads.html"><strong aria-hidden="true">10.1.</strong> å˜ä½“è½½è·</a></li><li class="chapter-item "><a href="enums/sizes.html"><strong aria-hidden="true">10.2.</strong> æšä¸¾å¤§å°</a></li></ol></li><li class="chapter-item "><a href="control-flow/novel.html"><strong aria-hidden="true">11.</strong> Novel Control Flow</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow/if-let-expressions.html"><strong aria-hidden="true">11.1.</strong> if let è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow/while-let-expressions.html"><strong aria-hidden="true">11.2.</strong> while let è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow/match-expressions.html"><strong aria-hidden="true">11.3.</strong> match è¡¨è¾¾å¼</a></li></ol></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">12.</strong> æ¨¡å¼åŒ¹é…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">12.1.</strong> è§£æ„æšä¸¾</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">12.2.</strong> è§£æ„ç»“æ„ä½“</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-arrays.html"><strong aria-hidden="true">12.3.</strong> è§£æ„æ•°ç»„</a></li><li class="chapter-item "><a href="pattern-matching/match-guards.html"><strong aria-hidden="true">12.4.</strong> åŒ¹é…å®ˆå«</a></li></ol></li><li class="chapter-item "><a href="exercises/day-1/afternoon.html"><strong aria-hidden="true">13.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/luhn.html"><strong aria-hidden="true">13.1.</strong> Luhn ç®—æ³•</a></li><li class="chapter-item "><a href="exercises/day-1/pattern-matching.html"><strong aria-hidden="true">13.2.</strong> æ¨¡å¼åŒ¹é…</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬äºŒå¤©ï¼šä¸Šåˆ</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">14.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">15.</strong> å†…å­˜ç®¡ç†</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/stack-vs-heap.html"><strong aria-hidden="true">15.1.</strong> æ ˆ vs å †</a></li><li class="chapter-item "><a href="memory-management/stack.html"><strong aria-hidden="true">15.2.</strong> æ ˆå†…å­˜</a></li><li class="chapter-item "><a href="memory-management/manual.html"><strong aria-hidden="true">15.3.</strong> æ‰‹åŠ¨å†…å­˜ç®¡ç†</a></li><li class="chapter-item "><a href="memory-management/scope-based.html"><strong aria-hidden="true">15.4.</strong> åŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç†</a></li><li class="chapter-item "><a href="memory-management/garbage-collection.html"><strong aria-hidden="true">15.5.</strong> åƒåœ¾å›æ”¶</a></li><li class="chapter-item "><a href="memory-management/rust.html"><strong aria-hidden="true">15.6.</strong> Rust å†…å­˜ç®¡ç†</a></li></ol></li><li class="chapter-item "><a href="ownership.html"><strong aria-hidden="true">16.</strong> æ‰€æœ‰æƒ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/move-semantics.html"><strong aria-hidden="true">16.1.</strong> ç§»åŠ¨è¯­ä¹‰</a></li><li class="chapter-item "><a href="ownership/moved-strings-rust.html"><strong aria-hidden="true">16.2.</strong> Rust ä¸­ç§»åŠ¨çš„å­—ç¬¦ä¸²</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/double-free-modern-cpp.html"><strong aria-hidden="true">16.2.1.</strong> ç°ä»£ C++ ä¸­çš„åŒé‡é‡Šæ”¾</a></li></ol></li><li class="chapter-item "><a href="ownership/moves-function-calls.html"><strong aria-hidden="true">16.3.</strong> å‡½æ•°è°ƒç”¨ä¸­çš„ç§»åŠ¨</a></li><li class="chapter-item "><a href="ownership/copy-clone.html"><strong aria-hidden="true">16.4.</strong> å¤åˆ¶å’Œå…‹éš†</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">16.5.</strong> å€Ÿç”¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/shared-unique-borrows.html"><strong aria-hidden="true">16.5.1.</strong> å…±äº«å’Œå”¯ä¸€çš„å€Ÿç”¨</a></li></ol></li><li class="chapter-item "><a href="ownership/lifetimes.html"><strong aria-hidden="true">16.6.</strong> ç”Ÿå‘½å‘¨æœŸ</a></li><li class="chapter-item "><a href="ownership/lifetimes-function-calls.html"><strong aria-hidden="true">16.7.</strong> å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></li><li class="chapter-item "><a href="ownership/lifetimes-data-structures.html"><strong aria-hidden="true">16.8.</strong> æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></li></ol></li><li class="chapter-item "><a href="structs.html"><strong aria-hidden="true">17.</strong> ç»“æ„ä½“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structs/tuple-structs.html"><strong aria-hidden="true">17.1.</strong> å…ƒç»„ç»“æ„ä½“</a></li><li class="chapter-item "><a href="structs/field-shorthand.html"><strong aria-hidden="true">17.2.</strong> å­—æ®µç®€å†™è¯­æ³•</a></li></ol></li><li class="chapter-item "><a href="methods.html"><strong aria-hidden="true">18.</strong> æ–¹æ³•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods/receiver.html"><strong aria-hidden="true">18.1.</strong> æ–¹æ³•æ¥æ”¶è€…</a></li><li class="chapter-item "><a href="methods/example.html"><strong aria-hidden="true">18.2.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/morning.html"><strong aria-hidden="true">19.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/book-library.html"><strong aria-hidden="true">19.1.</strong> Storing Books</a></li><li class="chapter-item "><a href="exercises/day-2/health-statistics.html"><strong aria-hidden="true">19.2.</strong> å¥åº·ç»Ÿè®¡</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬äºŒå¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="std.html"><strong aria-hidden="true">20.</strong> æ ‡å‡†åº“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/option-result.html"><strong aria-hidden="true">20.1.</strong> Option å’Œ Result</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">20.2.</strong> String</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">20.3.</strong> Vec</a></li><li class="chapter-item "><a href="std/hashmap.html"><strong aria-hidden="true">20.4.</strong> å“ˆå¸Œè¡¨</a></li><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">20.5.</strong> Box</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box-recursive.html"><strong aria-hidden="true">20.5.1.</strong> é€’å½’æ•°æ®ç±»å‹</a></li><li class="chapter-item "><a href="std/box-niche.html"><strong aria-hidden="true">20.5.2.</strong> å°ä¼—ä¼˜åŒ–</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">20.6.</strong> Rc</a></li><li class="chapter-item "><a href="std/cell.html"><strong aria-hidden="true">20.7.</strong> Cell/RefCell</a></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">21.</strong> æ¨¡å—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">21.1.</strong> å¯è§æ€§</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">21.2.</strong> è·¯å¾„</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">21.3.</strong> æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„</a></li></ol></li><li class="chapter-item "><a href="exercises/day-2/afternoon.html"><strong aria-hidden="true">22.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-2/iterators-and-ownership.html"><strong aria-hidden="true">22.1.</strong> è¿­ä»£å™¨å’Œæ‰€æœ‰æƒ</a></li><li class="chapter-item "><a href="exercises/day-2/strings-iterators.html"><strong aria-hidden="true">22.2.</strong> å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸‰å¤©ï¼šä¸Šåˆ</li><li class="spacer"></li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">23.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">24.</strong> æ³›å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/data-types.html"><strong aria-hidden="true">24.1.</strong> é€šç”¨æ•°æ®ç±»å‹</a></li><li class="chapter-item "><a href="generics/methods.html"><strong aria-hidden="true">24.2.</strong> æ³›å‹æ–¹æ³•</a></li><li class="chapter-item "><a href="generics/monomorphization.html"><strong aria-hidden="true">24.3.</strong> å•æ€åŒ–</a></li></ol></li><li class="chapter-item "><a href="traits.html"><strong aria-hidden="true">25.</strong> ç‰¹å¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/trait-objects.html"><strong aria-hidden="true">25.1.</strong> ç‰¹å¾ï¼ˆTraitï¼‰å¯¹è±¡</a></li><li class="chapter-item "><a href="traits/deriving-traits.html"><strong aria-hidden="true">25.2.</strong> æ´¾ç”Ÿç‰¹å¾</a></li><li class="chapter-item "><a href="traits/default-methods.html"><strong aria-hidden="true">25.3.</strong> é»˜è®¤æ–¹æ³•</a></li><li class="chapter-item "><a href="traits/trait-bounds.html"><strong aria-hidden="true">25.4.</strong> ç‰¹å¾è¾¹ç•Œ</a></li><li class="chapter-item "><a href="traits/impl-trait.html"><strong aria-hidden="true">25.5.</strong> impl Trait</a></li></ol></li><li class="chapter-item "><a href="traits/important-traits.html"><strong aria-hidden="true">26.</strong> é‡è¦ç‰¹å¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/iterator.html"><strong aria-hidden="true">26.1.</strong> è¿­ä»£å™¨</a></li><li class="chapter-item "><a href="traits/from-iterator.html"><strong aria-hidden="true">26.2.</strong> FromIterator</a></li><li class="chapter-item "><a href="traits/from-into.html"><strong aria-hidden="true">26.3.</strong> From å’Œ Into</a></li><li class="chapter-item "><a href="traits/read-write.html"><strong aria-hidden="true">26.4.</strong> è¯»å–å’Œå†™å…¥</a></li><li class="chapter-item "><a href="traits/drop.html"><strong aria-hidden="true">26.5.</strong> Drop</a></li><li class="chapter-item "><a href="traits/default.html"><strong aria-hidden="true">26.6.</strong> Default</a></li><li class="chapter-item "><a href="traits/operators.html"><strong aria-hidden="true">26.7.</strong> è¿ç®—ç¬¦ï¼šAddã€Mul...</a></li><li class="chapter-item "><a href="traits/closures.html"><strong aria-hidden="true">26.8.</strong> é—­åŒ…ï¼šFnã€FnMutã€FnOnce</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/morning.html"><strong aria-hidden="true">27.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/simple-gui.html"><strong aria-hidden="true">27.1.</strong> ä¸€ä¸ªç®€å•çš„ GUI åº“</a></li><li class="chapter-item "><a href="exercises/day-3/points-polygons.html"><strong aria-hidden="true">27.2.</strong> ç‚¹å’Œå¤šè¾¹å½¢</a></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸‰å¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">28.</strong> é”™è¯¯å¤„ç†</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">28.1.</strong> Panics</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panic-unwind.html"><strong aria-hidden="true">28.1.1.</strong> æ•è·å †æ ˆå±•å¼€</a></li></ol></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">28.2.</strong> ç»“æ„åŒ–é”™è¯¯å¤„ç†</a></li><li class="chapter-item "><a href="error-handling/try-operator.html"><strong aria-hidden="true">28.3.</strong> ä½¿ç”¨ ? ä¼ æ’­é”™è¯¯</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types.html"><strong aria-hidden="true">28.3.1.</strong> è½¬æ¢é”™è¯¯ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/converting-error-types-example.html"><strong aria-hidden="true">28.3.1.1.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="error-handling/deriving-error-enums.html"><strong aria-hidden="true">28.3.2.</strong> æ´¾ç”Ÿé”™è¯¯æšä¸¾</a></li><li class="chapter-item "><a href="error-handling/dynamic-errors.html"><strong aria-hidden="true">28.3.3.</strong> åŠ¨æ€é”™è¯¯ç±»å‹</a></li><li class="chapter-item "><a href="error-handling/error-contexts.html"><strong aria-hidden="true">28.3.4.</strong> ä¸ºé”™è¯¯æ·»åŠ èƒŒæ™¯ä¿¡æ¯</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">29.</strong> æµ‹è¯•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">29.1.</strong> å•å…ƒæµ‹è¯•</a></li><li class="chapter-item "><a href="testing/test-modules.html"><strong aria-hidden="true">29.2.</strong> æµ‹è¯•æ¨¡å—</a></li><li class="chapter-item "><a href="testing/doc-tests.html"><strong aria-hidden="true">29.3.</strong> æ–‡æ¡£æµ‹è¯•</a></li><li class="chapter-item "><a href="testing/integration-tests.html"><strong aria-hidden="true">29.4.</strong> é›†æˆæµ‹è¯•</a></li><li class="chapter-item "><a href="testing/useful-crates.html"><strong aria-hidden="true">29.5.</strong> å®ç”¨ crate</a></li></ol></li><li class="chapter-item "><a href="unsafe.html"><strong aria-hidden="true">30.</strong> ä¸å®‰å…¨ Rust</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/raw-pointers.html"><strong aria-hidden="true">30.1.</strong> è§£å¼•ç”¨è£¸æŒ‡é’ˆ</a></li><li class="chapter-item "><a href="unsafe/mutable-static-variables.html"><strong aria-hidden="true">30.2.</strong> å¯å˜çš„é™æ€å˜é‡</a></li><li class="chapter-item "><a href="unsafe/unions.html"><strong aria-hidden="true">30.3.</strong> è”åˆä½“</a></li><li class="chapter-item "><a href="unsafe/calling-unsafe-functions.html"><strong aria-hidden="true">30.4.</strong> è°ƒç”¨ Unsafe å‡½æ•°</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/writing-unsafe-functions.html"><strong aria-hidden="true">30.4.1.</strong> ç¼–å†™ Unsafe å‡½æ•°</a></li><li class="chapter-item "><a href="unsafe/extern-functions.html"><strong aria-hidden="true">30.4.2.</strong> å¤–éƒ¨å‡½æ•°</a></li></ol></li><li class="chapter-item "><a href="unsafe/unsafe-traits.html"><strong aria-hidden="true">30.5.</strong> å®ç° Unsafe Trait</a></li></ol></li><li class="chapter-item "><a href="exercises/day-3/afternoon.html"><strong aria-hidden="true">31.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-3/safe-ffi-wrapper.html"><strong aria-hidden="true">31.1.</strong> å®‰å…¨ FFI å°è£…å®¹å™¨</a></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">32.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">33.</strong> è®¾ç½®</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">34.</strong> æ„å»ºè§„åˆ™</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">34.1.</strong> å¯æ‰§è¡Œæ–‡ä»¶</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">34.2.</strong> åº“</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">35.</strong> AIDL</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/interface.html"><strong aria-hidden="true">35.1.</strong> æ¥å£</a></li><li class="chapter-item "><a href="android/aidl/implementation.html"><strong aria-hidden="true">35.2.</strong> å®ç°</a></li><li class="chapter-item "><a href="android/aidl/server.html"><strong aria-hidden="true">35.3.</strong> æœåŠ¡å™¨</a></li><li class="chapter-item "><a href="android/aidl/deploy.html"><strong aria-hidden="true">35.4.</strong> éƒ¨ç½²</a></li><li class="chapter-item "><a href="android/aidl/client.html"><strong aria-hidden="true">35.5.</strong> å®¢æˆ·ç«¯</a></li><li class="chapter-item "><a href="android/aidl/changing.html"><strong aria-hidden="true">35.6.</strong> æ›´æ”¹ API</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">36.</strong> æ—¥å¿—è®°å½•</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">37.</strong> äº’æ“ä½œæ€§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">37.1.</strong> ä¸ C è¯­è¨€äº¤äº’</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">37.1.1.</strong> ä½¿ç”¨Bindgenè°ƒç”¨Cè¯­è¨€</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">37.1.2.</strong> ä»Cè¯­è¨€è°ƒç”¨Rustè¯­è¨€</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">37.2.</strong> ä¸ C++ äº¤äº’</a></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">37.3.</strong> ä¸ Java äº¤äº’</a></li></ol></li><li class="chapter-item "><a href="exercises/android/morning.html"><strong aria-hidden="true">38.</strong> ä¹ é¢˜</a></li><li class="chapter-item affix "><li class="part-title">è£¸æœº:ä¸Šåˆ</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">39.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">40.</strong> no_std</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">40.1.</strong> æœ€å°ç¤ºä¾‹</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">40.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">41.</strong> å¾®æ§åˆ¶å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">41.1.</strong> åŸå§‹ MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">41.2.</strong> PAC</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">41.3.</strong> HAL crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">41.4.</strong> æ¿çº§æ”¯æŒ Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">41.5.</strong> ç±»å‹çŠ¶æ€æ¨¡å¼</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">41.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">41.7.</strong> probe-rsã€cargo-embed</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">41.7.1.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">41.8.</strong> å…¶ä»–é¡¹ç›®</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">42.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">42.1.</strong> ç½—ç›˜</a></li></ol></li><li class="chapter-item "><li class="part-title">è£¸æœº:ä¸‹åˆ</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">43.</strong> åº”ç”¨å¤„ç†å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">43.1.</strong> å‡†å¤‡ä½¿ç”¨ Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">43.2.</strong> å†…åµŒæ±‡ç¼–</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">43.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">43.4.</strong> ç¼–å†™ UART é©±åŠ¨ç¨‹åº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">43.4.1.</strong> æ›´å¤š trait</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">43.5.</strong> ä¸€ä¸ªæ›´å¥½çš„ UART é©±åŠ¨ç¨‹åº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">43.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">43.5.2.</strong> å¤šä¸ªå¯„å­˜å™¨</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">43.5.3.</strong> é©±åŠ¨ç¨‹åº</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">43.5.4.</strong> å¼€å§‹ä½¿ç”¨</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">43.6.</strong> æ—¥å¿—è®°å½•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">43.6.1.</strong> å¼€å§‹ä½¿ç”¨</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">43.7.</strong> Exceptions</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">43.8.</strong> å…¶ä»–é¡¹ç›®</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">44.</strong> å®ç”¨ crate</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">44.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">44.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">44.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">44.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">44.5.</strong> è½¬åŠ¨</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">45.</strong> Android</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">45.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">46.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">46.1.</strong> RTCé©±åŠ¨</a></li></ol></li><li class="chapter-item "><li class="part-title">å¹¶å‘ç¼–ç¨‹ï¼šå…¥é—¨ç¯‡</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency.html"><strong aria-hidden="true">47.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">48.</strong> çº¿ç¨‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/scoped-threads.html"><strong aria-hidden="true">48.1.</strong> èŒƒå›´çº¿ç¨‹</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">49.</strong> é€šé“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">49.1.</strong> æ— ç•Œé€šé“</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">49.2.</strong> æœ‰ç•Œé€šé“</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">50.</strong> Send å’Œ Sync</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">50.1.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">50.2.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">50.3.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared_state.html"><strong aria-hidden="true">51.</strong> å…±äº«çŠ¶æ€</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared_state/arc.html"><strong aria-hidden="true">51.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared_state/mutex.html"><strong aria-hidden="true">51.2.</strong> Mutex</a></li><li class="chapter-item "><a href="concurrency/shared_state/example.html"><strong aria-hidden="true">51.3.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/morning.html"><strong aria-hidden="true">52.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers.html"><strong aria-hidden="true">52.1.</strong> å“²å­¦å®¶å°±é¤é—®é¢˜ (Dining philosophers problem)</a></li><li class="chapter-item "><a href="exercises/concurrency/link-checker.html"><strong aria-hidden="true">52.2.</strong> å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨</a></li></ol></li><li class="chapter-item "><li class="part-title">å¹¶å‘ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="async.html"><strong aria-hidden="true">53.</strong> å¼‚æ­¥åŸºç¡€</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">53.1.</strong> async/await</a></li><li class="chapter-item "><a href="async/futures.html"><strong aria-hidden="true">53.2.</strong> Futures</a></li><li class="chapter-item "><a href="async/runtimes.html"><strong aria-hidden="true">53.3.</strong> Runtimes</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/runtimes/tokio.html"><strong aria-hidden="true">53.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="async/tasks.html"><strong aria-hidden="true">53.4.</strong> ä»»åŠ¡</a></li><li class="chapter-item "><a href="async/channels.html"><strong aria-hidden="true">53.5.</strong> å¼‚æ­¥é€šé“</a></li></ol></li><li class="chapter-item "><a href="async/control-flow.html"><strong aria-hidden="true">54.</strong> æ§åˆ¶æµ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/control-flow/join.html"><strong aria-hidden="true">54.1.</strong> åŠ å…¥</a></li><li class="chapter-item "><a href="async/control-flow/select.html"><strong aria-hidden="true">54.2.</strong> é€‰æ‹©</a></li></ol></li><li class="chapter-item "><a href="async/pitfalls.html"><strong aria-hidden="true">55.</strong> è¯¯åŒº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/pitfalls/blocking-executor.html"><strong aria-hidden="true">55.1.</strong> å±è”½æ‰§è¡Œå™¨</a></li><li class="chapter-item "><a href="async/pitfalls/pin.html"><strong aria-hidden="true">55.2.</strong> å›ºå®š</a></li><li class="chapter-item "><a href="async/pitfalls/async-traits.html"><strong aria-hidden="true">55.3.</strong> å¼‚æ­¥ç‰¹è´¨</a></li><li class="chapter-item "><a href="async/pitfalls/cancellation.html"><strong aria-hidden="true">55.4.</strong> Cancellation</a></li></ol></li><li class="chapter-item "><a href="exercises/concurrency/afternoon.html"><strong aria-hidden="true">56.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/concurrency/dining-philosophers-async.html"><strong aria-hidden="true">56.1.</strong> å“²å­¦å®¶å°±é¤é—®é¢˜ (Dining philosophers problem)</a></li><li class="chapter-item "><a href="exercises/concurrency/chat-app.html"><strong aria-hidden="true">56.2.</strong> å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº</a></li></ol></li><li class="chapter-item "><li class="part-title">ç»“æŸè¯­</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">57.</strong> è°¢è°¢ï¼</a></li><li class="chapter-item "><a href="glossary.html"><strong aria-hidden="true">58.</strong> Glossary</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">59.</strong> å…¶ä»–èµ„æº</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">60.</strong> é¸£è°¢</a></li><li class="chapter-item affix "><li class="part-title">è§£ç­”</li><li class="spacer"></li><li class="chapter-item "><a href="exercises/solutions.html"><strong aria-hidden="true">61.</strong> è§£ç­”</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/day-1/solutions-morning.html"><strong aria-hidden="true">61.1.</strong> ç¬¬ä¸€å¤©ä¸Šåˆ</a></li><li class="chapter-item "><a href="exercises/day-1/solutions-afternoon.html"><strong aria-hidden="true">61.2.</strong> ç¬¬ä¸€å¤©ä¸‹åˆ</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-morning.html"><strong aria-hidden="true">61.3.</strong> ç¬¬äºŒå¤©ä¸Šåˆ</a></li><li class="chapter-item "><a href="exercises/day-2/solutions-afternoon.html"><strong aria-hidden="true">61.4.</strong> ç¬¬äºŒå¤©ä¸‹åˆ</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-morning.html"><strong aria-hidden="true">61.5.</strong> ç¬¬ä¸‰å¤©ä¸Šåˆ</a></li><li class="chapter-item "><a href="exercises/day-3/solutions-afternoon.html"><strong aria-hidden="true">61.6.</strong> ç¬¬ä¸‰å¤©ä¸‹åˆ</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">61.7.</strong> åµŒå…¥å¼ Rustï¼šå…¥é—¨ç¯‡</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">61.8.</strong> åµŒå…¥å¼ Rustï¼šè¿›é˜¶ç¯‡</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-morning.html"><strong aria-hidden="true">61.9.</strong> å¹¶å‘ç¼–ç¨‹ï¼šå…¥é—¨ç¯‡</a></li><li class="chapter-item "><a href="exercises/concurrency/solutions-afternoon.html"><strong aria-hidden="true">61.10.</strong> å¹¶å‘ç¼–ç¨‹ï¼šè¿›é˜¶ç¯‡</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Comprehensive Rust ğŸ¦€</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (PortuguÃªs do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (í•œêµ­ì–´)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (EspaÃ±ol)</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-CN");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          
                          let full_path_to_root = "../";
                          
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#æ¬¢è¿æ¥åˆ°-comprehensive-rust-" id="æ¬¢è¿æ¥åˆ°-comprehensive-rust-">æ¬¢è¿æ¥åˆ° Comprehensive Rust ğŸ¦€</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="Build workflow" /></a> <a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub contributors" /></a> <a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub stars" /></a></p>
<p>è¿™æ˜¯ç”± Android å›¢é˜Ÿå¼€å‘çš„å…è´¹ Rust è¯¾ç¨‹ã€‚è¯¥è¯¾ç¨‹æ¶µç›–äº† Rust çš„å…¨éƒ¨èŒƒå›´,ä»åŸºæœ¬è¯­æ³•åˆ°é«˜çº§ä¸»é¢˜å¦‚æ³›å‹å’Œé”™è¯¯å¤„ç†ã€‚</p>
<blockquote>
<p>å¦‚éœ€æŸ¥çœ‹è¯¾ç¨‹çš„æœ€æ–°ç‰ˆæœ¬,è¯·è®¿é—® <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a>ã€‚å¦‚æœæ‚¨æ˜¯åœ¨å…¶ä»–åœ°æ–¹é˜…è¯»,è¯·æŸ¥çœ‹è¿™ä¸ªç½‘å€äº†è§£æ˜¯å¦æœ‰æ›´æ–°ã€‚</p>
</blockquote>
<p>æœ¬è¯¾ç¨‹çš„ç›®æ ‡æ˜¯æ•™æˆä½  Rustã€‚æˆ‘ä»¬å‡è®¾ä½ å¯¹ Rust ä¸€æ— æ‰€çŸ¥ï¼Œå¹¶å¸Œæœ›èƒ½å¤Ÿï¼š</p>
<ul>
<li>å¸®åŠ©ä½ å…¨é¢ç†è§£ Rust çš„è¯­æ³•å’Œè¯­è¨€ã€‚</li>
<li>ä½¿ä½ èƒ½å¤Ÿä¿®æ”¹ç°æœ‰çš„ç¨‹åºå¹¶ç”¨ Rust ç¼–å†™æ–°ç¨‹åºã€‚</li>
<li>å±•ç¤ºå¸¸è§çš„ Rust ä¹ è¯­ã€‚</li>
</ul>
<p>æˆ‘ä»¬å°†å‰ä¸‰å¤©çš„è¯¾ç¨‹ç§°ä¸º<code>Rust åŸºç¡€çŸ¥è¯†</code>ã€‚</p>
<p>åœ¨æ­¤åŸºç¡€ä¸Š,ä½ å¯ä»¥é€‰æ‹©æ·±å…¥å­¦ä¹ ä¸€ä¸ªæˆ–å¤šä¸ªä¸“é—¨çš„ä¸»é¢˜:</p>
<ul>
<li><a href="android.html">Android</a>ï¼šä¸€ä¸ªåŠå¤©çš„è¯¾ç¨‹ï¼Œä»‹ç»å¦‚ä½•åœ¨ Android å¹³å°å¼€å‘ä¸­ä½¿ç”¨ Rustï¼ˆAOSPï¼‰ã€‚è¯¾ç¨‹å†…å®¹åŒ…æ‹¬ä¸ Cã€C++ å’Œ Java çš„äº’æ“ä½œæ€§ã€‚</li>
<li><a href="bare-metal.html">Bare-metal</a>:ä¸ºæœŸä¸€å¤©çš„è¯¾ç¨‹,ä»‹ç»å¦‚ä½•ä½¿ç”¨ Rust è¿›è¡Œè£¸æœº(åµŒå…¥å¼)å¼€å‘ã€‚è¯¾ç¨‹å†…å®¹æ¶µç›–å¾®æ§åˆ¶å™¨å’Œåº”ç”¨å¤„ç†å™¨ã€‚</li>
<li><a href="concurrency.html">Concurrency</a>: a whole-day class on concurrency in Rust. We cover both classical concurrency (preemptively scheduling using threads and mutexes) and async/await concurrency (cooperative multitasking using futures).</li>
</ul>
<h2><a class="header" href="#éç›®æ ‡" id="éç›®æ ‡">éç›®æ ‡</a></h2>
<p>Rust æ˜¯ä¸€é—¨åºå¤§çš„è¯­è¨€ï¼Œæˆ‘ä»¬æ— æ³•åœ¨å‡ å¤©å†…æ¶µç›–æ‰€æœ‰å†…å®¹ã€‚æœ¬è¯¾ç¨‹çš„ä¸€äº›éç›®æ ‡åŒ…æ‹¬ï¼š</p>
<ul>
<li>Learning how to develop macros: please see <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Chapter 19.5 in the Rust Book</a> and <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by Example</a> instead.</li>
</ul>
<h2><a class="header" href="#å‰æå‡è®¾" id="å‰æå‡è®¾">å‰æå‡è®¾</a></h2>
<p>The course assumes that you already know how to program. Rust is a statically-typed language and we will sometimes make comparisons with C and C++ to better explain or contrast the Rust approach.</p>
<p>If you know how to program in a dynamically-typed language such as Python or JavaScript, then you will be able to follow along just fine too.</p>
<details>
<p>This is an example of a <em>speaker note</em>. We will use these to add additional information to the slides. This could be key points which the instructor should cover as well as answers to typical questions which come up in class.</p>
</details><h1><a class="header" href="#æˆè¯¾" id="æˆè¯¾">æˆè¯¾</a></h1>
<blockquote>
<p>æœ¬é¡µé¢é€‚ç”¨äºè¯¾ç¨‹æ•™å¸ˆã€‚</p>
</blockquote>
<p>ä»¥ä¸‹æ˜¯æœ‰å…³ Google å†…éƒ¨æˆè¯¾æ–¹å¼çš„ä¸€äº›èƒŒæ™¯ä¿¡æ¯ã€‚</p>
<p>ä¸Šè¯¾æ—¶é—´é€šå¸¸æ˜¯ä»ä¸Šåˆ 10:00 åˆ°ä¸‹åˆ 4:00,ä¸­é—´æœ‰ 1 å°æ—¶çš„åˆé¤ä¼‘æ¯æ—¶é—´ã€‚è¿™æ ·,ä¸Šåˆå’Œä¸‹åˆå„ç•™äº† 2.5 å°æ—¶çš„ä¸Šè¯¾æ—¶é—´ã€‚è¯·æ³¨æ„,è¿™ä»…æ˜¯å»ºè®®:æ‚¨ä¹Ÿå¯ä»¥ä¸Šåˆä¸Šè¯¾ 3 å°æ—¶,è®©å­¦å‘˜æœ‰æ›´å¤šçš„æ—¶é—´è¿›è¡Œç»ƒä¹ ã€‚ä¸Šè¯¾æ—¶é—´è¾ƒé•¿çš„ç¼ºç‚¹æ˜¯,å­¦å‘˜ä¸Šäº†æ•´æ•´ 6 å°æ—¶çš„è¯¾,åˆ°äº†ä¸‹åˆå¯èƒ½ä¼šéå¸¸ç–²å€¦ã€‚</p>
<p>åœ¨æˆè¯¾ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆä»¥ä¸‹äº‹é¡¹ï¼š</p>
<ol>
<li>
<p>ç†Ÿæ‚‰è¯¾ç¨‹èµ„æ–™ã€‚æˆ‘ä»¬æ·»åŠ äº†æ¼”è®²è€…å¤‡æ³¨ï¼Œå€Ÿæ­¤å¼ºè°ƒè¦ç‚¹ï¼ˆè¯·å¸®ä¸ªå¿™ï¼Œå¤šå¤šè´¡çŒ®æ¼”è®²è€…å¤‡æ³¨ï¼ï¼‰ã€‚æ¼”ç¤ºå¹»ç¯ç‰‡æ—¶ï¼Œä½ åº”ç¡®ä¿åœ¨å¼¹å‡ºå¼çª—å£ä¸­æ‰“å¼€æ¼”è®²è€…å¤‡æ³¨ï¼ˆç‚¹å‡»å¯¹åº”çš„é“¾æ¥ï¼Œåœ¨â€œæ¼”è®²è€…å¤‡æ³¨â€æ—è¾¹æœ‰ä¸€ä¸ªå°ç®­å¤´ï¼‰ã€‚è¿™æ ·ï¼Œä½ å°±å¯ä»¥ç¡®ä¿å±å¹•æ•´æ´æœ‰åºï¼Œæ›´å¥½åœ°å‘å…¨ç­å­¦å‘˜å±•ç¤ºè¯¾ç¨‹å†…å®¹ã€‚</p>
</li>
<li>
<p>ç¡®å®šåŸ¹è®­æ—¥æœŸã€‚ç”±äºæœ¬è¯¾ç¨‹è‡³å°‘éœ€è¦ä¸‰å¤©çš„æ—¶é—´ï¼Œå› æ­¤æˆ‘ä»¬å»ºè®®ä½ å®‰æ’ä¸¤å‘¨ä»¥ä¸Šçš„æ—¶é—´ã€‚è¯¾ç¨‹å­¦å‘˜æ›¾è¡¨ç¤ºï¼Œåœ¨æ¯å ‚è¯¾ä¹‹é—´ç•™ä¸€æ®µé—´éš”ä¼šå¾ˆæœ‰å¸®åŠ©ï¼Œå› ä¸ºè¿™æœ‰åˆ©äºä»–ä»¬å¸æ”¶æˆ‘ä»¬æ‰€æä¾›çš„æ‰€æœ‰ä¿¡æ¯ã€‚</p>
</li>
<li>
<p>æ‰¾ä¸€é—´è¶³ä»¥å®¹çº³å…¨ä½“çº¿ä¸‹å­¦å‘˜çš„å¤§æ•™å®¤ã€‚æˆ‘ä»¬å»ºè®®ä½ å°†è¯¾ç¨‹äººæ•°æ§åˆ¶åœ¨ 15-25 äººä¹‹é—´ã€‚è¿™æ ·ï¼Œäººæ•°è¶³å¤Ÿå°‘ï¼Œä¸ä»…ä¾¿äºå­¦å‘˜æé—®é—®é¢˜ï¼Œé…å¤‡çš„ä¸€ä½æ•™å¸ˆä¹Ÿæœ‰æ—¶é—´ç­”ç–‘è§£æƒ‘ã€‚ç¡®ä¿æ•™å®¤å¤‡æœ‰ä¾›ä½ å’Œå­¦ç”Ÿä½¿ç”¨çš„â€œè¯¾æ¡Œâ€ï¼šä½ ä»¬éƒ½éœ€è¦èƒ½å¤Ÿåä¸‹æ¥å¹¶æ“ä½œå„è‡ªçš„ç¬”è®°æœ¬ç”µè„‘ã€‚ç‰¹åˆ«æ˜¯èº«ä¸ºæ•™å¸ˆï¼Œä½ ç°åœºè¦è¿›è¡Œå¤§é‡ç¼–ç ï¼Œæ‰€ä»¥è®²å°å¯¹ä½ æ¥è¯´ç”¨å¤„ä¸å¤§ã€‚</p>
</li>
<li>
<p>åœ¨å¼€è¯¾å½“å¤©ï¼Œè¯·æå‰ä¸€ç‚¹åˆ°æ•™å®¤ï¼Œè®¾ç½®å¥½æ•™å­¦è®¾å¤‡ã€‚æˆ‘ä»¬å»ºè®®ä½ ç›´æ¥åœ¨ç¬”è®°æœ¬ç”µè„‘ä¸Šè¿è¡Œ <code>mdbook serve</code> æ¥æ¼”ç¤ºè¯¾ç¨‹å†…å®¹ï¼ˆè¯·å‚é˜…<a href="https://github.com/google/comprehensive-rust#building">å®‰è£…è¯´æ˜</a>ï¼‰ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿ä½ åœ¨åˆ‡æ¢é¡µé¢æ—¶æ²¡æœ‰å»¶è¿Ÿï¼Œæ¼”ç¤ºæ•ˆæœæ›´å¥½ã€‚å½“ä½ æˆ–è¯¾ç¨‹å­¦å‘˜å‘ç°æ‹¼å†™é”™è¯¯æ—¶ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ç¬”è®°æœ¬ç”µè„‘åŠæ—¶æ›´æ­£ã€‚</p>
</li>
<li>
<p>è®©å­¦å‘˜é‡‡å–å°ç»„å½¢å¼æˆ–ç‹¬ç«‹è§£é¢˜ã€‚é€šå¸¸ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸Šåˆå’Œä¸‹åˆå„å®‰æ’ 30-45 åˆ†é’Ÿçš„ç»ƒä¹ æ—¶é—´ï¼ˆåŒ…æ‹¬æŸ¥çœ‹è§£å†³æ–¹æ¡ˆçš„æ—¶é—´ï¼‰ã€‚è¯·åŠ¡å¿…è¯¢é—®å­¦å‘˜æ˜¯å¦é‡åˆ°å›°éš¾ï¼Œæˆ–æ˜¯å¦éœ€è¦ä»»ä½•å¸®åŠ©ã€‚å¦‚æœä½ çœ‹åˆ°å¤šä½å­¦å‘˜é‡åˆ°åŒæ ·çš„é—®é¢˜ï¼Œè¯·åœ¨ç­çº§é›†ä½“è¿›è¡Œè®²è§£ï¼Œå¹¶æä¾›ç›¸åº”çš„è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚å‘Šè¯‰å¤§å®¶åœ¨æ ‡å‡†åº“çš„ä»€ä¹ˆä½ç½®å¯ä»¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚</p>
</li>
</ol>
<p>ä»Šå¤©çš„åˆ†äº«å°±æ˜¯è¿™äº›ï¼Œç¥ä½ æˆè¯¾é¡ºåˆ©ï¼å¸Œæœ›ä½ å’Œæˆ‘ä»¬ä¸€æ ·ï¼Œä¹åœ¨å…¶ä¸­ï¼</p>
<p>æ¬¢è¿ä½ è¯¾å<a href="https://github.com/google/comprehensive-rust/discussions/86">æä¾›åé¦ˆ</a>ï¼Œå¸®åŠ©æˆ‘ä»¬ä¸æ–­æ”¹è¿›è¯¾ç¨‹ã€‚æˆ‘ä»¬éå¸¸æœŸå¾…äº†è§£å“ªäº›æ–¹é¢åšå¾—ä¸é”™ï¼Œå“ªäº›æ–¹é¢è¿˜éœ€è¦æ”¹è¿›ã€‚åŒæ—¶éå¸¸æ¬¢è¿å­¦ç”Ÿä»¬<a href="https://github.com/google/comprehensive-rust/discussions/100">å‘æˆ‘ä»¬å‘é€åé¦ˆ</a>ï¼</p>
<h1><a class="header" href="#è¯¾ç¨‹ç»“æ„" id="è¯¾ç¨‹ç»“æ„">è¯¾ç¨‹ç»“æ„</a></h1>
<blockquote>
<p>æœ¬é¡µé¢é€‚ç”¨äºè¯¾ç¨‹æ•™å¸ˆã€‚</p>
</blockquote>
<h2><a class="header" href="#rust-äºŒè¿›åˆ¶æ–‡ä»¶" id="rust-äºŒè¿›åˆ¶æ–‡ä»¶">Rust äºŒè¿›åˆ¶æ–‡ä»¶</a></h2>
<p>æˆ‘ä»¬ä¼šåœ¨å¤´ä¸‰å¤©ä»‹ç» <a href="running-the-course/../welcome-day-1.html">Rust åŸºç¡€çŸ¥è¯†</a>ã€‚è¿™å‡ å¤©çš„æ­¥è°ƒä¼šç¨å¿«,å› ä¸ºæˆ‘ä»¬è¦æ¢è®¨è®¸å¤šå±‚é¢:</p>
<ul>
<li>ç¬¬ 1 å¤©:Rust åŸºç¡€çŸ¥è¯†ã€è¯­æ³•ã€æ§åˆ¶æµã€åˆ›å»ºå’Œä½¿ç”¨å€¼ã€‚</li>
<li>Day 2: Memory management, ownership, compound data types, and the standard library.</li>
<li>Day 3: Generics, traits, error handling, testing, and unsafe Rust.</li>
</ul>
<h2><a class="header" href="#æ·±å…¥æ¢ç©¶" id="æ·±å…¥æ¢ç©¶">æ·±å…¥æ¢ç©¶</a></h2>
<p>é™¤äº†ä¸ºæœŸ 3 å¤©çš„â€œRust åŸºç¡€çŸ¥è¯†â€è¯¾ç¨‹å¤–ï¼Œæˆ‘ä»¬è¿˜æ¨å‡ºäº†ä¸€äº›ä¸“é¢˜è¯¾ç¨‹ï¼š</p>
<h3><a class="header" href="#rust-in-android" id="rust-in-android">Rust in Android</a></h3>
<p>The <a href="running-the-course/../android.html">Rust in Android</a> deep dive is a half-day course on using Rust for Android platform development. This includes interoperability with C, C++, and Java.</p>
<p>ä½ å°†éœ€è¦<a href="https://source.android.com/docs/setup/download/downloading">ç­¾å‡º AOSP</a>ã€‚åœ¨åŒä¸€æœºå™¨ä¸Šç­¾å‡º<a href="https://github.com/google/comprehensive-rust">è¯¾ç¨‹åº“</a>ï¼Œ ç„¶åå°† <code>src/android/</code> ç›®å½•ç§»è‡³æ‰€ç­¾å‡ºçš„ AOSP çš„æ ¹ç›®å½•ã€‚è¿™å°†ç¡®ä¿ Android æ„å»ºç³»ç»Ÿèƒ½æ£€æµ‹åˆ° <code>src/android/</code> ä¸­çš„ <code>Android.bp</code> æ–‡ä»¶ã€‚</p>
<p>ç¡®ä¿ <code>adb sync</code> é€‚ç”¨äºä½ çš„æ¨¡æ‹Ÿå™¨æˆ–å®é™…è®¾å¤‡ï¼Œ å¹¶ä½¿ç”¨ <code>src/android/build_all.sh</code> é¢„æ„å»ºæ‰€æœ‰ Android ç¤ºä¾‹ã€‚è¯·é˜…è¯»è„šæœ¬ï¼Œ æŸ¥çœ‹å®ƒæ‰€è¿è¡Œçš„å‘½ä»¤ï¼Œå¹¶ç¡®ä¿è¿™äº›å‘½ä»¤èƒ½åœ¨ä½ æ‰‹åŠ¨è¿è¡Œæ—¶æ­£ç¡®æ‰§è¡Œã€‚</p>
<h3><a class="header" href="#bare-metal-rust" id="bare-metal-rust">Bare-Metal Rust</a></h3>
<p>The <a href="running-the-course/../bare-metal.html">Bare-Metal Rust</a> deep dive is a full day class on using Rust for bare-metal (embedded) development. Both microcontrollers and application processors are covered.</p>
<p>å¯¹äºå¾®æ§åˆ¶å™¨éƒ¨åˆ†ï¼Œä½ éœ€è¦æå‰è´­ä¹° <a href="https://microbit.org/">BBC micro:bit</a> ç¬¬ 2 ç‰ˆå¼€å‘æ¿ã€‚æ¯ä¸ªäººéƒ½éœ€è¦å®‰è£…å¤šä¸ªè½¯ä»¶åŒ…ï¼Œ å…·ä½“å¦‚<a href="running-the-course/../bare-metal.html">æ¬¢è¿é¡µé¢</a>ä¸­æ‰€è¿°ã€‚</p>
<h3><a class="header" href="#æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘" id="æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘">æ¬¢è¿äº†è§£ Rust ä¸­çš„å¹¶å‘</a></h3>
<p><code>[æ·±å…¥æ¢ç©¶å¹¶å‘](../concurrency.md)</code>è¯¾ç¨‹ä¸ºæœŸä¸€å¤©,æ—¨åœ¨ä»‹ç»ä¼ ç»Ÿå¹¶å‘å’Œ <code>async</code>/<code>await</code> å¹¶å‘ã€‚</p>
<p>ä½ éœ€è¦è®¾ç½®ä¸€ä¸ªæ–° crateï¼Œä¸‹è½½æ‰€éœ€çš„ä¾èµ–é¡¹ï¼Œ åšå¥½è¯¾å‰å‡†å¤‡ã€‚ç„¶åï¼Œä½ å¯ä»¥å°†ç¤ºä¾‹å¤åˆ¶/ç²˜è´´åˆ° <code>src/main.rs</code> ä¸­ï¼Œ ä»¥ä¾¿å¯¹ä»¥ä¸‹ä»£ç è¿›è¡Œå®éªŒï¼š</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<h2><a class="header" href="#è¯¾ç¨‹å½¢å¼" id="è¯¾ç¨‹å½¢å¼">è¯¾ç¨‹å½¢å¼</a></h2>
<p>æœ¬è¯¾ç¨‹çš„äº’åŠ¨æ€§éå¸¸å¼ºï¼Œ å»ºè®®ä½ ä»¥é—®é¢˜é©±åŠ¨æ¢ç´¢ Rustï¼</p>
<h1><a class="header" href="#é”®ç›˜å¿«æ·é”®" id="é”®ç›˜å¿«æ·é”®">é”®ç›˜å¿«æ·é”®</a></h1>
<p>mdBook ä¸­æœ‰ä¸€äº›å®ç”¨é”®ç›˜å¿«æ·é”®ï¼š</p>
<ul>
<li><kbd>å‘å·¦ç®­å¤´</kbd>ï¼šè½¬åˆ°ä¸Šä¸€é¡µã€‚</li>
<li><kbd>å‘å³ç®­å¤´</kbd>ï¼šè½¬åˆ°ä¸‹ä¸€é¡µã€‚</li>
<li><kbd>Ctrl + Enter</kbd>ï¼šæ‰§è¡Œå…·æœ‰ç„¦ç‚¹çš„ä»£ç ç¤ºä¾‹ã€‚</li>
<li><kbd>s</kbd>ï¼šæ¿€æ´»æœç´¢æ ã€‚</li>
</ul>
<h1><a class="header" href="#ç¿»è¯‘" id="ç¿»è¯‘">ç¿»è¯‘</a></h1>
<p>ä¸€æ‰¹ä¼˜ç§€çš„å¿—æ„¿è€…å·²å°†æœ¬è¯¾ç¨‹ç¿»è¯‘æˆå…¶ä»–è¯­è¨€ï¼š</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">å·´è¥¿è‘¡è„ç‰™è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/rastringer">@rastringer</a>ã€<a href="https://github.com/hugojacob">@hugojacob</a>ã€<a href="https://github.com/joaovicmendes">@joaovicmendes</a> å’Œ <a href="https://github.com/henrif75">@henrif75</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">éŸ©è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/keispace">@keispace</a>ã€<a href="https://github.com/jiyongp">@jiyongp</a> å’Œ <a href="https://github.com/jooyunghan">@jooyunghan</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/es/">Spanish</a> by <a href="https://github.com/deavid">@deavid</a>.</li>
</ul>
<p>ä½¿ç”¨å³ä¸Šè§’çš„è¯­è¨€é€‰æ‹©å™¨åˆ‡æ¢è¯­è¨€ã€‚</p>
<h2><a class="header" href="#æœªå®Œæˆçš„ç¿»è¯‘" id="æœªå®Œæˆçš„ç¿»è¯‘">æœªå®Œæˆçš„ç¿»è¯‘</a></h2>
<p>å¤šæ•°è¯­è¨€ç‰ˆæœ¬ä»åœ¨ç¿»è¯‘ä¸­ã€‚æˆ‘ä»¬ä¼šæä¾›æœ€è¿‘æ›´æ–°çš„ç¿»è¯‘çš„é“¾æ¥ï¼š</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/bn/">å­ŸåŠ æ‹‰è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/raselmandol">@raselmandol</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-TW/">Chinese (Traditional)</a> by <a href="https://github.com/hueich">@hueich</a>, <a href="https://github.com/victorhsieh">@victorhsieh</a>, <a href="https://github.com/mingyc">@mingyc</a>, and <a href="https://github.com/johnathan79717">@johnathan79717</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/">Chinese (Simplified)</a> by <a href="https://github.com/suetfei">@suetfei</a>, <a href="https://github.com/wnghl">@wnghl</a>, <a href="https://github.com/anlunx">@anlunx</a>, <a href="https://github.com/kongy">@kongy</a>, <a href="https://github.com/noahdragon">@noahdragon</a>, and <a href="https://github.com/superwhd">@superwhd</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">æ³•è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/KookaS">@KookaS</a> å’Œ <a href="https://github.com/vcaen">@vcaen</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">å¾·è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/Throvn">@Throvn</a> å’Œ <a href="https://github.com/ronaldfw">@ronaldfw</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">æ—¥è¯­ç‰ˆæœ¬</a>è¯‘è€…:<a href="https://github.com/CoinEZ">@CoinEZ-JPN</a> å’Œ <a href="https://github.com/momotaro1105">@momotaro1105</a>ã€‚</li>
</ul>
<p>å¦‚æœä½ æƒ³å¸®åŠ©æˆ‘ä»¬,è¯·å‚é˜…<a href="htts://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md">æˆ‘ä»¬çš„è¯´æ˜</a>,äº†è§£å¦‚ä½•å¼€å§‹ç¿»è¯‘ã€‚ç¿»è¯‘å·¥ä½œå°†é€šè¿‡<a href="https://github.com/google/comprehensive-rust/issues/282">é—®é¢˜è·Ÿè¸ªå™¨</a>.</p>
<h1><a class="header" href="#ä½¿ç”¨-cargo" id="ä½¿ç”¨-cargo">ä½¿ç”¨ Cargo</a></h1>
<p>å¼€å§‹äº†è§£ Rust åï¼Œä½ å¾ˆå¿«å°±ä¼šé‡åˆ° <a href="https://doc.rust-lang.org/cargo/">Cargo</a>ï¼Œè¿™æ˜¯ Rust ç”Ÿæ€ç³»ç»Ÿä¸­ ç”¨äºæ„å»ºå’Œè¿è¡Œ Rust åº”ç”¨çš„æ ‡å‡†å·¥å…·ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¸Œæœ› ç®€è¦ä»‹ç»ä¸€ä¸‹ä»€ä¹ˆæ˜¯ Cargoï¼Œå®ƒå¦‚ä½•èå…¥æ›´å¹¿æ³›çš„ç”Ÿæ€ç³»ç»Ÿï¼Œ ä»¥åŠæˆ‘ä»¬å¦‚ä½•åœ¨æœ¬åŸ¹è®­ä¸­åˆç†åˆ©ç”¨ Cargoã€‚</p>
<h2><a class="header" href="#å®‰è£…" id="å®‰è£…">å®‰è£…</a></h2>
<blockquote>
<p><strong>è¯·æŒ‰ç…§ <a href="https://rustup.rs/">https://rustup.rs/</a> ä¸Šçš„è¯´æ˜æ“ä½œã€‚</strong></p>
</blockquote>
<p>è¿™å°†ä¸ºä½ æä¾› Cargo æ„å»ºå·¥å…· (<code>cargo</code>)å’Œ Rust ç¼–è¯‘å™¨ (<code>rustc</code>)ã€‚ä½ è¿˜å°†è·å¾— <code>rustup</code>,è¿™æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œå®ç”¨ç¨‹åº,ä½ å¯ä»¥ç”¨å®ƒæ¥å®‰è£…ä¸åŒçš„ç¼–è¯‘å™¨ç‰ˆæœ¬ã€‚</p>
<p>After installing Rust, you should configure your editor or IDE to work with Rust. Most editors do this by talking to <a href="https://rust-analyzer.github.io/">rust-analyzer</a>, which provides auto-completion and jump-to-definition functionality for <a href="https://code.visualstudio.com/">VS Code</a>, <a href="https://rust-analyzer.github.io/manual.html#emacs">Emacs</a>, <a href="https://rust-analyzer.github.io/manual.html#vimneovim">Vim/Neovim</a>, and many others. There is also a different IDE available called <a href="https://www.jetbrains.com/rust/">RustRover</a>.</p>
<details>
<ul>
<li>
<p>åœ¨ Debian/Ubuntu ä¸Š,ä½ ä¹Ÿå¯ä»¥é€šè¿‡ <code>apt</code> å®‰è£… Cargoã€Rust æºä»£ç å’Œ <a href="https://github.com/rust-lang/rustfmt">Rust æ ¼å¼è®¾ç½®å·¥å…·</a>ã€‚ä½†æ˜¯,è¿™æ ·ä¼šå¾—åˆ°ä¸€ä¸ªè¿‡æ—¶çš„ Rust ç‰ˆæœ¬,å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„è¡Œä¸ºã€‚å‘½ä»¤å¦‚ä¸‹:</p>
<pre><code class="language-shell">sudo apt install cargo rust-src rustfmt
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#rust-ç”Ÿæ€ç³»ç»Ÿ" id="rust-ç”Ÿæ€ç³»ç»Ÿ">Rust ç”Ÿæ€ç³»ç»Ÿ</a></h1>
<p>Rust ç”Ÿæ€ç³»ç»Ÿç”±è®¸å¤šå·¥å…·ç»„æˆï¼Œå…¶ä¸­çš„ä¸»è¦å·¥å…·åŒ…æ‹¬ï¼š</p>
<ul>
<li>
<p><code>rustc</code>ï¼šRust ç¼–è¯‘å™¨ï¼Œå¯å°† <code>.rs</code> æ–‡ä»¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶å’Œå…¶ä»– ä¸­é—´æ ¼å¼ã€‚</p>
</li>
<li>
<p><code>cargo</code>:Rust ä¾èµ–é¡¹ç®¡ç†å™¨å’Œæ„å»ºå·¥å…·ã€‚Cargo çŸ¥é“å¦‚ä½• ä¸‹è½½æ‰˜ç®¡åœ¨ <a href="https://crates.io">https://crates.io</a> ä¸Šçš„ä¾èµ–é¡¹,å¹¶åœ¨æ„å»ºé¡¹ç›®æ—¶å°†å®ƒä»¬ ä¼ é€’ç»™ <code>rustc</code>ã€‚Cargo è¿˜é™„å¸¦ä¸€ä¸ªå†…ç½®çš„ æµ‹è¯•è¿è¡Œç¨‹åº,ç”¨äºæ‰§è¡Œå•å…ƒæµ‹è¯•ã€‚</p>
</li>
<li>
<p><code>rustup</code>ï¼šRust å·¥å…·é“¾å®‰è£…ç¨‹åºå’Œæ›´æ–°ç¨‹åºã€‚å‘å¸ƒæ–°ç‰ˆæœ¬ Rust æ—¶ï¼Œæ­¤å·¥å…·ç”¨äº å®‰è£…å¹¶æ›´æ–° <code>rustc</code> å’Œ <code>cargo</code>ã€‚ æ­¤å¤–ï¼Œ<code>rustup</code> è¿˜å¯ä»¥ä¸‹è½½æ ‡å‡† åº“çš„æ–‡æ¡£ã€‚ä½ å¯ä»¥åŒæ—¶å®‰è£…å¤šä¸ªç‰ˆæœ¬çš„ Rustï¼Œå¹¶ä¸” <code>rustup</code> å¯è®©ä½ æ ¹æ®éœ€è¦åœ¨è¿™äº›ç‰ˆæœ¬ä¹‹é—´åˆ‡æ¢ã€‚</p>
</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Rust æœ‰ä¸€ä¸ªå¿«é€Ÿå‘å¸ƒæ—¶é—´è¡¨ï¼Œæ¯å…­å‘¨å°±ä¼šå‘å¸ƒä¸€æ¬¡ æ–°ç‰ˆæœ¬ã€‚æ–°ç‰ˆæœ¬ä¿æŒä¸ æ—§ç‰ˆæœ¬çš„å‘åå…¼å®¹æ€§ï¼Œè¿˜æ·»åŠ äº†æ–°åŠŸèƒ½ã€‚</p>
</li>
<li>
<p>å…±æœ‰ä¸‰ä¸ªå‘å¸ƒé˜¶æ®µï¼šâ€œç¨³å®šç‰ˆâ€â€œBeta ç‰ˆâ€å’Œâ€œå¤œé—´ç‰ˆâ€ã€‚</p>
</li>
<li>
<p>æˆ‘ä»¬ä¼šåœ¨â€œå¤œé—´ç‰ˆâ€ä¸Šæµ‹è¯•æ–°åŠŸèƒ½ï¼Œæ¯å…­å‘¨å°†â€œBeta ç‰ˆâ€å‡çº§ä¸º â€œç¨³å®šç‰ˆâ€ã€‚</p>
</li>
<li>
<p>æ‚¨ä¹Ÿå¯ä»¥é€šè¿‡å¤‡ç”¨çš„<a href="https://doc.rust-lang.org/cargo/reference/registries.html">æ³¨å†Œæ•°æ®åº“</a>ã€gitã€æ–‡ä»¶å¤¹ç­‰èµ„æºæ¥è§£æä¾èµ–é¡¹ã€‚</p>
</li>
<li>
<p>Rust ä¹Ÿæœ‰ä¸‰ä¸ª[ç‰ˆæœ¬]ï¼šå½“å‰ç‰ˆæœ¬æ˜¯ Rust 2021ã€‚ä¹‹å‰çš„ ç‰ˆæœ¬æ˜¯ Rust 2015 å’Œ Rust 2018ã€‚</p>
<ul>
<li>
<p>è¿™äº›ç‰ˆæœ¬æ”¯æŒå¯¹è¯­è¨€è¿›è¡Œå‘åä¸å…¼å®¹çš„ æ›´æ”¹ã€‚</p>
</li>
<li>
<p>ä¸ºé˜²æ­¢ç ´åä»£ç ï¼Œä½ å¯ä»¥è‡ªè¡Œé€‰æ‹©ç‰ˆæœ¬ï¼š é€šè¿‡ <code>Cargo.toml</code> æ–‡ä»¶ä¸º crate é€‰æ‹©åˆé€‚çš„ç‰ˆæœ¬ã€‚</p>
</li>
<li>
<p>ä¸ºå…åˆ†å‰²ç”Ÿæ€ç³»ç»Ÿï¼ŒRust ç¼–è¯‘å™¨å¯ä»¥æ··åˆä½¿ç”¨ ä¸ºä¸åŒç‰ˆæœ¬ç¼–å†™çš„ä»£ç ã€‚</p>
</li>
<li>
<p>æåŠä¸é€šè¿‡ <code>cargo</code> è€Œç›´æ¥ä½¿ç”¨ç¼–è¯‘å™¨çš„æƒ…å†µç›¸å½“å°‘è§ï¼ˆå¤§å¤šæ•°ç”¨æˆ·ä»ä¸è¿™æ ·åšï¼‰ã€‚</p>
</li>
<li>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒCargo æœ¬èº«å°±æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ä¸”å…¨é¢çš„å·¥å…·ã€‚å®ƒèƒ½å¤Ÿå®ç°è®¸å¤šé«˜çº§åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼š</p>
<ul>
<li>é¡¹ç›®/è½¯ä»¶åŒ…ç»“æ„</li>
<li>[å·¥ä½œåŒº]</li>
<li>å¼€å‘ä¾èµ–é¡¹å’Œè¿è¡Œæ—¶ä¾èµ–é¡¹ç®¡ç†/ç¼“å­˜</li>
<li>[æ„å»ºè„šæœ¬]</li>
<li>[å…¨å±€å®‰è£…] ]</li>
<li>å®ƒè¿˜å¯ä»¥ä½¿ç”¨å­å‘½ä»¤æ’ä»¶ï¼ˆä¾‹å¦‚ <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>ï¼‰è¿›è¡Œæ‰©å±•ã€‚</li>
</ul>
</li>
<li>
<p>å¦‚éœ€äº†è§£è¯¦æƒ…ï¼Œè¯·å‚é˜…[ Cargo å®˜æ–¹å›¾ä¹¦]</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹" id="æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹">æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹</a></h1>
<p>åœ¨æœ¬åŸ¹è®­ä¸­ï¼Œæˆ‘ä»¬å°†ä¸»è¦é€šè¿‡ç¤ºä¾‹ æ¢ç´¢ Rust è¯­è¨€ï¼Œè¿™äº›ç¤ºä¾‹å¯é€šè¿‡æµè§ˆå™¨æ‰§è¡Œã€‚è¿™èƒ½å¤§å¤§ç®€åŒ–è®¾ç½®è¿‡ç¨‹ï¼Œ å¹¶ç¡®ä¿æ‰€æœ‰äººéƒ½èƒ½è·å¾—ä¸€è‡´çš„ä½“éªŒã€‚</p>
<p>æˆ‘ä»¬ä»ç„¶å»ºè®®ä½ å®‰è£… Cargoï¼šå®ƒæœ‰åŠ©äºä½ æ›´è½»æ¾åœ°å®Œæˆ ç»ƒä¹ ã€‚åœ¨æœ€åä¸€å¤©ï¼Œæˆ‘ä»¬è¦åšä¸€ä¸ªæ›´å¤§çš„ç»ƒä¹ ï¼Œ å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨ä¾èµ–é¡¹ï¼Œå› æ­¤ä½ éœ€è¦å®‰è£… Cargoã€‚</p>
<p>æœ¬è¯¾ç¨‹ä¸­çš„ä»£ç å—æ˜¯å®Œå…¨äº¤äº’å¼çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>å½“æ–‡æœ¬æ¡†ä¸º ç„¦ç‚¹æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the text box.</p>
<details>
<p>å¤§å¤šæ•°ä»£ç ç¤ºä¾‹éƒ½å¯ä¿®æ”¹ï¼ˆå¦‚ä¸Šå›¾æ‰€ç¤ºï¼‰ã€‚å°‘æ•°ä»£ç ç¤ºä¾‹ å¯èƒ½ä¼šå› å„ç§åŸå› è€Œä¸å¯ä¿®æ”¹ï¼š</p>
<ul>
<li>
<p>åµŒå…¥å¼ Playground æ— æ³•æ‰§è¡Œå•å…ƒæµ‹è¯•ã€‚å°†ä»£ç å¤åˆ¶å¹¶ç²˜è´´ åˆ°å®é™… Playground ä¸­ï¼Œä»¥æ¼”ç¤ºå•å…ƒæµ‹è¯•ã€‚</p>
</li>
<li>
<p>åµŒå…¥å¼ Playground ä¼šåœ¨ä½ ç¦»å¼€é¡µé¢åç«‹å³ ä¸¢å¤±å…¶çŠ¶æ€ï¼æ­£å› å¦‚æ­¤ï¼Œå­¦å‘˜åº”ä½¿ç”¨æœ¬åœ°å®‰è£…çš„ Rust æˆ–é€šè¿‡ Playground è§£é¢˜ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#ä½¿ç”¨-cargo-åœ¨æœ¬åœ°è¿è¡Œä»£ç " id="ä½¿ç”¨-cargo-åœ¨æœ¬åœ°è¿è¡Œä»£ç ">ä½¿ç”¨ Cargo åœ¨æœ¬åœ°è¿è¡Œä»£ç </a></h1>
<p>å¦‚æœä½ æƒ³åœ¨è‡ªå·±çš„ç³»ç»Ÿä¸Šå¯¹ä»£ç è¿›è¡Œå®éªŒï¼Œ åˆ™éœ€è¦å…ˆå®‰è£… Rustã€‚ä¸ºæ­¤ï¼Œè¯·æŒ‰ç…§ <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust å›¾ä¹¦ä¸­çš„ è¯´æ˜</a>æ“ä½œã€‚è¿™åº”ä¼šä¸ºä½ æä¾›ä¸€ä¸ªæœ‰æ•ˆçš„ <code>rustc</code> å’Œ <code>cargo</code>ã€‚åœ¨æ’°å†™ æœ¬æ–‡æ—¶ï¼Œæœ€æ–°çš„ Rust ç¨³å®šç‰ˆå…·æœ‰ä»¥ä¸‹ç‰ˆæœ¬å·ï¼š</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ä»»ä½•æ›´é«˜ç‰ˆæœ¬,å› ä¸º Rust ä¿æŒå‘åå…¼å®¹æ€§ã€‚</p>
<p>äº†è§£è¿™äº›ä¿¡æ¯åï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ä»æœ¬åŸ¹è®­ä¸­çš„ ä¸€ä¸ªç¤ºä¾‹ä¸­æ„å»º Rust äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<ol>
<li>
<p>åœ¨ä½ è¦å¤åˆ¶çš„ç¤ºä¾‹ä¸Šç‚¹å‡»â€œå¤åˆ¶åˆ°å‰ªè´´æ¿â€æŒ‰é’®ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo new exercise</code> ä¸ºä½ çš„ä»£ç æ–°å»ºä¸€ä¸ª <code>exercise/</code> ç›®å½•ï¼š</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>å¯¼èˆªè‡³ <code>exercise/</code> å¹¶ä½¿ç”¨ <code>cargo run</code> æ„å»ºå¹¶è¿è¡Œä½ çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>å°† <code>src/main.rs</code> ä¸­çš„æ ·æ¿ä»£ç æ›¿æ¢ä¸ºä½ è‡ªå·±çš„ä»£ç ã€‚ä¾‹å¦‚ï¼Œ ä½¿ç”¨ä¸Šä¸€é¡µä¸­çš„ç¤ºä¾‹ï¼Œå°† <code>src/main.rs</code> æ”¹ä¸ºï¼š</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo run</code> æ„å»ºå¹¶è¿è¡Œä½ æ›´æ–°åçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo check</code> å¿«é€Ÿæ£€æŸ¥é¡¹ç›®æ˜¯å¦å­˜åœ¨é”™è¯¯ï¼›ä½¿ç”¨ <code>cargo build</code> åªè¿›è¡Œç¼–è¯‘ï¼Œè€Œä¸è¿è¡Œã€‚ä½ å¯ä»¥åœ¨ <code>target/debug/</code> ä¸­æ‰¾åˆ°å¸¸è§„è°ƒè¯• build çš„è¾“å‡ºã€‚ä½¿ç”¨ <code>cargo build --release</code> åœ¨ <code>target/release/</code> ä¸­ç”Ÿæˆç»è¿‡ä¼˜åŒ–çš„ å‘å¸ƒ buildã€‚</p>
</li>
<li>
<p>ä½ å¯ä»¥é€šè¿‡ä¿®æ”¹ <code>Cargo.toml</code> ä¸ºé¡¹ç›®æ·»åŠ ä¾èµ–é¡¹ã€‚å½“ä½  è¿è¡Œ <code>cargo</code> å‘½ä»¤æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ä¸ºä½ ä¸‹è½½å’Œç¼–è¯‘ç¼ºå¤± çš„ä¾èµ–é¡¹ã€‚</p>
</li>
</ol>
<details>
<p>å°½é‡é¼“åŠ±å…¨ç­å­¦å‘˜å®‰è£… Cargo å¹¶ä½¿ç”¨ æœ¬åœ°ç¼–è¾‘å™¨ã€‚è¿™èƒ½ä¸ºä»–ä»¬è¥é€ å¸¸è§„ å¼€å‘ç¯å¢ƒï¼Œè®©å·¥ä½œå˜å¾—æ›´åŠ è½»æ¾ã€‚</p>
</details><h1><a class="header" href="#æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©" id="æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©">æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©</a></h1>
<p>This is the first day of Rust Fundamentals. We will cover a lot of ground today:</p>
<ul>
<li>
<p>Rust åŸºæœ¬è¯­æ³•ï¼šå˜é‡ï¼Œæ ‡é‡ï¼ˆscalarï¼‰å’Œå¤åˆï¼ˆcompoundï¼‰ç±»å‹ï¼Œæšä¸¾ï¼ˆenumï¼‰ï¼Œç»“æ„ä½“ï¼ˆstructï¼‰ï¼Œå¼•ç”¨ï¼Œå‡½æ•°å’Œæ–¹æ³•ã€‚</p>
</li>
<li>
<p>æ§åˆ¶æµçš„æ„é€ : <code>if</code>, <code>if let</code>, <code>while</code>, <code>while let</code>, <code>break</code>, å’Œ <code>continue</code>ã€‚</p>
</li>
<li>
<p>æ¨¡å¼åŒ¹é…: è§£æ„æšä¸¾, ç»“æ„ä½“å’Œæ•°ç»„ï¼ˆarrayï¼‰ã€‚</p>
</li>
</ul>
<details>
<p>è¯·æé†’å­¦ç”Ÿï¼š</p>
<ul>
<li>ä»–ä»¬å¯ä»¥éšæ—¶æé—®ï¼Œä¸éœ€è¦ç•™åˆ°æœ€åã€‚</li>
<li>è¿™ä¸ªè¯¾ç¨‹æœ¬åº”è¯¥æ˜¯äº’åŠ¨çš„ï¼Œæˆ‘ä»¬é¼“åŠ±å¤§å®¶ç§¯æè®¨è®ºã€‚
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e., keep the discussions related to how Rust does things vs some other language.  It can be hard to find the right balance, but err on the side of allowing  discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>æœ‰äº›é—®é¢˜ä¼šå¯¼è‡´æˆ‘ä»¬æå‰è°ˆåˆ°åé¢çš„å†…å®¹
<ul>
<li>è¿™å®Œå…¨æ²¡æœ‰é—®é¢˜! é‡å¤æ˜¯å­¦ä¹ çš„ä¸€ä¸ªé‡è¦æ–¹æ³•ã€‚è¯·è®°å¾— è¿™äº›å¹»ç¯ç‰‡åªæ˜¯ä¸€ä¸ªè¾…åŠ©ï¼Œä½ å¯ä»¥é€‰æ‹©æ€§åœ°è·³è¿‡ã€‚</li>
</ul>
</li>
</ul>
<p>ç¬¬ä¸€å¤©çš„ä¸»è¦ç›®æ ‡æ˜¯è¦è°ˆåˆ°è‘—åçš„ borrow checkerï¼Œå…¶ä»–æ–¹é¢ç‚¹åˆ°ä¸ºæ­¢ã€‚Rust å¤„ç†å†…å­˜çš„æ–¹å¼æ˜¯å…¶ä¸»è¦ç‰¹ç‚¹ï¼Œè¿™ç‚¹æˆ‘ä»¬åº”è¯¥å°½æ—©å±•ç¤ºç»™å­¦ç”Ÿã€‚</p>
<p>å¦‚æœä½ æ˜¯åœ¨æ•™å®¤é‡Œæ•™æˆæ­¤è¯¾ç¨‹ï¼Œä¸å¦¨åœ¨è¿™é‡Œä»‹ç»ä¸€ä¸‹æ—¶é—´å®‰æ’ã€‚ è¿™è¾¹å»ºè®®æ˜¯æŠŠæ¯å¤©åˆ†æˆä¸¤éƒ¨åˆ†ï¼ˆè·Ÿç€å¹»ç¯ç‰‡æ¥ï¼‰ï¼š</p>
<ul>
<li>æ—©ä¸Šï¼š9:00 åˆ° 12:00ï¼Œ</li>
<li>ä¸‹åˆï¼š13:00 åˆ° 16:00ã€‚</li>
</ul>
<p>å½“ç„¶ä½ ä¹Ÿå¯ä»¥çœ‹æƒ…å†µè°ƒæ•´æ—¶é—´ã€‚ä½†æ˜¯è¯·åŠ¡å¿…è®°å¾—æä¾›ä¼‘æ¯æ—¶é—´ã€‚æˆ‘ä»¬å»ºè®®æ¯ä¸ªå°æ—¶ä¼‘æ¯ä¸€æ¬¡ï¼</p>
</details><h1><a class="header" href="#ä»€ä¹ˆæ˜¯-rust" id="ä»€ä¹ˆæ˜¯-rust">ä»€ä¹ˆæ˜¯ Rustï¼Ÿ</a></h1>
<p>Rust æ˜¯ä¸€ç§æ–°çš„ç¼–ç¨‹è¯­è¨€ï¼Œå®ƒçš„<a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 ç‰ˆæœ¬äº 2015 å¹´å‘å¸ƒ</a>ï¼š</p>
<ul>
<li>Rust æ˜¯ä¸€ç§é™æ€ç¼–è¯‘è¯­è¨€ï¼Œå…¶åŠŸèƒ½å®šä½ä¸ C++ ç›¸ä¼¼
<ul>
<li><code>rustc</code> ä½¿ç”¨ LLVM ä½œä¸ºå®ƒçš„åç«¯ã€‚</li>
</ul>
</li>
<li>Rust æ”¯æŒå¤šç§<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">å¹³å°å’Œæ¶æ„</a>:
<ul>
<li>x86, ARM, WebAssembly, ...</li>
<li>Linux, Mac, Windows, ...</li>
</ul>
</li>
<li>Rust è¢«å¹¿æ³›ç”¨äºå„ç§è®¾å¤‡ä¸­ï¼š
<ul>
<li>å›ºä»¶å’Œå¼•å¯¼ç¨‹åºï¼Œ</li>
<li>æ™ºèƒ½æ˜¾ç¤ºå™¨ï¼Œ</li>
<li>æ‰‹æœºï¼Œ</li>
<li>æ¡Œé¢ï¼Œ</li>
<li>æœåŠ¡å™¨ã€‚</li>
</ul>
</li>
</ul>
<details>
<p>Rust å’Œ C++ é€‚ç”¨äºç±»ä¼¼çš„åœºæ™¯ï¼š</p>
<ul>
<li>æé«˜çš„çµæ´»æ€§ã€‚</li>
<li>é«˜åº¦çš„æ§åˆ¶èƒ½åŠ›ã€‚</li>
<li>Can be scaled down to very constrained devices such as microcontrollers.</li>
<li>æ²¡æœ‰è¿è¡Œæ—¶å’Œåƒåœ¾æ”¶é›†ã€‚</li>
<li>å…³æ³¨ç¨‹åºå¯é æ€§å’Œå®‰å…¨æ€§ï¼Œè€Œä¸ä¼šç‰ºç‰²ä»»ä½•æ€§èƒ½ã€‚</li>
</ul>
</details><h1><a class="header" href="#hello-world" id="hello-world">Hello World!</a></h1>
<p>è®©æˆ‘ä»¬è¿›å…¥æœ€ç®€å•çš„ Rust ç¨‹åºï¼Œä¸€ä¸ªç»å…¸çš„ Hello World ç¨‹åºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello ğŸŒ!&quot;);
}
</code></pre></pre>
<p>ä½ çœ‹åˆ°çš„ï¼š</p>
<ul>
<li>å‡½æ•°ä»¥ <code>fn</code> å¼€å¤´ã€‚</li>
<li>åƒ C å’Œ C++ ä¸€æ ·ï¼Œå—ç”±èŠ±æ‹¬å·åˆ†éš”ã€‚</li>
<li><code>main</code> å‡½æ•°æ˜¯ç¨‹åºçš„å…¥å£ã€‚</li>
<li>Rust æœ‰å«ç”Ÿå® (hygienic macros)ï¼Œ<code>println!</code> å°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚</li>
<li>Rust å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç çš„ï¼Œå¯ä»¥åŒ…å«ä»»ä½• Unicode å­—ç¬¦ã€‚</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see a ton of it over the next three days so we start small with something familiar.</p>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is imperative and it doesnâ€™t try to reinvent things unless absolutely necessary.</p>
</li>
<li>
<p>Rust æ˜¯ä¸€ç§ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼Œå®ƒå®Œå…¨æ”¯æŒ Unicode ç­‰ç‰¹æ€§ã€‚</p>
</li>
<li>
<p>åœ¨éœ€è¦å¤„ç†å¯å˜æ•°é‡çš„å‚æ•°çš„æƒ…å†µä¸‹ï¼ŒRust ä½¿ç”¨å®ï¼ˆæ²¡æœ‰å‡½æ•°<a href="basic-syntax/functions-interlude.html">é‡è½½</a>ï¼‰ã€‚</p>
</li>
<li>
<p>å®æ˜¯â€œå«ç”Ÿçš„â€æ„å‘³ç€å®ƒä»¬ä¸ä¼šæ„å¤–åœ°æ•è·å®ƒä»¬æ‰€åœ¨ä½œç”¨åŸŸä¸­çš„æ ‡è¯†ç¬¦ã€‚Rust çš„å®å®é™…ä¸Šåªæ˜¯<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">éƒ¨åˆ†å«ç”Ÿ</a>ã€‚</p>
</li>
<li>
<p>Rust is multi-paradigm. For example, it has powerful <a href="https://doc.rust-lang.org/book/ch17-00-oop.html">object-oriented programming features</a>, and, while it is not a functional language, it includes a range of <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">functional concepts</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç®€çŸ­ç¤ºä¾‹" id="ç®€çŸ­ç¤ºä¾‹">ç®€çŸ­ç¤ºä¾‹</a></h1>
<p>ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€çŸ­çš„ Rust ç¤ºä¾‹ç¨‹åº</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {              // ç¨‹åºå…¥å£
    let mut x: i32 = 6;  // å¯å˜å˜é‡ç»‘å®š
    print!(&quot;{x}&quot;);       // ä¸ printf ç±»ä¼¼çš„è¾“å‡ºå®
    while x != 1 {       // è¡¨è¾¾å¼å‘¨å›´æ²¡æœ‰æ‹¬å·
        if x % 2 == 0 {  // ä¸å…¶ä»–è¯­è¨€ç±»ä¼¼çš„æ•°å€¼è®¡ç®—
            x = x / 2;
        } else {
            x = 3 * x + 1;
        }
        print!(&quot; -&gt; {x}&quot;);
    }
    println!();
}
</code></pre></pre>
<details>
<p>è¿™æ®µä»£ç å®ç°äº† Collatz çŒœæƒ³ï¼šçŒœæƒ³è®¤ä¸ºè¯¥å¾ªç¯æ€»æ˜¯ä¼šç»“æŸï¼Œä½†è¯¥çŒœæƒ³è¿˜æ²¡æœ‰è¢«è¯æ˜ã€‚å¯ä»¥ç¼–è¾‘ä»£ç æ¥å°è¯•ä¸åŒçš„è¾“å…¥ã€‚</p>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>è¯´æ˜æ‰€æœ‰å˜é‡çš„ç±»å‹éƒ½æ˜¯é™æ€çš„ã€‚å°è¯•åˆ é™¤ <code>i32</code> æ¥è§¦å‘ç±»å‹æ¨æ–­ã€‚å°è¯•ä½¿ç”¨ <code>i8</code> æ¥è§¦å‘è¿è¡Œæ—¶æ•´æ•°æº¢å‡ºã€‚</p>
</li>
<li>
<p>å°† <code>let mut x</code> æ”¹ä¸º <code>let x</code>ï¼Œè®¨è®ºå‡ºç°çš„ç¼–è¯‘é”™è¯¯ã€‚</p>
</li>
<li>
<p>å±•ç¤º <code>print!</code> åœ¨å‚æ•°ä¸æ ¼å¼å­—ç¬¦ä¸²ä¸åŒ¹é…æ—¶äº§ç”Ÿçš„ç¼–è¯‘é”™è¯¯ã€‚</p>
</li>
<li>
<p>å±•ç¤ºå¦‚ä½•ä½¿ç”¨ <code>{}</code> ä½œä¸ºå ä½ç¬¦ï¼Œæ¥è¾“å‡ºæ¯”å•ä¸ªå˜é‡æ›´å¤æ‚çš„è¡¨è¾¾å¼ã€‚</p>
</li>
<li>
<p>å‘å­¦ç”Ÿå±•ç¤ºæ ‡å‡†åº“ï¼Œå±•ç¤ºå¦‚ä½•æœç´¢ <code>std::fmt</code>ï¼Œå…¶ä¸­åŒ…å«ç”¨äºæ ¼å¼åŒ–å­—ç¬¦ä¸²çš„å¾®å‹è¯­è¨€è§„åˆ™ã€‚è¦ç‚¹æ˜¯è®©å­¦ç”Ÿç†Ÿæ‚‰åœ¨æ ‡å‡†åº“ä¸­æœç´¢çš„è¿‡ç¨‹ã€‚</p>
<ul>
<li>In a shell <code>rustup doc std::fmt</code> will open a browser on the local std::fmt documentation</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#ä¸ºä»€ä¹ˆé€‰æ‹©-rust" id="ä¸ºä»€ä¹ˆé€‰æ‹©-rust">ä¸ºä»€ä¹ˆé€‰æ‹© Rustï¼Ÿ</a></h1>
<p>Rust æœ‰ä¸€äº›ç‹¬ç‰¹çš„å–ç‚¹ï¼š</p>
<ul>
<li>ç¼–è¯‘æœŸå†…å­˜å®‰å…¨ã€‚</li>
<li>æ²¡æœ‰è¿è¡Œæ—¶æœªå®šä¹‰è¡Œä¸ºã€‚</li>
<li>ç°ä»£çš„ç¼–ç¨‹è¯­è¨€ç‰¹æ€§ã€‚</li>
</ul>
<details>
<p>åº”è¯¥é—®é—®å­¦ç”Ÿä»¬éƒ½ä½¿ç”¨è¿‡å“ªäº›è¯­è¨€ã€‚æ ¹æ®ç­”æ¡ˆä¾§é‡è®²è§£ Rust çš„ä¸åŒç‰¹æ€§ï¼š</p>
<ul>
<li>
<p>ä½¿ç”¨è¿‡ C æˆ– C++ï¼šRust åˆ©ç”¨â€å€Ÿç”¨æ£€æŸ¥â€æ¶ˆé™¤äº†ä¸€ç±» <em>è¿è¡Œæ—¶é”™è¯¯</em> ã€‚ä½ å¯ä»¥è¾¾åˆ°å ªæ¯” C å’Œ C++ çš„æ€§èƒ½ï¼Œè€Œæ²¡æœ‰å†…å­˜ä¸å®‰å…¨çš„é—®é¢˜ã€‚å¹¶ä¸”ä½ è¿˜å¯ä»¥å¾—åˆ°äº›ç°ä»£çš„è¯­è¨€æ„é€ ï¼Œæ¯”å¦‚æ¨¡å¼åŒ¹é…å’Œå†…ç½®ä¾èµ–ç®¡ç†ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨è¿‡ Java, Go, Python, JavaScript...ï¼šä½ å¯ä»¥å¾—åˆ°å’Œè¿™äº›è¯­è¨€ç›¸åŒçš„å†…å­˜å®‰å…¨ç‰¹æ€§ï¼Œå¹¶æ‹¥æœ‰ç±»ä¼¼çš„ä½¿ç”¨é«˜çº§è¯­è¨€çš„æ„Ÿå—ã€‚åŒæ—¶ä½ å¯ä»¥å¾—åˆ°ç±»ä¼¼ C å’Œ C++ çš„é«˜é€Ÿä¸”å¯é¢„æµ‹çš„æ‰§è¡Œæ€§èƒ½ï¼ˆæ— åƒåœ¾å›æ”¶æœºåˆ¶ï¼‰ï¼Œä»¥åŠåœ¨éœ€è¦æ—¶å¯¹åº•å±‚ç¡¬ä»¶çš„è®¿é—®ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#an-example-in-c" id="an-example-in-c">An Example in C</a></h1>
<p>Letâ€™s consider the following â€œminimum wrong exampleâ€ program in C:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;

int main(int argc, char* argv[]) {
	char *buf, *filename;
	FILE *fp;
	size_t bytes, len;
	struct stat st;

	switch (argc) {
		case 1:
			printf(&quot;Too few arguments!\n&quot;);
			return 1;

		case 2:
			filename = argv[argc];
			stat(filename, &amp;st);
			len = st.st_size;
			
			buf = (char*)malloc(len);
			if (!buf)
				printf(&quot;malloc failed!\n&quot;, len);
				return 1;

			fp = fopen(filename, &quot;rb&quot;);
			bytes = fread(buf, 1, len, fp);
			if (bytes = st.st_size)
				printf(&quot;%s&quot;, buf);
			else
				printf(&quot;fread failed!\n&quot;);

		case 3:
			printf(&quot;Too many arguments!\n&quot;);
			return 1;
	}

	return 0;
}
</code></pre>
<p>How many bugs do you spot?</p>
<details>
<p>Despite just 29 lines of code, this C example contains serious bugs in at least 11:</p>
<ol>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code> (line 28)</li>
<li>Excess argument to <code>printf</code> (line 23)</li>
<li>File descriptor leak (after line 26)</li>
<li>Forgotten braces in multi-line <code>if</code> (line 22)</li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement (line 32)</li>
<li>Forgotten NUL-termination of the <code>buf</code> string, leading to a buffer overflow (line 29)</li>
<li>Memory leak by not freeing the <code>malloc</code>-allocated buffer (line 21)</li>
<li>Out-of-bounds access (line 17)</li>
<li>Unchecked cases in the <code>switch</code> statement (line 11)</li>
<li>Unchecked return values of <code>stat</code> and <code>fopen</code> (lines 18 and 26)</li>
</ol>
<p><em>Shouldnâ€™t these bugs be obvious even for a C compiler?</em><br />
No, surprisingly this code compiles warning-free at the default warning level, even in the latest GCC version (13.2 as of writing).</p>
<p><em>Isnâ€™t this a highly unrealistic example?</em><br />
Absolutely not, these kind of bugs have lead to serious security vulnerabilities in the past. Some examples:</p>
<ul>
<li>Assignment <code>=</code> instead of equality comparison <code>==</code>: <a href="https://freedom-to-tinker.com/2013/10/09/the-linux-backdoor-attempt-of-2003">The Linux Backdoor Attempt of 2003</a></li>
<li>Forgotten braces in multi-line <code>if</code>: <a href="https://dwheeler.com/essays/apple-goto-fail.html">The Apple goto fail vulnerability</a></li>
<li>Forgotten <code>break</code> in a <code>switch</code> statement: <a href="https://nakedsecurity.sophos.com/2012/05/21/anatomy-of-a-security-hole-the-break-that-broke-sudo">The break that broke sudo</a></li>
</ul>
<p><em>How is Rust any better here?</em><br />
Safe Rust makes all of these bugs impossible:</p>
<ol>
<li>Assignments inside an <code>if</code> clause are not supported.</li>
<li>Format strings are checked at compile-time.</li>
<li>Resources are freed at the end of scope via the <code>Drop</code> trait.</li>
<li>All <code>if</code> clauses require braces.</li>
<li><code>match</code> (as the Rust equivalent to <code>switch</code>) does not fall-through, hence you canâ€™t accidentally forget a <code>break</code>.</li>
<li>Buffer slices carry their size and donâ€™t rely on a NUL terminator.</li>
<li>Heap-allocated memory is freed via the <code>Drop</code> trait when the corresponding <code>Box</code> leaves the scope.</li>
<li>Out-of-bounds accesses cause a panic or can be checked via the <code>get</code> method of a slice.</li>
<li><code>match</code> mandates that all cases are handled.</li>
<li>Fallible Rust functions return <code>Result</code> values that need to be unwrapped and thereby checked for success. Additionally, the compiler emits a warning if you miss to check the return value of a function marked with <code>#[must_use]</code>.</li>
</ol>
</details><h1><a class="header" href="#ç¼–è¯‘æœŸä¿éšœ" id="ç¼–è¯‘æœŸä¿éšœ">ç¼–è¯‘æœŸä¿éšœ</a></h1>
<p>ç¼–è¯‘æœŸé™æ€å†…å­˜ç®¡ç†ï¼š</p>
<ul>
<li>ä¸å­˜åœ¨æœªåˆå§‹åŒ–çš„å˜é‡ã€‚</li>
<li>ä¸å­˜åœ¨å†…å­˜æ³„æ¼ï¼ˆ<em>é€šå¸¸æƒ…å†µä¸‹</em>ï¼Œè§æ³¨é‡Šï¼‰ã€‚</li>
<li>ä¸å­˜åœ¨â€œåŒé‡é‡Šæ”¾â€ã€‚</li>
<li>ä¸å­˜åœ¨â€œé‡Šæ”¾åä½¿ç”¨â€ã€‚</li>
<li>ä¸å­˜åœ¨ <code>NULL</code> æŒ‡é’ˆã€‚</li>
<li>ä¸å­˜åœ¨è¢«é—å¿˜çš„äº’æ–¥é”ã€‚</li>
<li>ä¸å­˜åœ¨çº¿ç¨‹ä¹‹é—´çš„æ•°æ®ç«äº‰ã€‚</li>
<li>ä¸å­˜åœ¨è¿­ä»£å™¨å¤±æ•ˆã€‚</li>
</ul>
<details>
<p>åœ¨ï¼ˆå®‰å…¨çš„ï¼‰Rust ä¸­ä¹Ÿæœ‰å¯èƒ½äº§ç”Ÿå†…å­˜æ³„æ¼ã€‚ä¾‹å¦‚ï¼š</p>
<ul>
<li>You can use <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a> to leak a pointer. A use of this could be to get runtime-initialized and runtime-sized static variables</li>
<li>å¯ä»¥ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>std::mem::forget</code></a> æ¥è®©ç¼–è¯‘å™¨â€œå¿˜è®°â€ä¸€ä¸ªå€¼ï¼ˆå³å…¶ææ„å‡½æ•°ä¸ä¼šè¢«æ‰§è¡Œï¼‰ã€‚</li>
<li>å¯ä»¥ä½¿ç”¨ <code>Rc</code> æˆ– <code>Arc</code> æ„å¤–åˆ›å»ºä¸€ä¸ªå¾ªç¯å¼•ç”¨ï¼ˆ<a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html">reference cycle</a>ï¼‰ã€‚</li>
<li>å®é™…ä¸Šï¼Œæœ‰äººè®¤ä¸ºæ— é™å¡«å……ä¸€ä¸ªé›†åˆä¹Ÿæ˜¯ä¸€ç§å†…å­˜æ³„æ¼ï¼ŒRust å¯¹æ­¤æ²¡æœ‰ä¿æŠ¤ã€‚</li>
</ul>
<p>å°±æœ¬è¯¾ç¨‹è€Œè¨€ï¼Œâ€œä¸å­˜åœ¨å†…å­˜æ³„æ¼â€åº”ç†è§£ä¸ºâ€œå‡ ä¹æ²¡æœ‰ <em>æ„å¤–</em> å†…å­˜æ³„æ¼â€ã€‚</p>
</details><h1><a class="header" href="#è¿è¡Œæ—¶ä¿éšœ" id="è¿è¡Œæ—¶ä¿éšœ">è¿è¡Œæ—¶ä¿éšœ</a></h1>
<p>Rust æ²¡æœ‰è¿è¡Œæ—¶æœªå®šä¹‰è¡Œä¸ºï¼š</p>
<ul>
<li>æ•°ç»„è®¿é—®æœ‰è¾¹ç•Œæ£€æŸ¥ã€‚</li>
<li>Integer overflow is defined (panic or wrap-around).</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Integer overflow is defined via the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks"><code>overflow-checks</code></a> compile-time flag. If enabled, the program will panic (a controlled crash of the program), otherwise you get wrap-around semantics. By default, you get panics in debug mode (<code>cargo build</code>) and wrap-around in release mode (<code>cargo build --release</code>).</p>
</li>
<li>
<p>è¾¹ç•Œæ£€æŸ¥ä¸èƒ½ä½¿ç”¨ç¼–è¯‘æ ‡å¿—ç¦ç”¨ï¼Œä¹Ÿä¸èƒ½ç›´æ¥é€šè¿‡ <code>unsafe</code> å…³é”®å­—ç¦ç”¨ã€‚ç„¶è€Œï¼Œ <code>unsafe</code> å…è®¸ä½ è°ƒç”¨ <code>slice::get_unchecked</code> ç­‰ä¸åšè¾¹ç•Œæ£€æŸ¥çš„å‡½æ•°ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#ç°ä»£ç‰¹æ€§" id="ç°ä»£ç‰¹æ€§">ç°ä»£ç‰¹æ€§</a></h1>
<p>Rust is built with all the experience gained in the last decades.</p>
<h2><a class="header" href="#è¯­è¨€ç‰¹æ€§" id="è¯­è¨€ç‰¹æ€§">è¯­è¨€ç‰¹æ€§</a></h2>
<ul>
<li>æšä¸¾å’Œæ¨¡å¼åŒ¹é…ã€‚</li>
<li>æ³›å‹ã€‚</li>
<li>æ— é¢å¤–å¼€é”€å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆFFIï¼‰ã€‚</li>
<li>é›¶æˆæœ¬æŠ½è±¡ã€‚</li>
</ul>
<h2><a class="header" href="#å·¥å…·" id="å·¥å…·">å·¥å…·</a></h2>
<ul>
<li>å¼ºå¤§çš„ç¼–è¯‘å™¨é”™è¯¯æç¤ºã€‚</li>
<li>å†…ç½®ä¾èµ–ç®¡ç†å™¨ã€‚</li>
<li>å¯¹æµ‹è¯•çš„å†…ç½®æ”¯æŒã€‚</li>
<li>ä¼˜ç§€çš„è¯­è¨€æœåŠ¡åè®®ï¼ˆLanguage Server Protocolï¼‰æ”¯æŒã€‚</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>ä¸ C++ ç±»ä¼¼çš„é›¶æˆæœ¬æŠ½è±¡ï¼Œæ„å‘³ç€ä½ ä¸éœ€è¦ä¸ºé«˜çº§ç¨‹åºè¯­è¨€çš„ç»“æ„â€œä»˜å‡ºâ€æ›´å¤šçš„å†…å­˜å’Œ CPUã€‚ä¾‹å¦‚ä½¿ç”¨ <code>for</code> å¾ªç¯ä¸ä½¿ç”¨ <code>.iter().fold()</code> ç»“æ„åº”è¯¥ä¼šç”Ÿæˆå¤§è‡´ç›¸åŒçš„åº•å±‚æŒ‡ä»¤ã€‚</p>
</li>
<li>
<p>å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒRust çš„æšä¸¾æ˜¯â€œä»£æ•°æ•°æ®ç±»å‹â€ï¼ˆä¹Ÿå«â€œå’Œç±»å‹â€ï¼‰ã€‚å®ƒä½¿å¾—ç±»å‹ç³»ç»Ÿå¯ä»¥è¡¨ç¤º <code>Option&lt;T&gt;</code> å’Œ <code>Result&lt;T, E&gt;</code> ç­‰ç»“æ„ã€‚</p>
</li>
<li>
<p>æé†’å­¦ç”Ÿå»é˜…è¯»ç¼–è¯‘é”™è¯¯ --- è®¸å¤šå¼€å‘è€…å·²ç»ä¹ æƒ¯å»å¿½ç•¥å†—é•¿çš„ç¼–è¯‘å™¨è¾“å‡ºã€‚Rust ç¼–è¯‘å™¨ä¼šæ¯”å…¶å®ƒç¼–è¯‘å™¨æ›´å¥è°ˆã€‚å®ƒé€šå¸¸ä¼šæä¾› <em>å¯æ“ä½œçš„</em> åé¦ˆï¼Œå¯ä»¥ç›´æ¥å¤åˆ¶ç²˜è´´åˆ°ä»£ç ä¸­ã€‚</p>
</li>
<li>
<p>ç›¸æ¯” Java, Python å’Œ Go ç­‰è¯­è¨€ï¼ŒRust æ ‡å‡†åº“è¾ƒä¸ºç²¾ç®€ã€‚Rust å¹¶æ²¡æœ‰å†…ç½®ä¸€äº›ä½ å¯èƒ½è®¤ä¸ºæ ‡å‡†å’Œå¿…è¦çš„åŠŸèƒ½ï¼š</p>
<ul>
<li>éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/rand/">rand</a> æ›¿ä»£ã€‚</li>
<li>SSL å’Œ TLS æ”¯æŒï¼Œå¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/rustls/">rusttls</a> æ›¿ä»£ã€‚</li>
<li>JSON æ”¯æŒï¼Œå¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/serde_json/">serde_json</a> æ›¿ä»£ã€‚
Rust è¿™ä¹ˆåšçš„åŸå› æ˜¯æ ‡å‡†åº“ä¸­çš„åŠŸèƒ½æ˜¯æ— æ³•å»é™¤çš„ï¼Œå› æ­¤è¯¥åŠŸèƒ½å¿…é¡»éå¸¸ç¨³å®šã€‚å¯¹äºä»¥ä¸Šä¾‹å­ï¼ŒRust ç¤¾åŒºä»åœ¨å¯»æ‰¾æœ€ä½³è§£å†³æ–¹æ¡ˆ --- ç”šè‡³å¯¹ä¸€äº›æƒ…å†µå¯èƒ½æ²¡æœ‰å•ä¸€çš„â€œæœ€ä½³è§£å†³æ–¹æ¡ˆâ€ã€‚
Rust å†…ç½®äº†ä¸€ä¸ªåŒ…ç®¡ç†å™¨ Cargoï¼Œä½¿å¾—ä¸‹è½½å’Œç¼–è¯‘ç¬¬ä¸‰æ–¹ crate å˜å¾—ç®€å•ã€‚è¿™ä¹Ÿå¯¼è‡´æ ‡å‡†åº“å¯ä»¥æ›´åŠ ç²¾ç®€ã€‚</li>
</ul>
<p>å‘ç°é«˜è´¨é‡çš„ç¬¬ä¸‰æ–¹ crate ä¹Ÿè®¸æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚ <a href="https://lib.rs/">https://lib.rs/</a> ç­‰ç½‘ç«™å¯¹æ­¤é—®é¢˜æœ‰æ‰€å¸®åŠ©ã€‚å®ƒèƒ½å¸®ä½ æ¯”è¾ƒ crate çš„å¥åº·æŒ‡æ ‡ï¼Œä»¥æ‰¾åˆ°ä¸€ä¸ªé«˜è´¨é‡å¹¶å—ä¿¡ä»»çš„ crateã€‚</p>
</li>
<li>
<p><a href="https://rust-analyzer.github.io/">rust-analyzer</a> æ˜¯ä¸€ä¸ªå—åˆ°å¹¿æ³›æ”¯æŒçš„ LSP å®ç°ï¼Œè¢«ä¸»æµçš„ IDE å’Œæ–‡æœ¬ç¼–è¾‘å™¨æ‰€ä½¿ç”¨ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#åŸºæœ¬è¯­æ³•" id="åŸºæœ¬è¯­æ³•">åŸºæœ¬è¯­æ³•</a></h1>
<p>Rust çš„è®¸å¤šè¯­æ³•ä¸ C, C++ å’Œ Java çš„è¯­æ³•ç›¸ä¼¼</p>
<ul>
<li>ä»£ç å—å’Œä½œç”¨åŸŸéƒ½æ˜¯ç”±èŠ±æ‹¬å·æ¥ç•Œå®šçš„ã€‚</li>
<li>è¡Œå†…æ³¨é‡Šä»¥ <code>//</code> èµ·å§‹ï¼Œå—æ³¨é‡Šä½¿ç”¨ <code>/* ... */</code> æ¥ç•Œå®šã€‚</li>
<li><code>if</code> å’Œ <code>while</code> ç­‰å…³é”®è¯ä½œç”¨ä¸ä»¥ä¸Šè¯­è¨€ä¸€è‡´ã€‚</li>
<li>å˜é‡èµ‹å€¼ä½¿ç”¨ <code>=</code>ï¼Œå€¼ä¹‹é—´æ¯”è¾ƒä½¿ç”¨ <code>==</code>ã€‚</li>
</ul>
<h1><a class="header" href="#æ ‡é‡ç±»å‹" id="æ ‡é‡ç±»å‹">æ ‡é‡ç±»å‹</a></h1>
<table><thead><tr><th></th><th>ç±»å‹</th><th>å­—é¢é‡</th></tr></thead><tbody>
<tr><td>æœ‰ç¬¦å·æ•´æ•°</td><td><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></td><td><code>-10</code>, <code>0</code>, <code>1_000</code>, <code>123_i64</code></td></tr>
<tr><td>æ— ç¬¦å·æ•´æ•°</td><td><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></td><td><code>0</code>, <code>123</code>, <code>10_u16</code></td></tr>
<tr><td>æµ®ç‚¹æ•°</td><td><code>f32</code>, <code>f64</code></td><td><code>3.14</code>, <code>-10.0e20</code>, <code>2_f32</code></td></tr>
<tr><td>å­—ç¬¦ä¸²</td><td><code>&amp;str</code></td><td><code>&quot;foo&quot;</code>, <code>&quot;two\nlines&quot;</code></td></tr>
<tr><td>Unicode æ ‡é‡ç±»å‹</td><td><code>char</code></td><td><code>'a'</code>, <code>'Î±'</code>, <code>'âˆ'</code></td></tr>
<tr><td>å¸ƒå°”å€¼</td><td><code>bool</code></td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
<p>å„ç±»å‹å ç”¨çš„ç©ºé—´ä¸ºï¼š</p>
<ul>
<li><code>iN</code>, <code>uN</code> å’Œ <code>fN</code> å ç”¨ <em>N</em> ä½ï¼Œ</li>
<li><code>isize</code> å’Œ <code>usize</code> å ç”¨ä¸€ä¸ªæŒ‡é’ˆå¤§å°çš„ç©ºé—´ï¼Œ</li>
<li><code>char</code> is 32 bits wide,</li>
<li><code>bool</code> is 8 bits wide.</li>
</ul>
<details>
<p>ä¸Šè¡¨ä¸­è¿˜æœ‰ä¸€äº›æœªæåŠçš„è¯­æ³•ï¼š</p>
<ul>
<li>
<p>åŸå§‹å­—ç¬¦ä¸²å¯åœ¨åˆ›å»º <code>&amp;str</code> æ—¶ç¦ç”¨è½¬ä¹‰ï¼š<code>r&quot;\n&quot; == &quot;\\n&quot;</code>ã€‚å¯ä»¥åœ¨å¤–å±‚å¼•å·ä¸¤ä¾§æ·»åŠ ç›¸åŒæ•°é‡çš„ <code>#</code>ï¼Œä»¥åœ¨å­—ç¬¦ä¸²ä¸­åµŒå…¥åŒå¼•å·ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(r#&quot;&lt;a href=&quot;link.html&quot;&gt;link&lt;/a&gt;&quot;#);
    println!(&quot;&lt;a href=\&quot;link.html\&quot;&gt;link&lt;/a&gt;&quot;);
}
</code></pre></pre>
</li>
<li>
<p>å­—èŠ‚ä¸²å¯ä»¥ç”¨äºç›´æ¥åˆ›å»º <code>&amp;[u8]</code> ç±»å‹çš„å€¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, b&quot;abc&quot;);
    println!(&quot;{:?}&quot;, &amp;[97, 98, 99]);
}
</code></pre></pre>
</li>
<li>
<p>All underscores in numbers can be left out, they are for legibility only. So <code>1_000</code> can be written as <code>1000</code> (or <code>10_00</code>), and <code>123_i64</code> can be written as <code>123i64</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#å¤åˆç±»å‹" id="å¤åˆç±»å‹">å¤åˆç±»å‹</a></h1>
<table><thead><tr><th></th><th>ç±»å‹</th><th>å­—é¢é‡</th></tr></thead><tbody>
<tr><td>æ•°ç»„ï¼ˆArraysï¼‰</td><td><code>[T; N]</code></td><td><code>[20, 30, 40]</code>, <code>[0; 3]</code></td></tr>
<tr><td>å…ƒç»„ï¼ˆTuplesï¼‰</td><td><code>()</code>, <code>(T,)</code>, <code>(T1, T2)</code>, ...</td><td><code>()</code>, <code>('x',)</code>, <code>('x', 1.2)</code>, ...</td></tr>
</tbody></table>
<p>æ•°ç»„çš„èµ‹å€¼å’Œè®¿é—®æ“ä½œï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {:?}&quot;, a);
}
</code></pre></pre>
<p>å…ƒç»„çš„èµ‹å€¼å’Œè®¿é—®æ“ä½œï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;t.0: {}&quot;, t.0);
    println!(&quot;t.1: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<p>æ•°ç»„ï¼š</p>
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant) elements of the same type <code>T</code>. Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and <code>[u8; 4]</code> are considered two different types.</p>
</li>
<li>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å­—é¢é‡æ¥ä¸ºæ•°ç»„èµ‹å€¼ã€‚</p>
</li>
<li>
<p>åœ¨ä¸»å‡½æ•°ä¸­ï¼Œæ‰“å°ï¼ˆprintï¼‰è¯­å¥ä½¿ç”¨ <code>?</code> æ ¼å¼è¯·æ±‚è°ƒè¯•å®ç°ã€‚ ä½¿ç”¨å‚æ•° <code>{}</code> æ‰“å°é»˜è®¤è¾“å‡ºï¼Œ<code>{:?}</code> è¡¨ç¤ºä»¥è°ƒè¯•æ ¼å¼è¾“å‡ºã€‚ æˆ‘ä»¬ä¹Ÿå¯ä»¥ä¸åœ¨æ ¼å¼åŒ–å­—ç¬¦ä¸²åé¢æŒ‡å®šå˜é‡å€¼ï¼Œç›´æ¥ä½¿ç”¨ <code>{a}</code> å’Œ <code>{a:?}</code> è¿›è¡Œè¾“å‡ºã€‚</p>
</li>
<li>
<p>æ·»åŠ  <code>#</code>, æ¯”å¦‚ <code>{a:#?}</code>, ä¼šè¾“å‡ºâ€œç¾è§‚æ‰“å°ï¼ˆpretty printingï¼‰â€ æ ¼å¼, è¿™ç§æ ¼å¼å¯èƒ½ä¼šæ›´åŠ æ˜“è¯»ã€‚</p>
</li>
</ul>
<p>å…ƒç»„ï¼š</p>
<ul>
<li>
<p>å’Œæ•°ç»„ä¸€æ ·ï¼Œå…ƒç»„ä¹Ÿå…·æœ‰å›ºå®šçš„é•¿åº¦ã€‚</p>
</li>
<li>
<p>å…ƒç»„å°†ä¸åŒç±»å‹çš„å€¼ç»„æˆä¸€ä¸ªå¤åˆç±»å‹ã€‚</p>
</li>
<li>
<p>å…ƒç»„ä¸­çš„å­—æ®µå¯ä»¥é€šè¿‡è‹±æ–‡å¥å·åŠ ä¸Šå€¼çš„ä¸‹æ ‡è¿›è¡Œè®¿é—®æ¯”å¦‚ï¼š<code>t.0</code>, <code>t.1</code>ã€‚</p>
</li>
<li>
<p>ç©ºå…ƒç»„ <code>()</code> ä¹Ÿè¢«ç§°ä½œ â€œå•å…ƒï¼ˆunitï¼‰ç±»å‹â€. å®ƒæ—¢æ˜¯ä¸€ä¸ªç±»å‹ï¼Œ ä¹Ÿæ˜¯è¿™ç§ç±»å‹çš„å”¯ä¸€å€¼â€”â€”ä¹Ÿå°±æ˜¯è¯´å®ƒçš„ç±»å‹å’Œå®ƒçš„  å€¼éƒ½è¢«è¡¨ç¤ºä¸º <code>()</code>ã€‚å®ƒé€šå¸¸ç”¨äºè¡¨ç¤ºï¼Œæ¯”å¦‚ï¼Œä¸€ä¸ª  å‡½æ•°æˆ–è¡¨è¾¾å¼æ²¡æœ‰è¿”å›å€¼ï¼Œæˆ‘ä»¬ä¼šåœ¨åç»­çš„å¹»ç¯ç‰‡ç§è§åˆ°è¿™ç§ç”¨æ³•ã€‚</p>
<ul>
<li>ä½ å¯ä»¥å°†å…¶ç†è§£ä¸ºä½ å¯èƒ½åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­æ¯”è¾ƒç†Ÿæ‚‰çš„  <code>void</code> ç±»å‹</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#å¼•ç”¨" id="å¼•ç”¨">å¼•ç”¨</a></h1>
<p>å¦‚åŒ C++ ä¸€æ ·ï¼ŒRust ä¹Ÿæä¾›äº†å¼•ç”¨ç±»å‹ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x: i32 = 10;
    let ref_x: &amp;mut i32 = &amp;mut x;
    *ref_x = 20;
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š</p>
<ul>
<li>å°±åƒ C ä¸ C++ ä¸­çš„æŒ‡é’ˆä¸€æ ·ï¼Œå¯¹å¼•ç”¨ <code>ref_x</code> è¿›è¡Œèµ‹å€¼æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»å¯¹å…¶è§£å¼•ç”¨ã€‚</li>
<li>Rust æœ‰æ—¶ä¼šè¿›è¡Œè‡ªåŠ¨è§£å¼•ç”¨ã€‚æ¯”å¦‚è°ƒç”¨æ–¹æ³• <code>ref_x.count_ones()</code> æ—¶ï¼Œref_x ä¼šè¢«è§£å¼•ç”¨ã€‚</li>
<li>å¦‚æœå¼•ç”¨å€¼è¢«å£°æ˜ä¸º <code>mut</code>ï¼ˆå¯å˜å¼•ç”¨ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå¼•ç”¨å€¼å¯ä»¥åœ¨å®ƒçš„ç”Ÿå‘½å‘¨æœŸå†…è¢«ç»‘å®šä¸ºä¸åŒçš„å€¼ã€‚</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>æ³¨æ„ <code>let mut ref_x: &amp;i32</code> ä¸ <code>let ref_x: &amp;mut i32</code> ä¹‹é—´çš„åŒºåˆ«ã€‚ç¬¬ä¸€æ¡è¯­å¥å£°æ˜äº†ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¿®æ”¹è¿™ä¸ªå¼•ç”¨æ‰€ç»‘å®šçš„å€¼ï¼›ç¬¬äºŒæ¡è¯­å¥å£°æ˜äº†ä¸€ä¸ªæŒ‡å‘å¯å˜å˜é‡çš„å¼•ç”¨ã€‚</li>
</ul>
</details><h1><a class="header" href="#æ‚¬å‚å¼•ç”¨" id="æ‚¬å‚å¼•ç”¨">æ‚¬å‚å¼•ç”¨</a></h1>
<p>Rust ä¼šé™æ€åœ°ç¦æ­¢æ‚¬å‚å¼•ç”¨ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let ref_x: &amp;i32;
    {
        let x: i32 = 10;
        ref_x = &amp;x;
    }
    println!(&quot;ref_x: {ref_x}&quot;);
}
</code></pre></pre>
<ul>
<li>ä¸€ä¸ªå¼•ç”¨è¢«è®¤ä¸ºæ˜¯â€œå€Ÿç”¨ï¼ˆborrowï¼‰â€äº†å®ƒæŒ‡å‘çš„å€¼ã€‚</li>
<li>Rust ä¼šè·Ÿè¸ªæ‰€æœ‰å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä»¥ç¡®ä¿è¿™äº›å€¼çš„å­˜æ´»æ—¶é—´è¶³å¤Ÿé•¿ã€‚</li>
<li>æˆ‘ä»¬ä¼šåœ¨è®²åˆ°æ‰€æœ‰æƒï¼ˆownershipï¼‰æ—¶è¯¦ç»†è®¨è®ºå€Ÿç”¨ï¼ˆborrowï¼‰ã€‚</li>
</ul>
<h1><a class="header" href="#åˆ‡ç‰‡" id="åˆ‡ç‰‡">åˆ‡ç‰‡</a></h1>
<p>åˆ‡ç‰‡ (slice) çš„ä½œç”¨æ˜¯æä¾›å¯¹é›†åˆ (collection) çš„è§†å›¾ (view):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];

    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>åˆ‡ç‰‡ä»è¢«åˆ‡ç‰‡çš„ç±»å‹ä¸­å€Ÿç”¨ (borrow) æ•°æ®ã€‚</li>
<li>Question: What happens if you modify <code>a[3]</code> right before printing <code>s</code>?</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rustâ€™s range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain â€˜aliveâ€™ (in scope) for at least as long as our slice. </p>
</li>
<li>
<p>The question about modifying <code>a[3]</code> can spark an interesting discussion, but the answer is that for memory safety reasons you cannot do it through <code>a</code> at this point in the execution, but you can read the data from both <code>a</code> and <code>s</code> safely. It works before you created the slice, and again after the <code>println</code>, when the slice is no longer used. More details will be explained in the borrow checker section.</p>
</li>
</ul>
</details><h1><a class="header" href="#string-vs-str" id="string-vs-str"><code>String</code> vs <code>str</code></a></h1>
<p>ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ç†è§£ Rust ä¸­çš„ä¸¤ç§å­—ç¬¦ä¸²ç±»å‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);
    
    let s3: &amp;str = &amp;s2[6..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<p>Rust æœ¯è¯­ï¼š</p>
<ul>
<li><code>&amp;str</code> æ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦ä¸²ç‰‡æ®µçš„ä¸å¯å˜å¼•ç”¨ã€‚</li>
<li><code>String</code> æ˜¯ä¸€ä¸ªå¯å˜å­—ç¬¦ä¸²ç¼“å†²åŒºã€‚</li>
</ul>
<details>
<ul>
<li>
<p><code>&amp;str</code> å¼•å…¥äº†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘ä¿å­˜åœ¨å†…å­˜å—ä¸­çš„ UTF-8 ç¼–ç å­—ç¬¦ä¸²æ•°æ®çš„ä¸å¯å˜å¼•ç”¨ã€‚   å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆ<code>â€Helloâ€</code>ï¼‰ä¼šä¿å­˜åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚</p>
</li>
<li>
<p>Rust çš„ <code>String</code> ç±»å‹æ˜¯ä¸€ä¸ªå­—èŠ‚ vector çš„å°è£…ã€‚å’Œ <code>Vec&lt;T&gt;</code> ä¸€æ ·ï¼Œå®ƒæ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„ã€‚</p>
</li>
<li>
<p>å’Œå…¶ä»–ç±»å‹ä¸€æ ·ï¼Œ<code>String::from()</code> ä¼šä»å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼›<code>String::new()</code> ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºå­—ç¬¦ä¸²ï¼Œ   ä¹‹åå¯ä»¥ä½¿ç”¨ <code>push()</code> å’Œ <code>push_str()</code> æ–¹æ³•å‘å…¶ä¸­æ·»åŠ å­—ç¬¦ä¸²æ•°æ®ã€‚</p>
</li>
<li>
<p><code>format!()</code> å®å¯ä»¥æ–¹ä¾¿åœ°åŠ¨æ€ç”Ÿæˆæ‹¥æœ‰æ‰€æœ‰æƒçš„å­—ç¬¦ä¸²ã€‚å®ƒæ¥å—å’Œ <code>println!()</code> ç›¸åŒçš„æ ¼å¼è§„èŒƒã€‚</p>
</li>
<li>
<p>ä½ å¯ä»¥é€šè¿‡ <code>&amp;</code> å’Œå¯é€‰çš„èŒƒå›´é€‰æ‹©ä» <code>String</code> ä¸­å€Ÿç”¨ <code>&amp;str</code> åˆ‡ç‰‡ã€‚</p>
</li>
<li>
<p>å¯¹äº C++ ç¨‹åºå‘˜ï¼šå¯ä»¥æŠŠ <code>&amp;str</code> å½“ä½œ C++ ä¸­çš„ <code>const char*</code>ï¼Œä½†æ˜¯å®ƒæ€»æ˜¯æŒ‡å‘å†…å­˜ä¸­çš„ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦ä¸²ã€‚   Rust çš„ <code>String</code> å¤§è‡´ç›¸å½“äº C++ ä¸­ <code>std::string</code> ï¼ˆä¸»è¦åŒºåˆ«ï¼šå®ƒåªèƒ½åŒ…å« UTF-8 ç¼–ç çš„å­—èŠ‚ï¼Œ   å¹¶ä¸”æ°¸è¿œä¸ä¼šä½¿ç”¨å°å­—ç¬¦ä¸²ä¼˜åŒ–ï¼ˆsmall-string optimizationï¼‰ï¼‰ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å‡½æ•°" id="å‡½æ•°">å‡½æ•°</a></h1>
<p>ä¸€ä¸ª Rust ç‰ˆæœ¬çš„è‘—å <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> é¢è¯•é¢˜ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    print_fizzbuzz_to(20);
}

fn is_divisible(n: u32, divisor: u32) -&gt; bool {
    if divisor == 0 {
        return false;
    }
    n % divisor == 0
}

fn fizzbuzz(n: u32) -&gt; String {
    let fizz = if is_divisible(n, 3) { &quot;fizz&quot; } else { &quot;&quot; };
    let buzz = if is_divisible(n, 5) { &quot;buzz&quot; } else { &quot;&quot; };
    if fizz.is_empty() &amp;&amp; buzz.is_empty() {
        return format!(&quot;{n}&quot;);
    }
    format!(&quot;{fizz}{buzz}&quot;)
}

fn print_fizzbuzz_to(n: u32) {
    for i in 1..=n {
        println!(&quot;{}&quot;, fizzbuzz(i));
    }
}
</code></pre></pre>
<details>
<ul>
<li>æˆ‘ä»¬åœ¨ <code>main</code> ä¸­å¼•ç”¨äº†ä¸‹é¢ç¼–å†™çš„ä¸€ä¸ªå‡½æ•°ã€‚ä¸éœ€è¦æå‰å£°æ˜æˆ–æ·»åŠ å¤´æ–‡ä»¶ã€‚ </li>
<li>ç±»å‹è·Ÿéšåœ¨å£°æ˜çš„å‚æ•°åï¼ˆä¸æŸäº›ç¼–ç¨‹è¯­è¨€ç›¸åï¼‰ï¼Œç„¶åæ˜¯è¿”å›ç±»å‹ã€‚</li>
<li>å‡½æ•°ä½“ï¼ˆæˆ–ä»»ä½•å—ï¼‰ä¸­çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼å°†æˆä¸ºè¿”å›å€¼ã€‚åªéœ€çœç•¥è¡¨è¾¾å¼æœ«å°¾çš„ <code>;</code> å³å¯ã€‚</li>
<li>æœ‰äº›å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œä¼šè¿”å›â€œå•å…ƒç±»å‹ï¼ˆunit typeï¼‰â€<code>()</code>ã€‚å¦‚æœçœç•¥äº†<code>-&gt; ()</code>çš„è¿”å›ç±»å‹ï¼Œç¼–è¯‘å™¨å°†ä¼šè‡ªåŠ¨æ¨æ–­ã€‚</li>
<li><code>print_fizzbuzz_to()</code>å‡½æ•°ä¸­<code>for</code>å¾ªç¯çš„èŒƒå›´è¡¨è¾¾å¼ï¼ˆrange expressionï¼‰åŒ…å«<code>=n</code>ï¼Œè¿™ä¼šå¯¼è‡´å®ƒåŒ…æ‹¬ä¸Šé™ã€‚</li>
</ul>
</details><h1><a class="header" href="#rustdoc" id="rustdoc">Rustdoc</a></h1>
<p>Rust ä¸­çš„æ‰€æœ‰è¯­è¨€å…ƒç´ éƒ½å¯ä»¥é€šè¿‡ç‰¹æ®Šçš„ <code>///</code> è¯­æ³•è¿›è¡Œæ–‡æ¡£åŒ–ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
///
/// # Example
/// ```
/// assert!(is_divisible_by(42, 2));
/// ```
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;  // Corner case, early return
    }
    lhs % rhs == 0     // The last expression in a block is the return value
}
</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are automatically documented at <a href="https://docs.rs"><code>docs.rs</code></a> using the <a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is idiomatic to document all public items in an API using this pattern. Code snippets can document usage and will be used as unit tests.</p>
<details>
<ul>
<li>
<p>å‘å­¦ç”Ÿå±•ç¤ºåœ¨ <a href="https://docs.rs/rand"><code>docs.rs/rand</code></a> ä¸­ä¸º <code>rand</code> crate ç”Ÿæˆçš„æ–‡æ¡£ã€‚</p>
</li>
<li>
<p>æœ¬è¯¾ç¨‹çš„å¹»ç¯ç‰‡ä¸­ä¸åŒ…å« rustdocï¼Œè¿™æ˜¯ä¸ºäº†èŠ‚çœç©ºé—´ï¼Œä½†æ˜¯åœ¨å®é™…çš„ä»£ç ä¸­ï¼Œåº”å½“ç¼–å†™ç›¸å…³çš„ç¨‹åºæ–‡æ¡£ã€‚</p>
</li>
<li>
<p>å†…éƒ¨æ–‡æ¡£æ³¨é‡Šå°†åœ¨ç¨åï¼ˆåœ¨è®²è§£æ¨¡å—çš„é¡µé¢ï¼‰è®¨è®ºï¼Œè¿™é‡Œæ— éœ€è¿›è¡Œè¯´æ˜ã€‚</p>
</li>
<li>
<p>Rustdoc comments can contain code snippets that we can run and test using <code>cargo test</code>. We will discuss these tests in the <a href="basic-syntax/../testing/doc-tests.html">Testing section</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#æ–¹æ³•" id="æ–¹æ³•">æ–¹æ³•</a></h1>
<p>æ–¹æ³•æ˜¯ä¸æŸç§ç±»å‹å…³è”çš„å‡½æ•°ã€‚æ–¹æ³•çš„ <code>self</code> å‚æ•°æ˜¯ä¸å…¶å…³è”ç±»å‹çš„ä¸€ä¸ªå®ä¾‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn inc_width(&amp;mut self, delta: u32) {
        self.width += delta;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!(&quot;old area: {}&quot;, rect.area());
    rect.inc_width(5);
    println!(&quot;new area: {}&quot;, rect.area());
}
</code></pre></pre>
<ul>
<li>æˆ‘ä»¬å°†åœ¨ä»Šå¤©çš„ç»ƒä¹ å’Œæ˜å¤©çš„è¯¾ç¨‹ä¸­æ›´æ·±å…¥åœ°å­¦ä¹ æ–¹æ³•ç›¸å…³çš„æ¦‚å¿µã€‚</li>
</ul>
<details>
<ul>
<li>
<p>Add a static method called <code>Rectangle::new</code> and call this from <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn new(width: u32, height: u32) -&gt; Rectangle {
    Rectangle { width, height }
}
</code></pre></pre>
</li>
<li>
<p>While <em>technically</em>, Rust does not have custom constructors, static methods are commonly used to initialize structs (but donâ€™t have to). The actual constructor, <code>Rectangle { width, height }</code>, could be called directly. See the <a href="https://doc.rust-lang.org/nomicon/constructors.html">Rustnomicon</a>.</p>
</li>
<li>
<p>Add a <code>Rectangle::square(width: u32)</code> constructor to illustrate that such static methods can take arbitrary parameters.</p>
</li>
</ul>
</details><h1><a class="header" href="#å‡½æ•°é‡è½½" id="å‡½æ•°é‡è½½">å‡½æ•°é‡è½½</a></h1>
<p>ä¸æ”¯æŒé‡è½½ï¼š</p>
<ul>
<li>æ¯ä¸€ä¸ªå‡½æ•°éƒ½åªæœ‰ä¸€ç§å®ç°ï¼š
<ul>
<li>å§‹ç»ˆæ¥å—å›ºå®šä¸ªæ•°çš„å½¢å‚ã€‚</li>
<li>å§‹ç»ˆæ¥å—ä¸€ç»„å½¢å‚ç±»å‹ã€‚</li>
</ul>
</li>
<li>ä¸æ”¯æŒæä¾›é»˜è®¤å€¼ï¼š
<ul>
<li>å®å‚çš„æ•°é‡åœ¨æ‰€æœ‰è°ƒç”¨çš„åœ°æ–¹éƒ½æ˜¯ä¸€æ ·çš„ã€‚</li>
<li>æœ‰æ—¶å¯ä»¥ç”¨å®ï¼ˆMacroï¼‰ä½œä¸ºæ›¿ä»£ã€‚</li>
</ul>
</li>
</ul>
<p>ç„¶è€Œï¼Œå‡½æ•°å½¢å‚å¯ä»¥æ˜¯æ³›å‹ï¼ˆgenericsï¼‰ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn pick_one&lt;T&gt;(a: T, b: T) -&gt; T {
    if std::process::id() % 2 == 0 { a } else { b }
}

fn main() {
    println!(&quot;coin toss: {}&quot;, pick_one(&quot;heads&quot;, &quot;tails&quot;));
    println!(&quot;cash prize: {}&quot;, pick_one(500, 1000));
}
</code></pre></pre>
<details>
<ul>
<li>æ ‡å‡†åº“ä¸­çš„ <code>Into&lt;T&gt;</code> é€šè¿‡æ³›å‹å‚æ•°æä¾›äº†ä¸€ç§å…·æœ‰æœ‰é™å¤šæ€æ€§çš„å‚æ•°ç±»å‹ã€‚è¯¦è§ä¹‹åçš„ç« èŠ‚ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç¬¬ä¸€å¤©ä¸Šåˆä¹ é¢˜" id="ç¬¬ä¸€å¤©ä¸Šåˆä¹ é¢˜">ç¬¬ä¸€å¤©ä¸Šåˆä¹ é¢˜</a></h1>
<p>åœ¨è¿™äº›ä¹ é¢˜ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢ Rust çš„ä¸¤ä¸ªéƒ¨åˆ†ï¼š</p>
<ul>
<li>
<p>ç±»å‹ä¹‹é—´çš„éšå¼è½¬æ¢ã€‚</p>
</li>
<li>
<p>æ•°ç»„å’Œ <code>for</code> å¾ªç¯ã€‚</p>
</li>
</ul>
<details>
<p>åœ¨è§£é¢˜æ—¶è¦è€ƒè™‘å‡ ä»¶äº‹ï¼š</p>
<ul>
<li>
<p>æœ€å¥½ä½¿ç”¨æœ¬åœ°å®‰è£…çš„ Rustï¼Œä»¥å®ç°åœ¨ç¼–è¾‘å™¨ä¸­è‡ªåŠ¨è¡¥å…¨ã€‚å…³äºå®‰è£… Rust çš„ç»†èŠ‚ï¼Œè¯·å‚è§ [ä½¿ç”¨ Cargo] é¡µé¢ã€‚</p>
</li>
<li>
<p>ä¹Ÿå¯ä»¥ä½¿ç”¨ Rust Playground ä½œä¸ºæ›¿ä»£ã€‚</p>
</li>
</ul>
<p>é¡µé¢å†…åµŒçš„ä»£ç ç‰‡æ®µæ˜¯ä¸å¯ç¼–è¾‘çš„ï¼šå› ä¸ºç¦»å¼€é¡µé¢åå†…åµŒä»£ç ç‰‡æ®µä¸­çš„ä¿®æ”¹ä¼šä¸¢å¤±ã€‚</p>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#éšå¼ç±»å‹è½¬æ¢" id="éšå¼ç±»å‹è½¬æ¢">éšå¼ç±»å‹è½¬æ¢</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">ä¸ C++ ä¸åŒ</a>ï¼ŒRust ä¸ä¼šè‡ªåŠ¨è¿›è¡Œ <em>éšå¼ç±»å‹è½¬æ¢</em>ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ç¨‹åºä¸­ä¸å­˜åœ¨éšå¼ç±»å‹è½¬æ¢ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn multiply(x: i16, y: i16) -&gt; i16 {
    x * y
}

fn main() {
    let x: i8 = 15;
    let y: i16 = 1000;

    println!(&quot;{x} * {y} = {}&quot;, multiply(x, y));
}
</code></pre></pre>
<p>Rust çš„æ•´æ•°ç±»å‹éƒ½å®ç°äº† <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From&lt;T&gt;</code></a> å’Œ <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a> traitï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚<code>From&lt;T&gt;</code> trait åŒ…å« <code>from()</code> æ–¹æ³•ï¼Œ<code>Into&lt;T&gt;</code> trait åŒ…å« <code>into()</code> æ–¹æ³•ã€‚ç±»å‹é€šè¿‡å®ç°è¿™äº› trait æ¥è¡¨è¾¾å®ƒå°†è¢«å¦‚ä½•è½¬æ¢ä¸ºå¦ä¸€ä¸ªç±»å‹ã€‚</p>
<p>æ ‡å‡†åº“ä¸­åŒ…å« <code>From&lt;i8&gt; for i16</code> çš„å®ç°ï¼Œå³æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ <code>i16::from(x)</code> æ¥å°† <code>i8</code> ç±»å‹çš„å˜é‡ <code>x</code> è½¬æ¢ä¸º <code>i16</code>ã€‚æˆ–è€…ä¹Ÿå¯ä»¥ç®€å•åœ°ä½¿ç”¨ <code>x.into()</code>ï¼Œå› ä¸º <code>From&lt;i8&gt; for i16</code> çš„å®ç°ä¼šè‡ªåŠ¨åˆ›å»º <code>Into&lt;i16&gt; for i8</code> çš„å®ç°ã€‚</p>
<p>è¿™åŒæ ·ä¹Ÿé€‚ç”¨äºè‡ªå®šä¹‰ç±»å‹çš„ <code>From</code> å®ç°ï¼Œåªéœ€å®ç° <code>From</code> å°±å¯ä»¥è‡ªåŠ¨å¾—åˆ°å¯¹åº”çš„ <code>Into</code> å®ç°ã€‚</p>
<ol>
<li>
<p>æ‰§è¡Œä¸Šè¿°ç¨‹åºï¼Œå¹¶æŸ¥çœ‹å¯¹åº”çš„ç¼–è¯‘é”™è¯¯ã€‚</p>
</li>
<li>
<p>ä¿®æ”¹ä»£ç ï¼Œä½¿ç”¨ <code>into()</code> è¿›è¡Œç±»å‹è½¬æ¢ã€‚</p>
</li>
<li>
<p>ä¿®æ”¹ <code>x</code> å’Œ <code>y</code> çš„ç±»å‹ï¼ˆä¾‹å¦‚ <code>f32</code>, <code>bool</code>, <code>i128</code> ç­‰ï¼‰æ¥äº†è§£å“ªäº›ç±»å‹ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢ã€‚å°è¯•å°†è¾ƒå°çš„ç±»å‹è½¬æ¢ä¸ºè¾ƒå¤§çš„ç±»å‹å’Œå°†è¾ƒå¤§çš„ç±»å‹è½¬æ¢ä¸ºè¾ƒå°çš„ç±»å‹ã€‚é˜…è¯» <a href="https://doc.rust-lang.org/std/convert/trait.From.html">æ ‡å‡†åº“æ–‡æ¡£</a> æ¥äº†è§£å¯¹äºä½ æ‰€å°è¯•çš„ä¸¤ä¸ªç±»å‹ <code>From&lt;T&gt;</code> æ˜¯å¦å·²è¢«å®ç°ã€‚</p>
</li>
</ol>
<h1><a class="header" href="#æ•°ç»„ä¸-for-å¾ªç¯" id="æ•°ç»„ä¸-for-å¾ªç¯">æ•°ç»„ä¸ <code>for</code> å¾ªç¯</a></h1>
<p>æˆ‘ä»¬å¯ä»¥è¿™æ ·å£°æ˜ä¸€ä¸ªæ•°ç»„ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [10, 20, 30];
<span class="boring">}
</span></code></pre></pre>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>{:?}</code> æ¥æ‰“å°è¿™ç§æ•°ç»„çš„è°ƒè¯•æ ¼å¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [10, 20, 30];
    println!(&quot;array: {array:?}&quot;);
}
</code></pre></pre>
<p>åœ¨ Rust ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ <code>for</code> å…³é”®è¯éå†æ•°ç»„å’ŒåŒºé—´ç­‰å…ƒç´ ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let array = [10, 20, 30];
    print!(&quot;Iterating over array:&quot;);
    for n in &amp;array {
        print!(&quot; {n}&quot;);
    }
    println!();

    print!(&quot;Iterating over range:&quot;);
    for i in 0..3 {
        print!(&quot; {}&quot;, array[i]);
    }
    println!();
}
</code></pre></pre>
<p>ä½¿ç”¨ä»¥ä¸ŠçŸ¥è¯†ï¼Œå†™ä¸€ä¸ªç”¨æ˜“è¯»çš„æ ¼å¼è¾“å‡ºçŸ©é˜µçš„ <code>pretty_print</code> å‡½æ•°ï¼Œä»¥åŠä¸€ä¸ªå¯¹çŸ©é˜µè¿›è¡Œè½¬ç½®ï¼ˆå°†è¡Œå’Œåˆ—äº’æ¢ï¼‰çš„ <code>transpose</code> å‡½æ•°ï¼š</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7â¤</text><text x="250" y="28" >8â¥</text><text x="250" y="44" >9â¦</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">â›</text><text x="98" y="12">â¡</text><text x="106" y="12">1</text></g><g><text x="90" y="28">âœ</text><text x="98" y="28">â¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">â</text><text x="98" y="44">â£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3â¤</text><text x="154" y="12">â</text></g><g><text x="138" y="28">6â¥</text><text x="154" y="28">âŸ</text></g><g><text x="138" y="44">9â¦</text><text x="154" y="44">â </text></g><g><text x="210" y="12">â¡</text><text x="218" y="12">1</text></g><g><text x="210" y="28">â¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">â£</text><text x="218" y="44">3</text></g></svg></div>
<p>ç¡¬ç¼–ç è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œè®©å®ƒä»¬å¤„ç† 3 Ã— 3 çš„çŸ©é˜µã€‚</p>
<p>å°†ä¸‹é¢çš„ä»£ç å¤åˆ¶åˆ° <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> å¹¶å®ç°ä¸Šè¿°å‡½æ•°ï¼š</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: å®Œæˆä½ çš„å®ç°åç§»é™¤æ­¤è¡Œã€‚
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    unimplemented!()
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- è¿™ä¸ªæ³¨é‡Šä¼šè®© rustfmt æ·»åŠ ä¸€ä¸ªæ–°è¡Œ
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h2><a class="header" href="#é™„åŠ é¢˜" id="é™„åŠ é¢˜">é™„åŠ é¢˜</a></h2>
<p>æ˜¯å¦å¯ä»¥ä½¿ç”¨ <code>&amp;[i32]</code> åˆ‡ç‰‡è€Œä¸æ˜¯ç¡¬ç¼–ç çš„ 3 Ã— 3 çŸ©é˜µä½œä¸ºå‡½æ•°çš„å‚æ•°å’Œè¿”å›ç±»å‹ï¼Ÿä¾‹å¦‚ä½¿ç”¨ <code>&amp;[&amp;[i32]]</code> è¡¨ç¤ºä¸€ä¸ªäºŒç»´çš„åˆ‡ç‰‡çš„åˆ‡ç‰‡ã€‚ä¸ºä»€ä¹ˆè¿™æ ·åšæ˜¯å¯è¡Œæˆ–ä¸å¯è¡Œçš„ï¼Ÿ</p>
<p>å‚è€ƒ <a href="https://docs.rs/ndarray/"><code>ndarray</code> crate</a> ä»¥äº†è§£è¯¥åŠŸèƒ½æ»¡è¶³ç”Ÿäº§ç¯å¢ƒè´¨é‡çš„å®ç°ã€‚</p>
<details>
<p>é¢˜ç›®è§£ç­”å’Œé™„åŠ é¢˜çš„ç­”æ¡ˆåœ¨ <a href="exercises/day-1/solutions-morning.html#arrays-and-for-loops">é¢˜è§£</a> ç« èŠ‚ä¸­ã€‚</p>
<p>The use of the reference <code>&amp;array</code> within <code>for n in &amp;array</code> is a subtle preview of issues of ownership that will come later in the afternoon.</p>
<p>Without the <code>&amp;</code>...</p>
<ul>
<li>The loop would have been one that consumes the array.  This is a change <a href="https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html">introduced in the 2021 Edition</a>.</li>
<li>An implicit array copy would have occurred.  Since <code>i32</code> is a copy type, then <code>[i32; 3]</code> is also a copy type.</li>
</ul>
</details><h1><a class="header" href="#æ§åˆ¶æµ" id="æ§åˆ¶æµ">æ§åˆ¶æµ</a></h1>
<p>æ­£å¦‚æˆ‘ä»¬æ‰€çŸ¥ï¼Œ<code>if</code> æ˜¯ Rust ä¸­çš„ä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®ƒç”¨äºæœ‰æ¡ä»¶åœ° è¯„ä¼°ä¸¤ä¸ªå—ä¸­çš„ä¸€ä¸ªï¼Œä½†è¿™äº›å—å¯ä»¥æœ‰ä¸€ä¸ªå€¼ï¼Œ ç„¶åæˆä¸º <code>if</code> è¡¨è¾¾å¼çš„å€¼ã€‚å…¶ä»–æ§åˆ¶æµè¡¨è¾¾å¼åœ¨ Rust ä¸­ä¹Ÿæœ‰ç±»ä¼¼ çš„è¿ä½œæ–¹å¼ã€‚</p>
<h1><a class="header" href="#å—" id="å—">å—</a></h1>
<p>A block in Rust contains a sequence of expressions. Each block has a value and a type, which are those of the last expression of the block:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = {
        let y = 10;
        println!(&quot;y: {y}&quot;);
        let z = {
            let w = {
                3 + 4
            };
            println!(&quot;w: {w}&quot;);
            y * w
        };
        println!(&quot;z: {z}&quot;);
        z - y
    };
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<p>åŒæ ·çš„è§„åˆ™ä¹Ÿé€‚ç”¨äºå‡½æ•°ï¼šå‡½æ•°ä¸»ä½“çš„å€¼ æ˜¯è¿”å›å€¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn double(x: i32) -&gt; i32 {
    x + x
}

fn main() {
    println!(&quot;double: {}&quot;, double(7));
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>è¿™å¼ å¹»ç¯ç‰‡çš„é‡ç‚¹æ˜¯è¯´æ˜åœ¨ Rust ä¸­ï¼Œå—æœ‰ç±»å‹å’Œå€¼ã€‚</li>
<li>ä½ å¯ä»¥é€šè¿‡æ›´æ”¹å—çš„æœ€åä¸€è¡Œï¼Œæ¥å±•ç¤ºå—å€¼çš„å˜åŒ–æƒ…å†µã€‚ä¾‹å¦‚ï¼Œæ·»åŠ /ç§»é™¤åˆ†å·æˆ–ä½¿ç”¨ <code>return</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#if-è¡¨è¾¾å¼" id="if-è¡¨è¾¾å¼"><code>if</code> è¡¨è¾¾å¼</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> è¡¨è¾¾å¼</a> çš„ç”¨æ³•ä¸å…¶ä»–è¯­è¨€ä¸­çš„ <code>if</code> è¯­å¥å®Œå…¨ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    if x % 2 == 0 {
        x = x / 2;
    } else {
        x = 3 * x + 1;
    }
}
</code></pre></pre>
<p>æ­¤å¤–ï¼Œä½ è¿˜å¯ä»¥å°† <code>if</code> ç”¨ä½œä¸€ä¸ªè¡¨è¾¾å¼ã€‚æ¯ä¸ªå—çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ å°†æˆä¸º <code>if</code> è¡¨è¾¾å¼çš„å€¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    x = if x % 2 == 0 {
        x / 2
    } else {
        3 * x + 1
    };
}
</code></pre></pre>
<details>
<p>ç”±äº <code>if</code> æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ä¸”å¿…é¡»æœ‰ä¸€ä¸ªç‰¹å®šçš„ç±»å‹ï¼Œå› æ­¤å®ƒçš„ä¸¤ä¸ªåˆ†æ”¯å—å¿…é¡»æœ‰ç›¸åŒçš„ç±»å‹ã€‚è€ƒè™‘åœ¨ç¬¬äºŒä¸ªç¤ºä¾‹ä¸­å°† <code>;</code> æ·»åŠ åˆ° <code>x / 2</code> çš„åé¢ï¼Œçœ‹çœ‹ä¼šå‡ºç°ä»€ä¹ˆæƒ…å†µã€‚</p>
</details><h1><a class="header" href="#for-å¾ªç¯" id="for-å¾ªç¯"><code>for</code> å¾ªç¯</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> is closely related to the <a href="control-flow/while-let-expressions.html"><code>while let</code> loop</a>. It will automatically call <code>into_iter()</code> on the expression and then iterate over it:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];

    for x in v {
        println!(&quot;x: {x}&quot;);
    }
    
    for i in (0..10).step_by(2) {
        println!(&quot;i: {i}&quot;);
    }
}
</code></pre></pre>
<p>ä½ å¯ä»¥åœ¨æ­¤ç…§å¸¸ä½¿ç”¨ <code>break</code> å’Œ <code>continue</code>ã€‚</p>
<details>
<ul>
<li>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç´¢å¼•è¿­ä»£åœ¨ Rust ä¸­å¹¶ä¸æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„è¯­æ³•ã€‚</li>
<li><code>(0..10)</code> æ˜¯å®ç° <code>Iterator</code> trait çš„èŒƒå›´ã€‚</li>
<li><code>step_by</code> æ˜¯è¿”å›å¦ä¸€ä¸ª <code>Iterator</code> çš„æ–¹æ³•ï¼Œç”¨äºé€ä¸€è·³è¿‡æ‰€æœ‰å…¶ä»–å…ƒç´ ã€‚</li>
<li>ä¿®æ”¹çŸ¢é‡ä¸­çš„å…ƒç´ å¹¶è¯´æ˜ç¼–è¯‘å™¨é”™è¯¯ã€‚å°†çŸ¢é‡ <code>v</code> æ”¹ä¸ºå¯å˜ï¼Œå¹¶å°† for å¾ªç¯æ”¹ä¸º <code>for x in v.iter_mut()</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#while-å¾ªç¯" id="while-å¾ªç¯"><code>while</code> å¾ªç¯</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> å…³é”®å­—</a> çš„å·¥ä½œæ–¹å¼ä¸å…¶ä»–è¯­è¨€éå¸¸ç›¸ä¼¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    while x != 1 {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
    }
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#break-å’Œ-continue" id="break-å’Œ-continue"><code>break</code> å’Œ <code>continue</code></a></h1>
<ul>
<li>å¦‚æœä½ æƒ³æå‰é€€å‡ºå¾ªç¯ï¼Œè¯·ä½¿ç”¨ <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>ï¼Œ</li>
<li>å¦‚æœéœ€è¦ç«‹å³å¯åŠ¨ ä¸‹ä¸€æ¬¡è¿­ä»£ï¼Œè¯·ä½¿ç”¨ <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>ã€‚</li>
</ul>
<p><code>continue</code> å’Œ <code>break</code> éƒ½å¯ä»¥é€‰æ‹©æ¥å—ä¸€ä¸ªæ ‡ç­¾å‚æ•°ï¼Œç”¨æ¥ ç»ˆæ­¢åµŒå¥—å¾ªç¯ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();
    'outer: while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
        let mut i = 0;
        while i &lt; x {
            println!(&quot;x: {x}, i: {i}&quot;);
            i += 1;
            if i == 3 {
                break 'outer;
            }
        }
    }
}
</code></pre></pre>
<p>åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨å†…å¾ªç¯ 3 æ¬¡è¿­ä»£åç»ˆæ­¢å¤–å¾ªç¯ã€‚</p>
<h1><a class="header" href="#loop-è¡¨è¾¾å¼" id="loop-è¡¨è¾¾å¼"><code>loop</code> è¡¨è¾¾å¼</a></h1>
<p>æœ€åæ˜¯ç”¨äºåˆ›å»ºæ— é™å¾ªç¯çš„ <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code> å…³é”®å­—</a> ã€‚</p>
<p>åœ¨ä¸‹ä¾‹ä¸­ï¼Œä½ å¿…é¡» <code>break</code> æˆ– <code>return</code> æ‰èƒ½åœæ­¢å¾ªç¯ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 10;
    loop {
        x = if x % 2 == 0 {
            x / 2
        } else {
            3 * x + 1
        };
        if x == 1 {
            break;
        }
    }
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>ç”¨ä¸€ä¸ªå€¼ï¼ˆä¾‹å¦‚ <code>break 8</code>ï¼‰æ¥ä¸­æ–­ <code>loop</code> å¹¶å°†å…¶è¾“å‡ºã€‚</li>
<li>è¯·æ³¨æ„ï¼Œ<code>loop</code> æ˜¯å”¯ä¸€è¿”å›æœ‰æ„ä¹‰çš„å€¼çš„å¾ªç¯ç»“æ„ã€‚ è¿™æ˜¯å› ä¸ºå®ƒä¿è¯è‡³å°‘è¢«è¾“å…¥ä¸€æ¬¡ï¼ˆä¸ <code>while</code> å’Œ <code>for</code> å¾ªç¯ä¸åŒï¼‰ã€‚</li>
</ul>
</details><h1><a class="header" href="#å˜é‡" id="å˜é‡">å˜é‡</a></h1>
<p>Rust é€šè¿‡é™æ€ç±»å‹å®ç°äº†ç±»å‹å®‰å…¨ã€‚å˜é‡ç»‘å®šé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>ç”±äºç±»å‹æ¨å¯¼ï¼Œ<code>i32</code> å¯ä»¥çœç•¥ã€‚éšç€è¯¾ç¨‹æ¨è¿›ï¼Œæˆ‘ä»¬ä¼šè¶Šæ¥è¶Šå°‘åœ°çœ‹åˆ°ç±»å‹å£°æ˜ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç±»å‹æ¨å¯¼" id="ç±»å‹æ¨å¯¼">ç±»å‹æ¨å¯¼</a></h1>
<p>Rust ä¼šæ ¹æ®å˜é‡çš„ä½¿ç”¨æ¥ç¡®å®šå…¶ç±»å‹ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>è¿™å¼ å¹»ç¯ç‰‡æ¼”ç¤ºäº† Rust ç¼–è¯‘å™¨æ˜¯å¦‚ä½•æ ¹æ®å˜é‡å£°æ˜å’Œç”¨æ³•æ¥æ¨å¯¼å…¶ç±»å‹çš„ã€‚</p>
<p>éœ€è¦é‡ç‚¹å¼ºè°ƒçš„æ˜¯è¿™æ ·å£°æ˜çš„å˜é‡å¹¶éåƒé‚£ç§åŠ¨æ€ç±»å‹è¯­è¨€ä¸­å¯ä»¥æŒæœ‰ä»»ä½•æ•°æ®çš„â€œä»»ä½•ç±»å‹â€ã€‚è¿™ç§å£°æ˜æ‰€ç”Ÿæˆçš„æœºå™¨ç ä¸æ˜ç¡®ç±»å‹å£°æ˜å®Œå…¨ç›¸åŒã€‚ç¼–è¯‘å™¨è¿›è¡Œç±»å‹æ¨å¯¼èƒ½å¤Ÿè®©æˆ‘ä»¬ç¼–å†™æ›´ç®€ç•¥çš„ä»£ç ã€‚</p>
<p>The following code tells the compiler to copy into a certain generic container without the code ever explicitly specifying the contained type, using <code>_</code> as a placeholder:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v = Vec::new();
    v.push((10, false));
    v.push((20, true));
    println!(&quot;v: {v:?}&quot;);

    let vv = v.iter().collect::&lt;std::collections::HashSet&lt;_&gt;&gt;();
    println!(&quot;vv: {vv:?}&quot;);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.collect"><code>collect</code></a> relies on <a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a>, which <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#impl-FromIterator%3CT%3E-for-HashSet%3CT,+S%3E"><code>HashSet</code></a> implements.</p>
</details><h1><a class="header" href="#é™æ€-static-å˜é‡å’Œå¸¸æ•°-constant-å˜é‡" id="é™æ€-static-å˜é‡å’Œå¸¸æ•°-constant-å˜é‡">é™æ€ (Static) å˜é‡å’Œå¸¸æ•° (Constant) å˜é‡</a></h1>
<p>Static and constant variables are two different ways to create globally-scoped values that cannot be moved or reallocated during the execution of the program. </p>
<h2><a class="header" href="#const" id="const"><code>const</code></a></h2>
<p>Constant variables are evaluated at compile time and their values are inlined wherever they are used:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>æ ¹æ® <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> è¿™äº›å˜é‡åœ¨ä½¿ç”¨æ—¶æ˜¯å†…è” (inlined) çš„ã€‚</p>
<p>Only functions marked <code>const</code> can be called at compile time to generate <code>const</code> values. <code>const</code> functions can however be called at runtime.</p>
<h2><a class="header" href="#static" id="static"><code>static</code></a></h2>
<p>Static variables will live during the whole execution of the program, and therefore will not move:</p>
<pre><pre class="playground"><code class="language-rust editable">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location.  This is useful for unsafe and  embedded code, and the variable lives through the entirety of the program execution. When a globally-scoped value does not have a reason to need object identity, <code>const</code> is generally preferred.</p>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>. Interior mutability is possible through a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or similar. It is also possible to have mutable statics, but they require manual synchronisation so any access to them requires <code>unsafe</code> code. We will look at <a href="basic-syntax/../unsafe/mutable-static-variables.html">mutable statics</a> in the chapter on Unsafe Rust.</p>
<details>
<ul>
<li>å€¼å¾—ä¸€æçš„æ˜¯ï¼Œ<code>const</code> åœ¨è¯­ä¹‰ä¸Šä¸C++çš„ <code>constexpr</code> ç±»ä¼¼ã€‚</li>
<li>å¦ä¸€æ–¹é¢ï¼Œ<code>static</code> è¿œè¿œæ›´ç±»ä¼¼äºC++ä¸­çš„ <code>const</code> æˆ–å¯æ”¹å˜çš„å…¨å±€å˜é‡ã€‚</li>
<li><code>static</code> provides object identity: an address in memory and state as required by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
<li>è™½ç„¶éœ€è¦ä½¿ç”¨åœ¨è¿è¡Œä¸­æ±‚å€¼çš„å¸¸é‡çš„æƒ…å†µå¹¶ä¸æ˜¯å¾ˆå¸¸è§ï¼Œä½†æ˜¯å®ƒæ˜¯æœ‰å¸®åŠ©çš„ï¼Œè€Œä¸”æ¯”ä½¿ç”¨é™æ€å˜é‡æ›´å®‰å…¨ã€‚</li>
<li><code>thread_local</code> data can be created with the macro <code>std::thread_local</code>.</li>
</ul>
<h3><a class="header" href="#properties-table" id="properties-table">Properties table:</a></h3>
<table><thead><tr><th>Property</th><th>Static</th><th>Constant</th></tr></thead><tbody>
<tr><td>Has an address in memory</td><td>Yes</td><td>No (inlined)</td></tr>
<tr><td>Lives for the entire duration of the program</td><td>Yes</td><td>No</td></tr>
<tr><td>Can be mutable</td><td>Yes (unsafe)</td><td>No</td></tr>
<tr><td>Evaluated at compile time</td><td>Yes (initialised at compile time)</td><td>Yes</td></tr>
<tr><td>Inlined wherever it is used</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</details><h1><a class="header" href="#ä½œç”¨åŸŸå’Œéšè—-shadowing" id="ä½œç”¨åŸŸå’Œéšè—-shadowing">ä½œç”¨åŸŸå’Œéšè— (Shadowing)</a></h1>
<p>ä½ å¯ä»¥éšè—å˜é‡ï¼Œä½äºå¤–éƒ¨ä½œç”¨åŸŸçš„å˜é‡å’Œ ç›¸åŒä½œç”¨åŸŸçš„å˜é‡éƒ½å¯ä»¥ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);

    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>å®šä¹‰: éšè—å’Œå˜æ›´ (mutation) ä¸åŒï¼Œå› ä¸ºåœ¨éšè—ä¹‹åï¼Œä¸¤ä¸ªå˜é‡éƒ½ä¼šåŒæ—¶å­˜åœ¨äºå†…å­˜çš„ä¸åŒä½ç½®ä¸­ã€‚åœ¨åŒä¸€ä¸ªåå­—ä¸‹çš„ä¸¤ä¸ªå˜é‡éƒ½æ˜¯å¯ä»¥è¢«ä½¿ç”¨çš„ï¼Œä½†æ˜¯ä½ åœ¨ä»£ç çš„å“ªé‡Œä½¿ç”¨ä¼šæœ€ç»ˆå†³å®šä½ ä½¿ç”¨å“ªä¸€ä¸ªå˜é‡ã€‚</li>
<li>ä¸€ä¸ªéšè—å˜é‡å¯ä»¥å…·æœ‰ä¸åŒçš„ç±»å‹ã€‚</li>
<li>éšè—èµ·åˆçœ‹èµ·æ¥ä¼šæœ‰äº›æ™¦æ¶©ï¼Œä½†æ˜¯å®ƒå¾ˆä¾¿äºå­˜ <code>.unwrap()</code> ä¹‹åçš„å¾—åˆ°çš„å€¼ã€‚</li>
<li>ä»¥ä¸‹ä»£ç è¯´æ˜äº†ä¸ºä»€ä¹ˆåœ¨ä½œç”¨åŸŸå†…éšè—ä¸€ä¸ªä¸å¯å˜çš„å˜é‡æ—¶ï¼Œå³ä½¿æ˜¯åœ¨å˜é‡ç±»å‹æ²¡æœ‰æ”¹å˜çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¹Ÿä¸èƒ½ç®€å•åœ°é‡å¤åˆ©ç”¨ä¹‹å‰çš„å†…å­˜ä½ç½®ã€‚</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 1;
    let b = &amp;a;
    let a = a + 1;
    println!(&quot;{a} {b}&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#æšä¸¾" id="æšä¸¾">æšä¸¾</a></h1>
<p><code>enum</code> å…³é”®å­—å…è®¸åˆ›å»ºå…·æœ‰å‡ ä¸ª ä¸åŒå˜ä½“çš„ç±»å‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn generate_random_number() -&gt; i32 {
    // Implementation based on https://xkcd.com/221/
    4  // Chosen by fair dice roll. Guaranteed to be random.
}

#[derive(Debug)]
enum CoinFlip {
    Heads,
    Tails,
}

fn flip_coin() -&gt; CoinFlip {
    let random_number = generate_random_number();
    if random_number % 2 == 0 {
        return CoinFlip::Heads;
    } else {
        return CoinFlip::Tails;
    }
}

fn main() {
    println!(&quot;You got: {:?}&quot;, flip_coin());
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>æšä¸¾å…è®¸ä½ ä»ä¸€ç§ç±»å‹ä¸‹æ”¶é›†ä¸€ç»„å€¼</li>
<li>This page offers an enum type <code>CoinFlip</code> with two variants <code>Heads</code> and <code>Tails</code>. You might note the namespace when using variants.</li>
<li>è¿™å¯èƒ½æ˜¯æ¯”è¾ƒç»“æ„ä½“å’Œæšä¸¾çš„å¥½æ—¶æœºï¼š
<ul>
<li>åœ¨è¿™ä¸¤è€…ä¸­ï¼Œä½ å¯ä»¥è·å¾—ä¸€ä¸ªä¸å«å­—æ®µçš„ç®€å•ç‰ˆæœ¬ï¼ˆå•ä½ç»“æ„ä½“ï¼‰ï¼Œæˆ–ä¸€ä¸ªåŒ…å«ä¸åŒç±»å‹å­—æ®µçš„ç‰ˆæœ¬ï¼ˆå˜ä½“è½½è·ï¼‰ã€‚</li>
<li>åœ¨è¿™ä¸¤è€…ä¸­ï¼Œå…³è”çš„å‡½æ•°éƒ½åœ¨ <code>impl</code> å—ä¸­å®šä¹‰ã€‚</li>
<li>ä½ ç”šè‡³å¯ä»¥ä½¿ç”¨å•ç‹¬çš„ç»“æ„ä½“å®ç°æšä¸¾çš„ä¸åŒå˜ä½“ï¼Œä½†è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœå®ƒä»¬éƒ½å·²åœ¨æšä¸¾ä¸­å®šä¹‰ï¼Œç±»å‹ä¸ä¹‹å‰ä¹Ÿä¸ä¸€æ ·ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#å˜ä½“è½½è·" id="å˜ä½“è½½è·">å˜ä½“è½½è·</a></h1>
<p>ä½ å¯ä»¥å®šä¹‰æ›´ä¸°å¯Œçš„æšä¸¾ï¼Œå…¶ä¸­å˜ä½“ä¼šæºå¸¦æ•°æ®ã€‚ç„¶åï¼Œä½ å¯ä»¥ä½¿ç”¨ <code>match</code> è¯­å¥ä»æ¯ä¸ªå˜ä½“ä¸­æå–æ•°æ®ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">enum WebEvent {
    PageLoad,                 // Variant without payload
    KeyPress(char),           // Tuple struct variant
    Click { x: i64, y: i64 }, // Full struct variant
}

#[rustfmt::skip]
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad       =&gt; println!(&quot;page loaded&quot;),
        WebEvent::KeyPress(c)    =&gt; println!(&quot;pressed '{c}'&quot;),
        WebEvent::Click { x, y } =&gt; println!(&quot;clicked at x={x}, y={y}&quot;),
    }
}

fn main() {
    let load = WebEvent::PageLoad;
    let press = WebEvent::KeyPress('x');
    let click = WebEvent::Click { x: 20, y: 80 };

    inspect(load);
    inspect(press);
    inspect(click);
}
</code></pre></pre>
<details>
<ul>
<li>æšä¸¾å˜ä½“ä¸­çš„å€¼åªæœ‰åœ¨è¢«æ¨¡å¼åŒ¹é…åï¼Œæ‰å¯è®¿é—®ã€‚æ¨¡å¼å°†å¼•ç”¨ç»‘å®šåˆ° <code>=&gt;</code> ä¹‹åçš„â€œmatch åˆ†æ”¯â€ä¸­çš„å­—æ®µã€‚
<ul>
<li>è¡¨è¾¾å¼ä¼šä»ä¸Šåˆ°ä¸‹ä¸æ¨¡å¼åŒ¹é…ã€‚æ²¡æœ‰åƒ C æˆ– C++ ä¸­é‚£æ ·çš„è·³è½¬ã€‚</li>
<li>åŒ¹é…è¡¨è¾¾å¼æ‹¥æœ‰ä¸€ä¸ªå€¼ã€‚å€¼æ˜¯ match åˆ†æ”¯ä¸­è¢«æ‰§è¡Œçš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚</li>
<li>ä»é¡¶éƒ¨å¼€å§‹ï¼ŒæŸ¥æ‰¾ä¸è¯¥å€¼åŒ¹é…çš„æ¨¡å¼ï¼Œç„¶åæ²¿ç®­å¤´è¿è¡Œä»£ç ã€‚ä¸€æ—¦æ‰¾åˆ°åŒ¹é…ï¼Œæˆ‘ä»¬ä¾¿ä¼šåœæ­¢ã€‚</li>
</ul>
</li>
<li>å±•ç¤ºæœç´¢ä¸è¯¦å°½æ—¶ä¼šå‘ç”Ÿçš„æƒ…å†µã€‚è¯·æ³¨æ„ Rust ç¼–è¯‘å™¨çš„ä¼˜åŠ¿ï¼Œå³ç¡®è®¤æ‰€æœ‰æƒ…å†µä½•æ—¶éƒ½å¾—åˆ°äº†å¤„ç†ã€‚</li>
<li><code>match</code> ä¼šæ£€æŸ¥ <code>enum</code> ä¸­çš„éšè—çš„åˆ¤åˆ«å­—æ®µã€‚</li>
<li>å¯ä»¥é€šè¿‡è°ƒç”¨ <code>std::mem::discriminant()</code> æ¥æ£€ç´¢åˆ¤åˆ«
<ul>
<li>è¿™å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚å¦‚æœä¸ºç»“æ„ä½“å®ç° <code>PartialEq</code>ï¼Œæ¯”è¾ƒå­—æ®µå€¼ä¸ä¼šå½±å“ç­‰å¼ã€‚</li>
</ul>
</li>
<li><code>WebEvent::Click { ... }</code> ä¸å«é¡¶å±‚ <code>struct Click { ... }</code> çš„ <code>WebEvent::Click(Click)</code> ä¸å®Œå…¨ç›¸åŒã€‚ä¾‹å¦‚ï¼Œå†…åµŒç‰ˆæœ¬æ— æ³•å®ç° traitã€‚</li>
</ul>
</details><h1><a class="header" href="#æšä¸¾å¤§å°" id="æšä¸¾å¤§å°">æšä¸¾å¤§å°</a></h1>
<p>Rust æšä¸¾è¢«ç´§å¯†åœ°æ‰“åŒ…ï¼Œè€ƒè™‘åˆ°äº†å¯¹é½çš„å½±å“ï¼Œå› æ­¤å­˜åœ¨ä¸€äº›é™åˆ¶ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::any::type_name;
use std::mem::{align_of, size_of};

fn dbg_size&lt;T&gt;() {
    println!(&quot;{}: size {} bytes, align: {} bytes&quot;,
        type_name::&lt;T&gt;(), size_of::&lt;T&gt;(), align_of::&lt;T&gt;());
}

enum Foo {
    A,
    B,
}

fn main() {
    dbg_size::&lt;Foo&gt;();
}
</code></pre></pre>
<ul>
<li>è¯·å‚é˜… <a href="https://doc.rust-lang.org/reference/type-layout.html">Rust å¼•ç”¨</a>ã€‚</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Internally Rust is using a field (discriminant) to keep track of the enum variant.</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[repr(u32)]
enum Bar {
    A,  // 0
    B = 10000,
    C,  // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}
</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2 bytes.</p>
</li>
<li>
<p>Try out other types such as</p>
<ul>
<li><code>dbg_size!(bool)</code>: size 1 bytes, align: 1 bytes,</li>
<li><code>dbg_size!(Option&lt;bool&gt;)</code>: size 1 bytes, align: 1 bytes (niche optimization, see below),</li>
<li><code>dbg_size!(&amp;i32)</code>: size 8 bytes, align: 8 bytes (on a 64-bit machine),</li>
<li><code>dbg_size!(Option&lt;&amp;i32&gt;)</code>: size 8 bytes, align: 8 bytes (null pointer optimization, see below).</li>
</ul>
</li>
<li>
<p>Niche optimization: Rust will merge unused bit patterns for the enum discriminant.</p>
</li>
<li>
<p>Null pointer optimization: For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look like in practice. Itâ€™s important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    unsafe {
        println!(&quot;bool:&quot;);
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!(&quot;Option&lt;bool&gt;:&quot;);
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!(&quot;Option&lt;Option&lt;bool&gt;&gt;:&quot;);
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!(&quot;Option&lt;&amp;i32&gt;:&quot;);
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}
</code></pre></pre>
<p>More complex example if you want to discuss what happens when we chain more than 256 <code>Option</code>s together.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#![recursion_limit = &quot;1000&quot;]

use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

// Macro to wrap a value in 2^n Some() where n is the number of &quot;@&quot; signs.
// Increasing the recursion limit is required to evaluate this macro.
macro_rules! many_options {
    ($value:expr) =&gt; { Some($value) };
    ($value:expr, @) =&gt; {
        Some(Some($value))
    };
    ($value:expr, @ $($more:tt)+) =&gt; {
        many_options!(many_options!($value, $($more)+), $($more)+)
    };
}

fn main() {
    // TOTALLY UNSAFE. Rust provides no guarantees about the bitwise
    // representation of types.
    unsafe {
        assert_eq!(many_options!(false), Some(false));
        assert_eq!(many_options!(false, @), Some(Some(false)));
        assert_eq!(many_options!(false, @@), Some(Some(Some(Some(false)))));

        println!(&quot;Bitwise representation of a chain of 128 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@), u8);
        dbg_bits!(many_options!(true, @@@@@@@), u8);

        println!(&quot;Bitwise representation of a chain of 256 Option's.&quot;);
        dbg_bits!(many_options!(false, @@@@@@@@), u16);
        dbg_bits!(many_options!(true, @@@@@@@@), u16);

        println!(&quot;Bitwise representation of a chain of 257 Option's.&quot;);
        dbg_bits!(many_options!(Some(false), @@@@@@@@), u16);
        dbg_bits!(many_options!(Some(true), @@@@@@@@), u16);
        dbg_bits!(many_options!(None::&lt;bool&gt;, @@@@@@@@), u16);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#novel-control-flow" id="novel-control-flow">Novel Control Flow</a></h1>
<p>Rust has a few control flow constructs which differ from other languages. They are used for pattern matching:</p>
<ul>
<li><code>if let</code> è¡¨è¾¾å¼</li>
<li><code>while let</code> expressions</li>
<li><code>match</code> è¡¨è¾¾å¼</li>
</ul>
<h1><a class="header" href="#if-let-è¡¨è¾¾å¼" id="if-let-è¡¨è¾¾å¼"><code>if let</code> è¡¨è¾¾å¼</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> è¡¨è¾¾å¼</a> èƒ½è®©ä½ æ ¹æ®æŸä¸ªå€¼æ˜¯å¦ä¸æ¨¡å¼ç›¸åŒ¹é…æ¥æ‰§è¡Œä¸åŒçš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let arg = std::env::args().next();
    if let Some(value) = arg {
        println!(&quot;Program name: {value}&quot;);
    } else {
        println!(&quot;Missing name?&quot;);
    }
}
</code></pre></pre>
<p>å¦‚éœ€è¯¦ç»†äº†è§£ Rust ä¸­ çš„æ¨¡å¼ï¼Œè¯·å‚é˜…<a href="control-flow/../pattern-matching.html">æ¨¡å¼åŒ¹é…</a>ã€‚</p>
<details>
<ul>
<li>
<p>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it more concise than <code>match</code>.</p>
</li>
<li>
<p>ä½¿ç”¨ <code>Option</code> æ—¶ï¼Œå¸¸è§çš„åšæ³•æ˜¯å¤„ç† <code>Some</code> å€¼ã€‚</p>
</li>
<li>
<p>ä¸ <code>match</code> ä¸åŒçš„æ˜¯ï¼Œ<code>if let</code> ä¸æ”¯æŒæ¨¡å¼åŒ¹é…çš„ guard å­å¥ã€‚</p>
</li>
<li>
<p>Since 1.65, a similar <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html">let-else</a> construct allows to do a destructuring assignment, or if it fails, execute a block which is required to abort normal control flow (with <code>panic</code>/<code>return</code>/<code>break</code>/<code>continue</code>):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, second_word_to_upper(&quot;foo bar&quot;));
}
 
fn second_word_to_upper(s: &amp;str) -&gt; Option&lt;String&gt; {
    let mut it = s.split(' ');
    let (Some(_), Some(item)) = (it.next(), it.next()) else {
        return None;
    };
    Some(item.to_uppercase())
}

</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#while-let-å¾ªç¯" id="while-let-å¾ªç¯"><code>while let</code> å¾ªç¯</a></h1>
<p>ä¸ <code>if let</code> ä¸€æ ·ï¼Œ<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>with let</code></a> å˜ä½“ä¼šé’ˆå¯¹ä¸€ä¸ªæ¨¡å¼é‡å¤æµ‹è¯•ä¸€ä¸ªå€¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v = vec![10, 20, 30];
    let mut iter = v.into_iter();

    while let Some(x) = iter.next() {
        println!(&quot;x: {x}&quot;);
    }
}
</code></pre></pre>
<p>Here the iterator returned by <code>v.into_iter()</code> will return a <code>Option&lt;i32&gt;</code> on every call to <code>next()</code>. It returns <code>Some(x)</code> until it is done, after which it will return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<p>å¦‚éœ€è¯¦ç»†äº†è§£ Rust ä¸­ çš„æ¨¡å¼ï¼Œè¯·å‚é˜…<a href="control-flow/../pattern-matching.html">æ¨¡å¼åŒ¹é…</a>ã€‚</p>
<details>
<ul>
<li>æŒ‡å‡ºåªè¦å€¼ä¸æ¨¡å¼åŒ¹é…ï¼Œ<code>while let</code> å¾ªç¯å°±ä¼šä¸€ç›´è¿›è¡Œä¸‹å»ã€‚</li>
<li>ä½ å¯ä»¥ä½¿ç”¨ if è¯­å¥å°† <code>while let</code> å¾ªç¯é‡å†™ä¸ºæ— é™å¾ªç¯ï¼Œå½“ <code>iter.next()</code> æ²¡æœ‰å€¼å¯ä»¥è§£å°æ—¶ä¸­æ–­ã€‚<code>while let</code> ä¸ºä¸Šè¿°æƒ…å†µæä¾›äº†è¯­æ³•ç³–ã€‚</li>
</ul>
</details><h1><a class="header" href="#match-è¡¨è¾¾å¼" id="match-è¡¨è¾¾å¼"><code>match</code> è¡¨è¾¾å¼</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/match-expr.html"><code>match</code> å…³é”®å­—</a> ç”¨äºå°†ä¸€ä¸ªå€¼ä¸ä¸€ä¸ªæˆ–å¤šä¸ªæ¨¡å¼è¿›è¡ŒåŒ¹é…ã€‚ä»è¿™ä¸ªæ„ä¹‰ä¸Šè®²ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼ ç±»ä¼¼äºä¸€ç³»åˆ—çš„ <code>if let</code> è¡¨è¾¾å¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    match std::env::args().next().as_deref() {
        Some(&quot;cat&quot;) =&gt; println!(&quot;Will do cat things&quot;),
        Some(&quot;ls&quot;)  =&gt; println!(&quot;Will ls some files&quot;),
        Some(&quot;mv&quot;)  =&gt; println!(&quot;Let's move some files&quot;),
        Some(&quot;rm&quot;)  =&gt; println!(&quot;Uh, dangerous!&quot;),
        None        =&gt; println!(&quot;Hmm, no program name?&quot;),
        _           =&gt; println!(&quot;Unknown program name!&quot;),
    }
}
</code></pre></pre>
<p>ä¸ <code>if let</code> ç±»ä¼¼ï¼Œæ¯ä¸ªåŒ¹é…åˆ†æ”¯å¿…é¡»æœ‰ç›¸åŒçš„ç±»å‹ã€‚è¯¥ç±»å‹æ˜¯å—çš„æœ€åä¸€ä¸ª è¡¨è¾¾å¼ï¼ˆå¦‚æœ‰ï¼‰ã€‚åœ¨ä¸Šä¾‹ä¸­ï¼Œç±»å‹æ˜¯ <code>()</code>ã€‚</p>
<p>å¦‚éœ€è¯¦ç»†äº†è§£ Rust ä¸­ çš„æ¨¡å¼ï¼Œè¯·å‚é˜…<a href="control-flow/../pattern-matching.html">æ¨¡å¼åŒ¹é…</a>ã€‚</p>
<details>
<ul>
<li>å°† match è¡¨è¾¾å¼ä¿å­˜åˆ°ä¸€ä¸ªå˜é‡ä¸­å¹¶è¾“å‡ºç»“æœã€‚</li>
<li>ç§»é™¤ <code>.as_deref()</code> å¹¶è¯´æ˜é”™è¯¯ã€‚
<ul>
<li><code>std::env::args().next()</code> ä¼šè¿”å›  <code>Option&lt;String&gt;</code>ï¼Œä½†æ— æ³•ä¸ <code>String</code> è¿›è¡ŒåŒ¹é…ã€‚</li>
<li><code>as_deref()</code> ä¼šå°† <code>Option&lt;T&gt;</code> è½¬æ¢ä¸º <code>Option&lt;&amp;T::Target&gt;</code>ã€‚åœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ï¼Œè¿™ä¼šå°† <code>Option&lt;String&gt;</code> è½¬æ¢ä¸º <code>Option&lt;&amp;str&gt;</code>ã€‚</li>
<li>ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥åŒ¹é… <code>Option</code> ä¸­çš„ <code>&amp;str</code>ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#æ¨¡å¼åŒ¹é…" id="æ¨¡å¼åŒ¹é…">æ¨¡å¼åŒ¹é…</a></h1>
<p>ä½¿ç”¨å…³é”®è¯ <code>match</code> å¯¹ä¸€ä¸ªå€¼è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚è¿›è¡ŒåŒ¹é…æ—¶ï¼Œä¼šä»ä¸Šè‡³ä¸‹ä¾æ¬¡è¿›è¡Œæ¯”è¾ƒï¼Œå¹¶é€‰å®šç¬¬ä¸€ä¸ªåŒ¹é…æˆåŠŸçš„ç»“æœã€‚</p>
<p>æ¨¡å¼ (pattern) å¯ä»¥æ˜¯ç®€å•çš„å€¼ï¼Œå…¶ç”¨æ³•ç±»ä¼¼äº C ä¸ C++ ä¸­çš„ <code>switch</code> ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let input = 'x';

    match input {
        'q'                   =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd' =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'             =&gt; println!(&quot;Number input&quot;),
        _                     =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>æ¨¡å¼ <code>_</code> æ˜¯å¤–å¡ (wildcard) æ¨¡å¼ã€‚å®ƒå¯ä»¥åŒ¹é…ä»»ä½•å€¼ã€‚</p>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>You might point out how some specific characters are being used when in a pattern
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li><code>_</code> is a wild card</li>
</ul>
</li>
<li>It can be useful to show how binding works, by for instance replacing a wildcard character with a variable, or removing the quotes around <code>q</code>.</li>
<li>You can demonstrate matching on a reference.</li>
<li>This might be a good time to bring up the concept of irrefutable patterns, as the term can show up in error messages.</li>
</ul>
</details><h1><a class="header" href="#è§£æ„æšä¸¾" id="è§£æ„æšä¸¾">è§£æ„æšä¸¾</a></h1>
<p>Patterns can also be used to bind variables to parts of your values. This is how you inspect the structure of your types. Let us start with a simple <code>enum</code> type:</p>
<pre><pre class="playground"><code class="language-rust editable">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>Here we have used the arms to <em>destructure</em> the <code>Result</code> value. In the first arm, <code>half</code> is bound to the value inside the <code>Ok</code> variant. In the second arm, <code>msg</code> is bound to the error message.</p>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>The <code>if</code>/<code>else</code> expression is returning an enum that is later unpacked with a <code>match</code>.</li>
<li>You can try adding a third variant to the enum definition and displaying the errors when running the code. Point out the places where your code is now inexhaustive and how the compiler tries to give you hints.</li>
</ul>
</details><h1><a class="header" href="#è§£æ„ç»“æ„ä½“" id="è§£æ„ç»“æ„ä½“">è§£æ„ç»“æ„ä½“</a></h1>
<p>You can also destructure <code>structs</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, x = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>Change the literal values in <code>foo</code> to match with the other patterns.</li>
<li>Add a new field to <code>Foo</code> and make changes to the pattern as needed.</li>
<li>The distinction between a capture and a constant expression can be hard to spot. Try changing the <code>2</code> in the second arm to a variable, and see that it subtly doesnâ€™t work. Change it to a <code>const</code> and see it working again.</li>
</ul>
</details><h1><a class="header" href="#è§£æ„æ•°ç»„" id="è§£æ„æ•°ç»„">è§£æ„æ•°ç»„</a></h1>
<p>ä½ å¯ä»¥é€šè¿‡å…ƒç´ åŒ¹é…æ¥è§£æ„æ•°ç»„ã€å…ƒç»„å’Œåˆ‡ç‰‡ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let triple = [0, -2, 3];
    println!(&quot;Tell me about {triple:?}&quot;);
    match triple {
        [0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        [1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _         =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>å¯¹æœªçŸ¥é•¿åº¦çš„åˆ‡ç‰‡è¿›è¡Œè§£æ„ä¹Ÿå¯ä»¥ä½¿ç”¨å›ºå®šé•¿åº¦çš„æ¨¡å¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    inspect(&amp;[0, -2, 3]);
    inspect(&amp;[0, -2, 3, 4]);
}

#[rustfmt::skip]
fn inspect(slice: &amp;[i32]) {
    println!(&quot;Tell me about {slice:?}&quot;);
    match slice {
        &amp;[0, y, z] =&gt; println!(&quot;First is 0, y = {y}, and z = {z}&quot;),
        &amp;[1, ..]   =&gt; println!(&quot;First is 1 and the rest were ignored&quot;),
        _          =&gt; println!(&quot;All elements were ignored&quot;),
    }
}
</code></pre></pre>
</li>
<li>
<p>ä½¿ç”¨ <code>_</code> åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å¼æ¥ä»£è¡¨ä¸€ä¸ªå…ƒç´ ã€‚</p>
</li>
<li>
<p>å‘æ•°ç»„ä¸­æ·»åŠ æ›´å¤šçš„å€¼ã€‚</p>
</li>
<li>
<p>æŒ‡å‡º <code>..</code> æ˜¯å¦‚ä½•æ‰©å±•ä»¥é€‚åº”ä¸åŒæ•°é‡çš„å…ƒç´ çš„ã€‚ </p>
</li>
<li>
<p>å±•ç¤ºä½¿ç”¨æ¨¡å¼ <code>[.., b]</code> å’Œ <code>[a@..,b]</code> æ¥åŒ¹é…åˆ‡ç‰‡çš„å°¾éƒ¨ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#åŒ¹é…å®ˆå«" id="åŒ¹é…å®ˆå«">åŒ¹é…å®ˆå«</a></h1>
<p>When matching, you can add a <em>guard</em> to a pattern. This is an arbitrary Boolean expression which will be executed if the pattern matches:</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let pair = (2, -2);
    println!(&quot;Tell me about {pair:?}&quot;);
    match pair {
        (x, y) if x == y     =&gt; println!(&quot;These are twins&quot;),
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _                    =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>Match guards as a separate syntax feature are important and necessary when we wish to concisely express more complex ideas than patterns alone would allow.</li>
<li>They are not the same as separate <code>if</code> expression inside of the match arm. An <code>if</code> expression inside of the branch block (after <code>=&gt;</code>) happens after the match arm is selected. Failing the <code>if</code> condition inside of that block wonâ€™t result in other arms of the original <code>match</code> expression being considered.</li>
<li>You can use the variables defined in the pattern in your if expression.</li>
<li>The condition defined in the guard applies to every expression in a pattern with an <code>|</code>.</li>
</ul>
</details><h1><a class="header" href="#day-1-afternoon-exercises" id="day-1-afternoon-exercises">Day 1: Afternoon Exercises</a></h1>
<p>We will look at two things:</p>
<ul>
<li>
<p>The Luhn algorithm,</p>
</li>
<li>
<p>An exercise on pattern matching.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-1/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#luhn-ç®—æ³•" id="luhn-ç®—æ³•">Luhn ç®—æ³•</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a> is used to validate credit card numbers. The algorithm takes a string as input and does the following to validate the credit card number:</p>
<ul>
<li>
<p>Ignore all spaces. Reject number with less than two digits.</p>
</li>
<li>
<p>Moving from <strong>right to left</strong>, double every second digit: for the number <code>1234</code>, we double <code>3</code> and <code>1</code>. For the number <code>98765</code>, we double <code>6</code> and <code>8</code>.</p>
</li>
<li>
<p>After doubling a digit, sum the digits if the result is greater than 9. So doubling <code>7</code> becomes <code>14</code> which becomes <code>1 + 4 = 5</code>.</p>
</li>
<li>
<p>Sum all the undoubled and doubled digits.</p>
</li>
<li>
<p>The credit card number is valid if the sum ends with <code>0</code>.</p>
</li>
</ul>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function.</p>
<p>Try to solve the problem the â€œsimpleâ€ way first, using <code>for</code> loops and integers. Then, revisit the solution and try to implement it with iterators.</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn luhn(cc_number: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
    assert!(!luhn(&quot;foo 0 0&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<h1><a class="header" href="#exercise-expression-evaluation" id="exercise-expression-evaluation">Exercise: Expression Evaluation</a></h1>
<p>Letâ€™s write a simple recursive evaluator for arithmetic expressions. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op {
        op: Operation,
        left: Box&lt;Expression&gt;,
        right: Box&lt;Expression&gt;,
    },

    /// A literal value
    Value(i64),
}

/// The result of evaluating an expression.
#[derive(Debug, PartialEq, Eq)]
enum Res {
    /// Evaluation was successful, with the given result.
    Ok(i64),
    /// Evaluation failed, with the given error message.
    Err(String),
}
// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.
use Res::{Err, Ok};

fn eval(e: Expression) -&gt; Res {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Box</code> type here is a smart pointer, and will be covered in detail later in the course. An expression can be â€œboxedâ€ with <code>Box::new</code> as seen in the tests. To evaluate a boxed expression, use the deref operator to â€œunboxâ€ it: <code>eval(*boxed_expr)</code>.</p>
<p>Some expressions cannot be evaluated and will return an error. The <code>Res</code> type represents either a successful value or an error with a message. This is very similar to the standard-library <code>Result</code> which we will see later.</p>
<p>Copy and paste the code into the Rust playground, and begin implementing <code>eval</code>. The final product should pass the tests. It may be helpful to use <code>todo!()</code> and get the tests to pass one-by-one.</p>
<p>If you finish early, try writing a test that results in an integer overflow. How could you handle this with <code>Res::Err</code> instead of a panic?</p>
<h1><a class="header" href="#æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©" id="æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©">æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©</a></h1>
<p>ç°åœ¨æˆ‘ä»¬å·²ç»äº†è§£äº†ç›¸å½“å¤šçš„Rustï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†å­¦ä¹ ï¼š</p>
<ul>
<li>
<p>å†…å­˜ç®¡ç†ï¼šæ ˆä¸å †ï¼Œæ‰‹åŠ¨å†…å­˜ç®¡ç†ï¼ŒåŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç†ï¼Œä»¥åŠåƒåœ¾å›æ”¶ã€‚</p>
</li>
<li>
<p>æ‰€æœ‰æƒï¼šç§»åŠ¨ï¼ˆmoveï¼‰çš„è¯­ä¹‰ï¼Œå¤åˆ¶ï¼ˆcopyï¼‰å’Œå…‹éš†ï¼ˆcloneï¼‰ï¼Œå€Ÿç”¨ï¼ˆborrowï¼‰ï¼Œä»¥åŠç”Ÿå‘½å‘¨æœŸã€‚</p>
</li>
<li>
<p>Structs and methods.</p>
</li>
<li>
<p>æ ‡å‡†åº“: <code>å­—ç¬¦ä¸²ï¼ˆStringï¼‰</code>, <code>é€‰é¡¹ï¼ˆOptionï¼‰</code> å’Œ <code>ç»“æœï¼ˆResultï¼‰</code>, <code>åŠ¨æ€æ•°ç»„ï¼ˆVecï¼‰</code>, <code>æ•£åˆ—è¡¨ï¼ˆHashMapï¼‰</code>, <code>å¼•ç”¨è®¡æ•°ï¼ˆRcï¼‰</code> å’Œ <code>å…±äº«å¼•ç”¨è®¡æ•°ï¼ˆArcï¼‰</code>ã€‚</p>
</li>
<li>
<p>æ¨¡å—: å¯è§æ€§, è·¯å¾„å’Œæ–‡ä»¶ç³»ç»Ÿçš„å±‚æ¬¡ç»“æ„ã€‚</p>
</li>
</ul>
<h1><a class="header" href="#å†…å­˜ç®¡ç†" id="å†…å­˜ç®¡ç†">å†…å­˜ç®¡ç†</a></h1>
<p>ä¼ ç»Ÿä¸Šï¼Œè¯­è¨€åˆ†ä¸ºä¸¤å¤§ç±»ï¼š</p>
<ul>
<li>é€šè¿‡æ‰‹åŠ¨å†…å­˜ç®¡ç†å®ç°å®Œå…¨æ§åˆ¶ï¼šCã€C++ã€Pascalâ€¦</li>
<li>è¿è¡Œæ—¶é€šè¿‡è‡ªåŠ¨å†…å­˜ç®¡ç†å®ç°å®Œå…¨å®‰å…¨ï¼šJavaã€Pythonã€Goã€Haskellâ€¦</li>
</ul>
<p>Rust æä¾›äº†ä¸€ä¸ªå…¨æ–°çš„ç»„åˆï¼š</p>
<blockquote>
<p>é€šè¿‡ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡Œæ­£ç¡®çš„å†…å­˜&gt;ç®¡ç†æ¥å®ç°å®Œå…¨æ§åˆ¶ä¸å®‰å…¨ã€‚</p>
</blockquote>
<p>å®ƒé€šè¿‡ä¸€ä¸ªæ˜ç¡®çš„æ‰€æœ‰æƒï¼ˆownershipï¼‰æ¦‚å¿µæ¥å®ç°æ­¤ç›®çš„ã€‚</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬å›é¡¾ä¸€ä¸‹å†…å­˜ç®¡ç†çš„å·¥ä½œåŸç†ã€‚</p>
<h1><a class="header" href="#æ ˆä¸å †" id="æ ˆä¸å †">æ ˆä¸å †</a></h1>
<ul>
<li>
<p>æ ˆï¼šå±€éƒ¨å˜é‡çš„è¿ç»­å†…å­˜åŒºåŸŸã€‚</p>
<ul>
<li>å€¼åœ¨ç¼–è¯‘æ—¶å…·æœ‰å·²çŸ¥çš„å›ºå®šå¤§å°ã€‚</li>
<li>é€Ÿåº¦æå¿«ï¼šåªéœ€ç§»åŠ¨ä¸€ä¸ªæ ˆæŒ‡é’ˆã€‚</li>
<li>æ˜“äºç®¡ç†ï¼šéµå¾ªå‡½æ•°è°ƒç”¨è§„åˆ™ã€‚</li>
<li>ä¼˜ç§€çš„å†…å­˜å±€éƒ¨æ€§ã€‚</li>
</ul>
</li>
<li>
<p>å †ï¼šå‡½æ•°è°ƒç”¨ä¹‹å¤–çš„å€¼çš„å­˜å‚¨ã€‚</p>
<ul>
<li>å€¼å…·æœ‰åŠ¨æ€å¤§å°ï¼Œå…·ä½“å¤§å°éœ€åœ¨è¿è¡Œæ—¶ç¡®å®šã€‚</li>
<li>æ¯”æ ˆç¨æ…¢ï¼šéœ€è¦å‘ç³»ç»Ÿç”³è¯·ç©ºé—´ã€‚</li>
<li>ä¸ä¿è¯å†…å­˜å±€éƒ¨æ€§ã€‚</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#stack-and-heap-example" id="stack-and-heap-example">Stack and Heap Example</a></h1>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="50" y="108" >len</text><text x="178" y="108" >5</text><text x="50" y="124" >capacity</text><text x="178" y="124" >5</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="508" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="308" y1="104" x2="508" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><path d="M 528,24 A 4,4 0,0,1 532,28" class="nofill"></path><line x1="532" y1="28" x2="532" y2="148" class="broken"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><path d="M 532,148 A 4,4 0,0,1 528,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>æŒ‡å‡º <code>String</code> åº•å±‚ç”± <code>Vec</code> å®ç°ï¼Œå› æ­¤å®ƒå…·æœ‰å®¹é‡å’Œé•¿åº¦ï¼Œå¦‚æœå€¼å¯å˜ï¼Œåˆ™å¯ä»¥é€šè¿‡åœ¨å †ä¸Šé‡æ–°åˆ†é…å­˜å‚¨ç©ºé—´è¿›è¡Œå¢é•¿ã€‚</p>
</li>
<li>
<p>å¦‚æœå­¦å‘˜æå‡ºç›¸å…³é—®é¢˜ï¼Œä½ å¯ä»¥æåŠæˆ‘ä»¬ä¸ä»…èƒ½ä½¿ç”¨[ç³»ç»Ÿåˆ†é…å™¨]åœ¨å †ä¸Šåˆ†é…åº•å±‚å†…å­˜ï¼Œè¿˜èƒ½ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a> å®ç°è‡ªå®šä¹‰åˆ†é…å™¨</p>
</li>
<li>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ <code>unsafe</code> ä»£ç æ£€æŸ¥å†…å­˜å¸ƒå±€ã€‚ä¸è¿‡ï¼Œä½ åº”è¯¥æŒ‡å‡ºï¼Œè¿™ç§åšæ³•ä¸å®‰å…¨ï¼</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::from(&quot;Hello&quot;);
    s1.push(' ');
    s1.push_str(&quot;world&quot;);
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (ptr, capacity, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!(&quot;ptr = {ptr:#x}, len = {len}, capacity = {capacity}&quot;);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#æ‰‹åŠ¨å†…å­˜ç®¡ç†" id="æ‰‹åŠ¨å†…å­˜ç®¡ç†">æ‰‹åŠ¨å†…å­˜ç®¡ç†</a></h1>
<p>ä½ è‡ªå·±å®ç°å †å†…å­˜åˆ†é…å’Œé‡Šæ”¾ã€‚</p>
<p>ç¨æœ‰ä¸æ…ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å´©æºƒã€bugã€å®‰å…¨æ¼æ´å’Œå†…å­˜æ³„æ¼ã€‚</p>
<h2><a class="header" href="#c-ç¤ºä¾‹" id="c-ç¤ºä¾‹">C++ ç¤ºä¾‹</a></h2>
<p>ä½ å¿…é¡»å¯¹ä½¿ç”¨ <code>malloc</code> åˆ†é…çš„æ¯ä¸ªæŒ‡é’ˆè°ƒç”¨ <code>free</code>ï¼š</p>
<pre><code class="language-c">void foo(size_t n) {
    int* int_array = malloc(n * sizeof(int));
    //
    // ... lots of code
    //
    free(int_array);
}
</code></pre>
<p>Memory is leaked if the function returns early between <code>malloc</code> and <code>free</code>: the pointer is lost and we cannot deallocate the memory. Worse, freeing the pointer twice, or accessing a freed pointer can lead to exploitable security vulnerabilities.</p>
<h1><a class="header" href="#åŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç†" id="åŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç†">åŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç†</a></h1>
<p>æ„é€ å‡½æ•°å’Œææ„å‡½æ•°è®©ä½ å¯ä»¥é’©å…¥å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<p>é€šè¿‡å°†æŒ‡é’ˆå°è£…åœ¨å¯¹è±¡ä¸­ï¼Œä½ å¯ä»¥åœ¨è¯¥å¯¹è±¡ è¢«é”€æ¯æ—¶é‡Šæ”¾å†…å­˜ã€‚ç¼–è¯‘å™¨å¯ä¿è¯è¿™ä¸€ç‚¹çš„å®ç°ï¼Œå³ä½¿å¼•å‘äº†å¼‚å¸¸ä¹Ÿä¸ä¾‹å¤–ã€‚</p>
<p>è¿™é€šå¸¸ç§°ä¸ºâ€œèµ„æºè·å–å³åˆå§‹åŒ– (resource acquisition is initialization, RAII)â€ï¼Œ å¹¶ä¸ºä½ æä¾›æ™ºèƒ½æŒ‡é’ˆã€‚</p>
<h2><a class="header" href="#c-ç¤ºä¾‹-1" id="c-ç¤ºä¾‹-1">C++ ç¤ºä¾‹</a></h2>
<pre><code class="language-c++">void say_hello(std::unique_ptr&lt;Person&gt; person) {
  std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; person-&gt;name &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li><code>std::unique_ptr</code> å¯¹è±¡åœ¨æ ˆä¸Šåˆ†é…å†…å­˜ï¼Œå¹¶æŒ‡å‘åœ¨å †ä¸Šåˆ†é…çš„å†…å­˜ã€‚</li>
<li>åœ¨ <code>say_hello</code> ç»“æŸæ—¶ï¼Œ<code>std::unique_ptr</code> ææ„å‡½æ•°å°†è¿è¡Œã€‚</li>
<li>ææ„å‡½æ•°é‡Šæ”¾å®ƒæ‰€æŒ‡å‘çš„ <code>Person</code> å¯¹è±¡ã€‚</li>
</ul>
<p>å°†æ‰€æœ‰æƒä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œä½¿ç”¨ç‰¹æ®Šçš„ move æ„é€ å‡½æ•°ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-c++">std::unique_ptr&lt;Person&gt; person = find_person(&quot;Carla&quot;);
say_hello(std::move(person));
</code></pre>
<h1><a class="header" href="#è‡ªåŠ¨å†…å­˜ç®¡ç†" id="è‡ªåŠ¨å†…å­˜ç®¡ç†">è‡ªåŠ¨å†…å­˜ç®¡ç†</a></h1>
<p>è‡ªåŠ¨å†…å­˜ç®¡ç†æ˜¯æ‰‹åŠ¨å’ŒåŸºäºä½œç”¨åŸŸçš„å†…å­˜ç®¡ç† çš„æ›¿ä»£æ–¹æ¡ˆï¼š</p>
<ul>
<li>ç¨‹åºå‘˜ä»ä¸æ˜¾å¼åˆ†é…æˆ–å–æ¶ˆåˆ†é…å†…å­˜ã€‚</li>
<li>åƒåœ¾å›æ”¶å™¨æ‰¾åˆ°æœªä½¿ç”¨çš„å†…å­˜ï¼Œå¹¶ä¸ºç¨‹åºå‘˜å°†å…¶å–æ¶ˆåˆ†é…ã€‚</li>
</ul>
<h2><a class="header" href="#java-ç¤ºä¾‹" id="java-ç¤ºä¾‹">Java ç¤ºä¾‹</a></h2>
<p><code>sayHello</code> è¿”å›åï¼Œ<code>person</code> å¯¹è±¡æœªè¢«å–æ¶ˆåˆ†é…ï¼š</p>
<pre><code class="language-java">void sayHello(Person person) {
  System.out.println(&quot;Hello &quot; + person.getName());
}
</code></pre>
<h1><a class="header" href="#rust-ä¸­çš„å†…å­˜ç®¡ç†" id="rust-ä¸­çš„å†…å­˜ç®¡ç†">Rust ä¸­çš„å†…å­˜ç®¡ç†</a></h1>
<p>Rust ä¸­çš„å†…å­˜ç®¡ç†æ˜¯ä¸€ç§æ··åˆæ¨¡å¼ï¼š</p>
<ul>
<li>åƒ Java ä¸€æ ·å®‰å…¨åˆæ­£ç¡®ï¼Œä½†æ²¡æœ‰åƒåœ¾å›æ”¶å™¨ã€‚</li>
<li>åƒ C++ ä¸€æ ·åŸºäºä½œç”¨åŸŸï¼Œä½†ç¼–è¯‘å™¨ä¼šå¼ºåˆ¶å®Œå…¨éµå¾ªè§„åˆ™ã€‚</li>
<li>Rust ç”¨æˆ·å¯ä»¥æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©åˆé€‚çš„æŠ½è±¡ï¼Œæœ‰äº›ç”šè‡³æ²¡æœ‰åƒ C é‚£æ ·çš„è¿è¡Œæ—¶å¼€é”€ã€‚</li>
</ul>
<p>Rust achieves this by modeling <em>ownership</em> explicitly.</p>
<details>
<ul>
<li>
<p>å¦‚æœæ­¤æ—¶è¢«é—®åŠå¦‚ä½•æ“ä½œï¼Œä½ å¯ä»¥æåŠåœ¨ Rust ä¸­ï¼Œè¿™é€šå¸¸ç”± RAII å°è£…å®¹å™¨ç±»å‹ï¼ˆä¾‹å¦‚ <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">Box</a>ã€<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec</a>ã€<a href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a> æˆ– <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a>ï¼‰å¤„ç†ã€‚è¿™äº›ç±»å‹é€šè¿‡å„ç§æ–¹å¼å°è£…äº†æ‰€æœ‰æƒå’Œå†…å­˜åˆ†é…ï¼Œå¹¶é˜²æ­¢äº† C ä¸­æ½œåœ¨é”™è¯¯çš„å‘ç”Ÿã€‚</p>
</li>
<li>
<p>ä½ å¯èƒ½ä¼šè¢«é—®åŠææ„å‡½æ•°ï¼Œæ­¤å¤„ <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop</a> trait æ˜¯ Rust ç­‰æ•ˆé¡¹ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#æ‰€æœ‰æƒ" id="æ‰€æœ‰æƒ">æ‰€æœ‰æƒ</a></h1>
<p>æ‰€æœ‰å˜é‡ç»‘å®šéƒ½æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„â€œä½œç”¨åŸŸâ€ï¼Œä½¿ç”¨ è¶…å‡ºå…¶ä½œç”¨åŸŸçš„å˜é‡æ˜¯é”™è¯¯çš„ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<ul>
<li>ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œå˜é‡ä¼šâ€œè¢«ä¸¢å¼ƒâ€ï¼Œæ•°æ®ä¼šè¢«é‡Šæ”¾ã€‚</li>
<li>ææ„å‡½æ•°å¯åœ¨æ­¤è¿è¡Œä»¥é‡Šæ”¾èµ„æºã€‚</li>
<li>æŒ‡å‡ºå˜é‡â€œæ‹¥æœ‰â€å€¼ã€‚</li>
</ul>
<h1><a class="header" href="#ç§»åŠ¨è¯­ä¹‰" id="ç§»åŠ¨è¯­ä¹‰">ç§»åŠ¨è¯­ä¹‰</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>å°† <code>s1</code> èµ‹å€¼ç»™ <code>s2</code>ï¼Œå³è½¬ç§»äº†æ‰€æœ‰æƒã€‚</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>å½“ <code>s2</code> ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå­—ç¬¦ä¸²æ•°æ®è¢«é‡Šæ”¾ã€‚</li>
<li>å˜é‡ç»‘å®šåœ¨ä»»ä¸€æ—¶åˆ»æœ‰ä¸”â€œåªæœ‰â€ä¸€ä¸ªå€¼ã€‚</li>
</ul>
<details>
<ul>
<li>
<p>æŒ‡å‡ºè¿™ä¸ C++ ä¸­çš„é»˜è®¤å€¼ç›¸åã€‚é™¤éä½ ä½¿ç”¨ <code>std::move</code>ï¼ˆå¹¶å·²å®šä¹‰ move æ„é€ å‡½æ•°ï¼ï¼‰ï¼Œå¦åˆ™ C++ ä¸­çš„é»˜è®¤å€¼æ˜¯æŒ‰å€¼å¤åˆ¶çš„ã€‚</p>
</li>
<li>
<p>It is only the ownership that moves. Whether any machine code is generated to manipulate the data itself is a matter of optimization, and such copies are aggressively optimized away.</p>
</li>
<li>
<p>Simple values (such as integers) can be marked <code>Copy</code> (see later slides).</p>
</li>
<li>
<p>åœ¨ Rust ä¸­ï¼Œå…‹éš†æ˜¯æ˜¾å¼çš„ï¼ˆé€šè¿‡ä½¿ç”¨ <code>clone</code>ï¼‰ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#rust-ä¸­ç§»åŠ¨çš„å­—ç¬¦ä¸²" id="rust-ä¸­ç§»åŠ¨çš„å­—ç¬¦ä¸²">Rust ä¸­ç§»åŠ¨çš„å­—ç¬¦ä¸²</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Rust&quot;);
    let s2: String = s1;
}
</code></pre></pre>
<ul>
<li><code>s1</code> ä¸­çš„å †æ•°æ®ä¼šè¢« <code>s2</code> é‡å¤ä½¿ç”¨ã€‚</li>
<li>å½“ <code>s1</code> ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿï¼ˆå®ƒå·²è¢«ç§»å‡ºï¼‰ã€‚</li>
</ul>
<p>ç§»åŠ¨åˆ° <code>s2</code> ä¸­ä¹‹å‰ï¼š</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div>
<p>ç§»åŠ¨åˆ° <code>s2</code> ä¸­ä¹‹åï¼š</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="512" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="512" height="304"></rect><text x="10" y="12" >æ ˆ</text><text x="258" y="12" >å †</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><text x="226" y="44" >:</text><text x="274" y="44" >:</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><text x="498" y="44" >:</text><text x="42" y="60" >s1</text><text x="226" y="76" >:</text><text x="274" y="76" >:</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >R</text><text x="362" y="92" >u</text><text x="402" y="92" >s</text><text x="442" y="92" >t</text><text x="50" y="108" >len</text><text x="178" y="108" >4</text><text x="50" y="124" >capacity</text><text x="178" y="124" >4</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >4</text><text x="50" y="236" >capacity</text><text x="178" y="236" >4</text><text x="210" y="60" >:</text><text x="258" y="60" >:</text><text x="482" y="60" >:</text><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >ï¼ˆæ— æ³•è®¿é—®ï¼‰</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="32" class="solid"></line></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="32" class="solid"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line></g><g><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><path d="M 496,24 A 4,4 0,0,1 500,28" class="nofill"></path><line x1="500" y1="28" x2="500" y2="32" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="468" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="308" y1="104" x2="468" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="228" y1="80" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><line x1="276" y1="80" x2="276" y2="148" class="broken"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="500" y1="64" x2="500" y2="148" class="broken"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><path d="M 500,148 A 4,4 0,0,1 496,152" class="nofill"></path></g></svg></div><h1><a class="header" href="#defensive-copies-in-modern-c" id="defensive-copies-in-modern-c">Defensive Copies in Modern C++</a></h1>
<p>ç°ä»£ C++ ä»¥ä¸åŒçš„æ–¹å¼è§£å†³æ­¤é—®é¢˜ï¼š</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // å¤åˆ¶ s1 ä¸­çš„æ•°æ®ã€‚
</code></pre>
<ul>
<li><code>s1</code> ä¸­çš„å †æ•°æ®è¢«å¤åˆ¶ï¼Œ<code>s2</code> è·å¾—è‡ªå·±çš„ç‹¬ç«‹å‰¯æœ¬ã€‚</li>
<li>å½“ <code>s1</code> å’Œ <code>s2</code> ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒä»¬ä¼šå„è‡ªé‡Šæ”¾è‡ªå·±çš„å†…å­˜ã€‚</li>
</ul>
<p>å¤åˆ¶-èµ‹å€¼ä¹‹å‰ï¼š</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>å¤åˆ¶-èµ‹å€¼ä¹‹åï¼š</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>C++ has made a slightly different choice than Rust. Because <code>=</code> copies data, the string data has to be cloned. Otherwise we would get a double-free when either string goes out of scope.</p>
</li>
<li>
<p>C++ also has <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>, which is used to indicate when a value may be moved from. If the example had been <code>s2 = std::move(s1)</code>, no heap allocation would take place. After the move, <code>s1</code> would be in a valid but unspecified state. Unlike Rust, the programmer is allowed to keep using <code>s1</code>.</p>
</li>
<li>
<p>Unlike Rust, <code>=</code> in C++ can run arbitrary code as determined by the type which is being copied or moved.</p>
</li>
</ul>
</details><h1><a class="header" href="#å‡½æ•°è°ƒç”¨ä¸­çš„ç§»åŠ¨" id="å‡½æ•°è°ƒç”¨ä¸­çš„ç§»åŠ¨">å‡½æ•°è°ƒç”¨ä¸­çš„ç§»åŠ¨</a></h1>
<p>ä½ å°†å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œè¯¥å€¼ä¼šè¢«èµ‹ç»™å‡½æ•° å‚æ•°ã€‚è¿™å°±è½¬ç§»äº†æ‰€æœ‰æƒï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>é¦–æ¬¡è°ƒç”¨ <code>say_hello</code> æ—¶ï¼Œ<code>main</code> ä¾¿æ”¾å¼ƒäº† <code>name</code> çš„æ‰€æœ‰æƒã€‚æ­¤åï¼Œ<code>main</code> ä¸­ä¸èƒ½å†ä½¿ç”¨ <code>name</code>ã€‚</li>
<li>åœ¨ <code>say_hello</code> å‡½æ•°ç»“æŸæ—¶ï¼Œç³»ç»Ÿä¼šé‡Šæ”¾ä¸º <code>name</code> åˆ†é…çš„å †å†…å­˜ã€‚</li>
<li>å¦‚æœ <code>main</code> å°† <code>name</code> ä½œä¸ºå¼•ç”¨ (<code>&amp;name</code>) ä¼ é€’è¿‡å»ï¼Œä¸” <code>say_hello</code> æ¥å—ä½œä¸ºå‚æ•°çš„å¼•ç”¨ï¼Œåˆ™å¯ä¿ç•™æ‰€æœ‰æƒã€‚</li>
<li>æ­¤å¤–ï¼Œ<code>main</code> ä¹Ÿå¯ä»¥åœ¨é¦–æ¬¡è°ƒç”¨æ—¶ä¼ é€’ <code>name</code> çš„å…‹éš† (<code>name.clone()</code>)ã€‚</li>
<li>ç›¸è¾ƒäº C++ï¼ŒRust é€šè¿‡å°†ç§»åŠ¨è¯­ä¹‰è®¾ä¸ºé»˜è®¤å€¼ï¼Œå¹¶å¼ºåˆ¶ç¨‹åºå‘˜è¿›è¡Œæ˜¾å¼å…‹éš†ï¼Œæ›´éš¾ä»¥æ— æ„ä¸­åˆ›å»ºå‰¯æœ¬ã€‚</li>
</ul>
</details><h1><a class="header" href="#å¤åˆ¶å’Œå…‹éš†" id="å¤åˆ¶å’Œå…‹éš†">å¤åˆ¶å’Œå…‹éš†</a></h1>
<p>è™½ç„¶ç§»åŠ¨è¯­ä¹‰æ˜¯é»˜è®¤çš„ï¼Œä½†é»˜è®¤æƒ…å†µä¸‹ä¼šå¤åˆ¶æŸäº›ç±»å‹ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;);
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>è¿™äº›ç±»å‹å®ç°äº† <code>Copy</code> traitã€‚</p>
<p>ä½ å¯ä»¥é€‰æ‹©è‡ªå·±çš„ç±»å‹æ¥ä½¿ç”¨å¤åˆ¶è¯­ä¹‰ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>èµ‹å€¼ä¹‹åï¼Œ<code>p1</code> å’Œ <code>p2</code> éƒ½æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ã€‚</li>
<li>æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ <code>p1.clone()</code> æ˜¾å¼å¤åˆ¶æ•°æ®ã€‚</li>
</ul>
<details>
<p>å¤åˆ¶å’Œå…‹éš†æ˜¯ä¸¤ç äº‹ï¼š</p>
<ul>
<li>å¤åˆ¶æ˜¯æŒ‡å†…å­˜åŒºåŸŸçš„æŒ‰ä½å¤åˆ¶ï¼Œä¸é€‚ç”¨äºä»»æ„å¯¹è±¡ã€‚</li>
<li>å¤åˆ¶ä¸å…è®¸è‡ªå®šä¹‰é€»è¾‘ï¼ˆä¸åŒäº C++ ä¸­çš„å¤åˆ¶æ„é€ å‡½æ•°ï¼‰ã€‚</li>
<li>å…‹éš†æ˜¯ä¸€ç§æ›´é€šç”¨çš„æ“ä½œï¼Œä¹Ÿå…è®¸é€šè¿‡å®ç° <code>Clone</code> trait æ¥è‡ªå®šä¹‰è¡Œä¸ºã€‚</li>
<li>å¤åˆ¶ä¸é€‚ç”¨äºå®ç° <code>Drop</code> trait çš„ç±»å‹ã€‚</li>
</ul>
<p>åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œè¯·å°è¯•ä»¥ä¸‹æ“ä½œï¼š</p>
<ul>
<li>åœ¨ <code>struct Point</code> ä¸­æ·»åŠ  <code>String</code> å­—æ®µã€‚ç”±äº <code>String</code> ä¸å±äº <code>Copy</code> ç±»å‹ï¼Œå› æ­¤æ— æ³•ç¼–è¯‘ã€‚</li>
<li>ä» <code>derive</code> å±æ€§ä¸­ç§»é™¤ <code>Copy</code>ã€‚ç°åœ¨ï¼Œç¼–è¯‘å™¨é”™è¯¯ä½äº <code>p1</code>çš„ <code>println!</code> ä¸­ã€‚</li>
<li>æŒ‡å‡ºå¦‚æœä½ æ”¹ä¸ºå…‹éš† <code>p1</code>ï¼Œåˆ™å¯æŒ‰é¢„æœŸè¿è¡Œã€‚</li>
</ul>
<p>å¦‚æœå­¦å‘˜é—®èµ· <code>derive</code>ï¼Œåªéœ€è¯´è¿™æ˜¯ä¸€ç§ åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆ Rust ä»£ç çš„æ–¹æ³•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç³»ç»Ÿä¼šç”Ÿæˆ <code>Copy</code> å’Œ <code>Clone</code> trait çš„é»˜è®¤å®ç°ã€‚</p>
</details><h1><a class="header" href="#å€Ÿç”¨" id="å€Ÿç”¨">å€Ÿç”¨</a></h1>
<p>è°ƒç”¨å‡½æ•°æ—¶ï¼Œä½ å¯ä»¥è®© å‡½æ•°â€œå€Ÿç”¨â€å€¼ï¼Œè€Œä¸æ˜¯è½¬ç§»æ‰€æœ‰æƒï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>add</code> å‡½æ•°â€œå€Ÿç”¨â€ä¸¤ä¸ªç‚¹å¹¶è¿”å›ä¸€ä¸ªæ–°ç‚¹ã€‚</li>
<li>è°ƒç”¨æ–¹ä¼šä¿ç•™è¾“å…¥çš„æ‰€æœ‰æƒã€‚</li>
</ul>
<details>
<p>å…³äºæ ˆè¿”å›çš„è¯´æ˜ï¼š</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/">Playground</a> or look at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the â€œDEBUGâ€ optimization level, the addresses should change, while they stay the same when changing to the â€œRELEASEâ€ setting:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>Rust ç¼–è¯‘å™¨èƒ½å¤Ÿæ‰§è¡Œè¿”å›å€¼ä¼˜åŒ– (RVO)ã€‚</p>
</li>
<li>
<p>In C++, copy elision has to be defined in the language specification because constructors can have side effects. In Rust, this is not an issue at all. If RVO did not happen, Rust will always perform a simple and efficient <code>memcpy</code> copy.</p>
</li>
</ul>
</details><h1><a class="header" href="#å…±äº«å’Œå”¯ä¸€çš„å€Ÿç”¨" id="å…±äº«å’Œå”¯ä¸€çš„å€Ÿç”¨">å…±äº«å’Œå”¯ä¸€çš„å€Ÿç”¨</a></h1>
<p>Rust é™åˆ¶äº†å€Ÿç”¨å€¼çš„æ–¹å¼ï¼š</p>
<ul>
<li>åœ¨ä»»ä½•ç»™å®šæ—¶é—´ï¼Œä½ éƒ½å¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ª <code>&amp;T</code> å€¼ï¼Œæˆ–è€…</li>
<li>ä½ å¯ä»¥æœ‰ä¸”åªæœ‰ä¸€ä¸ª <code>&amp;mut T</code> å€¼ã€‚</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>ä¸Šè¿°ä»£ç æ— æ³•ç¼–è¯‘ï¼Œå› ä¸º <code>a</code> åŒæ—¶ä½œä¸ºå¯å˜å€¼ï¼ˆé€šè¿‡ <code>c</code>ï¼‰å’Œä¸å¯å˜å€¼ï¼ˆé€šè¿‡ <code>b</code>ï¼‰è¢«å€Ÿç”¨ã€‚</li>
<li>å°†<code>b</code> çš„ <code>println!</code> è¯­å¥ç§»åˆ°å¼•å…¥ <code>c</code> çš„ä½œç”¨åŸŸä¹‹å‰ï¼Œè¿™æ®µä»£ç å°±å¯ä»¥ç¼–è¯‘ã€‚</li>
<li>è¿™æ ·æ›´æ”¹åï¼Œç¼–è¯‘å™¨ä¼šå‘ç° <code>b</code> åªåœ¨é€šè¿‡ <code>c</code> å¯¹ <code>a</code> è¿›è¡Œæ–°å¯å˜å€Ÿç”¨ä¹‹å‰ä½¿ç”¨è¿‡ã€‚è¿™æ˜¯å€Ÿç”¨æ£€æŸ¥å™¨çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œåä¸ºâ€œéè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸâ€ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç”Ÿå‘½å‘¨æœŸ" id="ç”Ÿå‘½å‘¨æœŸ">ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>å€Ÿç”¨çš„å€¼æ˜¯æœ‰â€œç”Ÿå‘½å‘¨æœŸâ€çš„ï¼š</p>
<ul>
<li>ç”Ÿå‘½å‘¨æœŸå¯ä»¥æ˜¯éšå¼çš„ï¼šadd(p1: &amp;Point, p2: &amp;Point) -&gt; Point`ã€‚</li>
<li>ç”Ÿå‘½å‘¨æœŸä¹Ÿå¯ä»¥æ˜¯æ˜¾å¼çš„ï¼š<code>&amp;'a Point</code>ã€<code>&amp;'document str</code>ã€‚</li>
<li>å°† <code>&amp;'a Point</code> è¯»å–ä¸ºâ€œå€Ÿç”¨çš„ <code>Pointï¼Œè‡³å°‘ åœ¨ </code>a` ç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆã€‚</li>
<li>ç”Ÿå‘½å‘¨æœŸå§‹ç»ˆç”±ç¼–è¯‘å™¨æ¨æ–­å‡ºæ¥ï¼šä½ ä¸èƒ½è‡ªè¡Œ åˆ†é…ç”Ÿå‘½å‘¨æœŸã€‚
<ul>
<li>ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šä¼šåˆ›å»ºçº¦æŸæ¡ä»¶ï¼›ç¼–è¯‘å™¨ä¼šéªŒè¯ æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚</li>
</ul>
</li>
<li>Lifetimes for function arguments and return values must be fully specified, but Rust allows lifetimes to be elided in most cases with <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple rules</a>.</li>
</ul>
<h1><a class="header" href="#å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ" id="å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ">å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>é™¤äº†å€Ÿç”¨å…¶å‚æ•°ä¹‹å¤–ï¼Œå‡½æ•°è¿˜å¯ä»¥è¿”å›å€Ÿç”¨çš„å€¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3: &amp;Point = left_most(&amp;p1, &amp;p2);
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>'a</code> æ˜¯ä¸€ä¸ªæ³›å‹å½¢å‚ï¼Œç”±ç¼–è¯‘å™¨æ¨æ–­å‡ºæ¥ã€‚</li>
<li>ä»¥ <code>'</code> å’Œ <code>'a</code> å¼€å¤´çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å…¸å‹çš„é»˜è®¤åç§°ã€‚</li>
<li>å°† <code>&amp;'a Point</code> è¯»å–ä¸ºâ€œå€Ÿç”¨çš„ <code>Pointï¼Œè‡³å°‘ åœ¨ </code>a` ç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆã€‚
<ul>
<li>å½“å‚æ•°åœ¨ä¸åŒçš„ä½œç”¨åŸŸæ—¶ï¼Œâ€œè‡³å°‘â€éƒ¨åˆ†è‡³å…³é‡è¦ã€‚</li>
</ul>
</li>
</ul>
<details>
<p>åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œè¯·å°è¯•ä»¥ä¸‹æ“ä½œï¼š</p>
<ul>
<li>
<p>å°† <code>p2</code> å’Œ <code>p3</code> çš„å£°æ˜ç§»è‡³æ–°ä½œç”¨åŸŸ (<code>{ ... }</code>)ï¼Œä»¥äº§ç”Ÿä»¥ä¸‹ä»£ç ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-rust ignore">#[derive(Debug)]
struct Point(i32, i32);

fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
    if p1.0 &lt; p2.0 { p1 } else { p2 }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p3: &amp;Point;
    {
        let p2: Point = Point(20, 20);
        p3 = left_most(&amp;p1, &amp;p2);
    }
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre>
<p>è¯·æ³¨æ„ï¼šç”±äº <code>p3</code> çš„ç”Ÿå‘½å‘¨æœŸæ¯” <code>p2</code> é•¿ï¼Œå› æ­¤æ— æ³•ç¼–è¯‘ã€‚</p>
</li>
<li>
<p>é‡ç½®å·¥ä½œåŒºï¼Œç„¶åå°†å‡½æ•°ç­¾åæ›´æ”¹ä¸º <code>fn left_most&lt;'a, 'b&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'b Point</code>ã€‚è¿™ä¸ä¼šè¢«ç¼–è¯‘ï¼Œå› ä¸º <code>'a</code> å’Œ <code>'b</code> ç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»ä¸æ˜ç¡®ã€‚</p>
</li>
<li>
<p>å¦ä¸€ç§è§£é‡Šæ–¹å¼ï¼š</p>
<ul>
<li>å¯¹ä¸¤ä¸ªå€¼çš„ä¸¤ä¸ªå¼•ç”¨è¢«ä¸€ä¸ªå‡½æ•°å€Ÿç”¨ï¼Œè¯¥å‡½æ•°è¿”å› å¦ä¸€ä¸ªå¼•ç”¨ã€‚</li>
<li>å®ƒå¿…é¡»æ˜¯æ¥è‡ªè¿™ä¸¤ä¸ªè¾“å…¥ä¸­çš„ä¸€ä¸ªï¼ˆæˆ–æ¥è‡ªä¸€ä¸ªå…¨å±€å˜é‡ï¼‰ã€‚</li>
<li>æ˜¯å“ªä¸€ä¸ªå‘¢ï¼Ÿç¼–è¯‘å™¨éœ€è¦çŸ¥é“è¿™ä¸€ç‚¹ï¼Œå› æ­¤åœ¨è°ƒç”¨ç‚¹ï¼Œè¿”å›çš„å¼•ç”¨ çš„ä½¿ç”¨æ—¶é—´ä¸ä¼šè¶…è¿‡å¼•ç”¨çš„æ¥æºä¸­çš„å˜é‡ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ" id="æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ">æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>å¦‚æœæ•°æ®ç±»å‹å­˜å‚¨äº†å€Ÿç”¨çš„æ•°æ®ï¼Œåˆ™å¿…é¡»å¯¹å…¶æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œ<code>Highlight</code> æ³¨é‡Šä¼šå¼ºåˆ¶åŒ…å« <code>&amp;str</code> çš„åº•å±‚æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸè‡³å°‘ä¸ä½¿ç”¨è¯¥æ•°æ®çš„ä»»ä½• <code>Highlight</code> å®ä¾‹ä¸€æ ·é•¿ã€‚</li>
<li>å¦‚æœ <code>text</code> åœ¨ <code>fox</code>ï¼ˆæˆ– <code>dog</code>ï¼‰çš„ç”Ÿå‘½å‘¨æœŸç»“æŸå‰è¢«æ¶ˆè€—ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨å°†æŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚</li>
<li>å€Ÿç”¨æ•°æ®çš„ç±»å‹ä¼šè¿«ä½¿ç”¨æˆ·ä¿ç•™åŸå§‹æ•°æ®ã€‚è¿™å¯¹äºåˆ›å»ºè½»é‡çº§è§†å›¾å¾ˆæœ‰ç”¨ï¼Œä½†é€šå¸¸ä¼šä½¿å®ƒä»¬æ›´éš¾ä½¿ç”¨ã€‚</li>
<li>å¦‚æœ‰å¯èƒ½ï¼Œè®©æ•°æ®ç»“æ„ç›´æ¥æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ã€‚</li>
<li>ä¸€äº›åŒ…å«å¤šä¸ªå¼•ç”¨çš„ç»“æ„å¯ä»¥æœ‰å¤šä¸ªç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚é™¤äº†ç»“æ„ä½“æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸä¹‹å¤–ï¼Œå¦‚æœéœ€è¦æè¿°å¼•ç”¨ä¹‹é—´çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»ï¼Œåˆ™å¯èƒ½éœ€è¦è¿™æ ·åšã€‚è¿™äº›éƒ½æ˜¯éå¸¸é«˜çº§çš„ç”¨ä¾‹ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç»“æ„ä½“" id="ç»“æ„ä½“">ç»“æ„ä½“</a></h1>
<p>ä¸ C å’Œ C++ ä¸€æ ·ï¼ŒRust æ”¯æŒè‡ªå®šä¹‰ç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    name: String,
    age: u8,
}

fn main() {
    let mut peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    peter.age = 28;
    println!(&quot;{} is {} years old&quot;, peter.name, peter.age);
    
    let jackie = Person {
        name: String::from(&quot;Jackie&quot;),
        ..peter
    };
    println!(&quot;{} is {} years old&quot;, jackie.name, jackie.age);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>Structs work like in C or C++.
<ul>
<li>Like in C++, and unlike in C, no typedef is needed to define a type.</li>
<li>Unlike in C++, there is no inheritance between structs.</li>
</ul>
</li>
<li>Methods are defined in an <code>impl</code> block, which we will see in following slides.</li>
<li>This may be a good time to let people know there are different types of structs. 
<ul>
<li>Zero-sized structs <code>e.g., struct Foo;</code> might be used when implementing a trait on some type but donâ€™t have any data that you want to store in the value itself. </li>
<li>The next slide will introduce Tuple structs, used when the field names are not important.</li>
</ul>
</li>
<li>The syntax <code>..peter</code> allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element.</li>
</ul>
</details><h1><a class="header" href="#å…ƒç»„ç»“æ„ä½“" id="å…ƒç»„ç»“æ„ä½“">å…ƒç»„ç»“æ„ä½“</a></h1>
<p>å¦‚æœå­—æ®µåç§°ä¸é‡è¦ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å…ƒç»„ç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>è¿™é€šå¸¸ç”¨äºå•å­—æ®µå°è£…å®¹å™¨ï¼ˆç§°ä¸º newtypeï¼‰ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}

</code></pre></pre>
<details>
<ul>
<li>å¦‚éœ€å¯¹åŸºå…ƒç±»å‹ä¸­çš„å€¼çš„é¢å¤–ä¿¡æ¯è¿›è¡Œç¼–ç ï¼Œä½¿ç”¨ newtype æ˜¯ä¸€ç§éå¸¸å¥½çš„æ–¹å¼ï¼Œä¾‹å¦‚ï¼š
<ul>
<li>æ•°å­—ä¼šä»¥æŸäº›å•ä½æ¥è¡¡é‡ï¼šä¸Šæ–¹ç¤ºä¾‹ä¸­ä¸º <code>Newtons</code>ã€‚</li>
<li>å€¼åœ¨åˆ›å»ºæ—¶å·²é€šè¿‡ä¸€äº›éªŒè¯ï¼Œå› æ­¤æ‚¨ä¸å†éœ€è¦åœ¨æ¯æ¬¡ä½¿ç”¨æ—¶éƒ½å†æ¬¡éªŒè¯å®ƒï¼š<code>PhoneNumber(String)</code> æˆ– <code>OddNumber(u32)</code>ã€‚</li>
</ul>
</li>
<li>å±•ç¤ºå¦‚ä½•é€šè¿‡è®¿é—® newtype ä¸­çš„å•ä¸ªå­—æ®µï¼Œå°† <code>f64</code> å€¼æ·»åŠ åˆ° <code>Newtons</code> ç±»å‹ã€‚
<ul>
<li>Rust é€šå¸¸ä¸å–œæ¬¢ä¸æ˜ç¡®çš„å†…å®¹ï¼Œä¾‹å¦‚è‡ªåŠ¨è§£å°æˆ–å°†å¸ƒå°”å€¼ç”¨ä½œæ•´æ•°ã€‚</li>
<li>è¿ç®—ç¬¦è¿‡è½½åœ¨ç¬¬ 3 å¤©ï¼ˆæ³›å‹ï¼‰è®¨è®ºã€‚</li>
</ul>
</li>
<li>æ­¤ç¤ºä¾‹å·§å¦™åœ°å¼•ç”¨äº†<a href="https://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F">ç«æ˜Ÿæ°”å€™æ¢æµ‹è€…å·</a> çš„å¤±è´¥äº‹æ•…ã€‚</li>
</ul>
</details><h1><a class="header" href="#å­—æ®µç®€å†™è¯­æ³•" id="å­—æ®µç®€å†™è¯­æ³•">å­—æ®µç®€å†™è¯­æ³•</a></h1>
<p>å¦‚æœæ‚¨å·²æœ‰åç§°æ­£ç¡®çš„å˜é‡ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ç®€å†™å½¢å¼åˆ›å»ºç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let peter = Person::new(String::from(&quot;Peter&quot;), 27);
    println!(&quot;{peter:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>new</code> function could be written using <code>Self</code> as a type, as it is interchangeable with the struct type name</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Person {
    fn new(name: String, age: u8) -&gt; Self {
        Self { name, age }
    }
}
</code></pre></pre>
</li>
<li>
<p>Implement the <code>Default</code> trait for the struct. Define some fields and use the default values for the other fields.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}
impl Default for Person {
    fn default() -&gt; Person {
        Person {
            name: &quot;Bot&quot;.to_string(),
            age: 0,
        }
    }
}
fn create_default() {
    let tmp = Person {
        ..Person::default()
    };
    let tmp = Person {
        name: &quot;Sam&quot;.to_string(),
        ..Person::default()
    };
}
</code></pre></pre>
</li>
<li>
<p>Methods are defined in the <code>impl</code> block.</p>
</li>
<li>
<p>Use struct update syntax to define a new structure using <code>peter</code>. Note that the variable <code>peter</code> will no longer be accessible afterwards.</p>
</li>
<li>
<p>Use <code>{:#?}</code> when printing structs to request the <code>Debug</code> representation.</p>
</li>
</ul>
</details><h1><a class="header" href="#æ–¹æ³•-1" id="æ–¹æ³•-1">æ–¹æ³•</a></h1>
<p>Rust allows you to associate functions with your new types. You do this with an <code>impl</code> block:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn say_hello(&amp;self) {
        println!(&quot;Hello, my name is {}&quot;, self.name);
    }
}

fn main() {
    let peter = Person {
        name: String::from(&quot;Peter&quot;),
        age: 27,
    };
    peter.say_hello();
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>It can be helpful to introduce methods by comparing them to functions.
<ul>
<li>Methods are called on an instance of a type (such as a struct or enum), the first parameter represents the instance as <code>self</code>.</li>
<li>Developers may choose to use methods to take advantage of method receiver syntax and to help keep them more organized. By using methods we can keep all the implementation code in one predictable place.</li>
</ul>
</li>
<li>Point out the use of the keyword <code>self</code>, a method receiver.
<ul>
<li>Show that it is an abbreviated term for <code>self: Self</code> and perhaps show how the struct name could also be used.</li>
<li>Explain that <code>Self</code> is a type alias for the type the <code>impl</code> block is in and can be used elsewhere in the block.</li>
<li>Note how <code>self</code> is used like other structs and dot notation can be used to refer to individual fields.</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by modifying the code and trying to run say_hello twice.</li>
</ul>
</li>
<li>We describe the distinction between method receivers next.</li>
</ul>
</details><h1><a class="header" href="#æ–¹æ³•æ¥æ”¶è€…" id="æ–¹æ³•æ¥æ”¶è€…">æ–¹æ³•æ¥æ”¶è€…</a></h1>
<p>The <code>&amp;self</code> above indicates that the method borrows the object immutably. There are other possible receivers for a method:</p>
<ul>
<li><code>&amp;self</code>: borrows the object from the caller using a shared and immutable reference. The object can be used again afterwards.</li>
<li><code>&amp;mut self</code>: borrows the object from the caller using a unique and mutable reference. The object can be used again afterwards.</li>
<li><code>self</code>: takes ownership of the object and moves it away from the caller. The method becomes the owner of the object. The object will be dropped (deallocated) when the method returns, unless its ownership is explicitly transmitted. Complete ownership does not automatically mean mutability.</li>
<li><code>mut self</code>: same as above, but the method can mutate the object. </li>
<li>No receiver: this becomes a static method on the struct. Typically used to create constructors which are called <code>new</code> by convention.</li>
</ul>
<p>Beyond variants on <code>self</code>, there are also <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a> allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</p>
<details>
<p>Consider emphasizing â€œshared and immutableâ€ and â€œunique and mutableâ€. These constraints always come together in Rust due to borrow checker rules, and <code>self</code> is no exception. It isnâ€™t possible to reference a struct from multiple locations and call a mutating (<code>&amp;mut self</code>) method on it.</p>
</details><h1><a class="header" href="#ç¤ºä¾‹" id="ç¤ºä¾‹">ç¤ºä¾‹</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    fn new(name: &amp;str) -&gt; Race {  // No receiver, a static method
        Race { name: String::from(name), laps: Vec::new() }
    }

    fn add_lap(&amp;mut self, lap: i32) {  // Exclusive borrowed read-write access to self
        self.laps.push(lap);
    }

    fn print_laps(&amp;self) {  // Shared and read-only borrowed access to self
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    fn finish(self) {  // Exclusive ownership of self
        let total = self.laps.iter().sum::&lt;i32&gt;();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>All four methods here use a different method receiver.
<ul>
<li>You can point out how that changes what the function can do with the variable values and if/how it can be used again in <code>main</code>.</li>
<li>You can showcase the error that appears when trying to call <code>finish</code> twice.</li>
</ul>
</li>
<li>Note that although the method receivers are different, the non-static functions are called the same way in the main body. Rust enables automatic referencing and dereferencing when calling methods. Rust automatically adds in the <code>&amp;</code>, <code>*</code>, <code>muts</code> so that that object matches the method signature.</li>
<li>You might point out that <code>print_laps</code> is using a vector that is iterated over. We describe vectors in more detail in the afternoon. </li>
</ul>
</details><h1><a class="header" href="#ç¬¬äºŒå¤©ä¸Šåˆä¹ é¢˜" id="ç¬¬äºŒå¤©ä¸Šåˆä¹ é¢˜">ç¬¬äºŒå¤©ä¸Šåˆä¹ é¢˜</a></h1>
<p>æˆ‘ä»¬å°†è€ƒè™‘ä»¥ä¸‹ä¸¤ç§åœºæ™¯ï¼š</p>
<ul>
<li>
<p>Storing books and querying the collection</p>
</li>
<li>
<p>Keeping track of health statistics for patients</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#storing-books" id="storing-books">Storing Books</a></h1>
<p>We will learn much more about structs and the <code>Vec&lt;T&gt;</code> type tomorrow. For now, you just need to know part of its API:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut vec = vec![10, 20];
    vec.push(30);
    let midpoint = vec.len() / 2;
    println!(&quot;middle value: {}&quot;, vec[midpoint]);
    for item in &amp;vec {
        println!(&quot;item: {item}&quot;);
    }
}
</code></pre></pre>
<p>Use this to model a libraryâ€™s book collection. Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and update the types to make it compile:</p>
<pre><pre class="playground"><code class="language-rust should_panic">struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Notice how the `self` parameter
// changes type to indicate the method's required level of ownership
// over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {
    fn new() -&gt; Library {
        todo!(&quot;Initialize and return a `Library` value&quot;)
    }

    fn len(&amp;self) -&gt; usize {
        todo!(&quot;Return the length of `self.books`&quot;)
    }

    fn is_empty(&amp;self) -&gt; bool {
        todo!(&quot;Return `true` if `self.books` is empty&quot;)
    }

    fn add_book(&amp;mut self, book: Book) {
        todo!(&quot;Add a new book to `self.books`&quot;)
    }

    fn print_books(&amp;self) {
        todo!(&quot;Iterate over `self.books` and print each book's title and year&quot;)
    }

    fn oldest_book(&amp;self) -&gt; Option&lt;&amp;Book&gt; {
        todo!(&quot;Return a reference to the oldest book (if any)&quot;)
    }
}

fn main() {
    let mut library = Library::new();

    println!(
        &quot;The library is empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));

    println!(
        &quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.print_books();

    match library.oldest_book() {
        Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
        None =&gt; println!(&quot;The library is empty!&quot;),
    }

    println!(&quot;The library has {} books&quot;, library.len());
    library.print_books();
}
</code></pre></pre>
<h1><a class="header" href="#å¥åº·ç»Ÿè®¡" id="å¥åº·ç»Ÿè®¡">å¥åº·ç»Ÿè®¡</a></h1>
<p>ä½ æ­£åœ¨å®ç°ä¸€ä¸ªå¥åº·ç›‘æ§ç³»ç»Ÿã€‚ä½œä¸ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œä½ éœ€è¦å¯¹ç”¨æˆ·çš„å¥åº·ç»Ÿè®¡æ•°æ®è¿›è¡Œè¿½è¸ªã€‚</p>
<p><code>User</code> ç»“æ„ä½“çš„å®šä¹‰å’Œ <code>impl</code> å—ä¸­ä¸€äº›å‡½æ•°çš„æ¡†æ¶å·²ç»ç»™å‡ºã€‚ä½ çš„ç›®æ ‡æ˜¯å®ç°åœ¨ <code>impl</code> å—ä¸­å®šä¹‰çš„ <code>User</code> <code>struct</code> çš„æ–¹æ³•ã€‚</p>
<p>å°†ä»¥ä¸‹ä»£ç å¤åˆ¶åˆ° <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>ï¼Œå¹¶å¡«å……ç¼ºå¤±çš„æ–¹æ³•ï¼š</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        todo!(&quot;Create a new User instance&quot;)
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        todo!(&quot;Return the user's name&quot;)
    }

    pub fn age(&amp;self) -&gt; u32 {
        todo!(&quot;Return the user's age&quot;)
    }

    pub fn height(&amp;self) -&gt; f32 {
        todo!(&quot;Return the user's height&quot;)
    }

    pub fn doctor_visits(&amp;self) -&gt; u32 {
        todo!(&quot;Return the number of time the user has visited the doctor&quot;)
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        todo!(&quot;Set the user's age&quot;)
    }

    pub fn set_height(&amp;mut self, new_height: f32) {
        todo!(&quot;Set the user's height&quot;)
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        todo!(&quot;Update a user's statistics based on measurements from a visit to the doctor&quot;)
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_height() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.height(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.doctor_visits(), 0);
    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (120, 80),
    });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);

    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (115, 76),
    });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
}
</code></pre></pre>
<h1><a class="header" href="#æ ‡å‡†åº“" id="æ ‡å‡†åº“">æ ‡å‡†åº“</a></h1>
<p>Rust é™„å¸¦ä¸€ä¸ªæ ‡å‡†åº“ï¼Œæ­¤åº“æœ‰åŠ©äºå»ºç«‹ä¸€ä¸ªä¾› Rust åº“å’Œç¨‹åº ä½¿ç”¨çš„å¸¸ç”¨ç±»å‹é›†ã€‚è¿™æ ·ä¸€æ¥ï¼Œä¸¤ä¸ªåº“ä¾¿å¯é¡ºç•…åœ°æ­é…è¿ä½œï¼Œ å› ä¸ºå®ƒä»¬ä½¿ç”¨ç›¸åŒçš„ <code>String</code> ç±»å‹ã€‚</p>
<p>å¸¸è§çš„è¯æ±‡ç±»å‹åŒ…æ‹¬ï¼š</p>
<ul>
<li>
<p><a href="std/option-result.html"><code>Option</code> å’Œ <code>Result</code></a> ç±»å‹ï¼šç”¨äºå¯é€‰å€¼å’Œ <a href="error-handling.html">é”™è¯¯å¤„ç†</a>ã€‚</p>
</li>
<li>
<p><a href="std/string.html"><code>String</code></a>ï¼šç”¨äºè‡ªæœ‰æ•°æ®çš„é»˜è®¤å­—ç¬¦ä¸²ç±»å‹ã€‚</p>
</li>
<li>
<p><a href="std/vec.html"><code>Vec</code></a>ï¼šæ ‡å‡†çš„å¯æ‰©å±•çŸ¢é‡ã€‚</p>
</li>
<li>
<p><a href="std/hashmap.html"><code>HashMap</code></a>ï¼šé‡‡ç”¨å¯é…ç½®å“ˆå¸Œç®—æ³•çš„å“ˆå¸Œæ˜ å°„ ç±»å‹ã€‚</p>
</li>
<li>
<p><a href="std/box.html"><code>Box</code></a>ï¼šé€‚ç”¨äºå †åˆ†é…æ•°æ®çš„è‡ªæœ‰æŒ‡é’ˆã€‚</p>
</li>
<li>
<p><a href="std/rc.html"><code>Rc</code></a>ï¼šé€‚ç”¨äºå †åˆ†é…æ•°æ®çš„å…±äº«å¼•ç”¨è®¡æ•°æŒ‡é’ˆã€‚</p>
</li>
</ul>
<details>
<ul>
<li>Rust å®é™…ä¸Šå«æœ‰å¤šä¸ªå±‚çº§çš„æ ‡å‡†åº“ï¼Œåˆ†åˆ«æ˜¯ <code>core</code>ã€<code>alloc</code> å’Œ <code>std</code>ã€‚</li>
<li><code>core</code> åŒ…æ‹¬æœ€åŸºæœ¬çš„ç±»å‹ä¸å‡½æ•°ï¼Œè¿™äº›ç±»å‹ä¸å‡½æ•°ä¸ä¾èµ–äº <code>libc</code>ã€åˆ†é…å™¨ æˆ–æ˜¯å¦å­˜åœ¨æ“ä½œç³»ç»Ÿã€‚</li>
<li><code>alloc</code> åŒ…æ‹¬éœ€è¦å…¨å±€å †åˆ†é…å™¨çš„ç±»å‹ï¼Œä¾‹å¦‚ <code>Vec</code>ã€<code>Box</code> å’Œ <code>Arc</code>ã€‚</li>
<li>åµŒå…¥å¼ Rust åº”ç”¨é€šå¸¸åªä½¿ç”¨ <code>core</code>ï¼Œå¶å°”ä¼šä½¿ç”¨ <code>alloc</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#option-å’Œ-result" id="option-å’Œ-result"><code>Option</code> å’Œ <code>Result</code></a></h1>
<p>è¿™äº›ç±»å‹è¡¨ç¤ºå¯é€‰æ•°æ®ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let numbers = vec![10, 20, 30];
    let first: Option&lt;&amp;i8&gt; = numbers.first();
    println!(&quot;first: {first:?}&quot;);

    let arr: Result&lt;[i8; 3], Vec&lt;i8&gt;&gt; = numbers.try_into();
    println!(&quot;arr: {arr:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Option</code> å’Œ <code>Result</code> çš„ä½¿ç”¨èŒƒå›´å¾ˆå¹¿ï¼Œä¸å±€é™äºæ ‡å‡†åº“ã€‚</li>
<li>ç›¸è¾ƒäº <code>&amp;T</code>ï¼Œ<code>Option&lt;&amp;T&gt;</code> çš„ç©ºé—´å¼€é”€ä¸ºé›¶ã€‚</li>
<li><code>Result</code> æ˜¯ç”¨äºå®ç°é”™è¯¯å¤„ç†çš„æ ‡å‡†ç±»å‹ï¼Œæˆ‘ä»¬å°†åœ¨ç¬¬ 3 å¤©çš„è¯¾ç¨‹ä¸­ä»‹ç»ã€‚</li>
<li><code>try_into</code> attempts to convert the vector into a fixed-sized array. This can fail:
<ul>
<li>If the vector has the right size, <code>Result::Ok</code> is returned with the array.</li>
<li>Otherwise, <code>Result::Err</code> is returned with the original vector.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> æ˜¯æ ‡å‡†å †åˆ†é…çš„å¯æ‰©å®¹ UTF-8 å­—ç¬¦ä¸²ç¼“å†²åŒºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;ğŸ‡¨ğŸ‡­&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(),
             s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> ä¼šå®ç° <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥ å¯¹ <code>String</code> è°ƒç”¨æ‰€æœ‰ <code>str</code> æ–¹æ³•ã€‚</p>
<details>
<ul>
<li><code>String::new</code> returns a new empty string, use <code>String::with_capacity</code> when you know how much data you want to push to the string.</li>
<li><code>String::len</code> returns the size of the <code>String</code> in bytes (which can be different from its length in characters).</li>
<li><code>String::chars</code> returns an iterator over the actual characters. Note that a <code>char</code> can be different from what a human will consider a â€œcharacterâ€ due to <a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">grapheme clusters</a>.</li>
<li>When people refer to strings they could either be talking about <code>&amp;str</code> or <code>String</code>.</li>
<li>When a type implements <code>Deref&lt;Target = T&gt;</code>, the compiler will let you transparently call methods from <code>T</code>.
<ul>
<li><code>String</code> implements <code>Deref&lt;Target = str&gt;</code> which transparently gives it access to <code>str</code>â€˜s methods.</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and  <code>let s3 = &amp;*s1</code>;.</li>
</ul>
</li>
<li><code>String</code> is implemented as a wrapper around a vector of bytes, many of the operations you see supported on vectors are also supported on <code>String</code>, but with some extra guarantees.</li>
<li>Compare the different ways to index a <code>String</code>:
<ul>
<li>To a character by using <code>s3.chars().nth(i).unwrap()</code> where <code>i</code> is in-bound, out-of-bounds.</li>
<li>To a substring by using <code>s3[0..4]</code>, where that slice is on character boundaries or not.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#vec" id="vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> æ˜¯æ ‡å‡†çš„å¯è°ƒæ•´å¤§å°å †åˆ†é…ç¼“å†²åŒºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!(&quot;{v3:?}&quot;);

    // Remove consecutive duplicates.
    v3.dedup();
    println!(&quot;{v3:?}&quot;);
}
</code></pre></pre>
<p><code>Vec</code> ä¼šå®ç° <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥å¯¹ <code>Vec</code> è°ƒç”¨ slice æ–¹æ³•ã€‚</p>
<details>
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored on the heap. This means the amount of data doesnâ€™t need to be  known at compile time. It can grow or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you donâ€™t have to specify <code>T</code> explicitly. As always with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</li>
<li><code>vec![...]</code> is a canonical macro to use instead of <code>Vec::new()</code> and it supports adding initial elements to the vector.</li>
<li>To index the vector you use <code>[</code> <code>]</code>, but they will panic if out of bounds. Alternatively, using <code>get</code> will return an <code>Option</code>. The <code>pop</code> function will remove the last element.</li>
<li>Show iterating over a vector and mutating the value: <code>for e in &amp;mut v { *e += 50; }</code></li>
</ul>
</details><h1><a class="header" href="#hashmap" id="hashmap"><code>HashMap</code></a></h1>
<p>æ ‡å‡†çš„å“ˆå¸Œæ˜ å°„ï¼Œå†…å«é’ˆå¯¹ HashDoS æ”»å‡»çš„ä¿æŠ¤æªæ–½ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;.to_string(), 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;.to_string(), 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;.to_string(), 303);

    if !page_counts.contains_key(&quot;Les MisÃ©rables&quot;) {
        println!(&quot;We know about {} books, but not Les MisÃ©rables.&quot;,
                 page_counts.len());
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;)
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        let page_count: &amp;mut i32 = page_counts.entry(book.to_string()).or_insert(0);
        *page_count += 1;
    }

    println!(&quot;{page_counts:#?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>HashMap</code> is not defined in the prelude and needs to be brought into scope.</p>
</li>
<li>
<p>Try the following lines of code. The first line will see if a book is in the hashmap and if not return an alternative value. The second line will insert the alternative value in the hashmap if the book is not found.</p>
<pre><code class="language-rust ignore">  let pc1 = page_counts
      .get(&quot;Harry Potter and the Sorcerer's Stone &quot;)
      .unwrap_or(&amp;336);
  let pc2 = page_counts
      .entry(&quot;The Hunger Games&quot;.to_string())
      .or_insert(374);
</code></pre>
</li>
<li>
<p>Unlike <code>vec!</code>, there is unfortunately no standard <code>hashmap!</code> macro.</p>
<ul>
<li>
<p>Although, since Rust 1.56, HashMap implements <a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E"><code>From&lt;[(K, V); N]&gt;</code></a>, which allows us to easily initialize a hash map from a literal array:</p>
<pre><code class="language-rust ignore">  let page_counts = HashMap::from([
    (&quot;Harry Potter and the Sorcerer's Stone&quot;.to_string(), 336),
    (&quot;The Hunger Games&quot;.to_string(), 374),
  ]);
</code></pre>
</li>
</ul>
</li>
<li>
<p>Alternatively HashMap can be built from any <code>Iterator</code> which yields key-value tuples.</p>
</li>
<li>
<p>We are showing <code>HashMap&lt;String, i32&gt;</code>, and avoid using <code>&amp;str</code> as key to make examples easier. Using references in collections can, of course, be done, but it can lead into complications with the borrow checker.</p>
<ul>
<li>Try removing <code>to_string()</code> from the example above and see if it still compiles. Where do you think we might run into issues?</li>
</ul>
</li>
<li>
<p>This type has several â€œmethod-specificâ€ return types, such as <code>std::collections::hash_map::Keys</code>. These types often appear in searches of the Rust docs. Show students the docs for this type, and the helpful link back to the <code>keys</code> method.</p>
</li>
</ul>
</details><h1><a class="header" href="#box" id="box"><code>Box</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> æ˜¯æŒ‡å‘å †ä¸Šæ•°æ®çš„è‡ªæœ‰æŒ‡é’ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> ä¼šå®ç° <code>Deref&lt;Target = T&gt;</code>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">ç›´æ¥åœ¨ <code>Box&lt;T&gt;</code> ä¸Šé€šè¿‡ <code>T</code> è°ƒç”¨ç›¸åº”æ–¹æ³•</a>ã€‚</p>
<details>
<ul>
<li>åœ¨ C++ ä¸­ï¼Œ<code>Box</code> ä¸ <code>std::unique_ptr</code> ç±»ä¼¼ï¼Œé™¤äº†å®ƒä¸€å®šä¼šä¸ä¸º null ä»¥å¤–ã€‚</li>
<li>åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œå› ä¸ºæœ‰ <code>Deref</code>ï¼Œæ‚¨ç”šè‡³å¯ä»¥åœ¨ <code>println!</code> è¯­å¥ä¸­çœç•¥ <code>*</code>ã€‚</li>
<li>åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œ<code>Box</code> å¯èƒ½ä¼šå¾ˆå®ç”¨ï¼š
<ul>
<li>åœ¨ç¼–è¯‘æ—¶é—´é‡åˆ°æ— æ³•çŸ¥æ™“å¤§å°çš„ç±»å‹ï¼Œä½† Rust ç¼–è¯‘å™¨éœ€è¦çŸ¥é“ç¡®åˆ‡å¤§å°ã€‚</li>
<li>æƒ³è¦è½¬è®©å¤§é‡æ•°æ®çš„æ‰€æœ‰æƒã€‚ä¸ºé¿å…åœ¨å †æ ˆä¸Šå¤åˆ¶å¤§é‡æ•°æ®ï¼Œè¯·æ”¹ä¸ºå°†æ•°æ®å­˜å‚¨åœ¨ <code>Box</code> ä¸­çš„å †ä¸Šï¼Œä»¥ä¾¿ä»…ç§»åŠ¨æŒ‡é’ˆã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#åŒ…å«é€’å½’æ•°æ®ç»“æ„çš„-box" id="åŒ…å«é€’å½’æ•°æ®ç»“æ„çš„-box">åŒ…å«é€’å½’æ•°æ®ç»“æ„çš„ Box</a></h1>
<p>é€’å½’æ•°æ®ç±»å‹æˆ–å…·æœ‰åŠ¨æ€å¤§å°çš„æ•°æ®ç±»å‹éœ€è¦ä½¿ç”¨ <code>Box</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >Cons</text><text x="106" y="92" >1</text><circle cx="148" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >Cons</text><text x="370" y="92" >2</text><circle cx="412" cy="88" r="3" class="nofill"></circle><text x="490" y="92" >Nil</text><line x1="552" y1="80" x2="544" y2="96" class="solid"></line><line x1="560" y1="80" x2="552" y2="96" class="solid"></line><line x1="592" y1="80" x2="584" y2="96" class="solid"></line><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="172" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="92" y1="72" x2="92" y2="104" class="solid"></line><line x1="132" y1="72" x2="132" y2="104" class="solid"></line><line x1="172" y1="72" x2="172" y2="104" class="solid"></line><line x1="36" y1="104" x2="172" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="436" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="396" y1="72" x2="396" y2="104" class="solid"></line><line x1="436" y1="72" x2="436" y2="104" class="solid"></line><line x1="300" y1="104" x2="436" y2="104" class="solid"></line></g><g><line x1="476" y1="72" x2="612" y2="72" class="solid"></line><line x1="476" y1="72" x2="476" y2="104" class="solid"></line><line x1="532" y1="72" x2="532" y2="104" class="solid"></line><line x1="572" y1="72" x2="572" y2="104" class="solid"></line><line x1="612" y1="72" x2="612" y2="104" class="solid"></line><line x1="476" y1="104" x2="612" y2="104" class="solid"></line></g><g><line x1="152" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="416" y1="88" x2="464" y2="88" class="solid"></line><polygon points="464,84 472,88 464,92" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="148" class="broken"></line><line x1="632" y1="152" x2="640" y2="152" class="solid"></line><path d="M 644,148 A 4,4 0,0,1 640,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the <code>List</code>, the compiler would not compute a fixed size of the struct in memory (<code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> å¤§å°ä¸ä¸€èˆ¬æŒ‡é’ˆç›¸åŒï¼Œå¹¶ä¸”åªä¼šæŒ‡å‘å †ä¸­çš„ä¸‹ä¸€ä¸ª <code>List</code> å…ƒç´ ï¼Œ å› æ­¤å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p>
</li>
<li>
<p>å°† <code>Box</code> ä» List å®šä¹‰ä¸­ç§»é™¤åï¼Œç”»é¢ä¸Šä¼šæ˜¾ç¤ºç¼–è¯‘å™¨é”™è¯¯ã€‚å¦‚æœæ‚¨çœ‹åˆ°â€œRecursive with indirectionâ€é”™è¯¯æ¶ˆæ¯ï¼Œè¿™æ˜¯åœ¨æç¤ºæ‚¨ä½¿ç”¨ Box æˆ–å…¶ä»–ç±»å‹çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯ç›´æ¥å‚¨å­˜å€¼ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å°ä¼—ä¼˜åŒ–" id="å°ä¼—ä¼˜åŒ–">å°ä¼—ä¼˜åŒ–</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    Cons(T, Box&lt;List&lt;T&gt;&gt;),
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<p><code>Box</code> ä¸å¾—ä¸ºç©ºï¼Œå› æ­¤æŒ‡é’ˆå§‹ç»ˆæœ‰æ•ˆä¸”é <code>null</code>ã€‚è¿™æ ·ï¼Œ ç¼–è¯‘å™¨å°±å¯ä»¥ä¼˜åŒ–å†…å­˜å¸ƒå±€ï¼š</p>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><text x="42" y="60" >list</text><text x="50" y="92" >1</text><circle cx="92" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >2</text><circle cx="356" cy="88" r="3" class="nofill"></circle><line x1="440" y1="80" x2="432" y2="96" class="solid"></line><line x1="448" y1="80" x2="440" y2="96" class="solid"></line><text x="474" y="92" >null</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="280" y1="152" x2="288" y2="152" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><line x1="584" y1="152" x2="592" y2="152" class="solid"></line><line x1="600" y1="152" x2="608" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><path d="M 208,24 A 4,4 0,0,1 212,28" class="nofill"></path><line x1="212" y1="28" x2="212" y2="148" class="broken"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><path d="M 212,148 A 4,4 0,0,1 208,152" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="148" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,148 A 4,4 0,0,0 264,152" class="nofill"></path><line x1="264" y1="152" x2="272" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="116" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="76" y1="72" x2="76" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="36" y1="104" x2="116" y2="104" class="solid"></line></g><g><line x1="300" y1="72" x2="380" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="340" y1="72" x2="340" y2="104" class="solid"></line><line x1="380" y1="72" x2="380" y2="104" class="solid"></line><line x1="300" y1="104" x2="380" y2="104" class="solid"></line></g><g><line x1="420" y1="72" x2="516" y2="72" class="solid"></line><line x1="420" y1="72" x2="420" y2="104" class="solid"></line><line x1="460" y1="72" x2="460" y2="104" class="solid"></line><line x1="516" y1="72" x2="516" y2="104" class="solid"></line><line x1="420" y1="104" x2="516" y2="104" class="solid"></line></g><g><line x1="96" y1="88" x2="288" y2="88" class="solid"></line><polygon points="288,84 296,88 288,92" class="filled"></polygon></g><g><line x1="360" y1="88" x2="408" y2="88" class="solid"></line><polygon points="408,84 416,88 408,92" class="filled"></polygon></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="148" class="broken"></line><line x1="616" y1="152" x2="624" y2="152" class="solid"></line><path d="M 628,148 A 4,4 0,0,1 624,152" class="nofill"></path></g></svg></div><h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> æ˜¯å¼•ç”¨è®¡æ•°çš„å…±äº«æŒ‡é’ˆã€‚å¦‚æœæ‚¨éœ€è¦ä»å¤šä¸ªä½ç½® å¼•ç”¨ç›¸åŒçš„æ•°æ®ï¼Œè¯·ä½¿ç”¨æ­¤æŒ‡é’ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let mut a = Rc::new(10);
    let mut b = Rc::clone(&amp;a);

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<ul>
<li>See <a href="std/../concurrency/shared_state/arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>æ‚¨å¯ä»¥å°†å…±äº«æŒ‡é’ˆ_é™çº§_ä¸º <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> æŒ‡é’ˆï¼Œ ä»¥ä¾¿åˆ›å»ºä¹‹åä¼šè¢«èˆå¼ƒçš„å¾ªç¯å¼•ç”¨ã€‚</li>
</ul>
<details>
<ul>
<li><code>Rc</code> çš„è®¡æ•°å¯ç¡®ä¿åªè¦æœ‰å¼•ç”¨ï¼Œå†…å«çš„å€¼å°±ä¼šä¿æŒæœ‰æ•ˆã€‚</li>
<li><code>Rc</code> in Rust is like <code>std::shared_ptr</code> in C++.</li>
<li><code>Rc::clone</code> çš„æˆæœ¬å¾ˆä½ï¼šè¿™ä¸ªåšæ³•ä¼šåˆ›å»ºæŒ‡å‘ç›¸åŒåˆ†é…çš„æŒ‡é’ˆï¼Œå¹¶å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè€Œä¸ä¼šäº§ç”Ÿæ·±å±‚çš„å…‹éš†ï¼Œæ’æŸ¥ä»£ç æ€§èƒ½é—®é¢˜æ—¶é€šå¸¸å¯ä»¥å¿½ç•¥ã€‚</li>
<li><code>make_mut</code> å®é™…ä¸Šä¼šåœ¨å¿…è¦æ—¶å…‹éš†å†…éƒ¨å€¼ï¼ˆâ€œclone-on-writeâ€ï¼‰ï¼Œå¹¶è¿”å›å¯å˜çš„å¼•ç”¨ã€‚</li>
<li>ä½¿ç”¨ <code>Rc::strong_count</code> å¯æŸ¥çœ‹å¼•ç”¨è®¡æ•°ã€‚</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to create cycles that will be dropped properly (likely in combination with <code>RefCell</code>, on the next slide).</li>
</ul>
</details><h1><a class="header" href="#cell-and-refcell" id="cell-and-refcell"><code>Cell</code> and <code>RefCell</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell</code></a> and <a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell</code></a> implement what Rust calls <em>interior mutability:</em> mutation of values in an immutable context.</p>
<p><code>Cell</code> is typically used for simple types, as it requires copying or moving values. More complex interior types typically use <code>RefCell</code>, which tracks shared and exclusive references at runtime and panics if they are misused.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug, Default)]
struct Node {
    value: i64,
    children: Vec&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    fn new(value: i64) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        Rc::new(RefCell::new(Node { value, ..Node::default() }))
    }

    fn sum(&amp;self) -&gt; i64 {
        self.value + self.children.iter().map(|c| c.borrow().sum()).sum::&lt;i64&gt;()
    }
}

fn main() {
    let root = Node::new(1);
    root.borrow_mut().children.push(Node::new(5));
    let subtree = Node::new(10);
    subtree.borrow_mut().children.push(Node::new(11));
    subtree.borrow_mut().children.push(Node::new(12));
    root.borrow_mut().children.push(subtree);

    println!(&quot;graph: {root:#?}&quot;);
    println!(&quot;graph sum: {}&quot;, root.borrow().sum());
}
</code></pre></pre>
<details>
<ul>
<li>If we were using <code>Cell</code> instead of <code>RefCell</code> in this example, we would have to move the <code>Node</code> out of the <code>Rc</code> to push children, then move it back in. This is safe because thereâ€™s always one, un-referenced value in the cell, but itâ€™s not ergonomic.</li>
<li>To do anything with a Node, you must call a <code>RefCell</code> method, usually <code>borrow</code> or <code>borrow_mut</code>.</li>
<li>Demonstrate that reference loops can be created by adding <code>root</code> to <code>subtree.children</code> (donâ€™t try to print it!).</li>
<li>To demonstrate a runtime panic, add a <code>fn inc(&amp;mut self)</code> that increments <code>self.value</code> and calls the same method on its children. This will panic in the presence of the reference loop, with <code>thread 'main' panicked at 'already borrowed: BorrowMutError'</code>.</li>
</ul>
</details><h1><a class="header" href="#æ¨¡å—" id="æ¨¡å—">æ¨¡å—</a></h1>
<p>We have seen how <code>impl</code> blocks let us namespace functions to a type.</p>
<p>Similarly, <code>mod</code> lets us namespace types and functions:</p>
<pre><pre class="playground"><code class="language-rust editable">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<details>
<ul>
<li>Packages provide functionality and include a <code>Cargo.toml</code> file that describes how to build a bundle of 1+ crates.</li>
<li>Crates are a tree of modules, where a binary crate creates an executable and a library crate compiles to a library.</li>
<li>Modules define organization, scope, and are the focus of this section.</li>
</ul>
</details><h1><a class="header" href="#å¯è§æ€§" id="å¯è§æ€§">å¯è§æ€§</a></h1>
<p>Modules are a privacy boundary:</p>
<ul>
<li>Module items are private by default (hides implementation details).</li>
<li>Parent and sibling items are always visible.</li>
<li>In other words, if an item is visible in module <code>foo</code>, itâ€™s visible in all the descendants of <code>foo</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<details>
<ul>
<li>Use the <code>pub</code> keyword to make modules public.</li>
</ul>
<p>Additionally, there are advanced <code>pub(...)</code> specifiers to restrict the scope of public visibility.</p>
<ul>
<li>See the <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust Reference</a>.</li>
<li>Configuring <code>pub(crate)</code> visibility is a common pattern.</li>
<li>Less commonly, you can give visibility to a specific path.</li>
<li>In any case, visibility must be granted to an ancestor module (and all of its descendants).</li>
</ul>
</details><h1><a class="header" href="#è·¯å¾„" id="è·¯å¾„">è·¯å¾„</a></h1>
<p>Paths are resolved as follows:</p>
<ol>
<li>
<p>As a relative path:</p>
<ul>
<li><code>foo</code> or <code>self::foo</code> refers to <code>foo</code> in the current module,</li>
<li><code>super::foo</code> refers to <code>foo</code> in the parent module.</li>
</ul>
</li>
<li>
<p>As an absolute path:</p>
<ul>
<li><code>crate::foo</code> refers to <code>foo</code> in the root of the current crate,</li>
<li><code>bar::foo</code> refers to <code>foo</code> in the <code>bar</code> crate.</li>
</ul>
</li>
</ol>
<p>A module can bring symbols from another module into scope with <code>use</code>. You will typically see something like this at the top of each module:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashSet;
use std::mem::transmute;
</code></pre></pre>
<h1><a class="header" href="#æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„" id="æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„">æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„</a></h1>
<p>Omitting the module content will tell Rust to look for it in another file:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">mod garden;
</code></pre></pre>
<p>This tells rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>. Similarly, a <code>garden::vegetables</code> module can be found at <code>src/garden/vegetables.rs</code>.</p>
<p>The <code>crate</code> root is in:</p>
<ul>
<li><code>src/lib.rs</code> (for a library crate)</li>
<li><code>src/main.rs</code> (for a binary crate)</li>
</ul>
<p>Modules defined in files can be documented, too, using â€œinner doc commentsâ€. These document the item that contains them -- in this case, a module.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use seeds::SeedPacket;
pub use garden::Garden;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) { todo!() }

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) { todo!() }
</code></pre></pre>
<details>
<ul>
<li>
<p>Before Rust 2018, modules needed to be located at <code>module/mod.rs</code> instead of <code>module.rs</code>, and this is still a working alternative for editions after 2018.</p>
</li>
<li>
<p>The main reason to introduce <code>filename.rs</code> as alternative to <code>filename/mod.rs</code> was because many files named <code>mod.rs</code> can be hard to distinguish in IDEs.</p>
</li>
<li>
<p>Deeper nesting can use folders, even if the main module is a file:</p>
<pre><code class="language-ignore">src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ top_module.rs
â””â”€â”€ top_module/
    â””â”€â”€ sub_module.rs
</code></pre>
</li>
<li>
<p>The place rust will look for modules can be changed with a compiler directive:</p>
<pre><code class="language-rust ignore">#[path = &quot;some/path.rs&quot;]
mod some_module;
</code></pre>
<p>This is useful, for example, if you would like to place tests for a module in a file named <code>some_module_test.rs</code>, similar to the convention in Go.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç¬¬äºŒå¤©ä¸‹åˆä¹ é¢˜" id="ç¬¬äºŒå¤©ä¸‹åˆä¹ é¢˜">ç¬¬äºŒå¤©ä¸‹åˆä¹ é¢˜</a></h1>
<p>ä»Šå¤©ä¸‹åˆçš„ä¹ é¢˜å°†é‡ç‚¹å…³æ³¨å­—ç¬¦ä¸²ï¼ˆstringï¼‰å’Œè¿­ä»£å™¨ï¼ˆiteratorï¼‰ã€‚</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-2/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#è¿­ä»£å™¨å’Œæ‰€æœ‰æƒ" id="è¿­ä»£å™¨å’Œæ‰€æœ‰æƒ">è¿­ä»£å™¨å’Œæ‰€æœ‰æƒ</a></h1>
<p>The ownership model of Rust affects many APIs. An example of this is the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> and <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> traits.</p>
<h2><a class="header" href="#iterator" id="iterator"><code>Iterator</code></a></h2>
<p>Traits are like interfaces: they describe behavior (methods) for a type. The <code>Iterator</code> trait simply says that you can call <code>next</code> until you get <code>None</code> back:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>You use this trait like this:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    println!(&quot;v[0]: {:?}&quot;, iter.next());
    println!(&quot;v[1]: {:?}&quot;, iter.next());
    println!(&quot;v[2]: {:?}&quot;, iter.next());
    println!(&quot;No more items: {:?}&quot;, iter.next());
}
</code></pre></pre>
<p>What is the type returned by the iterator? Test your answer here:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let v: Vec&lt;i8&gt; = vec![10, 20, 30];
    let mut iter = v.iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<p>Why is this type used?</p>
<h2><a class="header" href="#intoiterator" id="intoiterator"><code>IntoIterator</code></a></h2>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an iterator. The related trait <code>IntoIterator</code> tells you how to create the iterator:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter;
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax here means that every implementation of <code>IntoIterator</code> must declare two types:</p>
<ul>
<li><code>Item</code>: the type we iterate over, such as <code>i8</code>,</li>
<li><code>IntoIter</code>: the <code>Iterator</code> type returned by the <code>into_iter</code> method.</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same <code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>Like before, what  is the type returned by the iterator?</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];
    let mut iter = v.into_iter();

    let v0: Option&lt;..&gt; = iter.next();
    println!(&quot;v0: {v0:?}&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#for-loops" id="for-loops"><code>for</code> Loops</a></h2>
<p>Now that we know both <code>Iterator</code> and <code>IntoIterator</code>, we can build <code>for</code> loops. They call <code>into_iter()</code> on an expression and iterates over the resulting iterator:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let v: Vec&lt;String&gt; = vec![String::from(&quot;foo&quot;), String::from(&quot;bar&quot;)];

    for word in &amp;v {
        println!(&quot;word: {word}&quot;);
    }

    for word in v {
        println!(&quot;word: {word}&quot;);
    }
}
</code></pre></pre>
<p>What is the type of <code>word</code> in each loop?</p>
<p>Experiment with the code above and then consult the documentation for <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-%26&#x27;a+Vec%3CT,+A%3E"><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></a> and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#impl-IntoIterator-for-Vec%3CT,+A%3E"><code>impl IntoIterator for Vec&lt;T&gt;</code></a> to check your answers.</p>
<h1><a class="header" href="#å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨" id="å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨">å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨</a></h1>
<p>In this exercise, you are implementing a routing component of a web server. The server is configured with a number of <em>path prefixes</em> which are matched against <em>request paths</em>. The path prefixes can contain a wildcard character which matches a full segment. See the unit tests below.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests pass. Try avoiding allocating a <code>Vec</code> for your intermediate results:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {
    unimplemented!()
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#welcome-to-day-3" id="welcome-to-day-3">Welcome to Day 3</a></h1>
<p>Today, we will cover some more advanced topics of Rust:</p>
<ul>
<li>
<p>Traits: deriving traits, default methods, and important standard library traits.</p>
</li>
<li>
<p>Generics: generic data types, generic methods, monomorphization, and trait objects.</p>
</li>
<li>
<p>Error handling: panics, <code>Result</code>, and the try operator <code>?</code>.</p>
</li>
<li>
<p>Testing: unit tests, documentation tests, and integration tests.</p>
</li>
<li>
<p>Unsafe Rust: raw pointers, static variables, unsafe functions, and extern functions.</p>
</li>
</ul>
<h1><a class="header" href="#æ³›å‹" id="æ³›å‹">æ³›å‹</a></h1>
<p>Rust support generics, which lets you abstract algorithms or data structures (such as sorting or a binary tree) over the types used or stored.</p>
<h1><a class="header" href="#é€šç”¨æ•°æ®ç±»å‹" id="é€šç”¨æ•°æ®ç±»å‹">é€šç”¨æ•°æ®ç±»å‹</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨æ³›å‹å¯¹å…·ä½“å­—æ®µç±»å‹è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Try declaring a new variable <code>let p = Point { x: 5, y: 10.0 };</code>.</p>
</li>
<li>
<p>Fix the code to allow points that have elements of different types.</p>
</li>
</ul>
</details><h1><a class="header" href="#æ³›å‹æ–¹æ³•" id="æ³›å‹æ–¹æ³•">æ³›å‹æ–¹æ³•</a></h1>
<p>æ‚¨å¯ä»¥åœ¨ <code>impl</code> å—ä¸­å£°æ˜é€šç”¨ç±»å‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt;(T, T);

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.0  // + 10
    }

    // fn set_x(&amp;mut self, x: T)
}

fn main() {
    let p = Point(5, 10);
    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<details>
<ul>
<li>*é—®ï¼š*ä¸ºä»€ä¹ˆ <code>T</code> åœ¨ <code>impl&lt;T&gt; Point&lt;T&gt; {}</code> ä¸­æŒ‡å®šäº†ä¸¤æ¬¡ï¼Ÿè¿™ä¸æ˜¯å¤šä½™çš„å—ï¼Ÿ
<ul>
<li>è¿™æ˜¯å› ä¸ºå®ƒæ˜¯æ³›å‹ç±»å‹çš„æ³›å‹å®ç°éƒ¨åˆ†ã€‚å®ƒä»¬æ˜¯ç‹¬ç«‹çš„æ³›å‹å†…å®¹ã€‚</li>
<li>è¿™æ„å‘³ç€è¿™äº›æ–¹æ³•æ˜¯é’ˆå¯¹æ‰€æœ‰ <code>T</code> å®šä¹‰çš„ã€‚</li>
<li>å¯ä»¥ç¼–å†™ <code>impl Point&lt;u32&gt; { .. }</code>ã€‚
<ul>
<li><code>Point</code> ä¾ç„¶æ˜¯ä¸€ä¸ªæ³›å‹ï¼Œå¹¶ä¸”æ‚¨å¯ä»¥ä½¿ç”¨ <code>Point&lt;f64&gt;</code>ï¼Œä½†æ­¤å—ä¸­çš„æ–¹æ³•å°†ä»…é€‚ç”¨äº <code>Point&lt;u32&gt;</code>ã€‚</li>
</ul>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#å•æ€åŒ–" id="å•æ€åŒ–">å•æ€åŒ–</a></h1>
<p>æ³›å‹ä»£ç æ ¹æ®è°ƒç”¨ä½ç½®è½¬æ¢ä¸ºéæ³›å‹ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let integer = Some(5);
    let float = Some(5.0);
}
</code></pre></pre>
<p>å…·ä½“è¡Œä¸ºä¸æ‚¨æ‰€ç¼–å†™çš„ä¸€æ ·</p>
<pre><pre class="playground"><code class="language-rust editable">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>è¿™æ˜¯é›¶æˆæœ¬çš„æŠ½è±¡åŒ–å¤„ç†ï¼šæ‚¨å¾—åˆ°çš„ç»“æœä¸ä¼šå—åˆ°å½±å“ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸åœ¨æ²¡æœ‰è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†çš„æƒ…å†µä¸‹ï¼Œå¯¹æ•°æ®ç»“æ„è¿›è¡Œæ‰‹åŠ¨ç¼–ç æ—¶çš„ç»“æœä¸€æ ·ã€‚</p>
<h1><a class="header" href="#ç‰¹å¾" id="ç‰¹å¾">ç‰¹å¾</a></h1>
<p>Rust è®©æ‚¨å¯ä»¥ä¾æ®ç‰¹å¾å¯¹ç±»å‹è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ã€‚ç‰¹å¾ä¸æ¥å£ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog { name: String, age: i8 }
struct Cat { lives: i8 } // No name needed, cats won't respond anyway.

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String { format!(&quot;Woof, my name is {}!&quot;, self.name) }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String { String::from(&quot;Miau!&quot;) }
}

fn greet&lt;P: Pet&gt;(pet: &amp;P) {
    println!(&quot;Oh you're a cutie! What's your name? {}&quot;, pet.talk());
}

fn main() {
    let captain_floof = Cat { lives: 9 };
    let fido = Dog { name: String::from(&quot;Fido&quot;), age: 5 };

    greet(&amp;captain_floof);
    greet(&amp;fido);
}
</code></pre></pre>
<h1><a class="header" href="#ç‰¹å¾traitå¯¹è±¡" id="ç‰¹å¾traitå¯¹è±¡">ç‰¹å¾ï¼ˆTraitï¼‰å¯¹è±¡</a></h1>
<p>ç‰¹å¾ï¼ˆTraitï¼‰å¯¹è±¡å¯æ¥å—ä¸åŒç±»å‹çš„å€¼ï¼Œä¸¾ä¾‹æ¥è¯´ï¼Œåœ¨é›†åˆä¸­ä¼šæ˜¯è¿™æ ·ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog { name: String, age: i8 }
struct Cat { lives: i8 } // No name needed, cats won't respond anyway.

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String { format!(&quot;Woof, my name is {}!&quot;, self.name) }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String { String::from(&quot;Miau!&quot;) }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from(&quot;Fido&quot;), age: 5 }),
    ];
    for pet in pets {
        println!(&quot;Hello, who are you? {}&quot;, pet.talk());
    }
}
</code></pre></pre>
<p>ä»¥ä¸‹æ˜¯åˆ†é… <code>pets</code> åçš„å†…å­˜å¸ƒå±€ï¼š</p>
<div style='width:100%; height:480px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="480"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="480"></rect><rect x="420" y="232" width="184" height="32" class="solid nofill" rx="0"></rect><text x="434" y="252" >&lt;Dog as Pet&gt;::talk</text><rect x="372" y="392" width="184" height="32" class="solid nofill" rx="0"></rect><text x="386" y="412" >&lt;Cat as Pet&gt;::talk</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >pets</text><text x="466" y="76" >F</text><text x="506" y="76" >i</text><text x="546" y="76" >d</text><text x="586" y="76" >o</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><circle cx="324" cy="88" r="3" class="nofill"></circle><circle cx="340" cy="88" r="3" class="nofill"></circle><circle cx="372" cy="88" r="3" class="nofill"></circle><circle cx="388" cy="88" r="3" class="nofill"></circle><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="426" y="124" >data</text><text x="434" y="156" >name</text><circle cx="508" cy="152" r="3" class="nofill"></circle><text x="514" y="156" >,</text><text x="530" y="156" >4,</text><text x="554" y="156" >4</text><text x="434" y="172" >age</text><text x="554" y="172" >5</text><text x="426" y="220" >vtable</text><text x="378" y="300" >data</text><text x="386" y="332" >lives</text><text x="482" y="332" >9</text><text x="378" y="380" >vtable</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><line x1="296" y1="456" x2="304" y2="456" class="solid"></line><line x1="312" y1="456" x2="320" y2="456" class="solid"></line><line x1="328" y1="456" x2="336" y2="456" class="solid"></line><line x1="344" y1="456" x2="352" y2="456" class="solid"></line><line x1="360" y1="456" x2="368" y2="456" class="solid"></line><line x1="376" y1="456" x2="384" y2="456" class="solid"></line><line x1="392" y1="456" x2="400" y2="456" class="solid"></line><line x1="408" y1="456" x2="416" y2="456" class="solid"></line><line x1="424" y1="456" x2="432" y2="456" class="solid"></line><line x1="440" y1="456" x2="448" y2="456" class="solid"></line><line x1="456" y1="456" x2="464" y2="456" class="solid"></line><line x1="472" y1="456" x2="480" y2="456" class="solid"></line><line x1="488" y1="456" x2="496" y2="456" class="solid"></line><line x1="504" y1="456" x2="512" y2="456" class="solid"></line><line x1="520" y1="456" x2="528" y2="456" class="solid"></line><line x1="536" y1="456" x2="544" y2="456" class="solid"></line><line x1="552" y1="456" x2="560" y2="456" class="solid"></line><line x1="568" y1="456" x2="576" y2="456" class="solid"></line><line x1="584" y1="456" x2="592" y2="456" class="solid"></line><line x1="600" y1="456" x2="608" y2="456" class="solid"></line><line x1="616" y1="456" x2="624" y2="456" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="452" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,452 A 4,4 0,0,0 280,456" class="nofill"></path><line x1="280" y1="456" x2="288" y2="456" class="solid"></line></g><g><line x1="452" y1="56" x2="612" y2="56" class="solid"></line><line x1="452" y1="56" x2="452" y2="88" class="solid"></line><line x1="492" y1="56" x2="492" y2="88" class="solid"></line><line x1="532" y1="56" x2="532" y2="88" class="solid"></line><line x1="572" y1="56" x2="572" y2="88" class="solid"></line><line x1="612" y1="56" x2="612" y2="88" class="solid"></line><line x1="452" y1="88" x2="612" y2="88" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="404" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="356" y1="72" x2="356" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="308" y1="104" x2="404" y2="104" class="solid"></line></g><g><path d="M 432,72 A 4,4 0,0,0 428,76" class="nofill"></path><line x1="428" y1="76" x2="428" y2="100" class="solid"></line><line x1="432" y1="72" x2="440" y2="72" class="solid"></line><polygon points="440,68 448,72 440,76" class="filled"></polygon><path d="M 428,100 A 4,4 0,0,0 432,104" class="nofill"></path><line x1="432" y1="104" x2="504" y2="104" class="solid"></line><path d="M 504,104 A 4,4 0,0,1 508,108" class="nofill"></path><line x1="508" y1="108" x2="508" y2="148" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="324" y1="92" x2="324" y2="404" class="solid"></line><path d="M 324,404 A 4,4 0,0,0 328,408" class="nofill"></path><line x1="328" y1="408" x2="360" y2="408" class="solid"></line><polygon points="360,404 368,408 360,412" class="filled"></polygon></g><g><line x1="340" y1="92" x2="340" y2="324" class="solid"></line><path d="M 340,324 A 4,4 0,0,0 344,328" class="nofill"></path><line x1="344" y1="328" x2="360" y2="328" class="solid"></line><polygon points="360,324 368,328 360,332" class="filled"></polygon></g><g><line x1="372" y1="92" x2="372" y2="244" class="solid"></line><path d="M 372,244 A 4,4 0,0,0 376,248" class="nofill"></path><line x1="376" y1="248" x2="408" y2="248" class="solid"></line><polygon points="408,244 416,248 408,252" class="filled"></polygon></g><g><line x1="388" y1="92" x2="388" y2="148" class="solid"></line><path d="M 388,148 A 4,4 0,0,0 392,152" class="nofill"></path><line x1="392" y1="152" x2="408" y2="152" class="solid"></line><polygon points="408,148 416,152 408,156" class="filled"></polygon></g><g><line x1="420" y1="136" x2="572" y2="136" class="solid"></line><line x1="420" y1="136" x2="420" y2="184" class="solid"></line><line x1="484" y1="136" x2="484" y2="184" class="solid"></line><line x1="572" y1="136" x2="572" y2="184" class="solid"></line><line x1="420" y1="184" x2="572" y2="184" class="solid"></line></g><g><line x1="372" y1="312" x2="500" y2="312" class="solid"></line><line x1="372" y1="312" x2="372" y2="344" class="solid"></line><line x1="436" y1="312" x2="436" y2="344" class="solid"></line><line x1="500" y1="312" x2="500" y2="344" class="solid"></line><line x1="372" y1="344" x2="500" y2="344" class="solid"></line></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="452" class="broken"></line><line x1="632" y1="456" x2="640" y2="456" class="solid"></line><path d="M 644,452 A 4,4 0,0,1 640,456" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>Types that implement a given trait may be of different sizes. This makes it impossible to have things like <code>Vec&lt;dyn Pet&gt;</code> in the example above.</li>
<li><code>dyn Pet</code> is a way to tell the compiler about a dynamically sized type that implements <code>Pet</code>.</li>
<li>In the example, <code>pets</code> is allocated on the stack and the vector data is on the heap. The two vector elements are <em>fat pointers</em>:
<ul>
<li>A fat pointer is a double-width pointer. It has two components: a pointer to the actual object and a pointer to the <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable) for the <code>Pet</code> implementation of that particular object.</li>
<li>The data for the <code>Dog</code> named Fido is the <code>name</code> and <code>age</code> fields. The <code>Cat</code> has a <code>lives</code> field.</li>
</ul>
</li>
<li>Compare these outputs in the above example:
<pre><code class="language-rust ignore">    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
    println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Pet&gt;());
    println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#æ´¾ç”Ÿç‰¹å¾" id="æ´¾ç”Ÿç‰¹å¾">æ´¾ç”Ÿç‰¹å¾</a></h1>
<p>Rust derive macros work by automatically generating code that implements the specified traits for a data structure.</p>
<p>You can let the compiler derive a number of traits as follows:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Clone, PartialEq, Eq, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default();
    let p2 = p1.clone();
    println!(&quot;Is {:?}\nequal to {:?}?\nThe answer is {}!&quot;, &amp;p1, &amp;p2,
             if p1 == p2 { &quot;yes&quot; } else { &quot;no&quot; });
}
</code></pre></pre>
<h1><a class="header" href="#é»˜è®¤æ–¹æ³•" id="é»˜è®¤æ–¹æ³•">é»˜è®¤æ–¹æ³•</a></h1>
<p>ç‰¹å¾å¯ä»¥ä¾ç…§å…¶ä»–ç‰¹å¾æ–¹æ³•æ¥å®ç°è¡Œä¸ºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">trait Equals {
    fn equals(&amp;self, other: &amp;Self) -&gt; bool;
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}

#[derive(Debug)]
struct Centimeter(i16);

impl Equals for Centimeter {
    fn equals(&amp;self, other: &amp;Centimeter) -&gt; bool {
        self.0 == other.0
    }
}

fn main() {
    let a = Centimeter(10);
    let b = Centimeter(20);
    println!(&quot;{a:?} equals {b:?}: {}&quot;, a.equals(&amp;b));
    println!(&quot;{a:?} not_equals {b:?}: {}&quot;, a.not_equals(&amp;b));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Traits may specify pre-implemented (default) methods and methods that users are required to implement themselves. Methods with default implementations can rely on required methods.</p>
</li>
<li>
<p>Move method <code>not_equals</code> to a new trait <code>NotEquals</code>.</p>
</li>
<li>
<p>Make <code>Equals</code> a super trait for <code>NotEquals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">trait NotEquals: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}
</code></pre></pre>
</li>
<li>
<p>Provide a blanket implementation of <code>NotEquals</code> for <code>Equals</code>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">trait NotEquals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool;
}

impl&lt;T&gt; NotEquals for T where T: Equals {
    fn not_equals(&amp;self, other: &amp;Self) -&gt; bool {
        !self.equals(other)
    }
}
</code></pre></pre>
<ul>
<li>With the blanket implementation, you no longer need <code>Equals</code> as a super trait for <code>NotEqual</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#ç‰¹å¾è¾¹ç•Œ" id="ç‰¹å¾è¾¹ç•Œ">ç‰¹å¾è¾¹ç•Œ</a></h1>
<p>ä½¿ç”¨æ³›å‹æ—¶ï¼Œæ‚¨é€šå¸¸ä¼šæƒ³è¦åˆ©ç”¨ç±»å‹æ¥å®ç°æŸäº›ç‰¹æ€§ï¼Œ è¿™æ ·æ‰èƒ½è°ƒç”¨æ­¤ç‰¹å¾çš„æ–¹æ³•ã€‚</p>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <code>T: Trait</code> æˆ– <code>impl Trait</code> æ‰§è¡Œæ­¤æ“ä½œï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

// struct NotClonable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);

    let many = add_42_millions(42_i8);
    println!(&quot;{many}&quot;);
    let many_more = add_42_millions(10_000_000);
    println!(&quot;{many_more}&quot;);
}
</code></pre></pre>
<details>
<p>æ˜¾ç¤º <code>where</code> å­å¥ï¼Œå­¦å‘˜åœ¨é˜…è¯»ä»£ç æ—¶ä¼šçœ‹åˆ°å®ƒã€‚</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>å®ƒä¼šåœ¨æ‚¨æœ‰å¤šä¸ªå½¢å‚çš„æƒ…å†µä¸‹æ•´ç†å‡½æ•°ç­¾åã€‚</li>
<li>å®ƒå…·æœ‰é¢å¤–åŠŸèƒ½ï¼Œå› æ­¤ä¹Ÿæ›´å¼ºå¤§ã€‚
<ul>
<li>å¦‚æœæœ‰äººæé—®ï¼Œä¾¿é˜æ˜é¢å¤–åŠŸèƒ½æ˜¯æŒ‡â€œ:â€å·¦ä¾§çš„ç±»åˆ«å¯ä¸ºä»»æ„å€¼ï¼Œä¾‹å¦‚ <code>Option&lt;T&gt;</code>ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>ä¸ç‰¹å¾è¾¹ç•Œç±»ä¼¼ï¼Œ<code>impl Trait</code> è¯­æ³•å¯ä»¥åœ¨å‡½æ•°å®å‚ å’Œè¿”å›å€¼ä¸­ä½¿ç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Display;

fn get_x(name: impl Display) -&gt; impl Display {
    format!(&quot;Hello {name}&quot;)
}

fn main() {
    let x = get_x(&quot;foo&quot;);
    println!(&quot;{x}&quot;);
}
</code></pre></pre>
<ul>
<li><code>impl Trait</code> è®©æ‚¨å¯ä½¿ç”¨æ— æ³•å‘½åçš„ç±»å‹ã€‚</li>
</ul>
<details>
<p><code>impl Trait</code> çš„æ„ä¹‰å› ä½¿ç”¨ä½ç½®è€Œç•¥æœ‰ä¸åŒã€‚</p>
<ul>
<li>
<p>å¯¹å½¢å‚æ¥è¯´ï¼Œ<code>impl Trait</code> å°±åƒæ˜¯å…·æœ‰ç‰¹å¾è¾¹ç•Œçš„åŒ¿åæ³›å‹å½¢å‚ã€‚</p>
</li>
<li>
<p>å¯¹è¿”å›å€¼ç±»å‹æ¥è¯´ï¼Œå®ƒåˆ™æ„å‘³ç€è¿”å›å€¼ç±»å‹å°±æ˜¯å®ç°è¯¥ç‰¹å¾çš„æŸå…·ä½“ç±»å‹ï¼Œ æ— éœ€ä¸ºè¯¥ç±»å‹å‘½åã€‚å¦‚æœæ‚¨ä¸æƒ³åœ¨å…¬å…± API ä¸­å…¬å¼€è¯¥å…·ä½“ç±»å‹ï¼Œä¾¿å¯ ä½¿ç”¨æ­¤æ–¹æ³•ã€‚</p>
<p>åœ¨è¿”å›ä½ç½®å¤„è¿›è¡Œæ¨æ–­æœ‰ä¸€å®šéš¾åº¦ã€‚ä¼šè¿”å› <code>impl Foo</code> çš„å‡½æ•°ä¼šæŒ‘é€‰ è‡ªèº«è¿”å›çš„å…·ä½“ç±»å‹ï¼Œè€Œä¸å¿…åœ¨æ¥æºä¸­å†™å‡ºæ­¤ä¿¡æ¯ã€‚ä¼šè¿”å› æ³›å‹ç±»å‹ï¼ˆä¾‹å¦‚ <code>collect&lt;B&gt;() -&gt; B</code>ï¼‰çš„å‡½æ•°åˆ™å¯è¿”å›ç¬¦åˆ <code>B</code> çš„ä»»ä½•ç±»å‹ï¼Œè€Œè°ƒç”¨æ–¹å¯èƒ½éœ€è¦é€‰æ‹©ä¸€ä¸ªç±»å‹ï¼Œä¾‹å¦‚ä½¿ç”¨ <code>let x: Vec&lt;_&gt; = foo.collect()</code> æˆ–ä½¿ç”¨ä»¥ä¸‹ Turbofishï¼š<code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>ã€‚</p>
</li>
</ul>
<p>è¿™æ˜¯ä¸€ä¸ªéå¸¸æ£’çš„ç¤ºä¾‹ï¼Œå› ä¸ºå®ƒä½¿ç”¨äº†ä¸¤æ¬¡ <code>impl Display</code>ã€‚è¿™æœ‰åŠ©äºè¯´æ˜ æ­¤å¤„æ²¡æœ‰ä»»ä½•é¡¹ç›®ä¼šå¼ºåˆ¶ä½¿ç”¨ç›¸åŒçš„ <code>impl Display</code> ç±»å‹ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨å•ä¸ª <code>T: Display</code>ï¼Œå®ƒä¼šå¼ºåˆ¶é™åˆ¶è¾“å…¥ <code>T</code> å’Œè¿”å› <code>T</code> å‡ä¸ºåŒä¸€ç±»å‹ã€‚ è¿™å¹¶ä¸é€‚ç”¨äºè¿™ä¸ªç‰¹å®šå‡½æ•°ï¼Œå› ä¸ºæˆ‘ä»¬é¢„æœŸä½œä¸ºè¾“å…¥çš„ç±»å‹å¯èƒ½ ä¸ä¼šæ˜¯ <code>format!</code> è¿”å›çš„å€¼ã€‚å¦‚æœæˆ‘ä»¬å¸Œæœ›é€šè¿‡ <code>: Display</code> è¯­æ³•æ‰§è¡Œç›¸åŒçš„æ“ä½œï¼Œåˆ™éœ€è¦ä¸¤ä¸ª ç‹¬ç«‹çš„æ³›å‹å½¢å‚ã€‚</p>
</details><h1><a class="header" href="#é‡è¦ç‰¹å¾" id="é‡è¦ç‰¹å¾">é‡è¦ç‰¹å¾</a></h1>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ Rust æ ‡å‡†åº“çš„ä¸€äº›æœ€å¸¸è§çš„ç‰¹å¾ï¼š</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> å’Œ <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> ç”¨äº <code>for</code> å¾ªç¯ä¸­ï¼Œ</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> å’Œ <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> ç”¨äºè½¬æ¢å€¼ï¼Œ</li>
<li><a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> å’Œ <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> ç”¨äºå®ç° IOã€‚</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a>ã€<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a> ç­‰ç”¨äºå®ç°è¿ç®—ç¬¦é‡è½½ï¼Œ</li>
<li><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> ç”¨äºå®šä¹‰ææ„å‡½æ•°ã€‚</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> ç”¨äºæ„å»ºç›¸åº”ç±»å‹çš„é»˜è®¤å®ä¾‹ã€‚</li>
</ul>
<h1><a class="header" href="#è¿­ä»£å™¨" id="è¿­ä»£å™¨">è¿­ä»£å™¨</a></h1>
<p>æ‚¨å¯ä»¥è‡ªè¡Œå®ç° <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> ç‰¹å¾ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Iterator</code> ç‰¹å¾ä¼šå¯¹é›†åˆå®ç°è®¸å¤šå¸¸è§çš„å‡½æ•°ç¨‹åºæ“ä½œï¼Œ ä¾‹å¦‚ <code> map</code>filter `<code>å’Œ</code>reduce` ç­‰ã€‚æ‚¨å¯ä»¥é€šè¿‡æ­¤ç‰¹å¾æ‰¾åˆ°æœ‰å…³å®ƒä»¬çš„æ‰€æœ‰ æ–‡æ¡£ã€‚åœ¨ Rust ä¸­ï¼Œè¿™äº›å‡½æ•°åº”ç”Ÿæˆä»£ç ï¼Œä¸”ç”Ÿæˆçš„ä»£ç åº”ä¸ç­‰æ•ˆå‘½ä»¤å¼å®ç°ä¸€æ · é«˜æ•ˆã€‚</p>
</li>
<li>
<p><code>IntoIterator</code> æ˜¯è¿«ä½¿ for å¾ªç¯è¿ä½œçš„ç‰¹å¾ã€‚æ­¤ç‰¹å¾ç”±é›†åˆç±»å‹ ï¼ˆä¾‹å¦‚ <code>Vec&lt;T&gt;</code>ï¼‰å’Œç›¸å…³å¼•ç”¨ï¼ˆä¾‹å¦‚ <code>&amp;Vec&lt;T&gt;</code> å’Œ <code>&amp;[T]</code>ï¼‰è€Œå®ç°ã€‚æ­¤å¤–ï¼ŒèŒƒå›´ä¹Ÿä¼šå®ç°è¿™é¡¹ç‰¹å¾ã€‚å› æ­¤ï¼Œ æ‚¨å¯ä»¥ä½¿ç”¨ <code>for i in some_vec { .. }</code> æ¥éå†æŸçŸ¢é‡ï¼Œä½† <code>some_vec.next()</code> ä¸å­˜åœ¨ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> è®©æ‚¨å¯é€šè¿‡ <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> æ„å»ºä¸€ä¸ªé›†åˆã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes
        .into_iter()
        .map(|prime| prime * prime)
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;prime_squares: {prime_squares:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>Iterator</code> ä¼šå®ç° <code>fn collect&lt;B&gt;(self) -&gt; B where B: FromIterator&lt;Self::Item&gt;, Self: Sized</code></p>
<p>è¿˜æœ‰ä¸€äº›å®ç°ï¼Œè®©æ‚¨å¯æ‰§è¡Œä¸€äº›å¾ˆé…·çš„æ“ä½œï¼Œæ¯”å¦‚ å°† <code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> è½¬æ¢æˆ <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>ã€‚</p>
</details><h1><a class="header" href="#from-å’Œ-into" id="from-å’Œ-into"><code>From</code> å’Œ <code>Into</code></a></h1>
<p>ç±»å‹ä¼šå®ç° <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> å’Œ <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> ä»¥åŠ å¿«ç±»å‹è½¬æ¢ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p>å®ç° <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> åï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å®ç° <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé€šå¸¸åªéœ€å®ç° <code>From</code>ï¼Œå› ä¸ºæ‚¨çš„ç±»å‹ä¹Ÿä¼šå®ç° <code>Into</code>ã€‚</li>
<li>è‹¥è¦å£°æ˜æŸä¸ªå‡½æ•°å®å‚è¾“å…¥ç±»å‹ï¼ˆä¾‹å¦‚â€œä»»ä½•å¯è½¬æ¢æˆ <code>String</code> çš„ç±»å‹â€ï¼‰ï¼Œè§„åˆ™ä¾¿ä¼šç›¸åï¼Œæ­¤æ—¶åº”ä½¿ç”¨ <code>Into</code>ã€‚ æ‚¨çš„å‡½æ•°ä¼šæ¥å—å¯å®ç° <code>From</code> çš„ç±»å‹ï¼Œä»¥åŠé‚£äº›ä»…å®ç° <code>Into</code> çš„ç±»å‹ã€‚</li>
</ul>
</details><h1><a class="header" href="#read-å’Œ-write" id="read-å’Œ-write"><code>Read</code> å’Œ <code>Write</code></a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> å’Œ <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> å¯¹ <code>u8</code> æ¥æºè¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>æ‚¨åŒæ ·å¯ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> å¯¹ <code>u8</code> æ¥æ”¶å™¨è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {:?}&quot;, buffer);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#drop-ç‰¹å¾" id="drop-ç‰¹å¾"><code>Drop</code> ç‰¹å¾</a></h1>
<p>ç”¨äºå®ç° <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> çš„å€¼å¯ä»¥æŒ‡å®šåœ¨è¶…å‡ºèŒƒå›´æ—¶è¿è¡Œçš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Note that <code>std::mem::drop</code> is not the same as <code>std::ops::Drop::drop</code>.</li>
<li>Values are automatically dropped when they go out of scope.</li>
<li>When a value is dropped, if it implements <code>std::ops::Drop</code> then its <code>Drop::drop</code> implementation will be called.</li>
<li>All its fields will then be dropped too, whether or not it implements <code>Drop</code>.</li>
<li><code>std::mem::drop</code> is just an empty function that takes any value. The significance is that it takes ownership of the value, so at the end of its scope it gets dropped. This makes it a convenient way to explicitly drop values earlier than they would otherwise go out of scope.
<ul>
<li>This can be useful for objects that do some work on <code>drop</code>: releasing locks, closing files, etc.</li>
</ul>
</li>
</ul>
<p>è®¨è®ºç‚¹ï¼š</p>
<ul>
<li>ä¸ºä»€ä¹ˆ <code>Drop::drop</code> ä¸ä½¿ç”¨ <code>self</code>ï¼Ÿ
<ul>
<li>ç®€ç­”ï¼šå¦‚æœè¿™æ ·çš„è¯ï¼Œç³»ç»Ÿä¼šåœ¨ä»£ç å—ç»“å°¾ è°ƒç”¨ <code>std::mem::drop</code>ï¼Œè¿›è€Œå¼•å‘å†ä¸€æ¬¡è°ƒç”¨ <code>Drop::drop</code>ï¼Œå¹¶å¼•å‘å †æ ˆ æº¢å‡ºï¼</li>
</ul>
</li>
<li>å°è¯•ç”¨ <code>a.drop()</code> æ›¿æ¢ <code>drop(a)</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#default-ç‰¹å¾" id="default-ç‰¹å¾"><code>Default</code> ç‰¹å¾</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> ç‰¹å¾ä¼šä¸ºç±»å‹ç”Ÿæˆé»˜è®¤å€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self(&quot;John Smith&quot;.into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!(&quot;{default_struct:#?}&quot;);

    let almost_default_struct = Derived {
        y: &quot;Y is set!&quot;.into(),
        ..Derived::default()
    };
    println!(&quot;{almost_default_struct:#?}&quot;);

    let nothing: Option&lt;Derived&gt; = None;
    println!(&quot;{:#?}&quot;, nothing.unwrap_or_default());
}

</code></pre></pre>
<details>
<ul>
<li>ç³»ç»Ÿå¯ä»¥ç›´æ¥å®ç°å®ƒï¼Œä¹Ÿå¯ä»¥é€šè¿‡ <code>#[derive(Default)]</code> æ´¾ç”Ÿå‡ºå®ƒã€‚</li>
<li>A derived implementation will produce a value where all fields are set to their default values.
<ul>
<li>è¿™æ„å‘³ç€ï¼Œè¯¥ç»“æ„ä½“ä¸­çš„æ‰€æœ‰ç±»å‹ä¹Ÿéƒ½å¿…é¡»å®ç° <code>Default</code>ã€‚</li>
</ul>
</li>
<li>æ ‡å‡†çš„ Rust ç±»å‹é€šå¸¸ä¼šä»¥åˆç†çš„å€¼ï¼ˆä¾‹å¦‚ <code> 0</code>â€œâ€ `<code>ç­‰ï¼‰å®ç°</code>Default`ã€‚</li>
<li>éƒ¨åˆ†ç»“æ„ä½“å‰¯æœ¬å¯ä¸é»˜è®¤å€¼å®Œç¾æ­é…è¿ä½œã€‚</li>
<li>Rust æ ‡å‡†åº“äº†è§£ç±»å‹å¯èƒ½ä¼šå®ç° <code>Default</code>ï¼Œå› æ­¤æä¾›äº†ä¾¿åˆ©çš„ä½¿ç”¨æ–¹å¼ã€‚</li>
<li>the <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a></li>
</ul>
</details><h1><a class="header" href="#addmul-" id="addmul-"><code> Add</code>Mul ``â€¦</a></h1>
<p>è¿ç®—ç¬¦é‡è½½æ˜¯é€šè¿‡ <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> ä¸­çš„ç‰¹å¾å®ç°çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Copy, Clone)]
struct Point { x: i32, y: i32 }

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self {x: self.x + other.x, y: self.y + other.y}
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{:?} + {:?} = {:?}&quot;, p1, p2, p1 + p2);
}
</code></pre></pre>
<details>
<p>è®¨è®ºç‚¹ï¼š</p>
<ul>
<li>æ‚¨å¯ä»¥é’ˆå¯¹ <code>&amp;Point</code> å®ç° <code>Add</code>ã€‚æ­¤åšæ³•åœ¨å“ªäº›æƒ…å†µä¸‹å¯æ´¾ä¸Šç”¨åœºï¼Ÿ
<ul>
<li>å›ç­”ï¼š<code>Add:add</code> ä¼šè€—ç”¨ <code>self</code>ã€‚å¦‚æœæ‚¨çš„è¿ç®—ç¬¦é‡è½½å¯¹è±¡ ï¼ˆå³ç±»å‹ <code>T</code>ï¼‰ä¸æ˜¯ <code>Copy</code>ï¼Œå»ºè®®æ‚¨ä¹Ÿä¸º <code>&amp;T</code> é‡è½½è¿ç®—ç¬¦ã€‚è¿™å¯é¿å…è°ƒç”¨ç‚¹ä¸Šå­˜åœ¨ä¸å¿…è¦çš„ å…‹éš†ä»»åŠ¡ã€‚</li>
</ul>
</li>
<li>ä¸ºä»€ä¹ˆ <code>Output</code> æ˜¯å…³è”ç±»å‹ï¼Ÿå¯å°†å®ƒç”¨ä½œè¯¥æ–¹æ³•çš„ç±»å‹å½¢å‚å—ï¼Ÿ
<ul>
<li>ç®€ç­”ï¼šå‡½æ•°ç±»å‹å½¢å‚æ˜¯ç”±è°ƒç”¨æ–¹æ§ç®¡ï¼Œä½† <code>Output</code> è¿™ç±»å…³è”ç±»å‹åˆ™ç”±ç‰¹å¾å®ç°äººå‘˜ æ§ç®¡ã€‚</li>
</ul>
</li>
<li>æ‚¨å¯ä»¥é’ˆå¯¹ä¸¤ç§ä¸åŒç±»å‹å®ç° <code>Add</code>ï¼Œä¾‹å¦‚ï¼Œ <code>impl Add&lt;(i32, i32)&gt; for Point</code> ä¼šå‘ <code>Point</code> ä¸­æ·»åŠ å…ƒç»„ã€‚</li>
</ul>
</details><h1><a class="header" href="#é—­åŒ…" id="é—­åŒ…">é—­åŒ…</a></h1>
<p>é—­åŒ…æˆ– lambda è¡¨è¾¾å¼å…·æœ‰æ— æ³•å‘½åçš„ç±»å‹ã€‚ä¸è¿‡ï¼Œå®ƒä»¬ä¼š å®ç°ç‰¹æ®Šçš„ <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>ï¼Œ <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> å’Œ <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> ç‰¹å¾ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn apply_with_log(func: impl FnOnce(i32) -&gt; i32, input: i32) -&gt; i32 {
    println!(&quot;Calling function on {input}&quot;);
    func(input)
}

fn main() {
    let add_3 = |x| x + 3;
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 10));
    println!(&quot;add_3: {}&quot;, apply_with_log(add_3, 20));

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 4));
    println!(&quot;accumulate: {}&quot;, apply_with_log(&amp;mut accumulate, 5));

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    println!(&quot;multiply_sum: {}&quot;, apply_with_log(multiply_sum, 3));
}
</code></pre></pre>
<details>
<p><code>Fn</code>ï¼ˆä¾‹å¦‚ <code>add_3</code>ï¼‰æ—¢ä¸ä¼šè€—ç”¨ä¹Ÿä¸ä¼šä¿®æ”¹æ•è·çš„å€¼ï¼Œæˆ–è®¸ ä¹Ÿä¸ä¼šæ•è·ä»»ä½•å€¼ã€‚å®ƒå¯è¢«å¹¶å‘è°ƒç”¨å¤šæ¬¡ã€‚</p>
<p><code>FnMut</code>ï¼ˆä¾‹å¦‚ <code>accumulate</code>ï¼‰å¯èƒ½ä¼šæ”¹å˜æ•è·çš„å€¼ã€‚æ‚¨å¯ä»¥å¤šæ¬¡è°ƒç”¨å®ƒï¼Œ ä½†ä¸èƒ½å¹¶å‘è°ƒç”¨å®ƒã€‚</p>
<p>å¦‚æœæ‚¨ä½¿ç”¨ <code>FnOnce</code>ï¼ˆä¾‹å¦‚ <code>multiply_sum</code>ï¼‰ï¼Œæˆ–è®¸åªèƒ½è°ƒç”¨å®ƒä¸€æ¬¡ã€‚å®ƒå¯èƒ½ä¼šè€—ç”¨ æ‰€æ•è·çš„å€¼ã€‚</p>
<p><code>FnMut</code> æ˜¯ <code>FnOnce</code> çš„å­ç±»å‹ã€‚<code>Fn</code> æ˜¯ <code>FnMut</code> å’Œ <code>FnOnce</code> çš„å­ç±»å‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‚¨å¯ä»¥åœ¨ä»»ä½• éœ€è¦è°ƒç”¨ <code>FnOnce</code> çš„åœ°æ–¹ä½¿ç”¨ <code>FnMut</code>ï¼Œè¿˜å¯åœ¨ä»»ä½•éœ€è¦è°ƒç”¨ <code>FnMut</code> æˆ– <code>FnOnce</code> çš„åœ°æ–¹ ä½¿ç”¨ <code>Fn</code>ã€‚</p>
<p>ç¼–è¯‘å™¨ä¹Ÿä¼šæ¨æ–­ <code>Copy</code>ï¼ˆä¾‹å¦‚é’ˆå¯¹ <code>add_3</code>ï¼‰å’Œ <code>Clone</code>ï¼ˆä¾‹å¦‚ <code>multiply_sum</code>ï¼‰ï¼Œ å…·ä½“å–å†³äºé—­åŒ…æ•è·çš„æ•°æ®ã€‚</p>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œé—­åŒ…ä¼šä¾æ®å¼•ç”¨æ¥æ•è·æ•°æ®ï¼ˆå¦‚æœå¯ä»¥çš„è¯ï¼‰ã€‚<code>move</code> å…³é”®å­—åˆ™å¯è®©é—­åŒ…ä¾æ®å€¼ æ¥æ•è·æ•°æ®ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!(&quot;{} {}&quot;, prefix, name)
}

fn main() {
    let hi = make_greeter(&quot;Hi&quot;.to_string());
    hi(&quot;there&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#day-3-morning-exercises" id="day-3-morning-exercises">Day 3: Morning Exercises</a></h1>
<p>We will design a classical GUI library using traits and trait objects.</p>
<p>We will also look at enum dispatch with an exercise involving points and polygons.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/day-3/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#drawing-a-simple-gui" id="drawing-a-simple-gui">Drawing A Simple GUI</a></h1>
<p>Let us design a classical GUI library using our new knowledge of traits and trait objects. Weâ€™ll only implement the drawing of it (as text) for simplicity.</p>
<p>We will have a number of widgets in our library:</p>
<ul>
<li><code>Window</code>: has a <code>title</code> and contains other widgets.</li>
<li><code>Button</code>: has a <code>label</code>. In reality, it would also take a callback function to allow the program to do something when the button is clicked but we wonâ€™t include that since weâ€™re only drawing the GUI.</li>
<li><code>Label</code>: has a <code>label</code>.</li>
</ul>
<p>The widgets will implement a <code>Widget</code> trait, see below.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>, fill in the missing <code>draw_into</code> methods so that you implement the <code>Widget</code> trait:</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button {
            label: Label::new(label),
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}


impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        unimplemented!()
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        unimplemented!()
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;
    )));
    window.draw();
}
</code></pre></pre>
<p>The output of the above program can be something simple like this:</p>
<pre><code class="language-text">========
Rust GUI Demo 1.23
========

This is a small text GUI demo.

| Click me! |
</code></pre>
<p>If you want to draw aligned text, you can use the <a href="https://doc.rust-lang.org/std/fmt/index.html#fillalignment">fill/alignment</a> formatting operators. In particular, notice how you can pad with different characters (here a <code>'/'</code>) and how you can control alignment:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let width = 10;
    println!(&quot;left aligned:  |{:/&lt;width$}|&quot;, &quot;foo&quot;);
    println!(&quot;centered:      |{:/^width$}|&quot;, &quot;foo&quot;);
    println!(&quot;right aligned: |{:/&gt;width$}|&quot;, &quot;foo&quot;);
}
</code></pre></pre>
<p>Using such alignment tricks, you can for example produce output like this:</p>
<pre><code class="language-text">+--------------------------------+
|       Rust GUI Demo 1.23       |
+================================+
| This is a small text GUI demo. |
| +-----------+                  |
| | Click me! |                  |
| +-----------+                  |
+--------------------------------+
</code></pre>
<h1><a class="header" href="#polygon-struct" id="polygon-struct">Polygon Struct</a></h1>
<p>We will create a <code>Polygon</code> struct which contain some points. Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing methods to make the tests pass:</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

pub struct Point {
    // add fields
}

impl Point {
    // add methods
}

pub struct Polygon {
    // add fields
}

impl Polygon {
    // add methods
}

pub struct Circle {
    // add fields
}

impl Circle {
    // add methods
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

#[allow(dead_code)]
fn main() {}
</code></pre></pre>
<details>
<p>Since the method signatures are missing from the problem statements, the key part of the exercise is to specify those correctly. You donâ€™t have to modify the tests.</p>
<p>Other interesting parts of the exercise:</p>
<ul>
<li>Derive a <code>Copy</code> trait for some structs, as in tests the methods sometimes donâ€™t borrow their arguments.</li>
<li>Discover that <code>Add</code> trait must be implemented for two objects to be addable via â€œ+â€. Note that we do not discuss generics until Day 3.</li>
</ul>
</details><h1><a class="header" href="#é”™è¯¯å¤„ç†" id="é”™è¯¯å¤„ç†">é”™è¯¯å¤„ç†</a></h1>
<p>Rust ä¸­çš„é”™è¯¯å¤„ç†æ˜¯ä½¿ç”¨æ˜¾å¼æ§åˆ¶æµæ¥è¿›è¡Œçš„ï¼š</p>
<ul>
<li>åŒ…å«é”™è¯¯çš„å‡½æ•°ä¼šåœ¨è¿”å›ç±»å‹ä¸­åˆ—å‡ºç›¸å…³ä¿¡æ¯ã€‚</li>
<li>æ­¤è§„åˆ™æ²¡æœ‰ä¾‹å¤–ã€‚</li>
</ul>
<h1><a class="header" href="#panics" id="panics">Panics</a></h1>
<p>å¦‚æœè¿è¡Œæ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯ï¼ŒRust ä¼šè§¦å‘ panicï¼š</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panic ç”¨äºæŒ‡ç¤ºä¸å¯æ¢å¤çš„æ„å¤–é”™è¯¯ã€‚
<ul>
<li>Panicåæ˜ äº†ç¨‹åºä¸­çš„ bug é—®é¢˜ã€‚</li>
</ul>
</li>
<li>å¦‚æœå´©æºƒä¸å¯æ¥å—ï¼Œè¯·ä½¿ç”¨ä¸ä¼šè§¦å‘ panic çš„ APIï¼ˆä¾‹å¦‚ <code>Vec::get</code>ï¼‰ã€‚</li>
</ul>
<h1><a class="header" href="#æ•è·å †æ ˆå±•å¼€" id="æ•è·å †æ ˆå±•å¼€">æ•è·å †æ ˆå±•å¼€</a></h1>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œpanic ä¼šå¯¼è‡´å †æ ˆå±•å¼€ã€‚æ‚¨å¯ä»¥æ•è·å±•å¼€ä¿¡æ¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| {
        println!(&quot;hello!&quot;);
    });
    assert!(result.is_ok());
    
    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    assert!(result.is_err());
}
</code></pre></pre>
<ul>
<li>å¦‚æœæœåŠ¡å™¨éœ€è¦æŒç»­è¿è¡Œï¼ˆå³ä½¿æ˜¯åœ¨è¯·æ±‚å‘ç”Ÿå´©æºƒçš„æƒ…å†µä¸‹ï¼‰ï¼Œ æ­¤æ–¹æ³•ååˆ†æœ‰ç”¨ã€‚</li>
<li>å¦‚æœæ‚¨åœ¨ <code>Cargo.toml</code> ä¸­è®¾ç½®äº† <code>panic = 'abort'</code>ï¼Œæ­¤æ–¹æ³•ä¸ä¼šç”Ÿæ•ˆã€‚</li>
</ul>
<h1><a class="header" href="#ä½¿ç”¨-result-è¿›è¡Œç»“æ„åŒ–é”™è¯¯å¤„ç†" id="ä½¿ç”¨-result-è¿›è¡Œç»“æ„åŒ–é”™è¯¯å¤„ç†">ä½¿ç”¨ <code>Result</code> è¿›è¡Œç»“æ„åŒ–é”™è¯¯å¤„ç†</a></h1>
<p>åœ¨å‰é¢ï¼Œæˆ‘ä»¬çœ‹åˆ°äº† <code>Result</code> æšä¸¾ã€‚åœ¨é‡åˆ°æ­£å¸¸æ“ä½œäº§ç”Ÿçš„é¢„æœŸé”™è¯¯æ—¶ï¼Œ æˆ‘ä»¬å¸¸ä¼šç”¨åˆ°æ­¤æ–¹æ³•ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs;
use std::io::Read;

fn main() {
    let file = fs::File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            file.read_to_string(&amp;mut contents);
            println!(&quot;Dear diary: {contents}&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>ä¸ <code>Option</code> æ–¹æ³•ç›¸åŒï¼ŒæˆåŠŸå€¼ä½äº <code>Result</code> æ–¹æ³•å†…éƒ¨ï¼Œ å¼€å‘è€…å¿…é¡»æ˜¾ç¤ºæå–æˆåŠŸå€¼ã€‚å› æ­¤ï¼Œå»ºè®®è¿›è¡Œé”™è¯¯æ£€æŸ¥ã€‚åœ¨ç»ä¸åº”å‡ºç°é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œ å¯ä»¥è°ƒç”¨ <code>unwrap()</code> æˆ– <code>expect()</code> æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å¼€å‘è€…æ„å‘ä¿¡å·ã€‚</li>
<li>æˆ‘ä»¬å»ºè®®é˜…è¯» <code>Result</code> æ–‡æ¡£ã€‚è™½ç„¶è¯¾ç¨‹ä¸­ä¸ä¼šæ¶‰åŠè¯¥æ–‡æ¡£ï¼Œä½†æ˜¯æœ‰å¿…è¦æåˆ°å®ƒã€‚ è¯¥æ–‡æ¡£ä¸­åŒ…å«è®¸å¤šä¾¿æ·çš„æ–¹æ³•å’Œå‡½æ•°ï¼Œå¯¹äºå‡½æ•°å¼ç¼–ç¨‹å¾ˆæœ‰å¸®åŠ©ã€‚</li>
</ul>
</details><h1><a class="header" href="#ä½¿ç”¨--ä¼ æ’­é”™è¯¯" id="ä½¿ç”¨--ä¼ æ’­é”™è¯¯">ä½¿ç”¨ <code>?</code> ä¼ æ’­é”™è¯¯</a></h1>
<p>try æ“ä½œç¬¦ <code>?</code> ç”¨äºå°†é”™è¯¯è¿”å›ç»™è°ƒç”¨æ–¹ã€‚å®ƒèƒ½æŠŠå¸¸ç”¨å‘½ä»¤</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>è½¬æ¢æˆæ›´ç®€å•çš„å‘½ä»¤</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::{fs, io};
use std::io::Read;

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li><code>username</code> å˜é‡å¯ä»¥æ˜¯ <code>Ok(string)</code> æˆ– <code>Err(error)</code>ã€‚</li>
<li>å¯ä»¥ä½¿ç”¨ <code>fs::write</code> è°ƒç”¨æ¥æµ‹è¯•ä¸åŒçš„åœºæ™¯ï¼šæ²¡æœ‰æ–‡ä»¶ã€ç©ºæ–‡ä»¶ã€åŒ…å«ç”¨æˆ·åçš„æ–‡ä»¶ã€‚</li>
<li>The return type of the function has to be compatible with the nested functions it calls. For instance, a function returning a <code>Result&lt;T, Err&gt;</code> can only apply the <code>?</code> operator on a function returning a  <code>Result&lt;AnyT, Err&gt;</code>. It cannot apply the <code>?</code> operator on a function returning an <code>Option&lt;AnyT&gt;</code> or <code>Result&lt;T, OtherErr&gt;</code> unless <code>OtherErr</code> implements <code>From&lt;Err&gt;</code>. Reciprocally, a function returning an <code>Option&lt;T&gt;</code> can only apply the <code>?</code> operator  on a function returning an <code>Option&lt;AnyT&gt;</code>.
<ul>
<li>You can convert incompatible types into one another with the different <code>Option</code> and <code>Result</code> methods  such as <code>Option::ok_or</code>, <code>Result::ok</code>, <code>Result::err</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#è½¬æ¢é”™è¯¯ç±»å‹" id="è½¬æ¢é”™è¯¯ç±»å‹">è½¬æ¢é”™è¯¯ç±»å‹</a></h1>
<p><code>?</code> çš„æœ‰æ•ˆå±•å¼€æ¯”å‰é¢ä»‹ç»çš„å†…å®¹ç•¥å¾®å¤æ‚ä¸€äº›ï¼š</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>æ•ˆæœç­‰åŒäº</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>æ­¤å¤„çš„ <code>From::from</code> è°ƒç”¨è¡¨ç¤ºï¼Œæˆ‘ä»¬å°è¯•å°†é”™è¯¯ç±»å‹è½¬æ¢ä¸º å‡½æ•°è¿”å›çš„ç±»å‹ï¼š</p>
<h1><a class="header" href="#è½¬æ¢é”™è¯¯ç±»å‹-1" id="è½¬æ¢é”™è¯¯ç±»å‹-1">è½¬æ¢é”™è¯¯ç±»å‹</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::fs::{self, File};
use std::io::{self, Read};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;IO error: {e}&quot;),
            Self::EmptyUsername(filename) =&gt; write!(f, &quot;Found no username in {filename}&quot;),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; ReadUsernameError {
        ReadUsernameError::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li><code>username</code> å˜é‡å¯ä»¥æ˜¯ <code>Ok(string)</code> æˆ– <code>Err(error)</code>ã€‚</li>
<li>å¯ä»¥ä½¿ç”¨ <code>fs::write</code> è°ƒç”¨æ¥æµ‹è¯•ä¸åŒçš„åœºæ™¯ï¼šæ²¡æœ‰æ–‡ä»¶ã€ç©ºæ–‡ä»¶ã€åŒ…å«ç”¨æˆ·åçš„æ–‡ä»¶ã€‚</li>
</ul>
<p>It is good practice for all error types that donâ€™t need to be <code>no_std</code> to implement <code>std::error::Error</code>, which requires <code>Debug</code> and <code>Display</code>. The <code>Error</code> crate for <code>core</code> is only available in <a href="https://github.com/rust-lang/rust/issues/103765">nightly</a>, so not fully <code>no_std</code> compatible yet.</p>
<p>Itâ€™s generally helpful for them to implement <code>Clone</code> and <code>Eq</code> too where possible, to make life easier for tests and consumers of your library. In this case we canâ€™t easily do so, because <code>io::Error</code> doesnâ€™t implement them.</p>
</details><h1><a class="header" href="#æ´¾ç”Ÿé”™è¯¯æšä¸¾" id="æ´¾ç”Ÿé”™è¯¯æšä¸¾">æ´¾ç”Ÿé”™è¯¯æšä¸¾</a></h1>
<p><a href="https://docs.rs/thiserror/">thiserror</a> crate æ˜¯åˆ›å»ºé”™è¯¯æšä¸¾çš„å¸¸ç”¨æ–¹æ³•ï¼Œ å°±åƒå‰ä¸€é¡µä¸­æä¾›çš„ç¤ºä¾‹ä¸€æ ·ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::{fs, io};
use std::io::Read;
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;Could not read: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><code>thiserror</code> çš„æ´¾ç”Ÿå®ä¼šè‡ªåŠ¨å®ç° <code>std::error::Error</code>ï¼Œå¹¶ä¸”å¯ä»¥é€‰æ‹©æ€§åœ°å®ç° <code>Display</code> ï¼ˆå¦‚æœæä¾›äº† <code>#[error(...)]</code> å±æ€§ï¼‰å’Œ <code>From</code>ï¼ˆå¦‚æœæ·»åŠ äº† <code>#[from]</code> å±æ€§ï¼‰ã€‚ æ­¤è§„åˆ™ä¹Ÿé€‚ç”¨äºç»“æ„ä½“ã€‚</p>
<p>ä½†æ˜¯ï¼Œæ­¤è§„åˆ™ä¸ä¼šå½±å“å…¬å…± APIï¼Œå¯¹äºåº“è€Œè¨€ï¼Œè¿™éå¸¸ç†æƒ³ã€‚</p>
</details><h1><a class="header" href="#åŠ¨æ€é”™è¯¯ç±»å‹" id="åŠ¨æ€é”™è¯¯ç±»å‹">åŠ¨æ€é”™è¯¯ç±»å‹</a></h1>
<p>æœ‰æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å…è®¸è¿”å›ä»»æ„ç±»å‹çš„é”™è¯¯ï¼Œä½†åˆä¸æƒ³è‡ªå·±æ‰‹åŠ¨ç¼–å†™æšä¸¾æ¥æ¶µç›–æ‰€æœ‰ä¸åŒçš„å¯èƒ½æ€§ã€‚ <code>std::error::Error</code> å¯ä»¥è®©æˆ‘ä»¬è½»æ¾åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::fs;
use std::io::Read;
use thiserror::Error;
use std::error::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    let mut username = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(EmptyUsernameError(String::from(path)).into());
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p>è™½ç„¶è¿™å¯ä»¥çœå´ç¼–å†™ä»£ç çš„éº»çƒ¦ï¼Œä½†ä¹Ÿä¼šå¯¼è‡´æˆ‘ä»¬æ— æ³•åœ¨ç¨‹åºä¸­ä»¥ä¸åŒçš„æ–¹å¼æ­£å¸¸å¤„ç†ä¸åŒçš„ é”™è¯¯æƒ…å†µã€‚å› æ­¤ï¼Œåœ¨åº“çš„å…¬å…± API ä¸­ä½¿ç”¨ <code>Box&lt;dyn Error&gt;</code> é€šå¸¸ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚ ä½†æ˜¯å¯¹äºæ‚¨åªéœ€è¦åœ¨æŸå¤„æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯çš„ç¨‹åºæ¥è¯´ï¼Œè¿™ä¸å¤±ä¸ºä¸€ä¸ª å¾ˆå¥½çš„é€‰æ‹©ã€‚</p>
</details><h1><a class="header" href="#ä¸ºé”™è¯¯æ·»åŠ èƒŒæ™¯ä¿¡æ¯" id="ä¸ºé”™è¯¯æ·»åŠ èƒŒæ™¯ä¿¡æ¯">ä¸ºé”™è¯¯æ·»åŠ èƒŒæ™¯ä¿¡æ¯</a></h1>
<p>å¹¿æ³›ä½¿ç”¨çš„ <a href="https://docs.rs/anyhow/">anyhow</a> crate å¯ä»¥å¸®åŠ©æˆ‘ä»¬ä¸ºé”™è¯¯æ·»åŠ  èƒŒæ™¯ä¿¡æ¯ï¼Œå¹¶å‡å°‘è‡ªå®šä¹‰é”™è¯¯ç±»å‹çš„ æ•°é‡ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::{fs, io};
use std::io::Read;
use anyhow::{Context, Result, bail};

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(&quot;Found no username in {path}&quot;);
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err)     =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such itâ€™s again generally not a good choice for the public API of a library, but is widely used in applications.</li>
<li>Actual error type inside of it can be extracted for examination if necessary.</li>
<li>Functionality provided by <code>anyhow::Result&lt;T&gt;</code> may be familiar to Go developers, as it provides similar usage patterns and ergonomics to <code>(T, error)</code> from Go.</li>
</ul>
</details><h1><a class="header" href="#æµ‹è¯•" id="æµ‹è¯•">æµ‹è¯•</a></h1>
<p>Rust å’Œ Cargo éšé™„äº†ä¸€ä¸ªç®€å•çš„å•å…ƒæµ‹è¯•æ¡†æ¶ï¼š</p>
<ul>
<li>
<p>å•å…ƒæµ‹è¯•åœ¨æ‚¨çš„æ•´ä¸ªä»£ç ä¸­éƒ½å—æ”¯æŒã€‚</p>
</li>
<li>
<p>æ‚¨å¯ä»¥é€šè¿‡ <code>tests/</code> ç›®å½•æ¥æ”¯æŒé›†æˆæµ‹è¯•ã€‚</p>
</li>
</ul>
<h1><a class="header" href="#å•å…ƒæµ‹è¯•" id="å•å…ƒæµ‹è¯•">å•å…ƒæµ‹è¯•</a></h1>
<p>ä½¿ç”¨ <code>#[test]</code> æ ‡è®°å•å…ƒæµ‹è¯•ï¼š</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[test]
fn test_empty() {
    assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
}

#[test]
fn test_single_word() {
    assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
}

#[test]
fn test_multiple_words() {
    assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
}
</code></pre>
<p>ä½¿ç”¨ <code>cargo test</code> æŸ¥æ‰¾å¹¶è¿è¡Œå•å…ƒæµ‹è¯•ã€‚</p>
<h1><a class="header" href="#æµ‹è¯•æ¨¡å—" id="æµ‹è¯•æ¨¡å—">æµ‹è¯•æ¨¡å—</a></h1>
<p>å•å…ƒæµ‹è¯•é€šå¸¸ä¼šæ”¾åœ¨åµŒå¥—æ¨¡å—ä¸­ï¼ˆåœ¨ <a href="https://play.rust-lang.org/">Playground</a> ä¸Šè¿è¡Œæµ‹è¯•ï¼‰ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn helper(a: &amp;str, b: &amp;str) -&gt; String {
    format!(&quot;{a} {b}&quot;)
}

pub fn main() {
    println!(&quot;{}&quot;, helper(&quot;Hello&quot;, &quot;World&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_helper() {
        assert_eq!(helper(&quot;foo&quot;, &quot;bar&quot;), &quot;foo bar&quot;);
    }
}
</code></pre></pre>
<ul>
<li>è¿™æ ·ä¸€æ¥ï¼Œæ‚¨å¯ä»¥å¯¹ä¸“ç”¨å¸®åŠ©ç¨‹åºè¿›è¡Œå•å…ƒæµ‹è¯•ã€‚</li>
<li>ä»…å½“æ‚¨è¿è¡Œ <code>cargo test</code> æ—¶ï¼Œ<code>#[cfg(test)]</code> å±æ€§æ‰æœ‰æ•ˆã€‚</li>
</ul>
<h1><a class="header" href="#æ–‡æ¡£æµ‹è¯•" id="æ–‡æ¡£æµ‹è¯•">æ–‡æ¡£æµ‹è¯•</a></h1>
<p>Rust æœ¬èº«å°±æ”¯æŒæ–‡æ¡£æµ‹è¯•ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>///</code> æ³¨é‡Šä¸­çš„ä»£ç å—ä¼šè‡ªåŠ¨è¢«è§†ä¸º Rust ä»£ç ã€‚</li>
<li>ä»£ç ä¼šä½œä¸º <code>cargo test</code> çš„ä¸€éƒ¨åˆ†è¿›è¡Œç¼–è¯‘å’Œæ‰§è¡Œã€‚</li>
<li>Adding <code># </code> in the code will hide it from the docs, but will still compile/run it.</li>
<li>åœ¨ <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a> ä¸Šæµ‹è¯•ä¸Šè¿°ä»£ç ã€‚</li>
</ul>
<h1><a class="header" href="#é›†æˆæµ‹è¯•" id="é›†æˆæµ‹è¯•">é›†æˆæµ‹è¯•</a></h1>
<p>å¦‚æœæ‚¨æƒ³è¦ä»¥å®¢æˆ·çš„èº«ä»½æµ‹è¯•æ‚¨çš„åº“ï¼Œè¯·ä½¿ç”¨é›†æˆæµ‹è¯•ã€‚</p>
<p>åœ¨ <code>tests/</code> ä¸‹æ–¹åˆ›å»ºä¸€ä¸ª <code>.rs</code> æ–‡ä»¶ï¼š</p>
<pre><code class="language-rust ignore">use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>è¿™äº›æµ‹è¯•åªèƒ½ä½¿ç”¨æ‚¨çš„ crate çš„å…¬å…± APIã€‚</p>
<h2><a class="header" href="#ç”¨äºç¼–å†™æµ‹è¯•çš„å®ç”¨-crate" id="ç”¨äºç¼–å†™æµ‹è¯•çš„å®ç”¨-crate">ç”¨äºç¼–å†™æµ‹è¯•çš„å®ç”¨ crate</a></h2>
<p>Rust ä»…ä¸ºç¼–å†™æµ‹è¯•æä¾›åŸºæœ¬æ”¯æŒã€‚</p>
<p>ä¸‹é¢åˆ—å‡ºäº†æˆ‘ä»¬å»ºè®®åœ¨ç¼–å†™æµ‹è¯•æ—¶ä½¿ç”¨çš„ä¸€äº›å…¶ä»– crateï¼š</p>
<ul>
<li><a href="https://docs.rs/googletest">googletest</a>ï¼šéµä» GoogleTest for C++ ä¼ ç»Ÿçš„ç»¼åˆæµ‹è¯•æ–­è¨€åº“ã€‚</li>
<li><a href="https://docs.rs/proptest">proptest</a>ï¼šåŸºäºå±æ€§çš„æµ‹è¯•ï¼Œé€‚ç”¨äº Rustã€‚</li>
<li><a href="https://docs.rs/rstest">rstest</a>ï¼šæ”¯æŒå›ºä»¶å’Œå‚æ•°åŒ–æµ‹è¯•ã€‚</li>
</ul>
<h1><a class="header" href="#ä¸å®‰å…¨-rust" id="ä¸å®‰å…¨-rust">ä¸å®‰å…¨ Rust</a></h1>
<p>Rust è¯­è¨€åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š</p>
<ul>
<li>**å®‰å…¨ Rustï¼š**å†…å­˜å®‰å…¨ï¼Œæ²¡æœ‰æ½œåœ¨çš„æœªå®šä¹‰è¡Œä¸ºã€‚</li>
<li>**ä¸å®‰å…¨ Rustï¼š**å¦‚æœè¿åäº†å‰ææ¡ä»¶ï¼Œå¯èƒ½ä¼šè§¦å‘æœªå®šä¹‰çš„è¡Œä¸ºã€‚</li>
</ul>
<p>æœ¬è¯¾ç¨‹ä¸­å‡ºç°çš„å¤§å¤šä¸ºâ€œå®‰å…¨ Rustâ€ï¼Œä½†æ˜¯äº†è§£â€œä¸å®‰å…¨ Rustâ€çš„å®šä¹‰ éå¸¸é‡è¦ã€‚</p>
<p>ä¸å®‰å…¨çš„ä»£ç é€šå¸¸å†…å®¹å¾ˆå°‘è€Œä¸”ä¸å…¶ä»–ä»£ç éš”ç¦»ï¼Œ å…¶æ­£ç¡®æ€§ä¹Ÿåº”å¾—åˆ°ä»”ç»†è®°å½•ã€‚è¿™ç±»ä»£ç é€šå¸¸å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡å±‚ä¸­ã€‚</p>
<p>ä¸å®‰å…¨ Rust æä¾›äº†äº”ç§æ–°åŠŸèƒ½ï¼š</p>
<ul>
<li>è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆã€‚</li>
<li>è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡ã€‚</li>
<li>è®¿é—® <code>union</code> å­—æ®µã€‚</li>
<li>è°ƒç”¨ <code>unsafe</code> å‡½æ•°ï¼ŒåŒ…æ‹¬ <code>extern</code> å‡½æ•°ã€‚</li>
<li>å®ç° <code>unsafe</code> traitã€‚</li>
</ul>
<p>ä¸‹é¢ï¼Œæˆ‘ä»¬å°†ç®€è¦ä»‹ç»è¿™äº›ä¸å®‰å…¨åŠŸèƒ½ã€‚å¦‚éœ€äº†è§£å®Œæ•´è¯¦æƒ…ï¼Œè¯·å‚é˜… <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">ã€ŠRust æ‰‹å†Œã€‹ç¬¬ 19.1 ç« </a> å’Œ <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>ã€‚</p>
<details>
<p>ä¸å®‰å…¨ Rust å¹¶ä¸æ„å‘³ç€ä»£ç ä¸æ­£ç¡®ï¼Œè€Œæ˜¯è¿™æ„å‘³ç€å¼€å‘è€…å·²åœç”¨ ç¼–è¯‘å™¨çš„å®‰å…¨åŠŸèƒ½ï¼Œå¿…é¡»è‡ªè¡Œç¼–å†™æ­£ç¡®çš„ ä»£ç ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç¼–è¯‘å™¨ä¸å†å¼ºåˆ¶æ‰§è¡Œ Rust çš„å†…å­˜å®‰å…¨è§„åˆ™ã€‚</p>
</details><h1><a class="header" href="#è§£å¼•ç”¨è£¸æŒ‡é’ˆ" id="è§£å¼•ç”¨è£¸æŒ‡é’ˆ">è§£å¼•ç”¨è£¸æŒ‡é’ˆ</a></h1>
<p>åˆ›å»ºæŒ‡é’ˆæ˜¯å®‰å…¨çš„æ“ä½œï¼Œä½†è§£å¼•ç”¨æŒ‡é’ˆéœ€è¦ä½¿ç”¨ <code>unsafe</code> æ–¹æ³•ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut num = 5;

    let r1 = &amp;mut num as *mut i32;
    let r2 = r1 as *const i32;

    // Safe because r1 and r2 were obtained from references and so are
    // guaranteed to be non-null and properly aligned, the objects underlying
    // the references from which they were obtained are live throughout the
    // whole unsafe block, and they are not accessed either through the
    // references or concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = 10;
        println!(&quot;r2 is: {}&quot;, *r2);
    }
}
</code></pre></pre>
<details>
<p>æˆ‘ä»¬å»ºè®®ï¼ˆè€Œä¸” Android Rust æ ·å¼æŒ‡å—è¦æ±‚ï¼‰ä¸ºæ¯ä¸ª <code>unsafe</code> ä»£ç å—ç¼–å†™ä¸€æ¡æ³¨é‡Šï¼Œ è¯´æ˜è¯¥ä»£ç å—ä¸­çš„ä»£ç å¦‚ä½•æ»¡è¶³å…¶æ‰€æ‰§è¡Œçš„ä¸å®‰å…¨æ“ä½œçš„ å®‰å…¨è¦æ±‚ã€‚</p>
<p>å¯¹äºæŒ‡é’ˆè§£é™¤å¼•ç”¨ï¼Œè¿™æ„å‘³ç€æŒ‡é’ˆå¿…é¡»ä¸º <a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>ï¼Œå³ï¼š</p>
<ul>
<li>æŒ‡é’ˆå¿…é¡»ä¸ºé nullã€‚</li>
<li>æŒ‡é’ˆå¿…é¡»æ˜¯ <em>dereferenceable</em>ï¼ˆåœ¨å•ä¸ªå·²åˆ†é…å¯¹è±¡çš„è¾¹ç•Œå†…ï¼‰ã€‚</li>
<li>å¯¹è±¡ä¸å¾—å·²å–æ¶ˆåˆ†é…ã€‚</li>
<li>ä¸å¾—å¹¶å‘è®¿é—®ç›¸åŒä½ç½®ã€‚</li>
<li>å¦‚æœé€šè¿‡è½¬æ¢å¼•ç”¨ç±»å‹æ¥è·å–æŒ‡é’ˆï¼Œåˆ™åº•å±‚å¯¹è±¡å¿…é¡»å¤„äºæ´»è·ƒçŠ¶æ€ï¼Œ è€Œä¸”ä¸å¾—ä½¿ç”¨ä»»ä½•å¼•ç”¨æ¥è®¿é—®å†…å­˜ã€‚</li>
</ul>
<p>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒæŒ‡é’ˆè¿˜å¿…é¡»æ­£ç¡®å¯¹é½ã€‚</p>
</details><h1><a class="header" href="#å¯å˜çš„é™æ€å˜é‡" id="å¯å˜çš„é™æ€å˜é‡">å¯å˜çš„é™æ€å˜é‡</a></h1>
<p>è¯»å–ä¸å¯å˜çš„é™æ€å˜é‡æ˜¯å®‰å…¨çš„æ“ä½œï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {HELLO_WORLD}&quot;);
}
</code></pre></pre>
<p>ä½†æ˜¯ï¼Œè¯»å–å’Œå†™å…¥å¯å˜çš„é™æ€å˜é‡æ˜¯ä¸å®‰å…¨çš„ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼š é€ æˆæ•°æ®äº‰ç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    unsafe { COUNTER += inc; }  // Potential data race!
}

fn main() {
    add_to_counter(42);

    unsafe { println!(&quot;COUNTER: {COUNTER}&quot;); }  // Potential data race!
}
</code></pre></pre>
<details>
<p>é€šå¸¸ï¼Œæˆ‘ä»¬ä¸å»ºè®®ä½¿ç”¨å¯å˜çš„é™æ€å˜é‡ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œåœ¨ä½å±‚çº§ <code>no_std</code> ä»£ç ä¸­å¯èƒ½éœ€è¦è¿™æ ·åšï¼Œ ä¾‹å¦‚å®ç°å †åˆ†é…å™¨æˆ–ä½¿ç”¨æŸäº› C APIã€‚</p>
</details><h1><a class="header" href="#è”åˆä½“" id="è”åˆä½“">è”åˆä½“</a></h1>
<p>è”åˆä½“ä¸æšä¸¾ç±»ä¼¼ï¼Œä½†æ‚¨éœ€è¦è‡ªè¡Œè·Ÿè¸ªæ´»è·ƒå­—æ®µï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b });  // Undefined behavior!
}
</code></pre></pre>
<details>
<p>åœ¨ Rust ä¸­å¾ˆå°‘éœ€è¦ç”¨åˆ°è”åˆä½“ï¼Œå› ä¸ºæ‚¨é€šå¸¸å¯ä»¥ä½¿ç”¨æšä¸¾ã€‚è”åˆä½“åªæ˜¯å¶å°”ç”¨äº ä¸ C åº“ API è¿›è¡Œäº¤äº’ã€‚</p>
<p>å¦‚æœæ‚¨åªæ˜¯æƒ³å°†å­—èŠ‚é‡æ–°è§£é‡Šä¸ºå…¶ä»–ç±»å‹ï¼Œåˆ™å¯èƒ½éœ€è¦ä½¿ç”¨ <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> æˆ– å®‰å…¨çš„å°è£…å®¹å™¨ï¼Œä¾‹å¦‚ <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crateã€‚</p>
</details><h1><a class="header" href="#è°ƒç”¨-unsafe-å‡½æ•°" id="è°ƒç”¨-unsafe-å‡½æ•°">è°ƒç”¨ Unsafe å‡½æ•°</a></h1>
<p>å¦‚æœå‡½æ•°æˆ–æ–¹æ³•å…·æœ‰é¢å¤–çš„å‰ææ¡ä»¶ï¼Œæ‚¨å¿…é¡»éµå®ˆè¿™äº›å‰ææ¡ä»¶æ¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ åˆ™å¯ä»¥å°†è¯¥å‡½æ•°æˆ–æ–¹æ³•æ ‡è®°ä¸º <code>unsafe</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let emojis = &quot;ğŸ—»âˆˆğŸŒ&quot;;

    // Safe because the indices are in the correct order, within the bounds of
    // the string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(7..11));
    }

    println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!(&quot;emoji: {}&quot;, unsafe { emojis.get_unchecked(0..3) });
    // println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().map(|_| 1).sum()
}
</code></pre></pre>
<h1><a class="header" href="#ç¼–å†™-unsafe-å‡½æ•°" id="ç¼–å†™-unsafe-å‡½æ•°">ç¼–å†™ Unsafe å‡½æ•°</a></h1>
<p>å¦‚æœæ‚¨è‡ªå·±ç¼–å†™çš„å‡½æ•°éœ€è¦æ»¡è¶³ç‰¹å®šæ¡ä»¶ä»¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ æ‚¨å¯ä»¥å°†è¿™äº›å‡½æ•°æ ‡è®°ä¸º <code>unsafe</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // Safe because ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<p>å®é™…ä¸Šï¼Œæˆ‘ä»¬ä¸ä¼šè¿™æ ·ä½¿ç”¨æŒ‡é’ˆï¼Œå› ä¸ºä½¿ç”¨å¼•ç”¨å¯ä»¥å®‰å…¨åœ°è¾¾åˆ°ç›¸åŒçš„ç›®çš„ã€‚</p>
<p>è¯·æ³¨æ„ï¼Œåœ¨ä¸å®‰å…¨å‡½æ•°ä¸­ï¼Œå¯ä»¥åœ¨æ²¡æœ‰ <code>unsafe</code> ä»£ç å—çš„æƒ…å†µä¸‹ä½¿ç”¨ä¸å®‰å…¨ä»£ç ã€‚æˆ‘ä»¬å¯ä»¥ ä½¿ç”¨ <code>#[deny(unsafe_op_in_unsafe_fn)]</code> æ¥ç¦æ­¢æ­¤è¡Œä¸ºã€‚è¯·å°è¯•æ·»åŠ è¯¥å‘½ä»¤ï¼Œçœ‹çœ‹ä¼šå‡ºç°ä»€ä¹ˆæƒ…å†µã€‚</p>
</details><h1><a class="header" href="#è°ƒç”¨å¤–éƒ¨ä»£ç " id="è°ƒç”¨å¤–éƒ¨ä»£ç ">è°ƒç”¨å¤–éƒ¨ä»£ç </a></h1>
<p>åŸºäºå…¶ä»–è¯­è¨€çš„å‡½æ•°å¯èƒ½ä¼šè¿å Rust çš„ä¿è¯ã€‚å› æ­¤ï¼Œ è°ƒç”¨è¿™ç±»å‡½æ•°æ˜¯ä¸å®‰å…¨çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // Undefined behavior if abs misbehaves.
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<details>
<p>è¿™ä¸ªé—®é¢˜é€šå¸¸ä»…å­˜åœ¨äºä½¿ç”¨æŒ‡é’ˆæ‰§è¡Œè¿å Rust å†…å­˜æ¨¡å‹çš„æ“ä½œçš„å¤–éƒ¨å‡½æ•°ä¸­ã€‚ ä½†ä¸€èˆ¬è€Œè¨€ï¼Œä»»ä½• C å‡½æ•°éƒ½æœ‰å¯èƒ½åœ¨ä»»æ„æƒ…å†µä¸‹å‡ºç°æœªå®šä¹‰è¡Œä¸ºã€‚</p>
<p>The <code>&quot;C&quot;</code> in this example is the ABI; <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">other ABIs are available too</a>.</p>
</details><h1><a class="header" href="#å®ç°-unsafe-trait" id="å®ç°-unsafe-trait">å®ç° Unsafe Trait</a></h1>
<p>ä¸å‡½æ•°ä¸€æ ·ï¼Œå¦‚æœæ‚¨åœ¨å®ç°æŸä¸ª trait æ—¶å¿…é¡»ä¿è¯ç‰¹å®šæ¡ä»¶æ¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ æ‚¨ä¹Ÿå¯ä»¥å°†è¯¥ trait æ ‡è®°ä¸º <code>unsafe</code>ã€‚</p>
<p>ä¾‹å¦‚ï¼Œ<code>zerocopy</code> crate åŒ…å«ä¸€ä¸ªä¸å®‰å…¨çš„ traitï¼Œ <a href="https://docs.rs/zerocopy/latest/zerocopy/trait.AsBytes.html">å¤§è‡´å†…å®¹æ˜¯è¿™æ ·çš„</a>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::mem::size_of_val;
use std::slice;

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait AsBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        unsafe {
            slice::from_raw_parts(self as *const Self as *const u8, size_of_val(self))
        }
    }
}

// Safe because u32 has a defined representation and no padding.
unsafe impl AsBytes for u32 {}
</code></pre></pre>
<details>
<p>åœ¨ Rustdoc ä¸­æœ‰å…³ trait çš„ç« èŠ‚ä¸‹ï¼Œæœ‰ä¸€ä¸ªæ ‡é¢˜ä¸º <code># å®‰å…¨</code> çš„éƒ¨åˆ†ä»‹ç»äº† å®‰å…¨å®ç° trait çš„è¦æ±‚ã€‚</p>
<p>å®é™…ä¸Šï¼Œä¸ <code>AsBytes</code> ç›¸å…³çš„å®‰å…¨è¯´æ˜è¿œæ¯”è¿™é‡Œå±•ç¤ºçš„æ›´è¯¦å°½ã€æ›´å¤æ‚ã€‚</p>
<p>å†…ç½®çš„ <code>Send</code> å’Œ <code>Sync</code> trait éƒ½æ˜¯ä¸å®‰å…¨çš„ã€‚</p>
</details><h1><a class="header" href="#day-3-afternoon-exercises" id="day-3-afternoon-exercises">Day 3: Afternoon Exercises</a></h1>
<p>Let us build a safe wrapper for reading directory content!</p>
<p>For this exercise, we suggest using a local dev environment instead of the Playground. This will allow you to run your binary on your own machine.</p>
<p>To get started, follow the <a href="exercises/day-3/../../cargo/running-locally.html">running locally</a> instructions.</p>
<details>
<p>After looking at the exercise, you can look at the <a href="exercises/day-3/solutions-afternoon.html">solution</a> provided.</p>
</details><h1><a class="header" href="#å®‰å…¨-ffi-å°è£…å®¹å™¨" id="å®‰å…¨-ffi-å°è£…å®¹å™¨">å®‰å…¨ FFI å°è£…å®¹å™¨</a></h1>
<p>Rust has great support for calling functions through a <em>foreign function interface</em> (FFI). We will use this to build a safe wrapper for the <code>libc</code> functions you would use from C to read the names of files in a directory.</p>
<p>You will want to consult the manual pages:</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>You will also want to browse the <a href="https://doc.rust-lang.org/std/ffi/"><code>std::ffi</code></a> module. There you find a number of string types which you need for the exercise:</p>
<table><thead><tr><th>ç±»å‹</th><th>Encoding</th><th>Use</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a> and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td><td>UTF-8</td><td>Text processing in Rust</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html"><code>CStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.CString.html"><code>CString</code></a></td><td>NUL-terminated</td><td>Communicating with C functions</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html"><code>OsStr</code></a> and <a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html"><code>OsString</code></a></td><td>OS-specific</td><td>Communicating with the OS</td></tr>
</tbody></table>
<p>You will convert between all these types:</p>
<ul>
<li><code>&amp;str</code> to <code>CString</code>: you need to allocate space for a trailing <code>\0</code> character,</li>
<li><code>CString</code> to <code>*const i8</code>: you need a pointer to call C functions,</li>
<li><code>*const i8</code> to <code>&amp;CStr</code>: you need something which can find the trailing <code>\0</code> character,</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for â€œsome unknow dataâ€,</li>
<li><code>&amp;[u8]</code> to <code>&amp;OsStr</code>: <code>&amp;OsStr</code> is a step towards <code>OsString</code>, use <a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a> to create it,</li>
<li><code>&amp;OsStr</code> to <code>OsString</code>: you need to clone the data in <code>&amp;OsStr</code> to be able to return it and call <code>readdir</code> again.</li>
</ul>
<p>The <a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon</a> also has a very useful chapter about FFI.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing functions and methods:</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿æ¥åˆ°android-ä¸­çš„rust" id="æ¬¢è¿æ¥åˆ°android-ä¸­çš„rust">æ¬¢è¿æ¥åˆ°Android ä¸­çš„Rust</a></h1>
<p>Rust æ”¯æŒAndroid çš„åŸç”Ÿå¹³å°å¼€å‘ã€‚è¿™æ„å‘³ç€æ‚¨å¯ä»¥åœ¨Rust ä¸­ç¼–å†™æ–°çš„æ“ä½œç³»ç»ŸæœåŠ¡ï¼Œä»¥åŠæ‰©å±•ç°æœ‰æœåŠ¡ã€‚</p>
<blockquote>
<p>ä»Šå¤©æˆ‘ä»¬ä¼šå°è¯•åœ¨ä½ è‡ªå·±çš„é¡¹ç›®ä¸­è°ƒç”¨Rustã€‚ æ‰€ä»¥è¯•ç€åœ¨ä½ çš„ä»£ç ä¸­æ‰¾ä¸€å°æ®µæ¥æ”¹æˆRustã€‚ ä»£ç ä¸­è¶Šå°‘ä¾èµ–(dependencies)ï¼Œè¶Šå°‘â€œç‹¬ç‰¹â€çš„ç±»å‹ï¼Œè¶Šå¥½ã€‚æ¯”å¦‚ ä¸€æ®µè§£æåŸå§‹å­—ç¬¦çš„ä»£ç å°±å¾ˆç†æƒ³ã€‚</p>
</blockquote>
<h1><a class="header" href="#è®¾ç½®" id="è®¾ç½®">è®¾ç½®</a></h1>
<p>æˆ‘ä»¬å°†ä¼šä½¿ç”¨Android è™šæ‹Ÿè®¾å¤‡ï¼ˆAndroid Virtual Deviceï¼‰æ¥æµ‹è¯•æˆ‘ä»¬çš„ä»£ç ã€‚ ç¡®ä¿ä½ æœ‰æƒé™è®¿é—®ä¸€ä¸ªï¼Œæˆ–è€…ç”¨ä»¥ä¸‹å‘½ä»¤åˆ›å»ºä¸€ä¸ªæ–°çš„ï¼š</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-userdebug
acloud create
</code></pre>
<p>æ›´å¤šç»†èŠ‚è¯·å‚è€ƒ <a href="https://source.android.com/docs/setup/start">Android Developer Codelab</a>.</p>
<h1><a class="header" href="#æ„å»ºè§„åˆ™" id="æ„å»ºè§„åˆ™">æ„å»ºè§„åˆ™</a></h1>
<p>Android æ„å»ºç³»ç»Ÿï¼ˆSoongï¼‰é€šè¿‡ä¸€ç³»åˆ—æ¨¡å—æ¥æ”¯æŒRustï¼š</p>
<table><thead><tr><th>Module Type</th><th>æè¿°</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>ç”Ÿæˆä¸€ä¸ªRustäºŒè¿›åˆ¶æ–‡ä»¶ã€‚</td></tr>
<tr><td><code>rust_library</code></td><td>ç”Ÿæˆä¸€ä¸ª Rust åº“ï¼Œå¹¶æä¾› <code>rlib</code> å’Œ <code>dylib</code> ä¸¤ç§å˜ä½“ã€‚</td></tr>
<tr><td><code>rust_ffi</code></td><td>ç”Ÿæˆä¸€ä¸ªå¯ç”± <code>cc</code> æ¨¡å—ä½¿ç”¨çš„ Rust C åº“ï¼Œå¹¶æä¾›é™æ€å’Œå…±äº«ä¸¤ç§å˜ä½“ã€‚</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>Produces a <code>proc-macro</code> Rust library. These are analogous to compiler plugins.</td></tr>
<tr><td><code>rust_test</code></td><td>ç”Ÿæˆä½¿ç”¨æ ‡å‡† Rust æµ‹è¯•æ¡†æ¶çš„ Rust æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</td></tr>
<tr><td><code>rust_fuzz</code></td><td>Produces a Rust fuzz binary leveraging <code>libfuzzer</code>.</td></tr>
<tr><td><code>rust_protobuf</code></td><td>ç”Ÿæˆæºä»£ç å¹¶ç”Ÿæˆä¸ºç‰¹å®š protobuf æä¾›æ¥å£çš„ Rust åº“ã€‚</td></tr>
<tr><td><code>rust_bindgen</code></td><td>ç”Ÿæˆæºä»£ç å¹¶ç”ŸæˆåŒ…å« Rust ç»‘å®šåˆ° C åº“çš„ Rust åº“ã€‚</td></tr>
</tbody></table>
<p>ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ <code>rust_binary</code> å’Œ <code>rust_library</code>ã€‚</p>
<h1><a class="header" href="#rust-äºŒè¿›åˆ¶æ–‡ä»¶-1" id="rust-äºŒè¿›åˆ¶æ–‡ä»¶-1">Rust äºŒè¿›åˆ¶æ–‡ä»¶</a></h1>
<p>è®©æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•çš„åº”ç”¨ç¨‹åºå¼€å§‹ã€‚åœ¨ AOSP ç­¾å‡ºçš„æ ¹ç›®å½•ä¸‹ï¼Œåˆ›å»ºä»¥ä¸‹æ–‡ä»¶ï¼š</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust&quot;,
    crate_name: &quot;hello_rust&quot;,
    srcs: [&quot;src/main.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;Hello from Rust!&quot;);
}
</code></pre></pre>
<p>ä½ ç°åœ¨å¯ä»¥æ„å»ºã€æ¨é€å’Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">m hello_rust
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<h1><a class="header" href="#rust-åº“" id="rust-åº“">Rust åº“</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <code>rust_library</code> ä¸º Android åˆ›å»ºä¸€ä¸ªæ–°çš„ Rust åº“ã€‚</p>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å£°æ˜äº†å¯¹ä¸¤ä¸ªåº“çš„ä¾èµ–ï¼š</p>
<ul>
<li><code>libgreeting</code>, æˆ‘ä»¬åœ¨ä¸‹é¢è¿›è¡Œäº†å®šä¹‰ï¼Œ</li>
<li><code>libtextwrap</code>, ä¸€ä¸ªå·²ç»åœ¨ <a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a> ä¸­æä¾›çš„ crateã€‚</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_with_dep&quot;,
    crate_name: &quot;hello_rust_with_dep&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libgreetings&quot;,
        &quot;libtextwrap&quot;,
    ],
    prefer_rlib: true,
}

rust_library {
    name: &quot;libgreetings&quot;,
    crate_name: &quot;greetings&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;{}&quot;, fill(&amp;greeting(&quot;Bob&quot;), 24));
}
</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}, it is very nice to meet you!&quot;)
}
</code></pre>
<p>æ‚¨å¯ä»¥åƒä¹‹å‰ä¸€æ ·æ„å»ºã€æ¨é€å’Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<h1><a class="header" href="#aidl" id="aidl">AIDL</a></h1>
<p>Rust æ”¯æŒ <a href="https://developer.android.com/guide/components/aidl">Android æ¥å£å®šä¹‰è¯­è¨€ (AIDL)</a>ï¼š</p>
<ul>
<li>Rust ä»£ç å¯ä»¥è°ƒç”¨ç°æœ‰çš„ AIDL æœåŠ¡å™¨ï¼Œ</li>
<li>æ‚¨å¯ä»¥åœ¨ Rust ä¸­åˆ›å»ºæ–°çš„ AIDL æœåŠ¡å™¨ã€‚</li>
</ul>
<h1><a class="header" href="#aidl-æ¥å£" id="aidl-æ¥å£">AIDL æ¥å£</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ AIDL æ¥å£å£°æ˜æ‚¨çš„æœåŠ¡çš„ APIï¼š</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: &quot;com.example.birthdayservice&quot;,
    srcs: [&quot;com/example/birthdayservice/*.aidl&quot;],
    unstable: true,
    backend: {
        rust: { // é»˜è®¤æƒ…å†µä¸‹ä¸å¯ç”¨ Rust 
            enabled: true,
        },
    },
}
</code></pre>
<p>å¦‚æœä¾›åº”å•†åˆ†åŒºä¸­çš„äºŒè¿›åˆ¶æ–‡ä»¶ä½¿ç”¨äº†æ‚¨çš„ AIDL æ–‡ä»¶ï¼Œè¯·æ·»åŠ  <code>vendor_available: true</code>ã€‚</p>
<h1><a class="header" href="#æœåŠ¡å®ç°" id="æœåŠ¡å®ç°">æœåŠ¡å®ç°</a></h1>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥å®ç°AIDLæœåŠ¡ï¼š</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! å®ç°äº† `IBirthdayService` AIDL æ¥å£ã€‚
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// `IBirthdayService` æ¥å£çš„å…·ä½“å®ç°ã€‚
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!(
            &quot;Happy Birthday {name}, congratulations with the {years} years!&quot;
        ))
    }
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libbirthdayservice&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    crate_name: &quot;birthdayservice&quot;,
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
}
</code></pre>
<h1><a class="header" href="#aidl-æœåŠ¡å™¨" id="aidl-æœåŠ¡å™¨">AIDL æœåŠ¡å™¨</a></h1>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæš´éœ²æœåŠ¡çš„æœåŠ¡å™¨ï¼š</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! ç”Ÿæ—¥æœåŠ¡ã€‚
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// ç”Ÿæ—¥æœåŠ¡çš„å…¥å£ã€‚
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect(&quot;Failed to register service&quot;);
    binder::ProcessState::join_thread_pool()
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_server&quot;,
    crate_name: &quot;birthday_server&quot;,
    srcs: [&quot;src/server.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
        &quot;libbirthdayservice&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<h1><a class="header" href="#éƒ¨ç½²" id="éƒ¨ç½²">éƒ¨ç½²</a></h1>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥æ„å»ºã€æ¨é€å’Œå¯åŠ¨æœåŠ¡ï¼š</p>
<pre><code class="language-shell">m birthday_server
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_server /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>åœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­ï¼Œæ£€æŸ¥è¯¥æœåŠ¡æ˜¯å¦æ­£åœ¨è¿è¡Œï¼š</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>æ‚¨è¿˜å¯ä»¥ä½¿ç”¨ <code>service call</code> å‘½ä»¤è°ƒç”¨è¯¥æœåŠ¡ï¼š</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<h1><a class="header" href="#aidl-å®¢æˆ·ç«¯" id="aidl-å®¢æˆ·ç«¯">AIDL å®¢æˆ·ç«¯</a></h1>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬çš„æ–°æœåŠ¡åˆ›å»ºä¸€ä¸ª Rust å®¢æˆ·ç«¯ã€‚</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">//! ç”Ÿæ—¥æœåŠ¡ã€‚
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// è¿æ¥åˆ° BirthdayServiceã€‚
pub fn connect() -&gt; Result&lt;binder::Strong&lt;dyn IBirthdayService&gt;, binder::StatusCode&gt; {
    binder::get_interface(SERVICE_IDENTIFIER)
}

/// è°ƒç”¨ç”Ÿæ—¥æœåŠ¡ã€‚
fn main() -&gt; Result&lt;(), binder::Status&gt; {
    let name = std::env::args()
        .nth(1)
        .unwrap_or_else(|| String::from(&quot;Bob&quot;));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!(&quot;{msg}&quot;);
    Ok(())
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_client&quot;,
    crate_name: &quot;birthday_client&quot;,
    srcs: [&quot;src/client.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
    prefer_rlib: true,
}
</code></pre>
<p>è¯·æ³¨æ„ï¼Œå®¢æˆ·ç«¯ä¸ä¾èµ–äº <code>libbirthdayservice</code>ã€‚</p>
<p>åœ¨æ‚¨çš„è®¾å¤‡ä¸Šæ„å»ºã€æ¨é€å¹¶è¿è¡Œå®¢æˆ·ç«¯ï¼š</p>
<pre><code class="language-shell">m birthday_client
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_client /data/local/tmp&quot;
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<h1><a class="header" href="#æ›´æ”¹-api" id="æ›´æ”¹-api">æ›´æ”¹ API</a></h1>
<p>è®©æˆ‘ä»¬æ‰©å±•APIä»¥æä¾›æ›´å¤šåŠŸèƒ½ï¼šæˆ‘ä»¬å¸Œæœ›å…è®¸å®¢æˆ·ç«¯æŒ‡å®šç”Ÿæ—¥è´ºå¡çš„è¡Œåˆ—è¡¨ï¼š</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<h1><a class="header" href="#æ—¥å¿—è®°å½•" id="æ—¥å¿—è®°å½•">æ—¥å¿—è®°å½•</a></h1>
<p>ä½ åº”è¯¥ä½¿ç”¨ <code>log</code> crate æ¥è‡ªåŠ¨è®°å½•æ—¥å¿—åˆ° <code>logcat</code> ï¼ˆè®¾å¤‡ä¸Šï¼‰æˆ– <code>stdout</code>ï¼ˆä¸»æœºä¸Šï¼‰ï¼š</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_logs&quot;,
    crate_name: &quot;hello_rust_logs&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;liblog_rust&quot;,
        &quot;liblogger&quot;,
    ],
    prefer_rlib: true,
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device(&quot;rust&quot;)
            .with_min_level(log::Level::Trace),
    );
    debug!(&quot;Starting program.&quot;);
    info!(&quot;Things are going fine.&quot;);
    error!(&quot;Something went wrong!&quot;);
}
</code></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m hello_rust_logs
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs /data/local/tmp&quot;
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>æ—¥å¿—å°†ä¼šåœ¨ <code>adb logcat</code> ä¸­æ˜¾ç¤ºï¼š</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<h1><a class="header" href="#äº’æ“ä½œæ€§" id="äº’æ“ä½œæ€§">äº’æ“ä½œæ€§</a></h1>
<p>Rust has excellent support for interoperability with other languages. This means that you can:</p>
<ul>
<li>Call Rust functions from other languages.</li>
<li>Call functions written in other languages from Rust.</li>
</ul>
<p>When you call functions in a foreign language we say that youâ€™re using a <em>foreign function interface</em>, also known as FFI.</p>
<h1><a class="header" href="#interoperability-with-c" id="interoperability-with-c">Interoperability with C</a></h1>
<p>Rust has full support for linking object files with a C calling convention. Similarly, you can export Rust functions and call them from C.</p>
<p>You can do it by hand if you want:</p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    let abs_x = unsafe { abs(x) };
    println!(&quot;{x}, {abs_x}&quot;);
}
</code></pre></pre>
<p>We already saw this in the <a href="android/interoperability/../../exercises/day-3/safe-ffi-wrapper.html">Safe FFI Wrapper exercise</a>.</p>
<blockquote>
<p>This assumes full knowledge of the target platform. Not recommended for production.</p>
</blockquote>
<p>We will look at better options next.</p>
<h1><a class="header" href="#using-bindgen" id="using-bindgen">Using Bindgen</a></h1>
<p>The <a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> tool can auto-generate bindings from a C header file.</p>
<p>First create a small C library:</p>
<p><em>interoperability/bindgen/libbirthday.h</em>:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;libbirthday.h&quot;

void print_card(const card* card) {
  printf(&quot;+--------------\n&quot;);
  printf(&quot;| Happy Birthday %s!\n&quot;, card-&gt;name);
  printf(&quot;| Congratulations with the %i years!\n&quot;, card-&gt;years);
  printf(&quot;+--------------\n&quot;);
}
</code></pre>
<p>Add this to your <code>Android.bp</code> file:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: &quot;libbirthday&quot;,
    srcs: [&quot;libbirthday.c&quot;],
}
</code></pre>
<p>Create a wrapper header file for the library (not strictly needed in this example):</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include &quot;libbirthday.h&quot;
</code></pre>
<p>You can now auto-generate the bindings:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: &quot;libbirthday_bindgen&quot;,
    crate_name: &quot;birthday_bindgen&quot;,
    wrapper_src: &quot;libbirthday_wrapper.h&quot;,
    source_stem: &quot;bindings&quot;,
    static_libs: [&quot;libbirthday&quot;],
}
</code></pre>
<p>Finally, we can use the bindings in our Rust program:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;print_birthday_card&quot;,
    srcs: [&quot;main.rs&quot;],
    rustlibs: [&quot;libbirthday_bindgen&quot;],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new(&quot;Peter&quot;).unwrap();
    let card = card {
        name: name.as_ptr(),
        years: 42,
    };
    unsafe {
        print_card(&amp;card as *const card);
    }
}
</code></pre></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m print_birthday_card
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card /data/local/tmp&quot;
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>Finally, we can run auto-generated tests to ensure the bindings work:</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: &quot;libbirthday_bindgen_test&quot;,
    srcs: [&quot;:libbirthday_bindgen&quot;],
    crate_name: &quot;libbirthday_bindgen_test&quot;,
    test_suites: [&quot;general-tests&quot;],
    auto_gen_config: true,
    clippy_lints: &quot;none&quot;, // Generated file, skip linting
    lints: &quot;none&quot;,
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<h1><a class="header" href="#calling-rust" id="calling-rust">Calling Rust</a></h1>
<p>Exporting Rust functions and types to C is easy:</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
#[no_mangle]
pub extern &quot;C&quot; fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!(&quot;x ({x}) is smallest!&quot;);
    } else {
        println!(&quot;y ({y}) is probably larger than x ({x})&quot;);
    }
}
</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

extern &quot;C&quot; {
void analyze_numbers(int x, int y);
}

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: &quot;libanalyze_ffi&quot;,
    crate_name: &quot;analyze_ffi&quot;,
    srcs: [&quot;analyze.rs&quot;],
    include_dirs: [&quot;.&quot;],
}
</code></pre>
<p>We can now call this from a C binary:</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include &quot;analyze.h&quot;

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: &quot;analyze_numbers&quot;,
    srcs: [&quot;main.c&quot;],
    static_libs: [&quot;libanalyze_ffi&quot;],
}
</code></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m analyze_numbers
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers /data/local/tmp&quot;
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[no_mangle]</code> disables Rustâ€™s usual name mangling, so the exported symbol will just be the name of the function. You can also use <code>#[export_name = &quot;some_name&quot;]</code> to specify whatever name you want.</p>
</details><h1><a class="header" href="#ä¸-c-äº¤äº’" id="ä¸-c-äº¤äº’">ä¸ C++ äº¤äº’</a></h1>
<p>The <a href="https://cxx.rs/">CXX crate</a> makes it possible to do safe interoperability between Rust and C++.</p>
<p>The overall approach looks like this:</p>
<img src="android/interoperability/cpp/overview.svg">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for an full example of using this.</p>
<details>
<ul>
<li>
<p>At this point, the instructor should switch to the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a>.</p>
</li>
<li>
<p>Walk the students through the tutorial step by step.</p>
</li>
<li>
<p>Highlight how CXX presents a clean interface without unsafe code in <em>both languages</em>.</p>
</li>
<li>
<p>Show the correspondence between <a href="https://cxx.rs/bindings.html">Rust and C++ types</a>:</p>
<ul>
<li>
<p>Explain how a Rust <code>String</code> cannot map to a C++ <code>std::string</code> (the latter does not uphold the UTF-8 invariant). Show that despite being different types, <code>rust::String</code> in C++ can be easily constructed from a C++ <code>std::string</code>, making it very ergonomic to use.</p>
</li>
<li>
<p>Explain that a Rust function returning <code>Result&lt;T, E&gt;</code> becomes a function which throws a <code>E</code> exception in C++ (and vice versa).</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#interoperability-with-java" id="interoperability-with-java">Interoperability with Java</a></h1>
<p>Java can load shared objects via <a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface (JNI)</a>. The <a href="https://docs.rs/jni/"><code>jni</code> crate</a> allows you to create a compatible library.</p>
<p>First, we create a Rust function to export to Java:</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
#[no_mangle]
pub extern &quot;system&quot; fn Java_HelloWorld_hello(
    env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(name).unwrap().into();
    let greeting = format!(&quot;Hello, {input}!&quot;);
    let output = env.new_string(greeting).unwrap();
    output.into_inner()
}
<span class="boring">}
</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: &quot;libhello_jni&quot;,
    crate_name: &quot;hello_jni&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    rustlibs: [&quot;libjni&quot;],
}
</code></pre>
<p>Finally, we can call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary(&quot;hello_jni&quot;);
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;Alice&quot;);
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: &quot;helloworld_jni&quot;,
    srcs: [&quot;HelloWorld.java&quot;],
    main_class: &quot;HelloWorld&quot;,
    required: [&quot;libhello_jni&quot;],
}
</code></pre>
<p>Finally, you can build, sync, and run the binary:</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<h1><a class="header" href="#ä¹ é¢˜" id="ä¹ é¢˜">ä¹ é¢˜</a></h1>
<p>This is a group exercise: We will look at one of the projects you work with and try to integrate some Rust into it. Some suggestions:</p>
<ul>
<li>
<p>Call your AIDL service with a client written in Rust.</p>
</li>
<li>
<p>Move a function from your project to Rust and call it.</p>
</li>
</ul>
<details>
<p>No solution is provided here since this is open-ended: it relies on someone in the class having a piece of code which you can turn in to Rust on the fly.</p>
</details><h1><a class="header" href="#welcome-to-bare-metal-rust" id="welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>This is a standalone one-day course about bare-metal Rust, aimed at people who are familiar with the basics of Rust (perhaps from completing the Comprehensive Rust course), and ideally also have some experience with bare-metal programming in some other language such as C.</p>
<p>Today we will talk about â€˜bare-metalâ€™ Rust: running Rust code without an OS underneath us. This will be divided into several parts:</p>
<ul>
<li>What is <code>no_std</code> Rust?</li>
<li>Writing firmware for microcontrollers.</li>
<li>Writing bootloader / kernel code for application processors.</li>
<li>Some useful crates for bare-metal Rust development.</li>
</ul>
<p>For the microcontroller part of the course we will use the <a href="https://microbit.org/">BBC micro:bit</a> v2 as an example. Itâ€™s a <a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic nRF51822 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, and an on-board SWD debugger.</p>
<p>To get started, install some tools weâ€™ll need later. On gLinux or Debian:</p>
<pre><code class="language-bash">sudo apt install gcc-aarch64-linux-gnu gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<p>And give users in the <code>plugdev</code> group access to the micro:bit programmer:</p>
<pre><code class="language-bash">echo 'SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0d28&quot;, MODE=&quot;0664&quot;, GROUP=&quot;plugdev&quot;' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>On MacOS:</p>
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
brew install --cask gcc-aarch64-embedded
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils cargo-embed
</code></pre>
<h1><a class="header" href="#no_std" id="no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Slices, <code>&amp;str</code>, <code>CStr</code></li>
<li><code>NonZeroU8</code>...</li>
<li><code>Option</code>, <code>Result</code></li>
<li><code>Display</code>, <code>Debug</code>, <code>write!</code>...</li>
<li><code>Iterator</code></li>
<li><code>panic!</code>, <code>assert_eq!</code>...</li>
<li><code>NonNull</code> and all the usual pointer-related functions</li>
<li><code>Future</code> and <code>async</code>/<code>await</code></li>
<li><code>fence</code>, <code>AtomicBool</code>, <code>AtomicPtr</code>, <code>AtomicU32</code>...</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>, <code>Cow</code>, <code>Arc</code>, <code>Rc</code></li>
<li><code>Vec</code>, <code>BinaryHeap</code>, <code>BtreeMap</code>, <code>LinkedList</code>, <code>VecDeque</code></li>
<li><code>String</code>, <code>CString</code>, <code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Error</code></li>
<li><code>HashMap</code></li>
<li><code>Mutex</code>, <code>Condvar</code>, <code>Barrier</code>, <code>Once</code>, <code>RwLock</code>, <code>mpsc</code></li>
<li><code>File</code> and the rest of <code>fs</code></li>
<li><code>println!</code>, <code>Read</code>, <code>Write</code>, <code>Stdin</code>, <code>Stdout</code> and the rest of <code>io</code></li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>, <code>Child</code>, <code>ExitCode</code></li>
<li><code>spawn</code>, <code>sleep</code> and the rest of <code>thread</code></li>
<li><code>SystemTime</code>, <code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> depends on RNG.</li>
<li><code>std</code> re-exports the contents of both <code>core</code> and <code>alloc</code>.</li>
</ul>
</details><h1><a class="header" href="#a-minimal-no_std-program" id="a-minimal-no_std-program">A minimal <code>no_std</code> program</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>This will compile to an empty binary.</li>
<li><code>std</code> provides a panic handler; without it we must provide our own.</li>
<li>It can also be provided by another crate, such as <code>panic-halt</code>.</li>
<li>Depending on the target, you may need to compile with <code>panic = &quot;abort&quot;</code> to avoid an error about <code>eh_personality</code>.</li>
<li>Note that there is no <code>main</code> or any other entry point; itâ€™s up to you to define your own entry point. This will typically involve a linker script and some assembly code to set things up ready for Rust code to run.</li>
</ul>
</details><h1><a class="header" href="#alloc" id="alloc"><code>alloc</code></a></h1>
<p>To use <code>alloc</code> you must implement a <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">global (heap) allocator</a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // Safe because `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR
            .lock()
            .init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push(&quot;A string&quot;.to_string());
}
</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> is a third-party crate implementing a basic buddy system allocator. Other crates are available, or you can write your own or hook into your existing allocator.</li>
<li>The const parameter of <code>LockedHeap</code> is the max order of the allocator; i.e. in this case it can allocate regions of up to 2**32 bytes.</li>
<li>If any crate in your dependency tree depends on <code>alloc</code> then you must have exactly one global allocator defined in your binary. Usually this is done in the top-level binary crate.</li>
<li><code>extern crate panic_halt as _</code> is necessary to ensure that the <code>panic_halt</code> crate is linked in so we get its panic handler.</li>
<li>This example will build but not run, as it doesnâ€™t have an entry point.</li>
</ul>
</details><h1><a class="header" href="#å¾®æ§åˆ¶å™¨" id="å¾®æ§åˆ¶å™¨">å¾®æ§åˆ¶å™¨</a></h1>
<p>The <code>cortex_m_rt</code> crate provides (among other things) a reset handler for Cortex M microcontrollers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}
</code></pre></pre>
<p>Next weâ€™ll look at how to access peripherals, with increasing levels of abstraction.</p>
<details>
<ul>
<li>The <code>cortex_m_rt::entry</code> macro requires that the function have type <code>fn() -&gt; !</code>, because returning to the reset handler doesnâ€™t make sense.</li>
<li>Run the example with <code>cargo embed --bin minimal</code></li>
</ul>
</details><h1><a class="header" href="#åŸå§‹-mmio" id="åŸå§‹-mmio">åŸå§‹ MMIO</a></h1>
<p>Most microcontrollers access peripherals via memory-mapped IO. Letâ€™s try turning on an LED on our micro:bit:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT | INPUT_DISCONNECT | PULL_DISABLED | DRIVE_S0S1 | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // Safe because the pointers are to valid peripheral control registers, and
    // no aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>GPIO 0 pin 21 is connected to the first column of the LED matrix, and pin 28 to the first row.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details><h1><a class="header" href="#peripheral-access-crates" id="peripheral-access-crates">Peripheral Access Crates</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> generates mostly-safe Rust wrappers for memory-mapped peripherals from <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> files.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>SVD (System View Description) files are XML files typically provided by silicon vendors which describe the memory map of the device.
<ul>
<li>They are organised by peripheral, register, field and value, with names, descriptions, addresses and so on.</li>
<li>SVD files are often buggy and incomplete, so there are various projects which patch the mistakes, add missing details, and publish the generated crates.</li>
</ul>
</li>
<li><code>cortex-m-rt</code> provides the vector table, among other things.</li>
<li>If you <code>cargo install cargo-binutils</code> then you can run <code>cargo objdump --bin pac -- -d --no-show-raw-insn</code> to see the resulting binary.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details><h1><a class="header" href="#hal-crates" id="hal-crates">HAL crates</a></h1>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crates</a> for many microcontrollers provide wrappers around various peripherals. These generally implement traits from <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a>.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;
use nrf52833_hal::prelude::*;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> and <code>set_high</code> are methods on the <code>embedded_hal</code> <code>OutputPin</code> trait.</li>
<li>HAL crates exist for many Cortex-M and RISC-V devices, including various STM32, GD32, nRF, NXP, MSP430, AVR and PIC microcontrollers.</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details><h1><a class="header" href="#board-support-crates" id="board-support-crates">Board support crates</a></h1>
<p>Board support crates provide a further level of wrapping for a specific board for convenience.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use microbit::hal::prelude::*;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>In this case the board support crate is just providing more useful names, and a bit of initialisation.</li>
<li>The crate may also include drivers for some on-board devices outside of the microcontroller itself.
<ul>
<li><code>microbit-v2</code> includes a simple driver for the LED matrix.</li>
</ul>
</li>
</ul>
<p>Run the example with:</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details><h1><a class="header" href="#the-type-state-pattern" id="the-type-state-pattern">The type state pattern</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; = gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>Pins donâ€™t implement <code>Copy</code> or <code>Clone</code>, so only one instance of each can exist. Once a pin is moved out of the port struct nobody else can take it.</li>
<li>Changing the configuration of a pin consumes the old pin instance, so you canâ€™t keep use the old instance afterwards.</li>
<li>The type of a value indicates the state that it is in: e.g. in this case, the configuration state of a GPIO pin. This encodes the state machine into the type system, and ensures that you donâ€™t try to use a pin in a certain way without properly configuring it first. Illegal state transitions are caught at compile time.</li>
<li>You can call <code>is_high</code> on an input pin and <code>set_high</code> on an output pin, but not vice-versa.</li>
<li>Many HAL crates follow this pattern.</li>
</ul>
</details><h1><a class="header" href="#embedded-hal" id="embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits covering common microcontroller peripherals.</p>
<ul>
<li>GPIO</li>
<li>ADC</li>
<li>I2C, SPI, UART, CAN</li>
<li>RNG</li>
<li>Timers</li>
<li>Watchdogs</li>
</ul>
<p>Other crates then implement <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these traits, e.g. an accelerometer driver might need an I2C or SPI bus implementation.</p>
<details>
<ul>
<li>There are implementations for many microcontrollers, as well as other platforms such as Linux on Raspberry Pi.</li>
<li>There is work in progress on an <code>async</code> version of <code>embedded-hal</code>, but it isnâ€™t stable yet.</li>
</ul>
</details><h1><a class="header" href="#probe-rs-cargo-embed" id="probe-rs-cargo-embed"><code>probe-rs</code>, <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> is a handy toolset for embedded debugging, like OpenOCD but better integrated.</p>
<ul>
<li>SWD (Serial Wire Debug) and JTAG via CMSIS-DAP, ST-Link and J-Link probes</li>
<li>GDB stub and Microsoft DAP (Debug Adapter Protocol) server</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> is a cargo subcommand to build and flash binaries, log RTT (Real Time Transfers) output and connect GDB. Itâ€™s configured by an <code>Embed.toml</code> file in your project directory.</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> is an Arm standard protocol over USB for an in-circuit debugger to access the CoreSight Debug Access Port of various Arm Cortex processors. Itâ€™s what the on-board debugger on the BBC micro:bit uses.</li>
<li>ST-Link is a range of in-circuit debuggers from ST Microelectronics, J-Link is a range from SEGGER.</li>
<li>The Debug Access Port is usually either a 5-pin JTAG interface or 2-pin Serial Wire Debug.</li>
<li>probe-rs is a library which you can integrate into your own tools if you want to.</li>
<li>The <a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft Debug Adapter Protocol</a> lets VSCode and other IDEs debug code running on any supported microcontroller.</li>
<li>cargo-embed is a binary built using the probe-rs library.</li>
<li>RTT (Real Time Transfers) is a mechanism to transfer data between the debug host and the target through a number of ringbuffers.</li>
</ul>
</details><h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p><em>Embed.toml</em>:</p>
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true
</code></pre>
<p>In one terminal under <code>src/bare-metal/microcontrollers/examples/</code>:</p>
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>In another terminal in the same directory:</p>
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<details>
<p>In GDB, try running:</p>
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details><h1><a class="header" href="#other-projects" id="other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>â€œReal-Time Interrupt-driven Concurrencyâ€</li>
<li>Shared resource management, message passing, task scheduling, timer queue</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit support</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, IPC</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a></li>
<li>Some platforms have <code>std</code> implementations, e.g. <a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>.</li>
</ul>
<details>
<ul>
<li>RTIC can be considered either an RTOS or a concurrency framework.
<ul>
<li>It doesnâ€™t include any HALs.</li>
<li>It uses the Cortex-M NVIC (Nested Virtual Interrupt Controller) for scheduling rather than a proper kernel.</li>
<li>Cortex-M only.</li>
</ul>
</li>
<li>Google uses TockOS on the Haven microcontroller for Titan security keys.</li>
<li>FreeRTOS is mostly written in C, but there are Rust bindings for writing applications.</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-1" id="ä¹ é¢˜-1">ä¹ é¢˜</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#ç½—ç›˜" id="ç½—ç›˜">ç½—ç›˜</a></h1>
<p>We will read the direction from an I2C compass, and log the readings to a serial port. If you have time, try displaying it on the LEDs somehow too, or use the buttons somehow.</p>
<p>Hints:</p>
<ul>
<li>Check the documentation for the <a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> and <a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crates, as well as the <a href="https://tech.microbit.org/hardware/">micro:bit hardware</a>.</li>
<li>The LSM303AGR Inertial Measurement Unit is connected to the internal I2C bus.</li>
<li>TWI is another name for I2C, so the I2C master peripheral is called TWIM.</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::blocking::i2c::WriteRead</code> trait. The <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a> struct implements this.</li>
<li>You have a <a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a> struct with fields for the various pins and peripherals.</li>
<li>You can also look at the <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 datasheet</a> if you want, but it shouldnâ€™t be necessary for this exercise.</li>
</ul>
<p>Download the <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>compass</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::uarte::{Baudrate, Parity, Uarte}, Board};

#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}
</code></pre></pre>
<p><em>Cargo.toml</em> (you shouldnâ€™t need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;compass&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
cortex-m-rt = &quot;0.7.3&quot;
embedded-hal = &quot;0.2.6&quot;
lsm303agr = &quot;0.2.2&quot;
microbit-v2 = &quot;0.13.0&quot;
panic-halt = &quot;0.2.0&quot;
</code></pre>
<p><em>Embed.toml</em> (you shouldnâ€™t need to change this):</p>
<!-- File Embed.toml -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldnâ€™t need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]
</code></pre>
<p>See the serial output on Linux with:</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>Or on Mac OS something like (the device name may be slightly different):</p>
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>Use Ctrl+A Ctrl+Q to quit picocom.</p>
<h1><a class="header" href="#application-processors" id="application-processors">Application processors</a></h1>
<p>So far weâ€™ve talked about microcontrollers, such as the Arm Cortex-M series. Now letâ€™s try writing something for Cortex-A. For simplicity weâ€™ll just work with QEMUâ€™s aarch64 <a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html">â€˜virtâ€™</a> board.</p>
<details>
<ul>
<li>Broadly speaking, microcontrollers donâ€™t have an MMU or multiple levels of privilege (exception levels on Arm CPUs, rings on x86), while application processors do.</li>
<li>QEMU supports emulating various different machines or board models for each architecture. The â€˜virtâ€™ board doesnâ€™t correspond to any particular real hardware, but is designed purely for virtual machines.</li>
</ul>
</details><h1><a class="header" href="#å‡†å¤‡ä½¿ç”¨-rust" id="å‡†å¤‡ä½¿ç”¨-rust">å‡†å¤‡ä½¿ç”¨ Rust</a></h1>
<p>Before we can start running Rust code, we need to do some initialisation.</p>
<pre><code class="language-armasm">.section .init.entry, &quot;ax&quot;
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to enable MMU and
     * caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then invalidate any
     * potentially stale local TLB entries before they start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed until this
     * has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>This is the same as it would be for C: initialising the processor state, zeroing the BSS, and setting up the stack pointer.
<ul>
<li>The BSS (block starting symbol, for historical reasons) is the part of the object file which containing statically allocated variables which are initialised to zero. They are omitted from the image, to avoid wasting space on zeroes. The compiler assumes that the loader will take care of zeroing them.</li>
</ul>
</li>
<li>The BSS may already be zeroed, depending on how memory is initialised and the image is loaded, but we zero it to be sure.</li>
<li>We need to enable the MMU and cache before reading or writing any memory. If we donâ€™t:
<ul>
<li>Unaligned accesses will fault. We build the Rust code for the <code>aarch64-unknown-none</code> target which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses, so it should be fine in this case, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM is accessing memory directly with the cache disabled, while the host has cacheable aliases to the same memory. Even if the host doesnâ€™t explicitly access the memory, speculative accesses can lead to cache fills, and then changes from one or the other will get lost when the cache is cleaned or the VM enables the cache. (Cache is keyed by physical address, not VA or IPA.)</li>
</ul>
</li>
<li>For simplicity, we just use a hardcoded pagetable (see <code>idmap.S</code>) which identity maps the first 1 GiB of address space for devices, the next 1 GiB for DRAM, and another 1 GiB higher up for more devices. This matches the memory layout that QEMU uses.</li>
<li>We also set up the exception vector (<code>vbar_el1</code>), which weâ€™ll see more about later.</li>
<li>All examples this afternoon assume we will be running at exception level 1 (EL1). If you need to run at a different exception level youâ€™ll need to modify <code>entry.S</code> accordingly.</li>
</ul>
</details><h1><a class="header" href="#inline-assembly" id="inline-assembly">Inline assembly</a></h1>
<p>Sometimes we need to use assembly to do things that arenâ€™t possible with Rust code. For example, to make an HVC (hypervisor call) to tell the firmware to power off the system:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

#[no_mangle]
extern &quot;C&quot; fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // Safe because this only uses the declared registers and doesn't do
    // anything with memory.
    unsafe {
        asm!(&quot;hvc #0&quot;,
            inout(&quot;w0&quot;) PSCI_SYSTEM_OFF =&gt; _,
            inout(&quot;w1&quot;) 0 =&gt; _,
            inout(&quot;w2&quot;) 0 =&gt; _,
            inout(&quot;w3&quot;) 0 =&gt; _,
            inout(&quot;w4&quot;) 0 =&gt; _,
            inout(&quot;w5&quot;) 0 =&gt; _,
            inout(&quot;w6&quot;) 0 =&gt; _,
            inout(&quot;w7&quot;) 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}
</code></pre></pre>
<p>(If you actually want to do this, use the <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crate which has wrappers for all these functions.)</p>
<details>
<ul>
<li>PSCI is the Arm Power State Coordination Interface, a standard set of functions to manage system and CPU power states, among other things. It is implemented by EL3 firmware and hypervisors on many systems.</li>
<li>The <code>0 =&gt; _</code> syntax means initialise the register to 0 before running the inline assembly code, and ignore its contents afterwards. We need to use <code>inout</code> rather than <code>in</code> because the call could potentially clobber the contents of the registers.</li>
<li>This <code>main</code> function needs to be <code>#[no_mangle]</code> and <code>extern &quot;C&quot;</code> because it is called from our entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>â€“<code>_x3</code> are the values of registers <code>x0</code>â€“<code>x3</code>, which are conventionally used by the bootloader to pass things like a pointer to the device tree. According to the standard aarch64 calling convention (which is what <code>extern &quot;C&quot;</code> specifies to use), registers <code>x0</code>â€“<code>x7</code> are used for the first 8 arguments passed to a function, so <code>entry.S</code> doesnâ€™t need to do anything special except make sure it doesnâ€™t change these registers.</li>
<li>Run the example in QEMU with <code>make qemu_psci</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#volatile-memory-access-for-mmio" id="volatile-memory-access-for-mmio">Volatile memory access for MMIO</a></h1>
<ul>
<li>Use <code>pointer::read_volatile</code> and <code>pointer::write_volatile</code>.</li>
<li>Never hold a reference.</li>
<li><code>addr_of!</code> lets you get fields of structs without creating an intermediate reference.</li>
</ul>
<details>
<ul>
<li>Volatile access: read or write operations may have side-effects, so prevent the compiler or hardware from reordering, duplicating or eliding them.
<ul>
<li>Usually if you write and then read, e.g. via a mutable reference, the compiler may assume that the value read is the same as the value just written, and not bother actually reading memory.</li>
</ul>
</li>
<li>Some existing crates for volatile access to hardware do hold references, but this is unsound. Whenever a reference exist, the compiler may choose to dereference it.</li>
<li>Use the <code>addr_of!</code> macro to get struct field pointers from a pointer to the struct.</li>
</ul>
</details><h1><a class="header" href="#lets-write-a-uart-driver" id="lets-write-a-uart-driver">Letâ€™s write a UART driver</a></h1>
<p>The QEMU â€˜virtâ€™ machine has a <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UART, so letâ€™s write a driver for that.</p>
<pre><pre class="playground"><code class="language-rust editable">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // Safe because we know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note that <code>Uart::new</code> is unsafe while the other methods are safe. This is because as long as the caller of <code>Uart::new</code> guarantees that its safety requirements are met (i.e. that there is only ever one instance of the driver for a given UART, and nothing else aliasing its address space), then it is always safe to call <code>write_byte</code> later because we can assume the necessary preconditions.</li>
<li>We could have done it the other way around (making <code>new</code> safe but <code>write_byte</code> unsafe), but that would be much less convenient to use as every place that calls <code>write_byte</code> would need to reason about the safety</li>
<li>This is a common pattern for writing safe wrappers of unsafe code: moving the burden of proof for soundness from a large number of places to a smaller number of places.</li>
</ul>
</details><h1><a class="header" href="#more-traits" id="more-traits">More traits</a></h1>
<p>We derived the <code>Debug</code> trait. It would be useful to implement a few more traits too.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
</code></pre></pre>
<details>
<ul>
<li>Implementing <code>Write</code> lets us use the <code>write!</code> and <code>writeln!</code> macros with our <code>Uart</code> type.</li>
<li>Run the example in QEMU with <code>make qemu_minimal</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#a-better-uart-driver" id="a-better-uart-driver">A better UART driver</a></h1>
<p>The PL011 actually has <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">a bunch more registers</a>, and adding offsets to construct pointers to access them is error-prone and hard to read. Plus, some of them are bit fields which would be nice to access in a structured way.</p>
<table><thead><tr><th>Offset</th><th>Register name</th><th>Width</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
<details>
<ul>
<li>There are also some ID registers which have been omitted for brevity.</li>
</ul>
</details><h1><a class="header" href="#bitflags" id="bitflags">Bitflags</a></h1>
<p>The <a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate is useful for working with bitflags.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
</code></pre></pre>
<details>
<ul>
<li>The <code>bitflags!</code> macro creates a newtype something like <code>Flags(u16)</code>, along with a bunch of method implementations to get and set flags.</li>
</ul>
</details><h1><a class="header" href="#multiple-registers" id="multiple-registers">Multiple registers</a></h1>
<p>We can use a struct to represent the memory layout of the UARTâ€™s registers.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a> tells the compiler to lay the struct fields out in order, following the same rules as C. This is necessary for our struct to have a predictable layout, as default Rust representation allows the compiler to (among other things) reorder fields however it sees fit.</li>
</ul>
</details><h1><a class="header" href="#é©±åŠ¨ç¨‹åº" id="é©±åŠ¨ç¨‹åº">é©±åŠ¨ç¨‹åº</a></h1>
<p>Now letâ€™s use the new <code>Registers</code> struct in our driver.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>addr_of!</code> / <code>addr_of_mut!</code> to get pointers to individual fields without creating an intermediate reference, which would be unsound.</li>
</ul>
</details><h1><a class="header" href="#using-it" id="using-it">Using it</a></h1>
<p>Letâ€™s write a small program using our driver to write to the serial console, and echo incoming bytes.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, &quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;).unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; {}
            }
        }
    }

    writeln!(uart, &quot;Bye!&quot;).unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>As in the <a href="bare-metal/aps/better-uart/../inline-assembly.html">inline assembly</a> example, this <code>main</code> function is called from our entry point code in <code>entry.S</code>. See the speaker notes there for details.</li>
<li>Run the example in QEMU with <code>make qemu</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#æ—¥å¿—è®°å½•-1" id="æ—¥å¿—è®°å½•-1">æ—¥å¿—è®°å½•</a></h1>
<p>It would be nice to be able to use the logging macros from the <a href="https://crates.io/crates/log"><code>log</code></a> crate. We can do this by implementing the <code>Log</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>The unwrap in <code>log</code> is safe because we initialise <code>LOGGER</code> before calling <code>set_logger</code>.</li>
</ul>
</details><h1><a class="header" href="#using-it-1" id="using-it-1">Using it</a></h1>
<p>We need to initialise the logger before we use it.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;);

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>Note that our panic handler can now log details of panics.</li>
<li>Run the example in QEMU with <code>make qemu_logger</code> under <code>src/bare-metal/aps/examples</code>.</li>
</ul>
</details><h1><a class="header" href="#exceptions" id="exceptions">Exceptions</a></h1>
<p>AArch64 defines an exception vector table with 16 entries, for 4 types of exceptions (synchronous, IRQ, FIQ, SError) from 4 states (current EL with SP0, current EL with SPx, lower EL using AArch64, lower EL using AArch32). We implement this in assembly to save volatile registers to the stack before calling into Rust code:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    error!(&quot;irq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>EL is exception level; all our examples this afternoon run in EL1.</li>
<li>For simplicity we arenâ€™t distinguishing between SP0 and SPx for the current EL exceptions, or between AArch32 and AArch64 for the lower EL exceptions.</li>
<li>For this example we just log the exception and power down, as we donâ€™t expect any of them to actually happen.</li>
<li>We can think of exception handlers and our main execution context more or less like different threads. <a href="bare-metal/aps/../../concurrency/send-sync.html"><code>Send</code> and <code>Sync</code></a> will control what we can share between them, just like with threads. For example, if we want to share some value between exception handlers and the rest of the program, and itâ€™s <code>Send</code> but not <code>Sync</code>, then weâ€™ll need to wrap it in something like a <code>Mutex</code> and put it in a static.</li>
</ul>
</details><h1><a class="header" href="#other-projects-1" id="other-projects-1">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>â€œcoreboot without the Câ€</li>
<li>Supports x86, aarch64 and RISC-V.</li>
<li>Relies on LinuxBoot rather than having many drivers itself.</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi OS tutorial</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling, page tables</li>
<li>Some dodginess around cache maintenance and initialisation in Rust, not necessarily a good example to copy for production code.</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>Static analysis to determine maximum stack usage.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>The RaspberryPi OS tutorial runs Rust code before the MMU and caches are enabled. This will read and write memory (e.g. the stack). However:
<ul>
<li>Without the MMU and cache, unaligned accesses will fault. It builds with <code>aarch64-unknown-none</code> which sets <code>+strict-align</code> to prevent the compiler generating unaligned accesses so it should be alright, but this is not necessarily the case in general.</li>
<li>If it were running in a VM, this can lead to cache coherency issues. The problem is that the VM is accessing memory directly with the cache disabled, while the host has cacheable aliases to the same memory. Even if the host doesnâ€™t explicitly access the memory, speculative accesses can lead to cache fills, and then changes from one or the other will get lost. Again this is alright in this particular case (running directly on the hardware with no hypervisor), but isnâ€™t a good pattern in general.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#å®ç”¨-crate" id="å®ç”¨-crate">å®ç”¨ crate</a></h1>
<p>Weâ€™ll go over a few crates which solve some common problems in bare-metal programming.</p>
<h1><a class="header" href="#zerocopy" id="zerocopy"><code>zerocopy</code></a></h1>
<p>The <a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crate (from Fuchsia) provides traits and macros for safely converting between byte sequences and other types.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use zerocopy::AsBytes;

#[repr(u32)]
#[derive(AsBytes, Debug, Default)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(AsBytes, Debug, Default)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}
</code></pre></pre>
<p>This is not suitable for MMIO (as it doesnâ€™t use volatile reads and writes), but can be useful for working with structures shared with hardware e.g. by DMA, or sent over some external interface.</p>
<details>
<ul>
<li><code>FromBytes</code> can be implemented for types for which any byte pattern is valid, and so can safely be converted from an untrusted sequence of bytes.</li>
<li>Attempting to derive <code>FromBytes</code> for these types would fail, because <code>RequestType</code> doesnâ€™t use all possible u32 values as discriminants, so not all byte patterns are valid.</li>
<li><code>zerocopy::byteorder</code> has types for byte-order aware numeric primitives.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/zerocopy-example/</code>. (It wonâ€™t run in the Playground because of the crate dependency.)</li>
</ul>
</details><h1><a class="header" href="#aarch64-paging" id="aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>The <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crate lets you create page tables according to the AArch64 Virtual Memory System Architecture.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();
</code></pre></pre>
<details>
<ul>
<li>For now it only supports EL1, but support for other exception levels should be straightforward to add.</li>
<li>This is used in Android for the <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">Protected VM Firmware</a>.</li>
<li>Thereâ€™s no easy way to run this example, as it needs to run on real hardware or under QEMU.</li>
</ul>
</details><h1><a class="header" href="#buddy_system_allocator" id="buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> is a third-party crate implementing a basic buddy system allocator. It can be used both for <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> implementing <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> so you can use the standard <code>alloc</code> crate (as we saw <a href="bare-metal/useful-crates/../alloc.html">before</a>), or for allocating other address space. For example, we might want to allocate MMIO space for PCI BARs:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect(&quot;Failed to allocate 0x100 byte MMIO region&quot;);
    println!(&quot;Allocated 0x100 byte MMIO region at {:#x}&quot;, bar);
}
</code></pre></pre>
<details>
<ul>
<li>PCI BARs always have alignment equal to their size.</li>
<li>Run the example with <code>cargo run</code> under <code>src/bare-metal/useful-crates/allocator-example/</code>. (It wonâ€™t run in the Playground because of the crate dependency.)</li>
</ul>
</details><h1><a class="header" href="#tinyvec" id="tinyvec"><code>tinyvec</code></a></h1>
<p>Sometimes you want something which can be resized like a <code>Vec</code>, but without heap allocation. <a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> provides this: a vector backed by an array or slice, which could be statically allocated or on the stack, which keeps track of how many elements are used and panics if you try to use more than are allocated.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!(&quot;{numbers:?}&quot;);
    numbers.push(7);
    println!(&quot;{numbers:?}&quot;);
    numbers.remove(1);
    println!(&quot;{numbers:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>tinyvec</code> requires that the element type implement <code>Default</code> for initialisation.</li>
<li>The Rust Playground includes <code>tinyvec</code>, so this example will run fine inline.</li>
</ul>
</details><h1><a class="header" href="#spin" id="spin"><code>spin</code></a></h1>
<p><code>std::sync::Mutex</code> and the other synchronisation primitives from <code>std::sync</code> are not available in <code>core</code> or <code>alloc</code>. How can we manage synchronisation or interior mutability, such as for sharing state between different CPUs?</p>
<p>The <a href="https://crates.io/crates/spin"><code>spin</code></a> crate provides spinlock-based equivalents of many of these primitives.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!(&quot;count: {}&quot;, counter.lock());
    *counter.lock() += 2;
    println!(&quot;count: {}&quot;, counter.lock());
}
</code></pre></pre>
<details>
<ul>
<li>Be careful to avoid deadlock if you take locks in interrupt handlers.</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>, <code>Barrier</code> and <code>Once</code> from <code>std::sync</code>;  and <code>Lazy</code> for lazy initialisation.</li>
<li>The <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate also has some useful types for late initialisation with a slightly different approach to <code>spin::once::Once</code>.</li>
<li>The Rust Playground includes <code>spin</code>, so this example will run fine inline.</li>
</ul>
</details><h1><a class="header" href="#android" id="android">Android</a></h1>
<p>To build a bare-metal Rust binary in AOSP, you need to use a <code>rust_ffi_static</code> Soong rule to build your Rust code, then a <code>cc_binary</code> with a linker script to produce the binary itself, and then a <code>raw_binary</code> to convert the ELF to a raw binary ready to be run.</p>
<pre><code class="language-soong">rust_ffi_static {
    name: &quot;libvmbase_example&quot;,
    defaults: [&quot;vmbase_ffi_defaults&quot;],
    crate_name: &quot;vmbase_example&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libvmbase&quot;,
    ],
}

cc_binary {
    name: &quot;vmbase_example&quot;,
    defaults: [&quot;vmbase_elf_defaults&quot;],
    srcs: [
        &quot;idmap.S&quot;,
    ],
    static_libs: [
        &quot;libvmbase_example&quot;,
    ],
    linker_scripts: [
        &quot;image.ld&quot;,
        &quot;:vmbase_sections&quot;,
    ],
}

raw_binary {
    name: &quot;vmbase_example_bin&quot;,
    stem: &quot;vmbase_example.bin&quot;,
    src: &quot;:vmbase_example&quot;,
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<h1><a class="header" href="#vmbase" id="vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/master/vmbase/">vmbase</a> library provides a linker script and useful defaults for the build rules, along with an entry point, UART console logging and more.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The <code>main!</code> macro marks your main function, to be called from the <code>vmbase</code> entry point.</li>
<li>The <code>vmbase</code> entry point handles console initialisation, and issues a PSCI_SYSTEM_OFF to shutdown the VM if your main function returns.</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-2" id="ä¹ é¢˜-2">ä¹ é¢˜</a></h1>
<p>We will write a driver for the PL031 real-time clock device.</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#rtc-driver" id="rtc-driver">RTC driver</a></h1>
<p>The QEMU aarch64 virt machine has a <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> real-time clock at 0x9010000. For this exercise, you should write a driver for it.</p>
<ol>
<li>Use it to print the current time to the serial console. You can use the <a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate for date/time formatting.</li>
<li>Use the match register and raw interrupt status to busy-wait until a given time, e.g. 3 seconds in the future. (Call <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a> inside the loop.)</li>
<li><em>Extension if you have time:</em> Enable and handle the interrupt generated by the RTC match. You can use the driver provided in the <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate to configure the Arm Generic Interrupt Controller.
<ul>
<li>Use the RTC interrupt, which is wired to the GIC as <code>IntId::spi(2)</code>.</li>
<li>Once the interrupt is enabled, you can put the core to sleep via <code>arm_gic::wfi()</code>, which will cause the core to sleep until it receives an interrupt.</li>
</ul>
</li>
</ol>
<p>Download the <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">exercise template</a> and look in the <code>rtc</code> directory for the following files.</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>src/exceptions.rs</em> (you should only need to change this for the 3rd part of the exercise):</p>
<!-- File src/exceptions.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

#[no_mangle]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    trace!(&quot;irq_current&quot;);
    let intid = GicV3::get_and_acknowledge_interrupt().expect(&quot;No pending interrupt&quot;);
    info!(&quot;IRQ {intid:?}&quot;);
}

#[no_mangle]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

#[no_mangle]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/logger.rs</em> (you shouldnâ€™t need to change this):</p>
<!-- File src/logger.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger {
    uart: SpinMutex::new(None),
};

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/pl011.rs</em> (you shouldnâ€™t need to change this):</p>
<!-- File src/pl011.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};
use core::ptr::{addr_of, addr_of_mut};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            addr_of_mut!((*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            let data = unsafe { addr_of!((*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // Safe because we know that self.registers points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}
</span></code></pre></pre>
<p><em>Cargo.toml</em> (you shouldnâ€™t need to change this):</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;rtc&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
arm-gic = &quot;0.1.0&quot;
bitflags = &quot;2.0.0&quot;
chrono = { version = &quot;0.4.24&quot;, default-features = false }
log = &quot;0.4.17&quot;
smccc = &quot;0.1.1&quot;
spin = &quot;0.9.8&quot;

[build-dependencies]
cc = &quot;1.0.73&quot;
</code></pre>
<p><em>build.rs</em> (you shouldnâ€™t need to change this):</p>
<!-- File build.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    #[cfg(target_os = &quot;linux&quot;)]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-linux-gnu&quot;);
    #[cfg(not(target_os = &quot;linux&quot;))]
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-none-elf&quot;);

    Build::new()
        .file(&quot;entry.S&quot;)
        .file(&quot;exceptions.S&quot;)
        .file(&quot;idmap.S&quot;)
        .compile(&quot;empty&quot;)
}
</code></pre></pre>
<p><em>entry.S</em> (you shouldnâ€™t need to change this):</p>
<!-- File entry.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, &quot;ax&quot;
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><em>exceptions.S</em> (you shouldnâ€™t need to change this):</p>
<!-- File exceptions.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, &quot;ax&quot;
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><em>idmap.S</em> (you shouldnâ€™t need to change this):</p>
<!-- File idmap.S -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section &quot;.rodata.idmap&quot;, &quot;a&quot;, %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><em>image.ld</em> (you shouldnâ€™t need to change this):</p>
<!-- File image.ld -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><em>Makefile</em> (you shouldnâ€™t need to change this):</p>
<!-- File Makefile -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

UNAME := $(shell uname -s)
ifeq ($(UNAME),Linux)
	TARGET = aarch64-linux-gnu
else
	TARGET = aarch64-none-elf
endif
OBJCOPY = $(TARGET)-objcopy

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	$(OBJCOPY) -O binary target/aarch64-unknown-none/debug/rtc $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><em>.cargo/config.toml</em> (you shouldnâ€™t need to change this):</p>
<!-- File .cargo/config.toml -->
<pre><code class="language-toml">[build]
target = &quot;aarch64-unknown-none&quot;
rustflags = [&quot;-C&quot;, &quot;link-arg=-Timage.ld&quot;]
</code></pre>
<p>Run the code in QEMU with <code>make qemu</code>.</p>
<h1><a class="header" href="#æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘-1" id="æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘-1">æ¬¢è¿äº†è§£ Rust ä¸­çš„å¹¶å‘</a></h1>
<p>Rust å®Œå…¨æ”¯æŒä½¿ç”¨å¸¦æœ‰äº’æ–¥é”å’Œé€šé“çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹è¿›è¡Œå¹¶å‘ã€‚</p>
<p>Rust ç±»å‹ç³»ç»Ÿèƒ½å¸®åŠ©æˆ‘ä»¬æŠŠè®¸å¤šå¹¶å‘bugè½¬æ¢ä¸ºç¼–è¯‘æœŸbug å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è¿™é€šå¸¸ç§°ä¸ºâ€œæ— ç•å¹¶å‘â€ï¼Œå› ä¸ºä½ å¯ä»¥ä¾é ç¼–è¯‘å™¨æ¥ç¡®ä¿ è¿è¡Œæ—¶çš„æ­£ç¡®æ€§ã€‚</p>
<h1><a class="header" href="#çº¿ç¨‹" id="çº¿ç¨‹">çº¿ç¨‹</a></h1>
<p>Rust çº¿ç¨‹çš„è¿ä½œæ–¹å¼ä¸å…¶ä»–è¯­è¨€ä¸­çš„çº¿ç¨‹ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>çº¿ç¨‹å‡ä¸ºå®ˆæŠ¤ç¨‹åºçº¿ç¨‹ï¼Œä¸»çº¿ç¨‹ä¸ä¼šç­‰å¾…è¿™äº›çº¿ç¨‹ã€‚</li>
<li>çº¿ç¨‹ç´§æ€¥è­¦æŠ¥ (panic) æ˜¯å½¼æ­¤ç‹¬ç«‹çš„ã€‚
<ul>
<li>ç´§æ€¥è­¦æŠ¥å¯ä»¥æºå¸¦è½½è·ï¼Œå¹¶å¯ä»¥ä½¿ç”¨ <code>downcast_ref</code> å¯¹è½½è·è¿›è¡Œè§£å‹ç¼©ã€‚</li>
</ul>
</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>è¯·æ³¨æ„ï¼Œçº¿ç¨‹åœ¨è¾¾åˆ° 10 ä¹‹å‰å°±åœæ­¢äº†ï¼Œè€Œä¸»çº¿ç¨‹å¹¶ æ²¡æœ‰ç­‰å¾…ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>let handle = thread::spawn(...)</code> å’Œåé¢çš„ <code>handle.join()</code> ç­‰å¾… çº¿ç¨‹å®Œæˆã€‚</p>
</li>
<li>
<p>åœ¨çº¿ç¨‹ä¸­è§¦å‘ç´§æ€¥è­¦æŠ¥ï¼Œå¹¶æ³¨æ„è¿™ä¸ºä½•ä¸ä¼šå½±å“åˆ° <code>main</code>ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>handle.join()</code> çš„ <code>Result</code> è¿”å›å€¼æ¥è·å–å¯¹ç´§æ€¥è­¦æŠ¥ è½½è·çš„è®¿é—®æƒé™ã€‚ç°åœ¨æœ‰å¿…è¦ä»‹ç»ä¸€ä¸‹ <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a> äº†ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#èŒƒå›´çº¿ç¨‹" id="èŒƒå›´çº¿ç¨‹">èŒƒå›´çº¿ç¨‹</a></h1>
<p>å¸¸è§„çº¿ç¨‹ä¸èƒ½ä»å®ƒä»¬æ‰€å¤„çš„ç¯å¢ƒä¸­å€Ÿç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<p>ä¸è¿‡ï¼Œä½ å¯ä»¥ä½¿ç”¨<a href="https://doc.rust-lang.org/std/thread/fn.scope.html">èŒƒå›´çº¿ç¨‹</a>æ¥å®ç°æ­¤ç›®çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let s = String::from(&quot;Hello&quot;);

    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}
</code></pre></pre>
<details>
<ul>
<li>å…¶åŸå› åœ¨äºï¼Œåœ¨ <code>thread::scope</code> å‡½æ•°å®Œæˆåï¼Œå¯ä¿è¯æ‰€æœ‰çº¿ç¨‹éƒ½å·²è”ç»“åœ¨ä¸€èµ·ï¼Œä½¿å¾—çº¿ç¨‹èƒ½å¤Ÿè¿”å›å€Ÿç”¨çš„æ•°æ®ã€‚</li>
<li>æ­¤æ—¶é¡»éµå®ˆå¸¸è§„ Rust å€Ÿç”¨è§„åˆ™ï¼šä½ å¯ä»¥é€šè¿‡ä¸€ä¸ªçº¿ç¨‹ä»¥å¯å˜çš„æ–¹å¼å€Ÿç”¨ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä»»æ„æ•°é‡çš„çº¿ç¨‹ä»¥ä¸å¯å˜çš„æ–¹å¼å€Ÿç”¨ã€‚</li>
</ul>
</details><h1><a class="header" href="#é€šé“" id="é€šé“">é€šé“</a></h1>
<p>Rust é€šé“ï¼ˆChannelï¼‰åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š<code>Sender&lt;T&gt;</code> å’Œ <code>Receiver&lt;T&gt;</code>ã€‚è¿™ä¸¤ä¸ªéƒ¨åˆ† é€šè¿‡é€šé“è¿›è¡Œè¿æ¥ï¼Œä½†ä½ åªèƒ½çœ‹åˆ°ç«¯ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><code>mpsc</code> ä»£è¡¨å¤šä¸ªç”Ÿäº§æ–¹ï¼Œå•ä¸ªä½¿ç”¨æ–¹ã€‚<code>Sender</code> å’Œ <code>SyncSender</code> ä¼šå®ç° <code>Clone</code>ï¼ˆå› æ­¤ï¼Œ ä½ å¯ä»¥è®¾ç½®å¤šä¸ªç”Ÿäº§æ–¹ï¼‰ï¼Œä½† <code>Receiver</code> ä¸ä¼šå®ç°ã€‚</li>
<li><code>send()</code> å’Œ <code>recv()</code> ä¼šè¿”å› <code>Result</code>ã€‚å¦‚æœå®ƒä»¬è¿”å› <code>Err</code>ï¼Œåˆ™è¡¨ç¤ºå¯¹åº”çš„ <code>Sender</code> æˆ– <code>Receiver</code> å·²è¢«ä¸¢å¼ƒï¼Œä¸”é€šé“å·²å…³é—­ã€‚</li>
</ul>
</details><h1><a class="header" href="#æ— ç•Œé€šé“" id="æ— ç•Œé€šé“">æ— ç•Œé€šé“</a></h1>
<p>ä½ å¯ä»¥ä½¿ç”¨ <code>mpsc::channel()</code> è·å¾—æ— è¾¹ç•Œçš„å¼‚æ­¥é€šé“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#æœ‰ç•Œé€šé“" id="æœ‰ç•Œé€šé“">æœ‰ç•Œé€šé“</a></h1>
<p>With bounded (synchronous) channels, <code>send</code> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 1..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Calling <code>send</code> will block the current thread until there is space in the channel for the new message. The thread can be blocked indefinitely if there is nobody who reads from the channel.</li>
<li>A call to <code>send</code> will abort with an error (that is why it returns <code>Result</code>) if the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a â€œrendezvous channelâ€. Every send will block the current thread until another thread calls <code>read</code>.</li>
</ul>
</details><h1><a class="header" href="#send-å’Œ-sync" id="send-å’Œ-sync"><code>Send</code> å’Œ <code>Sync</code></a></h1>
<p>How does Rust know to forbid shared access across threads? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>ï¼šå¦‚æœè·¨çº¿ç¨‹è¾¹ç•Œç§»åŠ¨ <code>T</code> æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <code>Send</code>ã€‚</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>ï¼šå¦‚æœè·¨çº¿ç¨‹è¾¹ç•Œç§»åŠ¨ <code>&amp;T</code> æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <code>Sync</code>ã€‚</li>
</ul>
<p><code>Send</code> å’Œ <code>Sync</code> å‡ä¸º<a href="concurrency/../unsafe/unsafe-traits.html">ä¸å®‰å…¨ç‰¹å¾</a>ã€‚åªè¦ç±»å‹ä»…åŒ…å« <code>Send</code> å’Œ <code>Sync</code> ç±»å‹ï¼Œç¼–è¯‘å™¨å°±ä¼šè‡ªåŠ¨ä¸ºç±»å‹æ´¾ç”Ÿ è¿™ä¸¤ç§ç‰¹å¾ã€‚ä½ ä¹Ÿå¯ä»¥æ‰‹åŠ¨å®ç°å®ƒä»¬ï¼ˆå¦‚æœä½ ç¡®å®šè¿™æ · æœ‰æ•ˆçš„è¯ï¼‰ã€‚</p>
<details>
<ul>
<li>ä¸å¦¨å°†è¿™äº›ç‰¹å¾è§†ä¸ºç±»å‹åŒ…å«æŸäº›çº¿ç¨‹å®‰å…¨å±æ€§çš„æ ‡è®°ã€‚</li>
<li>å®ƒä»¬å¯ä»¥åœ¨æ³›å‹çº¦æŸä¸­ä½œä¸ºå¸¸è§„ç‰¹å¾ä½¿ç”¨ã€‚</li>
</ul>
</details><h1><a class="header" href="#send" id="send"><code>Send</code></a></h1>
<blockquote>
<p>å¦‚æœå°† <code>T</code> å€¼ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>ã€‚</p>
</blockquote>
<p>å°†æ‰€æœ‰æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹çš„å½±å“æ˜¯ï¼Œâ€œææ„å‡½æ•°â€å°†åœ¨ç›¸åº”çº¿ç¨‹ä¸­ è¿è¡Œã€‚å› æ­¤ï¼Œé—®é¢˜åœ¨äºä½ ä½•æ—¶å¯ä»¥åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­åˆ†é…æŸä¸ªå€¼ï¼Œç„¶ååœ¨ å¦ä¸€ä¸ªçº¿ç¨‹ä¸­å–æ¶ˆåˆ†é…è¯¥å€¼ã€‚</p>
<details>
<p>ä¾‹å¦‚ï¼Œä¸ SQLite åº“çš„è¿æ¥åªèƒ½é€šè¿‡ å•ä¸ªçº¿ç¨‹è®¿é—®ã€‚</p>
</details><h1><a class="header" href="#sync" id="sync"><code>Sync</code></a></h1>
<blockquote>
<p>å¦‚æœåŒæ—¶ä»å¤šä¸ªçº¿ç¨‹è®¿é—® <code>T</code> å€¼æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>ã€‚</p>
</blockquote>
<p>æ›´å‡†ç¡®åœ°è¯´ï¼Œå®šä¹‰æ˜¯ï¼š</p>
<blockquote>
<p>å½“ä¸”ä»…å½“ <code>&amp;T</code> ä¸º <code>Send</code> æ—¶ï¼Œ<code>T</code> ä¸º <code>Sync</code></p>
</blockquote>
<details>
<p>è¯¥è¯­å¥å®è´¨ä¸Šæ˜¯ä¸€ç§ç®€å†™å½¢å¼ï¼Œè¡¨ç¤ºå¦‚æœæŸä¸ªç±»å‹å¯¹äºå…±äº«ä½¿ç”¨æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé‚£ä¹ˆè·¨çº¿ç¨‹ä¼ é€’å¯¹è¯¥ç±»å‹çš„å¼•ç”¨ä¹Ÿæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</p>
<p>è¿™æ˜¯å› ä¸ºå¦‚æœæŸä¸ªç±»å‹ä¸º Syncï¼Œåˆ™æ„å‘³ç€å®ƒå¯ä»¥åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«ï¼Œè€Œä¸å­˜åœ¨æ•°æ®äº‰ç”¨æˆ–å…¶ä»–åŒæ­¥é—®é¢˜çš„é£é™©ï¼Œå› æ­¤å°†å…¶ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ˜¯å®‰å…¨çš„ã€‚å¯¹è¯¥ç±»å‹çš„å¼•ç”¨åŒæ ·å¯ä»¥å®‰å…¨åœ°ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œå› ä¸ºå®ƒå¼•ç”¨çš„æ•°æ®å¯ä»¥ä»ä»»ä½•çº¿ç¨‹å®‰å…¨åœ°è®¿é—®ã€‚</p>
</details><h1><a class="header" href="#ç¤ºä¾‹-1" id="ç¤ºä¾‹-1">ç¤ºä¾‹</a></h1>
<h2><a class="header" href="#send--sync" id="send--sync"><code>Send + Sync</code></a></h2>
<p>ä½ é‡åˆ°çš„ç±»å‹å¤§éƒ½å±äº <code>Send + Sync</code>ï¼š</p>
<ul>
<li><code>i8</code>ã€<code>f32</code>ã€<code>bool</code>ã€<code>char</code>ã€<code>&amp;str</code>â€¦</li>
<li><code>(T1, T2)</code>ã€<code>[T; N]</code>ã€<code>&amp;[T]</code>ã€<code>struct { x: T }</code>â€¦</li>
<li><code>String</code>ã€<code>Option&lt;T&gt;</code>ã€<code>Vec&lt;T&gt;</code>ã€<code>Box&lt;T&gt;</code>â€¦</li>
<li><code>Arc&lt;T&gt;</code>ï¼šæ˜ç¡®é€šè¿‡åŸå­å¼•ç”¨è®¡æ•°å®ç°çº¿ç¨‹å®‰å…¨ã€‚</li>
<li><code>Mutex&lt;T&gt;</code>ï¼šæ˜ç¡®é€šè¿‡å†…éƒ¨é”å®šå®ç°çº¿ç¨‹å®‰å…¨ã€‚</li>
<li><code>AtomicBool</code>ã€<code>AtomicU8</code>â€¦ï¼šä½¿ç”¨ç‰¹æ®Šçš„åŸå­æŒ‡ä»¤ã€‚</li>
</ul>
<p>å½“ç±»å‹å‚æ•°ä¸º <code>Send + Sync</code> æ—¶ï¼Œæ³›å‹ç±»å‹é€šå¸¸ ä¸º <code>Send + Sync</code>ã€‚</p>
<h2><a class="header" href="#send--sync-1" id="send--sync-1"><code>Send + !Sync</code></a></h2>
<p>è¿™äº›ç±»å‹å¯ä»¥ç§»åŠ¨åˆ°å…¶ä»–çº¿ç¨‹ï¼Œä½†å®ƒä»¬ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ è¿™é€šå¸¸æ˜¯ç”±å†…éƒ¨å¯å˜æ€§é€ æˆçš„ï¼š</p>
<ul>
<li><code>mpsc::Sender&lt;T&gt;</code></li>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2><a class="header" href="#send--sync-2" id="send--sync-2"><code>!Send + Sync</code></a></h2>
<p>è¿™äº›ç±»å‹æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†å®ƒä»¬ä¸èƒ½ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼š</p>
<ul>
<li><code>MutexGuard&lt;T&gt;</code>ï¼šä½¿ç”¨æ“ä½œç³»ç»Ÿçº§åˆ«çš„åŸè¯­ï¼ˆå¿…é¡»åœ¨åˆ›å»ºè¿™äº›åŸè¯­çš„çº¿ç¨‹ä¸Š å–æ¶ˆåˆ†é…ï¼‰ã€‚</li>
</ul>
<h2><a class="header" href="#send--sync-3" id="send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>è¿™äº›ç±»å‹ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä¸èƒ½ç§»åŠ¨åˆ°å…¶ä»–çº¿ç¨‹ï¼š</p>
<ul>
<li><code>Rc&lt;T&gt;</code>ï¼šæ¯ä¸ª <code>Rc&lt;T&gt;</code> éƒ½å…·æœ‰å¯¹ <code>RcBox&lt;T&gt;</code> çš„å¼•ç”¨ï¼Œå…¶ä¸­åŒ…å« éåŸå­å¼•ç”¨è®¡æ•°ã€‚</li>
<li><code>*const T</code>ã€<code>*mut T</code>ï¼šRust ä¼šå‡å®šåŸå§‹æŒ‡é’ˆå¯èƒ½ åœ¨å¹¶å‘æ–¹é¢æœ‰ç‰¹æ®Šçš„æ³¨æ„äº‹é¡¹ã€‚</li>
</ul>
<h1><a class="header" href="#å…±äº«çŠ¶æ€" id="å…±äº«çŠ¶æ€">å…±äº«çŠ¶æ€</a></h1>
<p>Rust ä½¿ç”¨ç±»å‹ç³»ç»Ÿæ¥å¼ºåˆ¶åŒæ­¥å…±äº«æ•°æ®ã€‚è¿™ä¸»è¦ é€šè¿‡ä¸¤ç§ç±»å‹å®ç°ï¼š</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>ï¼Œå¯¹ <code>T</code> è¿›è¡ŒåŸå­è®¡æ•°ï¼šç”¨äºå¤„ç†çº¿ç¨‹ä¹‹é—´çš„å…±äº«ï¼Œå¹¶è´Ÿè´£ åœ¨æœ€åä¸€ä¸ªå¼•ç”¨è¢«ä¸¢å¼ƒæ—¶å–æ¶ˆåˆ†é… <code>T</code>ã€‚</li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a>ï¼šç¡®ä¿å¯¹ <code>T</code> å€¼çš„äº’æ–¥è®¿é—®ã€‚</li>
</ul>
<h1><a class="header" href="#arc" id="arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> å…è®¸é€šè¿‡ <code>Arc::clone</code> å®ç°å…±äº«åªè¯»æƒé™ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::sync::Arc;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Arc</code> ä»£è¡¨â€œåŸå­å¼•ç”¨è®¡æ•°â€ï¼Œå®ƒæ˜¯ä½¿ç”¨åŸå­æ“ä½œçš„ <code>Rc</code> çš„ çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ã€‚</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> åœ¨æ‰§è¡ŒåŸå­æ“ä½œæ–¹é¢æœ‰å¼€é”€ï¼Œä½†åœ¨æ­¤ä¹‹åï¼Œ<code>T</code> ä¾¿å¯ éšæ„ä½¿ç”¨ï¼Œè€Œæ²¡æœ‰ä»»ä½•å¼€é”€ã€‚</li>
<li>è¯·è­¦æƒ•å¼•ç”¨å¾ªç¯ï¼Œ<code>Arc</code> ä¸ä¼šä½¿ç”¨åƒåœ¾å›æ”¶å™¨æ£€æµ‹å¼•ç”¨å¾ªç¯ã€‚
<ul>
<li><code>std::sync::Weak</code> å¯¹æ­¤æœ‰æ‰€å¸®åŠ©ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#äº’æ–¥å™¨-mutex" id="äº’æ–¥å™¨-mutex"><code>äº’æ–¥å™¨ (Mutex)</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> èƒ½å¤Ÿç¡®ä¿äº’æ–¥ï¼Œå¹¶å…è®¸å¯¹åªè¯»æ¥å£ åé¢çš„ <code>T</code> è¿›è¡Œå¯å˜è®¿é—®ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>è¯·æ³¨æ„æˆ‘ä»¬å¦‚ä½•è®¾ç½® <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> é€šç”¨ å®ç°ã€‚</p>
<details>
<ul>
<li>Rust ä¸­çš„äº’æ–¥å™¨çœ‹èµ·æ¥å°±åƒåªåŒ…å«ä¸€ä¸ªå…ƒç´ çš„é›†åˆï¼Œå…¶ä¸­çš„å…ƒç´ å°±æ˜¯å—ä¿æŠ¤çš„æ•°æ®ã€‚
<ul>
<li>åœ¨è®¿é—®å—ä¿æŠ¤çš„æ•°æ®ä¹‹å‰ä¸å¯èƒ½å¿˜è®°è·å–äº’æ–¥é‡ã€‚</li>
</ul>
</li>
<li>ä½ å¯ä»¥é€šè¿‡è·å–é”ï¼Œä» <code>&amp;Mutex&lt;T&gt;</code> ä¸­è·å– <code>&amp;mut T</code>ã€‚<code>MutexGuard</code> èƒ½å¤Ÿç¡®ä¿ <code>&amp;mut T</code> å­˜åœ¨çš„æ—¶é—´ä¸ä¼šæ¯”æŒæœ‰é”çš„æ—¶é—´æ›´é•¿ã€‚</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> iff (if and only if) <code>T</code> implements <code>Send</code>.</li>
<li>è¯»å†™é”ç‰ˆæœ¬ - <code>RwLock</code>ã€‚</li>
<li>ä¸ºä»€ä¹ˆ <code>lock()</code> ä¼šè¿”å› <code>Result</code>ï¼Ÿ
<ul>
<li>å¦‚æœæŒæœ‰ <code>Mutex</code> çš„çº¿ç¨‹å‘ç”Ÿpanicï¼Œ<code>Mutex</code> ä¾¿ä¼šâ€œä¸­æ¯’â€å¹¶å‘å‡ºä¿¡å·ï¼Œ è¡¨æ˜å…¶æ‰€ä¿æŠ¤çš„æ•°æ®å¯èƒ½å¤„äºä¸ä¸€è‡´çŠ¶æ€ã€‚å¯¹ä¸­æ¯’çš„äº’æ–¥é‡è°ƒç”¨ <code>lock()</code> å°†ä¼šå¤±è´¥ï¼Œ å¹¶å°†æ˜¾ç¤º <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>ã€‚æ— è®ºå¦‚ä½•ï¼Œä½ å¯ä»¥å¯¹è¯¥é”™è¯¯è°ƒç”¨ <code>into_inner()</code> æ¥ æ¢å¤æ•°æ®ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#ç¤ºä¾‹-2" id="ç¤ºä¾‹-2">ç¤ºä¾‹</a></h1>
<p>è®©æˆ‘ä»¬çœ‹çœ‹ <code>Arc</code> å’Œ <code>Mutex</code> çš„å®é™…æ•ˆæœï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>å¯èƒ½æœ‰ç”¨çš„è§£å†³æ–¹æ¡ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<p>å€¼å¾—æ³¨æ„çš„éƒ¨åˆ†ï¼š</p>
<ul>
<li><code>Arc</code> å’Œ <code>Mutex</code> ä¸­éƒ½å°è£…äº† <code>v</code>ï¼Œå› ä¸ºå®ƒä»¬çš„å…³æ³¨ç‚¹æ˜¯æ­£äº¤çš„ã€‚
<ul>
<li>å°† <code>Mutex</code> å°è£…åœ¨ <code>Arc</code> ä¸­æ˜¯ä¸€ç§åœ¨çº¿ç¨‹ä¹‹é—´å…±äº«å¯å˜çŠ¶æ€çš„å¸¸è§æ¨¡å¼ã€‚</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> å¿…é¡»å…ˆå…‹éš†ä¸º <code>v2</code>ï¼Œç„¶åæ‰èƒ½ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ã€‚è¯·æ³¨æ„ï¼Œlambda ç­¾åä¸­æ·»åŠ äº† <code>move</code>ã€‚</li>
<li>æˆ‘ä»¬å¼•å…¥äº†å—ï¼Œä»¥å°½å¯èƒ½ç¼©å° <code>LockGuard</code> çš„ä½œç”¨åŸŸã€‚</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-3" id="ä¹ é¢˜-3">ä¹ é¢˜</a></h1>
<p>Let us practice our new concurrency skills with</p>
<ul>
<li>
<p>Dining philosophers: a classic problem in concurrency.</p>
</li>
<li>
<p>Multi-threaded link checker: a larger project where youâ€™ll use Cargo to download dependencies and then check links in parallel.</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-morning.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#å“²å­¦å®¶å°±é¤é—®é¢˜-dining-philosophers-problem" id="å“²å­¦å®¶å°±é¤é—®é¢˜-dining-philosophers-problem">å“²å­¦å®¶å°±é¤é—®é¢˜ (Dining philosophers problem)</a></h1>
<p>The dining philosophers problem is a classic problem in concurrency:</p>
<blockquote>
<p>Five philosophers dine together at the same table. Each philosopher has their own place at the table. There is a fork between each plate. The dish served is a kind of spaghetti which has to be eaten with two forks. Each philosopher can only alternately think and eat. Moreover, a philosopher can only eat their spaghetti when they have both a left and right fork. Thus two forks will only be available when their two nearest neighbors are thinking, not eating. After an individual philosopher finishes eating, they will put down both forks.</p>
</blockquote>
<p>You will need a local <a href="exercises/concurrency/../../cargo/running-locally.html">Cargo installation</a> for this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}
</code></pre></pre>
<p>You can use the following <code>Cargo.toml</code>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<h1><a class="header" href="#å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨" id="å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨">å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨</a></h1>
<p>Let us use our new knowledge to create a multi-threaded link checker. It should start at a webpage and check that links on the page are valid. It should recursively check other pages on the same domain and keep doing this until all pages have been validated.</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. Create a new Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
</code></pre>
<blockquote>
<p>If <code>cargo add</code> fails with <code>error: no such subcommand</code>, then please edit the <code>Cargo.toml</code> file by hand. Add the dependencies listed below.</p>
</blockquote>
<p>You will also need a way to find links. We can use <a href="https://docs.rs/scraper/"><code>scraper</code></a> for that:</p>
<pre><code class="language-shell">cargo add scraper
</code></pre>
<p>Finally, weâ€™ll need some way of handling errors. We use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> for that:</p>
<pre><code class="language-shell">cargo add thiserror
</code></pre>
<p>The <code>cargo add</code> calls will update the <code>Cargo.toml</code> file to look like this:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;link-checker&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>You can now download the start page. Try with a small site such as <code>https://www.google.org/</code>.</p>
<p>Your <code>src/main.rs</code> file should look something like this:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>Run the code in <code>src/main.rs</code> with</p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2><a class="header" href="#ä»»åŠ¡" id="ä»»åŠ¡">ä»»åŠ¡</a></h2>
<ul>
<li>Use threads to check the links in parallel: send the URLs to be checked to a channel and let a few threads check the URLs in parallel.</li>
<li>Extend this to recursively extract links from all pages on the <code>www.google.org</code> domain. Put an upper limit of 100 pages or so so that you donâ€™t end up being blocked by the site.</li>
</ul>
<h1><a class="header" href="#async-rust" id="async-rust">Async Rust</a></h1>
<p>â€œAsyncâ€ is a concurrency model where multiple tasks are executed concurrently by executing each task until it would block, then switching to another task that is ready to make progress. The model allows running a larger number of tasks on a limited number of threads. This is because the per-task overhead is typically very low and operating systems provide primitives for efficiently identifying I/O that is able to proceed.</p>
<p>Rustâ€™s asynchronous operation is based on â€œfuturesâ€, which represent work that may be completed in the future. Futures are â€œpolledâ€ until they signal that they are complete.</p>
<p>Futures are polled by an async runtime, and several different runtimes are available.</p>
<h2><a class="header" href="#comparisons" id="comparisons">Comparisons</a></h2>
<ul>
<li>
<p>Python has a similar model in its <code>asyncio</code>. However, its <code>Future</code> type is callback-based, and not polled. Async Python programs require a â€œloopâ€, similar to a runtime in Rust.</p>
</li>
<li>
<p>JavaScriptâ€™s <code>Promise</code> is similar, but again callback-based. The language runtime implements the event loop, so many of the details of Promise resolution are hidden.</p>
</li>
</ul>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>ä»é«˜å±‚æ¬¡ä¸Šçœ‹ï¼Œå¼‚æ­¥ Rust ä»£ç ä¸â€œæ­£å¸¸â€çš„é¡ºåºä»£ç éå¸¸ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count is: {i}!&quot;);
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>è¯·æ³¨æ„ï¼Œè¿™åªæ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œç”¨äºå±•ç¤ºè¯­æ³•ã€‚å…¶ä¸­æ²¡æœ‰é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œæˆ–ä»»ä½•çœŸæ­£çš„å¹¶å‘ï¼</p>
</li>
<li>
<p>å¼‚æ­¥è°ƒç”¨çš„è¿”å›ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿ</p>
<ul>
<li>åœ¨ <code>main</code> ä¸­ä½¿ç”¨ <code>let future: () = async_main(10);</code> æ¥æŸ¥çœ‹ç±»å‹ã€‚</li>
</ul>
</li>
<li>
<p>â€œasyncâ€ å…³é”®å­—æ˜¯è¯­æ³•ç³–ã€‚ç¼–è¯‘å™¨ä¼šå°†è¿”å›ç±»å‹æ›¿æ¢ä¸º futureã€‚</p>
</li>
<li>
<p>ä½ ä¸èƒ½å°† <code>main</code> å£°æ˜ä¸ºå¼‚æ­¥å‡½æ•°ï¼Œé™¤éåœ¨ç¼–è¯‘å™¨ä¸­åŠ å…¥é¢å¤–çš„æŒ‡ä»¤æ¥å‘Šè¯‰å®ƒå¦‚ä½•ä½¿ç”¨è¿”å›çš„ futureã€‚</p>
</li>
<li>
<p>ä½ éœ€è¦ä¸€ä¸ªæ‰§è¡Œå™¨æ¥è¿è¡Œå¼‚æ­¥ä»£ç ã€‚<code>block_on</code>ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°æä¾›çš„futureå®Œæˆä¸ºæ­¢ã€‚ </p>
</li>
<li>
<p><code>.await</code> ä¼šå¼‚æ­¥åœ°ç­‰å¾…å¦ä¸€ä¸ªæ“ä½œçš„å®Œæˆã€‚ä¸ <code>block_on</code> ä¸åŒï¼Œ<code>.await</code> ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ã€‚</p>
</li>
<li>
<p><code>.await</code> åªèƒ½åœ¨ <code>async</code> å‡½æ•°ï¼ˆæˆ–å—ï¼Œè¿™äº›ç¨åä¼šä»‹ç»ï¼‰ä¸­ä½¿ç”¨ã€‚ </p>
</li>
</ul>
</details><h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> is a trait, implemented by objects that represent an operation that may not be complete yet. A future can be polled, and <code>poll</code> returns a <a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>An async function returns an <code>impl Future</code>. Itâ€™s also possible (but uncommon) to implement <code>Future</code> for your own types. For example, the <code>JoinHandle</code> returned from <code>tokio::spawn</code> implements <code>Future</code> to allow joining to it.</p>
<p>The <code>.await</code> keyword, applied to a Future, causes the current async function to pause until that Future is ready, and then evaluates to its output.</p>
<details>
<ul>
<li>
<p>The <code>Future</code> and <code>Poll</code> types are implemented exactly as shown; click the links to show the implementations in the docs.</p>
</li>
<li>
<p>We will not get to <code>Pin</code> and <code>Context</code>, as we will focus on writing async code, rather than building new async primitives. Briefly:</p>
<ul>
<li>
<p><code>Context</code> allows a Future to schedule itself to be polled again when an event occurs.</p>
</li>
<li>
<p><code>Pin</code> ensures that the Future isnâ€™t moved in memory, so that pointers into that future remain valid. This is required to allow references to remain valid after an <code>.await</code>.</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#runtimes" id="runtimes">Runtimes</a></h1>
<p>A <em>runtime</em> provides support for performing operations asynchronously (a <em>reactor</em>) and is responsible for executing futures (an <em>executor</em>). Rust does not have a â€œbuilt-inâ€ runtime, but several options are available:</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>: performant, with a well-developed ecosystem of functionality like <a href="https://hyper.rs/">Hyper</a> for HTTP or <a href="https://github.com/hyperium/tonic">Tonic</a> for gRPC.</li>
<li><a href="https://async.rs/">async-std</a>: aims to be a â€œstd for asyncâ€, and includes a basic runtime in <code>async::task</code>.</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>: simple and lightweight</li>
</ul>
<p>Several larger applications have their own runtimes. For example, <a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a> already has one.</p>
<details>
<ul>
<li>
<p>Note that of the listed runtimes, only Tokio is supported in the Rust playground. The playground also does not permit any I/O, so most interesting async things canâ€™t run in the playground.</p>
</li>
<li>
<p>Futures are â€œinertâ€ in that they do not do anything (not even start an I/O operation) unless there is an executor polling them. This differs from JS Promises, for example, which will run to completion even if they are never used.</p>
</li>
</ul>
</details><h1><a class="header" href="#tokio" id="tokio">Tokio</a></h1>
<p>Tokio provides: </p>
<ul>
<li>A multi-threaded runtime for executing asynchronous code.</li>
<li>An asynchronous version of the standard library.</li>
<li>A large ecosystem of libraries.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::time;

async fn count_to(count: i32) {
    for i in 1..=count {
        println!(&quot;Count in task: {i}!&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 1..5 {
        println!(&quot;Main task: {i}&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>With the <code>tokio::main</code> macro we can now make <code>main</code> async.</p>
</li>
<li>
<p>The <code>spawn</code> function creates a new, concurrent â€œtaskâ€.</p>
</li>
<li>
<p>Note: <code>spawn</code> takes a <code>Future</code>, you donâ€™t call <code>.await</code> on <code>count_to</code>.</p>
</li>
</ul>
<p><strong>Further exploration:</strong></p>
<ul>
<li>
<p>Why does <code>count_to</code> not (usually) get to 10? This is an example of async cancellation. <code>tokio::spawn</code> returns a handle which can be awaited to wait until it finishes.</p>
</li>
<li>
<p>Try <code>count_to(10).await</code> instead of spawning.</p>
</li>
<li>
<p>Try awaiting the task returned from <code>tokio::spawn</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#ä»»åŠ¡-1" id="ä»»åŠ¡-1">ä»»åŠ¡</a></h1>
<p>Rust has a task system, which is a form of lightweight threading.</p>
<p>A task has a single top-level future which the executor polls to make progress. That future may have one or more nested futures that its <code>poll</code> method polls, corresponding loosely to a call stack. Concurrency within a task is possible by polling multiple child futures, such as racing a timer and an I/O operation.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:6142&quot;).await?;
	println!(&quot;listening on port 6142&quot;);

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!(&quot;connection from {addr:?}&quot;);

        tokio::spawn(async move {
            if let Err(e) = socket.write_all(b&quot;Who are you?\n&quot;).await {
                println!(&quot;socket error: {e:?}&quot;);
                return;
            }

            let mut buf = vec![0; 1024];
            let reply = match socket.read(&amp;mut buf).await {
                Ok(n) =&gt; {
                    let name = std::str::from_utf8(&amp;buf[..n]).unwrap().trim();
                    format!(&quot;Thanks for dialing in, {name}!\n&quot;)
                }
                Err(e) =&gt; {
                    println!(&quot;socket error: {e:?}&quot;);
                    return;
                }
            };

            if let Err(e) = socket.write_all(reply.as_bytes()).await {
                println!(&quot;socket error: {e:?}&quot;);
            }
        });
    }
}
</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>Ask students to visualize what the state of the example server would be with a few connected clients. What tasks exist? What are their Futures?</p>
</li>
<li>
<p>This is the first time weâ€™ve seen an <code>async</code> block. This is similar to a closure, but does not take any arguments. Its return value is a Future, similar to an <code>async fn</code>. </p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using <code>?</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#å¼‚æ­¥é€šé“" id="å¼‚æ­¥é€šé“">å¼‚æ­¥é€šé“</a></h1>
<p>Several crates have support for asynchronous channels. For instance <code>tokio</code>:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc::{self, Receiver};

async fn ping_handler(mut input: Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!(&quot;Received {count} pings so far.&quot;);
    }

    println!(&quot;ping_handler complete&quot;);
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect(&quot;Failed to send ping.&quot;);
        println!(&quot;Sent {} pings so far.&quot;, i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect(&quot;Something went wrong in ping handler task.&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Change the channel size to <code>3</code> and see how it affects the execution.</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the <a href="async/concurrency/channels.html">morning class</a>.</p>
</li>
<li>
<p>Try removing the <code>std::mem::drop</code> call. What happens? Why?</p>
</li>
<li>
<p>The <a href="https://docs.rs/flume/latest/flume/">Flume</a> crate has channels that implement both <code>sync</code> and <code>async</code> <code>send</code> and <code>recv</code>. This can be convenient for complex applications with both IO and heavy CPU processing tasks.</p>
</li>
<li>
<p>What makes working with <code>async</code> channels preferable is the ability to combine them with other <code>future</code>s to combine them and create complex control flow.</p>
</li>
</ul>
</details><h1><a class="header" href="#futures-control-flow" id="futures-control-flow">Futures Control Flow</a></h1>
<p>Futures can be combined together to produce concurrent compute flow graphs. We have already seen tasks, that function as independent threads of execution.</p>
<ul>
<li><a href="async/control-flow/join.html">Join</a></li>
<li><a href="async/control-flow/select.html">Select</a></li>
</ul>
<h1><a class="header" href="#åŠ å…¥" id="åŠ å…¥">åŠ å…¥</a></h1>
<p>A join operation waits until all of a set of futures are ready, and returns a collection of their results. This is similar to <code>Promise.all</code> in JavaScript or <code>asyncio.gather</code> in Python.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        &quot;https://google.com&quot;,
        &quot;https://httpbin.org/ip&quot;,
        &quot;https://play.rust-lang.org/&quot;,
        &quot;BAD_URL&quot;,
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(&quot;{:?}&quot;, page_sizes_dict);
}
</code></pre></pre>
<details>
<p>Copy this example into your prepared <code>src/main.rs</code> and run it from there.</p>
<ul>
<li>
<p>For multiple futures of disjoint types, you can use <code>std::future::join!</code> but you must know how many futures you will have at compile time. This is currently in the <code>futures</code> crate, soon to be stabilised in <code>std::future</code>.</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would cause your program to stall. </p>
</li>
<li>
<p>You can also combine <code>join_all</code> with <code>join!</code> for instance to join all requests to an http service as well as a database query. Try adding a <code>tokio::time::sleep</code> to the future, using <code>futures::join!</code>. This is not a timeout (that requires <code>select!</code>, explained in the next chapter), but demonstrates <code>join!</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#é€‰æ‹©" id="é€‰æ‹©">é€‰æ‹©</a></h1>
<p>A select operation waits until any of a set of futures is ready, and responds to that futureâ€™s result. In JavaScript, this is similar to <code>Promise.race</code>. In Python, it compares to <code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>.</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each of the form <code>pattern = future =&gt; statement</code>. When the <code>future</code> is ready, the <code>statement</code> is executed with the variables in <code>pattern</code> bound to the <code>future</code>â€˜s result.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc::{self, Receiver};
use tokio::time::{sleep, Duration};

#[derive(Debug, PartialEq)]
enum Animal {
    Cat { name: String },
    Dog { name: String },
}

async fn first_animal_to_finish_race(
    mut cat_rcv: Receiver&lt;String&gt;,
    mut dog_rcv: Receiver&lt;String&gt;,
) -&gt; Option&lt;Animal&gt; {
    tokio::select! {
        cat_name = cat_rcv.recv() =&gt; Some(Animal::Cat { name: cat_name? }),
        dog_name = dog_rcv.recv() =&gt; Some(Animal::Dog { name: dog_name? })
    }
}

#[tokio::main]
async fn main() {
    let (cat_sender, cat_receiver) = mpsc::channel(32);
    let (dog_sender, dog_receiver) = mpsc::channel(32);
    tokio::spawn(async move {
        sleep(Duration::from_millis(500)).await;
        cat_sender
            .send(String::from(&quot;Felix&quot;))
            .await
            .expect(&quot;Failed to send cat.&quot;);
    });
    tokio::spawn(async move {
        sleep(Duration::from_millis(50)).await;
        dog_sender
            .send(String::from(&quot;Rex&quot;))
            .await
            .expect(&quot;Failed to send dog.&quot;);
    });

    let winner = first_animal_to_finish_race(cat_receiver, dog_receiver)
        .await
        .expect(&quot;Failed to receive winner&quot;);

    println!(&quot;Winner is {winner:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>In this example, we have a race between a cat and a dog. <code>first_animal_to_finish_race</code> listens to both channels and will pick whichever arrives first. Since the dog takes 50ms, it wins against the cat that take 500ms.</p>
</li>
<li>
<p>You can use <code>oneshot</code> channels in this example as the channels are supposed to receive only one <code>send</code>.</p>
</li>
<li>
<p>Try adding a deadline to the race, demonstrating selecting different sorts of futures.</p>
</li>
<li>
<p>Note that <code>select!</code> drops unmatched branches, which cancels their futures. It is easiest to use when every execution of <code>select!</code> creates new futures.</p>
<ul>
<li>An alternative is to pass <code>&amp;mut future</code> instead of the future itself, but this can lead to issues, further discussed in the pinning slide.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#pitfalls-of-asyncawait" id="pitfalls-of-asyncawait">Pitfalls of async/await</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent asynchronous programming. However, the async/await model in Rust also comes with its share of pitfalls and footguns. We illustrate some of them in this chapter:</p>
<ul>
<li><a href="async/pitfalls/blocking-executor.html">Blocking the Executor</a></li>
<li><a href="async/pitfalls/pin.html">Pin</a></li>
<li><a href="async/pitfalls/async-traits.html">Async Traits</a></li>
<li><a href="async/pitfalls/cancellation.html">Cancellation</a></li>
</ul>
<h1><a class="header" href="#blocking-the-executor" id="blocking-the-executor">Blocking the executor</a></h1>
<p>Most async runtimes only allow IO tasks to run concurrently. This means that CPU blocking tasks will block the executor and prevent other tasks from being executed. An easy workaround is to use async equivalent methods where possible.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        &quot;future {id} slept for {duration_ms}ms, finished after {}ms&quot;,
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Run the code and see that the sleeps happen consecutively rather than concurrently.</p>
</li>
<li>
<p>The <code>&quot;current_thread&quot;</code> flavor puts all tasks on a single thread. This makes the effect more obvious, but the bug is still present in the multi-threaded flavor.</p>
</li>
<li>
<p>Switch the <code>std::thread::sleep</code> to <code>tokio::time::sleep</code> and await its result.</p>
</li>
<li>
<p>Another fix would be to <code>tokio::task::spawn_blocking</code> which spawns an actual thread and transforms its handle into a future without blocking the executor.</p>
</li>
<li>
<p>You should not think of tasks as OS threads. They do not map 1 to 1 and most executors will allow many tasks to run on a single OS thread. This is particularly problematic when interacting with other libraries via FFI, where that library might depend on thread-local storage or map to specific OS threads (e.g., CUDA). Prefer <code>tokio::task::spawn_blocking</code> in such situations.</p>
</li>
<li>
<p>Use sync mutexes with care. Holding a mutex over an <code>.await</code> may cause another task to block, and that task may be running on the same thread.</p>
</li>
</ul>
</details><h1><a class="header" href="#å›ºå®š" id="å›ºå®š">å›ºå®š</a></h1>
<p>When you await a future, all local variables (that would ordinarily be stored on a stack frame) are instead stored in the Future for the current async block. If your future has pointers to data on the stack, those pointers might get invalidated. This is unsafe.</p>
<p>Therefore, you must guarantee that the addresses your future points to donâ€™t change. That is why we need to <code>pin</code> futures. Using the same future repeatedly in a <code>select!</code> often leads to issues with pinned values.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect(&quot;failed to send response&quot;);
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work {
            input,
            respond_on: tx,
        })
        .await
        .expect(&quot;failed to send on work queue&quot;);
    rx.await.expect(&quot;failed waiting for response&quot;)
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!(&quot;work result for iteration {i}: {resp}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>You may recognize this as an example of the actor pattern. Actors typically call <code>select!</code> in a loop.</p>
</li>
<li>
<p>This serves as a summation of a few of the previous lessons, so take your time with it.</p>
<ul>
<li>
<p>Naively add a <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code> to the <code>select!</code>. This will never execute. Why?</p>
</li>
<li>
<p>Instead, add a <code>timeout_fut</code> containing that future outside of the <code>loop</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This still doesnâ€™t work. Follow the compiler errors, adding <code>&amp;mut</code> to the <code>timeout_fut</code> in the <code>select!</code> to work around the move, then using <code>Box::pin</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every iteration (a fused future would help with this). Update to reset <code>timeout_fut</code> every time it expires.</p>
</li>
</ul>
</li>
<li>
<p>Box allocates on the heap. In some cases, <code>std::pin::pin!</code> (only recently stabilized, with older code often using <code>tokio::pin!</code>) is also an option, but that is difficult to use for a future that is reassigned.</p>
</li>
<li>
<p>Another alternative is to not use <code>pin</code> at all but spawn another task that will send to a <code>oneshot</code> channel every 100ms.</p>
</li>
</ul>
</details><h1><a class="header" href="#å¼‚æ­¥ç‰¹è´¨" id="å¼‚æ­¥ç‰¹è´¨">å¼‚æ­¥ç‰¹è´¨</a></h1>
<p>Async methods in traits are not yet supported in the stable channel (<a href="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html">An experimental feature exists in nightly and should be stabilized in the mid term.</a>)</p>
<p>The crate <a href="https://docs.rs/async-trait/latest/async_trait/">async_trait</a> provides a workaround through a macro:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;, n_times: usize) {
    for _ in 0..n_times {
        println!(&quot;running all sleepers..&quot;);
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!(&quot;slept for {}ms&quot;, start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}
</code></pre></pre>
<details>  
<ul>
<li>
<p><code>async_trait</code> is easy to use, but note that itâ€™s using heap allocations to achieve this. This heap allocation has performance overhead.</p>
</li>
<li>
<p>å¯¹äº <code>async trait</code> çš„è¯­è¨€æ”¯æŒä¸­çš„æŒ‘æˆ˜æ˜¯æ·±å…¥  Rustçš„ï¼Œå¹¶ä¸”å¯èƒ½ä¸å€¼å¾—æ·±å…¥æè¿°ã€‚å¦‚æœæ‚¨å¯¹æ·±å…¥äº†è§£æ„Ÿå…´è¶£ï¼ŒNiko Matsakis åœ¨<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">è¿™ç¯‡æ–‡ç« </a>ä¸­å¯¹å®ƒä»¬åšäº†å¾ˆå¥½çš„è§£é‡Šã€‚</p>
</li>
<li>
<p>å°è¯•åˆ›å»ºä¸€ä¸ªæ–°çš„ sleeper ç»“æ„ï¼Œä½¿å…¶éšæœºä¼‘çœ ä¸€æ®µæ—¶é—´ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ° Vec ä¸­ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#cancellation" id="cancellation">Cancellation</a></h1>
<p>Dropping a future implies it can never be polled again. This is called <em>cancellation</em> and it can occur at any <code>await</code> point. Care is needed to ensure the system works correctly even when futures are cancelled. For example, it shouldnâ€™t deadlock or lose data.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io::{self, ErrorKind};
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None)
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; std::io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy(&quot;hi\nthere\n&quot;.to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!(&quot;tick!&quot;),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!(&quot;{}&quot;, l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The compiler doesnâ€™t help with cancellation-safety. You need to read API documentation and consider what state your <code>async fn</code> holds.</p>
</li>
<li>
<p>Unlike <code>panic</code> and <code>?</code>, cancellation is part of normal control flow (vs error-handling).</p>
</li>
<li>
<p>The example loses parts of the string.</p>
<ul>
<li>
<p>Whenever the <code>tick()</code> branch finishes first, <code>next()</code> and its <code>buf</code> are dropped.</p>
</li>
<li>
<p><code>LinesReader</code> can be made cancellation-safe by making <code>buf</code> part of the struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a> is cancellation-safe because it keeps track of whether a tick has been â€˜deliveredâ€™.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a> is cancellation-safe because it either returns or doesnâ€™t read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a> is similar to the example and <em>isnâ€™t</em> cancellation-safe. See its documentation for details and alternatives.</p>
</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-4" id="ä¹ é¢˜-4">ä¹ é¢˜</a></h1>
<p>ä¸ºäº†ç»ƒä¹ æ‚¨çš„å¼‚æ­¥ Rust æŠ€èƒ½ï¼Œæˆ‘ä»¬å†æ¬¡ä¸ºæ‚¨æä¾›äº†ä¸¤ä¸ªç»ƒä¹ ï¼š</p>
<ul>
<li>
<p>å“²å­¦å®¶è¿›é¤ï¼šæˆ‘ä»¬å·²ç»åœ¨ä¸Šåˆçœ‹åˆ°äº†è¿™ä¸ªé—®é¢˜ã€‚è¿™æ¬¡ä½ å°†ä½¿ç”¨å¼‚æ­¥ Rust æ¥å®ç°å®ƒã€‚</p>
</li>
<li>
<p>å¹¿æ’­èŠå¤©åº”ç”¨ï¼šè¿™æ˜¯ä¸€ä¸ªæ›´å¤§çš„é¡¹ç›®ï¼Œå…è®¸æ‚¨å°è¯•æ›´é«˜çº§çš„å¼‚æ­¥RuståŠŸèƒ½ã€‚</p>
</li>
</ul>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/concurrency/solutions-afternoon.html">solutions</a> provided.</p>
</details><h1><a class="header" href="#å“²å­¦å®¶è¿›é¤---å¼‚æ­¥" id="å“²å­¦å®¶è¿›é¤---å¼‚æ­¥">å“²å­¦å®¶è¿›é¤ - å¼‚æ­¥</a></h1>
<p>æŸ¥çœ‹<a href="exercises/concurrency/dining-philosophers.html">å“²å­¦å®¶è¿›é¤</a>ä»¥è·å–é—®é¢˜çš„æè¿°ã€‚</p>
<p>ä¸ä¹‹å‰ä¸€æ ·ï¼Œæ‚¨éœ€è¦ä¸€ä¸ªæœ¬åœ°çš„ <a href="exercises/concurrency/../../cargo/running-locally.html">Cargo å®‰è£…</a>æ¥è¿›è¡Œè¿™ä¸ªç»ƒä¹ ã€‚å°†ä¸‹é¢çš„ä»£ç å¤åˆ¶åˆ°ä¸€ä¸ªåä¸º <code>src/main.rs</code> çš„æ–‡ä»¶ä¸­ï¼Œå¡«å†™ç©ºç™½éƒ¨åˆ†ï¼Œå¹¶æµ‹è¯•ç¡®ä¿ <code>cargo run</code> ä¸ä¼šæ­»é”ï¼š</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<p>å› ä¸ºè¿™æ¬¡æ‚¨æ­£åœ¨ä½¿ç”¨å¼‚æ­¥Rustï¼Œæ‚¨å°†éœ€è¦ä¸€ä¸ª <code>tokio</code> ä¾èµ–ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹çš„ <code>Cargo.toml</code>ï¼š</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers-async-dine&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tokio = {version = &quot;1.26.0&quot;, features = [&quot;sync&quot;, &quot;time&quot;, &quot;macros&quot;, &quot;rt-multi-thread&quot;]}
</code></pre>
<p>å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œè¿™æ¬¡æ‚¨å¿…é¡»ä½¿ç”¨æ¥è‡ª <code>tokio</code> åŒ…çš„ <code>Mutex</code> å’Œ <code>mpsc</code> æ¨¡å—ã€‚</p>
<details>
<ul>
<li>æ‚¨å¯ä»¥ä½¿æ‚¨çš„å®ç°ä¸ºå•çº¿ç¨‹å—ï¼Ÿ</li>
</ul>
</details><h1><a class="header" href="#å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº" id="å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº">å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº</a></h1>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨æˆ‘ä»¬çš„æ–°çŸ¥è¯†æ¥å®ç°ä¸€ä¸ªå¹¿æ’­èŠå¤©åº”ç”¨ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªèŠå¤©æœåŠ¡å™¨ï¼Œå®¢æˆ·ç«¯è¿æ¥åˆ°è¯¥æœåŠ¡å™¨å¹¶å‘å¸ƒä»–ä»¬çš„æ¶ˆæ¯ã€‚å®¢æˆ·ç«¯ä»æ ‡å‡†è¾“å…¥è¯»å–ç”¨æˆ·æ¶ˆæ¯ï¼Œå¹¶å°†å…¶å‘é€åˆ°æœåŠ¡å™¨ã€‚èŠå¤©æœåŠ¡å™¨å°†æ”¶åˆ°çš„æ¯æ¡æ¶ˆæ¯å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯ã€‚</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and <a href="https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/"><code>tokio_websockets</code></a> for the communication between the client and the server.</p>
<p>åˆ›å»ºä¸€ä¸ªæ–°çš„ Cargo é¡¹ç›®å¹¶æ·»åŠ ä»¥ä¸‹ä¾èµ–ï¼š</p>
<p><em>Cargo.toml</em>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;chat-async&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
futures-util = { version = &quot;0.3.28&quot;, features = [&quot;sink&quot;] }
http = &quot;0.2.9&quot;
tokio = { version = &quot;1.28.1&quot;, features = [&quot;full&quot;] }
tokio-websockets = { version = &quot;0.4.0&quot;, features = [&quot;client&quot;, &quot;fastrand&quot;, &quot;server&quot;, &quot;sha1_smol&quot;] }
</code></pre>
<h2><a class="header" href="#æ‰€éœ€çš„api" id="æ‰€éœ€çš„api">æ‰€éœ€çš„API</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and <a href="https://docs.rs/tokio-websockets/0.4.0/tokio_websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the API. </p>
<ul>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next">StreamExt::next()</a> implemented by <code>WebsocketStream</code>: for asynchronously reading messages from a Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> ç”±<code>WebsocketStream</code>å®ç°ï¼šç”¨äºåœ¨Websocketæµä¸Šå¼‚æ­¥å‘é€æ¶ˆæ¯ã€‚</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages from the standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>ï¼šç”¨äºè®¢é˜…å¹¿æ’­é¢‘é“ã€‚</li>
</ul>
<h2><a class="header" href="#ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶" id="ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶">ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶</a></h2>
<p>é€šå¸¸åœ¨ä¸€ä¸ªCargoé¡¹ç›®ä¸­ï¼Œä½ åªèƒ½æœ‰ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå’Œä¸€ä¸ª<code>src/main.rs</code>æ–‡ä»¶ã€‚åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ã€‚ä¸€ä¸ªç”¨äºå®¢æˆ·ç«¯ï¼Œå¦ä¸€ä¸ªç”¨äºæœåŠ¡å™¨ã€‚ä½ å¯èƒ½ä¼šè€ƒè™‘å°†å®ƒä»¬åˆ¶ä½œæˆä¸¤ä¸ªå•ç‹¬çš„Cargoé¡¹ç›®ï¼Œä½†æˆ‘ä»¬å°†å®ƒä»¬æ”¾åœ¨ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶çš„Cargoé¡¹ç›®ä¸­ã€‚ä¸ºäº†ä½¿è¿™ä¸ªå·¥ä½œï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨çš„ä»£ç åº”è¯¥æ”¾åœ¨<code>src/bin</code>ä¸‹ï¼ˆå‚è§<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">æ–‡æ¡£</a>ï¼‰ã€‚</p>
<p>å°†ä»¥ä¸‹æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä»£ç åˆ†åˆ«å¤åˆ¶åˆ° <code>src/bin/server.rs</code> å’Œ <code>src/bin/client.rs</code> ä¸­ã€‚æ‚¨çš„ä»»åŠ¡æ˜¯æŒ‰ç…§ä¸‹é¢çš„æè¿°å®Œæˆè¿™äº›æ–‡ä»¶ã€‚</p>
<p><em>src/bin/server.rs</em>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}
</code></pre></pre>
<h2><a class="header" href="#è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶" id="è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶">è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶</a></h2>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡ŒæœåŠ¡å™¨ï¼š</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2><a class="header" href="#ä»»åŠ¡-2" id="ä»»åŠ¡-2">ä»»åŠ¡</a></h2>
<ul>
<li>åœ¨ <code>src/bin/server.rs</code> ä¸­å®ç° <code>handle_connection</code> å‡½æ•°ã€‚
<ul>
<li>æç¤ºï¼šä½¿ç”¨ <code>tokio::select!</code> åœ¨ä¸€ä¸ªè¿ç»­çš„å¾ªç¯ä¸­å¹¶å‘æ‰§è¡Œä¸¤ä¸ªä»»åŠ¡ã€‚ä¸€ä¸ªä»»åŠ¡ä»å®¢æˆ·ç«¯æ¥æ”¶æ¶ˆæ¯å¹¶å¹¿æ’­å®ƒä»¬ã€‚å¦ä¸€ä¸ªä»»åŠ¡å°†æœåŠ¡å™¨æ¥æ”¶åˆ°çš„æ¶ˆæ¯å‘é€ç»™å®¢æˆ·ç«¯ã€‚</li>
</ul>
</li>
<li>å®Œæˆ <code>src/bin/client.rs</code> ä¸­çš„ <code>main</code> å‡½æ•°ã€‚
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently performing two tasks: (1) reading user messages from standard input and sending them to the server, and (2) receiving messages from the server, and displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all clients, but the sender of the message.</li>
</ul>
<h1><a class="header" href="#è°¢è°¢" id="è°¢è°¢">è°¢è°¢ï¼</a></h1>
<p><em>Thank you for taking Comprehensive Rust ğŸ¦€!</em> We hope you enjoyed it and that it was useful.</p>
<p>Weâ€™ve had a lot of fun putting the course together. The course is not perfect, so if you spotted any mistakes or have ideas for improvements, please get in <a href="https://github.com/google/comprehensive-rust/discussions">contact with us on GitHub</a>. We would love to hear from you.</p>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<p>The following is a glossary which aims to give a short definition of many Rust terms. For translations, this also serves to connect the term back to the English original.</p>
<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>
<!--
Translators: please add the English term in italic after your translated term.
Also, please keep the hard line breaks to ensure a nice formatting.
-->
<ul>
<li>allocate:<br />
Dynamic memory allocation on <a href="memory-management/stack-vs-heap.html">the heap</a>.</li>
<li>argument:</li>
<li>Bare-metal Rust: See <a href="bare-metal.html">Bare-metal Rust</a>.</li>
<li>block:<br />
See <a href="control-flow/blocks.html">Blocks</a> and <em>scope</em>.</li>
<li>borrow:<br />
See <a href="ownership/borrowing.html">Borrowing</a>.</li>
<li>borrow checker:<br />
The part of the Rust compiler which checks that all borrows are valid.</li>
<li>brace:<br />
<code>{</code> and <code>}</code>. Also called <em>curly brace</em>, they delimit <em>blocks</em>.</li>
<li>build:</li>
<li>call:</li>
<li>channel:<br />
Used to safely pass messages <a href="concurrency/channels.html">between threads</a>.</li>
<li>Comprehensive Rust ğŸ¦€:<br />
The courses here are jointly called Comprehensive Rust ğŸ¦€.</li>
<li>concurrency:</li>
<li>Concurrency in Rust:<br />
See <a href="concurrency.html">Concurrency in Rust</a>.</li>
<li>constant:</li>
<li>control flow:</li>
<li>crash:</li>
<li>enumeration:</li>
<li>error:</li>
<li>error handling:</li>
<li>exercise:</li>
<li>function:</li>
<li>garbage collector:</li>
<li>generics:</li>
<li>immutable:</li>
<li>integration test:</li>
<li>keyword:</li>
<li>library:</li>
<li>macro:</li>
<li>main function:</li>
<li>match:</li>
<li>memory leak:</li>
<li>method:</li>
<li>module:</li>
<li>move:</li>
<li>mutable:</li>
<li>ownership:</li>
<li>panic:</li>
<li>parameter:</li>
<li>pattern:</li>
<li>payload:</li>
<li>program:</li>
<li>programming language:</li>
<li>receiver:</li>
<li>reference counting:</li>
<li>return:</li>
<li>Rust:</li>
<li>Rust Fundamentals:<br />
Days 1 to 3 of this course.</li>
<li>Rust in Android:<br />
See <a href="android.html">Rust in Android</a>.</li>
<li>safe:</li>
<li>scope:</li>
<li>standard library:</li>
<li>static:</li>
<li>string:</li>
<li>struct:</li>
<li>test:</li>
<li>thread:</li>
<li>thread safety:</li>
<li>trait:</li>
<li>type:</li>
<li>type inference:</li>
<li>undefined behavior:</li>
<li>union:</li>
<li>unit test:</li>
<li>unsafe:</li>
<li>variable:\</li>
</ul>
<h1><a class="header" href="#å…¶ä»–-rust-èµ„æº" id="å…¶ä»–-rust-èµ„æº">å…¶ä»– Rust èµ„æº</a></h1>
<p>Rust ç¤¾åŒºå·²ç»åˆ›é€ äº†ä¸°å¯Œçš„é«˜è´¨é‡å…è´¹èµ„æºåœ¨çº¿æä¾›ã€‚</p>
<h2><a class="header" href="#å®˜æ–¹æ–‡æ¡£" id="å®˜æ–¹æ–‡æ¡£">å®˜æ–¹æ–‡æ¡£</a></h2>
<p>Rust é¡¹ç›®æä¾›äº†è®¸å¤šèµ„æºã€‚è¿™äº›èµ„æºæ¶µç›–äº† Rust çš„ä¸€èˆ¬å†…å®¹ï¼š</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>: the canonical free book about Rust. Covers the language in detail and includes a few projects for people to build.</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>: covers the Rust syntax via a series of examples which showcase different constructs. Sometimes includes small exercises where you are asked to expand on the code in the examples.</li>
<li><a href="https://doc.rust-lang.org/std/">Rust Standard Library</a>: full documentation of the standard library for Rust.</li>
<li><a href="https://doc.rust-lang.org/reference/">The Rust Reference</a>: an incomplete book which describes the Rust grammar and memory model.</li>
</ul>
<p>More specialized guides hosted on the official Rust site:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>: covers unsafe Rust, including working with raw pointers and interfacing with other languages (FFI).</li>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous Programming in Rust</a>: covers the new asynchronous programming model which was introduced after the Rust Book was written.</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">The Embedded Rust Book</a>: an introduction to using Rust on embedded devices without an operating system.</li>
</ul>
<h2><a class="header" href="#éå®˜æ–¹å­¦ä¹ èµ„æ–™" id="éå®˜æ–¹å­¦ä¹ èµ„æ–™">éå®˜æ–¹å­¦ä¹ èµ„æ–™</a></h2>
<p>å…¶ä»– Rust æŒ‡å—å’Œæ•™ç¨‹çš„å°é€‰é›†ï¼š</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Way</a>: covers Rust from the perspective of low-level C programmers.</li>
<li><a href="https://docs.opentitan.org/doc/ug/rust_for_c/">Rust for Embedded C Programmers</a>: covers Rust from the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionals</a>: covers the syntax of Rust using side-by-side comparisons with other languages such as C, C++, Java, JavaScript, and Python.</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercism</a>: 100+ exercises to help you learn Rust.</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching Material</a>: a series of small presentations covering both basic and advanced part of the Rust language. Other topics such as WebAssembly, and async/await are also covered.</li>
<li><a href="https://docs.microsoft.com/en-us/shows/beginners-series-to-rust/">Beginnerâ€™s Series to Rust</a> and <a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Take your first steps with Rust</a>: two Rust guides aimed at new developers. The first is a set of 35 videos and the second is a set of 11 modules which covers Rust syntax and basic constructs.</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists</a>: in-depth exploration of Rustâ€™s memory management rules, through implementing a few different types of list structures.</li>
</ul>
<p>Please see the <a href="https://lborb.github.io/book/">Little Book of Rust Books</a> for even more Rust books.</p>
<h1><a class="header" href="#é¸£è°¢" id="é¸£è°¢">é¸£è°¢</a></h1>
<p>æœ¬è¯¾ä¸­çš„èµ„æ–™ä»¥ä¼—å¤šä¼˜ç§€çš„ Rust æ–‡æ¡£èµ„æºä¸ºåŸºç¡€ã€‚ å¦‚éœ€æŸ¥çœ‹å®ç”¨èµ„æºçš„å®Œæ•´åˆ—è¡¨ï¼Œ è¯·å‚é˜…å…³äº<a href="other-resources.html">å…¶ä»–èµ„æº</a>çš„é¡µé¢ã€‚</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0 license, please see <a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for details.</p>
<h2><a class="header" href="#rust-ç¤ºä¾‹" id="rust-ç¤ºä¾‹">Rust ç¤ºä¾‹</a></h2>
<p>éƒ¨åˆ†ç¤ºä¾‹å’Œç»ƒä¹ å¤åˆ¶å¹¶ æ”¹ç¼–è‡ª<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯ æ¡æ¬¾ï¼‰ï¼Œè¯·å‚é˜… <code>third_party/rust-by-example/</code> ç›®å½•ã€‚</p>
<h2><a class="header" href="#rust-on-exercism" id="rust-on-exercism">Rust on Exercism</a></h2>
<p>éƒ¨åˆ†ç»ƒä¹ å¤åˆ¶å¹¶ æ”¹ç¼–è‡ª <a href="https://exercism.org/tracks/rust">Rust on Exercism</a>ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯ æ¡æ¬¾ï¼‰ï¼Œè¯·å‚é˜… <code>third_party/rust-on-exercism/</code> ç›®å½•ã€‚</p>
<h2><a class="header" href="#cxx" id="cxx">CXX</a></h2>
<p>â€œ<a href="android/interoperability/cpp.html">ä¸ C++ çš„äº’æ“ä½œæ€§</a>â€éƒ¨åˆ†å¼•ç”¨äº†ä¸€å¼  æ¥è‡ª <a href="https://cxx.rs/">CXX</a> çš„å›¾ç‰‡ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯æ¡æ¬¾ï¼‰ï¼Œ è¯·å‚é˜… <code>third_party/cxx/</code> ç›®å½•ã€‚</p>
<h2><a class="header" href="#an-example-in-c-1" id="an-example-in-c-1">An Example in C</a></h2>
<p>The <a href="why-rust/an-example-in-c.html">Why Rust? - An Example in C</a> section has been taken from the presentation slides of <a href="https://colinfinck.de/Master_Thesis_Colin_Finck.pdf">Colin Finckâ€™s Master Thesis</a>. It has been relicensed under the terms of the Apache 2.0 license for this course by the author.</p>
<h1><a class="header" href="#è§£ç­”" id="è§£ç­”">è§£ç­”</a></h1>
<p>æ‚¨å°†åœ¨ä¸‹é¢çš„é¡µé¢æ‰¾åˆ°ç»ƒä¹ çš„è§£ç­”ã€‚</p>
<p>æ¬¢è¿æ‚¨åœ¨ <a href="https://github.com/google/comprehensive-rust/discussions">GitHub</a> ä¸Šæé—®å…³äºè§£å†³æ–¹æ¡ˆçš„é—®é¢˜ã€‚å¦‚æœæ‚¨æœ‰ä¸æ­¤å¤„å‘ˆç°çš„ä¸åŒæˆ–æ›´å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œè¯·å‘Šè¯‰æˆ‘ä»¬ã€‚</p>
<h1><a class="header" href="#ç¬¬ä¸€å¤©ä¸Šåˆçš„ç»ƒä¹ " id="ç¬¬ä¸€å¤©ä¸Šåˆçš„ç»ƒä¹ ">ç¬¬ä¸€å¤©ä¸Šåˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#æ•°ç»„ä¸-for-å¾ªç¯-1" id="æ•°ç»„ä¸-for-å¾ªç¯-1">æ•°ç»„ä¸ <code>for</code> å¾ªç¯</a></h2>
<p>(<a href="exercises/day-1/for-loops.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}

fn pretty_print(matrix: &amp;[[i32; 3]; 3]) {
    for row in matrix {
        println!(&quot;{row:?}&quot;);
    }
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix:&quot;);
    pretty_print(&amp;matrix);

    let transposed = transpose(matrix);
    println!(&quot;transposed:&quot;);
    pretty_print(&amp;transposed);
}
</code></pre></pre>
<h3><a class="header" href="#é™„åŠ é—®é¢˜" id="é™„åŠ é—®é¢˜">é™„åŠ é—®é¢˜</a></h3>
<p>è¿™éœ€è¦æ›´é«˜çº§çš„æ¦‚å¿µã€‚çœ‹èµ·æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡çš„åˆ‡ç‰‡ï¼ˆ<code>&amp;[&amp;[i32]]</code>ï¼‰ä½œä¸ºè¾“å…¥ç±»å‹æ¥è¿›è¡Œè½¬ç½®ï¼Œä»è€Œä½¿æˆ‘ä»¬çš„å‡½æ•°èƒ½å¤Ÿå¤„ç†ä»»æ„å¤§å°çš„çŸ©é˜µã€‚ç„¶è€Œï¼Œè¿™å¾ˆå¿«å°±ä¼šå´©æºƒï¼šè¿”å›ç±»å‹ä¸èƒ½æ˜¯ <code>&amp;[&amp;[i32]]</code>ï¼Œå› ä¸ºå®ƒéœ€è¦æ‹¥æœ‰æ‚¨è¿”å›çš„æ•°æ®ã€‚</p>
<p>æ‚¨å¯ä»¥å°è¯•ä½¿ç”¨ç±»ä¼¼ <code>Vec&lt;Vec&lt;i32&gt;&gt;</code> çš„æ–¹å¼ï¼Œä½†è¿™ä¹Ÿæ— æ³•ç›´æ¥å·¥ä½œï¼šä» <code>Vec&lt;Vec&lt;i32&gt;&gt;</code> è½¬æ¢ä¸º <code>&amp;[&amp;[i32]]</code> å¾ˆå›°éš¾ï¼Œå› æ­¤æ‚¨ç°åœ¨ä¹Ÿä¸èƒ½è½»æ¾ä½¿ç”¨ <code>pretty_print</code>ã€‚</p>
<p>Once we get to traits and generics, weâ€™ll be able to use the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>std::convert::AsRef</code></a> trait to abstract over anything that can be referenced as a slice.</p>
<pre><pre class="playground"><code class="language-rust">use std::convert::AsRef;
use std::fmt::Debug;

fn pretty_print&lt;T, Line, Matrix&gt;(matrix: Matrix)
where
    T: Debug,
    // A line references a slice of items
    Line: AsRef&lt;[T]&gt;,
    // A matrix references a slice of lines
    Matrix: AsRef&lt;[Line]&gt;
{
    for row in matrix.as_ref() {
        println!(&quot;{:?}&quot;, row.as_ref());
    }
}

fn main() {
    // &amp;[&amp;[i32]]
    pretty_print(&amp;[&amp;[1, 2, 3], &amp;[4, 5, 6], &amp;[7, 8, 9]]);
    // [[&amp;str; 2]; 2]
    pretty_print([[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]);
    // Vec&lt;Vec&lt;i32&gt;&gt;
    pretty_print(vec![vec![1, 2], vec![3, 4]]);
}
</code></pre></pre>
<p>æ­¤å¤–ï¼Œç±»å‹æœ¬èº«ä¸ä¼šå¼ºåˆ¶è¦æ±‚å­åˆ‡ç‰‡å…·æœ‰ç›¸åŒçš„é•¿åº¦ï¼Œå› æ­¤è¿™æ ·çš„å˜é‡å¯èƒ½åŒ…å«ä¸€ä¸ªæ— æ•ˆçš„çŸ©é˜µã€‚</p>
<h1><a class="header" href="#ç¬¬ä¸€å¤©ä¸‹åˆçš„ç»ƒä¹ " id="ç¬¬ä¸€å¤©ä¸‹åˆçš„ç»ƒä¹ ">ç¬¬ä¸€å¤©ä¸‹åˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#luhn-ç®—æ³•-1" id="luhn-ç®—æ³•-1">Luhn ç®—æ³•</a></h2>
<p>(<a href="exercises/day-1/luhn.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut digits_seen = 0;
    let mut sum = 0;
    for (i, ch) in cc_number.chars().rev().filter(|&amp;ch| ch != ' ').enumerate() {
        match ch.to_digit(10) {
            Some(d) =&gt; {
                sum += if i % 2 == 1 {
                    let dd = d * 2;
                    dd / 10 + dd % 10
                } else {
                    d
                };
                digits_seen += 1;
            }
            None =&gt; return false,
        }
    }

    if digits_seen &lt; 2 {
        return false;
    }

    sum % 10 == 0
}

fn main() {
    let cc_number = &quot;1234 5678 1234 5670&quot;;
    println!(
        &quot;Is {cc_number} a valid credit card number? {}&quot;,
        if luhn(cc_number) { &quot;yes&quot; } else { &quot;no&quot; }
    );
}

#[test]
fn test_non_digit_cc_number() {
    assert!(!luhn(&quot;foo&quot;));
    assert!(!luhn(&quot;foo 0 0&quot;));
}

#[test]
fn test_empty_cc_number() {
    assert!(!luhn(&quot;&quot;));
    assert!(!luhn(&quot; &quot;));
    assert!(!luhn(&quot;  &quot;));
    assert!(!luhn(&quot;    &quot;));
}

#[test]
fn test_single_digit_cc_number() {
    assert!(!luhn(&quot;0&quot;));
}

#[test]
fn test_two_digit_cc_number() {
    assert!(luhn(&quot; 0 0 &quot;));
}

#[test]
fn test_valid_cc_number() {
    assert!(luhn(&quot;4263 9826 4026 9299&quot;));
    assert!(luhn(&quot;4539 3195 0343 6467&quot;));
    assert!(luhn(&quot;7992 7398 713&quot;));
}

#[test]
fn test_invalid_cc_number() {
    assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
    assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
    assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h2>
<pre><pre class="playground"><code class="language-rust">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op {
        op: Operation,
        left: Box&lt;Expression&gt;,
        right: Box&lt;Expression&gt;,
    },

    /// A literal value
    Value(i64),
}

/// The result of evaluating an expression.
#[derive(Debug, PartialEq, Eq)]
enum Res {
    /// Evaluation was successful, with the given result.
    Ok(i64),
    /// Evaluation failed, with the given error message.
    Err(String),
}
// Allow `Ok` and `Err` as shorthands for `Res::Ok` and `Res::Err`.
use Res::{Err, Ok};

fn eval(e: Expression) -&gt; Res {
    match e {
        Expression::Op { op, left, right } =&gt; {
            let left = match eval(*left) {
                Ok(v) =&gt; v,
                Err(msg) =&gt; return Err(msg),
            };
            let right = match eval(*right) {
                Ok(v) =&gt; v,
                Err(msg) =&gt; return Err(msg),
            };
            Ok(match op {
                Operation::Add =&gt; left + right,
                Operation::Sub =&gt; left - right,
                Operation::Mul =&gt; left * right,
                Operation::Div =&gt; {
                    if right == 0 {
                        return Err(String::from(&quot;division by zero&quot;));
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) =&gt; Ok(v),
    }
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
fn main() {
    let expr = Expression::Op {
        op: Operation::Sub,
        left: Box::new(Expression::Value(20)),
        right: Box::new(Expression::Value(10)),
    };
    println!(&quot;expr: {:?}&quot;, expr);
    println!(&quot;result: {:?}&quot;, eval(expr));
}
</code></pre></pre>
<h1><a class="header" href="#ç¬¬äºŒå¤©ä¸Šåˆçš„ç»ƒä¹ " id="ç¬¬äºŒå¤©ä¸Šåˆçš„ç»ƒä¹ ">ç¬¬äºŒå¤©ä¸Šåˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#è®¾è®¡ä¸€ä¸ªåº“" id="è®¾è®¡ä¸€ä¸ªåº“">è®¾è®¡ä¸€ä¸ªåº“</a></h2>
<p>(<a href="exercises/day-2/book-library.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">struct Library {
    books: Vec&lt;Book&gt;,
}

struct Book {
    title: String,
    year: u16,
}

impl Book {
    // This is a constructor, used below.
    fn new(title: &amp;str, year: u16) -&gt; Book {
        Book {
            title: String::from(title),
            year,
        }
    }
}

// Implement the methods below. Notice how the `self` parameter
// changes type to indicate the method's required level of ownership
// over the object:
//
// - `&amp;self` for shared read-only access,
// - `&amp;mut self` for unique and mutable access,
// - `self` for unique access by value.
impl Library {

    fn new() -&gt; Library {
        Library { books: Vec::new() }
    }

    fn len(&amp;self) -&gt; usize {
        self.books.len()
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.books.is_empty()
    }

    fn add_book(&amp;mut self, book: Book) {
        self.books.push(book)
    }

    fn print_books(&amp;self) {
        for book in &amp;self.books {
            println!(&quot;{}, published in {}&quot;, book.title, book.year);
        }
    }

    fn oldest_book(&amp;self) -&gt; Option&lt;&amp;Book&gt; {
        // Using a closure and a built-in method:
        // self.books.iter().min_by_key(|book| book.year)

        // Longer hand-written solution:
        let mut oldest: Option&lt;&amp;Book&gt; = None;
        for book in self.books.iter() {
            if oldest.is_none() || book.year &lt; oldest.unwrap().year {
                oldest = Some(book);
            }
        }

        oldest
    }
}

fn main() {
    let mut library = Library::new();

    println!(
        &quot;The library is empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));

    println!(
        &quot;The library is no longer empty: library.is_empty() -&gt; {}&quot;,
        library.is_empty()
    );

    library.print_books();

    match library.oldest_book() {
        Some(book) =&gt; println!(&quot;The oldest book is {}&quot;, book.title),
        None =&gt; println!(&quot;The library is empty!&quot;),
    }

    println!(&quot;The library has {} books&quot;, library.len());
    library.print_books();
}

#[test]
fn test_library_len() {
    let mut library = Library::new();
    assert_eq!(library.len(), 0);
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(library.len(), 2);
    assert!(!library.is_empty());
}

#[test]
fn test_library_is_empty() {
    let mut library = Library::new();
    assert!(library.is_empty());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert!(!library.is_empty());
}

#[test]
fn test_library_print_books() {
    let mut library = Library::new();
    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    // We could try and capture stdout, but let us just call the
    // method to start with.
    library.print_books();
}

#[test]
fn test_library_oldest_book() {
    let mut library = Library::new();
    assert!(library.oldest_book().is_none());

    library.add_book(Book::new(&quot;Lord of the Rings&quot;, 1954));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Lord of the Rings&quot;)
    );

    library.add_book(Book::new(&quot;Alice's Adventures in Wonderland&quot;, 1865));
    assert_eq!(
        library.oldest_book().map(|b| b.title.as_str()),
        Some(&quot;Alice's Adventures in Wonderland&quot;)
    );
}
</code></pre></pre>
<h2><a class="header" href="#å¥åº·ç»Ÿè®¡-1" id="å¥åº·ç»Ÿè®¡-1">å¥åº·ç»Ÿè®¡</a></h2>
<p>(<a href="exercises/day-2/health-statistics.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust">pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self {
            name,
            age,
            height,
            visit_count: 0,
            last_blood_pressure: None,
        }
    }

    pub fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    pub fn age(&amp;self) -&gt; u32 {
        self.age
    }

    pub fn height(&amp;self) -&gt; f32 {
        self.height
    }

    pub fn doctor_visits(&amp;self) -&gt; u32 {
        self.visit_count as u32
    }

    pub fn set_age(&amp;mut self, new_age: u32) {
        self.age = new_age
    }

    pub fn set_height(&amp;mut self, new_height: f32) {
        self.height = new_height
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &amp;self.name,
            visit_count: self.visit_count as u32,
            height_change: measurements.height - self.height,
            blood_pressure_change: match self.last_blood_pressure {
                Some(lbp) =&gt; Some((
                    bp.0 as i32 - lbp.0 as i32,
                    bp.1 as i32 - lbp.1 as i32
                )),
                None =&gt; None,
            }
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name(), bob.age());
}

#[test]
fn test_height() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.height(), 155.2);
}

#[test]
fn test_set_age() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.age(), 32);
    bob.set_age(33);
    assert_eq!(bob.age(), 33);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.doctor_visits(), 0);
    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (120, 80),
    });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);

    let report = bob.visit_doctor(Measurements {
        height: 156.1,
        blood_pressure: (115, 76),
    });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
}
</code></pre></pre>
<h1><a class="header" href="#ç¬¬äºŒå¤©ä¸‹åˆçš„ç»ƒä¹ " id="ç¬¬äºŒå¤©ä¸‹åˆçš„ç»ƒä¹ ">ç¬¬äºŒå¤©ä¸‹åˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨-1" id="å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨-1">å­—ç¬¦ä¸²å’Œè¿­ä»£å™¨</a></h2>
<p>(<a href="exercises/day-2/strings-iterators.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">pub fn prefix_matches(prefix: &amp;str, request_path: &amp;str) -&gt; bool {

    let mut request_segments = request_path.split('/');

    for prefix_segment in prefix.split('/') {
        let Some(request_segment) = request_segments.next() else {
            return false;
        };
        if request_segment != prefix_segment &amp;&amp; prefix_segment != &quot;*&quot; {
            return false;
        }
    }
    true

    // Alternatively, Iterator::zip() lets us iterate simultaneously over prefix
    // and request segments. The zip() iterator is finished as soon as one of
    // the source iterators is finished, but we need to iterate over all request
    // segments. A neat trick that makes zip() work is to use map() and chain()
    // to produce an iterator that returns Some(str) for each pattern segments,
    // and then returns None indefinitely.
}

#[test]
fn test_matches_without_wildcard() {
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc-123&quot;));
    assert!(prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishers/abc/books&quot;));

    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/publishersBooks&quot;));
    assert!(!prefix_matches(&quot;/v1/publishers&quot;, &quot;/v1/parent/publishers&quot;));
}

#[test]
fn test_matches_with_wildcard() {
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/bar/books&quot;
    ));
    assert!(prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/books/book1&quot;
    ));

    assert!(!prefix_matches(&quot;/v1/publishers/*/books&quot;, &quot;/v1/publishers&quot;));
    assert!(!prefix_matches(
        &quot;/v1/publishers/*/books&quot;,
        &quot;/v1/publishers/foo/booksByAuthor&quot;
    ));
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#ç¬¬ä¸‰å¤©ä¸Šåˆçš„ç»ƒä¹ " id="ç¬¬ä¸‰å¤©ä¸Šåˆçš„ç»ƒä¹ ">ç¬¬ä¸‰å¤©ä¸Šåˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#drawing-a-simple-gui-1" id="drawing-a-simple-gui-1">Drawing A Simple GUI</a></h2>
<p>(<a href="exercises/day-3/simple-gui.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label {
            label: label.to_owned(),
        }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button {
            label: Label::new(label),
        }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window {
            title: title.to_owned(),
            widgets: Vec::new(),
        }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}


impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        self.label
            .lines()
            .map(|line| line.chars().count())
            .max()
            .unwrap_or(0)
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(
        &quot;Click me!&quot;
    )));
    window.draw();
}
</code></pre></pre>
<h2><a class="header" href="#ç‚¹å’Œå¤šè¾¹å½¢" id="ç‚¹å’Œå¤šè¾¹å½¢">ç‚¹å’Œå¤šè¾¹å½¢</a></h2>
<p>(<a href="exercises/day-3/points-polygons.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Point {
    x: i32,
    y: i32,
}

impl Point {
    pub fn new(x: i32, y: i32) -&gt; Point {
        Point { x, y }
    }

    pub fn magnitude(self) -&gt; f64 {
        f64::from(self.x.pow(2) + self.y.pow(2)).sqrt()
    }

    pub fn dist(self, other: Point) -&gt; f64 {
        (self - other).magnitude()
    }
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl std::ops::Sub for Point {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

pub struct Polygon {
    points: Vec&lt;Point&gt;,
}

impl Polygon {
    pub fn new() -&gt; Polygon {
        Polygon { points: Vec::new() }
    }

    pub fn add_point(&amp;mut self, point: Point) {
        self.points.push(point);
    }

    pub fn left_most_point(&amp;self) -&gt; Option&lt;Point&gt; {
        self.points.iter().min_by_key(|p| p.x).copied()
    }

    pub fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Point&gt; {
        self.points.iter()
    }

    pub fn length(&amp;self) -&gt; f64 {
        if self.points.is_empty() {
            return 0.0;
        }

        let mut result = 0.0;
        let mut last_point = self.points[0];
        for point in &amp;self.points[1..] {
            result += last_point.dist(*point);
            last_point = *point;
        }
        result += last_point.dist(self.points[0]);
        result
        // Alternatively, Iterator::zip() lets us iterate over the points as pairs
        // but we need to pair each point with the next one, and the last point
        // with the first point. The zip() iterator is finished as soon as one of 
        // the source iterators is finished, a neat trick is to combine Iterator::cycle
        // with Iterator::skip to create the second iterator for the zip and using map 
        // and sum to calculate the total length.
    }
}

pub struct Circle {
    center: Point,
    radius: i32,
}

impl Circle {
    pub fn new(center: Point, radius: i32) -&gt; Circle {
        Circle { center, radius }
    }

    pub fn circumference(&amp;self) -&gt; f64 {
        2.0 * std::f64::consts::PI * f64::from(self.radius)
    }

    pub fn dist(&amp;self, other: &amp;Self) -&gt; f64 {
        self.center.dist(other.center)
    }
}

pub enum Shape {
    Polygon(Polygon),
    Circle(Circle),
}

impl From&lt;Polygon&gt; for Shape {
    fn from(poly: Polygon) -&gt; Self {
        Shape::Polygon(poly)
    }
}

impl From&lt;Circle&gt; for Shape {
    fn from(circle: Circle) -&gt; Self {
        Shape::Circle(circle)
    }
}

impl Shape {
    pub fn perimeter(&amp;self) -&gt; f64 {
        match self {
            Shape::Polygon(poly) =&gt; poly.length(),
            Shape::Circle(circle) =&gt; circle.circumference(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn round_two_digits(x: f64) -&gt; f64 {
        (x * 100.0).round() / 100.0
    }

    #[test]
    fn test_point_magnitude() {
        let p1 = Point::new(12, 13);
        assert_eq!(round_two_digits(p1.magnitude()), 17.69);
    }

    #[test]
    fn test_point_dist() {
        let p1 = Point::new(10, 10);
        let p2 = Point::new(14, 13);
        assert_eq!(round_two_digits(p1.dist(p2)), 5.00);
    }

    #[test]
    fn test_point_add() {
        let p1 = Point::new(16, 16);
        let p2 = p1 + Point::new(-4, 3);
        assert_eq!(p2, Point::new(12, 19));
    }

    #[test]
    fn test_polygon_left_most_point() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);
        assert_eq!(poly.left_most_point(), Some(p1));
    }

    #[test]
    fn test_polygon_iter() {
        let p1 = Point::new(12, 13);
        let p2 = Point::new(16, 16);

        let mut poly = Polygon::new();
        poly.add_point(p1);
        poly.add_point(p2);

        let points = poly.iter().cloned().collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(points, vec![Point::new(12, 13), Point::new(16, 16)]);
    }

    #[test]
    fn test_shape_perimeters() {
        let mut poly = Polygon::new();
        poly.add_point(Point::new(12, 13));
        poly.add_point(Point::new(17, 11));
        poly.add_point(Point::new(16, 16));
        let shapes = vec![
            Shape::from(poly),
            Shape::from(Circle::new(Point::new(10, 20), 5)),
        ];
        let perimeters = shapes
            .iter()
            .map(Shape::perimeter)
            .map(round_two_digits)
            .collect::&lt;Vec&lt;_&gt;&gt;();
        assert_eq!(perimeters, vec![15.48, 31.42]);
    }
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#ç¬¬ä¸‰å¤©ä¸‹åˆçš„ç»ƒä¹ " id="ç¬¬ä¸‰å¤©ä¸‹åˆçš„ç»ƒä¹ ">ç¬¬ä¸‰å¤©ä¸‹åˆçš„ç»ƒä¹ </a></h1>
<h2><a class="header" href="#å®‰å…¨-ffi-å°è£…å®¹å™¨-1" id="å®‰å…¨-ffi-å°è£…å®¹å™¨-1">å®‰å…¨ FFI å°è£…å®¹å™¨</a></h2>
<p>(<a href="exercises/day-3/safe-ffi-wrapper.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust">mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_ulong, c_ushort, c_uchar};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    extern &quot;C&quot; {
        pub fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        let path = CString::new(path).map_err(|err| format!(&quot;Invalid path: {err}&quot;))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!(&quot;Could not open {:?}&quot;, path))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        if !self.dir.is_null() {
            // SAFETY: self.dir is not NULL.
            if unsafe { ffi::closedir(self.dir) } != 0 {
                panic!(&quot;Could not close {:?}&quot;, self.path);
            }
        }
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new(&quot;no-such-directory&quot;);
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join(&quot;foo.txt&quot;), &quot;The Foo Diaries\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;bar.png&quot;), &quot;&lt;PNG&gt;\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;crab.rs&quot;), &quot;//! Crab\n&quot;)?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;, &quot;bar.png&quot;, &quot;crab.rs&quot;, &quot;foo.txt&quot;]);
        Ok(())
    }
}
</code></pre></pre>
<h1><a class="header" href="#bare-metal-rust-morning-exercise" id="bare-metal-rust-morning-exercise">Bare Metal Rust Morning Exercise</a></h1>
<h2><a class="header" href="#ç½—ç›˜-1" id="ç½—ç›˜-1">ç½—ç›˜</a></h2>
<p>(<a href="exercises/bare-metal/compass.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use core::cmp::{max, min};
use lsm303agr::{AccelOutputDataRate, Lsm303agr, MagOutputDataRate};
use microbit::display::blocking::Display;
use microbit::hal::prelude::*;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::Timer;
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

#[entry]
fn main() -&gt; ! {
    let board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Set up the I2C controller and Inertial Measurement Unit.
    writeln!(serial, &quot;Setting up IMU...&quot;).unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_odr(MagOutputDataRate::Hz50).unwrap();
    imu.set_accel_odr(AccelOutputDataRate::Hz50).unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        while !(imu.mag_status().unwrap().xyz_new_data
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data)
        {}
        let compass_reading = imu.mag_data().unwrap();
        let accelerometer_reading = imu.accel_data().unwrap();
        writeln!(
            serial,
            &quot;{},{},{}\t{},{},{}&quot;,
            compass_reading.x,
            compass_reading.y,
            compass_reading.z,
            accelerometer_reading.x,
            accelerometer_reading.y,
            accelerometer_reading.z,
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
                scale(compass_reading.y, -COMPASS_SCALE, COMPASS_SCALE, 0, 4) as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y,
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(
        min_out + range_out * (value - min_in) / range_in,
        min_out,
        max_out,
    )
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}
</code></pre></pre>
<h1><a class="header" href="#åµŒå…¥å¼-rustè¿›é˜¶ç¯‡" id="åµŒå…¥å¼-rustè¿›é˜¶ç¯‡">åµŒå…¥å¼ Rustï¼šè¿›é˜¶ç¯‡</a></h1>
<h2><a class="header" href="#rtc-driver-1" id="rtc-driver-1">RTC driver</a></h2>
<p>(<a href="exercises/bare-metal/rtc.html">è¿”å›ç»ƒä¹ </a>)</p>
<p><em>main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

#[no_mangle]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // Safe because `PL011_BASE_ADDRESS` is the base address of a PL011 device,
    // and nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // Safe because `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // Safe because `PL031_BASE_ADDRESS` is the base address of a PL031 device,
    // and nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!(&quot;RTC: {time}&quot;);

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!(
        &quot;Waiting for {}&quot;,
        Utc.timestamp_opt(target.into(), 0).unwrap()
    );
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>pl031.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ptr::{addr_of, addr_of_mut};

#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self {
            registers: base_address as *mut Registers,
        }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of!((*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        let ris = unsafe { addr_of!((*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // Safe because we know that self.registers points to the control
        // registers of a PL031 device which is appropriately mapped.
        unsafe { addr_of_mut!((*self.registers).icr).write_volatile(0x01) }
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#å¹¶å‘ç¼–ç¨‹ä¸Šåˆç»ƒä¹ " id="å¹¶å‘ç¼–ç¨‹ä¸Šåˆç»ƒä¹ ">å¹¶å‘ç¼–ç¨‹ï¼šä¸Šåˆç»ƒä¹ </a></h1>
<h2><a class="header" href="#å“²å­¦å®¶å°±é¤é—®é¢˜-dining-philosophers-problem-1" id="å“²å­¦å®¶å°±é¤é—®é¢˜-dining-philosophers-problem-1">å“²å­¦å®¶å°±é¤é—®é¢˜ (Dining philosophers problem)</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        println!(&quot;{} is trying to eat&quot;, &amp;self.name);
        let left = self.left_fork.lock().unwrap();
        let right = self.right_fork.lock().unwrap();

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

fn main() {
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!(&quot;{thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#link-checker" id="link-checker">Link Checker</a></h2>
<p>(<a href="exercises/concurrency/link-checker.html">back to exercise</a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::{sync::Arc, sync::Mutex, sync::mpsc, thread};

use reqwest::{blocking::Client, Url};
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState {
            domain: start_url.domain().unwrap().to_string(),
            visited_pages,
        }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning true if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!(&quot;Got crawling error: {:#}&quot;, error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let bad_urls = check_links(start_url);
    println!(&quot;Bad URLs: {:#?}&quot;, bad_urls);
}
</code></pre></pre>
<h1><a class="header" href="#å¹¶å‘ç¼–ç¨‹ä¸‹åˆç»ƒä¹ " id="å¹¶å‘ç¼–ç¨‹ä¸‹åˆç»ƒä¹ ">å¹¶å‘ç¼–ç¨‹ï¼šä¸‹åˆç»ƒä¹ </a></h1>
<h2><a class="header" href="#å“²å­¦å®¶è¿›é¤---å¼‚æ­¥-1" id="å“²å­¦å®¶è¿›é¤---å¼‚æ­¥-1">å“²å­¦å®¶è¿›é¤ - å¼‚æ­¥</a></h2>
<p>(<a href="exercises/concurrency/dining-philosophers-async.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::time;
use tokio::sync::mpsc::{self, Sender};
use tokio::sync::Mutex;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: Sender&lt;String&gt;,
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name)).await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Pick up forks...
        let _first_lock = self.left_fork.lock().await;
        // Add a delay before picking the second fork to allow the execution
        // to transfer to another task
        time::sleep(time::Duration::from_millis(1)).await;
        let _second_lock = self.right_fork.lock().await;

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;

        // The locks are dropped here
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Thales&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let left_fork = Arc::clone(&amp;forks[i]);
            let right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            // To avoid a deadlock, we have to break the symmetry
            // somewhere. This will swap the forks without deinitializing
            // either of them.
            if i  == 0 {
                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });

    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!(&quot;Here is a thought: {thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº-1" id="å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº-1">å¹¿æ’­èŠå¤©åº”ç”¨ç¨‹åº</a></h2>
<p>(<a href="exercises/concurrency/chat-app.html">back to exercise</a>)</p>
<p><em>src/bin/server.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebsocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebsocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    ws_stream
        .send(Message::text(&quot;Welcome to chat! Type a message&quot;.into()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From client {addr:?} {text:?}&quot;);
                            bcast_tx.send(text.into())?;
                        }
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From server: {}&quot;, text);
                        }
                    },
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script>
            window.playground_line_numbers = true;
        </script>
        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        

        
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        
        <script src="theme/speaker-notes.js"></script>
        

        
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </div>
    </body>
</html>
