<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Comprehensive Rust ğŸ¦€</title>
        
        <meta name="robots" content="noindex">
        
        


        <!-- Custom HTML head -->
        <script async src="https://www.gstatic.com/brandstudio/kato/cookie_choice_component/cookie_consent_bar.v3.js"
        data-autoload-cookie-consent-bar="true"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZN78TEJMRW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-ZN78TEJMRW');
</script>


<script>
  (function () {
      // See these pages for details:
      // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
      // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
      let base = "https://google.github.io/comprehensive-rust";
      
      let canonical_href = `${base}/zh-CN/print.md`;
      

      // mdbook gives us a string ending in ".md", we replace it with ".html":
      canonical_href = canonical_href.slice(0, -"md".length) + "html";
      if (canonical_href.endsWith("/index.html")) {
          canonical_href = canonical_href.slice(0, -"index.html".length);
      }

      let link = document.createElement("link");
      link.rel = "canonical";
      link.href = canonical_href;
      document.head.appendChild(link);
  })()
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/svgbob.css">
        
        <link rel="stylesheet" href="theme/css/redbox.css">
        
        <link rel="stylesheet" href="theme/css/speaker-notes.css">
        
        <link rel="stylesheet" href="theme/css/language-picker.css">
        
        <link rel="stylesheet" href="theme/css/rtl.css">
        

        
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">æ¬¢è¿æ¥åˆ° Comprehensive Rust ğŸ¦€</a></li><li class="chapter-item "><a href="running-the-course.html"><strong aria-hidden="true">1.</strong> æˆè¯¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="running-the-course/course-structure.html"><strong aria-hidden="true">1.1.</strong> è¯¾ç¨‹ç»“æ„</a></li><li class="chapter-item "><a href="running-the-course/keyboard-shortcuts.html"><strong aria-hidden="true">1.2.</strong> é”®ç›˜å¿«æ·é”®</a></li><li class="chapter-item "><a href="running-the-course/translations.html"><strong aria-hidden="true">1.3.</strong> ç¿»è¯‘</a></li></ol></li><li class="chapter-item "><a href="cargo.html"><strong aria-hidden="true">2.</strong> ä½¿ç”¨ Cargo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/rust-ecosystem.html"><strong aria-hidden="true">2.1.</strong> Rust ç”Ÿæ€ç³»ç»Ÿ</a></li><li class="chapter-item "><a href="cargo/code-samples.html"><strong aria-hidden="true">2.2.</strong> ä»£ç ç¤ºä¾‹</a></li><li class="chapter-item "><a href="cargo/running-locally.html"><strong aria-hidden="true">2.3.</strong> åœ¨æœ¬åœ°è¿è¡Œ Cargo</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸€å¤©ï¼šä¸Šåˆ</li><li class="chapter-item "><a href="welcome-day-1.html"><strong aria-hidden="true">3.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="hello-world.html"><strong aria-hidden="true">4.</strong> Hello, World</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello-world/what-is-rust.html"><strong aria-hidden="true">4.1.</strong> ä»€ä¹ˆæ˜¯ Rustï¼Ÿ</a></li><li class="chapter-item "><a href="hello-world/benefits.html"><strong aria-hidden="true">4.2.</strong> Rust çš„ä¼˜åŠ¿</a></li><li class="chapter-item "><a href="hello-world/playground.html"><strong aria-hidden="true">4.3.</strong> Playground</a></li></ol></li><li class="chapter-item "><a href="types-and-values.html"><strong aria-hidden="true">5.</strong> ç±»å‹å’Œå€¼</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/hello-world.html"><strong aria-hidden="true">5.1.</strong> Hello, World</a></li><li class="chapter-item "><a href="types-and-values/variables.html"><strong aria-hidden="true">5.2.</strong> å˜é‡</a></li><li class="chapter-item "><a href="types-and-values/values.html"><strong aria-hidden="true">5.3.</strong> å€¼</a></li><li class="chapter-item "><a href="types-and-values/arithmetic.html"><strong aria-hidden="true">5.4.</strong> ç®—æœ¯</a></li><li class="chapter-item "><a href="types-and-values/inference.html"><strong aria-hidden="true">5.5.</strong> ç±»å‹æ¨å¯¼</a></li><li class="chapter-item "><a href="types-and-values/exercise.html"><strong aria-hidden="true">5.6.</strong> ç»ƒä¹ ï¼šFibonacci</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types-and-values/solution.html"><strong aria-hidden="true">5.6.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="control-flow-basics.html"><strong aria-hidden="true">6.</strong> æ§åˆ¶æµåŸºç¡€</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/if.html"><strong aria-hidden="true">6.1.</strong> if è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="control-flow-basics/loops.html"><strong aria-hidden="true">6.2.</strong> å¾ªç¯æ§åˆ¶</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/loops/for.html"><strong aria-hidden="true">6.2.1.</strong> for</a></li><li class="chapter-item "><a href="control-flow-basics/loops/loop.html"><strong aria-hidden="true">6.2.2.</strong> loop</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/break-continue.html"><strong aria-hidden="true">6.3.</strong> break å’Œ continue</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/break-continue/labels.html"><strong aria-hidden="true">6.3.1.</strong> Labels</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes.html"><strong aria-hidden="true">6.4.</strong> ä»£ç å—å’Œä½œç”¨åŸŸ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/blocks-and-scopes/scopes.html"><strong aria-hidden="true">6.4.1.</strong> ä½œç”¨åŸŸå’Œé®è”½ï¼ˆShadowingï¼‰</a></li></ol></li><li class="chapter-item "><a href="control-flow-basics/functions.html"><strong aria-hidden="true">6.5.</strong> å‡½æ•°</a></li><li class="chapter-item "><a href="control-flow-basics/macros.html"><strong aria-hidden="true">6.6.</strong> å®</a></li><li class="chapter-item "><a href="control-flow-basics/exercise.html"><strong aria-hidden="true">6.7.</strong> ç»ƒä¹ ï¼šè€ƒæ‹‰å…¹åºåˆ—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="control-flow-basics/solution.html"><strong aria-hidden="true">6.7.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸€å¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="welcome-day-1-afternoon.html"><strong aria-hidden="true">7.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="tuples-and-arrays.html"><strong aria-hidden="true">8.</strong> å…ƒç»„å’Œæ•°ç»„</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/arrays.html"><strong aria-hidden="true">8.1.</strong> æ•°ç»„ï¼ˆArraysï¼‰</a></li><li class="chapter-item "><a href="tuples-and-arrays/tuples.html"><strong aria-hidden="true">8.2.</strong> å…ƒç»„ï¼ˆTuplesï¼‰</a></li><li class="chapter-item "><a href="tuples-and-arrays/iteration.html"><strong aria-hidden="true">8.3.</strong> æ•°ç»„è¿­ä»£</a></li><li class="chapter-item "><a href="tuples-and-arrays/destructuring.html"><strong aria-hidden="true">8.4.</strong> è§£æ„</a></li><li class="chapter-item "><a href="tuples-and-arrays/exercise.html"><strong aria-hidden="true">8.5.</strong> ç»ƒä¹ ï¼šåµŒå¥—æ•°ç»„</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tuples-and-arrays/solution.html"><strong aria-hidden="true">8.5.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="references.html"><strong aria-hidden="true">9.</strong> å¼•ç”¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/shared.html"><strong aria-hidden="true">9.1.</strong> å…±äº«å¼•ç”¨</a></li><li class="chapter-item "><a href="references/exclusive.html"><strong aria-hidden="true">9.2.</strong> ç‹¬å å¼•ç”¨</a></li><li class="chapter-item "><a href="references/slices.html"><strong aria-hidden="true">9.3.</strong> åˆ‡ç‰‡</a></li><li class="chapter-item "><a href="references/strings.html"><strong aria-hidden="true">9.4.</strong> å­—ç¬¦ä¸²</a></li><li class="chapter-item "><a href="references/exercise.html"><strong aria-hidden="true">9.5.</strong> ç»ƒä¹ ï¼šå‡ ä½•å›¾å½¢</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/solution.html"><strong aria-hidden="true">9.5.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="user-defined-types.html"><strong aria-hidden="true">10.</strong> ç”¨æˆ·å®šä¹‰çš„ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/named-structs.html"><strong aria-hidden="true">10.1.</strong> ç»“æ„ä½“</a></li><li class="chapter-item "><a href="user-defined-types/tuple-structs.html"><strong aria-hidden="true">10.2.</strong> å…ƒç»„ç»“æ„ä½“</a></li><li class="chapter-item "><a href="user-defined-types/enums.html"><strong aria-hidden="true">10.3.</strong> æšä¸¾</a></li><li class="chapter-item "><a href="user-defined-types/const.html"><strong aria-hidden="true">10.4.</strong> å¸¸é‡</a></li><li class="chapter-item "><a href="user-defined-types/static.html"><strong aria-hidden="true">10.5.</strong> static</a></li><li class="chapter-item "><a href="user-defined-types/aliases.html"><strong aria-hidden="true">10.6.</strong> ç±»å‹åˆ«å</a></li><li class="chapter-item "><a href="user-defined-types/exercise.html"><strong aria-hidden="true">10.7.</strong> ç»ƒä¹ ï¼šç”µæ¢¯äº‹ä»¶</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user-defined-types/solution.html"><strong aria-hidden="true">10.7.1.</strong> è§£ç­”</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬äºŒå¤©ï¼šä¸Šåˆ</li><li class="chapter-item "><a href="welcome-day-2.html"><strong aria-hidden="true">11.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="pattern-matching.html"><strong aria-hidden="true">12.</strong> æ¨¡å¼åŒ¹é…</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/match.html"><strong aria-hidden="true">12.1.</strong> Matching Values</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-structs.html"><strong aria-hidden="true">12.2.</strong> Destructuring Structs</a></li><li class="chapter-item "><a href="pattern-matching/destructuring-enums.html"><strong aria-hidden="true">12.3.</strong> Destructuring Enums</a></li><li class="chapter-item "><a href="pattern-matching/let-control-flow.html"><strong aria-hidden="true">12.4.</strong> let æ§åˆ¶æµ</a></li><li class="chapter-item "><a href="pattern-matching/exercise.html"><strong aria-hidden="true">12.5.</strong> ç»ƒä¹ ï¼šè¡¨è¾¾å¼æ±‚å€¼</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-matching/solution.html"><strong aria-hidden="true">12.5.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="methods-and-traits.html"><strong aria-hidden="true">13.</strong> æ–¹æ³•å’Œç‰¹å¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/methods.html"><strong aria-hidden="true">13.1.</strong> æ–¹æ³•</a></li><li class="chapter-item "><a href="methods-and-traits/traits.html"><strong aria-hidden="true">13.2.</strong> ç‰¹å¾ï¼ˆTraitï¼‰</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/traits/implementing.html"><strong aria-hidden="true">13.2.1.</strong> å®ç° Unsafe Trait</a></li><li class="chapter-item "><a href="methods-and-traits/traits/supertraits.html"><strong aria-hidden="true">13.2.2.</strong> æ›´å¤š trait</a></li><li class="chapter-item "><a href="methods-and-traits/traits/associated-types.html"><strong aria-hidden="true">13.2.3.</strong> å…±äº«ç±»å‹</a></li></ol></li><li class="chapter-item "><a href="methods-and-traits/deriving.html"><strong aria-hidden="true">13.3.</strong> æ´¾ç”Ÿç‰¹å¾</a></li><li class="chapter-item "><a href="methods-and-traits/exercise.html"><strong aria-hidden="true">13.4.</strong> ç»ƒä¹ ï¼šé€šç”¨æ—¥å¿—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="methods-and-traits/solution.html"><strong aria-hidden="true">13.4.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬äºŒå¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="welcome-day-2-afternoon.html"><strong aria-hidden="true">14.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="generics.html"><strong aria-hidden="true">15.</strong> æ³›å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/generic-functions.html"><strong aria-hidden="true">15.1.</strong> æ³›å‹å‡½æ•°</a></li><li class="chapter-item "><a href="generics/generic-data.html"><strong aria-hidden="true">15.2.</strong> æ³›å‹ç±»å‹</a></li><li class="chapter-item "><a href="generics/generic-traits.html"><strong aria-hidden="true">15.3.</strong> æ³›å‹</a></li><li class="chapter-item "><a href="generics/trait-bounds.html"><strong aria-hidden="true">15.4.</strong> ç‰¹å¾è¾¹ç•Œ</a></li><li class="chapter-item "><a href="generics/impl-trait.html"><strong aria-hidden="true">15.5.</strong> impl Trait</a></li><li class="chapter-item "><a href="generics/dyn-trait.html"><strong aria-hidden="true">15.6.</strong> dyn Trait</a></li><li class="chapter-item "><a href="generics/exercise.html"><strong aria-hidden="true">15.7.</strong> ç»ƒä¹ ï¼šé€šç”¨ min å‡½æ•°</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/solution.html"><strong aria-hidden="true">15.7.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-types.html"><strong aria-hidden="true">16.</strong> æ ‡å‡†åº“ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/std.html"><strong aria-hidden="true">16.1.</strong> æ ‡å‡†åº“</a></li><li class="chapter-item "><a href="std-types/docs.html"><strong aria-hidden="true">16.2.</strong> æ–‡æ¡£</a></li><li class="chapter-item "><a href="std-types/option.html"><strong aria-hidden="true">16.3.</strong> Option</a></li><li class="chapter-item "><a href="std-types/result.html"><strong aria-hidden="true">16.4.</strong> Result</a></li><li class="chapter-item "><a href="std-types/string.html"><strong aria-hidden="true">16.5.</strong> String</a></li><li class="chapter-item "><a href="std-types/vec.html"><strong aria-hidden="true">16.6.</strong> Vec</a></li><li class="chapter-item "><a href="std-types/hashmap.html"><strong aria-hidden="true">16.7.</strong> HashMap</a></li><li class="chapter-item "><a href="std-types/exercise.html"><strong aria-hidden="true">16.8.</strong> ç»ƒä¹ ï¼šè®¡æ•°å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-types/solution.html"><strong aria-hidden="true">16.8.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="std-traits.html"><strong aria-hidden="true">17.</strong> æ ‡å‡†åº“ç‰¹å¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/comparisons.html"><strong aria-hidden="true">17.1.</strong> æ¯”è¾ƒ</a></li><li class="chapter-item "><a href="std-traits/operators.html"><strong aria-hidden="true">17.2.</strong> è¿ç®—ç¬¦</a></li><li class="chapter-item "><a href="std-traits/from-and-into.html"><strong aria-hidden="true">17.3.</strong> From å’Œ Into</a></li><li class="chapter-item "><a href="std-traits/casting.html"><strong aria-hidden="true">17.4.</strong> ç±»å‹è½¬æ¢</a></li><li class="chapter-item "><a href="std-traits/read-and-write.html"><strong aria-hidden="true">17.5.</strong> Read å’Œ Write</a></li><li class="chapter-item "><a href="std-traits/default.html"><strong aria-hidden="true">17.6.</strong> Defaultï¼Œç»“æ„ä½“æ›´æ–°è¯­æ³•</a></li><li class="chapter-item "><a href="std-traits/closures.html"><strong aria-hidden="true">17.7.</strong> é—­åŒ…</a></li><li class="chapter-item "><a href="std-traits/exercise.html"><strong aria-hidden="true">17.8.</strong> ç»ƒä¹ ï¼šROT13</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std-traits/solution.html"><strong aria-hidden="true">17.8.1.</strong> è§£ç­”</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸‰å¤©ï¼šä¸Šåˆ</li><li class="chapter-item "><a href="welcome-day-3.html"><strong aria-hidden="true">18.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="memory-management.html"><strong aria-hidden="true">19.</strong> å†…å­˜ç®¡ç†</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/review.html"><strong aria-hidden="true">19.1.</strong> å›é¡¾ï¼šç¨‹åºçš„å†…å­˜åˆ†é…</a></li><li class="chapter-item "><a href="memory-management/approaches.html"><strong aria-hidden="true">19.2.</strong> å†…å­˜ç®¡ç†æ–¹æ³•</a></li><li class="chapter-item "><a href="memory-management/ownership.html"><strong aria-hidden="true">19.3.</strong> æ‰€æœ‰æƒ</a></li><li class="chapter-item "><a href="memory-management/move.html"><strong aria-hidden="true">19.4.</strong> ç§»åŠ¨è¯­ä¹‰</a></li><li class="chapter-item "><a href="memory-management/clone.html"><strong aria-hidden="true">19.5.</strong> Clone</a></li><li class="chapter-item "><a href="memory-management/copy-types.html"><strong aria-hidden="true">19.6.</strong> å¤åˆç±»å‹</a></li><li class="chapter-item "><a href="memory-management/drop.html"><strong aria-hidden="true">19.7.</strong> Drop</a></li><li class="chapter-item "><a href="memory-management/exercise.html"><strong aria-hidden="true">19.8.</strong> ç»ƒä¹ ï¼šæ„å»ºå™¨ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="memory-management/solution.html"><strong aria-hidden="true">19.8.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="smart-pointers.html"><strong aria-hidden="true">20.</strong> æ™ºèƒ½æŒ‡é’ˆ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">20.1.</strong> Box<T></a></li><li class="chapter-item "><a href="smart-pointers/rc.html"><strong aria-hidden="true">20.2.</strong> Rc</a></li><li class="chapter-item "><a href="smart-pointers/trait-objects.html"><strong aria-hidden="true">20.3.</strong> Owned Trait Objects</a></li><li class="chapter-item "><a href="smart-pointers/exercise.html"><strong aria-hidden="true">20.4.</strong> ç»ƒä¹ ï¼šäºŒå‰æ ‘</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/solution.html"><strong aria-hidden="true">20.4.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬ä¸‰å¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="welcome-day-3-afternoon.html"><strong aria-hidden="true">21.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="borrowing.html"><strong aria-hidden="true">22.</strong> å€Ÿç”¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/shared.html"><strong aria-hidden="true">22.1.</strong> å€Ÿç”¨å€¼</a></li><li class="chapter-item "><a href="borrowing/borrowck.html"><strong aria-hidden="true">22.2.</strong> å€Ÿç”¨æ£€æŸ¥</a></li><li class="chapter-item "><a href="borrowing/examples.html"><strong aria-hidden="true">22.3.</strong> Borrow Errors</a></li><li class="chapter-item "><a href="borrowing/interior-mutability.html"><strong aria-hidden="true">22.4.</strong> å†…éƒ¨å¯å˜æ€§</a></li><li class="chapter-item "><a href="borrowing/exercise.html"><strong aria-hidden="true">22.5.</strong> ç»ƒä¹ ï¼šå¥åº·ç»Ÿè®¡</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrowing/solution.html"><strong aria-hidden="true">22.5.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="lifetimes.html"><strong aria-hidden="true">23.</strong> ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/lifetime-annotations.html"><strong aria-hidden="true">23.1.</strong> ç”Ÿå‘½å‘¨æœŸæ³¨è§£</a></li><li class="chapter-item "><a href="lifetimes/lifetime-elision.html"><strong aria-hidden="true">23.2.</strong> ç”Ÿå‘½å‘¨æœŸçœç•¥</a></li><li class="chapter-item "><a href="lifetimes/struct-lifetimes.html"><strong aria-hidden="true">23.3.</strong> ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ</a></li><li class="chapter-item "><a href="lifetimes/exercise.html"><strong aria-hidden="true">23.4.</strong> ç»ƒä¹ ï¼šProtobuf è§£æ</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetimes/solution.html"><strong aria-hidden="true">23.4.1.</strong> è§£ç­”</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬å››å¤©ï¼šä¸Šåˆ</li><li class="chapter-item "><a href="welcome-day-4.html"><strong aria-hidden="true">24.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="iterators.html"><strong aria-hidden="true">25.</strong> è¿­ä»£å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/iterator.html"><strong aria-hidden="true">25.1.</strong> Iterator</a></li><li class="chapter-item "><a href="iterators/intoiterator.html"><strong aria-hidden="true">25.2.</strong> IntoIterator</a></li><li class="chapter-item "><a href="iterators/fromiterator.html"><strong aria-hidden="true">25.3.</strong> FromIterator</a></li><li class="chapter-item "><a href="iterators/exercise.html"><strong aria-hidden="true">25.4.</strong> ç»ƒä¹ ï¼šè¿­ä»£å™¨æ–¹æ³•é“¾</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="iterators/solution.html"><strong aria-hidden="true">25.4.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="modules.html"><strong aria-hidden="true">26.</strong> æ¨¡å—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/modules.html"><strong aria-hidden="true">26.1.</strong> æ¨¡å—</a></li><li class="chapter-item "><a href="modules/filesystem.html"><strong aria-hidden="true">26.2.</strong> æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„</a></li><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">26.3.</strong> å¯è§æ€§</a></li><li class="chapter-item "><a href="modules/paths.html"><strong aria-hidden="true">26.4.</strong> useã€superã€self</a></li><li class="chapter-item "><a href="modules/exercise.html"><strong aria-hidden="true">26.5.</strong> ç»ƒä¹ ï¼šé¢å‘ GUI åº“çš„æ¨¡å—</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/solution.html"><strong aria-hidden="true">26.5.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="testing.html"><strong aria-hidden="true">27.</strong> æµ‹è¯•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/unit-tests.html"><strong aria-hidden="true">27.1.</strong> æµ‹è¯•æ¨¡å—</a></li><li class="chapter-item "><a href="testing/other.html"><strong aria-hidden="true">27.2.</strong> å…¶ä»–ç±»å‹çš„æµ‹è¯•</a></li><li class="chapter-item "><a href="testing/lints.html"><strong aria-hidden="true">27.3.</strong> ç¼–è¯‘å™¨ Lint å’Œ Clippy</a></li><li class="chapter-item "><a href="testing/exercise.html"><strong aria-hidden="true">27.4.</strong> ç»ƒä¹ ï¼šå¢æ©ç®—æ³•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="testing/solution.html"><strong aria-hidden="true">27.4.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">ç¬¬å››å¤©ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="welcome-day-4-afternoon.html"><strong aria-hidden="true">28.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="error-handling.html"><strong aria-hidden="true">29.</strong> é”™è¯¯å¤„ç†</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/panics.html"><strong aria-hidden="true">29.1.</strong> Panics</a></li><li class="chapter-item "><a href="error-handling/result.html"><strong aria-hidden="true">29.2.</strong> Result</a></li><li class="chapter-item "><a href="error-handling/try.html"><strong aria-hidden="true">29.3.</strong> å°è¯•è¿ç®—ç¬¦</a></li><li class="chapter-item "><a href="error-handling/try-conversions.html"><strong aria-hidden="true">29.4.</strong> å°è¯•è½¬æ¢</a></li><li class="chapter-item "><a href="error-handling/error.html"><strong aria-hidden="true">29.5.</strong> Error ç‰¹å¾</a></li><li class="chapter-item "><a href="error-handling/thiserror.html"><strong aria-hidden="true">29.6.</strong> thiserror</a></li><li class="chapter-item "><a href="error-handling/anyhow.html"><strong aria-hidden="true">29.7.</strong> anyhow</a></li><li class="chapter-item "><a href="error-handling/exercise.html"><strong aria-hidden="true">29.8.</strong> ç»ƒä¹ ï¼šä½¿ç”¨ Result è¿›è¡Œé‡å†™</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error-handling/solution.html"><strong aria-hidden="true">29.8.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><a href="unsafe-rust.html"><strong aria-hidden="true">30.</strong> ä¸å®‰å…¨ Rust</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/unsafe.html"><strong aria-hidden="true">30.1.</strong> Unsafe</a></li><li class="chapter-item "><a href="unsafe-rust/dereferencing.html"><strong aria-hidden="true">30.2.</strong> è§£å¼•ç”¨è£¸æŒ‡é’ˆ</a></li><li class="chapter-item "><a href="unsafe-rust/mutable-static.html"><strong aria-hidden="true">30.3.</strong> å¯å˜çš„é™æ€å˜é‡</a></li><li class="chapter-item "><a href="unsafe-rust/unions.html"><strong aria-hidden="true">30.4.</strong> è”åˆä½“</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-functions.html"><strong aria-hidden="true">30.5.</strong> Unsafe å‡½æ•°</a></li><li class="chapter-item "><a href="unsafe-rust/unsafe-traits.html"><strong aria-hidden="true">30.6.</strong> Unsafe ç‰¹å¾</a></li><li class="chapter-item "><a href="unsafe-rust/exercise.html"><strong aria-hidden="true">30.7.</strong> ç»ƒä¹ ï¼šFFI å°è£…å®¹å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe-rust/solution.html"><strong aria-hidden="true">30.7.1.</strong> è§£ç­”</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">Android</li><li class="spacer"></li><li class="chapter-item "><a href="android.html"><strong aria-hidden="true">31.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="android/setup.html"><strong aria-hidden="true">32.</strong> è®¾ç½®</a></li><li class="chapter-item "><a href="android/build-rules.html"><strong aria-hidden="true">33.</strong> æ„å»ºè§„åˆ™</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/build-rules/binary.html"><strong aria-hidden="true">33.1.</strong> å¯æ‰§è¡Œæ–‡ä»¶</a></li><li class="chapter-item "><a href="android/build-rules/library.html"><strong aria-hidden="true">33.2.</strong> åº“</a></li></ol></li><li class="chapter-item "><a href="android/aidl.html"><strong aria-hidden="true">34.</strong> AIDL</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/birthday-service.html"><strong aria-hidden="true">34.1.</strong> /** Birthday service interface. */</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/example-service/interface.html"><strong aria-hidden="true">34.1.1.</strong> æ¥å£</a></li><li class="chapter-item "><a href="android/aidl/example-service/service-bindings.html"><strong aria-hidden="true">34.1.2.</strong> Service API</a></li><li class="chapter-item "><a href="android/aidl/example-service/service.html"><strong aria-hidden="true">34.1.3.</strong> æœåŠ¡å™¨</a></li><li class="chapter-item "><a href="android/aidl/example-service/server.html"><strong aria-hidden="true">34.1.4.</strong> æœåŠ¡å™¨</a></li><li class="chapter-item "><a href="android/aidl/example-service/deploy.html"><strong aria-hidden="true">34.1.5.</strong> éƒ¨ç½²</a></li><li class="chapter-item "><a href="android/aidl/example-service/client.html"><strong aria-hidden="true">34.1.6.</strong> å®¢æˆ·ç«¯</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-definition.html"><strong aria-hidden="true">34.1.7.</strong> æ›´æ”¹ API</a></li><li class="chapter-item "><a href="android/aidl/example-service/changing-implementation.html"><strong aria-hidden="true">34.1.8.</strong> å®ç°</a></li></ol></li><li class="chapter-item "><a href="android/aidl/types.html"><strong aria-hidden="true">34.2.</strong> ç±»å‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/aidl/types/primitives.html"><strong aria-hidden="true">34.2.1.</strong> Primitive Types</a></li><li class="chapter-item "><a href="android/aidl/types/arrays.html"><strong aria-hidden="true">34.2.2.</strong> æ•°ç»„ï¼ˆArraysï¼‰</a></li><li class="chapter-item "><a href="android/aidl/types/objects.html"><strong aria-hidden="true">34.2.3.</strong> ç‰¹å¾å¯¹è±¡</a></li><li class="chapter-item "><a href="android/aidl/types/parcelables.html"><strong aria-hidden="true">34.2.4.</strong> å˜é‡</a></li><li class="chapter-item "><a href="android/aidl/types/file-descriptor.html"><strong aria-hidden="true">34.2.5.</strong> Sending Files</a></li></ol></li></ol></li><li class="chapter-item "><a href="android/testing.html"><strong aria-hidden="true">35.</strong> æµ‹è¯•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/testing/googletest.html"><strong aria-hidden="true">35.1.</strong> GoogleTest</a></li><li class="chapter-item "><a href="android/testing/mocking.html"><strong aria-hidden="true">35.2.</strong> æ¨¡æ‹Ÿ</a></li></ol></li><li class="chapter-item "><a href="android/logging.html"><strong aria-hidden="true">36.</strong> æ—¥å¿—è®°å½•</a></li><li class="chapter-item "><a href="android/interoperability.html"><strong aria-hidden="true">37.</strong> äº’æ“ä½œæ€§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c.html"><strong aria-hidden="true">37.1.</strong> ä¸ C è¯­è¨€äº¤äº’</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/with-c/bindgen.html"><strong aria-hidden="true">37.1.1.</strong> ä½¿ç”¨ Bindgen è°ƒç”¨ C è¯­è¨€</a></li><li class="chapter-item "><a href="android/interoperability/with-c/rust.html"><strong aria-hidden="true">37.1.2.</strong> ä» C è¯­è¨€è°ƒç”¨ Rust è¯­è¨€</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/cpp.html"><strong aria-hidden="true">37.2.</strong> ä¸ C++ äº¤äº’</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="android/interoperability/cpp/bridge.html"><strong aria-hidden="true">37.2.1.</strong> æ¡¥æ¥æ¨¡å—</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-bridge.html"><strong aria-hidden="true">37.2.2.</strong> Rust æ¡¥æ¥</a></li><li class="chapter-item "><a href="android/interoperability/cpp/generated-cpp.html"><strong aria-hidden="true">37.2.3.</strong> ç”Ÿæˆçš„ C++ ä»£ç </a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-bridge.html"><strong aria-hidden="true">37.2.4.</strong> C++ æ¡¥æ¥</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-types.html"><strong aria-hidden="true">37.2.5.</strong> å…±äº«ç±»å‹</a></li><li class="chapter-item "><a href="android/interoperability/cpp/shared-enums.html"><strong aria-hidden="true">37.2.6.</strong> å…±äº«æšä¸¾</a></li><li class="chapter-item "><a href="android/interoperability/cpp/rust-result.html"><strong aria-hidden="true">37.2.7.</strong> Rust é”™è¯¯å¤„ç†</a></li><li class="chapter-item "><a href="android/interoperability/cpp/cpp-exception.html"><strong aria-hidden="true">37.2.8.</strong> C++ é”™è¯¯å¤„ç†</a></li><li class="chapter-item "><a href="android/interoperability/cpp/type-mapping.html"><strong aria-hidden="true">37.2.9.</strong> å…¶ä»–ç±»å‹</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-cpp.html"><strong aria-hidden="true">37.2.10.</strong> ä¸º Android æ„å»ºï¼šC++</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-cpp-genrules.html"><strong aria-hidden="true">37.2.11.</strong> ä¸º Android æ„å»ºï¼šGenrule</a></li><li class="chapter-item "><a href="android/interoperability/cpp/android-build-rust.html"><strong aria-hidden="true">37.2.12.</strong> ä¸º Android æ„å»ºï¼šRust</a></li></ol></li><li class="chapter-item "><a href="android/interoperability/java.html"><strong aria-hidden="true">37.3.</strong> ä¸ Java äº¤äº’</a></li></ol></li><li class="chapter-item "><li class="part-title">Chromium</li><li class="spacer"></li><li class="chapter-item "><a href="chromium.html"><strong aria-hidden="true">38.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="chromium/setup.html"><strong aria-hidden="true">39.</strong> è®¾ç½®</a></li><li class="chapter-item "><a href="chromium/cargo.html"><strong aria-hidden="true">40.</strong> Chromium å’Œ Cargo çš„ç”Ÿæ€å¯¹æ¯”</a></li><li class="chapter-item "><a href="chromium/policy.html"><strong aria-hidden="true">41.</strong> æ”¿ç­–</a></li><li class="chapter-item "><a href="chromium/build-rules.html"><strong aria-hidden="true">42.</strong> æ„å»ºè§„åˆ™</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/build-rules/unsafe.html"><strong aria-hidden="true">42.1.</strong> ä¸å®‰å…¨ä»£ç </a></li><li class="chapter-item "><a href="chromium/build-rules/depending.html"><strong aria-hidden="true">42.2.</strong> åœ¨ Chromium C++ ä¸­å¯¼å…¥ Rust ä»£ç </a></li><li class="chapter-item "><a href="chromium/build-rules/vscode.html"><strong aria-hidden="true">42.3.</strong> Visual Studio Code</a></li><li class="chapter-item "><a href="exercises/chromium/build-rules.html"><strong aria-hidden="true">42.4.</strong> ç»ƒä¹ </a></li></ol></li><li class="chapter-item "><a href="chromium/testing.html"><strong aria-hidden="true">43.</strong> æµ‹è¯•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/testing/rust-gtest-interop.html"><strong aria-hidden="true">43.1.</strong> rust_gtest_interop åº“</a></li><li class="chapter-item "><a href="chromium/testing/build-gn.html"><strong aria-hidden="true">43.2.</strong> Rust æµ‹è¯•çš„ GN è§„åˆ™</a></li><li class="chapter-item "><a href="chromium/testing/chromium-import-macro.html"><strong aria-hidden="true">43.3.</strong> chromium::import! å®</a></li><li class="chapter-item "><a href="exercises/chromium/testing.html"><strong aria-hidden="true">43.4.</strong> ç»ƒä¹ </a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp.html"><strong aria-hidden="true">44.</strong> ä¸ C++ çš„äº’æ“ä½œæ€§</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/example-bindings.html"><strong aria-hidden="true">44.1.</strong> ç»‘å®šç¤ºä¾‹</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/limitations-of-cxx.html"><strong aria-hidden="true">44.2.</strong> CXX çš„å±€é™æ€§</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling.html"><strong aria-hidden="true">44.3.</strong> CXX é”™è¯¯å¤„ç†</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-qr.html"><strong aria-hidden="true">44.3.1.</strong> é”™è¯¯å¤„ç†ï¼šQR ç ç¤ºä¾‹</a></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/error-handling-png.html"><strong aria-hidden="true">44.3.2.</strong> é”™è¯¯å¤„ç†ï¼šPNG ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="chromium/interoperability-with-cpp/using-cxx-in-chromium.html"><strong aria-hidden="true">44.4.</strong> åœ¨ Chromium ä¸­ä½¿ç”¨ CXX</a></li><li class="chapter-item "><a href="exercises/chromium/interoperability-with-cpp.html"><strong aria-hidden="true">44.5.</strong> ç»ƒä¹ </a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates.html"><strong aria-hidden="true">45.</strong> æ·»åŠ ç¬¬ä¸‰æ–¹ Crate</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-cargo-toml.html"><strong aria-hidden="true">45.1.</strong> é…ç½® Cargo.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/configuring-gnrt-config-toml.html"><strong aria-hidden="true">45.2.</strong> é…ç½® gnrt_config.toml</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/downloading-crates.html"><strong aria-hidden="true">45.3.</strong> ä¸‹è½½ Crate</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/generating-gn-build-rules.html"><strong aria-hidden="true">45.4.</strong> ç”Ÿæˆ gn æ„å»ºè§„åˆ™</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems.html"><strong aria-hidden="true">45.5.</strong> è§£å†³é—®é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-generate-code.html"><strong aria-hidden="true">45.5.1.</strong> æ„å»ºç”¨äºç”Ÿæˆä»£ç çš„è„šæœ¬</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/resolving-problems/build-scripts-which-take-arbitrary-actions.html"><strong aria-hidden="true">45.5.2.</strong> æ„å»ºç”¨äºæ„å»º C++ æˆ–æ‰§è¡Œä»»æ„æ“ä½œçš„è„šæœ¬</a></li></ol></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/depending-on-a-crate.html"><strong aria-hidden="true">45.6.</strong> ä¾èµ–äº Crate</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/reviews-and-audits.html"><strong aria-hidden="true">45.7.</strong> å®¡æŸ¥å’Œå®¡æ ¸</a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/checking-in.html"><strong aria-hidden="true">45.8.</strong> æäº¤åˆ° Chromium æºä»£ç </a></li><li class="chapter-item "><a href="chromium/adding-third-party-crates/keeping-up-to-date.html"><strong aria-hidden="true">45.9.</strong> åŠæ—¶æ›´æ–° Crate</a></li><li class="chapter-item "><a href="exercises/chromium/third-party.html"><strong aria-hidden="true">45.10.</strong> ç»ƒä¹ </a></li></ol></li><li class="chapter-item "><a href="exercises/chromium/bringing-it-together.html"><strong aria-hidden="true">46.</strong> ç»¼åˆåº”ç”¨ç»ƒä¹ </a></li><li class="chapter-item "><a href="exercises/chromium/solutions.html"><strong aria-hidden="true">47.</strong> ç»ƒä¹ è§£ç­”</a></li><li class="chapter-item affix "><li class="part-title">è£¸æœºï¼šä¸Šåˆ</li><li class="spacer"></li><li class="chapter-item "><a href="bare-metal.html"><strong aria-hidden="true">48.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="bare-metal/no_std.html"><strong aria-hidden="true">49.</strong> no_std</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/minimal.html"><strong aria-hidden="true">49.1.</strong> æœ€å°ç¤ºä¾‹</a></li><li class="chapter-item "><a href="bare-metal/alloc.html"><strong aria-hidden="true">49.2.</strong> alloc</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers.html"><strong aria-hidden="true">50.</strong> å¾®æ§åˆ¶å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/mmio.html"><strong aria-hidden="true">50.1.</strong> åŸå§‹ MMIO</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/pacs.html"><strong aria-hidden="true">50.2.</strong> PAC</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/hals.html"><strong aria-hidden="true">50.3.</strong> HAL Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/board-support.html"><strong aria-hidden="true">50.4.</strong> æ¿çº§æ”¯æŒ Crate</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/type-state.html"><strong aria-hidden="true">50.5.</strong> ç±»å‹çŠ¶æ€æ¨¡å¼</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/embedded-hal.html"><strong aria-hidden="true">50.6.</strong> embedded-hal</a></li><li class="chapter-item "><a href="bare-metal/microcontrollers/probe-rs.html"><strong aria-hidden="true">50.7.</strong> probe-rs å’Œ cargo-embed</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/microcontrollers/debugging.html"><strong aria-hidden="true">50.7.1.</strong> è°ƒè¯•</a></li></ol></li><li class="chapter-item "><a href="bare-metal/microcontrollers/other-projects.html"><strong aria-hidden="true">50.8.</strong> å…¶ä»–é¡¹ç›®</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/morning.html"><strong aria-hidden="true">51.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/compass.html"><strong aria-hidden="true">51.1.</strong> ç½—ç›˜</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-morning.html"><strong aria-hidden="true">51.2.</strong> è§£ç­”</a></li></ol></li><li class="chapter-item "><li class="part-title">è£¸æœºï¼šä¸‹åˆ</li><li class="chapter-item "><a href="bare-metal/aps.html"><strong aria-hidden="true">52.</strong> åº”ç”¨å¤„ç†å™¨</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/entry-point.html"><strong aria-hidden="true">52.1.</strong> å‡†å¤‡ä½¿ç”¨ Rust</a></li><li class="chapter-item "><a href="bare-metal/aps/inline-assembly.html"><strong aria-hidden="true">52.2.</strong> å†…è”æ±‡ç¼–</a></li><li class="chapter-item "><a href="bare-metal/aps/mmio.html"><strong aria-hidden="true">52.3.</strong> MMIO</a></li><li class="chapter-item "><a href="bare-metal/aps/uart.html"><strong aria-hidden="true">52.4.</strong> ç¼–å†™ UART é©±åŠ¨ç¨‹åº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/uart/traits.html"><strong aria-hidden="true">52.4.1.</strong> æ›´å¤šç‰¹å¾</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/better-uart.html"><strong aria-hidden="true">52.5.</strong> ä¼˜åŒ– UART é©±åŠ¨ç¨‹åº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/better-uart/bitflags.html"><strong aria-hidden="true">52.5.1.</strong> Bitflags</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/registers.html"><strong aria-hidden="true">52.5.2.</strong> å¤šå¯„å­˜å™¨</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/driver.html"><strong aria-hidden="true">52.5.3.</strong> é©±åŠ¨ç¨‹åº</a></li><li class="chapter-item "><a href="bare-metal/aps/better-uart/using.html"><strong aria-hidden="true">52.5.4.</strong> å¼€å§‹ä½¿ç”¨</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/logging.html"><strong aria-hidden="true">52.6.</strong> æ—¥å¿—è®°å½•</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/aps/logging/using.html"><strong aria-hidden="true">52.6.1.</strong> å¼€å§‹ä½¿ç”¨</a></li></ol></li><li class="chapter-item "><a href="bare-metal/aps/exceptions.html"><strong aria-hidden="true">52.7.</strong> å¼‚å¸¸</a></li><li class="chapter-item "><a href="bare-metal/aps/other-projects.html"><strong aria-hidden="true">52.8.</strong> å…¶ä»–é¡¹ç›®</a></li></ol></li><li class="chapter-item "><a href="bare-metal/useful-crates.html"><strong aria-hidden="true">53.</strong> å®ç”¨ Crate</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/useful-crates/zerocopy.html"><strong aria-hidden="true">53.1.</strong> zerocopy</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/aarch64-paging.html"><strong aria-hidden="true">53.2.</strong> aarch64-paging</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/buddy_system_allocator.html"><strong aria-hidden="true">53.3.</strong> buddy_system_allocator</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/tinyvec.html"><strong aria-hidden="true">53.4.</strong> tinyvec</a></li><li class="chapter-item "><a href="bare-metal/useful-crates/spin.html"><strong aria-hidden="true">53.5.</strong> spin</a></li></ol></li><li class="chapter-item "><a href="bare-metal/android.html"><strong aria-hidden="true">54.</strong> Bare-Metal on Android</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="bare-metal/android/vmbase.html"><strong aria-hidden="true">54.1.</strong> vmbase</a></li></ol></li><li class="chapter-item "><a href="exercises/bare-metal/afternoon.html"><strong aria-hidden="true">55.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="exercises/bare-metal/rtc.html"><strong aria-hidden="true">55.1.</strong> RTC é©±åŠ¨</a></li><li class="chapter-item "><a href="exercises/bare-metal/solutions-afternoon.html"><strong aria-hidden="true">55.2.</strong> è§£ç­”</a></li></ol></li><li class="chapter-item "><li class="part-title">å¹¶å‘ï¼šä¸Šåˆ</li><li class="spacer"></li><li class="chapter-item "><a href="concurrency/welcome.html"><strong aria-hidden="true">56.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="concurrency/threads.html"><strong aria-hidden="true">57.</strong> çº¿ç¨‹</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/threads/plain.html"><strong aria-hidden="true">57.1.</strong> Plain Threads</a></li><li class="chapter-item "><a href="concurrency/threads/scoped.html"><strong aria-hidden="true">57.2.</strong> èŒƒå›´çº¿ç¨‹</a></li></ol></li><li class="chapter-item "><a href="concurrency/channels.html"><strong aria-hidden="true">58.</strong> é€šé“</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/channels/senders-receivers.html"><strong aria-hidden="true">58.1.</strong> Senders and Receivers</a></li><li class="chapter-item "><a href="concurrency/channels/unbounded.html"><strong aria-hidden="true">58.2.</strong> æ— ç•Œé€šé“</a></li><li class="chapter-item "><a href="concurrency/channels/bounded.html"><strong aria-hidden="true">58.3.</strong> æœ‰ç•Œé€šé“</a></li></ol></li><li class="chapter-item "><a href="concurrency/send-sync.html"><strong aria-hidden="true">59.</strong> Send å’Œ Sync</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/send-sync/marker-traits.html"><strong aria-hidden="true">59.1.</strong> Marker Traits</a></li><li class="chapter-item "><a href="concurrency/send-sync/send.html"><strong aria-hidden="true">59.2.</strong> Send</a></li><li class="chapter-item "><a href="concurrency/send-sync/sync.html"><strong aria-hidden="true">59.3.</strong> Sync</a></li><li class="chapter-item "><a href="concurrency/send-sync/examples.html"><strong aria-hidden="true">59.4.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="concurrency/shared-state.html"><strong aria-hidden="true">60.</strong> å…±äº«çŠ¶æ€</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/shared-state/arc.html"><strong aria-hidden="true">60.1.</strong> Arc</a></li><li class="chapter-item "><a href="concurrency/shared-state/mutex.html"><strong aria-hidden="true">60.2.</strong> äº’æ–¥å™¨ï¼ˆMutexï¼‰</a></li><li class="chapter-item "><a href="concurrency/shared-state/example.html"><strong aria-hidden="true">60.3.</strong> ç¤ºä¾‹</a></li></ol></li><li class="chapter-item "><a href="concurrency/sync-exercises.html"><strong aria-hidden="true">61.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/sync-exercises/dining-philosophers.html"><strong aria-hidden="true">61.1.</strong> å“²å­¦å®¶å°±é¤é—®é¢˜</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/link-checker.html"><strong aria-hidden="true">61.2.</strong> å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨</a></li><li class="chapter-item "><a href="concurrency/sync-exercises/solutions.html"><strong aria-hidden="true">61.3.</strong> è§£ç­”</a></li></ol></li><li class="chapter-item "><li class="part-title">å¹¶å‘ï¼šä¸‹åˆ</li><li class="chapter-item "><a href="concurrency/welcome-async.html"><strong aria-hidden="true">62.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="concurrency/async.html"><strong aria-hidden="true">63.</strong> å¼‚æ­¥åŸºç¡€</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/async-await.html"><strong aria-hidden="true">63.1.</strong> async/await</a></li><li class="chapter-item "><a href="concurrency/async/futures.html"><strong aria-hidden="true">63.2.</strong> Futures</a></li><li class="chapter-item "><a href="concurrency/async/runtimes.html"><strong aria-hidden="true">63.3.</strong> Runtimes</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async/runtimes/tokio.html"><strong aria-hidden="true">63.3.1.</strong> Tokio</a></li></ol></li><li class="chapter-item "><a href="concurrency/async/tasks.html"><strong aria-hidden="true">63.4.</strong> ä»»åŠ¡</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-control-flow.html"><strong aria-hidden="true">64.</strong> Channels and Control Flow</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-control-flow/channels.html"><strong aria-hidden="true">64.1.</strong> å¼‚æ­¥é€šé“</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/join.html"><strong aria-hidden="true">64.2.</strong> åŠ å…¥</a></li><li class="chapter-item "><a href="concurrency/async-control-flow/select.html"><strong aria-hidden="true">64.3.</strong> é€‰æ‹©</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-pitfalls.html"><strong aria-hidden="true">65.</strong> è¯¯åŒº</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-pitfalls/blocking-executor.html"><strong aria-hidden="true">65.1.</strong> é˜»å¡æ‰§è¡Œå™¨</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/pin.html"><strong aria-hidden="true">65.2.</strong> Pin</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/async-traits.html"><strong aria-hidden="true">65.3.</strong> å¼‚æ­¥ç‰¹å¾</a></li><li class="chapter-item "><a href="concurrency/async-pitfalls/cancellation.html"><strong aria-hidden="true">65.4.</strong> æ¶ˆé™¤</a></li></ol></li><li class="chapter-item "><a href="concurrency/async-exercises.html"><strong aria-hidden="true">66.</strong> ä¹ é¢˜</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concurrency/async-exercises/dining-philosophers.html"><strong aria-hidden="true">66.1.</strong> å“²å­¦å®¶å°±é¤é—®é¢˜</a></li><li class="chapter-item "><a href="concurrency/async-exercises/chat-app.html"><strong aria-hidden="true">66.2.</strong> å¹¿æ’­èŠå¤©åº”ç”¨</a></li><li class="chapter-item "><a href="concurrency/async-exercises/solutions.html"><strong aria-hidden="true">66.3.</strong> è§£ç­”</a></li></ol></li><li class="chapter-item "><li class="part-title">ç»“æŸè¯­</li><li class="spacer"></li><li class="chapter-item "><a href="thanks.html"><strong aria-hidden="true">67.</strong> è°¢è°¢ï¼</a></li><li class="chapter-item "><a href="glossary.html"><strong aria-hidden="true">68.</strong> è¯æ±‡è¡¨</a></li><li class="chapter-item "><a href="other-resources.html"><strong aria-hidden="true">69.</strong> å…¶ä»–èµ„æº</a></li><li class="chapter-item "><a href="credits.html"><strong aria-hidden="true">70.</strong> é¸£è°¢</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Comprehensive Rust ğŸ¦€</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="pt-BR">Brazilian Portuguese (PortuguÃªs do Brasil)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-CN">Chinese Simplified (æ±‰è¯­)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-TW">Chinese Traditional (æ¼¢èª)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ja">Japanese (æ—¥æœ¬èª)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="ko">Korean (í•œêµ­ì–´)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="fa">Farsi (ÙØ§Ø±Ø³ÛŒ)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="es">Spanish (EspaÃ±ol)</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="uk">Ukrainian (ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ°)</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-CN");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          
                          let full_path_to_root = "../";
                          
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/google/comprehensive-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#æ¬¢è¿æ¥åˆ°-comprehensive-rust-" id="æ¬¢è¿æ¥åˆ°-comprehensive-rust-">æ¬¢è¿æ¥åˆ° Comprehensive Rust ğŸ¦€</a></h1>
<p><a href="https://github.com/google/comprehensive-rust/actions/workflows/build.yml?query=branch%3Amain"><img src="https://img.shields.io/github/actions/workflow/status/google/comprehensive-rust/build.yml?style=flat-square" alt="æ„å»ºå·¥ä½œæµ" /></a> <a href="https://github.com/google/comprehensive-rust/graphs/contributors"><img src="https://img.shields.io/github/contributors/google/comprehensive-rust?style=flat-square" alt="GitHub è´¡çŒ®è€…" /></a> <a href="https://github.com/google/comprehensive-rust/stargazers"><img src="https://img.shields.io/github/stars/google/comprehensive-rust?style=flat-square" alt="GitHub æ˜Ÿæ ‡" /></a></p>
<p>è¿™æ˜¯ä¸€é—¨ç”± Android å›¢é˜Ÿå¼€å‘çš„å…è´¹ Rust è¯¾ç¨‹ã€‚è¯¾ç¨‹æ¶µç›–äº† Rust çš„å…¨éƒ¨å†…å®¹ï¼Œä»åŸºæœ¬è¯­æ³•åˆ°æ³›å‹å’Œé”™è¯¯å¤„ç†ç­‰é«˜çº§ä¸»é¢˜ã€‚</p>
<blockquote>
<p>å¦‚éœ€æŸ¥çœ‹è¯¾ç¨‹çš„æœ€æ–°ç‰ˆæœ¬ï¼Œè¯·è®¿é—® <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a>ã€‚å¦‚æœæ‚¨åœ¨å…¶ä»–åœ°æ–¹é˜…è¯»ï¼Œè¯·åœ¨é‚£é‡ŒæŸ¥çœ‹æ›´æ–°ã€‚</p>
<p>The course is available in other languages. Select your preferred language in the top right corner of the page or check the <a href="running-the-course/translations.html">Translations</a> page for a list of all available translations.</p>
<p>The course is also available <a href="comprehensive-rust.pdf">as a PDF</a>.</p>
</blockquote>
<p>æœ¬è¯¾ç¨‹çš„ç›®æ ‡æ˜¯æ•™ä¼šä½ ä½¿ç”¨ Rustã€‚å‡è®¾ä½ å¯¹ Rust ä¸€æ— æ‰€çŸ¥ï¼Œæœ¬è¯¾ç¨‹å¯ä»¥ï¼š</p>
<ul>
<li>å¸®åŠ©ä½ å…¨é¢ç†è§£ Rust çš„è¯­æ³•å’Œè¯­è¨€ã€‚</li>
<li>è®©ä½ å¯ä»¥ç”¨ Rust ä¿®æ”¹ç°æœ‰ç¨‹åºå’Œç¼–å†™æ–°ç¨‹åºã€‚</li>
<li>ä¸ºä½ å±•ç¤ºå¸¸è§çš„ Rust ä¹ æƒ¯ç”¨æ³•ã€‚</li>
</ul>
<p>æˆ‘ä»¬å°†å‰å››å¤©çš„è¯¾ç¨‹ç§°ä¸ºâ€œRust åŸºç¡€â€ã€‚</p>
<p>åœ¨æ­¤åŸºç¡€ä¸Šï¼Œä½ å¯ä»¥é€‰æ‹©æ·±å…¥ç ”ç©¶ä¸€ä¸ªæˆ–å¤šä¸ªä¸“é—¨çš„ä¸»é¢˜ï¼š</p>
<ul>
<li><a href="android.html">Android</a>ï¼šä¸ºæœŸåŠå¤©çš„è¯¾ç¨‹ï¼Œä»‹ç»å¦‚ä½•åœ¨ Android å¹³å°å¼€å‘ä¸­ä½¿ç”¨ Rustï¼ˆAOSPï¼‰ã€‚è¯¾ç¨‹å†…å®¹åŒ…æ‹¬ä¸ Cã€C++ å’Œ Java çš„äº’æ“ä½œæ€§ã€‚</li>
<li><a href="chromium.html">Chromium</a>ï¼šä¸ºæœŸåŠå¤©çš„è¯¾ç¨‹ï¼Œä»‹ç»å¦‚ä½•åœ¨åŸºäº Chromium çš„æµè§ˆå™¨ä¸­ä½¿ç”¨ Rustã€‚è¯¾ç¨‹å†…å®¹åŒ…æ‹¬ä¸ C++ çš„äº’æ“ä½œæ€§ä»¥åŠå¦‚ä½•åœ¨ Chromium ä¸­åŠ å…¥ç¬¬ä¸‰æ–¹ crateã€‚</li>
<li><a href="bare-metal.html">è£¸æœº</a>ï¼šä¸ºæœŸä¸€å¤©çš„è¯¾ç¨‹ï¼Œä»‹ç»å¦‚ä½•ä½¿ç”¨ Rust è¿›è¡Œè£¸æœºï¼ˆåµŒå…¥å¼ï¼‰å¼€å‘ã€‚è¯¾ç¨‹å†…å®¹æ¶µç›–å¾®æ§åˆ¶å™¨å’Œåº”ç”¨å¤„ç†å™¨ã€‚</li>
<li><a href="concurrency/welcome.html">Concurrency</a>: a whole-day class on concurrency in Rust. We cover both classical concurrency (preemptively scheduling using threads and mutexes) and async/await concurrency (cooperative multitasking using futures).</li>
</ul>
<h2><a class="header" href="#éç›®æ ‡" id="éç›®æ ‡">éç›®æ ‡</a></h2>
<p>Rust æ˜¯ä¸€é—¨åºå¤§çš„è¯­è¨€ï¼ŒçŸ­çŸ­å‡ å¤©çš„è¯¾ç¨‹æ— æ³•è¦†ç›–å…¶å…¨éƒ¨å†…å®¹ã€‚æœ¬è¯¾ç¨‹ä¸åŒ…æ‹¬ä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>å­¦ä¹ å¦‚ä½•å¼€å‘å®ï¼šè¯·å‚é˜… <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Rust Book çš„ç¬¬ 19.5 ç« </a> å’Œ <a href="https://doc.rust-lang.org/rust-by-example/macros.html">Rust by Examples å¯¹åº”ç« èŠ‚</a>ã€‚</li>
</ul>
<h2><a class="header" href="#å­¦ä¹ å‰æ" id="å­¦ä¹ å‰æ">å­¦ä¹ å‰æ</a></h2>
<p>æœ¬è¯¾ç¨‹å‡è®¾ä½ å·²ç»å…·å¤‡ç¼–ç¨‹çŸ¥è¯†ã€‚Rust æ˜¯ä¸€ç§é™æ€ç±»å‹è¯­è¨€ï¼Œæœ¬è¯¾ç¨‹æœ‰æ—¶ä¼šå°†å…¶ä¸ C å’Œ C++ è¿›è¡Œæ¯”è¾ƒï¼Œä»¥ä¾¿æ›´å¥½åœ°è§£é‡Šæˆ–å¯¹æ¯” Rust çš„è®¾è®¡ã€‚</p>
<p>å¦‚æœä½ ä¼šä½¿ç”¨ Python æˆ– JavaScript ç­‰åŠ¨æ€ç±»å‹è¯­è¨€ç¼–ç¨‹ï¼Œé‚£ä¹ˆä½ ä¹Ÿèƒ½å¤Ÿå¾ˆå¥½åœ°è·Ÿä¸Šè¿›åº¦ã€‚</p>
<details>
<p>è¿™æ˜¯æ¼”è®²è€…å¤‡æ³¨ï¼ˆ<em>Speaker Notes</em>ï¼‰çš„ç¤ºä¾‹ã€‚é¡µé¢ä¸­ä½¿ç”¨å®ƒæ¥ä¸ºå¹»ç¯ç‰‡æ·»åŠ å¤‡æ³¨ä¿¡æ¯ï¼Œå…¶å†…å®¹åŒ…æ‹¬è®²å¸ˆåº”æ¶‰åŠçš„è¦ç‚¹ï¼Œä»¥åŠå¯¹è¯¾å ‚ä¸Šå¯èƒ½å‡ºç°çš„å…¸å‹é—®é¢˜çš„å›ç­”ã€‚</p>
</details>
<h1><a class="header" href="#æˆè¯¾" id="æˆè¯¾">æˆè¯¾</a></h1>
<blockquote>
<p>æœ¬é¡µä¾›è¯¾ç¨‹è®²å¸ˆä½¿ç”¨ã€‚</p>
</blockquote>
<p>ä»¥ä¸‹æ˜¯æœ‰å…³ Google å†…éƒ¨å¼€å±•è¯¾ç¨‹çš„ä¸€äº›ç›¸å…³èƒŒæ™¯ã€‚</p>
<p>ä¸Šè¯¾æ—¶é—´é€šå¸¸æ˜¯ä»ä¸Šåˆ 9:00 åˆ°ä¸‹åˆ 4:00ï¼Œä¸­é—´æœ‰ 1 å°æ—¶çš„åˆé¤ä¼‘æ¯æ—¶é—´ã€‚è¿™æ ·ä¸Šåˆå’Œä¸‹åˆå°±å„æœ‰ 3 å°æ—¶ä¸Šè¯¾æ—¶é—´ã€‚ä¸Šä¸‹åˆä¸Šè¯¾æ—¶é—´æ®µå†…éƒ½æœ‰å¤šæ¬¡ä¼‘æ¯æ—¶é—´å’Œå­¦ç”Ÿåšç»ƒä¹ çš„æ—¶é—´ã€‚</p>
<p>åœ¨æˆè¯¾ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆä»¥ä¸‹äº‹é¡¹ï¼š</p>
<ol>
<li>
<p>ç†Ÿæ‚‰è¯¾ç¨‹èµ„æ–™ã€‚é¡µé¢æä¾›äº†æ¼”è®²è€…æ³¨é‡Šä»¥çªå‡ºé‡ç‚¹ï¼ˆè¯·å¸®å¿™å¤šå¤šè´¡çŒ®æ¼”è®²è€…å¤‡æ³¨ï¼ï¼‰ã€‚æ¼”è®²æ—¶ï¼Œè¯·ç¡®ä¿åœ¨å¼¹å‡ºçª—å£ä¸­æ‰“å¼€æ¼”è®²è€…ç¬”è®°ï¼ˆç‚¹å‡»â€œæ¼”è®²è€…ç¬”è®°â€æ—è¾¹å¸¦å°ç®­å¤´çš„é“¾æ¥ï¼‰ã€‚è¿™æ ·å°±å¯ä»¥ç¡®ä¿å±å¹•æ•´æ´æœ‰åºï¼Œæ›´å¥½åœ°å‘å…¨ç­å­¦å‘˜å±•ç¤ºè¯¾ç¨‹å†…å®¹ã€‚</p>
</li>
<li>
<p>å†³å®šåŸ¹è®­æ—¥æœŸã€‚ç”±äºè¯¾ç¨‹ä¸ºæœŸå››å¤©ï¼Œå»ºè®®å°†æ—¶é—´å®‰æ’åœ¨ä¸¤å‘¨å†…ã€‚è¯¾ç¨‹å­¦å‘˜æ›¾è¡¨ç¤ºï¼Œä»–ä»¬è®¤ä¸ºåœ¨è¯¾ç¨‹ä¿ç•™ä¸€äº›é—´éš™æœ‰åŠ©äºæ›´å¥½åœ°è¿›è¡Œç†è§£ã€‚</p>
</li>
<li>
<p>æ‰¾ä¸€é—´è¶³ä»¥å®¹çº³å…¨ä½“çº¿ä¸‹å­¦å‘˜çš„æ•™å®¤ã€‚å»ºè®®çš„ç­çº§äººæ•°ä¸º 15-25 äººã€‚è¿™æ ·å°‘çš„äººæ•°å¯ä»¥è®©å¤§å®¶èƒ½å¤Ÿæ›´è½»æ¾åœ°æé—®ï¼Œä¹Ÿå¯ä»¥è®©ä»…æœ‰ä¸€ä½çš„è®²å¸ˆæœ‰è¶³å¤Ÿæ—¶é—´å›ç­”é—®é¢˜ã€‚ç¡®ä¿æ•™å®¤é‡Œæœ‰è®²å¸ˆå’Œå­¦ç”Ÿç”¨çš„æ¡Œå­ï¼Œå¹¶èƒ½å¤Ÿåä¸‹æ¥ä½¿ç”¨ç¬”è®°æœ¬ç”µè„‘ã€‚ç‰¹åˆ«åœ°ï¼Œè®²å¸ˆéœ€è¦è¿›è¡Œå¤§é‡çš„ç°åœºç¼–ç å·¥ä½œï¼Œå› æ­¤è®²å°æ˜¯ä¸éœ€è¦çš„ã€‚</p>
</li>
<li>
<p>è¯¾ç¨‹å½“å¤©ï¼Œè¯·ææ—©åˆ°æ•™å®¤è¿›è¡Œå‡†å¤‡ã€‚å»ºè®®ç›´æ¥åœ¨ç¬”è®°æœ¬ç”µè„‘ä¸Šè¿è¡Œ <code>mdbook serve</code> æ¥æ¼”ç¤ºè¯¾ç¨‹å†…å®¹ï¼ˆè¯·å‚é˜…<a href="https://github.com/google/comprehensive-rust#building">å®‰è£…è¯´æ˜</a>ï¼‰ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿åœ¨æ›´æ¢é¡µé¢æ—¶ä¸ä¼šå‡ºç°å»¶è¿Ÿï¼Œæ¼”ç¤ºæ•ˆæœæ›´å¥½ã€‚ä½¿ç”¨ç¬”è®°æœ¬è¿è¡Œè¿˜å¯ä»¥åœ¨å‘ç°é”™åˆ«å­—æ—¶åŠæ—¶æ›´æ­£ã€‚</p>
</li>
<li>
<p>è®©å­¦å‘˜è‡ªå·±æˆ–ä»¥å°ç»„ä¸ºå•ä½è§£å†³ç»ƒä¹ é—®é¢˜ã€‚é€šå¸¸åœ¨ä¸Šåˆå’Œä¸‹åˆå„å®‰æ’ 30-45 åˆ†é’Ÿçš„ç»ƒä¹ æ—¶é—´ï¼ˆåŒ…æ‹¬æŸ¥çœ‹è§£ç­”çš„æ—¶é—´ï¼‰ã€‚è¯·åŠ¡å¿…è¯¢é—®å­¦å‘˜æ˜¯å¦é‡åˆ°å›°éš¾ï¼Œæˆ–æ˜¯å¦éœ€è¦ä»»ä½•å¸®åŠ©ã€‚å¦‚æœæœ‰å¤šä½å­¦å‘˜é‡åˆ°åŒæ ·çš„é—®é¢˜ï¼Œåˆ™åœ¨ç­çº§å†…è¿›è¡Œè®²è§£ï¼Œå¹¶æä¾›ç›¸åº”çš„è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚å‘Šè¯‰å¤§å®¶åœ¨æ ‡å‡†åº“çš„ä»€ä¹ˆä½ç½®å¯ä»¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯ã€‚</p>
</li>
</ol>
<p>ä»¥ä¸Šå°±æ˜¯å…¨éƒ¨äº‹é¡¹ï¼Œç¥ä½ æˆè¯¾é¡ºåˆ©ï¼å¸Œæœ›ä½ èƒ½åƒæˆ‘ä»¬ä¸€æ ·äº«å—å…¶ä¸­çš„ä¹è¶£ï¼</p>
<p>æ¬¢è¿ä½ åœ¨è¯¾å <a href="https://github.com/google/comprehensive-rust/discussions/86">æä¾›åé¦ˆ</a>ï¼Œä»¥å¸®åŠ©æˆ‘ä»¬ä¸æ–­æ”¹è¿›è¯¾ç¨‹ã€‚æˆ‘ä»¬éå¸¸æœŸå¾…äº†è§£å“ªäº›æ–¹é¢åšå¾—ä¸é”™ï¼Œå“ªäº›æ–¹é¢è¿˜éœ€è¦æ”¹è¿›ã€‚åŒæ—¶éå¸¸æ¬¢è¿å­¦ç”Ÿä»¬ <a href="https://github.com/google/comprehensive-rust/discussions/100">å‘æˆ‘ä»¬å‘é€åé¦ˆ</a>ï¼</p>
<h1><a class="header" href="#è¯¾ç¨‹ç»“æ„" id="è¯¾ç¨‹ç»“æ„">è¯¾ç¨‹ç»“æ„</a></h1>
<blockquote>
<p>æœ¬é¡µä¾›è¯¾ç¨‹è®²å¸ˆä½¿ç”¨ã€‚</p>
</blockquote>
<h2><a class="header" href="#rust-åŸºç¡€" id="rust-åŸºç¡€">Rust åŸºç¡€</a></h2>
<p>å‰å››å¤©çš„å†…å®¹æ˜¯ <a href="running-the-course/../welcome-day-1.html">Rust åŸºç¡€</a>ã€‚è¿™å‡ å¤©çš„è¯¾ç¨‹èŠ‚å¥å¾ˆå¿«ï¼Œå†…å®¹ä¹Ÿå¾ˆä¸°å¯Œï¼</p>
<p>{{%course outline Fundamentals}}</p>
<h2><a class="header" href="#æ·±å…¥æ¢ç©¶" id="æ·±å…¥æ¢ç©¶">æ·±å…¥æ¢ç©¶</a></h2>
<p>é™¤äº†ä¸ºæœŸå››å¤©çš„â€œRust åŸºç¡€â€è¯¾ç¨‹å¤–ï¼Œè¿˜æœ‰ä¸€äº›ä¸“ä¸šè¯¾é¢˜æä¾›ï¼š</p>
<h3><a class="header" href="#android-ä¸­çš„-rust" id="android-ä¸­çš„-rust">Android ä¸­çš„ Rust</a></h3>
<p>æ·±å…¥æ¢ç©¶ <a href="running-the-course/../android.html">Android ä¸­çš„ Rust</a> è¯¾ç¨‹ä¸ºæœŸåŠå¤©ï¼Œæ—¨åœ¨ä»‹ç»å¦‚ä½•ä½¿ç”¨ Rust è¿›è¡Œ Android å¹³å°å¼€å‘ã€‚å…¶ä¸­åŒ…æ‹¬ä¸ Cã€C++ å’Œ Java çš„äº’æ“ä½œæ€§ã€‚</p>
<p>ä½ éœ€è¦ <a href="https://source.android.com/docs/setup/download/downloading">æ£€å‡º AOSP</a>ã€‚åœ¨åŒä¸€æœºå™¨ä¸Šæ£€å‡º <a href="https://github.com/google/comprehensive-rust">è¯¾ç¨‹åº“</a>ï¼Œ ç„¶åå°† <code>src/android/</code> ç›®å½•ç§»è‡³æ‰€æ£€å‡ºçš„ AOSP çš„æ ¹ç›®å½•ã€‚è¿™å°†ç¡®ä¿ Android æ„å»ºç³»ç»Ÿèƒ½æ£€æµ‹åˆ° <code>src/android/</code> ä¸­çš„ <code>Android.bp</code> æ–‡ä»¶ã€‚</p>
<p>ç¡®ä¿ <code>adb sync</code> é€‚ç”¨äºä½ çš„æ¨¡æ‹Ÿå™¨æˆ–å®é™…è®¾å¤‡ï¼Œ å¹¶ä½¿ç”¨ <code>src/android/build_all.sh</code> é¢„æ„å»ºæ‰€æœ‰ Android ç¤ºä¾‹ã€‚è¯·é˜…è¯»è„šæœ¬ï¼Œ æŸ¥çœ‹å®ƒæ‰€è¿è¡Œçš„å‘½ä»¤ï¼Œå¹¶ç¡®ä¿è¿™äº›å‘½ä»¤èƒ½åœ¨ä½ æ‰‹åŠ¨è¿è¡Œæ—¶æ­£ç¡®æ‰§è¡Œã€‚</p>
<h3><a class="header" href="#chromium-ä¸­çš„-rust" id="chromium-ä¸­çš„-rust">Chromium ä¸­çš„ Rust</a></h3>
<p>æ·±å…¥æ¢ç©¶ <a href="running-the-course/../chromium.html">Chromium ä¸­çš„ Rust</a> è¯¾ç¨‹ä¸ºæœŸåŠå¤©ï¼Œæ—¨åœ¨ä»‹ç» Chromium æµè§ˆå™¨ä¸­ Rust çš„ä½¿ç”¨ã€‚è¯¾ç¨‹å†…å®¹åŒ…æ‹¬åœ¨ Chromium çš„ <code>gn</code> ç¼–è¯‘ç³»ç»Ÿä¸­ä½¿ç”¨ Rustï¼Œå¼•å…¥ç¬¬ä¸‰æ–¹ crateï¼Œä»¥åŠä¸ C++ çš„äº’æ“ä½œæ€§ã€‚</p>
<p>æ‚¨éœ€è¦èƒ½å¤Ÿæ„å»º Chromiumã€‚ä¸ºäº†æé«˜é€Ÿåº¦ï¼Œå»ºè®®ä½¿ç”¨è°ƒè¯•ã€ç»„ä»¶ <a href="running-the-course/../chromium/setup.html">æ„å»ºæ–¹å¼</a>ï¼Œå…¶ä»–æ„å»ºæ–¹å¼ä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚ç¡®ä¿æ‰€æ„å»ºçš„ Chromium æµè§ˆå™¨å¯ä»¥æ­£å¸¸è¿è¡Œã€‚</p>
<h3><a class="header" href="#è£¸æœº-rust" id="è£¸æœº-rust">è£¸æœº Rust</a></h3>
<p>æ·±å…¥æ¢ç©¶ <a href="running-the-course/../bare-metal.html">è£¸æœº Rust</a> è¯¾ç¨‹ä¸ºæœŸä¸€å¤©ï¼Œæ—¨åœ¨ä»‹ç»å¦‚ä½•ä½¿ç”¨ Rust è¿›è¡Œè£¸æœºï¼ˆåµŒå…¥å¼ï¼‰å¼€å‘ã€‚å…¶ä¸­æ¶µç›–äº†å¾®æ§åˆ¶å™¨å’Œåº”ç”¨å¤„ç†å™¨ã€‚</p>
<p>å¯¹äºå¾®æ§åˆ¶å™¨éƒ¨åˆ†ï¼Œéœ€è¦æå‰è´­ä¹° <a href="https://microbit.org/">BBC micro:bit</a> v2 å¼€å‘æ¿ã€‚æ¯ä¸ªäººéƒ½éœ€è¦å®‰è£…å¤šä¸ªè½¯ä»¶åŒ…ï¼Œ å…·ä½“å¦‚ <a href="running-the-course/../bare-metal.html">æ¬¢è¿é¡µé¢</a> ä¸­æ‰€è¿°ã€‚</p>
<h3><a class="header" href="#rust-ä¸­çš„å¹¶å‘" id="rust-ä¸­çš„å¹¶å‘">Rust ä¸­çš„å¹¶å‘</a></h3>
<p>The <a href="running-the-course/../concurrency/welcome.html">Concurrency in Rust</a> deep dive is a full day class on classical as well as <code>async</code>/<code>await</code> concurrency.</p>
<p>ä½ éœ€è¦è®¾ç½®ä¸€ä¸ªæ–° crateï¼Œä¸‹è½½æ‰€éœ€çš„ä¾èµ–é¡¹ï¼Œ åšå¥½è¯¾å‰å‡†å¤‡ã€‚ç„¶åï¼Œä½ å¯ä»¥å°†ç¤ºä¾‹å¤åˆ¶/ç²˜è´´åˆ° <code>src/main.rs</code> ä¸­ï¼Œ ä»¥ä¾¿å¯¹ä»¥ä¸‹ä»£ç è¿›è¡Œå®éªŒï¼š</p>
<pre><code class="language-shell">cargo init concurrency
cd concurrency
cargo add tokio --features full
cargo run
</code></pre>
<p>{{%course outline Concurrency}}</p>
<h2><a class="header" href="#è¯¾ç¨‹å½¢å¼" id="è¯¾ç¨‹å½¢å¼">è¯¾ç¨‹å½¢å¼</a></h2>
<p>æœ¬è¯¾ç¨‹çš„äº’åŠ¨æ€§éå¸¸å¼ºï¼Œ å»ºè®®ä½ ä»¥é—®é¢˜é©±åŠ¨æ¢ç´¢ Rustï¼</p>
<h1><a class="header" href="#é”®ç›˜å¿«æ·é”®" id="é”®ç›˜å¿«æ·é”®">é”®ç›˜å¿«æ·é”®</a></h1>
<p>mdBook ä¸­æœ‰ä¸€äº›å®ç”¨é”®ç›˜å¿«æ·é”®ï¼š</p>
<ul>
<li><kbd>Arrow-Left</kbd>: Navigate to the previous page.</li>
<li><kbd>Arrow-Right</kbd>: Navigate to the next page.</li>
<li><kbd>Ctrl + Enter</kbd>: Execute the code sample that has focus.</li>
<li><kbd>s</kbd>: Activate the search bar.</li>
</ul>
<h1><a class="header" href="#ç¿»è¯‘" id="ç¿»è¯‘">ç¿»è¯‘</a></h1>
<p>ä¸€æ‰¹ä¼˜ç§€çš„å¿—æ„¿è€…å·²å°†æœ¬è¯¾ç¨‹ç¿»è¯‘æˆå…¶ä»–è¯­è¨€ï¼š</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/pt-BR/">å·´è¥¿è‘¡è„ç‰™è¯­ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/rastringer">@rastringer</a>ã€<a href="https://github.com/hugojacob">@hugojacob</a>ã€<a href="https://github.com/joaovicmendes">@joaovicmendes</a> å’Œ <a href="https://github.com/henrif75">@henrif75</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-CN/">Chinese (Simplified)</a> by <a href="https://github.com/suetfei">@suetfei</a>, <a href="https://github.com/wnghl">@wnghl</a>, <a href="https://github.com/anlunx">@anlunx</a>, <a href="https://github.com/kongy">@kongy</a>, <a href="https://github.com/noahdragon">@noahdragon</a>, <a href="https://github.com/superwhd">@superwhd</a>, @SketchK, and <a href="https://github.com/nodmp">@nodmp</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/zh-TW/">ç¹ä½“ä¸­æ–‡ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/hueich">@hueich</a>ã€<a href="https://github.com/victorhsieh">@victorhsieh</a>ã€<a href="https://github.com/mingyc">@mingyc</a>ã€<a href="https://github.com/kuanhungchen">@kuanhungchen</a> å’Œ <a href="https://github.com/johnathan79717">@johnathan79717</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/fa/">Farsi</a> by <a href="https://github.com/DannyRavi">@DannyRavi</a>, <a href="https://github.com/javad-jafari">@javad-jafari</a>, <a href="https://github.com/alix1383">@Alix1383</a>, <a href="https://github.com/moaminsharifi">@moaminsharifi</a> , <a href="https://github.com/hamidrezakp">@hamidrezakp</a> and <a href="https://github.com/mehrad77">@mehrad77</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ja/">Japanese</a> by <a href="https://github.com/CoinEZ">@CoinEZ-JPN</a>, <a href="https://github.com/momotaro1105">@momotaro1105</a>, <a href="https://github.com/HidenoriKobayashi">@HidenoriKobayashi</a> and <a href="https://github.com/kantasv">@kantasv</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/ko/">Korean</a> by <a href="https://github.com/keispace">@keispace</a>, <a href="https://github.com/jiyongp">@jiyongp</a>, <a href="https://github.com/jooyunghan">@jooyunghan</a>, and <a href="https://github.com/namhyung">@namhyung</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/es/">è¥¿ç­ç‰™è¯­ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/deavid">@deavid</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/uk/">Ukrainian</a> by <a href="https://github.com/git-user-cpp">@git-user-cpp</a>, <a href="https://github.com/yaremam">@yaremam</a> and <a href="https://github.com/reta">@reta</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/fa/">Farsi</a> by <a href="https://github.com/DannyRavi">@DannyRavi</a>, <a href="https://github.com/javad-jafari">@javad-jafari</a>, <a href="https://github.com/alix1383">@Alix1383</a>, <a href="https://github.com/moaminsharifi">@moaminsharifi</a>, <a href="https://github.com/hamidrezakp">@hamidrezakp</a> and <a href="https://github.com/mehrad77">@mehrad77</a>.</li>
</ul>
<p>ä½¿ç”¨å³ä¸Šè§’çš„è¯­è¨€é€‰æ‹©å™¨åˆ‡æ¢è¯­è¨€ã€‚</p>
<h2><a class="header" href="#æœªå®Œæˆçš„ç¿»è¯‘" id="æœªå®Œæˆçš„ç¿»è¯‘">æœªå®Œæˆçš„ç¿»è¯‘</a></h2>
<p>è¿˜æœ‰å¾ˆå¤šè¯­è¨€ç‰ˆæœ¬ä»åœ¨ç¿»è¯‘ä¸­ã€‚ä»¥ä¸‹æ˜¯æœ€è¿‘æ›´æ–°çš„ç¿»è¯‘ç‰ˆæœ¬çš„é“¾æ¥ï¼š</p>
<ul>
<li><a href="https://google.github.io/comprehensive-rust/ar/">Arabic</a> by <a href="https://github.com/younies">@younies</a></li>
<li><a href="https://google.github.io/comprehensive-rust/bn/">å­ŸåŠ æ‹‰è¯­ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/raselmandol">@raselmandol</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/fr/">French</a> by <a href="https://github.com/KookaS">@KookaS</a>, <a href="https://github.com/vcaen">@vcaen</a> and <a href="https://github.com/AdrienBaudemont">@AdrienBaudemont</a>.</li>
<li><a href="https://google.github.io/comprehensive-rust/de/">å¾·è¯­ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/Throvn">@Throvn</a> å’Œ <a href="https://github.com/ronaldfw">@ronaldfw</a>ã€‚</li>
<li><a href="https://google.github.io/comprehensive-rust/it/">æ„å¤§åˆ©è¯­ç‰ˆæœ¬</a> è¯‘è€…ï¼š<a href="https://github.com/henrythebuilder">@henrythebuilder</a> å’Œ <a href="https://github.com/detro">@detro</a>ã€‚</li>
</ul>
<p>The full list of translations with their current status is also available either <a href="https://google.github.io/comprehensive-rust/translation-report.html">as of their last update</a> or <a href="https://google.github.io/comprehensive-rust/synced-translation-report.html">synced to the latest version of the course</a>.</p>
<p>å¦‚æœä½ æƒ³ååŠ©ç¿»è¯‘ï¼Œè¯·å‚é˜… <a href="https://github.com/google/comprehensive-rust/blob/main/TRANSLATIONS.md">ç¿»è¯‘è¯´æ˜</a>ï¼Œäº†è§£å¦‚ä½•å¼€å§‹ç¿»è¯‘å·¥ä½œã€‚ç¿»è¯‘å·¥ä½œå¯é€šè¿‡ <a href="https://github.com/google/comprehensive-rust/issues/282">æ­¤è®®é¢˜</a> è¿½è¸ªã€‚</p>
<h1><a class="header" href="#ä½¿ç”¨-cargo" id="ä½¿ç”¨-cargo">ä½¿ç”¨ Cargo</a></h1>
<p>å¼€å§‹äº†è§£ Rust åï¼Œä½ å¾ˆå¿«å°±ä¼šé‡åˆ° <a href="https://doc.rust-lang.org/cargo/">Cargo</a>ï¼Œè¿™æ˜¯ Rust ç”Ÿæ€ç³»ç»Ÿä¸­ç”¨äºæ„å»ºå’Œè¿è¡Œ Rust åº”ç”¨çš„æ ‡å‡†å·¥å…·ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æƒ³ç®€è¦ä»‹ç»ä¸€ä¸‹ä»€ä¹ˆæ˜¯ Cargoã€å®ƒå¦‚ä½•èå…¥æ›´å¹¿æ³›çš„ç”Ÿæ€ç³»ç»Ÿï¼Œ ä»¥åŠæˆ‘ä»¬å¦‚ä½•åœ¨æœ¬åŸ¹è®­ä¸­åˆç†åˆ©ç”¨ Cargoã€‚</p>
<h2><a class="header" href="#å®‰è£…" id="å®‰è£…">å®‰è£…</a></h2>
<blockquote>
<p><strong>è¯·æŒ‰ç…§ <a href="https://rustup.rs/">https://rustup.rs/</a> ä¸Šçš„è¯´æ˜æ“ä½œã€‚</strong></p>
</blockquote>
<p>è¿™å°†ä¸ºä½ æä¾› Cargo æ„å»ºå·¥å…· (<code>cargo</code>)å’Œ Rust ç¼–è¯‘å™¨ (<code>rustc</code>)ã€‚ä½ è¿˜å°†è·å¾— <code>rustup</code>ï¼Œè¿™æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œå®ç”¨ç¨‹åº,ä½ å¯ä»¥ç”¨å®ƒæ¥å®‰è£…ä¸åŒçš„ç¼–è¯‘å™¨ç‰ˆæœ¬ã€‚</p>
<p>å®‰è£… Rust ä¹‹åï¼Œä½ åº”å½“é…ç½®ä½ çš„ç¼–è¾‘å™¨æˆ– IDE ä»¥å¼€å§‹ä½¿ç”¨ Rustã€‚å¤§å¤šæ•°ç¼–è¾‘å™¨ä½¿ç”¨äº† <a href="https://rust-analyzer.github.io/">rust-analyzer</a>ã€‚å®ƒä¸º <a href="https://code.visualstudio.com/">VS Code</a>ã€<a href="https://rust-analyzer.github.io/manual.html#emacs">Emacs</a>ã€<a href="https://rust-analyzer.github.io/manual.html#vimneovim">Vim/Neovim</a> åŠå…¶ä»–è®¸å¤šç¼–è¾‘å™¨æä¾›äº†è‡ªåŠ¨è¡¥å…¨åŠå®šä¹‰è·³è½¬çš„åŠŸèƒ½ã€‚åŒæ ·ä¹Ÿå¯ä»¥ä½¿ç”¨ <a href="https://www.jetbrains.com/rust/">RustRover</a> IDEã€‚</p>
<details>
<ul>
<li>
<p>On Debian/Ubuntu, you can also install Cargo, the Rust source and the <a href="https://github.com/rust-lang/rustfmt">Rust formatter</a> via <code>apt</code>. However, this gets you an outdated Rust version and may lead to unexpected behavior. The command would be:</p>
<pre><code class="language-shell">sudo apt install cargo rust-src rustfmt
</code></pre>
</li>
<li>
<p>On macOS, you can use <a href="https://brew.sh/">Homebrew</a> to install Rust, but this may provide an outdated version. Therefore, it is recommended to install Rust from the official site.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust-ç”Ÿæ€ç³»ç»Ÿ" id="rust-ç”Ÿæ€ç³»ç»Ÿ">Rust ç”Ÿæ€ç³»ç»Ÿ</a></h1>
<p>Rust ç”Ÿæ€ç³»ç»Ÿç”±è®¸å¤šå·¥å…·ç»„æˆï¼Œä¸»è¦åŒ…æ‹¬ï¼š</p>
<ul>
<li>
<p><code>rustc</code>ï¼šRust ç¼–è¯‘å™¨ï¼Œå¯å°† <code>.rs</code> æ–‡ä»¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶å’Œå…¶ä»–ä¸­é—´æ ¼å¼ã€‚</p>
</li>
<li>
<p><code>cargo</code>ï¼šRust ä¾èµ–é¡¹ç®¡ç†å™¨å’Œæ„å»ºå·¥å…·ã€‚Cargo çŸ¥é“å¦‚ä½•ä¸‹è½½æ‰˜ç®¡åœ¨ <a href="https://crates.io">https://crates.io</a> ä¸Šçš„ä¾èµ–é¡¹,å¹¶åœ¨æ„å»ºé¡¹ç›®æ—¶å°†å®ƒä»¬ä¼ é€’ç»™ <code>rustc</code>ã€‚Cargo è¿˜é™„å¸¦ä¸€ä¸ªå†…ç½®çš„æµ‹è¯•è¿è¡Œç¨‹åºï¼Œç”¨äºæ‰§è¡Œå•å…ƒæµ‹è¯•ã€‚</p>
</li>
<li>
<p><code>rustup</code>ï¼šRust å·¥å…·é“¾å®‰è£…å’Œæ›´æ–°å·¥å…·ã€‚å½“ Rust å‘å¸ƒæ–°ç‰ˆæœ¬æ—¶ï¼Œæ­¤å·¥å…·ç”¨äºå®‰è£…å¹¶æ›´æ–° <code>rustc</code> å’Œ <code>cargo</code>ã€‚ æ­¤å¤–ï¼Œ<code>rustup</code> è¿˜å¯ä»¥ä¸‹è½½æ ‡å‡†åº“çš„æ–‡æ¡£ã€‚å¯ä»¥åŒæ—¶å®‰è£…å¤šä¸ªç‰ˆæœ¬çš„ Rustï¼Œ<code>rustup</code> ä¼šæ ¹æ®éœ€è¦è®©ä½ åœ¨è¿™äº›ç‰ˆæœ¬ä¹‹é—´åˆ‡æ¢ã€‚</p>
</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Rust æœ‰ä¸€ä¸ªå¿«é€Ÿå‘å¸ƒæ—¶é—´è¡¨ï¼Œæ¯å…­å‘¨å°±ä¼šå‘å¸ƒä¸€æ¬¡æ–°ç‰ˆæœ¬ã€‚æ–°ç‰ˆæœ¬ä¿æŒä¸æ—§ç‰ˆæœ¬çš„å‘åå…¼å®¹æ€§ï¼Œå¹¶æ·»åŠ æ–°åŠŸèƒ½ã€‚</p>
</li>
<li>
<p>å…±æœ‰ä¸‰ä¸ªå‘å¸ƒé˜¶æ®µï¼šâ€œç¨³å®šç‰ˆï¼ˆstableï¼‰â€ã€â€œæµ‹è¯•ç‰ˆï¼ˆbetaï¼‰â€å’Œâ€œå¤œé—´ç‰ˆï¼ˆnightlyï¼‰â€ã€‚</p>
</li>
<li>
<p>æ–°åŠŸèƒ½ä¼šå…ˆåœ¨â€œå¤œé—´ç‰ˆâ€ä¸Šæµ‹è¯•ï¼Œâ€œæµ‹è¯•ç‰ˆâ€ä¼šæ¯å…­å‘¨è½¬ä¸ºâ€œç¨³å®šç‰ˆâ€ã€‚</p>
</li>
<li>
<p>ä¾èµ–å…³ç³»ä¹Ÿå¯ä»¥é€šè¿‡å…¶ä»– <a href="https://doc.rust-lang.org/cargo/reference/registries.html">registry</a>ã€git åŠæ–‡ä»¶å¤¹ç­‰è§£æã€‚</p>
</li>
<li>
<p>Rust åŒºåˆ† <a href="https://doc.rust-lang.org/edition-guide/">ç‰ˆæœ¬ï¼ˆeditionï¼‰</a>ï¼šå½“å‰ç‰ˆæœ¬æ˜¯ Rust 2021ã€‚ä¹‹å‰çš„ç‰ˆæœ¬æ˜¯ Rust 2015 å’Œ Rust 2018ã€‚</p>
<ul>
<li>
<p>è¿™äº›ç‰ˆæœ¬æ”¯æŒå¯¹è¯­è¨€è¿›è¡Œå‘åä¸å…¼å®¹çš„æ›´æ”¹ã€‚</p>
</li>
<li>
<p>ä¸ºé˜²æ­¢ç ´åä»£ç ï¼Œç‰ˆæœ¬æ˜¯å¯é€‰çš„ï¼š é€šè¿‡ <code>Cargo.toml</code> æ–‡ä»¶ä¸º crate é€‰æ‹©åˆé€‚çš„ç‰ˆæœ¬ã€‚</p>
</li>
<li>
<p>ä¸ºå…åˆ†å‰²ç”Ÿæ€ç³»ç»Ÿï¼ŒRust ç¼–è¯‘å™¨å¯ä»¥æ··åˆä½¿ç”¨ä¸ºä¸åŒç‰ˆæœ¬ç¼–å†™çš„ä»£ç ã€‚</p>
</li>
<li>
<p>è¯·æ³¨æ„ï¼Œä¸å€ŸåŠ© <code>cargo</code> ç›´æ¥ä½¿ç”¨ç¼–è¯‘å™¨çš„æƒ…å†µç›¸å½“å°‘è§ï¼ˆå¤§å¤šæ•°ç”¨æˆ·ä»ä¸è¿™æ ·åšï¼‰ã€‚</p>
</li>
<li>
<p>å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒCargo æœ¬èº«å°±æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ä¸”å…¨é¢çš„å·¥å…·ã€‚å®ƒèƒ½å¤Ÿå®ç°è®¸å¤šé«˜çº§åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼š</p>
<ul>
<li>é¡¹ç›®/è½¯ä»¶åŒ…ç»“æ„</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">å·¥ä½œåŒº</a></li>
<li>å¼€å‘ä¾èµ–å’Œè¿è¡Œæ—¶ä¾èµ–ç®¡ç†/ç¼“å­˜</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">æ„å»ºè„šæœ¬</a></li>
<li><a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">å…¨å±€å®‰è£…</a></li>
<li>å®ƒè¿˜å¯ä»¥ä½¿ç”¨å­å‘½ä»¤æ’ä»¶ï¼ˆä¾‹å¦‚ <a href="https://github.com/rust-lang/rust-clippy">cargo clippy</a>ï¼‰è¿›è¡Œæ‰©å±•ã€‚</li>
</ul>
</li>
<li>
<p>è¯¦æƒ…è¯·å‚é˜… <a href="https://doc.rust-lang.org/cargo/">å®˜æ–¹ Cargo Book</a></p>
</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹" id="æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹">æœ¬åŸ¹è®­ä¸­çš„ä»£ç ç¤ºä¾‹</a></h1>
<p>åœ¨æœ¬åŸ¹è®­ä¸­ï¼Œæˆ‘ä»¬å°†ä¸»è¦é€šè¿‡ç¤ºä¾‹æ¢ç´¢ Rust è¯­è¨€ï¼Œè¿™äº›ç¤ºä¾‹å¯ä»¥é€šè¿‡æµè§ˆå™¨æ‰§è¡Œã€‚è¿™èƒ½å¤§å¤§ç®€åŒ–é…ç½®è¿‡ç¨‹ï¼Œ å¹¶ç¡®ä¿æ‰€æœ‰äººéƒ½èƒ½è·å¾—ä¸€è‡´çš„ä½“éªŒã€‚</p>
<p>æˆ‘ä»¬ä»ç„¶å»ºè®®ä½ å®‰è£… Cargoï¼šå®ƒæœ‰åŠ©äºä½ æ›´è½»æ¾åœ°å®Œæˆç»ƒä¹ ã€‚åœ¨æœ€åä¸€å¤©ï¼Œæˆ‘ä»¬è¦åšä¸€ä¸ªç»¼åˆçš„ç»ƒä¹ ï¼Œ å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨ä¾èµ–é¡¹ï¼Œå› æ­¤ä½ éœ€è¦å®‰è£… Cargoã€‚</p>
<p>æœ¬è¯¾ç¨‹ä¸­çš„ä»£ç å—æ˜¯å®Œå…¨äº¤äº’å¼çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
<p>You can use <kbd>Ctrl + Enter</kbd> to execute the code when focus is in the text box.</p>
<details>
<p>å¦‚ä¸Šæ‰€ç¤ºï¼Œå¤§å¤šæ•°ä»£ç ç¤ºä¾‹éƒ½å¯ä¿®æ”¹ã€‚å°‘æ•°ä»£ç ç¤ºä¾‹å¯èƒ½ä¼šå› ä»¥ä¸‹åŸå› è€Œä¸å¯ä¿®æ”¹ï¼š</p>
<ul>
<li>
<p>åµŒå…¥çš„ Playground æ— æ³•æ‰§è¡Œå•å…ƒæµ‹è¯•ã€‚å°†ä»£ç å¤åˆ¶å¹¶ç²˜è´´åˆ°å®é™… Playground ä¸­ï¼Œä»¥æ¼”ç¤ºå•å…ƒæµ‹è¯•ã€‚</p>
</li>
<li>
<p>åµŒå…¥çš„ Playground ä¼šåœ¨ç¦»å¼€é¡µé¢åä¸¢å¤±ç¼–è¾‘çŠ¶æ€ï¼å› æ­¤ï¼Œå­¦å‘˜åº”ä½¿ç”¨æœ¬åœ°å®‰è£…çš„ Rust æˆ–é€šè¿‡ Playground è§£é¢˜ã€‚</p>
</li>
</ul>
</details>
<h1><a class="header" href="#ä½¿ç”¨-cargo-åœ¨æœ¬åœ°è¿è¡Œä»£ç " id="ä½¿ç”¨-cargo-åœ¨æœ¬åœ°è¿è¡Œä»£ç ">ä½¿ç”¨ Cargo åœ¨æœ¬åœ°è¿è¡Œä»£ç </a></h1>
<p>å¦‚æœä½ æƒ³åœ¨è‡ªå·±çš„ç³»ç»Ÿä¸Šè¿›è¡Œä»£ç å®éªŒï¼Œ åˆ™éœ€è¦å…ˆå®‰è£… Rustã€‚ä¸ºæ­¤ï¼Œè¯·æŒ‰ç…§ <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Rust Book ä¸­çš„è¯´æ˜</a> æ“ä½œã€‚è¿™åº”ä¼šä¸ºä½ æä¾›ä¸€ä¸ªæœ‰æ•ˆçš„ <code>rustc</code> å’Œ <code>cargo</code>ã€‚åœ¨æ’°å†™æœ¬æ–‡æ—¶ï¼Œæœ€æ–°çš„ Rust ç¨³å®šç‰ˆæ˜¯ä»¥ä¸‹çš„ç‰ˆæœ¬å·ï¼š</p>
<pre><code class="language-shell">% rustc --version
rustc 1.69.0 (84c898d65 2023-04-16)
% cargo --version
cargo 1.69.0 (6e9a83356 2023-04-12)
</code></pre>
<p>ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ä»»ä½•æ›´é«˜ç‰ˆæœ¬ï¼Œå› ä¸º Rust ä¿æŒå‘åå…¼å®¹æ€§ã€‚</p>
<p>äº†è§£è¿™äº›ä¿¡æ¯åï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ä»æœ¬åŸ¹è®­ä¸­çš„ä¸€ä¸ªç¤ºä¾‹ä¸­æ„å»º Rust äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<ol>
<li>
<p>åœ¨ä½ è¦å¤åˆ¶çš„ç¤ºä¾‹ä¸Šç‚¹å‡»â€œå¤åˆ¶åˆ°å‰ªè´´æ¿ï¼ˆCopy to clipboardï¼‰â€æŒ‰é’®ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo new exercise</code> ä¸ºä»£ç æ–°å»ºä¸€ä¸ª <code>exercise/</code> ç›®å½•ï¼š</p>
<pre><code class="language-shell">$ cargo new exercise
     Created binary (application) `exercise` package
</code></pre>
</li>
<li>
<p>è½¬åˆ° <code>exercise/</code> å¹¶ä½¿ç”¨ <code>cargo run</code> æ„å»ºå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">$ cd exercise
$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.75s
     Running `target/debug/exercise`
Hello, world!
</code></pre>
</li>
<li>
<p>å°† <code>src/main.rs</code> ä¸­çš„æ ·æ¿ä»£ç æ›¿æ¢ä¸ºè‡ªå·±çš„ä»£ç ã€‚ä¾‹å¦‚ï¼Œ ä½¿ç”¨ä¸Šä¸€é¡µä¸­çš„ç¤ºä¾‹ï¼Œå°† <code>src/main.rs</code> æ”¹ä¸ºï¼š</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Edit me!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo run</code> æ„å»ºå¹¶è¿è¡Œæ›´æ–°åçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">$ cargo run
   Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/exercise`
Edit me!
</code></pre>
</li>
<li>
<p>ä½¿ç”¨ <code>cargo check</code> å¿«é€Ÿæ£€æŸ¥é¡¹ç›®æ˜¯å¦å­˜åœ¨é”™è¯¯ï¼›ä½¿ç”¨ <code>cargo build</code> åªè¿›è¡Œç¼–è¯‘ï¼Œè€Œä¸è¿è¡Œã€‚ä½ å¯ä»¥åœ¨ <code>target/debug/</code> ä¸­æ‰¾åˆ°å¸¸è§„è°ƒè¯• build çš„è¾“å‡ºã€‚ä½¿ç”¨ <code>cargo build --release</code> åœ¨ <code>target/release/</code> ä¸­ç”Ÿæˆç»è¿‡ä¼˜åŒ–çš„ å‘å¸ƒ buildã€‚</p>
</li>
<li>
<p>å¯ä»¥é€šè¿‡ä¿®æ”¹ <code>Cargo.toml</code> ä¸ºé¡¹ç›®æ·»åŠ ä¾èµ–é¡¹ã€‚å½“è¿è¡Œ <code>cargo</code> å‘½ä»¤æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ä¸‹è½½å’Œç¼–è¯‘ç¼ºå¤±çš„ä¾èµ–é¡¹ã€‚</p>
</li>
</ol>
<details>
<p>å°½é‡é¼“åŠ±å…¨ç­å­¦å‘˜å®‰è£… Cargo å¹¶ä½¿ç”¨æœ¬åœ°ç¼–è¾‘å™¨ã€‚è¿™èƒ½ä½¿ä»–ä»¬æ‹¥æœ‰å¸¸è§„çš„å¼€å‘ç¯å¢ƒï¼Œè®©å·¥ä½œå˜å¾—æ›´åŠ è½»æ¾ã€‚</p>
</details>
<h1><a class="header" href="#æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©" id="æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©">æ¬¢è¿æ¥åˆ°ç¬¬ä¸€å¤©</a></h1>
<p>ä»Šå¤©æ˜¯å­¦ä¹  Comprehensive Rust çš„ç¬¬ä¸€å¤©ã€‚æˆ‘ä»¬ä¼šæ¶‰åŠå¾ˆå¤šå†…å®¹ï¼š</p>
<ul>
<li>Rust åŸºæœ¬è¯­æ³•ï¼šå˜é‡ã€æ ‡é‡ï¼ˆscalarï¼‰å’Œå¤åˆï¼ˆcompoundï¼‰ç±»å‹ã€æšä¸¾ï¼ˆEnumï¼‰ã€ç»“æ„ä½“ï¼ˆstructï¼‰ã€å¼•ç”¨ã€å‡½æ•°å’Œæ–¹æ³•ã€‚</li>
<li>Types and type inference.</li>
<li>æ§åˆ¶æµç»“æ„ï¼šå¾ªç¯ã€æ¡ä»¶è¯­å¥ç­‰ã€‚</li>
<li>ç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼šç»“æ„ä½“å’Œæšä¸¾ã€‚</li>
<li>æ¨¡å¼åŒ¹é…ï¼šè§£æ„æšä¸¾ã€ç»“æ„ä½“å’Œæ•°ç»„ï¼ˆarrayï¼‰ã€‚</li>
</ul>
<h2><a class="header" href="#æ—¶é—´è¡¨" id="æ—¶é—´è¡¨">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<details>
<p>è¯·æé†’å­¦ç”Ÿï¼š</p>
<ul>
<li>ä»–ä»¬å¯ä»¥éšæ—¶æé—®ï¼Œä¸éœ€è¦ç•™åˆ°æœ€åã€‚</li>
<li>è¿™ä¸ªè¯¾ç¨‹æœ¬åº”è¯¥æ˜¯äº’åŠ¨çš„ï¼Œæˆ‘ä»¬é¼“åŠ±å¤§å®¶ç§¯æè®¨è®ºã€‚
<ul>
<li>As an instructor, you should try to keep the discussions relevant, i.e., keep the discussions related to how Rust does things vs some other language. It can be hard to find the right balance, but err on the side of allowing discussions since they engage people much more than one-way communication.</li>
</ul>
</li>
<li>æœ‰äº›é—®é¢˜ä¼šå¯¼è‡´æˆ‘ä»¬æå‰è°ˆåˆ°åé¢çš„å†…å®¹ã€‚
<ul>
<li>è¿™å®Œå…¨æ²¡æœ‰é—®é¢˜ï¼é‡å¤æ˜¯å­¦ä¹ çš„ä¸€ä¸ªé‡è¦æ–¹æ³•ã€‚è¯·è®°ä½ï¼Œè¿™äº›å¹»ç¯ç‰‡åªæ˜¯ä¸€ç§è¾…åŠ©ï¼Œä½ å¯ä»¥é€‰æ‹©æ€§åœ°è·³è¿‡ã€‚</li>
</ul>
</li>
</ul>
<p>ç¬¬ä¸€å¤©çš„ç›®æ ‡æ˜¯å±•ç¤º Rust ä¸­ä¸å…¶ä»–ç¼–ç¨‹è¯­è¨€æœ‰æ˜æ˜¾ç›¸ä¼¼ä¹‹å¤„çš„ â€œåŸºç¡€â€å†…å®¹ã€‚Rust ä¸­æ›´é«˜çº§å¤æ‚çš„å†…å®¹å°†åœ¨åç»­å‡ å¤©ä¸­é€æ­¥ä»‹ç»ã€‚</p>
<p>å¦‚æœæ‚¨æ˜¯åœ¨æ•™å®¤é‡Œæˆè¯¾ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªå¥½æ—¶æœºï¼Œå¯å¯¹è¯¾ç¨‹æ—¶é—´è¡¨è¿›è¡Œè®²è§£ã€‚è¯·æ³¨æ„ï¼Œæ¯èŠ‚è¯¾ç»“æŸä¹‹åä¼šæœ‰ç»ƒä¹ å†…å®¹ï¼Œç„¶åæ˜¯ä¼‘æ¯æ—¶é—´ã€‚å®‰æ’åœ¨ä¼‘æ¯ç»“æŸåè®²è§£ç»ƒä¹ å†…å®¹çš„è§£ç­”ã€‚ä¸ºäº†ç¡®ä¿è¯¾ç¨‹æŒ‰æ—¶é—´è¡¨è¿›è¡Œï¼Œæ­¤å¤„æ‰€åˆ—æ—¶é—´ä»…ä¾›å‚è€ƒã€‚è¯·æŒ‰éœ€è¿›è¡Œçµæ´»è°ƒæ•´ï¼</p>
</details><h1><a class="header" href="#hello-world" id="hello-world">Hello, World</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#ä»€ä¹ˆæ˜¯-rust" id="ä»€ä¹ˆæ˜¯-rust">ä»€ä¹ˆæ˜¯ Rustï¼Ÿ</a></h1>
<p>Rust æ˜¯ä¸€é—¨æ–°çš„ç¼–ç¨‹è¯­è¨€ï¼Œå®ƒçš„<a href="https://blog.rust-lang.org/2015/05/15/Rust-1.0.html">1.0 ç‰ˆæœ¬äº 2015 å¹´å‘å¸ƒ</a>ï¼š</p>
<ul>
<li>Rust æ˜¯ä¸€é—¨é™æ€ç¼–è¯‘è¯­è¨€ï¼Œå…¶åŠŸèƒ½å®šä½ä¸ C++ ç›¸ä¼¼
<ul>
<li><code>rustc</code> ä½¿ç”¨ LLVM ä½œä¸ºå®ƒçš„åç«¯ã€‚</li>
</ul>
</li>
<li>Rust æ”¯æŒå¤šç§<a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">å¹³å°å’Œæ¶æ„</a>:
<ul>
<li>x86ã€ARMã€WebAssembly......</li>
<li>Linuxã€Macã€Windows......</li>
</ul>
</li>
<li>Rust è¢«å¹¿æ³›ç”¨äºå„ç§è®¾å¤‡ä¸­ï¼š
<ul>
<li>å›ºä»¶å’Œå¼•å¯¼ç¨‹åºï¼Œ</li>
<li>æ™ºèƒ½æ˜¾ç¤ºå™¨ï¼Œ</li>
<li>æ‰‹æœºï¼Œ</li>
<li>æ¡Œé¢ï¼Œ</li>
<li>æœåŠ¡å™¨ã€‚</li>
</ul>
</li>
</ul>
<details>
<p>Rust å’Œ C++ é€‚ç”¨äºç±»ä¼¼çš„åœºæ™¯ï¼š</p>
<ul>
<li>æé«˜çš„çµæ´»æ€§ã€‚</li>
<li>é«˜åº¦çš„æ§åˆ¶èƒ½åŠ›ã€‚</li>
<li>èƒ½å¤Ÿåœ¨èµ„æºåŒ®ä¹çš„è®¾å¤‡ï¼ˆå¦‚æ‰‹æœºï¼‰ä¸Šè¿è¡Œã€‚</li>
<li>æ²¡æœ‰è¿è¡Œæ—¶å’Œåƒåœ¾æ”¶é›†ã€‚</li>
<li>å…³æ³¨ç¨‹åºå¯é æ€§å’Œå®‰å…¨æ€§ï¼Œè€Œä¸ä¼šç‰ºç‰²ä»»ä½•æ€§èƒ½ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#rust-çš„ä¼˜åŠ¿" id="rust-çš„ä¼˜åŠ¿">Rust çš„ä¼˜åŠ¿</a></h1>
<p>Rust æœ‰ä¸€äº›ç‹¬ç‰¹çš„å–ç‚¹ï¼š</p>
<ul>
<li>
<p><em>ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨</em>ï¼šåœ¨ç¼–è¯‘æ—¶å¯é˜²æ­¢æ‰€æœ‰ç±»å†…å­˜ bug</p>
<ul>
<li>ä¸å­˜åœ¨æœªåˆå§‹åŒ–çš„å˜é‡ã€‚</li>
<li>ä¸å­˜åœ¨â€œåŒé‡é‡Šæ”¾â€ã€‚</li>
<li>ä¸å­˜åœ¨â€œé‡Šæ”¾åä½¿ç”¨â€ã€‚</li>
<li>ä¸å­˜åœ¨ <code>NULL</code> æŒ‡é’ˆã€‚</li>
<li>ä¸å­˜åœ¨è¢«é—å¿˜çš„äº’æ–¥é”ã€‚</li>
<li>ä¸å­˜åœ¨çº¿ç¨‹ä¹‹é—´çš„æ•°æ®ç«äº‰ã€‚</li>
<li>ä¸å­˜åœ¨è¿­ä»£å™¨å¤±æ•ˆã€‚</li>
</ul>
</li>
<li>
<p><em>æ²¡æœ‰æœªå®šä¹‰çš„è¿è¡Œæ—¶è¡Œä¸º</em>ï¼šæ¯ä¸ª Rust è¯­å¥çš„è¡Œä¸ºéƒ½æœ‰æ˜ç¡®å®šä¹‰</p>
<ul>
<li>æ•°ç»„è®¿é—®æœ‰è¾¹ç•Œæ£€æŸ¥ã€‚</li>
<li>æ•´æ•°æº¢å‡ºæœ‰æ˜ç¡®å®šä¹‰ï¼ˆpanic æˆ–å›ç»•ï¼‰ã€‚</li>
</ul>
</li>
<li>
<p><em>ç°ä»£è¯­è¨€åŠŸèƒ½</em>ï¼šå…·æœ‰ä¸é«˜çº§è¯­è¨€ä¸€æ ·ä¸°å¯Œä¸”äººæ€§åŒ–çš„è¡¨è¾¾èƒ½åŠ›</p>
<ul>
<li>æšä¸¾å’Œæ¨¡å¼åŒ¹é…ã€‚</li>
<li>æ³›å‹ã€‚</li>
<li>æ— é¢å¤–å¼€é”€çš„å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆFFIï¼‰ã€‚</li>
<li>é›¶æˆæœ¬æŠ½è±¡ã€‚</li>
<li>å¼ºå¤§çš„ç¼–è¯‘å™¨é”™è¯¯æç¤ºã€‚</li>
<li>å†…ç½®ä¾èµ–ç®¡ç†å™¨ã€‚</li>
<li>å¯¹æµ‹è¯•çš„å†…ç½®æ”¯æŒã€‚</li>
<li>ä¼˜ç§€çš„è¯­è¨€æœåŠ¡åè®®ï¼ˆLanguage Server Protocolï¼‰æ”¯æŒã€‚</li>
</ul>
</li>
</ul>
<details>
<p>ä¸ç”¨åœ¨è¿™é‡Œå ç”¨è¿‡å¤šæ—¶é—´ã€‚æ‰€æœ‰è¿™äº›è¦ç‚¹å‡ä¼šåœ¨åé¢è¿›è¡Œè¯¦ç»†è®²è§£ã€‚</p>
<p>åº”è¯¥é—®é—®å­¦ç”Ÿä»¬éƒ½ä½¿ç”¨è¿‡å“ªäº›è¯­è¨€ã€‚æ ¹æ®ç­”æ¡ˆä¾§é‡è®²è§£ Rust çš„ä¸åŒç‰¹æ€§ï¼š</p>
<ul>
<li>
<p>ä½¿ç”¨è¿‡ C æˆ– C++ï¼šRust åˆ©ç”¨å€Ÿç”¨æ£€æŸ¥æ¶ˆé™¤äº†ä¸€ç±» <em>è¿è¡Œæ—¶é”™è¯¯</em> ã€‚ä½ å¯ä»¥è¾¾åˆ°å ªæ¯” C å’Œ C++ çš„æ€§èƒ½ï¼Œè€Œæ²¡æœ‰å†…å­˜ä¸å®‰å…¨çš„é—®é¢˜ã€‚å¹¶ä¸”ä½ è¿˜å¯ä»¥å¾—åˆ°äº›ç°ä»£çš„è¯­è¨€æ„é€ ï¼Œæ¯”å¦‚æ¨¡å¼åŒ¹é…å’Œå†…ç½®ä¾èµ–ç®¡ç†ã€‚</p>
</li>
<li>
<p>Experience with Java, Go, Python, JavaScript...: You get the same memory safety as in those languages, plus a similar high-level language feeling. In addition you get fast and predictable performance like C and C++ (no garbage collector) as well as access to low-level hardware (should you need it).</p>
</li>
</ul>
</details><h1><a class="header" href="#playground" id="playground">Playground</a></h1>
<p>The <a href="https://play.rust-lang.org/">Rust Playground</a> provides an easy way to run short Rust programs, and is the basis for the examples and exercises in this course. Try running the &quot;hello-world&quot; program it starts with. It comes with a few handy features:</p>
<ul>
<li>
<p>åœ¨ &quot;Tools&quot; ä¸‹ï¼Œä½¿ç”¨ <code>rustfmt</code> é€‰é¡¹ä»¥ &quot;standard&quot; æ–¹å¼è®¾ç½®ä»£ç æ ¼å¼ã€‚</p>
</li>
<li>
<p>Rust å…·æœ‰ä¸¤ä¸ªç”¨äºç”Ÿæˆä»£ç çš„ä¸»è¦ â€œé…ç½®æ–‡ä»¶â€ï¼šè°ƒè¯•ï¼ˆè¿›è¡Œé¢å¤–è¿è¡Œæ—¶æ£€æŸ¥ã€è¾ƒå°‘ä¼˜åŒ–ï¼‰å’Œå‘å¸ƒï¼ˆè¾ƒå°‘è¿è¡Œæ—¶æ£€æŸ¥ï¼Œè¿›è¡Œå¤§é‡ä¼˜åŒ–ï¼‰ã€‚å¯ä»¥åœ¨é¡¶éƒ¨çš„ &quot;Debug&quot; ä¸‹è®¿é—®è¿™äº›å†…å®¹ã€‚</p>
</li>
<li>
<p>å¦‚æœæ„Ÿå…´è¶£ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ &quot;...&quot; ä¸‹çš„ &quot;ASM&quot; æŸ¥çœ‹ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ã€‚</p>
</li>
</ul>
<details>
<p>As students head into the break, encourage them to open up the playground and experiment a little. Encourage them to keep the tab open and try things out during the rest of the course. This is particularly helpful for advanced students who want to know more about Rust's optimizations or generated assembly.</p>
</details><h1><a class="header" href="#ç±»å‹å’Œå€¼" id="ç±»å‹å’Œå€¼">ç±»å‹å’Œå€¼</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#hello-world-1" id="hello-world-1">Hello, World</a></h1>
<p>è®©æˆ‘ä»¬è¿›å…¥æœ€ç®€å•çš„ Rust ç¨‹åºï¼Œä¸€ä¸ªç»å…¸çš„ Hello World ç¨‹åºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello ğŸŒ!&quot;);
}
</code></pre></pre>
<p>ä½ çœ‹åˆ°çš„ï¼š</p>
<ul>
<li>å‡½æ•°ä»¥ <code>fn</code> å¼€å¤´ã€‚</li>
<li>åƒ C å’Œ C++ ä¸€æ ·ï¼Œå—ç”±èŠ±æ‹¬å·åˆ†éš”ã€‚</li>
<li><code>main</code> å‡½æ•°æ˜¯ç¨‹åºçš„å…¥å£ç‚¹ã€‚</li>
<li>Rust æœ‰å«ç”Ÿå® (hygienic macros)ï¼Œ<code>println!</code> å°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚</li>
<li>Rust å­—ç¬¦ä¸²æ˜¯ UTF-8 ç¼–ç çš„ï¼Œå¯ä»¥åŒ…å«ä»»ä½• Unicode å­—ç¬¦ã€‚</li>
</ul>
<details>
<p>This slide tries to make the students comfortable with Rust code. They will see a ton of it over the next four days so we start small with something familiar.</p>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Rust is very much like other languages in the C/C++/Java tradition. It is imperative and it doesn't try to reinvent things unless absolutely necessary.</p>
</li>
<li>
<p>Rust æ˜¯ä¸€é—¨ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼Œå®ƒå®Œå…¨æ”¯æŒ Unicode ç­‰ç‰¹æ€§ã€‚</p>
</li>
<li>
<p>Rust uses macros for situations where you want to have a variable number of arguments (no function <a href="types-and-values/../control-flow-basics/functions.html">overloading</a>).</p>
</li>
<li>
<p>å®æ˜¯â€œå«ç”Ÿçš„â€ï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¸ä¼šæ„å¤–åœ°æ•è·å®ƒä»¬æ‰€åœ¨ä½œç”¨åŸŸä¸­çš„æ ‡è¯†ç¬¦ã€‚å®é™…ä¸Šï¼ŒRust çš„å®åªæ˜¯<a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">éƒ¨åˆ†å«ç”Ÿ</a>ã€‚</p>
</li>
<li>
<p>Rust æ˜¯å¤šèŒƒå¼ç¼–ç¨‹è¯­è¨€ã€‚ä¾‹å¦‚ï¼Œå®ƒå…·æœ‰å¼ºå¤§çš„<a href="https://doc.rust-lang.org/book/ch17-00-oop.html">é¢å‘å¯¹è±¡çš„ç¼–ç¨‹åŠŸèƒ½</a>ï¼Œè™½ç„¶å®ƒä¸æ˜¯å‡½æ•°å¼è¯­è¨€ï¼Œä½†åŒ…æ‹¬ä¸€ç³»åˆ—çš„<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">å‡½æ•°æ¦‚å¿µ</a>ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å˜é‡" id="å˜é‡">å˜é‡</a></h1>
<p>Rust provides type safety via static typing. Variable bindings are made with <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: i32 = 10;
    println!(&quot;x: {x}&quot;);
    // x = 20;
    // println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>å–æ¶ˆå¤‡æ³¨ <code>x = 20</code>ï¼Œä»¥è¯æ˜å˜é‡é»˜è®¤æ˜¯ä¸å¯å˜çš„ã€‚æ·»åŠ  <code>mut</code> å…³é”®å­—ä»¥å…è®¸è¿›è¡Œæ›´æ”¹ã€‚</p>
</li>
<li>
<p>è¿™é‡Œçš„ <code>i32</code> æ˜¯å˜é‡çš„ç±»å‹ã€‚ç¼–è¯‘æ—¶å¿…é¡»å·²çŸ¥ç±»å‹ï¼Œä½†åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œç”±äºå…·æœ‰ç±»å‹æ¨ç†åŠŸèƒ½ï¼ˆç¨åä»‹ç»ï¼‰ï¼Œç¨‹åºå‘˜å¯ä»¥å¿½ç•¥è¿™ä¸€ç‚¹ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å€¼" id="å€¼">å€¼</a></h1>
<p>ä»¥ä¸‹æ˜¯ä¸€äº›åŸºæœ¬çš„å†…ç½®ç±»å‹ä»¥åŠæ¯ç§ç±»å‹çš„å­—é¢é‡å€¼çš„è¯­æ³•ã€‚</p>
<table><thead><tr><th></th><th>ç±»å‹</th><th>å­—é¢é‡</th></tr></thead><tbody>
<tr><td>æœ‰ç¬¦å·æ•´æ•°</td><td><code>i8</code>ã€<code>i16</code>ã€<code>i32</code>ã€<code>i64</code>ã€<code>i128</code>ã€<code>isize</code></td><td><code>-10</code>ã€<code>0</code>ã€<code>1_000</code>ã€<code>123_i64</code></td></tr>
<tr><td>æ— ç¬¦å·æ•´æ•°</td><td><code>u8</code>ã€<code>u16</code>ã€<code>u32</code>ã€<code>u64</code>ã€<code>u128</code>ã€<code>usize</code></td><td><code>0</code>ã€<code>123</code>ã€<code>10_u16</code></td></tr>
<tr><td>æµ®ç‚¹æ•°</td><td><code>f32</code>ã€<code>f64</code></td><td><code>3.14</code>ã€<code>-10.0e20</code>ã€<code>2_f32</code></td></tr>
<tr><td>Unicode æ ‡é‡ç±»å‹</td><td><code>char</code></td><td><code>'a'</code>ã€<code>'Î±'</code>ã€<code>'âˆ'</code></td></tr>
<tr><td>å¸ƒå°”å€¼</td><td><code>bool</code></td><td><code>true</code>ã€<code>false</code></td></tr>
</tbody></table>
<p>å„ç±»å‹å ç”¨çš„ç©ºé—´ä¸ºï¼š</p>
<ul>
<li><code>iN</code>, <code>uN</code> å’Œ <code>fN</code> å ç”¨ <em>N</em> ä½ï¼Œ</li>
<li><code>isize</code> å’Œ <code>usize</code> å ç”¨ä¸€ä¸ªæŒ‡é’ˆå¤§å°çš„ç©ºé—´ï¼Œ</li>
<li><code>char</code> å ç”¨ 32 ä½ç©ºé—´ï¼Œ</li>
<li><code>bool</code> å ç”¨ 8 ä½ç©ºé—´ã€‚</li>
</ul>
<details>
<p>ä¸Šè¡¨ä¸­è¿˜æœ‰ä¸€äº›æœªæåŠçš„è¯­æ³•ï¼š</p>
<ul>
<li>æ•°å­—ä¸­çš„æ‰€æœ‰ä¸‹åˆ’çº¿å‡å¯å¿½ç•¥ï¼Œå®ƒä»¬åªæ˜¯ä¸ºäº†æ–¹ä¾¿è¾¨è¯†ã€‚å› æ­¤ï¼Œ<code>1_000</code> å¯ä»¥å†™ä¸º <code>1000</code>ï¼ˆæˆ– <code>10_00</code>ï¼‰ï¼Œè€Œ <code>123_i64</code> å¯ä»¥å†™ä¸º <code>123i64</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç®—æœ¯" id="ç®—æœ¯">ç®—æœ¯</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn interproduct(a: i32, b: i32, c: i32) -&gt; i32 {
    return a * b + b * c + c * a;
}

fn main() {
    println!(&quot;result: {}&quot;, interproduct(120, 100, 248));
}
</code></pre></pre>
<details>
<p>è¿™æ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡çœ‹åˆ°é™¤ <code>main</code> ä¹‹å¤–çš„å‡½æ•°ï¼Œä¸è¿‡å…¶å«ä¹‰åº”è¯¥å¾ˆæ˜ç¡®ï¼šå®ƒæ¥å—ä¸‰ä¸ªæ•´æ•°ï¼Œç„¶åè¿”å›ä¸€ä¸ªæ•´æ•°ã€‚ç¨åä¼šå¯¹è¿™äº›å‡½æ•°è¿›è¡Œè¯¦ç»†ä»‹ç»ã€‚</p>
<p>ç®—æœ¯å’Œä¼˜å…ˆçº§å‡ä¸å…¶ä»–è¯­è¨€æä¸ºç›¸ä¼¼ã€‚</p>
<p>What about integer overflow? In C and C++ overflow of <em>signed</em> integers is actually undefined, and might do unknown things at runtime. In Rust, it's defined.</p>
<p>Change the <code>i32</code>'s to <code>i16</code> to see an integer overflow, which panics (checked) in a debug build and wraps in a release build. There are other options, such as overflowing, saturating, and carrying. These are accessed with method syntax, e.g., <code>(a * b).saturating_add(b * c).saturating_add(c * a)</code>.</p>
<p>äº‹å®ä¸Šï¼Œç¼–è¯‘å™¨ä¼šæ£€æµ‹å¸¸é‡è¡¨è¾¾å¼çš„æº¢å‡ºæƒ…å†µï¼Œè¿™ä¾¿æ˜¯ä¸ºä½•è¯¥ç¤ºä¾‹éœ€è¦å•ç‹¬çš„å‡½æ•°ã€‚</p>
</details><h1><a class="header" href="#ç±»å‹æ¨å¯¼" id="ç±»å‹æ¨å¯¼">ç±»å‹æ¨å¯¼</a></h1>
<p>Rust ä¼šæ ¹æ®å˜é‡çš„ä½¿ç”¨æ¥ç¡®å®šå…¶ç±»å‹ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn takes_u32(x: u32) {
    println!(&quot;u32: {x}&quot;);
}

fn takes_i8(y: i8) {
    println!(&quot;i8: {y}&quot;);
}

fn main() {
    let x = 10;
    let y = 20;

    takes_u32(x);
    takes_i8(y);
    // takes_u32(y);
}
</code></pre></pre>
<details>
<p>è¿™å¼ å¹»ç¯ç‰‡æ¼”ç¤ºäº† Rust ç¼–è¯‘å™¨æ˜¯å¦‚ä½•æ ¹æ®å˜é‡å£°æ˜å’Œç”¨æ³•æ¥æ¨å¯¼å…¶ç±»å‹çš„ã€‚</p>
<p>éœ€è¦é‡ç‚¹å¼ºè°ƒçš„æ˜¯è¿™æ ·å£°æ˜çš„å˜é‡å¹¶éåƒé‚£ç§åŠ¨æ€ç±»å‹è¯­è¨€ä¸­å¯ä»¥æŒæœ‰ä»»ä½•æ•°æ®çš„â€œä»»ä½•ç±»å‹â€ã€‚è¿™ç§å£°æ˜æ‰€ç”Ÿæˆçš„æœºå™¨ç ä¸æ˜ç¡®ç±»å‹å£°æ˜å®Œå…¨ç›¸åŒã€‚ç¼–è¯‘å™¨è¿›è¡Œç±»å‹æ¨å¯¼èƒ½å¤Ÿè®©æˆ‘ä»¬ç¼–å†™æ›´ç®€ç•¥çš„ä»£ç ã€‚</p>
<p>å½“æ•´æ•°å­—é¢é‡çš„ç±»å‹ä¸å—é™åˆ¶æ—¶ï¼ŒRust é»˜è®¤ä¸º <code>i32</code>ã€‚è¿™åœ¨é”™è¯¯æ¶ˆæ¯ä¸­æœ‰æ—¶æ˜¾ç¤ºä¸º <code>{integer}</code>ã€‚åŒæ ·ï¼Œæµ®ç‚¹å­—é¢é‡é»˜è®¤ä¸º <code>f64</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    let x = 3.14;
    let y = 20;
    assert_eq!(x, y);
    // ERROR: no implementation for `{float} == {integer}`
}
</code></pre></pre>
</details><h1><a class="header" href="#ç»ƒä¹ fibonacci" id="ç»ƒä¹ fibonacci">ç»ƒä¹ ï¼šFibonacci</a></h1>
<p>The Fibonacci sequence begins with <code>[0,1]</code>. For n&gt;1, the n'th Fibonacci number is calculated recursively as the sum of the n-1'th and n-2'th Fibonacci numbers.</p>
<p>Write a function <code>fib(n)</code> that calculates the n'th Fibonacci number. When will this function panic?</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        // The base case.
        todo!(&quot;Implement this&quot;)
    } else {
        // The recursive case.
        todo!(&quot;Implement this&quot;)
    }
}

fn main() {
    let n = 20;
    println!(&quot;fib({n}) = {}&quot;, fib(n));
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”" id="è§£ç­”">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn fib(n: u32) -&gt; u32 {
    if n &lt; 2 {
        return n;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}

fn main() {
    let n = 20;
    println!(&quot;fib({n}) = {}&quot;, fib(n));
}
</code></pre></pre>
<h1><a class="header" href="#æ§åˆ¶æµåŸºç¡€" id="æ§åˆ¶æµåŸºç¡€">æ§åˆ¶æµåŸºç¡€</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#if-è¡¨è¾¾å¼" id="if-è¡¨è¾¾å¼"><code>if</code> è¡¨è¾¾å¼</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-expressions"><code>if</code> è¡¨è¾¾å¼</a> çš„ç”¨æ³•ä¸å…¶ä»–è¯­è¨€ä¸­çš„ <code>if</code> è¯­å¥å®Œå…¨ä¸€æ ·ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 10;
    if x == 0 {
        println!(&quot;zero!&quot;);
    } else if x &lt; 100 {
        println!(&quot;biggish&quot;);
    } else {
        println!(&quot;huge&quot;);
    }
}
</code></pre></pre>
<p>æ­¤å¤–ï¼Œä½ è¿˜å¯ä»¥å°† <code>if</code> ç”¨ä½œä¸€ä¸ªè¡¨è¾¾å¼ã€‚æ¯ä¸ªå—çš„æœ€åä¸€ä¸ªè¡¨è¾¾å¼ å°†æˆä¸º <code>if</code> è¡¨è¾¾å¼çš„å€¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 10;
    let size = if x &lt; 20 { &quot;small&quot; } else { &quot;large&quot; };
    println!(&quot;number size: {}&quot;, size);
}
</code></pre></pre>
<details>
<p>Because <code>if</code> is an expression and must have a particular type, both of its branch blocks must have the same type. Show what happens if you add <code>;</code> after <code>&quot;small&quot;</code> in the second example.</p>
<p>An <code>if</code> expression should be used in the same way as the other expressions. For example, when it is used in a <code>let</code> statement, the statement must be terminated with a <code>;</code> as well. Remove the <code>;</code> before <code>println!</code> to see the compiler error.</p>
</details><h1><a class="header" href="#å¾ªç¯æ§åˆ¶" id="å¾ªç¯æ§åˆ¶">å¾ªç¯æ§åˆ¶</a></h1>
<p>Rust ä¸­æœ‰ä¸‰ä¸ªå¾ªç¯å…³é”®å­—ï¼š<code>while</code>ã€<code>loop</code> å’Œ <code>for</code>ï¼š</p>
<h2><a class="header" href="#while" id="while"><code>while</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops"><code>while</code> keyword</a> works much like in other languages, executing the loop body as long as the condition is true.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 200;
    while x &gt;= 10 {
        x = x / 2;
    }
    println!(&quot;Final x: {x}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#for" id="for"><code>for</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.for.html"><code>for</code> loop</a> iterates over ranges of values or the items in a collection:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    for x in 1..5 {
        println!(&quot;x: {x}&quot;);
    }

    for elem in [1, 2, 3, 4, 5] {
        println!(&quot;elem: {elem}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Under the hood <code>for</code> loops use a concept called &quot;iterators&quot; to handle iterating over different kinds of ranges/collections. Iterators will be discussed in more detail later.</li>
<li>Note that the first <code>for</code> loop only iterates to <code>4</code>. Show the <code>1..=5</code> syntax for an inclusive range.</li>
</ul>
</details>
<h1><a class="header" href="#loop" id="loop"><code>loop</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/keyword.loop.html"><code>loop</code> statement</a> just loops forever, until a <code>break</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        println!(&quot;{i}&quot;);
        if i &gt; 100 {
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#break-å’Œ-continue" id="break-å’Œ-continue"><code>break</code> å’Œ <code>continue</code></a></h1>
<p>å¦‚æœéœ€è¦ç«‹å³å¯åŠ¨ ä¸‹ä¸€æ¬¡è¿­ä»£ï¼Œè¯·ä½¿ç”¨ <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions"><code>continue</code></a>ã€‚</p>
<p>If you want to exit any kind of loop early, use <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions"><code>break</code></a>. With <code>loop</code>, this can take an optional expression that becomes the value of the <code>loop</code> expression.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut i = 0;
    loop {
        i += 1;
        if i &gt; 5 {
            break;
        }
        if i % 2 == 0 {
            continue;
        }
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<details>
<p>Note that <code>loop</code> is the only looping construct which can return a non-trivial value. This is because it's guaranteed to only return at a <code>break</code> statement (unlike <code>while</code> and <code>for</code> loops, which can also return when the condition fails).</p>
</details><h1><a class="header" href="#labels" id="labels">Labels</a></h1>
<p><code>continue</code> å’Œ <code>break</code> éƒ½å¯ä»¥é€‰æ‹©æ¥å—ä¸€ä¸ªæ ‡ç­¾å‚æ•°ï¼Œç”¨æ¥ ç»ˆæ­¢åµŒå¥—å¾ªç¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = [[5, 6, 7], [8, 9, 10], [21, 15, 32]];
    let mut elements_searched = 0;
    let target_value = 10;
    'outer: for i in 0..=2 {
        for j in 0..=2 {
            elements_searched += 1;
            if s[i][j] == target_value {
                break 'outer;
            }
        }
    }
    print!(&quot;elements searched: {elements_searched}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Labeled break also works on arbitrary blocks, e.g.
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'label: {
    break 'label;
    println!(&quot;This line gets skipped&quot;);
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</details>
<h1><a class="header" href="#ä»£ç å—å’Œä½œç”¨åŸŸ" id="ä»£ç å—å’Œä½œç”¨åŸŸ">ä»£ç å—å’Œä½œç”¨åŸŸ</a></h1>
<h2><a class="header" href="#å—" id="å—">å—</a></h2>
<p>A block in Rust contains a sequence of expressions, enclosed by braces <code>{}</code>. Each block has a value and a type, which are those of the last expression of the block:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let z = 13;
    let x = {
        let y = 10;
        println!(&quot;y: {y}&quot;);
        z - y
    };
    println!(&quot;x: {x}&quot;);
}
</code></pre></pre>
<p>If the last expression ends with <code>;</code>, then the resulting value and type is <code>()</code>.</p>
<details>
<ul>
<li>ä½ å¯ä»¥é€šè¿‡æ›´æ”¹å—çš„æœ€åä¸€è¡Œï¼Œæ¥å±•ç¤ºå—å€¼çš„å˜åŒ–æƒ…å†µã€‚ä¾‹å¦‚ï¼Œæ·»åŠ /ç§»é™¤åˆ†å·æˆ–ä½¿ç”¨ <code>return</code>ã€‚</li>
</ul>
</details><h1><a class="header" href="#ä½œç”¨åŸŸå’Œé®è”½shadowing" id="ä½œç”¨åŸŸå’Œé®è”½shadowing">ä½œç”¨åŸŸå’Œé®è”½ï¼ˆShadowingï¼‰</a></h1>
<p>å˜é‡çš„ä½œç”¨åŸŸä»…é™äºå°é—­ä»£ç å—å†…ã€‚</p>
<p>ä½ å¯ä»¥éšè—å˜é‡ï¼Œä½äºå¤–éƒ¨ä½œç”¨åŸŸçš„å˜é‡å’Œ ç›¸åŒä½œç”¨åŸŸçš„å˜é‡éƒ½å¯ä»¥ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 10;
    println!(&quot;before: {a}&quot;);
    {
        let a = &quot;hello&quot;;
        println!(&quot;inner scope: {a}&quot;);

        let a = true;
        println!(&quot;shadowed in inner scope: {a}&quot;);
    }

    println!(&quot;after: {a}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Show that a variable's scope is limited by adding a <code>b</code> in the inner block in the last example, and then trying to access it outside that block.</li>
<li>Shadowing is different from mutation, because after shadowing both variables' memory locations exist at the same time. Both are available under the same name, depending where you use it in the code.</li>
<li>A shadowing variable can have a different type.</li>
<li>éšè—èµ·åˆçœ‹èµ·æ¥ä¼šæœ‰äº›æ™¦æ¶©ï¼Œä½†æ˜¯å®ƒå¾ˆä¾¿äºå­˜ <code>.unwrap()</code> ä¹‹åçš„å¾—åˆ°çš„å€¼ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å‡½æ•°" id="å‡½æ•°">å‡½æ•°</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn gcd(a: u32, b: u32) -&gt; u32 {
    if b &gt; 0 {
        gcd(b, a % b)
    } else {
        a
    }
}

fn main() {
    println!(&quot;gcd: {}&quot;, gcd(143, 52));
}
</code></pre></pre>
<details>
<ul>
<li>ç±»å‹è·Ÿéšåœ¨å£°æ˜çš„å‚æ•°åï¼ˆä¸æŸäº›ç¼–ç¨‹è¯­è¨€ç›¸åï¼‰ï¼Œç„¶åæ˜¯è¿”å›ç±»å‹ã€‚</li>
<li>The last expression in a function body (or any block) becomes the return value. Simply omit the <code>;</code> at the end of the expression. The <code>return</code> keyword can be used for early return, but the &quot;bare value&quot; form is idiomatic at the end of a function (refactor <code>gcd</code> to use a <code>return</code>).</li>
<li>Some functions have no return value, and return the 'unit type', <code>()</code>. The compiler will infer this if the return type is omitted.</li>
<li>Overloading is not supported -- each function has a single implementation.
<ul>
<li>å§‹ç»ˆé‡‡ç”¨å›ºå®šæ•°é‡çš„å‚æ•°ã€‚ä¸æ”¯æŒé»˜è®¤å‚æ•°ã€‚å®å¯ç”¨äºæ”¯æŒå¯å˜å‡½æ•°ã€‚</li>
<li>Always takes a single set of parameter types. These types can be generic, which will be covered later.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#å®" id="å®">å®</a></h1>
<p>å®åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šæ‰©å±•ä¸º Rust ä»£ç ï¼Œå¹¶ä¸”å¯ä»¥æ¥å—å¯å˜æ•°é‡çš„å‚æ•°ã€‚å®ƒä»¬ä»¥ <code>!</code> ç»“å°¾æ¥è¿›è¡ŒåŒºåˆ†ã€‚Rust æ ‡å‡†åº“åŒ…å«å„ç§æœ‰ç”¨çš„å®ã€‚</p>
<ul>
<li><code>println!(format, ..)</code> prints a line to standard output, applying formatting described in <a href="https://doc.rust-lang.org/std/fmt/index.html"><code>std::fmt</code></a>.</li>
<li><code>format!(format, ..)</code> çš„ç”¨æ³•ä¸ <code>println!</code> ç±»ä¼¼ï¼Œä½†å®ƒä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›ç»“æœã€‚</li>
<li><code>dbg!(expression)</code> ä¼šè®°å½•è¡¨è¾¾å¼çš„å€¼å¹¶è¿”å›è¯¥å€¼ã€‚</li>
<li><code>todo!()</code> ç”¨äºæ ‡è®°å°šæœªå®ç°çš„ä»£ç æ®µã€‚å¦‚æœæ‰§è¡Œè¯¥ä»£ç æ®µï¼Œåˆ™ä¼šè§¦å‘ panicã€‚</li>
<li><code>unreachable!()</code> ç”¨äºæ ‡è®°æ— æ³•è®¿é—®çš„ä»£ç æ®µã€‚å¦‚æœæ‰§è¡Œè¯¥ä»£ç æ®µï¼Œåˆ™ä¼šè§¦å‘ panicã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn factorial(n: u32) -&gt; u32 {
    let mut product = 1;
    for i in 1..=n {
        product *= dbg!(i);
    }
    product
}

fn fizzbuzz(n: u32) -&gt; u32 {
    todo!()
}

fn main() {
    let n = 4;
    println!(&quot;{n}! = {}&quot;, factorial(n));
}
</code></pre></pre>
<details>
<p>è¿™ä¸€èŠ‚çš„è¦ç‚¹æ˜¯ä»‹ç»è¿™äº›å¸¸è§çš„ä¾¿æ·åŠŸèƒ½ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒä»¬ã€‚è€Œä¸ºä½•å°†å®ƒä»¬å®šä¹‰ä¸ºå®ä»¥åŠå®ƒä»¬å¯ä»¥æ‰©å±•ä¸ºä»€ä¹ˆå†…å®¹ï¼Œå¹¶ä¸æ˜¯ç‰¹åˆ«å…³é”®ã€‚</p>
<p>æœ¬è¯¾ç¨‹ä¸ä¼šä»‹ç»å¦‚ä½•å®šä¹‰å®ï¼Œä½†åœ¨åç»­éƒ¨åˆ†ä¼šä»‹ç»æ´¾ç”Ÿå®çš„ç”¨æ³•ã€‚</p>
</details><h1><a class="header" href="#ç»ƒä¹ è€ƒæ‹‰å…¹åºåˆ—" id="ç»ƒä¹ è€ƒæ‹‰å…¹åºåˆ—">ç»ƒä¹ ï¼šè€ƒæ‹‰å…¹åºåˆ—</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz Sequence</a> is defined as follows, for an arbitrary n<sub>1</sub> greater than zero:</p>
<ul>
<li>If <em>n<sub>i</sub></em> is 1, then the sequence terminates at <em>n<sub>i</sub></em>.</li>
<li>If <em>n<sub>i</sub></em> is even, then <em>n<sub>i+1</sub> = n<sub>i</sub> / 2</em>.</li>
<li>If <em>n<sub>i</sub></em> is odd, then <em>n<sub>i+1</sub> = 3 * n<sub>i</sub> + 1</em>.</li>
</ul>
<p>For example, beginning with <em>n<sub>1</sub></em> = 3:</p>
<ul>
<li>3 is odd, so <em>n<sub>2</sub></em> = 3 * 3 + 1 = 10;</li>
<li>10 is even, so <em>n<sub>3</sub></em> = 10 / 2 = 5;</li>
<li>5 is odd, so <em>n<sub>4</sub></em> = 3 * 5 + 1 = 16;</li>
<li>16 is even, so <em>n<sub>5</sub></em> = 16 / 2 = 8;</li>
<li>8 is even, so <em>n<sub>6</sub></em> = 8 / 2 = 4;</li>
<li>4 is even, so <em>n<sub>7</sub></em> = 4 / 2 = 2;</li>
<li>2 is even, so <em>n<sub>8</sub></em> = 1; and</li>
<li>åºåˆ—ç»ˆæ­¢ã€‚</li>
</ul>
<p>ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—ç»™å®šåˆå§‹ <code>n</code> çš„è€ƒæ‹‰å…¹åºåˆ—çš„é•¿åº¦ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
  todo!(&quot;Implement this&quot;)
}

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}

fn main() {
    println!(&quot;Length: {}&quot;, collatz_length(11));
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-1" id="è§£ç­”-1">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Determine the length of the collatz sequence beginning at `n`.
fn collatz_length(mut n: i32) -&gt; u32 {
    let mut len = 1;
    while n &gt; 1 {
        n = if n % 2 == 0 { n / 2 } else { 3 * n + 1 };
        len += 1;
    }
    len
}

#[test]
fn test_collatz_length() {
    assert_eq!(collatz_length(11), 15);
}

fn main() {
    println!(&quot;Length: {}&quot;, collatz_length(11));
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back" id="welcome-back">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#å…ƒç»„å’Œæ•°ç»„" id="å…ƒç»„å’Œæ•°ç»„">å…ƒç»„å’Œæ•°ç»„</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#æ•°ç»„arrays" id="æ•°ç»„arrays">æ•°ç»„ï¼ˆArraysï¼‰</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i8; 10] = [42; 10];
    a[5] = 0;
    println!(&quot;a: {a:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>A value of the array type <code>[T; N]</code> holds <code>N</code> (a compile-time constant) elements of the same type <code>T</code>. Note that the length of the array is <em>part of its type</em>, which means that <code>[u8; 3]</code> and <code>[u8; 4]</code> are considered two different types. Slices, which have a size determined at runtime, are covered later.</p>
</li>
<li>
<p>è¯·å°è¯•è®¿é—®å‡ºç•Œæ•°ç»„å…ƒç´ ã€‚ç³»ç»Ÿä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ•°ç»„è®¿é—®ã€‚Rust é€šå¸¸ä¼šé€šè¿‡ä¼˜åŒ–æ¶ˆé™¤è¿™äº›æ£€æŸ¥ï¼Œä»¥åŠä½¿ç”¨ä¸å®‰å…¨çš„ Rust æ¥é¿å…è¿™äº›æ£€æŸ¥ã€‚</p>
</li>
<li>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å­—é¢é‡æ¥ä¸ºæ•°ç»„èµ‹å€¼ã€‚</p>
</li>
<li>
<p>The <code>println!</code> macro asks for the debug implementation with the <code>?</code> format parameter: <code>{}</code> gives the default output, <code>{:?}</code> gives the debug output. Types such as integers and strings implement the default output, but arrays only implement the debug output. This means that we must use debug output here.</p>
</li>
<li>
<p>æ·»åŠ  <code>#</code>ï¼Œæ¯”å¦‚ <code>{a:#?}</code>ï¼Œä¼šè¾“å‡ºâ€œç¾è§‚æ‰“å°ï¼ˆpretty printingï¼‰â€ æ ¼å¼ï¼Œè¿™ç§æ ¼å¼å¯èƒ½ä¼šæ›´åŠ æ˜“è¯»ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å…ƒç»„tuples" id="å…ƒç»„tuples">å…ƒç»„ï¼ˆTuplesï¼‰</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let t: (i8, bool) = (7, true);
    println!(&quot;t.0: {}&quot;, t.0);
    println!(&quot;t.1: {}&quot;, t.1);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>å’Œæ•°ç»„ä¸€æ ·ï¼Œå…ƒç»„ä¹Ÿå…·æœ‰å›ºå®šçš„é•¿åº¦ã€‚</p>
</li>
<li>
<p>å…ƒç»„å°†ä¸åŒç±»å‹çš„å€¼ç»„æˆä¸€ä¸ªå¤åˆç±»å‹ã€‚</p>
</li>
<li>
<p>å…ƒç»„ä¸­çš„å­—æ®µå¯ä»¥é€šè¿‡è‹±æ–‡å¥å·åŠ ä¸Šå€¼çš„ä¸‹æ ‡è¿›è¡Œè®¿é—®æ¯”å¦‚ï¼š<code>t.0</code>, <code>t.1</code>ã€‚</p>
</li>
<li>
<p>The empty tuple <code>()</code> is referred to as the &quot;unit type&quot; and signifies absence of a return value, akin to <code>void</code> in other languages.</p>
</li>
</ul>
</details><h1><a class="header" href="#æ•°ç»„è¿­ä»£" id="æ•°ç»„è¿­ä»£">æ•°ç»„è¿­ä»£</a></h1>
<p><code>for</code> è¯­å¥æ”¯æŒå¯¹æ•°ç»„è¿›è¡Œè¿­ä»£ï¼ˆä½†ä¸æ”¯æŒå…ƒç»„ï¼‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19];
    for prime in primes {
        for i in 2..prime {
            assert_ne!(prime % i, 0);
        }
    }
}
</code></pre></pre>
<details>
<p>æ­¤åŠŸèƒ½ä½¿ç”¨äº† <code>IntoIterator</code> traitï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è®²åˆ°å®ƒã€‚</p>
<p>The <code>assert_ne!</code> macro is new here. There are also <code>assert_eq!</code> and <code>assert!</code> macros. These are always checked, while debug-only variants like <code>debug_assert!</code> compile to nothing in release builds.</p>
</details><h1><a class="header" href="#è§£æ„" id="è§£æ„">è§£æ„</a></h1>
<p>When working with tuples and other structured values it's common to want to extract the inner values into local variables. This can be done manually by directly accessing the inner values:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_tuple(tuple: (i32, i32)) {
    let left = tuple.0;
    let right = tuple.1;
    println!(&quot;left: {left}, right: {right}&quot;);
}
</code></pre></pre>
<p>However, Rust also supports using pattern matching to destructure a larger value into its constituent parts:</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_tuple(tuple: (i32, i32)) {
    let (left, right) = tuple;
    println!(&quot;left: {left}, right: {right}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>The patterns used here are &quot;irrefutable&quot;, meaning that the compiler can statically verify that the value on the right of <code>=</code> has the same structure as the pattern.</li>
<li>A variable name is an irrefutable pattern that always matches any value, hence why we can also use <code>let</code> to declare a single variable.</li>
<li>Rust also supports using patterns in conditionals, allowing for equality comparison and destructuring to happen at the same time. This form of pattern matching will be discussed in more detail later.</li>
<li>Edit the examples above to show the compiler error when the pattern doesn't match the value being matched on.</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ åµŒå¥—æ•°ç»„" id="ç»ƒä¹ åµŒå¥—æ•°ç»„">ç»ƒä¹ ï¼šåµŒå¥—æ•°ç»„</a></h1>
<p>æ•°ç»„å¯ä»¥åŒ…å«å…¶ä»–æ•°ç»„ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
<span class="boring">}
</span></code></pre></pre>
<p>What is the type of this variable?</p>
<p>Use an array such as the above to write a function <code>transpose</code> which will transpose a matrix (turn rows into columns):</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="272" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="272" height="64"></rect><text x="122" y="12" >2</text><text x="122" y="28" >5</text><text x="122" y="44" >8</text><text x="234" y="12" >4</text><text x="234" y="28" >5</text><text x="234" y="44" >6</text><text x="250" y="12" >7â¤</text><text x="250" y="28" >8â¥</text><text x="250" y="44" >9â¦</text><text x="2" y="28" >transpose</text><text x="178" y="28" >==</text><g><text x="90" y="12">â›</text><text x="98" y="12">â¡</text><text x="106" y="12">1</text></g><g><text x="90" y="28">âœ</text><text x="98" y="28">â¢</text><text x="106" y="28">4</text></g><g><text x="90" y="44">â</text><text x="98" y="44">â£</text><text x="106" y="44">7</text></g><g><text x="138" y="12">3â¤</text><text x="154" y="12">â</text></g><g><text x="138" y="28">6â¥</text><text x="154" y="28">âŸ</text></g><g><text x="138" y="44">9â¦</text><text x="154" y="44">â </text></g><g><text x="210" y="12">â¡</text><text x="218" y="12">1</text></g><g><text x="210" y="28">â¢</text><text x="218" y="28">2</text></g><g><text x="210" y="44">â£</text><text x="218" y="44">3</text></g></svg></div>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and implement the function. This function only operates on 3x3 matrices.</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]

fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    unimplemented!()
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix: {:#?}&quot;, matrix);
    let transposed = transpose(matrix);
    println!(&quot;transposed: {:#?}&quot;, transposed);
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-2" id="è§£ç­”-2">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">fn transpose(matrix: [[i32; 3]; 3]) -&gt; [[i32; 3]; 3] {
    let mut result = [[0; 3]; 3];
    for i in 0..3 {
        for j in 0..3 {
            result[j][i] = matrix[i][j];
        }
    }
    result
}

#[test]
fn test_transpose() {
    let matrix = [
        [101, 102, 103], //
        [201, 202, 203],
        [301, 302, 303],
    ];
    let transposed = transpose(matrix);
    assert_eq!(
        transposed,
        [
            [101, 201, 301], //
            [102, 202, 302],
            [103, 203, 303],
        ]
    );
}

fn main() {
    let matrix = [
        [101, 102, 103], // &lt;-- the comment makes rustfmt add a newline
        [201, 202, 203],
        [301, 302, 303],
    ];

    println!(&quot;matrix: {:#?}&quot;, matrix);
    let transposed = transpose(matrix);
    println!(&quot;transposed: {:#?}&quot;, transposed);
}
</code></pre></pre>
<h1><a class="header" href="#å¼•ç”¨" id="å¼•ç”¨">å¼•ç”¨</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å…±äº«å¼•ç”¨" id="å…±äº«å¼•ç”¨">å…±äº«å¼•ç”¨</a></h1>
<p>A reference provides a way to access another value without taking ownership of the value, and is also called &quot;borrowing&quot;. Shared references are read-only, and the referenced data cannot change.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 'A';
    let b = 'B';
    let mut r: &amp;char = &amp;a;
    println!(&quot;r: {}&quot;, *r);
    r = &amp;b;
    println!(&quot;r: {}&quot;, *r);
}
</code></pre></pre>
<p>å¯¹ç±»å‹ <code>T</code> çš„å…±äº«å¼•ç”¨è¡¨ç¤ºä¸º <code>&amp;T</code>ã€‚å¯ä»¥ä½¿ç”¨ <code>&amp;</code> è¿ç®—ç¬¦åˆ›å»ºå¼•ç”¨å€¼ã€‚<code>*</code> è¿ç®—ç¬¦ä¼š â€œè§£å¼•ç”¨â€æŸä¸ªå¼•ç”¨ï¼Œå¹¶å¾—åˆ°è¯¥å¼•ç”¨å€¼ã€‚</p>
<p>Rust ä¼šé™æ€ç¦æ­¢æ‚¬å‚å¼•ç”¨ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn x_axis(x: &amp;i32) -&gt; &amp;(i32, i32) {
    let point = (*x, 0);
    return &amp;point;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>References can never be null in Rust, so null checking is not necessary.</p>
</li>
<li>
<p>å¼•ç”¨è¢«ç§°ä¸º â€œå€Ÿç”¨â€äº†å…¶æ‰€å¼•ç”¨çš„å€¼ï¼Œè¿™å¯¹äºä¸ç†Ÿæ‚‰æŒ‡é’ˆçš„å­¦ç”Ÿæ¥è¯´æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ¨¡å‹ï¼šä»£ç å¯ä»¥é€šè¿‡å¼•ç”¨æ¥è®¿é—®å€¼ï¼Œä½†åŸå§‹å˜é‡ä»ç„¶ä¿æœ‰å¯¹è¯¥å€¼çš„ â€œæ‰€æœ‰æƒâ€ã€‚æœ¬è¯¾ç¨‹ä¼šåœ¨ç¬¬ 3 å¤©è¯¦ç»†ä»‹ç»æ‰€æœ‰æƒã€‚</p>
</li>
<li>
<p>å¼•ç”¨æ˜¯ä»¥æŒ‡é’ˆçš„å½¢å¼å®ç°çš„ï¼Œå…¶å…³é”®ä¼˜åŠ¿åœ¨äºå®ƒä»¬å¯ä»¥æ¯”å…¶æ‰€æŒ‡çš„å†…å®¹å°å¾—å¤šã€‚ç†Ÿæ‚‰ C æˆ– C++ çš„å­¦ç”Ÿä¼šå°†å¼•ç”¨è§†ä¸ºæŒ‡é’ˆã€‚æœ¬è¯¾ç¨‹çš„åç»­éƒ¨åˆ†å°†ä»‹ç» Rust å¦‚ä½•é˜²æ­¢å› ä½¿ç”¨åŸå§‹æŒ‡é’ˆè€Œå¯¼è‡´çš„å†…å­˜å®‰å…¨ bugã€‚</p>
</li>
<li>
<p>Rust ä¸ä¼šè‡ªåŠ¨ä¸ºæ‚¨åˆ›å»ºå¼•ç”¨ï¼Œå¿…é¡»å§‹ç»ˆä½¿ç”¨ <code>&amp;</code> ç¬¦å·ã€‚</p>
</li>
<li>
<p>Rust will auto-dereference in some cases, in particular when invoking methods (try <code>r.is_ascii()</code>). There is no need for an <code>-&gt;</code> operator like in C++.</p>
</li>
<li>
<p>åœ¨æœ¬ä¾‹ä¸­ï¼Œ<code>r</code> æ˜¯å¯å˜çš„ï¼Œå› æ­¤å¯ä»¥ä¸ºå…¶é‡æ–°èµ‹å€¼ (<code>r = &amp;b</code>)ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¼šé‡æ–°ç»‘å®š <code>r</code>ï¼Œä½¿å…¶å¼•ç”¨å…¶ä»–å†…å®¹ã€‚è¿™ä¸ C++ ä¸åŒï¼Œåœ¨ C++ ä¸­ä¸ºå¼•ç”¨èµ‹å€¼ä¼šæ›´æ”¹å¼•ç”¨çš„å€¼ã€‚</p>
</li>
<li>
<p>å…±äº«å¼•ç”¨ä¸å…è®¸ä¿®æ”¹å…¶æ‰€å¼•ç”¨çš„å€¼ï¼Œå³ä½¿è¯¥å€¼æ˜¯å¯å˜çš„ã€‚è¯·å°è¯• <code>*r = 'X'</code>ã€‚</p>
</li>
<li>
<p>Rust ä¼šè·Ÿè¸ªæ‰€æœ‰å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Œä»¥ç¡®ä¿å®ƒä»¬å­˜åœ¨è¶³å¤Ÿé•¿çš„æ—¶é—´ã€‚åœ¨å®‰å…¨çš„ Rust ä¸­ä¸ä¼šå‡ºç°æ‚¬ç©ºå¼•ç”¨ã€‚<code>x_axis</code> ä¼šè¿”å›å¯¹ <code>point</code> çš„å¼•ç”¨ï¼Œä½† <code>point</code> ä¼šåœ¨è¯¥å‡½æ•°è¿”å›æ—¶å–æ¶ˆåˆ†é…ï¼Œå› æ­¤ä¸ä¼šè¿›è¡Œç¼–è¯‘ã€‚</p>
</li>
<li>
<p>æˆ‘ä»¬ä¼šåœ¨è®²åˆ°æ‰€æœ‰æƒï¼ˆownershipï¼‰æ—¶è¯¦ç»†è®¨è®ºå€Ÿç”¨ï¼ˆborrowï¼‰ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#ç‹¬å å¼•ç”¨" id="ç‹¬å å¼•ç”¨">ç‹¬å å¼•ç”¨</a></h1>
<p>ç‹¬å å¼•ç”¨ï¼ˆä¹Ÿç§°ä¸ºå¯å˜å¼•ç”¨ï¼‰å…è®¸æ›´æ”¹å…¶æ‰€å¼•ç”¨çš„å€¼ã€‚å®ƒä»¬çš„ç±»å‹ä¸º <code>&amp;mut T</code>ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut point = (1, 2);
    let x_coord = &amp;mut point.0;
    *x_coord = 20;
    println!(&quot;point: {point:?}&quot;);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>â€œç‹¬å æ¨¡å¼â€è¡¨ç¤ºåªæœ‰æ­¤å¼•ç”¨å¯ç”¨äºè®¿é—®è¯¥å€¼ã€‚åœ¨ç‹¬å å¼•ç”¨å­˜åœ¨æœŸé—´ï¼Œä¸å…è®¸åŒæ—¶å­˜åœ¨å…¶ä»–å¼•ç”¨ï¼ˆæ— è®ºæ˜¯å…±äº«å¼•ç”¨è¿˜æ˜¯ç‹¬å å¼•ç”¨ï¼‰ï¼Œå¹¶ä¸”æ— æ³•è®¿é—®å¼•ç”¨çš„å€¼ã€‚è¯·å°è¯•åœ¨ <code>x_coord</code> å¤„äºæ´»åŠ¨çŠ¶æ€æ—¶åˆ›å»º <code>&amp;point.0</code> æˆ–æ›´æ”¹ <code>point.0</code>ã€‚</p>
</li>
<li>
<p>Be sure to note the difference between <code>let mut x_coord: &amp;i32</code> and <code>let x_coord: &amp;mut i32</code>. The first one represents a shared reference which can be bound to different values, while the second represents an exclusive reference to a mutable value.</p>
</li>
</ul>
</details><h1><a class="header" href="#åˆ‡ç‰‡" id="åˆ‡ç‰‡">åˆ‡ç‰‡</a></h1>
<p>åˆ‡ç‰‡ (slice) çš„ä½œç”¨æ˜¯æä¾›å¯¹é›†åˆ (collection) çš„è§†å›¾ (view):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut a: [i32; 6] = [10, 20, 30, 40, 50, 60];
    println!(&quot;a: {a:?}&quot;);

    let s: &amp;[i32] = &amp;a[2..4];

    println!(&quot;s: {s:?}&quot;);
}
</code></pre></pre>
<ul>
<li>åˆ‡ç‰‡ä»è¢«åˆ‡ç‰‡çš„ç±»å‹ä¸­å€Ÿç”¨ (borrow) æ•°æ®ã€‚</li>
</ul>
<details>
<ul>
<li>
<p>We create a slice by borrowing <code>a</code> and specifying the starting and ending indexes in brackets.</p>
</li>
<li>
<p>If the slice starts at index 0, Rustâ€™s range syntax allows us to drop the starting index, meaning that <code>&amp;a[0..a.len()]</code> and <code>&amp;a[..a.len()]</code> are identical.</p>
</li>
<li>
<p>The same is true for the last index, so <code>&amp;a[2..a.len()]</code> and <code>&amp;a[2..]</code> are identical.</p>
</li>
<li>
<p>To easily create a slice of the full array, we can therefore use <code>&amp;a[..]</code>.</p>
</li>
<li>
<p><code>s</code> is a reference to a slice of <code>i32</code>s. Notice that the type of <code>s</code> (<code>&amp;[i32]</code>) no longer mentions the array length. This allows us to perform computation on slices of different sizes.</p>
</li>
<li>
<p>Slices always borrow from another object. In this example, <code>a</code> has to remain 'alive' (in scope) for at least as long as our slice.</p>
</li>
</ul>
</details><!-- NOTES:
Including `&str` as a way of representing a slice of valid utf-8
-->
<h1><a class="header" href="#å­—ç¬¦ä¸²" id="å­—ç¬¦ä¸²">å­—ç¬¦ä¸²</a></h1>
<p>ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥ç†è§£ Rust ä¸­çš„ä¸¤ç§å­—ç¬¦ä¸²ç±»å‹ï¼š</p>
<ul>
<li><code>&amp;str</code> is a slice of UTF-8 encoded bytes, similar to <code>&amp;[u8]</code>.</li>
<li><code>String</code> is an owned buffer of UTF-8 encoded bytes, similar to <code>Vec&lt;T&gt;</code>.</li>
</ul>
<!-- Avoid using fixed integers when slicing since this breaks
translations. Using the length of s1 and s2 is safe. -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: &amp;str = &quot;World&quot;;
    println!(&quot;s1: {s1}&quot;);

    let mut s2: String = String::from(&quot;Hello &quot;);
    println!(&quot;s2: {s2}&quot;);
    s2.push_str(s1);
    println!(&quot;s2: {s2}&quot;);

    let s3: &amp;str = &amp;s2[s2.len() - s1.len()..];
    println!(&quot;s3: {s3}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>&amp;str</code> introduces a string slice, which is an immutable reference to UTF-8 encoded string data stored in a block of memory. String literals (<code>&quot;Hello&quot;</code>), are stored in the programâ€™s binary.</p>
</li>
<li>
<p>Rust's <code>String</code> type is a wrapper around a vector of bytes. As with a <code>Vec&lt;T&gt;</code>, it is owned.</p>
</li>
<li>
<p>As with many other types <code>String::from()</code> creates a string from a string literal; <code>String::new()</code> creates a new empty string, to which string data can be added using the <code>push()</code> and <code>push_str()</code> methods.</p>
</li>
<li>
<p>The <code>format!()</code> macro is a convenient way to generate an owned string from dynamic values. It accepts the same format specification as <code>println!()</code>.</p>
</li>
<li>
<p>You can borrow <code>&amp;str</code> slices from <code>String</code> via <code>&amp;</code> and optionally range selection. If you select a byte range that is not aligned to character boundaries, the expression will panic. The <code>chars</code> iterator iterates over characters and is preferred over trying to get character boundaries right.</p>
</li>
<li>
<p>For C++ programmers: think of <code>&amp;str</code> as <code>std::string_view</code> from C++, but the one that always points to a valid string in memory. Rust <code>String</code> is a rough equivalent of <code>std::string</code> from C++ (main difference: it can only contain UTF-8 encoded bytes and will never use a small-string optimization).</p>
</li>
<li>
<p>Byte strings literals allow you to create a <code>&amp;[u8]</code> value directly:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;{:?}&quot;, b&quot;abc&quot;);
    println!(&quot;{:?}&quot;, &amp;[97, 98, 99]);
}
</code></pre></pre>
</li>
<li>
<p>åŸå§‹å­—ç¬¦ä¸²å¯åœ¨åˆ›å»º <code>&amp;str</code> æ—¶ç¦ç”¨è½¬ä¹‰ï¼š<code>r&quot;\n&quot; == &quot;\\n&quot;</code>ã€‚å¯ä»¥åœ¨å¤–å±‚å¼•å·ä¸¤ä¾§æ·»åŠ ç›¸åŒæ•°é‡çš„ <code>#</code>ï¼Œä»¥åœ¨å­—ç¬¦ä¸²ä¸­åµŒå…¥åŒå¼•å·ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(r#&quot;&lt;a href=&quot;link.html&quot;&gt;link&lt;/a&gt;&quot;#);
    println!(&quot;&lt;a href=\&quot;link.html\&quot;&gt;link&lt;/a&gt;&quot;);
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ å‡ ä½•å›¾å½¢" id="ç»ƒä¹ å‡ ä½•å›¾å½¢">ç»ƒä¹ ï¼šå‡ ä½•å›¾å½¢</a></h1>
<p>æˆ‘ä»¬å°†ä¸ºä¸‰ç»´å‡ ä½•å›¾å½¢åˆ›å»ºå‡ ä¸ªå®ç”¨å‡½æ•°ï¼Œå°†ç‚¹è¡¨ç¤ºä¸º <code>[f64;3]</code>ã€‚å‡½æ•°ç­¾åç”±æ‚¨è‡ªè¡Œç¡®å®šã€‚</p>
<pre><pre class="playground"><code class="language-rust compile_fail">// Calculate the magnitude of a vector by summing the squares of its coordinates
// and taking the square root. Use the `sqrt()` method to calculate the square
// root, like `v.sqrt()`.


fn magnitude(...) -&gt; f64 {
    todo!()
}

// Normalize a vector by calculating its magnitude and dividing all of its
// coordinates by that magnitude.


fn normalize(...) {
    todo!()
}

// Use the following `main` to test your work.

fn main() {
    println!(&quot;Magnitude of a unit vector: {}&quot;, magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!(&quot;Magnitude of {v:?}: {}&quot;, magnitude(&amp;v));
    normalize(&amp;mut v);
    println!(&quot;Magnitude of {v:?} after normalization: {}&quot;, magnitude(&amp;v));
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-3" id="è§£ç­”-3">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Calculate the magnitude of the given vector.
fn magnitude(vector: &amp;[f64; 3]) -&gt; f64 {
    let mut mag_squared = 0.0;
    for coord in vector {
        mag_squared += coord * coord;
    }
    mag_squared.sqrt()
}

/// Change the magnitude of the vector to 1.0 without changing its direction.
fn normalize(vector: &amp;mut [f64; 3]) {
    let mag = magnitude(vector);
    for item in vector {
        *item /= mag;
    }
}

fn main() {
    println!(&quot;Magnitude of a unit vector: {}&quot;, magnitude(&amp;[0.0, 1.0, 0.0]));

    let mut v = [1.0, 2.0, 9.0];
    println!(&quot;Magnitude of {v:?}: {}&quot;, magnitude(&amp;v));
    normalize(&amp;mut v);
    println!(&quot;Magnitude of {v:?} after normalization: {}&quot;, magnitude(&amp;v));
}
</code></pre></pre>
<h1><a class="header" href="#ç”¨æˆ·å®šä¹‰çš„ç±»å‹" id="ç”¨æˆ·å®šä¹‰çš„ç±»å‹">ç”¨æˆ·å®šä¹‰çš„ç±»å‹</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#ç»“æ„ä½“" id="ç»“æ„ä½“">ç»“æ„ä½“</a></h1>
<p>ä¸ C å’Œ C++ ä¸€æ ·ï¼ŒRust æ”¯æŒè‡ªå®šä¹‰ç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    name: String,
    age: u8,
}

fn describe(person: &amp;Person) {
    println!(&quot;{} is {} years old&quot;, person.name, person.age);
}

fn main() {
    let mut peter = Person { name: String::from(&quot;Peter&quot;), age: 27 };
    describe(&amp;peter);

    peter.age = 28;
    describe(&amp;peter);

    let name = String::from(&quot;Avery&quot;);
    let age = 39;
    let avery = Person { name, age };
    describe(&amp;avery);

    let jackie = Person { name: String::from(&quot;Jackie&quot;), ..avery };
    describe(&amp;jackie);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>ç»“æ„ä½“çš„è¿ä½œæ–¹å¼ä¸ä½¿ç”¨ C æˆ– C++ æ—¶ç±»ä¼¼ã€‚
<ul>
<li>ä¸éœ€è¦ typedef å³å¯å®šä¹‰ç±»å‹ï¼Œè¿™ä¸ä½¿ç”¨ C++ ç±»ä¼¼ï¼Œä½†ä¸ä½¿ç”¨ C ä¸åŒã€‚</li>
<li>ä¸ä½¿ç”¨ C++ ä¸åŒçš„æ˜¯ï¼Œç»“æ„ä½“ä¹‹é—´æ²¡æœ‰ç»§æ‰¿å…³ç³»ã€‚</li>
</ul>
</li>
<li>This may be a good time to let people know there are different types of structs.
<ul>
<li>Zero-sized structs (e.g. <code>struct Foo;</code>) might be used when implementing a trait on some type but donâ€™t have any data that you want to store in the value itself.</li>
<li>ä¸‹ä¸€å¼ å¹»ç¯ç‰‡å°†ä»‹ç»å…ƒç»„ç»“æ„ä½“ï¼Œå½“å­—æ®µåç§°ä¸é‡è¦æ—¶ä½¿ç”¨ã€‚</li>
</ul>
</li>
<li>If you already have variables with the right names, then you can create the struct using a shorthand.</li>
<li>The syntax <code>..avery</code> allows us to copy the majority of the fields from the old struct without having to explicitly type it all out. It must always be the last element.</li>
</ul>
</details><!-- NOTES:
Tuple structs, newtype wrappers, unit-like structs, including initialization syntax
-->
<h1><a class="header" href="#å…ƒç»„ç»“æ„ä½“" id="å…ƒç»„ç»“æ„ä½“">å…ƒç»„ç»“æ„ä½“</a></h1>
<p>å¦‚æœå­—æ®µåç§°ä¸é‡è¦ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å…ƒç»„ç»“æ„ä½“ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point(i32, i32);

fn main() {
    let p = Point(17, 23);
    println!(&quot;({}, {})&quot;, p.0, p.1);
}
</code></pre></pre>
<p>è¿™é€šå¸¸ç”¨äºå•å­—æ®µå°è£…å®¹å™¨ï¼ˆç§°ä¸º newtypeï¼‰ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct PoundsOfForce(f64);
struct Newtons(f64);

fn compute_thruster_force() -&gt; PoundsOfForce {
    todo!(&quot;Ask a rocket scientist at NASA&quot;)
}

fn set_thruster_force(force: Newtons) {
    // ...
}

fn main() {
    let force = compute_thruster_force();
    set_thruster_force(force);
}
</code></pre></pre>
<details>
<ul>
<li>å¦‚éœ€å¯¹åŸºå…ƒç±»å‹ä¸­çš„å€¼çš„é¢å¤–ä¿¡æ¯è¿›è¡Œç¼–ç ï¼Œä½¿ç”¨ newtype æ˜¯ä¸€ç§éå¸¸å¥½çš„æ–¹å¼ï¼Œä¾‹å¦‚ï¼š
<ul>
<li>æ•°å­—ä¼šä»¥æŸäº›å•ä½æ¥è¡¡é‡ï¼šä¸Šæ–¹ç¤ºä¾‹ä¸­ä¸º <code>Newtons</code>ã€‚</li>
<li>The value passed some validation when it was created, so you no longer have to validate it again at every use: <code>PhoneNumber(String)</code> or <code>OddNumber(u32)</code>.</li>
</ul>
</li>
<li>å±•ç¤ºå¦‚ä½•é€šè¿‡è®¿é—® newtype ä¸­çš„å•ä¸ªå­—æ®µï¼Œå°† <code>f64</code> å€¼æ·»åŠ åˆ° <code>Newtons</code> ç±»å‹ã€‚
<ul>
<li>Rust é€šå¸¸ä¸å–œæ¬¢ä¸æ˜ç¡®çš„å†…å®¹ï¼Œä¾‹å¦‚è‡ªåŠ¨è§£å°æˆ–å°†å¸ƒå°”å€¼ç”¨ä½œæ•´æ•°ã€‚</li>
<li>è¿ç®—ç¬¦è¿‡è½½åœ¨ç¬¬ 3 å¤©ï¼ˆæ³›å‹ï¼‰è®¨è®ºã€‚</li>
</ul>
</li>
<li>æ­¤ç¤ºä¾‹å·§å¦™åœ°å¼•ç”¨äº†<a href="https://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%B0%A3%E5%80%99%E6%8E%A2%E6%B8%AC%E8%80%85%E8%99%9F">ç«æ˜Ÿæ°”å€™æ¢æµ‹è€…å·</a> çš„å¤±è´¥äº‹æ•…ã€‚</li>
</ul>
</details><h1><a class="header" href="#æšä¸¾" id="æšä¸¾">æšä¸¾</a></h1>
<p><code>enum</code> å…³é”®å­—å…è®¸åˆ›å»ºå…·æœ‰å‡ ä¸ª ä¸åŒå˜ä½“çš„ç±»å‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum Direction {
    Left,
    Right,
}

#[derive(Debug)]
enum PlayerMove {
    Pass,                        // Simple variant
    Run(Direction),              // Tuple variant
    Teleport { x: u32, y: u32 }, // Struct variant
}

fn main() {
    let player_move: PlayerMove = PlayerMove::Run(Direction::Left);
    println!(&quot;On this turn: {player_move:?}&quot;);
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>Enumerations allow you to collect a set of values under one type.</li>
<li><code>Direction</code> is a type with variants. There are two values of <code>Direction</code>: <code>Direction::Left</code> and <code>Direction::Right</code>.</li>
<li><code>PlayerMove</code> is a type with three variants. In addition to the payloads, Rust will store a discriminant so that it knows at runtime which variant is in a <code>PlayerMove</code> value.</li>
<li>This might be a good time to compare structs and enums:
<ul>
<li>In both, you can have a simple version without fields (unit struct) or one with different types of fields (variant payloads).</li>
<li>You could even implement the different variants of an enum with separate structs but then they wouldnâ€™t be the same type as they would if they were all defined in an enum.</li>
</ul>
</li>
<li>Rust ä½¿ç”¨æœ€å°çš„ç©ºé—´æ¥å­˜å‚¨åˆ¤æ ‡è¯†ã€‚
<ul>
<li>
<p>å¦‚æœ‰å¿…è¦ï¼Œå®ƒä¼šå­˜å‚¨æ‰€éœ€æœ€å°å¤§å°çš„æ•´æ•°</p>
</li>
<li>
<p>å¦‚æœå…è®¸çš„å˜ä½“å€¼æœªæ¶µç›–æ‰€æœ‰ä½æ¨¡å¼ï¼Œåˆ™å®ƒå°†ä½¿ç”¨æ— æ•ˆçš„ä½æ¨¡å¼å¯¹åˆ¤åˆ«æ ‡è¯†è¿›è¡Œç¼–ç ï¼ˆâ€œå°ä¼—ä¼˜åŒ–â€ï¼‰ã€‚ä¾‹å¦‚ï¼Œ<code>Option&lt;&amp;u8&gt;</code> å­˜å‚¨çš„è¦ä¹ˆæ˜¯æŒ‡å‘æ•´æ•°çš„æŒ‡é’ˆï¼Œè¦ä¹ˆæ˜¯ <code>None</code> å˜ä½“çš„ <code>NULL</code> å€¼ã€‚</p>
</li>
<li>
<p>You can control the discriminant if needed (e.g., for compatibility with C):</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[repr(u32)]
enum Bar {
    A, // 0
    B = 10000,
    C, // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}
</code></pre></pre>
<p>Without <code>repr</code>, the discriminant type takes 2 bytes, because 10001 fits 2 bytes.</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#æ¢ç´¢æ›´å¤š" id="æ¢ç´¢æ›´å¤š">æ¢ç´¢æ›´å¤š</a></h2>
<p>Rust å…·æœ‰å¤šç§ä¼˜åŒ–æªæ–½ï¼Œå¯ä»¥å‡å°‘æšä¸¾å ç”¨çš„ç©ºé—´ã€‚</p>
<ul>
<li>
<p>Null pointer optimization: For <a href="https://doc.rust-lang.org/std/option/#representation">some types</a>, Rust guarantees that <code>size_of::&lt;T&gt;()</code> equals <code>size_of::&lt;Option&lt;T&gt;&gt;()</code>.</p>
<p>Example code if you want to show how the bitwise representation <em>may</em> look like in practice. It's important to note that the compiler provides no guarantees regarding this representation, therefore this is totally unsafe.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">use std::mem::transmute;

macro_rules! dbg_bits {
    ($e:expr, $bit_type:ty) =&gt; {
        println!(&quot;- {}: {:#x}&quot;, stringify!($e), transmute::&lt;_, $bit_type&gt;($e));
    };
}

fn main() {
    unsafe {
        println!(&quot;bool:&quot;);
        dbg_bits!(false, u8);
        dbg_bits!(true, u8);

        println!(&quot;Option&lt;bool&gt;:&quot;);
        dbg_bits!(None::&lt;bool&gt;, u8);
        dbg_bits!(Some(false), u8);
        dbg_bits!(Some(true), u8);

        println!(&quot;Option&lt;Option&lt;bool&gt;&gt;:&quot;);
        dbg_bits!(Some(Some(false)), u8);
        dbg_bits!(Some(Some(true)), u8);
        dbg_bits!(Some(None::&lt;bool&gt;), u8);
        dbg_bits!(None::&lt;Option&lt;bool&gt;&gt;, u8);

        println!(&quot;Option&lt;&amp;i32&gt;:&quot;);
        dbg_bits!(None::&lt;&amp;i32&gt;, usize);
        dbg_bits!(Some(&amp;0i32), usize);
    }
}
</code></pre></pre>
</li>
</ul>
</details><h1><a class="header" href="#const" id="const"><code>const</code></a></h1>
<p>Constants are evaluated at compile time and their values are inlined wherever they are used:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">const DIGEST_SIZE: usize = 3;
const ZERO: Option&lt;u8&gt; = Some(42);

fn compute_digest(text: &amp;str) -&gt; [u8; DIGEST_SIZE] {
    let mut digest = [ZERO.unwrap_or(0); DIGEST_SIZE];
    for (idx, &amp;b) in text.as_bytes().iter().enumerate() {
        digest[idx % DIGEST_SIZE] = digest[idx % DIGEST_SIZE].wrapping_add(b);
    }
    digest
}

fn main() {
    let digest = compute_digest(&quot;Hello&quot;);
    println!(&quot;digest: {digest:?}&quot;);
}
</code></pre></pre>
<p>æ ¹æ® <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a> è¿™äº›å˜é‡åœ¨ä½¿ç”¨æ—¶æ˜¯å†…è” (inlined) çš„ã€‚</p>
<p>åœ¨ç¼–è¯‘æ—¶åªèƒ½è°ƒç”¨æ ‡è®°ä¸ºâ€œconstâ€çš„å‡½æ•°ä»¥ç”Ÿæˆâ€œconstâ€å€¼ã€‚ä¸è¿‡ï¼Œå¯åœ¨è¿è¡Œæ—¶è°ƒç”¨â€œconstâ€å‡½æ•°ã€‚</p>
<details>
<ul>
<li>Mention that <code>const</code> behaves semantically similar to C++'s <code>constexpr</code></li>
<li>è™½ç„¶éœ€è¦ä½¿ç”¨åœ¨è¿è¡Œä¸­æ±‚å€¼çš„å¸¸é‡çš„æƒ…å†µå¹¶ä¸æ˜¯å¾ˆå¸¸è§ï¼Œä½†æ˜¯å®ƒæ˜¯æœ‰å¸®åŠ©çš„ï¼Œè€Œä¸”æ¯”ä½¿ç”¨é™æ€å˜é‡æ›´å®‰å…¨ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#static" id="static"><code>static</code></a></h1>
<p>é™æ€å˜é‡åœ¨ç¨‹åºçš„æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ä¸­å§‹ç»ˆæœ‰æ•ˆï¼Œå› æ­¤ä¸ä¼šç§»åŠ¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">static BANNER: &amp;str = &quot;Welcome to RustOS 3.14&quot;;

fn main() {
    println!(&quot;{BANNER}&quot;);
}
</code></pre></pre>
<p>As noted in the <a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html">Rust RFC Book</a>, these are not inlined upon use and have an actual associated memory location. This is useful for unsafe and embedded code, and the variable lives through the entirety of the program execution. When a globally-scoped value does not have a reason to need object identity, <code>const</code> is generally preferred.</p>
<details>
<ul>
<li><code>static</code> is similar to mutable global variables in C++.</li>
<li><code>static</code> provides object identity: an address in memory and state as required by types with interior mutability such as <code>Mutex&lt;T&gt;</code>.</li>
</ul>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-1" id="æ¢ç´¢æ›´å¤š-1">æ¢ç´¢æ›´å¤š</a></h1>
<p>Because <code>static</code> variables are accessible from any thread, they must be <code>Sync</code>. Interior mutability is possible through a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, atomic or similar.</p>
<p>Thread-local data can be created with the macro <code>std::thread_local</code>.</p>
</details>
<h1><a class="header" href="#ç±»å‹åˆ«å" id="ç±»å‹åˆ«å">ç±»å‹åˆ«å</a></h1>
<p>ç±»å‹åˆ«åä¸ºå¦ä¸€ç§ç±»å‹åˆ›å»ºåç§°ã€‚è¿™ä¸¤ç§ç±»å‹å¯ä»¥äº’æ¢ä½¿ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">enum CarryableConcreteItem {
    Left,
    Right,
}

type Item = CarryableConcreteItem;

// Aliases are more useful with long, complex types:
use std::cell::RefCell;
use std::sync::{Arc, RwLock};
type PlayerInventory = RwLock&lt;Vec&lt;Arc&lt;RefCell&lt;Item&gt;&gt;&gt;&gt;;
</code></pre></pre>
<details>
<p>C è¯­è¨€ç¨‹åºå‘˜ä¼šè®¤ä¸ºè¿™ç±»ä¼¼äº <code>typedef</code>ã€‚</p>
</details><h1><a class="header" href="#ç»ƒä¹ ç”µæ¢¯äº‹ä»¶" id="ç»ƒä¹ ç”µæ¢¯äº‹ä»¶">ç»ƒä¹ ï¼šç”µæ¢¯äº‹ä»¶</a></h1>
<p>æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„æ¥è¡¨ç¤ºç”µæ¢¯æ§åˆ¶ç³»ç»Ÿä¸­çš„äº‹ä»¶ã€‚æ‚¨å¯ä»¥è‡ªè¡Œå®šä¹‰ç”¨äºæ„é€ å„ç§äº‹ä»¶çš„ç±»å‹å’Œå‡½æ•°ã€‚ä½¿ç”¨ <code>#[derive(Debug)]</code> ä»¥å…è®¸é€šè¿‡ <code>{:?}</code> è®¾ç½®ç±»å‹æ ¼å¼ã€‚</p>
<p>This exercise only requires creating and populating data structures so that <code>main</code> runs without errors. The next part of the course will cover getting data out of these structures.</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    // TODO: add required variants
}

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    todo!()
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    todo!()
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    todo!()
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    todo!()
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    todo!()
}

fn main() {
    println!(
        &quot;A ground floor passenger has pressed the up button: {:?}&quot;,
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!(&quot;The car has arrived on the ground floor: {:?}&quot;, car_arrived(0));
    println!(&quot;The car door opened: {:?}&quot;, car_door_opened());
    println!(
        &quot;A passenger has pressed the 3rd floor button: {:?}&quot;,
        car_floor_button_pressed(3)
    );
    println!(&quot;The car door closed: {:?}&quot;, car_door_closed());
    println!(&quot;The car has arrived on the 3rd floor: {:?}&quot;, car_arrived(3));
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-4" id="è§£ç­”-4">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
/// An event in the elevator system that the controller must react to.
enum Event {
    /// A button was pressed.
    ButtonPressed(Button),

    /// The car has arrived at the given floor.
    CarArrived(Floor),

    /// The car's doors have opened.
    CarDoorOpened,

    /// The car's doors have closed.
    CarDoorClosed,
}

/// A floor is represented as an integer.
type Floor = i32;

/// A direction of travel.
#[derive(Debug)]
enum Direction {
    Up,
    Down,
}

/// A user-accessible button.
#[derive(Debug)]
enum Button {
    /// A button in the elevator lobby on the given floor.
    LobbyCall(Direction, Floor),

    /// A floor button within the car.
    CarFloor(Floor),
}

/// The car has arrived on the given floor.
fn car_arrived(floor: i32) -&gt; Event {
    Event::CarArrived(floor)
}

/// The car doors have opened.
fn car_door_opened() -&gt; Event {
    Event::CarDoorOpened
}

/// The car doors have closed.
fn car_door_closed() -&gt; Event {
    Event::CarDoorClosed
}

/// A directional button was pressed in an elevator lobby on the given floor.
fn lobby_call_button_pressed(floor: i32, dir: Direction) -&gt; Event {
    Event::ButtonPressed(Button::LobbyCall(dir, floor))
}

/// A floor button was pressed in the elevator car.
fn car_floor_button_pressed(floor: i32) -&gt; Event {
    Event::ButtonPressed(Button::CarFloor(floor))
}

fn main() {
    println!(
        &quot;A ground floor passenger has pressed the up button: {:?}&quot;,
        lobby_call_button_pressed(0, Direction::Up)
    );
    println!(&quot;The car has arrived on the ground floor: {:?}&quot;, car_arrived(0));
    println!(&quot;The car door opened: {:?}&quot;, car_door_opened());
    println!(
        &quot;A passenger has pressed the 3rd floor button: {:?}&quot;,
        car_floor_button_pressed(3)
    );
    println!(&quot;The car door closed: {:?}&quot;, car_door_closed());
    println!(&quot;The car has arrived on the 3rd floor: {:?}&quot;, car_arrived(3));
}
</code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©" id="æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©">æ¬¢è¿æ¥åˆ°ç¬¬äºŒå¤©</a></h1>
<p>Now that we have seen a fair amount of Rust, today will focus on Rust's type system:</p>
<ul>
<li>Pattern matching: extracting data from structures.</li>
<li>æ–¹æ³•ï¼šå°†å‡½æ•°ä¸ç±»å‹ç›¸å…³è”ã€‚</li>
<li>ç‰¹å¾ï¼šå¤šä¸ªç±»å‹æ‰€å…±æœ‰çš„è¡Œä¸ºã€‚</li>
<li>æ³›å‹ï¼šå¯¹å…¶ä»–ç±»å‹è¿›è¡Œç±»å‹å‚æ•°åŒ–ã€‚</li>
<li>æ ‡å‡†åº“ç±»å‹å’Œç‰¹å¾ï¼šæ¢ç´¢ Rust ä¸°å¯Œçš„æ ‡å‡†åº“ã€‚</li>
</ul>
<h2><a class="header" href="#æ—¶é—´è¡¨-1" id="æ—¶é—´è¡¨-1">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#æ¨¡å¼åŒ¹é…" id="æ¨¡å¼åŒ¹é…">æ¨¡å¼åŒ¹é…</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#matching-values" id="matching-values">Matching Values</a></h1>
<p>The <code>match</code> keyword lets you match a value against one or more <em>patterns</em>. The comparisons are done from top to bottom and the first match wins.</p>
<p>æ¨¡å¼ï¼ˆpatternï¼‰å¯ä»¥æ˜¯ç®€å•çš„å€¼ï¼Œå…¶ç”¨æ³•ç±»ä¼¼äº C ä¸ C++ ä¸­çš„ <code>switch</code> ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">#[rustfmt::skip]
fn main() {
    let input = 'x';
    match input {
        'q'                       =&gt; println!(&quot;Quitting&quot;),
        'a' | 's' | 'w' | 'd'     =&gt; println!(&quot;Moving around&quot;),
        '0'..='9'                 =&gt; println!(&quot;Number input&quot;),
        key if key.is_lowercase() =&gt; println!(&quot;Lowercase: {key}&quot;),
        _                         =&gt; println!(&quot;Something else&quot;),
    }
}
</code></pre></pre>
<p>The <code>_</code> pattern is a wildcard pattern which matches any value. The expressions <em>must</em> be exhaustive, meaning that it covers every possibility, so <code>_</code> is often used as the final catch-all case.</p>
<p>Match can be used as an expression. Just like <code>if</code>, each match arm must have the same type. The type is the last expression of the block, if any. In the example above, the type is <code>()</code>.</p>
<p>æ¨¡å¼ä¸­çš„å˜é‡ï¼ˆæœ¬ä¾‹ä¸­ä¸º <code>key</code>ï¼‰å°†åˆ›å»ºä¸€ä¸ªå¯åœ¨åŒ¹é…åˆ†æ”¯å†…ä½¿ç”¨çš„ç»‘å®šã€‚</p>
<p>åªæœ‰å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œä¿æŠ¤è¯­å¥æ‰èƒ½ä½¿åˆ†æ”¯åŒ¹é…æˆåŠŸã€‚</p>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>You might point out how some specific characters are being used when in a pattern</p>
<ul>
<li><code>|</code> as an <code>or</code></li>
<li><code>..</code> can expand as much as it needs to be</li>
<li><code>1..=5</code> represents an inclusive range</li>
<li>â€œ_â€æ˜¯é€šé…ç¬¦</li>
</ul>
</li>
<li>
<p>æœ‰äº›æƒ³æ³•æ¯”æ¨¡å¼æœ¬èº«æ‰€å…è®¸çš„ç¨‹åº¦æ›´åŠ å¤æ‚ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ç®€è¦åœ°è¡¨è¾¾è¿™äº›æƒ³æ³•ï¼Œå°±å¿…é¡»æŠŠåŒ¹é…å®ˆå«è§†ä¸ºç‹¬ç«‹çš„è¯­æ³•åŠŸèƒ½ã€‚</p>
</li>
<li>
<p>å®ƒä»¬ä¸åŒ¹é…åˆ†æ”¯ä¸­çš„å•ç‹¬â€œifâ€è¡¨è¾¾å¼ä¸åŒã€‚é€‰æ‹©åŒ¹é…åˆ†æ”¯åï¼Œåˆ†æ”¯å—å†…ï¼ˆåœ¨â€œ=&gt;â€ä¹‹åï¼‰ä¼šå‡ºç°â€œifâ€è¡¨è¾¾å¼ã€‚å¦‚æœè¯¥åˆ†æ”¯å—å†…çš„â€œifâ€æ¡ä»¶å¤±è´¥ï¼Œç³»ç»Ÿä¸ä¼šè€ƒè™‘åŸå§‹â€œmatchâ€è¡¨è¾¾å¼çš„å…¶ä»–åˆ†æ”¯ã€‚</p>
</li>
<li>
<p>åªè¦è¡¨è¾¾å¼åœ¨åŒ…å«â€œ|â€çš„æ¨¡å¼ä¸­ï¼Œå°±ä¼šé€‚ç”¨å®ˆå«å®šä¹‰çš„æ¡ä»¶ã€‚</p>
</li>
</ul>
<h1><a class="header" href="#more-to-explore" id="more-to-explore">More To Explore</a></h1>
<ul>
<li>
<p>Another piece of pattern syntax you can show students is the <code>@</code> syntax which binds a part of a pattern to a variable. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt = Some(123);
match opt {
    outer @ Some(inner) =&gt; {
        println!(&quot;outer: {outer:?}, inner: {inner}&quot;);
    }
    None =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example <code>inner</code> has the value 123 which it pulled from the <code>Option</code> via destructuring, <code>outer</code> captures the entire <code>Some(inner)</code> expression, so it contains the full <code>Option::Some(123)</code>. This is rarely used but can be useful in more complex patterns.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç»“æ„ä½“-1" id="ç»“æ„ä½“-1">ç»“æ„ä½“</a></h1>
<p>Like tuples, Struct can also be destructured by matching:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Foo {
    x: (u32, u32),
    y: u32,
}

#[rustfmt::skip]
fn main() {
    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;x.0 = 1, b = {b}, y = {y}&quot;),
        Foo { y: 2, x: i }   =&gt; println!(&quot;y = 2, x = {i:?}&quot;),
        Foo { y, .. }        =&gt; println!(&quot;y = {y}, other fields were ignored&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>æ›´æ”¹â€œfooâ€ä¸­çš„å­—é¢é‡å€¼ä»¥ä¸å…¶ä»–æ¨¡å¼ç›¸åŒ¹é…ã€‚</li>
<li>å‘â€œFooâ€æ·»åŠ ä¸€ä¸ªæ–°å­—æ®µï¼Œå¹¶æ ¹æ®éœ€è¦æ›´æ”¹æ¨¡å¼ã€‚</li>
<li>æ•è·å’Œå¸¸é‡è¡¨è¾¾å¼ä¹‹é—´çš„åŒºåˆ«å¯èƒ½å¾ˆéš¾å‘ç°ã€‚å°è¯•å°†ç¬¬äºŒä¸ªåˆ†æ”¯ä¸­çš„â€œ2â€æ›´æ”¹ä¸ºä¸€ä¸ªå˜é‡ï¼Œå¯ä»¥çœ‹åˆ°å®ƒå‡ ä¹æ— æ³•è¿ä½œäº†ã€‚å°†å®ƒæ›´æ”¹ä¸ºâ€œconstâ€ï¼Œå¯ä»¥çœ‹åˆ°å®ƒåˆæ­£å¸¸è¿ä½œäº†ã€‚</li>
</ul>
</details><h1><a class="header" href="#æšä¸¾-1" id="æšä¸¾-1">æšä¸¾</a></h1>
<p>Like tuples, enums can also be destructured by matching:</p>
<p>æ¨¡å¼è¿˜å¯ç”¨äºå°†å˜é‡ç»‘å®šåˆ°å€¼çš„æŸäº›éƒ¨åˆ†ã€‚è¿™æ˜¯æ‚¨æ£€æŸ¥ç±»å‹ç»“æ„çš„æ–¹å¼ã€‚æˆ‘ä»¬å…ˆä»ç®€å•çš„â€œenumâ€ç±»å‹å¼€å§‹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">enum Result {
    Ok(i32),
    Err(String),
}

fn divide_in_two(n: i32) -&gt; Result {
    if n % 2 == 0 {
        Result::Ok(n / 2)
    } else {
        Result::Err(format!(&quot;cannot divide {n} into two equal parts&quot;))
    }
}

fn main() {
    let n = 100;
    match divide_in_two(n) {
        Result::Ok(half) =&gt; println!(&quot;{n} divided in two is {half}&quot;),
        Result::Err(msg) =&gt; println!(&quot;sorry, an error happened: {msg}&quot;),
    }
}
</code></pre></pre>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨äº†åˆ†æ”¯æ¥è§£æ„â€œResultâ€å€¼ã€‚åœ¨ç¬¬ä¸€ä¸ªåˆ†æ”¯ä¸­ï¼Œâ€œhalfâ€è¢«ç»‘å®šåˆ°â€œOkâ€å˜ä½“ä¸­çš„å€¼ã€‚åœ¨ç¬¬äºŒä¸ªåˆ†æ”¯ä¸­ï¼Œâ€œmsgâ€è¢«ç»‘å®šåˆ°é”™è¯¯æ¶ˆæ¯ã€‚</p>
<details>
<ul>
<li>â€œifâ€/â€œelseâ€è¡¨è¾¾å¼å°†è¿”å›ä¸€ä¸ªæšä¸¾ï¼Œè¯¥æšä¸¾ä¹‹åä¼šä½¿ç”¨â€œmatchâ€è¿›è¡Œè§£å°è£…ã€‚</li>
<li>æ‚¨å¯ä»¥å°è¯•åœ¨æšä¸¾å®šä¹‰ä¸­æ·»åŠ ç¬¬ä¸‰ä¸ªå˜ä½“ï¼Œå¹¶åœ¨è¿è¡Œä»£ç æ—¶æ˜¾ç¤ºé”™è¯¯ã€‚æŒ‡å‡ºä»£ç ç°åœ¨æœ‰å“ªäº›åœ°æ–¹è¿˜ä¸è¯¦å°½ï¼Œå¹¶è¯´æ˜ç¼–è¯‘å™¨ä¼šå¦‚ä½•å°è¯•ç»™äºˆæç¤ºã€‚</li>
<li>The values in the enum variants can only be accessed after being pattern matched.</li>
<li>Demonstrate what happens when the search is inexhaustive. Note the advantage the Rust compiler provides by confirming when all cases are handled.</li>
</ul>
</details><h1><a class="header" href="#let-æ§åˆ¶æµ" id="let-æ§åˆ¶æµ">let æ§åˆ¶æµ</a></h1>
<p>Rust æœ‰å‡ ä¸ªä¸å…¶ä»–è¯­è¨€ä¸åŒçš„æ§åˆ¶æµç»“æ„ã€‚å®ƒä»¬ç”¨äºæ¨¡å¼åŒ¹é…ï¼š</p>
<ul>
<li><code>if let</code> è¡¨è¾¾å¼</li>
<li><code>let else</code> expressions</li>
<li><code>while let</code> expressions</li>
</ul>
<h1><a class="header" href="#if-let-è¡¨è¾¾å¼" id="if-let-è¡¨è¾¾å¼"><code>if let</code> è¡¨è¾¾å¼</a></h1>
<p><a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code> è¡¨è¾¾å¼</a> èƒ½è®©ä½ æ ¹æ®æŸä¸ªå€¼æ˜¯å¦ä¸æ¨¡å¼ç›¸åŒ¹é…æ¥æ‰§è¡Œä¸åŒçš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::time::Duration;

fn sleep_for(secs: f32) {
    if let Ok(duration) = Duration::try_from_secs_f32(secs) {
        std::thread::sleep(duration);
        println!(&quot;slept for {duration:?}&quot;);
    }
}

fn main() {
    sleep_for(-10.0);
    sleep_for(0.8);
}
</code></pre></pre>
<h1><a class="header" href="#let-else-expressions" id="let-else-expressions"><code>let else</code> expressions</a></h1>
<p>å¦‚éœ€äº†è§£åŒ¹é…æ¨¡å¼å¹¶ä»å‡½æ•°è¿”å›çš„å¸¸è§æƒ…å†µï¼Œè¯·ä½¿ç”¨ <a href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"><code>let else</code></a>ã€‚&quot;else&quot; åˆ†æ”¯å¿…é¡»æ‰§è¡Œä¸åŒçš„ç»“æŸæ–¹å¼ï¼ˆä¾‹å¦‚ï¼Œ<code>return</code>ã€<code>break</code> æˆ– <code>panic</code>ï¼Œä½†ä¸èƒ½ç›´æ¥æ‰§è¡Œåˆ°ä»£ç å—çš„æœ«å°¾ï¼‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    if let Some(s) = maybe_string {
        if let Some(first_byte_char) = s.chars().next() {
            if let Some(digit) = first_byte_char.to_digit(16) {
                Ok(digit)
            } else {
                return Err(String::from(&quot;not a hex digit&quot;));
            }
        } else {
            return Err(String::from(&quot;got empty string&quot;));
        }
    } else {
        return Err(String::from(&quot;got None&quot;));
    }
}

fn main() {
    println!(&quot;result: {:?}&quot;, hex_or_die_trying(Some(String::from(&quot;foo&quot;))));
}
</code></pre></pre>
<p>ä¸ <code>if let</code> ä¸€æ ·ï¼Œ<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a> å˜ä½“ä¼šé’ˆå¯¹ä¸€ä¸ªæ¨¡å¼é‡å¤æµ‹è¯•ä¸€ä¸ªå€¼ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut name = String::from(&quot;Comprehensive Rust ğŸ¦€&quot;);
    while let Some(c) = name.pop() {
        println!(&quot;character: {c}&quot;);
    }
    // (There are more efficient ways to reverse a string!)
}
</code></pre></pre>
<p>Here <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.pop"><code>String::pop</code></a> returns <code>Some(c)</code> until the string is empty, after which it will return <code>None</code>. The <code>while let</code> lets us keep iterating through all items.</p>
<details>
<h2><a class="header" href="#if-let" id="if-let">if-let</a></h2>
<ul>
<li>Unlike <code>match</code>, <code>if let</code> does not have to cover all branches. This can make it more concise than <code>match</code>.</li>
<li>ä½¿ç”¨ <code>Option</code> æ—¶ï¼Œå¸¸è§çš„åšæ³•æ˜¯å¤„ç† <code>Some</code> å€¼ã€‚</li>
<li>ä¸ <code>match</code> ä¸åŒçš„æ˜¯ï¼Œ<code>if let</code> ä¸æ”¯æŒæ¨¡å¼åŒ¹é…çš„ guard å­å¥ã€‚</li>
</ul>
<h2><a class="header" href="#let-else" id="let-else">let-else</a></h2>
<p><code>if-let</code>s can pile up, as shown. The <code>let-else</code> construct supports flattening this nested code. Rewrite the awkward version for students, so they can see the transformation.</p>
<p>é‡å†™åçš„ç‰ˆæœ¬ä¸ºï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hex_or_die_trying(maybe_string: Option&lt;String&gt;) -&gt; Result&lt;u32, String&gt; {
    let Some(s) = maybe_string else {
        return Err(String::from(&quot;got None&quot;));
    };

    let Some(first_byte_char) = s.chars().next() else {
        return Err(String::from(&quot;got empty string&quot;));
    };

    let Some(digit) = first_byte_char.to_digit(16) else {
        return Err(String::from(&quot;not a hex digit&quot;));
    };

    return Ok(digit);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#while-let" id="while-let">while-let</a></h1>
<ul>
<li>æŒ‡å‡ºåªè¦å€¼ä¸æ¨¡å¼åŒ¹é…ï¼Œ<code>while let</code> å¾ªç¯å°±ä¼šä¸€ç›´è¿›è¡Œä¸‹å»ã€‚</li>
<li>You could rewrite the <code>while let</code> loop as an infinite loop with an if statement that breaks when there is no value to unwrap for <code>name.pop()</code>. The <code>while let</code> provides syntactic sugar for the above scenario.</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ è¡¨è¾¾å¼æ±‚å€¼" id="ç»ƒä¹ è¡¨è¾¾å¼æ±‚å€¼">ç»ƒä¹ ï¼šè¡¨è¾¾å¼æ±‚å€¼</a></h1>
<p>Let's write a simple recursive evaluator for arithmetic expressions.</p>
<p>An example of a small arithmetic expression could be <code>10 + 20</code>, which evaluates to <code>30</code>. We can represent the expression as a tree:</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:128px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="280" height="128"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="280" height="128"></rect><rect x="100" y="8" width="64" height="32" class="solid nofill" rx="4"></rect><text x="130" y="28" >+</text><rect x="4" y="72" width="72" height="32" class="solid nofill" rx="4"></rect><text x="34" y="92" >10</text><rect x="196" y="72" width="72" height="32" class="solid nofill" rx="4"></rect><text x="226" y="92" >20</text><g><path d="M 40,24 A 4,4 0,0,0 36,28" class="nofill"></path><line x1="36" y1="28" x2="36" y2="52" class="solid"></line><line x1="40" y1="24" x2="88" y2="24" class="solid"></line><polygon points="32,52 40,52 36,64" class="filled"></polygon></g><g><line x1="176" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="52" class="solid"></line><polygon points="224,52 232,52 228,64" class="filled"></polygon></g></svg></div>
<p>A bigger and more complex expression would be <code>(10 * 9) + ((3 - 4) * 5)</code>, which evaluate to <code>85</code>. We represent this as a much bigger tree:</p>
<!-- mdbook-xgettext: skip -->
<div style='width:100%; height:256px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="256"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="256"></rect><rect x="244" y="8" width="48" height="32" class="solid nofill" rx="4"></rect><text x="266" y="28" >+</text><rect x="76" y="72" width="48" height="32" class="solid nofill" rx="4"></rect><text x="98" y="92" >*</text><rect x="412" y="72" width="48" height="32" class="solid nofill" rx="4"></rect><text x="434" y="92" >*</text><rect x="4" y="136" width="56" height="32" class="solid nofill" rx="4"></rect><text x="26" y="156" >10</text><rect x="148" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="170" y="156" >9</text><rect x="340" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="362" y="156" >-</text><rect x="484" y="136" width="48" height="32" class="solid nofill" rx="4"></rect><text x="506" y="156" >5</text><rect x="268" y="200" width="48" height="32" class="solid nofill" rx="4"></rect><text x="290" y="220" >3</text><rect x="412" y="200" width="48" height="32" class="solid nofill" rx="4"></rect><text x="434" y="220" >4</text><g><path d="M 104,24 A 4,4 0,0,0 100,28" class="nofill"></path><line x1="100" y1="28" x2="100" y2="52" class="solid"></line><line x1="104" y1="24" x2="232" y2="24" class="solid"></line><polygon points="96,52 104,52 100,64" class="filled"></polygon></g><g><line x1="304" y1="24" x2="432" y2="24" class="solid"></line><path d="M 432,24 A 4,4 0,0,1 436,28" class="nofill"></path><line x1="436" y1="28" x2="436" y2="52" class="solid"></line><polygon points="432,52 440,52 436,64" class="filled"></polygon></g><g><path d="M 32,88 A 4,4 0,0,0 28,92" class="nofill"></path><line x1="28" y1="92" x2="28" y2="116" class="solid"></line><line x1="32" y1="88" x2="64" y2="88" class="solid"></line><polygon points="24,116 32,116 28,128" class="filled"></polygon></g><g><line x1="136" y1="88" x2="168" y2="88" class="solid"></line><path d="M 168,88 A 4,4 0,0,1 172,92" class="nofill"></path><line x1="172" y1="92" x2="172" y2="116" class="solid"></line><polygon points="168,116 176,116 172,128" class="filled"></polygon></g><g><path d="M 368,88 A 4,4 0,0,0 364,92" class="nofill"></path><line x1="364" y1="92" x2="364" y2="116" class="solid"></line><line x1="368" y1="88" x2="400" y2="88" class="solid"></line><polygon points="360,116 368,116 364,128" class="filled"></polygon></g><g><line x1="472" y1="88" x2="504" y2="88" class="solid"></line><path d="M 504,88 A 4,4 0,0,1 508,92" class="nofill"></path><line x1="508" y1="92" x2="508" y2="116" class="solid"></line><polygon points="504,116 512,116 508,128" class="filled"></polygon></g><g><path d="M 296,152 A 4,4 0,0,0 292,156" class="nofill"></path><line x1="292" y1="156" x2="292" y2="180" class="solid"></line><line x1="296" y1="152" x2="328" y2="152" class="solid"></line><polygon points="288,180 296,180 292,192" class="filled"></polygon></g><g><line x1="400" y1="152" x2="432" y2="152" class="solid"></line><path d="M 432,152 A 4,4 0,0,1 436,156" class="nofill"></path><line x1="436" y1="156" x2="436" y2="180" class="solid"></line><polygon points="432,180 440,180 436,192" class="filled"></polygon></g></svg></div>
<p>In code, we will represent the tree with two types:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Box</code> type here is a smart pointer, and will be covered in detail later in the course. An expression can be &quot;boxed&quot; with <code>Box::new</code> as seen in the tests. To evaluate a boxed expression, use the deref operator (<code>*</code>) to &quot;unbox&quot; it: <code>eval(*boxed_expr)</code>.</p>
<p>Some expressions cannot be evaluated and will return an error. The standard <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result&lt;Value, String&gt;</code></a> type is an enum that represents either a successful value (<code>Ok(Value)</code>) or an error (<code>Err(String)</code>). We will cover this type in detail later.</p>
<p>å°†ä»£ç å¤åˆ¶ç²˜è´´åˆ° Rust Playgroundï¼Œç„¶åå¼€å§‹å®ç° <code>eval</code>ã€‚æœ€ç»ˆç»“æœåº”èƒ½é€šè¿‡æµ‹è¯•ã€‚ä½¿ç”¨ <code>todo!()</code> å¹¶ä½¿æµ‹è¯•é€ä¸ªé€šè¿‡å¯èƒ½ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚æ‚¨è¿˜å¯ä»¥ä½¿ç”¨ <code>#[ignore]</code> æš‚æ—¶è·³è¿‡æµ‹è¯•ï¼š</p>
<pre><code class="language-none">#[test]
#[ignore]
fn test_value() { .. }
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    todo!()
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_zeros() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Mul,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#è§£ç­”-5" id="è§£ç­”-5">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// An operation to perform on two subexpressions.
#[derive(Debug)]
enum Operation {
    Add,
    Sub,
    Mul,
    Div,
}

/// An expression, in tree form.
#[derive(Debug)]
enum Expression {
    /// An operation on two subexpressions.
    Op { op: Operation, left: Box&lt;Expression&gt;, right: Box&lt;Expression&gt; },

    /// A literal value
    Value(i64),
}

fn eval(e: Expression) -&gt; Result&lt;i64, String&gt; {
    match e {
        Expression::Op { op, left, right } =&gt; {
            let left = match eval(*left) {
                Ok(v) =&gt; v,
                Err(e) =&gt; return Err(e),
            };
            let right = match eval(*right) {
                Ok(v) =&gt; v,
                Err(e) =&gt; return Err(e),
            };
            Ok(match op {
                Operation::Add =&gt; left + right,
                Operation::Sub =&gt; left - right,
                Operation::Mul =&gt; left * right,
                Operation::Div =&gt; {
                    if right == 0 {
                        return Err(String::from(&quot;division by zero&quot;));
                    } else {
                        left / right
                    }
                }
            })
        }
        Expression::Value(v) =&gt; Ok(v),
    }
}

#[test]
fn test_value() {
    assert_eq!(eval(Expression::Value(19)), Ok(19));
}

#[test]
fn test_sum() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(10)),
            right: Box::new(Expression::Value(20)),
        }),
        Ok(30)
    );
}

#[test]
fn test_recursion() {
    let term1 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Value(10)),
        right: Box::new(Expression::Value(9)),
    };
    let term2 = Expression::Op {
        op: Operation::Mul,
        left: Box::new(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(3)),
            right: Box::new(Expression::Value(4)),
        }),
        right: Box::new(Expression::Value(5)),
    };
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(term1),
            right: Box::new(term2),
        }),
        Ok(85)
    );
}

#[test]
fn test_zeros() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Add,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Mul,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Sub,
            left: Box::new(Expression::Value(0)),
            right: Box::new(Expression::Value(0))
        }),
        Ok(0)
    );
}

#[test]
fn test_error() {
    assert_eq!(
        eval(Expression::Op {
            op: Operation::Div,
            left: Box::new(Expression::Value(99)),
            right: Box::new(Expression::Value(0)),
        }),
        Err(String::from(&quot;division by zero&quot;))
    );
}

fn main() {
    let expr = Expression::Op {
        op: Operation::Sub,
        left: Box::new(Expression::Value(20)),
        right: Box::new(Expression::Value(10)),
    };
    println!(&quot;expr: {expr:?}&quot;);
    println!(&quot;result: {:?}&quot;, eval(expr));
}
</code></pre></pre>
<h1><a class="header" href="#æ–¹æ³•å’Œç‰¹å¾" id="æ–¹æ³•å’Œç‰¹å¾">æ–¹æ³•å’Œç‰¹å¾</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#æ–¹æ³•" id="æ–¹æ³•">æ–¹æ³•</a></h1>
<p>Rust å…è®¸æ‚¨å°†å‡½æ•°ä¸æ–°ç±»å‹ç›¸å…³è”ã€‚æ‚¨å¯ä»¥ä½¿ç”¨â€œimplâ€å—æ¥æ‰§è¡Œæ­¤æ“ä½œï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Race {
    name: String,
    laps: Vec&lt;i32&gt;,
}

impl Race {
    // No receiver, a static method
    fn new(name: &amp;str) -&gt; Self {
        Self { name: String::from(name), laps: Vec::new() }
    }

    // Exclusive borrowed read-write access to self
    fn add_lap(&amp;mut self, lap: i32) {
        self.laps.push(lap);
    }

    // Shared and read-only borrowed access to self
    fn print_laps(&amp;self) {
        println!(&quot;Recorded {} laps for {}:&quot;, self.laps.len(), self.name);
        for (idx, lap) in self.laps.iter().enumerate() {
            println!(&quot;Lap {idx}: {lap} sec&quot;);
        }
    }

    // Exclusive ownership of self (covered later)
    fn finish(self) {
        let total: i32 = self.laps.iter().sum();
        println!(&quot;Race {} is finished, total lap time: {}&quot;, self.name, total);
    }
}

fn main() {
    let mut race = Race::new(&quot;Monaco Grand Prix&quot;);
    race.add_lap(70);
    race.add_lap(68);
    race.print_laps();
    race.add_lap(71);
    race.print_laps();
    race.finish();
    // race.add_lap(42);
}
</code></pre></pre>
<p>The <code>self</code> arguments specify the &quot;receiver&quot; - the object the method acts on. There are several common receivers for a method:</p>
<ul>
<li>â€œ&amp;selfâ€ï¼šä½¿ç”¨ä¸å¯å˜çš„å…±äº«å¼•ç”¨ä»è°ƒç”¨æ–¹å€Ÿç”¨å¯¹è±¡ã€‚ä¹‹åå¯ä»¥å†æ¬¡ä½¿ç”¨è¯¥å¯¹è±¡ã€‚</li>
<li>â€œ&amp;mut selfâ€ï¼šä½¿ç”¨å”¯ä¸€çš„å¯å˜å¼•ç”¨ä»è°ƒç”¨æ–¹å€Ÿç”¨å¯¹è±¡ã€‚ä¹‹åå¯ä»¥å†æ¬¡ä½¿ç”¨è¯¥å¯¹è±¡ã€‚</li>
<li>â€œselfâ€ï¼šè·å–å¯¹è±¡çš„æ‰€æœ‰æƒå¹¶å°†å…¶ä»è°ƒç”¨æ–¹ç§»å‡ºã€‚è¯¥æ–¹æ³•ä¼šæˆä¸ºå¯¹è±¡çš„æ‰€æœ‰è€…ã€‚é™¤éæ˜ç¡®è½¬ç§»å¯¹è±¡çš„æ‰€æœ‰æƒï¼Œå¦åˆ™åœ¨è¯¥æ–¹æ³•è¿”å›æ—¶ï¼Œå¯¹è±¡å°†è¢«ä¸¢å¼ƒï¼ˆå–æ¶ˆåˆ†é…ï¼‰ã€‚å…·å¤‡å®Œå…¨æ‰€æœ‰æƒï¼Œä¸è‡ªåŠ¨ç­‰åŒäºå…·å¤‡å¯å˜æ€§ã€‚</li>
<li><code>mut self</code>: same as above, but the method can mutate the object.</li>
<li>æ— æ¥æ”¶å™¨ï¼šè¿™å°†å˜ä¸ºç»“æ„ä½“ä¸Šçš„é™æ€æ–¹æ³•ã€‚é€šå¸¸ç”¨äºåˆ›å»ºæ„é€ å‡½æ•°ï¼ŒæŒ‰æƒ¯ä¾‹è¢«ç§°ä¸ºâ€œnewâ€ã€‚</li>
</ul>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>å¼•å…¥æ–¹æ³•æ—¶ï¼Œå°†æ–¹æ³•ä¸å‡½æ•°è¿›è¡Œæ¯”è¾ƒä¼šå¾ˆæœ‰å¸®åŠ©ã€‚
<ul>
<li>åœ¨æŸç§ç±»å‹ï¼ˆä¾‹å¦‚ç»“æ„ä½“æˆ–æšä¸¾ï¼‰çš„å®ä¾‹ä¸Šè°ƒç”¨æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å°†è¯¥å®ä¾‹è¡¨ç¤ºä¸ºâ€œselfâ€ã€‚</li>
<li>å¼€å‘è€…å¯èƒ½ä¼šé€‰æ‹©ä½¿ç”¨æ–¹æ³•ï¼Œä»¥ä¾¿åˆ©ç”¨æ–¹æ³•æ¥æ”¶å™¨è¯­æ³•å¹¶è®©æ–¹æ³•æ›´æœ‰æ¡ç†ã€‚é€šè¿‡ä½¿ç”¨æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰å®ç°ä»£ç ä¿å­˜åœ¨ä¸€ä¸ªå¯é¢„æµ‹çš„ä½ç½®ã€‚</li>
</ul>
</li>
<li>æŒ‡å‡ºå…³é”®å­—â€œselfâ€çš„ç”¨æ³•ï¼Œå®ƒæ˜¯ä¸€ç§æ–¹æ³•æ¥æ”¶å™¨ã€‚
<ul>
<li>æ˜¾ç¤ºå®ƒæ˜¯â€œself: Selfâ€çš„ç¼©å†™æœ¯è¯­ï¼Œæˆ–è®¸è¦æ˜¾ç¤ºç»“æ„ä½“åç§°çš„å¯èƒ½ç”¨æ³•ã€‚</li>
<li>è¯´æ˜â€œSelfâ€æ˜¯â€œimplâ€å—æ‰€å±ç±»å‹çš„ç±»å‹åˆ«åï¼Œå¯ä»¥åœ¨å—ä¸­çš„å…¶ä»–ä½ç½®ä½¿ç”¨ã€‚</li>
<li>æŒ‡å‡ºâ€œselfâ€çš„ä½¿ç”¨æ–¹å¼ä¸å…¶ä»–ç»“æ„ä½“ä¸€æ ·ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨ç‚¹è¡¨ç¤ºæ³•æ¥æŒ‡ä»£å„ä¸ªå­—æ®µã€‚</li>
<li>This might be a good time to demonstrate how the <code>&amp;self</code> differs from <code>self</code> by trying to run <code>finish</code> twice.</li>
<li>Beyond variants on <code>self</code>, there are also <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html">special wrapper types</a> allowed to be receiver types, such as <code>Box&lt;Self&gt;</code>.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#ç‰¹å¾trait" id="ç‰¹å¾trait">ç‰¹å¾ï¼ˆTraitï¼‰</a></h1>
<p>Rust è®©æ‚¨å¯ä»¥ä¾æ®ç‰¹å¾å¯¹ç±»å‹è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ã€‚ç‰¹å¾ä¸æ¥å£ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">trait Pet {
    /// Return a sentence from this pet.
    fn talk(&amp;self) -&gt; String;

    /// Print a string to the terminal greeting this pet.
    fn greet(&amp;self);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>trait å®šä¹‰äº†ç±»å‹å®ç°è¯¥ trait æ‰€å¿…é¡»å…·å¤‡çš„ä¸€äº›æ–¹æ³•ã€‚</p>
</li>
<li>
<p>In the &quot;Generics&quot; segment, next, we will see how to build functionality that is generic over all types implementing a trait.</p>
</li>
</ul>
</details><h1><a class="header" href="#å®ç°-unsafe-trait" id="å®ç°-unsafe-trait">å®ç° Unsafe Trait</a></h1>
<pre><pre class="playground"><code class="language-rust editable">trait Pet {
    fn talk(&amp;self) -&gt; String;

    fn greet(&amp;self) {
        println!(&quot;Oh you're a cutie! What's your name? {}&quot;, self.talk());
    }
}

struct Dog {
    name: String,
    age: i8,
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

fn main() {
    let fido = Dog { name: String::from(&quot;Fido&quot;), age: 5 };
    fido.greet();
}
</code></pre></pre>
<details>
<ul>
<li>
<p>To implement <code>Trait</code> for <code>Type</code>, you use an <code>impl Trait for Type { .. }</code> block.</p>
</li>
<li>
<p>Unlike Go interfaces, just having matching methods is not enough: a <code>Cat</code> type with a <code>talk()</code> method would not automatically satisfy <code>Pet</code> unless it is in an <code>impl Pet</code> block.</p>
</li>
<li>
<p>Traits may provide default implementations of some methods. Default implementations can rely on all the methods of the trait. In this case, <code>greet</code> is provided, and relies on <code>talk</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#æ›´å¤š-trait" id="æ›´å¤š-trait">æ›´å¤š trait</a></h1>
<p>A trait can require that types implementing it also implement other traits, called <em>supertraits</em>. Here, any type implementing <code>Pet</code> must implement <code>Animal</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">trait Animal {
    fn leg_count(&amp;self) -&gt; u32;
}

trait Pet: Animal {
    fn name(&amp;self) -&gt; String;
}

struct Dog(String);

impl Animal for Dog {
    fn leg_count(&amp;self) -&gt; u32 {
        4
    }
}

impl Pet for Dog {
    fn name(&amp;self) -&gt; String {
        self.0.clone()
    }
}

fn main() {
    let puppy = Dog(String::from(&quot;Rex&quot;));
    println!(&quot;{} has {} legs&quot;, puppy.name(), puppy.leg_count());
}
</code></pre></pre>
<details>
<p>This is sometimes called &quot;trait inheritance&quot; but students should not expect this to behave like OO inheritance. It just specifies an additional requirement on implementations of a trait.</p>
</details>
<h1><a class="header" href="#å…±äº«ç±»å‹" id="å…±äº«ç±»å‹">å…±äº«ç±»å‹</a></h1>
<p>Associated types are placeholder types which are supplied by the trait implementation.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Meters(i32);
#[derive(Debug)]
struct MetersSquared(i32);

trait Multiply {
    type Output;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output;
}

impl Multiply for Meters {
    type Output = MetersSquared;
    fn multiply(&amp;self, other: &amp;Self) -&gt; Self::Output {
        MetersSquared(self.0 * other.0)
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Meters(10).multiply(&amp;Meters(20)));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Associated types are sometimes also called &quot;output types&quot;. The key observation is that the implementer, not the caller, chooses this type.</p>
</li>
<li>
<p>Many standard library traits have associated types, including arithmetic operators and <code>Iterator</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#æ´¾ç”Ÿç‰¹å¾" id="æ´¾ç”Ÿç‰¹å¾">æ´¾ç”Ÿç‰¹å¾</a></h1>
<p>ç³»ç»Ÿå¯ä»¥è‡ªåŠ¨ä¸ºæ‚¨çš„è‡ªå®šä¹‰ç±»å‹å®ç°æ”¯æŒçš„ traitï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Clone, Default)]
struct Player {
    name: String,
    strength: u8,
    hit_points: u8,
}

fn main() {
    let p1 = Player::default(); // Default trait adds `default` constructor.
    let mut p2 = p1.clone(); // Clone trait adds `clone` method.
    p2.name = String::from(&quot;EldurScrollz&quot;);
    // Debug trait adds support for printing with `{:?}`.
    println!(&quot;{p1:?} vs. {p2:?}&quot;);
}
</code></pre></pre>
<details>
<p>æ´¾ç”ŸåŠŸèƒ½æ˜¯é€šè¿‡å®å®ç°çš„ï¼Œå¹¶ä¸”è®¸å¤š crate æä¾›æœ‰ç”¨çš„æ´¾ç”Ÿå®ï¼Œä»¥æ·»åŠ å®ç”¨åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œ<code>serde</code> å¯ä»¥ä½¿ç”¨ <code>#[derive(Serialize)]</code> ä¸ºç»“æ„ä½“æ´¾ç”Ÿåºåˆ—åŒ–æ”¯æŒã€‚</p>
</details><h1><a class="header" href="#exercise-logger-trait" id="exercise-logger-trait">Exercise: Logger Trait</a></h1>
<p>Let's design a simple logging utility, using a trait <code>Logger</code> with a <code>log</code> method. Code which might log its progress can then take an <code>&amp;impl Logger</code>. In testing, this might put messages in the test logfile, while in a production build it would send messages to a log server.</p>
<p>However, the <code>StdoutLogger</code> given below logs all messages, regardless of verbosity. Your task is to write a <code>VerbosityFilter</code> type that will ignore messages above a maximum verbosity.</p>
<p>This is a common pattern: a struct wrapping a trait implementation and implementing that same trait, adding behavior in the process. What other kinds of wrappers might be useful in a logging utility?</p>
<pre><pre class="playground"><code class="language-rust compile_fail">pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: &amp;str);
}

struct StdoutLogger;

impl Logger for StdoutLogger {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        println!(&quot;verbosity={verbosity}: {message}&quot;);
    }
}

// TODO: Define and implement `VerbosityFilter`.

fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StdoutLogger };
    logger.log(5, &quot;FYI&quot;);
    logger.log(2, &quot;Uhoh&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-6" id="è§£ç­”-6">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">pub trait Logger {
    /// Log a message at the given verbosity level.
    fn log(&amp;self, verbosity: u8, message: &amp;str);
}

struct StdoutLogger;

impl Logger for StdoutLogger {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        println!(&quot;verbosity={verbosity}: {message}&quot;);
    }
}

/// Only log messages up to the given verbosity level.
struct VerbosityFilter {
    max_verbosity: u8,
    inner: StdoutLogger,
}

impl Logger for VerbosityFilter {
    fn log(&amp;self, verbosity: u8, message: &amp;str) {
        if verbosity &lt;= self.max_verbosity {
            self.inner.log(verbosity, message);
        }
    }
}

fn main() {
    let logger = VerbosityFilter { max_verbosity: 3, inner: StdoutLogger };
    logger.log(5, &quot;FYI&quot;);
    logger.log(2, &quot;Uhoh&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-1" id="welcome-back-1">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#æ³›å‹" id="æ³›å‹">æ³›å‹</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#æ³›å‹å‡½æ•°" id="æ³›å‹å‡½æ•°">æ³›å‹å‡½æ•°</a></h1>
<p>Rust supports generics, which lets you abstract algorithms or data structures (such as sorting or a binary tree) over the types used or stored.</p>
<pre><pre class="playground"><code class="language-rust editable">/// Pick `even` or `odd` depending on the value of `n`.
fn pick&lt;T&gt;(n: i32, even: T, odd: T) -&gt; T {
    if n % 2 == 0 {
        even
    } else {
        odd
    }
}

fn main() {
    println!(&quot;picked a number: {:?}&quot;, pick(97, 222, 333));
    println!(&quot;picked a string: {:?}&quot;, pick(28, &quot;dog&quot;, &quot;cat&quot;));
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Rust ä¼šæ ¹æ®å‚æ•°ç±»å‹å’Œè¿”å›å€¼æ¨ç†å‡º T çš„ç±»å‹ã€‚</p>
</li>
<li>
<p>In this example we only use the primitive types <code>i32</code> and <code>&amp;str</code> for <code>T</code>, but we can use any type here, including user-defined types:</p>
<pre><code class="language-rust ignore">struct Foo {
    val: u8,
}

pick(123, Foo { val: 7 }, Foo { val: 456 });
</code></pre>
</li>
<li>
<p>è¿™ä¸ C++ æ¨¡æ¿ç±»ä¼¼ï¼Œä½† Rust ä¼šç«‹å³ç¼–è¯‘éƒ¨åˆ†é€šç”¨å‡½æ•°ï¼Œå› æ­¤è¯¥å‡½æ•°å¿…é¡»å¯¹æ‰€æœ‰ç¬¦åˆçº¦æŸæ¡ä»¶çš„ç±»å‹éƒ½æœ‰æ•ˆã€‚ä¾‹å¦‚ï¼Œè¯·å°è¯•ä¿®æ”¹ <code>pick</code> å‡½æ•°ï¼Œå¦‚æœ <code>n == 0</code>ï¼Œåˆ™è¿”å› <code>even + odd</code>ã€‚å³ä½¿ä»…ä½¿ç”¨å¸¦æœ‰æ•´æ•°çš„â€œpickâ€å®ä¾‹åŒ–ï¼ŒRust ä»ä¼šå°†å…¶è§†ä¸ºæ— æ•ˆã€‚C++ å¯è®©æ‚¨åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>
</li>
<li>
<p>Generic code is turned into non-generic code based on the call sites. This is a zero-cost abstraction: you get exactly the same result as if you had hand-coded the data structures without the abstraction.</p>
</li>
</ul>
</details><h1><a class="header" href="#æ³›å‹ç±»å‹" id="æ³›å‹ç±»å‹">æ³›å‹ç±»å‹</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨æ³›å‹å¯¹å…·ä½“å­—æ®µç±»å‹è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn coords(&amp;self) -&gt; (&amp;T, &amp;T) {
        (&amp;self.x, &amp;self.y)
    }

    fn set_x(&amp;mut self, x: T) {
        self.x = x;
    }
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    println!(&quot;{integer:?} and {float:?}&quot;);
    println!(&quot;coords: {:?}&quot;, integer.coords());
}
</code></pre></pre>
<details>
<ul>
<li>
<p>*é—®ï¼š*ä¸ºä»€ä¹ˆ <code>T</code> åœ¨ <code>impl&lt;T&gt; Point&lt;T&gt; {}</code> ä¸­æŒ‡å®šäº†ä¸¤æ¬¡ï¼Ÿè¿™ä¸æ˜¯å¤šä½™çš„å—ï¼Ÿ</p>
<ul>
<li>è¿™æ˜¯å› ä¸ºå®ƒæ˜¯æ³›å‹ç±»å‹çš„æ³›å‹å®ç°éƒ¨åˆ†ã€‚å®ƒä»¬æ˜¯ç‹¬ç«‹çš„æ³›å‹å†…å®¹ã€‚</li>
<li>è¿™æ„å‘³ç€è¿™äº›æ–¹æ³•æ˜¯é’ˆå¯¹æ‰€æœ‰ <code>T</code> å®šä¹‰çš„ã€‚</li>
<li>It is possible to write <code>impl Point&lt;u32&gt; { .. }</code>.
<ul>
<li><code>Point</code> ä¾ç„¶æ˜¯ä¸€ä¸ªæ³›å‹ï¼Œå¹¶ä¸”æ‚¨å¯ä»¥ä½¿ç”¨ <code>Point&lt;f64&gt;</code>ï¼Œä½†æ­¤å—ä¸­çš„æ–¹æ³•å°†ä»…é€‚ç”¨äº <code>Point&lt;u32&gt;</code>ã€‚</li>
</ul>
</li>
</ul>
</li>
<li>
<p>è¯·å°è¯•å£°æ˜ä¸€ä¸ªæ–°å˜é‡ <code>let p = Point { x: 5, y: 10.0 };</code>ã€‚é€šè¿‡ä½¿ç”¨ä¸¤ç§ç±»å‹å˜é‡ï¼ˆä¾‹å¦‚ <code>T</code> å’Œ <code>U</code>ï¼‰ï¼Œæ›´æ–°ä»£ç ä»¥å…è®¸å…·æœ‰ä¸åŒç±»å‹å…ƒç´ çš„ç‚¹ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#æ³›å‹-1" id="æ³›å‹-1">æ³›å‹</a></h1>
<p>Traits can also be generic, just like types and functions. A trait's parameters get concrete types when it is used.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Foo(String);

impl From&lt;u32&gt; for Foo {
    fn from(from: u32) -&gt; Foo {
        Foo(format!(&quot;Converted from integer: {from}&quot;))
    }
}

impl From&lt;bool&gt; for Foo {
    fn from(from: bool) -&gt; Foo {
        Foo(format!(&quot;Converted from bool: {from}&quot;))
    }
}

fn main() {
    let from_int = Foo::from(123);
    let from_bool = Foo::from(true);
    println!(&quot;{from_int:?}, {from_bool:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>From</code> trait will be covered later in the course, but its <a href="https://doc.rust-lang.org/std/convert/trait.From.html">definition in the <code>std</code> docs</a> is simple.</p>
</li>
<li>
<p>Implementations of the trait do not need to cover all possible type parameters. Here, <code>Foo::from(&quot;hello&quot;)</code> would not compile because there is no <code>From&lt;&amp;str&gt;</code> implementation for <code>Foo</code>.</p>
</li>
<li>
<p>Generic traits take types as &quot;input&quot;, while associated types are a kind of &quot;output&quot; type. A trait can have multiple implementations for different input types.</p>
</li>
<li>
<p>In fact, Rust requires that at most one implementation of a trait match for any type T. Unlike some other languages, Rust has no heuristic for choosing the &quot;most specific&quot; match. There is work on adding this support, called <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç‰¹å¾è¾¹ç•Œ" id="ç‰¹å¾è¾¹ç•Œ">ç‰¹å¾è¾¹ç•Œ</a></h1>
<p>ä½¿ç”¨æ³›å‹æ—¶ï¼Œæ‚¨é€šå¸¸ä¼šæƒ³è¦åˆ©ç”¨ç±»å‹æ¥å®ç°æŸäº›ç‰¹æ€§ï¼Œ è¿™æ ·æ‰èƒ½è°ƒç”¨æ­¤ç‰¹å¾çš„æ–¹æ³•ã€‚</p>
<p>You can do this with <code>T: Trait</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn duplicate&lt;T: Clone&gt;(a: T) -&gt; (T, T) {
    (a.clone(), a.clone())
}

// struct NotCloneable;

fn main() {
    let foo = String::from(&quot;foo&quot;);
    let pair = duplicate(foo);
    println!(&quot;{pair:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Try making a <code>NonCloneable</code> and passing it to <code>duplicate</code>.</p>
</li>
<li>
<p>å½“éœ€è¦å¤šä¸ª trait æ—¶ï¼Œè¯·ä½¿ç”¨ <code>+</code> å°†å®ƒä»¬è¿æ¥èµ·æ¥ã€‚</p>
</li>
<li>
<p>æ˜¾ç¤º <code>where</code> å­å¥ï¼Œå­¦å‘˜åœ¨é˜…è¯»ä»£ç æ—¶ä¼šçœ‹åˆ°å®ƒã€‚</p>
<pre><code class="language-rust ignore">fn duplicate&lt;T&gt;(a: T) -&gt; (T, T)
where
    T: Clone,
{
    (a.clone(), a.clone())
}
</code></pre>
<ul>
<li>å®ƒä¼šåœ¨æ‚¨æœ‰å¤šä¸ªå½¢å‚çš„æƒ…å†µä¸‹æ•´ç†å‡½æ•°ç­¾åã€‚</li>
<li>å®ƒå…·æœ‰é¢å¤–åŠŸèƒ½ï¼Œå› æ­¤ä¹Ÿæ›´å¼ºå¤§ã€‚
<ul>
<li>å¦‚æœæœ‰äººæé—®ï¼Œä¾¿é˜æ˜é¢å¤–åŠŸèƒ½æ˜¯æŒ‡â€œ:â€å·¦ä¾§çš„ç±»åˆ«å¯ä¸ºä»»æ„å€¼ï¼Œä¾‹å¦‚ <code>Option&lt;T&gt;</code>ã€‚</li>
</ul>
</li>
</ul>
</li>
<li>
<p>è¯·æ³¨æ„ï¼ŒRust å°šä¸æ”¯æŒä¸“ç²¾é¢†åŸŸè®¤è¯ã€‚ä¾‹å¦‚ï¼Œæ ¹æ®åŸå§‹ <code>duplicate</code> å‡½æ•°ï¼Œæ·»åŠ ä¸“ç²¾é¢†åŸŸè®¤è¯çš„ <code>Duplicate(a: u32)</code> æ˜¯æ— æ•ˆçš„ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>ä¸ç‰¹å¾è¾¹ç•Œç±»ä¼¼ï¼Œ<code>impl Trait</code> è¯­æ³•å¯ä»¥åœ¨å‡½æ•°å½¢å‚ å’Œè¿”å›å€¼ä¸­ä½¿ç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">// Syntactic sugar for:
//   fn add_42_millions&lt;T: Into&lt;i32&gt;&gt;(x: T) -&gt; i32 {
fn add_42_millions(x: impl Into&lt;i32&gt;) -&gt; i32 {
    x.into() + 42_000_000
}

fn pair_of(x: u32) -&gt; impl std::fmt::Debug {
    (x + 1, x - 1)
}

fn main() {
    let many = add_42_millions(42_i8);
    println!(&quot;{many}&quot;);
    let many_more = add_42_millions(10_000_000);
    println!(&quot;{many_more}&quot;);
    let debuggable = pair_of(27);
    println!(&quot;debuggable: {debuggable:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>impl Trait</code> allows you to work with types which you cannot name. The meaning of <code>impl Trait</code> is a bit different in the different positions.</p>
<ul>
<li>
<p>å¯¹å½¢å‚æ¥è¯´ï¼Œ<code>impl Trait</code> å°±åƒæ˜¯å…·æœ‰ç‰¹å¾è¾¹ç•Œçš„åŒ¿åæ³›å‹å½¢å‚ã€‚</p>
</li>
<li>
<p>å¯¹è¿”å›å€¼ç±»å‹æ¥è¯´ï¼Œå®ƒåˆ™æ„å‘³ç€è¿”å›å€¼ç±»å‹å°±æ˜¯å®ç°è¯¥ç‰¹å¾çš„æŸå…·ä½“ç±»å‹ï¼Œ æ— éœ€ä¸ºè¯¥ç±»å‹å‘½åã€‚å¦‚æœæ‚¨ä¸æƒ³åœ¨å…¬å…± API ä¸­å…¬å¼€è¯¥å…·ä½“ç±»å‹ï¼Œä¾¿å¯ ä½¿ç”¨æ­¤æ–¹æ³•ã€‚</p>
<p>åœ¨è¿”å›ä½ç½®å¤„è¿›è¡Œæ¨æ–­æœ‰ä¸€å®šéš¾åº¦ã€‚ä¼šè¿”å› <code>impl Foo</code> çš„å‡½æ•°ä¼šæŒ‘é€‰ è‡ªèº«è¿”å›çš„å…·ä½“ç±»å‹ï¼Œè€Œä¸å¿…åœ¨æ¥æºä¸­å†™å‡ºæ­¤ä¿¡æ¯ã€‚ä¼šè¿”å› æ³›å‹ç±»å‹ï¼ˆä¾‹å¦‚ <code>collect&lt;B&gt;() -&gt; B</code>ï¼‰çš„å‡½æ•°åˆ™å¯è¿”å›ç¬¦åˆ <code>B</code> çš„ä»»ä½•ç±»å‹ï¼Œè€Œè°ƒç”¨æ–¹å¯èƒ½éœ€è¦é€‰æ‹©ä¸€ä¸ªç±»å‹ï¼Œä¾‹å¦‚ä½¿ç”¨ <code>let x: Vec&lt;_&gt; = foo.collect()</code> æˆ–ä½¿ç”¨ä»¥ä¸‹ Turbofishï¼š<code>foo.collect::&lt;Vec&lt;_&gt;&gt;()</code>ã€‚</p>
</li>
</ul>
<p><code>debuggable</code> æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿå°è¯•è¾“å…¥ <code>let debuggable: () = ..</code>ï¼ŒæŸ¥çœ‹ä¼šæ˜¾ç¤ºä»€ä¹ˆé”™è¯¯æ¶ˆæ¯ã€‚</p>
</details><h1><a class="header" href="#dyn-trait" id="dyn-trait"><code>dyn Trait</code></a></h1>
<p>In addition to using traits for static dispatch via generics, Rust also supports using them for type-erased, dynamic dispatch via trait objects:</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from(&quot;Miau!&quot;)
    }
}

// Uses generics and static dispatch.
fn generic(pet: &amp;impl Pet) {
    println!(&quot;Hello, who are you? {}&quot;, pet.talk());
}

// Uses type-erasure and dynamic dispatch.
fn dynamic(pet: &amp;dyn Pet) {
    println!(&quot;Hello, who are you? {}&quot;, pet.talk());
}

fn main() {
    let cat = Cat { lives: 9 };
    let dog = Dog { name: String::from(&quot;Fido&quot;), age: 5 };

    generic(&amp;cat);
    generic(&amp;dog);

    dynamic(&amp;cat);
    dynamic(&amp;dog);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>Generics, including <code>impl Trait</code>, use monomorphization to create a specialized instance of the function for each different type that the generic is instantiated with. This means that calling a trait method from within a generic function still uses static dispatch, as the compiler has full type information and can resolve which type's trait implementation to use.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, it instead uses dynamic dispatch through a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual method table</a> (vtable). This means that there's a single version of <code>fn dynamic</code> that is used regardless of what type of <code>Pet</code> is passed in.</p>
</li>
<li>
<p>When using <code>dyn Trait</code>, the trait object needs to be behind some kind of indirection. In this case it's a reference, though smart pointer types like <code>Box</code> can also be used (this will be demonstrated on day 3).</p>
</li>
<li>
<p>At runtime, a <code>&amp;dyn Pet</code> is represented as a &quot;fat pointer&quot;, i.e. a pair of two pointers: One pointer points to the concrete object that implements <code>Pet</code>, and the other points to the vtable for the trait implementation for that type. When calling the <code>talk</code> method on <code>&amp;dyn Pet</code> the compiler looks up the function pointer for <code>talk</code> in the vtable and then invokes the function, passing the pointer to the <code>Dog</code> or <code>Cat</code> into that function. The compiler doesn't need to know the concrete type of the <code>Pet</code> in order to do this.</p>
</li>
<li>
<p>A <code>dyn Trait</code> is considered to be &quot;type-erased&quot;, because we no longer have compile-time knowledge of what the concrete type is.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ é€šç”¨-min-å‡½æ•°" id="ç»ƒä¹ é€šç”¨-min-å‡½æ•°">ç»ƒä¹ ï¼šé€šç”¨ <code>min</code> å‡½æ•°</a></h1>
<p>In this short exercise, you will implement a generic <code>min</code> function that determines the minimum of two values, using the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::cmp::Ordering;

// TODO: implement the `min` function used in `main`.

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min(&quot;hello&quot;, &quot;goodbye&quot;), &quot;goodbye&quot;);
    assert_eq!(min(&quot;bat&quot;, &quot;armadillo&quot;), &quot;armadillo&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>Show students the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a> trait and <a href="https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html"><code>Ordering</code></a> enum.</li>
</ul>
</details>
<h1><a class="header" href="#è§£ç­”-7" id="è§£ç­”-7">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;

fn min&lt;T: Ord&gt;(l: T, r: T) -&gt; T {
    match l.cmp(&amp;r) {
        Ordering::Less | Ordering::Equal =&gt; l,
        Ordering::Greater =&gt; r,
    }
}

fn main() {
    assert_eq!(min(0, 10), 0);
    assert_eq!(min(500, 123), 123);

    assert_eq!(min('a', 'z'), 'a');
    assert_eq!(min('7', '1'), '1');

    assert_eq!(min(&quot;hello&quot;, &quot;goodbye&quot;), &quot;goodbye&quot;);
    assert_eq!(min(&quot;bat&quot;, &quot;armadillo&quot;), &quot;armadillo&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#æ ‡å‡†åº“ç±»å‹" id="æ ‡å‡†åº“ç±»å‹">æ ‡å‡†åº“ç±»å‹</a></h1>
<p>{{%segment outline}}</p>
<details>
<p>å¯¹äºæœ¬éƒ¨åˆ†çš„æ¯å¼ å¹»ç¯ç‰‡ï¼Œè¯·èŠ±äº›æ—¶é—´ä»”ç»†é˜…è¯»æ–‡æ¡£é¡µé¢ï¼Œé‡ç‚¹äº†è§£ä¸€äº›è¾ƒä¸ºå¸¸ç”¨çš„æ–¹æ³•ã€‚</p>
</details>
<h1><a class="header" href="#æ ‡å‡†åº“" id="æ ‡å‡†åº“">æ ‡å‡†åº“</a></h1>
<p>Rust comes with a standard library which helps establish a set of common types used by Rust libraries and programs. This way, two libraries can work together smoothly because they both use the same <code>String</code> type.</p>
<p>In fact, Rust contains several layers of the Standard Library: <code>core</code>, <code>alloc</code> and <code>std</code>.</p>
<ul>
<li><code>core</code> includes the most basic types and functions that don't depend on <code>libc</code>, allocator or even the presence of an operating system.</li>
<li><code>alloc</code> åŒ…æ‹¬éœ€è¦å…¨å±€å †åˆ†é…å™¨çš„ç±»å‹ï¼Œä¾‹å¦‚ <code>Vec</code>ã€<code>Box</code> å’Œ <code>Arc</code>ã€‚</li>
<li>åµŒå…¥å¼ Rust åº”ç”¨é€šå¸¸åªä½¿ç”¨ <code>core</code>ï¼Œå¶å°”ä¼šä½¿ç”¨ <code>alloc</code>ã€‚</li>
</ul>
<h1><a class="header" href="#æ–‡æ¡£" id="æ–‡æ¡£">æ–‡æ¡£</a></h1>
<p>Rust comes with extensive documentation. For example:</p>
<ul>
<li>All of the details about <a href="https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html">loops</a>.</li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.u8.html">'u8'</a> ç­‰åŸºå…ƒç±»å‹ã€‚</li>
<li>Standard library types like <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> or <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a>.</li>
</ul>
<p>Use <code>rustup doc --std</code> or <a href="https://std.rs">https://std.rs</a> to view the documentation.</p>
<p>äº‹å®ä¸Šï¼Œæ‚¨å¯ä»¥ä¸ºè‡ªå·±çš„ä»£ç ç¼–å†™æ–‡æ¡£ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">/// Determine whether the first argument is divisible by the second argument.
///
/// If the second argument is zero, the result is false.
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    if rhs == 0 {
        return false;
    }
    lhs % rhs == 0
}
</code></pre></pre>
<p>The contents are treated as Markdown. All published Rust library crates are automatically documented at <a href="https://docs.rs"><code>docs.rs</code></a> using the <a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> tool. It is idiomatic to document all public items in an API using this pattern.</p>
<p>å¦‚éœ€ä»é¡¹å†…ï¼ˆä¾‹å¦‚åœ¨æ¨¡å—å†…ï¼‰ä¸ºé¡¹ç¼–å†™æ–‡æ¡£ï¼Œè¯·ä½¿ç”¨ <code>//!</code> æˆ– <code>/*! .. */</code>ï¼Œè¿™ç§°ä¸ºâ€œå†…éƒ¨æ–‡æ¡£æ³¨é‡Šâ€ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">//! This module contains functionality relating to divisibility of integers.
</code></pre></pre>
<details>
<ul>
<li>Show students the generated docs for the <code>rand</code> crate at <a href="https://docs.rs/rand">https://docs.rs/rand</a>.</li>
</ul>
</details><h1><a class="header" href="#option" id="option">Option</a></h1>
<p>æˆ‘ä»¬å·²ç»äº†è§£äº† <code>Option&lt;T&gt;</code> çš„ä¸€äº›ç”¨æ³•ã€‚å®ƒå¯ä»¥å­˜å‚¨â€œTâ€ç±»å‹çš„å€¼ï¼Œæˆ–è€…ä¸å­˜å‚¨ä»»ä½•å€¼ã€‚ä¾‹å¦‚ï¼Œ<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.find">'String::find'</a> ä¼šè¿”å› <code>Option&lt;usize&gt;</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let name = &quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;;
    let mut position: Option&lt;usize&gt; = name.find('Ã©');
    println!(&quot;find returned {position:?}&quot;);
    assert_eq!(position.unwrap(), 14);
    position = name.find('Z');
    println!(&quot;find returned {position:?}&quot;);
    assert_eq!(position.expect(&quot;Character not found&quot;), 0);
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Option</code> is widely used, not just in the standard library.</p>
</li>
<li>
<p><code>unwrap</code> ä¼šè¿”å› <code>Option</code> æˆ– panic ä¸­çš„å€¼ã€‚<code>expect</code> æ–¹æ³•ä¸æ­¤ç±»ä¼¼ï¼Œä½†å…¶ä½¿ç”¨é”™è¯¯æ¶ˆæ¯ã€‚</p>
<ul>
<li>å‡ºç° None æ—¶æ‚¨æˆ–è®¸ä¼šææ…Œï¼Œä½†ä¸èƒ½ â€œæ— æ„ä¸­â€å¿˜è®°æ£€æŸ¥æ˜¯å¦ä¸º None çš„æƒ…å†µã€‚</li>
<li>åœ¨è‰æ‹Ÿé˜¶æ®µçš„ç¼–ç¨‹ä¸­ï¼Œé¢‘ç¹ä½¿ç”¨ <code>unwrap</code>/<code>expect</code> è¿›è¡Œå¤„ç†ååˆ†å¸¸è§ï¼Œä½†åœ¨æ­£å¼ç‰ˆä»£ç æ—¶ï¼Œé€šå¸¸ä»¥æ›´ä¸ºå¦¥å½“çš„æ–¹å¼å¤„ç† <code>None</code> çš„æƒ…å†µã€‚</li>
</ul>
</li>
<li>
<p>The &quot;niche optimization&quot; means that <code>Option&lt;T&gt;</code> often has the same size in memory as <code>T</code>, if there is some representation that is not a valid value of T. For example, a reference cannot be NULL, so <code>Option&lt;&amp;T&gt;</code> automatically uses NULL to represent the <code>None</code> variant, and thus can be stored in the same memory as <code>&amp;T</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#result" id="result">Result</a></h1>
<p><code>Result</code> is similar to <code>Option</code>, but indicates the success or failure of an operation, each with a different enum variant. It is generic: <code>Result&lt;T, E&gt;</code> where <code>T</code> is used in the <code>Ok</code> variant and <code>E</code> appears in the <code>Err</code> variant.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!(&quot;Dear diary: {contents} ({bytes} bytes)&quot;);
            } else {
                println!(&quot;Could not read file content&quot;);
            }
        }
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>ä¸ <code>Option</code> æ–¹æ³•ç›¸åŒï¼ŒæˆåŠŸå€¼ä½äº <code>Result</code> æ–¹æ³•å†…éƒ¨ï¼Œ å¼€å‘è€…å¿…é¡»æ˜¾ç¤ºæå–æˆåŠŸå€¼ã€‚å› æ­¤ï¼Œå»ºè®®è¿›è¡Œé”™è¯¯æ£€æŸ¥ã€‚åœ¨ç»ä¸åº”å‡ºç°é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œ å¯ä»¥è°ƒç”¨ <code>unwrap()</code> æˆ– <code>expect()</code> æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§å¼€å‘è€…æ„å‘ä¿¡å·ã€‚</li>
<li><code>Result</code> documentation is a recommended read. Not during the course, but it is worth mentioning. It contains a lot of convenience methods and functions that help functional-style programming.</li>
<li><code>Result</code> is the standard type to implement error handling as we will see on Day 4.</li>
</ul>
</details><h1><a class="header" href="#string" id="string">String</a></h1>
<p><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> is a growable UTF-8 encoded string:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::new();
    s1.push_str(&quot;Hello&quot;);
    println!(&quot;s1: len = {}, capacity = {}&quot;, s1.len(), s1.capacity());

    let mut s2 = String::with_capacity(s1.len() + 1);
    s2.push_str(&amp;s1);
    s2.push('!');
    println!(&quot;s2: len = {}, capacity = {}&quot;, s2.len(), s2.capacity());

    let s3 = String::from(&quot;ğŸ‡¨ğŸ‡­&quot;);
    println!(&quot;s3: len = {}, number of chars = {}&quot;, s3.len(), s3.chars().count());
}
</code></pre></pre>
<p><code>String</code> ä¼šå®ç° <a href="https://doc.rust-lang.org/std/string/struct.String.html#deref-methods-str"><code>Deref&lt;Target = str&gt;</code></a>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥ å¯¹ <code>String</code> è°ƒç”¨æ‰€æœ‰ <code>str</code> æ–¹æ³•ã€‚</p>
<details>
<ul>
<li>â€œString::newâ€ä¼šè¿”å›ä¸€ä¸ªæ–°çš„ç©ºå­—ç¬¦ä¸²ï¼Œå¦‚æœæ‚¨çŸ¥é“è‡ªå·±æƒ³è¦æ¨é€åˆ°å­—ç¬¦ä¸²çš„æ•°æ®é‡ï¼Œè¯·ä½¿ç”¨â€œString::with_capacityâ€ã€‚</li>
<li>â€œString::lenâ€ä¼šè¿”å›â€œStringâ€çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼Œå¯èƒ½ä¸åŒäºä»¥å­—ç¬¦ä¸ºå•ä½çš„é•¿åº¦ï¼‰ã€‚</li>
<li>â€œString::charsâ€ä¼šé’ˆå¯¹å®é™…å­—ç¬¦è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ã€‚è¯·æ³¨æ„ï¼Œç”±äº<a href="https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html">å­—ç´ ç°‡</a>ï¼Œâ€œcharâ€å¯èƒ½ä¸äººä»¬æ‰€è®¤ä¸ºçš„â€œå­—ç¬¦â€æœ‰æ‰€ä¸åŒã€‚</li>
<li>å½“äººä»¬æåˆ°å­—ç¬¦ä¸²æ—¶ï¼Œå¯èƒ½æ˜¯æŒ‡â€œ&amp;strâ€æˆ–â€œStringâ€ã€‚</li>
<li>å½“æŸä¸ªç±»å‹å®ç°â€œDeref&lt;Target = T&gt;â€æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè®©æ‚¨ä»¥å…¬å¼€é€æ˜æ–¹å¼ä»â€œTâ€è°ƒç”¨æ–¹æ³•ã€‚
<ul>
<li>æˆ‘ä»¬å°šæœªè®¨è®ºè¿‡ <code>Deref</code> traitï¼Œæ‰€ä»¥æœ¬éƒ¨åˆ†ç›®å‰ä¸»è¦ä»‹ç»æ–‡æ¡£ä¸­è¾¹æ çš„ç»“æ„ã€‚</li>
<li>â€œStringâ€ä¼šå®ç°â€œDeref&lt;Target = str&gt;â€ï¼Œåè€…å¯å…¬å¼€é€æ˜åœ°æˆäºˆå…¶è®¿é—®â€œstrâ€æ–¹æ³•çš„æƒé™ã€‚</li>
<li>Write and compare <code>let s3 = s1.deref();</code> and <code>let s3 = &amp;*s1;</code>.</li>
</ul>
</li>
<li>â€œStringâ€æ˜¯ä½œä¸ºå­—èŠ‚çŸ¢é‡çš„å°è£…å®¹å™¨å®ç°çš„ï¼ŒçŸ¢é‡ä¸Šæ”¯æŒçš„è®¸å¤šæ“ä½œåœ¨â€œStringâ€ä¸Šä¹Ÿå—æ”¯æŒï¼Œä½†æœ‰ä¸€äº›é¢å¤–ä¿è¯ã€‚</li>
<li>æ¯”è¾ƒå°†â€œStringâ€ç¼–å…¥ç´¢å¼•çš„ä¸åŒæ–¹å¼ï¼š
<ul>
<li>ä½¿ç”¨â€œs3.chars().nth(i).unwrap()â€è½¬æ¢ä¸ºå­—ç¬¦ï¼Œå…¶ä¸­â€œiâ€ä»£è¡¨æ˜¯å¦å‡ºç•Œã€‚</li>
<li>é€šè¿‡ä½¿ç”¨â€œs3[0..4]â€è½¬æ¢ä¸ºå­å­—ç¬¦ä¸²ï¼Œå…¶ä¸­è¯¥ Slice åœ¨æˆ–ä¸åœ¨å­—ç¬¦è¾¹ç•Œä¸Šã€‚</li>
</ul>
</li>
<li>Many types can be converted to a string with the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string"><code>to_string</code></a> method. This trait is automatically implemented for all types that implement <code>Display</code>, so anything that can be formatted can also be converted to a string.</li>
</ul>
</details><h1><a class="header" href="#vec" id="vec"><code>Vec</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> æ˜¯æ ‡å‡†çš„å¯è°ƒæ•´å¤§å°å †åˆ†é…ç¼“å†²åŒºï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut v1 = Vec::new();
    v1.push(42);
    println!(&quot;v1: len = {}, capacity = {}&quot;, v1.len(), v1.capacity());

    let mut v2 = Vec::with_capacity(v1.len() + 1);
    v2.extend(v1.iter());
    v2.push(9999);
    println!(&quot;v2: len = {}, capacity = {}&quot;, v2.len(), v2.capacity());

    // Canonical macro to initialize a vector with elements.
    let mut v3 = vec![0, 0, 1, 2, 3, 4];

    // Retain only the even elements.
    v3.retain(|x| x % 2 == 0);
    println!(&quot;{v3:?}&quot;);

    // Remove consecutive duplicates.
    v3.dedup();
    println!(&quot;{v3:?}&quot;);
}
</code></pre></pre>
<p><code>Vec</code> ä¼šå®ç° <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D"><code>Deref&lt;Target = [T]&gt;</code></a>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥å¯¹ <code>Vec</code> è°ƒç”¨ slice æ–¹æ³•ã€‚</p>
<details>
<ul>
<li><code>Vec</code> is a type of collection, along with <code>String</code> and <code>HashMap</code>. The data it contains is stored on the heap. This means the amount of data doesn't need to be known at compile time. It can grow or shrink at runtime.</li>
<li>Notice how <code>Vec&lt;T&gt;</code> is a generic type too, but you don't have to specify <code>T</code> explicitly. As always with Rust type inference, the <code>T</code> was established during the first <code>push</code> call.</li>
<li>â€œvec![...]â€æ˜¯ç”¨æ¥ä»£æ›¿â€œVec::new()â€çš„è§„èŒƒåŒ–å®ï¼Œå®ƒæ”¯æŒå‘çŸ¢é‡æ·»åŠ åˆå§‹å…ƒç´ ã€‚</li>
<li>å¦‚éœ€å°†çŸ¢é‡ç¼–å…¥ç´¢å¼•ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨â€œ[â€™ â€˜]â€æ–¹æ³•ï¼Œä½†å¦‚æœè¶…å‡ºè¾¹ç•Œï¼ŒçŸ¢é‡å°†ä¼š panicã€‚æ­¤å¤–ï¼Œä½¿ç”¨â€œgetâ€å°†è¿”å›â€œOptionâ€ã€‚â€œpopâ€å‡½æ•°ä¼šç§»é™¤æœ€åä¸€ä¸ªå…ƒç´ ã€‚</li>
<li>Slices are covered on day 3. For now, students only need to know that a value of type <code>Vec</code> gives access to all of the documented slice methods, too.</li>
</ul>
</details><h1><a class="header" href="#hashmap" id="hashmap"><code>HashMap</code></a></h1>
<p>æ ‡å‡†çš„å“ˆå¸Œæ˜ å°„ï¼Œå†…å«é’ˆå¯¹ HashDoS æ”»å‡»çš„ä¿æŠ¤æªæ–½ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let mut page_counts = HashMap::new();
    page_counts.insert(&quot;Adventures of Huckleberry Finn&quot;, 207);
    page_counts.insert(&quot;Grimms' Fairy Tales&quot;, 751);
    page_counts.insert(&quot;Pride and Prejudice&quot;, 303);

    if !page_counts.contains_key(&quot;Les MisÃ©rables&quot;) {
        println!(
            &quot;We know about {} books, but not Les MisÃ©rables.&quot;,
            page_counts.len()
        );
    }

    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        match page_counts.get(book) {
            Some(count) =&gt; println!(&quot;{book}: {count} pages&quot;),
            None =&gt; println!(&quot;{book} is unknown.&quot;),
        }
    }

    // Use the .entry() method to insert a value if nothing is found.
    for book in [&quot;Pride and Prejudice&quot;, &quot;Alice's Adventure in Wonderland&quot;] {
        let page_count: &amp;mut i32 = page_counts.entry(book).or_insert(0);
        *page_count += 1;
    }

    println!(&quot;{page_counts:#?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>â€œHashMapâ€æœªåœ¨åºè¨€ä¸­å®šä¹‰ï¼Œå› æ­¤éœ€è¦çº³å…¥èŒƒå›´ä¸­ã€‚</p>
</li>
<li>
<p>è¯·å°è¯•ä½¿ç”¨ä»¥ä¸‹ä»£ç è¡Œã€‚ç¬¬ä¸€è¡Œå°†æŸ¥çœ‹å›¾ä¹¦æ˜¯å¦åœ¨ hashmap ä¸­ï¼›å¦‚æœä¸åœ¨ï¼Œåˆ™è¿”å›æ›¿ä»£å€¼ã€‚å¦‚æœæœªæ‰¾åˆ°å›¾ä¹¦ï¼Œç¬¬äºŒè¡Œä¼šåœ¨ hashmap ä¸­æ’å…¥æ›¿ä»£å€¼ã€‚</p>
<pre><code class="language-rust ignore">let pc1 = page_counts
    .get(&quot;Harry Potter and the Sorcerer's Stone&quot;)
    .unwrap_or(&amp;336);
let pc2 = page_counts
    .entry(&quot;The Hunger Games&quot;)
    .or_insert(374);
</code></pre>
</li>
<li>
<p>é—æ†¾çš„æ˜¯ï¼Œä¸â€œvec!â€ä¸åŒï¼Œä¸å­˜åœ¨æ ‡å‡†çš„â€œhashmap!â€å®ã€‚</p>
<ul>
<li>
<p>ä¸è¿‡ï¼Œä» Rust 1.56 å¼€å§‹ï¼ŒHashMap å®ç°äº†<a href="https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#impl-From%3C%5B(K,+V);+N%5D%3E-for-HashMap%3CK,+V,+RandomState%3E">â€œFrom&lt;[(K, V); N]&gt;â€</a>ï¼Œè®©æˆ‘ä»¬èƒ½å¤Ÿè½»æ¾åœ°ä»å­—é¢é‡æ•°ç»„åˆå§‹åŒ–å“ˆå¸Œæ˜ å°„ï¼š</p>
<pre><code class="language-rust ignore">let page_counts = HashMap::from([
  (&quot;Harry Potter and the Sorcerer's Stone&quot;.to_string(), 336),
  (&quot;The Hunger Games&quot;.to_string(), 374),
]);
</code></pre>
</li>
</ul>
</li>
<li>
<p>æˆ–è€…ï¼ŒHashMap ä¹Ÿå¯ä»¥åŸºäºä»»ä½•å¯ç”Ÿæˆé”®-å€¼å…ƒç»„çš„â€œIteratorâ€è¿›è¡Œæ„å»ºã€‚</p>
</li>
<li>
<p>æ­¤ç±»å‹å…·æœ‰å‡ ç§ç‰¹å®šäºæ–¹æ³•çš„è¿”å›å€¼ç±»å‹ï¼Œä¾‹å¦‚â€œstd::collections::hash_map::Keysâ€ã€‚è¿™äº›ç±»å‹é€šå¸¸ä¼šå‡ºç°åœ¨ Rust æ–‡æ¡£çš„æœç´¢ç»“æœä¸­ã€‚å‘å­¦å‘˜å±•ç¤ºæ­¤ç±»å‹çš„æ–‡æ¡£ï¼Œä»¥åŠæŒ‡å‘â€œkeysâ€æ–¹æ³•çš„å®ç”¨é“¾æ¥ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ è®¡æ•°å™¨" id="ç»ƒä¹ è®¡æ•°å™¨">ç»ƒä¹ ï¼šè®¡æ•°å™¨</a></h1>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæ‚¨å°†å­¦ä¹ ä¸€ä¸ªéå¸¸ç®€å•çš„æ•°æ®ç»“æ„ï¼Œå¹¶å°†å…¶å˜æˆæ³›å‹çš„ã€‚è¯¥ç»“æ„ä½¿ç”¨ <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>std::collections::HashMap</code></a> æ¥è·Ÿè¸ªå·²ç»å‡ºç°è¿‡çš„å€¼ä»¥åŠæ¯ä¸ªå€¼å‡ºç°çš„æ¬¡æ•°ã€‚</p>
<p><code>Counter</code> çš„åˆå§‹ç‰ˆæœ¬ç»è¿‡ç¡¬ç¼–ç ï¼Œä»…é€‚ç”¨äº <code>u32</code> å€¼ã€‚ä½¿ç»“æ„ä½“åŠå…¶æ–¹æ³•å¯ç”¨äºæ‰€è·Ÿè¸ªçš„å€¼ç±»å‹ï¼Œä»¥ä¾¿ <code>Counter</code> èƒ½å¤Ÿè·Ÿè¸ªä»»ä½•ç±»å‹çš„å€¼ã€‚</p>
<p>å¦‚æœæå‰å®Œæˆæ“ä½œï¼Œè¯·å°è¯•ä½¿ç”¨ <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.entry"><code>entry</code></a> æ–¹æ³•å°†å“ˆå¸ŒæŸ¥æ‰¾æ¬¡æ•°å‡åŠï¼Œä»è€Œå®ç° <code>count</code> æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust compile_fail editable">use std::collections::HashMap;

/// Counter counts the number of times each value of type T has been seen.
struct Counter {
    values: HashMap&lt;u32, u64&gt;,
}

impl Counter {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter {
            values: HashMap::new(),
        }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: u32) {
        if self.values.contains_key(&amp;value) {
            *self.values.get_mut(&amp;value).unwrap() += 1;
        } else {
            self.values.insert(value, 1);
        }
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: u32) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!(&quot;saw {} values equal to {}&quot;, ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count(&quot;apple&quot;);
    strctr.count(&quot;orange&quot;);
    strctr.count(&quot;apple&quot;);
    println!(&quot;got {} apples&quot;, strctr.times_seen(&quot;apple&quot;));
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-8" id="è§£ç­”-8">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;
use std::hash::Hash;

/// Counter counts the number of times each value of type T has been seen.
struct Counter&lt;T&gt; {
    values: HashMap&lt;T, u64&gt;,
}

impl&lt;T: Eq + Hash&gt; Counter&lt;T&gt; {
    /// Create a new Counter.
    fn new() -&gt; Self {
        Counter { values: HashMap::new() }
    }

    /// Count an occurrence of the given value.
    fn count(&amp;mut self, value: T) {
        *self.values.entry(value).or_default() += 1;
    }

    /// Return the number of times the given value has been seen.
    fn times_seen(&amp;self, value: T) -&gt; u64 {
        self.values.get(&amp;value).copied().unwrap_or_default()
    }
}

fn main() {
    let mut ctr = Counter::new();
    ctr.count(13);
    ctr.count(14);
    ctr.count(16);
    ctr.count(14);
    ctr.count(14);
    ctr.count(11);

    for i in 10..20 {
        println!(&quot;saw {} values equal to {}&quot;, ctr.times_seen(i), i);
    }

    let mut strctr = Counter::new();
    strctr.count(&quot;apple&quot;);
    strctr.count(&quot;orange&quot;);
    strctr.count(&quot;apple&quot;);
    println!(&quot;got {} apples&quot;, strctr.times_seen(&quot;apple&quot;));
}
</code></pre></pre>
<h1><a class="header" href="#æ ‡å‡†åº“ç‰¹å¾" id="æ ‡å‡†åº“ç‰¹å¾">æ ‡å‡†åº“ç‰¹å¾</a></h1>
<p>{{%segment outline}}</p>
<details>
<p>ä¸æ ‡å‡†åº“ç±»å‹ä¸€æ ·ï¼Œè¯·èŠ±äº›æ—¶é—´ä»”ç»†é˜…è¯»æ¯ä¸ª trait çš„æ–‡æ¡£ã€‚</p>
<p>æ­¤éƒ¨åˆ†å†…å®¹è¾ƒé•¿ã€‚ä¸­é€”å¯ä¼‘æ¯ä¸€ä¸‹ã€‚</p>
</details>
<h1><a class="header" href="#æ¯”è¾ƒ" id="æ¯”è¾ƒ">æ¯”è¾ƒ</a></h1>
<p>è¿™äº› trait æ”¯æŒåœ¨å€¼ä¹‹é—´è¿›è¡Œæ¯”è¾ƒã€‚å¯¹äºåŒ…å«å®ç°è¿™äº› trait çš„å­—æ®µï¼Œå¯ä»¥æ´¾ç”Ÿæ‰€æœ‰è¿™äº› traitã€‚</p>
<h2><a class="header" href="#partialeq-and-eq" id="partialeq-and-eq"><code>PartialEq</code> and <code>Eq</code></a></h2>
<p><code>PartialEq</code> æŒ‡éƒ¨åˆ†ç­‰ä»·å…³ç³»ï¼Œå…¶ä¸­åŒ…å«å¿…éœ€çš„æ–¹æ³• <code>eq</code> å’Œæä¾›çš„æ–¹æ³• <code>ne</code>ã€‚<code>==</code> å’Œ <code>!=</code> è¿ç®—ç¬¦ä¼šè°ƒç”¨è¿™äº›æ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq for Key {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.id == other.id
    }
}
</code></pre></pre>
<p><code>Eq</code> is a full equivalence relation (reflexive, symmetric, and transitive) and implies <code>PartialEq</code>. Functions that require full equivalence will use <code>Eq</code> as a trait bound.</p>
<h2><a class="header" href="#partialord-and-ord" id="partialord-and-ord"><code>PartialOrd</code> and <code>Ord</code></a></h2>
<p><code>PartialOrd</code> å®šä¹‰äº†ä½¿ç”¨ <code>partial_cmp</code> æ–¹æ³•çš„éƒ¨åˆ†æ’åºã€‚å®ƒç”¨äºå®ç° <code>&lt;</code>ã€<code>&lt;=</code>ã€<code>&gt;=</code> å’Œ <code>&gt;</code> è¿ç®—ç¬¦ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;
#[derive(Eq, PartialEq)]
struct Citation {
    author: String,
    year: u32,
}
impl PartialOrd for Citation {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        match self.author.partial_cmp(&amp;other.author) {
            Some(Ordering::Equal) =&gt; self.year.partial_cmp(&amp;other.year),
            author_ord =&gt; author_ord,
        }
    }
}
</code></pre></pre>
<p><code>Ord</code> æ˜¯æ€»æ’åºï¼Œå…¶ä¸­ <code>cmp</code> è¿”å› <code>Ordering</code>ã€‚</p>
<details>
<p><code>PartialEq</code> å¯ä»¥åœ¨ä¸åŒç±»å‹ä¹‹é—´å®ç°ï¼Œä½† <code>Eq</code> ä¸èƒ½ï¼Œå› ä¸ºå®ƒå…·æœ‰è‡ªåæ€§ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Key {
    id: u32,
    metadata: Option&lt;String&gt;,
}
impl PartialEq&lt;u32&gt; for Key {
    fn eq(&amp;self, other: &amp;u32) -&gt; bool {
        self.id == *other
    }
}
</code></pre></pre>
<p>åœ¨å®è·µä¸­ï¼Œæ´¾ç”Ÿè¿™äº› trait å¾ˆå¸¸è§ï¼Œä½†å¾ˆå°‘ä¼šå®ç°å®ƒä»¬ã€‚</p>
</details><h1><a class="header" href="#è¿ç®—ç¬¦" id="è¿ç®—ç¬¦">è¿ç®—ç¬¦</a></h1>
<p>è¿ç®—ç¬¦é‡è½½æ˜¯é€šè¿‡ <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> ä¸­çš„ç‰¹å¾å®ç°çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Copy, Clone)]
struct Point {
    x: i32,
    y: i32,
}

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&gt; Self {
        Self { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 10, y: 20 };
    let p2 = Point { x: 100, y: 200 };
    println!(&quot;{p1:?} + {p2:?} = {:?}&quot;, p1 + p2);
}
</code></pre></pre>
<details>
<p>è®¨è®ºç‚¹ï¼š</p>
<ul>
<li>You could implement <code>Add</code> for <code>&amp;Point</code>. In which situations is that useful?
<ul>
<li>å›ç­”ï¼š<code>Add:add</code> ä¼šè€—ç”¨ <code>self</code>ã€‚å¦‚æœæ‚¨çš„è¿ç®—ç¬¦é‡è½½å¯¹è±¡ ï¼ˆå³ç±»å‹ <code>T</code>ï¼‰ä¸æ˜¯ <code>Copy</code>ï¼Œå»ºè®®æ‚¨ä¹Ÿä¸º <code>&amp;T</code> é‡è½½è¿ç®—ç¬¦ã€‚è¿™å¯é¿å…è°ƒç”¨ç‚¹ä¸Šå­˜åœ¨ä¸å¿…è¦çš„ å…‹éš†ä»»åŠ¡ã€‚</li>
</ul>
</li>
<li>ä¸ºä»€ä¹ˆ <code>Output</code> æ˜¯å…³è”ç±»å‹ï¼Ÿå¯å°†å®ƒç”¨ä½œè¯¥æ–¹æ³•çš„ç±»å‹å½¢å‚å—ï¼Ÿ
<ul>
<li>Short answer: Function type parameters are controlled by the caller, but associated types (like <code>Output</code>) are controlled by the implementer of a trait.</li>
</ul>
</li>
<li>æ‚¨å¯ä»¥é’ˆå¯¹ä¸¤ç§ä¸åŒç±»å‹å®ç° <code>Add</code>ï¼Œä¾‹å¦‚ï¼Œ <code>impl Add&lt;(i32, i32)&gt; for Point</code> ä¼šå‘ <code>Point</code> ä¸­æ·»åŠ å…ƒç»„ã€‚</li>
</ul>
<p>The <code>Not</code> trait (<code>!</code> operator) is notable because it does not &quot;boolify&quot; like the same operator in C-family languages; instead, for integer types it negates each bit of the number, which arithmetically is equivalent to subtracting it from -1: <code>!5 == -6</code>.</p>
</details>
<h1><a class="header" href="#from-å’Œ-into" id="from-å’Œ-into"><code>From</code> å’Œ <code>Into</code></a></h1>
<p>Types implement <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> to facilitate type conversions. Unlike <code>as</code>, these traits correspond to lossless, infallible conversions.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s = String::from(&quot;hello&quot;);
    let addr = std::net::Ipv4Addr::from([127, 0, 0, 1]);
    let one = i16::from(true);
    let bigger = i32::from(123_i16);
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<p>å®ç° <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> åï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å®ç° <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s: String = &quot;hello&quot;.into();
    let addr: std::net::Ipv4Addr = [127, 0, 0, 1].into();
    let one: i16 = true.into();
    let bigger: i32 = 123_i16.into();
    println!(&quot;{s}, {addr}, {one}, {bigger}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé€šå¸¸åªéœ€å®ç° <code>From</code>ï¼Œå› ä¸ºæ‚¨çš„ç±»å‹ä¹Ÿä¼šå®ç° <code>Into</code>ã€‚</li>
<li>è‹¥è¦å£°æ˜æŸä¸ªå‡½æ•°å®å‚è¾“å…¥ç±»å‹ï¼ˆä¾‹å¦‚â€œä»»ä½•å¯è½¬æ¢æˆ <code>String</code> çš„ç±»å‹â€ï¼‰ï¼Œè§„åˆ™ä¾¿ä¼šç›¸åï¼Œæ­¤æ—¶åº”ä½¿ç”¨ <code>Into</code>ã€‚ æ‚¨çš„å‡½æ•°ä¼šæ¥å—å¯å®ç° <code>From</code> çš„ç±»å‹ï¼Œä»¥åŠé‚£äº›ä»…å®ç° <code>Into</code> çš„ç±»å‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ç±»å‹è½¬æ¢" id="ç±»å‹è½¬æ¢">ç±»å‹è½¬æ¢</a></h1>
<p>Rust æ²¡æœ‰éšå¼ç±»å‹è½¬æ¢ï¼Œä½†æ”¯æŒä½¿ç”¨ <code>as</code> è¿›è¡Œæ˜¾å¼è½¬æ¢ã€‚è½¬æ¢å†™æ³•é€šå¸¸å’Œ C è¯­è¨€çš„å†™æ³•ç›¸ä¸€è‡´ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let value: i64 = 1000;
    println!(&quot;as u16: {}&quot;, value as u16);
    println!(&quot;as i16: {}&quot;, value as i16);
    println!(&quot;as u8: {}&quot;, value as u8);
}
</code></pre></pre>
<p>ä½¿ç”¨ <code>as</code> çš„ç»“æœåœ¨ Rust ä¸­ <em>å§‹ç»ˆ</em> å®šä¹‰æ˜ç¡®ï¼Œå¹¶ä¸”åœ¨ä¸åŒå¹³å°ä¸Šä¿æŒä¸€è‡´ã€‚è¿™å¯èƒ½å’Œæ‚¨å¯¹äºæ›´æ”¹ç¬¦å·æˆ–è½¬æ¢ä¸ºæ›´å°ç±»å‹çš„ç›´è§‚ç†è§£ä¸ä¸€æ ·ã€‚ä¸ºæ¸…æ™°èµ·è§ï¼Œè¯·æŸ¥çœ‹æ–‡æ¡£å’Œæ³¨é‡Šã€‚</p>
<p>ä½¿ç”¨ <code>as</code> è¿›è¡Œç±»å‹è½¬æ¢æ˜¯ä¸€ç§å¿«æ·å¥½ç”¨ä½†å®¹æ˜“å‡ºé”™çš„æ–¹æ³•ï¼Œä¹Ÿåœ¨æœªæ¥è¿›è¡Œä»£ç æ›´æ–°æ—¶ï¼Œæ¯”å¦‚æ”¹å˜äº†ç±»å‹æˆ–ç±»å‹èŒƒå›´æ—¶ä¼šå¯¼è‡´æ½œä¼çš„ Bugã€‚ ç±»å‹è½¬æ¢æœ€å¥½æ˜¯ç”¨äºæ˜ç¡®æ˜¯è¦è¿›è¡Œæ— æ¡ä»¶æˆªå–ï¼ˆæ¯”å¦‚æˆªå–ä½ä½çš„ <code>u64</code> ä¸º <code>u32</code>ï¼Œå¿½ç•¥é«˜ä½çš„æ•°å€¼ï¼‰ã€‚</p>
<p>å¯¹äºç»å¯¹ä¸ä¼šå‡ºé”™çš„è½¬æ¢ï¼ˆæ¯”å¦‚ <code>u32</code> è½¬ <code>u64</code>ï¼‰ï¼Œç›¸æ¯” <code>as</code>ï¼Œæ›´æ¨èç”¨ <code>From</code> æˆ– <code>Into</code> ä»¥è‚¯å®šè¯¥è½¬æ¢æ˜¯ä¸ä¼šå‡ºé”™çš„ã€‚å¯¹äºå¯èƒ½å‡ºé”™çš„è½¬æ¢ï¼Œå¦‚æœä½ æƒ³å¯¹è¿™äº›ä¸èƒ½æˆåŠŸè½¬æ¢çš„æƒ…å†µæœ‰ä¸åŒå¤„ç†æ–¹æ¡ˆæ—¶ï¼Œå¯ä»¥è€ƒè™‘ <code>TryFrom</code> å’Œ <code>TryInto</code>ã€‚</p>
<details>
<p>è¯·åœ¨è¿™å¼ å¹»ç¯ç‰‡ä¹‹åä¼‘æ¯ä¸€ä¸‹ã€‚</p>
<p><code>as</code> ç±»ä¼¼äº C++ é™æ€ç±»å‹è½¬æ¢ã€‚é€šå¸¸ä¸å»ºè®®åœ¨å¯èƒ½ä¸¢å¤±æ•°æ®çš„æƒ…å†µä¸‹ä½¿ç”¨ <code>as</code>ï¼Œæˆ–è€…è‡³å°‘åº”è¯¥æ·»åŠ è¯´æ˜æ€§æ³¨é‡Šã€‚</p>
<p>ä¼šç»å¸¸é‡åˆ°çš„æ˜¯ï¼Œå°†æ•´æ•°ç±»å‹è½¬æ¢ä¸º <code>usize</code> ä»¥ç”¨ä½œç´¢å¼•ã€‚</p>
</details><h1><a class="header" href="#read-å’Œ-write" id="read-å’Œ-write"><code>Read</code> å’Œ <code>Write</code></a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> å’Œ <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> å¯¹ <code>u8</code> æ¥æºè¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{BufRead, BufReader, Read, Result};

fn count_lines&lt;R: Read&gt;(reader: R) -&gt; usize {
    let buf_reader = BufReader::new(reader);
    buf_reader.lines().count()
}

fn main() -&gt; Result&lt;()&gt; {
    let slice: &amp;[u8] = b&quot;foo\nbar\nbaz\n&quot;;
    println!(&quot;lines in slice: {}&quot;, count_lines(slice));

    let file = std::fs::File::open(std::env::current_exe()?)?;
    println!(&quot;lines in file: {}&quot;, count_lines(file));
    Ok(())
}
</code></pre></pre>
<p>æ‚¨åŒæ ·å¯ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> å¯¹ <code>u8</code> æ¥æ”¶å™¨è¿›è¡ŒæŠ½è±¡åŒ–å¤„ç†ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::{Result, Write};

fn log&lt;W: Write&gt;(writer: &amp;mut W, msg: &amp;str) -&gt; Result&lt;()&gt; {
    writer.write_all(msg.as_bytes())?;
    writer.write_all(&quot;\n&quot;.as_bytes())
}

fn main() -&gt; Result&lt;()&gt; {
    let mut buffer = Vec::new();
    log(&amp;mut buffer, &quot;Hello&quot;)?;
    log(&amp;mut buffer, &quot;World&quot;)?;
    println!(&quot;Logged: {buffer:?}&quot;);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#default-ç‰¹å¾" id="default-ç‰¹å¾"><code>Default</code> ç‰¹å¾</a></h1>
<p><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> ç‰¹å¾ä¼šä¸ºç±»å‹ç”Ÿæˆé»˜è®¤å€¼ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, Default)]
struct Derived {
    x: u32,
    y: String,
    z: Implemented,
}

#[derive(Debug)]
struct Implemented(String);

impl Default for Implemented {
    fn default() -&gt; Self {
        Self(&quot;John Smith&quot;.into())
    }
}

fn main() {
    let default_struct = Derived::default();
    println!(&quot;{default_struct:#?}&quot;);

    let almost_default_struct =
        Derived { y: &quot;Y is set!&quot;.into(), ..Derived::default() };
    println!(&quot;{almost_default_struct:#?}&quot;);

    let nothing: Option&lt;Derived&gt; = None;
    println!(&quot;{:#?}&quot;, nothing.unwrap_or_default());
}
</code></pre></pre>
<details>
<ul>
<li>ç³»ç»Ÿå¯ä»¥ç›´æ¥å®ç°å®ƒï¼Œä¹Ÿå¯ä»¥é€šè¿‡ <code>#[derive(Default)]</code> æ´¾ç”Ÿå‡ºå®ƒã€‚</li>
<li>A derived implementation will produce a value where all fields are set to their default values.
<ul>
<li>è¿™æ„å‘³ç€ï¼Œè¯¥ç»“æ„ä½“ä¸­çš„æ‰€æœ‰ç±»å‹ä¹Ÿéƒ½å¿…é¡»å®ç° <code>Default</code>ã€‚</li>
</ul>
</li>
<li>æ ‡å‡†çš„ Rust ç±»å‹é€šå¸¸ä¼šä»¥åˆç†çš„å€¼ï¼ˆä¾‹å¦‚ <code> 0</code>&quot;&quot; `<code>ç­‰ï¼‰å®ç°</code>Default`ã€‚</li>
<li>The partial struct initialization works nicely with default.</li>
<li>The Rust standard library is aware that types can implement <code>Default</code> and provides convenience methods that use it.</li>
<li>The <code>..</code> syntax is called <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">struct update syntax</a>.</li>
</ul>
</details>
<h1><a class="header" href="#é—­åŒ…" id="é—­åŒ…">é—­åŒ…</a></h1>
<p>é—­åŒ…æˆ– lambda è¡¨è¾¾å¼å…·æœ‰æ— æ³•å‘½åçš„ç±»å‹ã€‚ä¸è¿‡ï¼Œå®ƒä»¬ä¼š å®ç°ç‰¹æ®Šçš„ <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>ï¼Œ <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a> å’Œ <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> ç‰¹å¾ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn apply_and_log(func: impl FnOnce(i32) -&gt; i32, func_name: &amp;str, input: i32) {
    println!(&quot;Calling {func_name}({input}): {}&quot;, func(input))
}

fn main() {
    let n = 3;
    let add_3 = |x| x + n;
    apply_and_log(&amp;add_3, &quot;add_3&quot;, 10);
    apply_and_log(&amp;add_3, &quot;add_3&quot;, 20);

    let mut v = Vec::new();
    let mut accumulate = |x: i32| {
        v.push(x);
        v.iter().sum::&lt;i32&gt;()
    };
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, 4);
    apply_and_log(&amp;mut accumulate, &quot;accumulate&quot;, 5);

    let multiply_sum = |x| x * v.into_iter().sum::&lt;i32&gt;();
    apply_and_log(multiply_sum, &quot;multiply_sum&quot;, 3);
}
</code></pre></pre>
<details>
<p>An <code>Fn</code> (e.g. <code>add_3</code>) neither consumes nor mutates captured values. It can be called needing only a shared reference to the closure, which means the closure can be executed repeatedly and even concurrently.</p>
<p>An <code>FnMut</code> (e.g. <code>accumulate</code>) might mutate captured values. The closure object is accessed via exclusive reference, so it can be called repeatedly but not concurrently.</p>
<p>If you have an <code>FnOnce</code> (e.g. <code>multiply_sum</code>), you may only call it once. Doing so consumes the closure and any values captured by move.</p>
<p><code>FnMut</code> æ˜¯ <code>FnOnce</code> çš„å­ç±»å‹ã€‚<code>Fn</code> æ˜¯ <code>FnMut</code> å’Œ <code>FnOnce</code> çš„å­ç±»å‹ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‚¨å¯ä»¥åœ¨ä»»ä½• éœ€è¦è°ƒç”¨ <code>FnOnce</code> çš„åœ°æ–¹ä½¿ç”¨ <code>FnMut</code>ï¼Œè¿˜å¯åœ¨ä»»ä½•éœ€è¦è°ƒç”¨ <code>FnMut</code> æˆ– <code>FnOnce</code> çš„åœ°æ–¹ ä½¿ç”¨ <code>Fn</code>ã€‚</p>
<p>When you define a function that takes a closure, you should take <code>FnOnce</code> if you can (i.e. you call it once), or <code>FnMut</code> else, and last <code>Fn</code>. This allows the most flexibility for the caller.</p>
<p>In contrast, when you have a closure, the most flexible you can have is <code>Fn</code> (which can be passed to a consumer of any of the 3 closure traits), then <code>FnMut</code>, and lastly <code>FnOnce</code>.</p>
<p>The compiler also infers <code>Copy</code> (e.g. for <code>add_3</code>) and <code>Clone</code> (e.g. <code>multiply_sum</code>), depending on what the closure captures. Function pointers (references to <code>fn</code> items) implement <code>Copy</code> and <code>Fn</code>.</p>
<p>By default, closures will capture each variable from an outer scope by the least demanding form of access they can (by shared reference if possible, then exclusive reference, then by move). The <code>move</code> keyword forces capture by value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn make_greeter(prefix: String) -&gt; impl Fn(&amp;str) {
    return move |name| println!(&quot;{} {}&quot;, prefix, name);
}

fn main() {
    let hi = make_greeter(&quot;Hi&quot;.to_string());
    hi(&quot;Greg&quot;);
}
</code></pre></pre>
</details><h1><a class="header" href="#ç»ƒä¹ rot13" id="ç»ƒä¹ rot13">ç»ƒä¹ ï¼šROT13</a></h1>
<p>åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæ‚¨å°†å®ç°ç»å…¸çš„ <a href="https://en.wikipedia.org/wiki/ROT13">â€œROT13â€åŠ å¯†</a>ã€‚å°†æ­¤ä»£ç å¤åˆ¶åˆ° Playgroundï¼Œå¹¶å®ç°ç¼ºå¤±çš„ä½ã€‚è¯·ä»…æ—‹è½¬ ASCII å­—æ¯å­—ç¬¦ï¼Œä»¥ç¡®ä¿ç»“æœä»ä¸ºæœ‰æ•ˆçš„ UTF-8 ç¼–ç å­—ç¬¦ã€‚</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

// Implement the `Read` trait for `RotDecoder`.

fn main() {
    let mut rot =
        RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!(&quot;{}&quot;, result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, &quot;To get to the other side!&quot;);
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}
</code></pre></pre>
<p>å¦‚æœå°†ä¸¤ä¸ª <code>RotDecoder</code> å®ä¾‹é“¾æ¥åœ¨ä¸€èµ·ï¼Œæ¯ä¸ªå®ä¾‹æ—‹è½¬ 13 ä¸ªå­—ç¬¦ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Ÿ</p>
<h1><a class="header" href="#è§£ç­”-9" id="è§£ç­”-9">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::io::Read;

struct RotDecoder&lt;R: Read&gt; {
    input: R,
    rot: u8,
}

impl&lt;R: Read&gt; Read for RotDecoder&lt;R&gt; {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
        let size = self.input.read(buf)?;
        for b in &amp;mut buf[..size] {
            if b.is_ascii_alphabetic() {
                let base = if b.is_ascii_uppercase() { 'A' } else { 'a' } as u8;
                *b = (*b - base + self.rot) % 26 + base;
            }
        }
        Ok(size)
    }
}

fn main() {
    let mut rot =
        RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
    let mut result = String::new();
    rot.read_to_string(&amp;mut result).unwrap();
    println!(&quot;{}&quot;, result);
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn joke() {
        let mut rot =
            RotDecoder { input: &quot;Gb trg gb gur bgure fvqr!&quot;.as_bytes(), rot: 13 };
        let mut result = String::new();
        rot.read_to_string(&amp;mut result).unwrap();
        assert_eq!(&amp;result, &quot;To get to the other side!&quot;);
    }

    #[test]
    fn binary() {
        let input: Vec&lt;u8&gt; = (0..=255u8).collect();
        let mut rot = RotDecoder::&lt;&amp;[u8]&gt; { input: input.as_ref(), rot: 13 };
        let mut buf = [0u8; 256];
        assert_eq!(rot.read(&amp;mut buf).unwrap(), 256);
        for i in 0..=255 {
            if input[i] != buf[i] {
                assert!(input[i].is_ascii_alphabetic());
                assert!(buf[i].is_ascii_alphabetic());
            }
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿å‚åŠ ç¬¬-3-å¤©çš„è¯¾ç¨‹" id="æ¬¢è¿å‚åŠ ç¬¬-3-å¤©çš„è¯¾ç¨‹">æ¬¢è¿å‚åŠ ç¬¬ 3 å¤©çš„è¯¾ç¨‹</a></h1>
<p>ä»Šæ—¥å†…å®¹ï¼š</p>
<ul>
<li>å†…å­˜ç®¡ç†ã€ç”Ÿå‘½å‘¨æœŸå’Œå€Ÿç”¨æ£€æŸ¥å™¨ï¼šRust å¦‚ä½•ç¡®ä¿å†…å­˜å®‰å…¨ã€‚</li>
<li>æ™ºèƒ½æŒ‡é’ˆï¼šæ ‡å‡†åº“æŒ‡é’ˆç±»å‹ã€‚</li>
</ul>
<h2><a class="header" href="#æ—¶é—´è¡¨-2" id="æ—¶é—´è¡¨-2">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#å†…å­˜ç®¡ç†" id="å†…å­˜ç®¡ç†">å†…å­˜ç®¡ç†</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å›é¡¾ç¨‹åºçš„å†…å­˜åˆ†é…" id="å›é¡¾ç¨‹åºçš„å†…å­˜åˆ†é…">å›é¡¾ï¼šç¨‹åºçš„å†…å­˜åˆ†é…</a></h1>
<p>ç¨‹åºé€šè¿‡ä»¥ä¸‹ä¸¤ç§æ–¹å¼åˆ†é…å†…å­˜ï¼š</p>
<ul>
<li>
<p>æ ˆï¼šå±€éƒ¨å˜é‡çš„è¿ç»­å†…å­˜åŒºåŸŸã€‚</p>
<ul>
<li>å€¼åœ¨ç¼–è¯‘æ—¶å…·æœ‰å·²çŸ¥çš„å›ºå®šå¤§å°ã€‚</li>
<li>é€Ÿåº¦æå¿«ï¼šåªéœ€ç§»åŠ¨ä¸€ä¸ªæ ˆæŒ‡é’ˆã€‚</li>
<li>æ˜“äºç®¡ç†ï¼šéµå¾ªå‡½æ•°è°ƒç”¨è§„åˆ™ã€‚</li>
<li>ä¼˜ç§€çš„å†…å­˜å±€éƒ¨æ€§ã€‚</li>
</ul>
</li>
<li>
<p>å †ï¼šå‡½æ•°è°ƒç”¨ä¹‹å¤–çš„å€¼çš„å­˜å‚¨ã€‚</p>
<ul>
<li>å€¼å…·æœ‰åŠ¨æ€å¤§å°ï¼Œå…·ä½“å¤§å°éœ€åœ¨è¿è¡Œæ—¶ç¡®å®šã€‚</li>
<li>æ¯”æ ˆç¨æ…¢ï¼šéœ€è¦å‘ç³»ç»Ÿç”³è¯·ç©ºé—´ã€‚</li>
<li>ä¸ä¿è¯å†…å­˜å±€éƒ¨æ€§ã€‚</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#ç¤ºä¾‹" id="ç¤ºä¾‹">ç¤ºä¾‹</a></h2>
<p>Creating a <code>String</code> puts fixed-sized metadata on the stack and dynamically sized data, the actual string, on the heap:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
}
</code></pre></pre>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="544" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="544" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><text x="282" y="28" >Heap</text><line x1="296" y1="40" x2="304" y2="40" class="solid"></line><line x1="312" y1="40" x2="320" y2="40" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >capacity</text><text x="178" y="92" >5</text><text x="50" y="108" >ptr</text><circle cx="180" cy="104" r="3" class="nofill"></circle><text x="322" y="108" >H</text><text x="362" y="108" >e</text><text x="402" y="108" >l</text><text x="442" y="108" >l</text><text x="482" y="108" >o</text><text x="50" y="124" >len</text><text x="178" y="124" >5</text><line x1="328" y1="40" x2="336" y2="40" class="solid"></line><line x1="344" y1="40" x2="352" y2="40" class="solid"></line><line x1="360" y1="40" x2="368" y2="40" class="solid"></line><line x1="376" y1="40" x2="384" y2="40" class="solid"></line><line x1="392" y1="40" x2="400" y2="40" class="solid"></line><line x1="408" y1="40" x2="416" y2="40" class="solid"></line><line x1="424" y1="40" x2="432" y2="40" class="solid"></line><line x1="440" y1="40" x2="448" y2="40" class="solid"></line><line x1="456" y1="40" x2="464" y2="40" class="solid"></line><line x1="472" y1="40" x2="480" y2="40" class="solid"></line><line x1="488" y1="40" x2="496" y2="40" class="solid"></line><line x1="504" y1="40" x2="512" y2="40" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><line x1="296" y1="168" x2="304" y2="168" class="solid"></line><line x1="312" y1="168" x2="320" y2="168" class="solid"></line><line x1="328" y1="168" x2="336" y2="168" class="solid"></line><line x1="344" y1="168" x2="352" y2="168" class="solid"></line><line x1="360" y1="168" x2="368" y2="168" class="solid"></line><line x1="376" y1="168" x2="384" y2="168" class="solid"></line><line x1="392" y1="168" x2="400" y2="168" class="solid"></line><line x1="408" y1="168" x2="416" y2="168" class="solid"></line><line x1="424" y1="168" x2="432" y2="168" class="solid"></line><line x1="440" y1="168" x2="448" y2="168" class="solid"></line><line x1="456" y1="168" x2="464" y2="168" class="solid"></line><line x1="472" y1="168" x2="480" y2="168" class="solid"></line><line x1="488" y1="168" x2="496" y2="168" class="solid"></line><line x1="504" y1="168" x2="512" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,40 A 4,4 0,0,0 276,44" class="nofill"></path><line x1="276" y1="44" x2="276" y2="164" class="broken"></line><line x1="280" y1="40" x2="288" y2="40" class="solid"></line><path d="M 276,164 A 4,4 0,0,0 280,168" class="nofill"></path><line x1="280" y1="168" x2="288" y2="168" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="88" x2="508" y2="88" class="solid"></line><line x1="308" y1="88" x2="308" y2="120" class="solid"></line><line x1="348" y1="88" x2="348" y2="120" class="solid"></line><line x1="388" y1="88" x2="388" y2="120" class="solid"></line><line x1="428" y1="88" x2="428" y2="120" class="solid"></line><line x1="468" y1="88" x2="468" y2="120" class="solid"></line><line x1="508" y1="88" x2="508" y2="120" class="solid"></line><line x1="308" y1="120" x2="508" y2="120" class="solid"></line></g><g><line x1="184" y1="104" x2="296" y2="104" class="solid"></line><polygon points="296,100 304,104 296,108" class="filled"></polygon></g><g><line x1="520" y1="40" x2="528" y2="40" class="solid"></line><path d="M 528,40 A 4,4 0,0,1 532,44" class="nofill"></path><line x1="532" y1="44" x2="532" y2="164" class="broken"></line><line x1="520" y1="168" x2="528" y2="168" class="solid"></line><path d="M 532,164 A 4,4 0,0,1 528,168" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p>æŒ‡å‡º <code>String</code> åº•å±‚ç”± <code>Vec</code> å®ç°ï¼Œå› æ­¤å®ƒå…·æœ‰å®¹é‡å’Œé•¿åº¦ï¼Œå¦‚æœå€¼å¯å˜ï¼Œåˆ™å¯ä»¥é€šè¿‡åœ¨å †ä¸Šé‡æ–°åˆ†é…å­˜å‚¨ç©ºé—´è¿›è¡Œå¢é•¿ã€‚</p>
</li>
<li>
<p>å¦‚æœå­¦å‘˜æå‡ºç›¸å…³é—®é¢˜ï¼Œä½ å¯ä»¥æåŠæˆ‘ä»¬ä¸ä»…èƒ½ä½¿ç”¨[ç³»ç»Ÿåˆ†é…å™¨]åœ¨å †ä¸Šåˆ†é…åº•å±‚å†…å­˜ï¼Œè¿˜èƒ½ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/alloc/index.html">Allocator API</a> å®ç°è‡ªå®šä¹‰åˆ†é…å™¨</p>
</li>
</ul>
<h2><a class="header" href="#æ¢ç´¢æ›´å¤š-2" id="æ¢ç´¢æ›´å¤š-2">æ¢ç´¢æ›´å¤š</a></h2>
<p>We can inspect the memory layout with <code>unsafe</code> Rust. However, you should point out that this is rightfully unsafe!</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s1 = String::from(&quot;Hello&quot;);
    s1.push(' ');
    s1.push_str(&quot;world&quot;);
    // DON'T DO THIS AT HOME! For educational purposes only.
    // String provides no guarantees about its layout, so this could lead to
    // undefined behavior.
    unsafe {
        let (capacity, ptr, len): (usize, usize, usize) = std::mem::transmute(s1);
        println!(&quot;capacity = {capacity}, ptr = {ptr:#x}, len = {len}&quot;);
    }
}
</code></pre></pre>
</details>
<h1><a class="header" href="#å†…å­˜ç®¡ç†æ–¹æ³•" id="å†…å­˜ç®¡ç†æ–¹æ³•">å†…å­˜ç®¡ç†æ–¹æ³•</a></h1>
<p>ä¼ ç»Ÿä¸Šï¼Œè¯­è¨€åˆ†ä¸ºä¸¤å¤§ç±»ï¼š</p>
<ul>
<li>é€šè¿‡æ‰‹åŠ¨å†…å­˜ç®¡ç†å®ç°å®Œå…¨æ§åˆ¶ï¼šCã€C++ã€Pascalâ€¦
<ul>
<li>ç¨‹åºå‘˜å†³å®šä½•æ—¶åˆ†é…æˆ–é‡Šæ”¾å †å†…å­˜ã€‚</li>
<li>ç¨‹åºå‘˜å¿…é¡»ç¡®å®šæŒ‡é’ˆæ˜¯å¦ä»æŒ‡å‘æœ‰æ•ˆå†…å­˜ã€‚</li>
<li>ç ”ç©¶è¡¨æ˜ï¼Œç¨‹åºå‘˜éš¾å…ä¼šçŠ¯é”™ã€‚</li>
</ul>
</li>
<li>è¿è¡Œæ—¶é€šè¿‡è‡ªåŠ¨å†…å­˜ç®¡ç†å®ç°å®Œå…¨å®‰å…¨ï¼šJavaã€Pythonã€Goã€Haskellâ€¦
<ul>
<li>è¿è¡Œæ—¶ç³»ç»Ÿå¯ç¡®ä¿åœ¨å†…å­˜æ— æ³•è¢«å¼•ç”¨ä¹‹å‰ï¼Œä¸ä¼šé‡Šæ”¾è¯¥å†…å­˜ã€‚</li>
<li>Typically implemented with reference counting or garbage collection.</li>
</ul>
</li>
</ul>
<p>Rust æä¾›äº†ä¸€ä¸ªå…¨æ–°çš„ç»„åˆï¼š</p>
<blockquote>
<p>é€šè¿‡ç¼–è¯‘æ—¶å¼ºåˆ¶æ‰§è¡Œæ­£ç¡®çš„å†…å­˜&gt;ç®¡ç†æ¥å®ç°å®Œå…¨æ§åˆ¶ä¸å®‰å…¨ã€‚</p>
</blockquote>
<p>å®ƒé€šè¿‡ä¸€ä¸ªæ˜ç¡®çš„æ‰€æœ‰æƒï¼ˆownershipï¼‰æ¦‚å¿µæ¥å®ç°æ­¤ç›®çš„ã€‚</p>
<details>
<p>æœ¬å¹»ç¯ç‰‡æ—¨åœ¨å¸®åŠ©å­¦ä¹ å…¶ä»–è¯­è¨€çš„å­¦ç”Ÿæ›´å¥½åœ°äº†è§£ Rustã€‚</p>
<ul>
<li>
<p>C è¯­è¨€å¿…é¡»ä½¿ç”¨ <code>malloc</code> å’Œ <code>free</code> å‡½æ•°æ‰‹åŠ¨ç®¡ç†å †ã€‚å¸¸è§é”™è¯¯åŒ…æ‹¬å¿˜è®°è°ƒç”¨ <code>free</code>ã€é’ˆå¯¹åŒä¸€æŒ‡é’ˆå¤šæ¬¡è°ƒç”¨å®ƒï¼Œæˆ–åœ¨é‡Šæ”¾æŸæŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜åè§£å¼•ç”¨å®ƒã€‚</p>
</li>
<li>
<p>C++ å…·æœ‰æ™ºèƒ½æŒ‡é’ˆï¼ˆ<code>unique_ptr</code>ã€<code>shared_ptr</code>ï¼‰ç­‰å·¥å…·ï¼Œå¯ä»¥åˆ©ç”¨ä¸è°ƒç”¨ææ„å‡½æ•°ç›¸å…³çš„è¯­è¨€ä¿è¯æ¥ç¡®ä¿åœ¨å‡½æ•°è¿”å›æ—¶é‡Šæ”¾å†…å­˜ã€‚è¿™äº›å·¥å…·ä»ç„¶å¾ˆå®¹æ˜“è¢«æ»¥ç”¨å¹¶å¯¼è‡´ä¸ C è¯­è¨€ç±»ä¼¼çš„ bugã€‚</p>
</li>
<li>
<p>Javaã€Go å’Œ Python ä¾èµ–åƒåœ¾å›æ”¶å™¨æ¥è¯†åˆ«æ— æ³•å†è®¿é—®çš„å†…å­˜å¹¶å°†å…¶èˆå¼ƒã€‚è¿™ä¿è¯å¯å¯¹æ‰€æœ‰æŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨æ“ä½œï¼Œä»è€Œæ¶ˆé™¤äº†é‡Šæ”¾åä½¿ç”¨ç­‰å„ç±» bugã€‚ä½†æ˜¯ï¼Œåƒåœ¾å›æ”¶ (GC) ä¼šäº§ç”Ÿè¿è¡Œæ—¶æˆæœ¬ï¼Œå¹¶ä¸”å¾ˆéš¾è¿›è¡Œé€‚å½“è°ƒä¼˜ã€‚</p>
</li>
</ul>
<p>åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼ŒRust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨æ¨¡å‹å¯ä»¥å®ç° C è¯­è¨€çš„æ€§èƒ½ï¼Œèƒ½å¤Ÿç²¾ç¡®åœ°åœ¨æ‰€éœ€ä½ç½®æ‰§è¡Œåˆ†é…å’Œé‡Šæ”¾æ“ä½œï¼Œä¸”ä¸ºé›¶æˆæœ¬ã€‚å®ƒè¿˜æä¾›ç±»ä¼¼äº C++ æ™ºèƒ½æŒ‡é’ˆçš„å·¥å…·ã€‚å¿…è¦æ—¶ï¼Œå®ƒè¿˜æä¾›å¼•ç”¨è®¡æ•°ç­‰å…¶ä»–é€‰é¡¹ï¼Œç”šè‡³è¿˜æœ‰ç¬¬ä¸‰æ–¹ crate å¯ä»¥æ”¯æŒè¿è¡Œæ—¶åƒåœ¾å›æ”¶ï¼ˆæœ¬è¯¾ç¨‹ä¸­ä¸ä½œä»‹ç»ï¼‰ã€‚</p>
</details><h1><a class="header" href="#æ‰€æœ‰æƒ" id="æ‰€æœ‰æƒ">æ‰€æœ‰æƒ</a></h1>
<p>æ‰€æœ‰å˜é‡ç»‘å®šéƒ½æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„â€œä½œç”¨åŸŸâ€ï¼Œä½¿ç”¨ è¶…å‡ºå…¶ä½œç”¨åŸŸçš„å˜é‡æ˜¯é”™è¯¯çš„ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">struct Point(i32, i32);

fn main() {
    {
        let p = Point(3, 4);
        println!(&quot;x: {}&quot;, p.0);
    }
    println!(&quot;y: {}&quot;, p.1);
}
</code></pre></pre>
<p>We say that the variable <em>owns</em> the value. Every Rust value has precisely one owner at all times.</p>
<p>At the end of the scope, the variable is <em>dropped</em> and the data is freed. A destructor can run here to free up resources.</p>
<details>
<p>ç†Ÿæ‚‰åƒåœ¾å›æ”¶å®ç°çš„å­¦ç”ŸçŸ¥é“ï¼Œåƒåœ¾å›æ”¶å™¨ä»ä¸€ç»„ â€œæ ¹â€å¼€å§‹æŸ¥æ‰¾æ‰€æœ‰å¯è®¿é—®å†…å­˜ã€‚Rust çš„ â€œå•ä¸€æ‰€æœ‰è€…â€åŸåˆ™ä¸æ­¤ç±»ä¼¼ã€‚</p>
</details><h1><a class="header" href="#ç§»åŠ¨è¯­ä¹‰" id="ç§»åŠ¨è¯­ä¹‰">ç§»åŠ¨è¯­ä¹‰</a></h1>
<p>An assignment will transfer <em>ownership</em> between variables:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1: String = String::from(&quot;Hello!&quot;);
    let s2: String = s1;
    println!(&quot;s2: {s2}&quot;);
    // println!(&quot;s1: {s1}&quot;);
}
</code></pre></pre>
<ul>
<li>å°† <code>s1</code> èµ‹å€¼ç»™ <code>s2</code>ï¼Œå³è½¬ç§»äº†æ‰€æœ‰æƒã€‚</li>
<li>When <code>s1</code> goes out of scope, nothing happens: it does not own anything.</li>
<li>å½“ <code>s2</code> ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå­—ç¬¦ä¸²æ•°æ®è¢«é‡Šæ”¾ã€‚</li>
</ul>
<p>ç§»åŠ¨åˆ° <code>s2</code> ä¸­ä¹‹å‰ï¼š</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="208"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>ç§»åŠ¨åˆ° <code>s2</code> ä¸­ä¹‹åï¼š</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="592" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="592" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >H</text><text x="362" y="92" >e</text><text x="402" y="92" >l</text><text x="442" y="92" >l</text><text x="482" y="92" >o</text><text x="522" y="92" >!</text><text x="50" y="108" >len</text><text x="178" y="108" >6</text><text x="50" y="124" >capacity</text><text x="178" y="124" >6</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="50" y="220" >len</text><text x="178" y="220" >6</text><text x="50" y="236" >capacity</text><text x="178" y="236" >6</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><line x1="472" y1="152" x2="480" y2="152" class="solid"></line><line x1="488" y1="152" x2="496" y2="152" class="solid"></line><line x1="504" y1="152" x2="512" y2="152" class="solid"></line><line x1="520" y1="152" x2="528" y2="152" class="solid"></line><line x1="536" y1="152" x2="544" y2="152" class="solid"></line><line x1="552" y1="152" x2="560" y2="152" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><text x="66" y="60" >(inaccessible)</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="548" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="468" y1="72" x2="468" y2="104" class="solid"></line><line x1="508" y1="72" x2="508" y2="104" class="solid"></line><line x1="548" y1="72" x2="548" y2="104" class="solid"></line><line x1="308" y1="104" x2="548" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><line x1="252" y1="88" x2="252" y2="196" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon><line x1="168" y1="200" x2="248" y2="200" class="solid"></line><path d="M 252,196 A 4,4 0,0,1 248,200" class="nofill"></path></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><path d="M 576,24 A 4,4 0,0,1 580,28" class="nofill"></path><line x1="580" y1="28" x2="580" y2="148" class="broken"></line><line x1="568" y1="152" x2="576" y2="152" class="solid"></line><path d="M 580,148 A 4,4 0,0,1 576,152" class="nofill"></path></g></svg></div>
<p>ä½ å°†å€¼ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œè¯¥å€¼ä¼šè¢«èµ‹ç»™å‡½æ•° å‚æ•°ã€‚è¿™å°±è½¬ç§»äº†æ‰€æœ‰æƒï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name);
    // say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>æŒ‡å‡ºè¿™ä¸ C++ ä¸­çš„é»˜è®¤å€¼ç›¸åã€‚é™¤éä½ ä½¿ç”¨ <code>std::move</code>ï¼ˆå¹¶å·²å®šä¹‰ move æ„é€ å‡½æ•°ï¼ï¼‰ï¼Œå¦åˆ™ C++ ä¸­çš„é»˜è®¤å€¼æ˜¯æŒ‰å€¼å¤åˆ¶çš„ã€‚</p>
</li>
<li>
<p>åªæœ‰æ‰€æœ‰æƒå‘ç”Ÿäº†è½¬ç§»ã€‚æ˜¯å¦ä¼šç”Ÿæˆä»»ä½•æœºå™¨ç æ¥æ“æ§æ•°æ®æœ¬èº«æ˜¯ä¸€ä¸ªä¼˜åŒ–æ–¹é¢çš„é—®é¢˜ï¼Œç³»ç»Ÿä¼šä¸»åŠ¨ä¼˜åŒ–æ­¤ç±»å‰¯æœ¬ã€‚</p>
</li>
<li>
<p>ç®€å•çš„å€¼ï¼ˆä¾‹å¦‚æ•´æ•°ï¼‰å¯ä»¥æ ‡è®°ä¸ºâ€œCopyâ€ï¼ˆè¯·çœ‹åç»­å¹»ç¯ç‰‡ï¼‰ã€‚</p>
</li>
<li>
<p>åœ¨ Rust ä¸­ï¼Œå…‹éš†æ˜¯æ˜¾å¼çš„ï¼ˆé€šè¿‡ä½¿ç”¨ <code>clone</code>ï¼‰ã€‚</p>
</li>
</ul>
<p>åœ¨ <code>say_hello</code> ç¤ºä¾‹ä¸­ï¼š</p>
<ul>
<li>é¦–æ¬¡è°ƒç”¨ <code>say_hello</code> æ—¶ï¼Œ<code>main</code> ä¾¿æ”¾å¼ƒäº† <code>name</code> çš„æ‰€æœ‰æƒã€‚æ­¤åï¼Œ<code>main</code> ä¸­ä¸èƒ½å†ä½¿ç”¨ <code>name</code>ã€‚</li>
<li>åœ¨ <code>say_hello</code> å‡½æ•°ç»“æŸæ—¶ï¼Œç³»ç»Ÿä¼šé‡Šæ”¾ä¸º <code>name</code> åˆ†é…çš„å †å†…å­˜ã€‚</li>
<li>å¦‚æœ <code>main</code> å°† <code>name</code> ä½œä¸ºå¼•ç”¨ (<code>&amp;name</code>) ä¼ é€’è¿‡å»ï¼Œä¸” <code>say_hello</code> æ¥å—ä½œä¸ºå‚æ•°çš„å¼•ç”¨ï¼Œåˆ™å¯ä¿ç•™æ‰€æœ‰æƒã€‚</li>
<li>æ­¤å¤–ï¼Œ<code>main</code> ä¹Ÿå¯ä»¥åœ¨é¦–æ¬¡è°ƒç”¨æ—¶ä¼ é€’ <code>name</code> çš„å…‹éš† (<code>name.clone()</code>)ã€‚</li>
<li>ç›¸è¾ƒäº C++ï¼ŒRust é€šè¿‡å°†ç§»åŠ¨è¯­ä¹‰è®¾ä¸ºé»˜è®¤å€¼ï¼Œå¹¶å¼ºåˆ¶ç¨‹åºå‘˜è¿›è¡Œæ˜¾å¼å…‹éš†ï¼Œæ›´éš¾ä»¥æ— æ„ä¸­åˆ›å»ºå‰¯æœ¬ã€‚</li>
</ul>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-3" id="æ¢ç´¢æ›´å¤š-3">æ¢ç´¢æ›´å¤š</a></h1>
<h2><a class="header" href="#defensive-copies-in-modern-c" id="defensive-copies-in-modern-c">Defensive Copies in Modern C++</a></h2>
<p>ç°ä»£ C++ ä»¥ä¸åŒçš„æ–¹å¼è§£å†³æ­¤é—®é¢˜ï¼š</p>
<pre><code class="language-c++">std::string s1 = &quot;Cpp&quot;;
std::string s2 = s1;  // Duplicate the data in s1.
</code></pre>
<ul>
<li><code>s1</code> ä¸­çš„å †æ•°æ®è¢«å¤åˆ¶ï¼Œ<code>s2</code> è·å¾—è‡ªå·±çš„ç‹¬ç«‹å‰¯æœ¬ã€‚</li>
<li>å½“ <code>s1</code> å’Œ <code>s2</code> ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒä»¬ä¼šå„è‡ªé‡Šæ”¾è‡ªå·±çš„å†…å­˜ã€‚</li>
</ul>
<p>å¤åˆ¶-èµ‹å€¼ä¹‹å‰ï¼š</p>
<div style='width:100%; height:192px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="192"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="192"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="152" x2="304" y2="152" class="solid"></line><line x1="312" y1="152" x2="320" y2="152" class="solid"></line><line x1="328" y1="152" x2="336" y2="152" class="solid"></line><line x1="344" y1="152" x2="352" y2="152" class="solid"></line><line x1="360" y1="152" x2="368" y2="152" class="solid"></line><line x1="376" y1="152" x2="384" y2="152" class="solid"></line><line x1="392" y1="152" x2="400" y2="152" class="solid"></line><line x1="408" y1="152" x2="416" y2="152" class="solid"></line><line x1="424" y1="152" x2="432" y2="152" class="solid"></line><line x1="440" y1="152" x2="448" y2="152" class="solid"></line><line x1="24" y1="168" x2="32" y2="168" class="solid"></line><line x1="40" y1="168" x2="48" y2="168" class="solid"></line><line x1="56" y1="168" x2="64" y2="168" class="solid"></line><line x1="72" y1="168" x2="80" y2="168" class="solid"></line><line x1="88" y1="168" x2="96" y2="168" class="solid"></line><line x1="104" y1="168" x2="112" y2="168" class="solid"></line><line x1="120" y1="168" x2="128" y2="168" class="solid"></line><line x1="136" y1="168" x2="144" y2="168" class="solid"></line><line x1="152" y1="168" x2="160" y2="168" class="solid"></line><line x1="168" y1="168" x2="176" y2="168" class="solid"></line><line x1="184" y1="168" x2="192" y2="168" class="solid"></line><line x1="200" y1="168" x2="208" y2="168" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="164" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,164 A 4,4 0,0,0 8,168" class="nofill"></path><line x1="8" y1="168" x2="16" y2="168" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="164" class="broken"></line><line x1="216" y1="168" x2="224" y2="168" class="solid"></line><path d="M 228,164 A 4,4 0,0,1 224,168" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,148 A 4,4 0,0,0 280,152" class="nofill"></path><line x1="280" y1="152" x2="288" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="148" class="broken"></line><line x1="456" y1="152" x2="464" y2="152" class="solid"></line><path d="M 468,148 A 4,4 0,0,1 464,152" class="nofill"></path></g></svg></div>
<p>å¤åˆ¶-èµ‹å€¼ä¹‹åï¼š</p>
<div style='width:100%; height:304px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="480" height="304"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="480" height="304"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="42" y="60" >s1</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="322" y="92" >C</text><text x="362" y="92" >p</text><text x="402" y="92" >p</text><text x="50" y="108" >len</text><text x="178" y="108" >3</text><text x="50" y="124" >capacity</text><text x="178" y="124" >3</text><text x="42" y="172" >s2</text><text x="50" y="204" >ptr</text><circle cx="164" cy="200" r="3" class="nofill"></circle><text x="322" y="204" >C</text><text x="362" y="204" >p</text><text x="402" y="204" >p</text><text x="50" y="220" >len</text><text x="178" y="220" >3</text><text x="50" y="236" >capacity</text><text x="178" y="236" >3</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="296" y1="264" x2="304" y2="264" class="solid"></line><line x1="312" y1="264" x2="320" y2="264" class="solid"></line><line x1="328" y1="264" x2="336" y2="264" class="solid"></line><line x1="344" y1="264" x2="352" y2="264" class="solid"></line><line x1="360" y1="264" x2="368" y2="264" class="solid"></line><line x1="376" y1="264" x2="384" y2="264" class="solid"></line><line x1="392" y1="264" x2="400" y2="264" class="solid"></line><line x1="408" y1="264" x2="416" y2="264" class="solid"></line><line x1="424" y1="264" x2="432" y2="264" class="solid"></line><line x1="440" y1="264" x2="448" y2="264" class="solid"></line><line x1="24" y1="280" x2="32" y2="280" class="solid"></line><line x1="40" y1="280" x2="48" y2="280" class="solid"></line><line x1="56" y1="280" x2="64" y2="280" class="solid"></line><line x1="72" y1="280" x2="80" y2="280" class="solid"></line><line x1="88" y1="280" x2="96" y2="280" class="solid"></line><line x1="104" y1="280" x2="112" y2="280" class="solid"></line><line x1="120" y1="280" x2="128" y2="280" class="solid"></line><line x1="136" y1="280" x2="144" y2="280" class="solid"></line><line x1="152" y1="280" x2="160" y2="280" class="solid"></line><line x1="168" y1="280" x2="176" y2="280" class="solid"></line><line x1="184" y1="280" x2="192" y2="280" class="solid"></line><line x1="200" y1="280" x2="208" y2="280" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="276" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,276 A 4,4 0,0,0 8,280" class="nofill"></path><line x1="8" y1="280" x2="16" y2="280" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="276" class="broken"></line><line x1="216" y1="280" x2="224" y2="280" class="solid"></line><path d="M 228,276 A 4,4 0,0,1 224,280" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="260" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,260 A 4,4 0,0,0 280,264" class="nofill"></path><line x1="280" y1="264" x2="288" y2="264" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="308" y1="72" x2="428" y2="72" class="solid"></line><line x1="308" y1="72" x2="308" y2="104" class="solid"></line><line x1="348" y1="72" x2="348" y2="104" class="solid"></line><line x1="388" y1="72" x2="388" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="308" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="296" y2="88" class="solid"></line><polygon points="296,84 304,88 296,92" class="filled"></polygon></g><g><line x1="36" y1="184" x2="196" y2="184" class="solid"></line><line x1="36" y1="184" x2="36" y2="248" class="solid"></line><line x1="132" y1="184" x2="132" y2="248" class="solid"></line><line x1="196" y1="184" x2="196" y2="248" class="solid"></line><line x1="36" y1="248" x2="196" y2="248" class="solid"></line></g><g><line x1="308" y1="184" x2="428" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="348" y1="184" x2="348" y2="216" class="solid"></line><line x1="388" y1="184" x2="388" y2="216" class="solid"></line><line x1="428" y1="184" x2="428" y2="216" class="solid"></line><line x1="308" y1="216" x2="428" y2="216" class="solid"></line></g><g><line x1="168" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><path d="M 464,24 A 4,4 0,0,1 468,28" class="nofill"></path><line x1="468" y1="28" x2="468" y2="260" class="broken"></line><line x1="456" y1="264" x2="464" y2="264" class="solid"></line><path d="M 468,260 A 4,4 0,0,1 464,264" class="nofill"></path></g></svg></div>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>C++ åšå‡ºäº†ä¸ Rust ç•¥æœ‰ä¸åŒçš„é€‰æ‹©ã€‚ç”±äºâ€œ=â€ä¼šå¤åˆ¶æ•°æ®ï¼Œå› æ­¤å¿…é¡»å…‹éš†å­—ç¬¦ä¸²æ•°æ®ã€‚å¦åˆ™ï¼Œå½“ä»»ä¸€å­—ç¬¦ä¸²è¶…å‡ºèŒƒå›´æ—¶ï¼Œä¾¿ä¼šå‡ºç°äºŒæ¬¡é‡Šæ”¾ã€‚</p>
</li>
<li>
<p>C++ è¿˜åŒ…å«<a href="https://en.cppreference.com/w/cpp/utility/move">â€œstd::moveâ€</a>ï¼Œå®ƒç”¨äºæŒ‡ç¤ºä½•æ—¶å¯ä»¥ç§»åŠ¨æŸä¸ªå€¼ã€‚å¦‚æœç¤ºä¾‹ä¸ºâ€œs2 = std::move(s1)â€ï¼Œåˆ™ä¸ä¼šå‘ç”Ÿå †åˆ†é…ã€‚ç§»åŠ¨åï¼Œâ€œs1â€å°†å¤„äºæœ‰æ•ˆä½†æœªæŒ‡å®šçš„çŠ¶æ€ã€‚ä¸ Rust ä¸åŒï¼Œç¨‹åºå‘˜å¯ä»¥ç»§ç»­ä½¿ç”¨â€œs1â€ã€‚</p>
</li>
<li>
<p>ä¸ Rust ä¸åŒï¼Œä½¿ç”¨ C++ æ—¶ï¼Œâ€œ=â€å¯ä»¥è¿è¡Œä»»æ„ä»£ç ï¼Œå…·ä½“å–å†³äºè¦å¤åˆ¶æˆ–ç§»åŠ¨çš„ç±»å‹ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#clone" id="clone">Clone</a></h1>
<p>æœ‰æ—¶ï¼Œ<em>å¦‚éœ€</em> å¤åˆ¶æŸä¸ªå€¼ã€‚<code>Clone</code> ç‰¹å¾ å¯ä»¥å®Œæˆæ­¤æ“ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn say_hello(name: String) {
    println!(&quot;Hello {name}&quot;)
}

fn main() {
    let name = String::from(&quot;Alice&quot;);
    say_hello(name.clone());
    say_hello(name);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The idea of <code>Clone</code> is to make it easy to spot where heap allocations are occurring. Look for <code>.clone()</code> and a few others like <code>vec!</code> or <code>Box::new</code>.</p>
</li>
<li>
<p>é€šå¸¸çš„åšæ³•æ˜¯ï¼Œå…ˆä½¿ç”¨ â€œå…‹éš†æ“ä½œâ€è§£å†³å€Ÿç”¨æ£€æŸ¥å™¨é—®é¢˜ï¼Œåœ¨åç»­é€šè¿‡ä¼˜åŒ–æ¶ˆé™¤è¿™äº›å…‹éš†æ“ä½œã€‚</p>
</li>
<li>
<p><code>clone</code> generally performs a deep copy of the value, meaning that if you e.g. clone an array, all of the elements of the array are cloned as well.</p>
</li>
<li>
<p>The behavior for <code>clone</code> is user-defined, so it can perform custom cloning logic if needed.</p>
</li>
</ul>
</details><h1><a class="header" href="#å¤åˆç±»å‹" id="å¤åˆç±»å‹">å¤åˆç±»å‹</a></h1>
<p>è™½ç„¶ç§»åŠ¨è¯­ä¹‰æ˜¯é»˜è®¤çš„ï¼Œä½†é»˜è®¤æƒ…å†µä¸‹ä¼šå¤åˆ¶æŸäº›ç±»å‹ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42;
    let y = x;
    println!(&quot;x: {x}&quot;); // would not be accessible if not Copy
    println!(&quot;y: {y}&quot;);
}
</code></pre></pre>
<p>è¿™äº›ç±»å‹å®ç°äº† <code>Copy</code> traitã€‚</p>
<p>ä½ å¯ä»¥é€‰æ‹©è‡ªå·±çš„ç±»å‹æ¥ä½¿ç”¨å¤åˆ¶è¯­ä¹‰ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Copy, Clone, Debug)]
struct Point(i32, i32);

fn main() {
    let p1 = Point(3, 4);
    let p2 = p1;
    println!(&quot;p1: {p1:?}&quot;);
    println!(&quot;p2: {p2:?}&quot;);
}
</code></pre></pre>
<ul>
<li>èµ‹å€¼ä¹‹åï¼Œ<code>p1</code> å’Œ <code>p2</code> éƒ½æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ã€‚</li>
<li>æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ <code>p1.clone()</code> æ˜¾å¼å¤åˆ¶æ•°æ®ã€‚</li>
</ul>
<details>
<p>å¤åˆ¶å’Œå…‹éš†æ˜¯ä¸¤ç äº‹ï¼š</p>
<ul>
<li>å¤åˆ¶æ˜¯æŒ‡å†…å­˜åŒºåŸŸçš„æŒ‰ä½å¤åˆ¶ï¼Œä¸é€‚ç”¨äºä»»æ„å¯¹è±¡ã€‚</li>
<li>å¤åˆ¶ä¸å…è®¸è‡ªå®šä¹‰é€»è¾‘ï¼ˆä¸åŒäº C++ ä¸­çš„å¤åˆ¶æ„é€ å‡½æ•°ï¼‰ã€‚</li>
<li>å…‹éš†æ˜¯ä¸€ç§æ›´é€šç”¨çš„æ“ä½œï¼Œä¹Ÿå…è®¸é€šè¿‡å®ç° <code>Clone</code> trait æ¥è‡ªå®šä¹‰è¡Œä¸ºã€‚</li>
<li>å¤åˆ¶ä¸é€‚ç”¨äºå®ç° <code>Drop</code> trait çš„ç±»å‹ã€‚</li>
</ul>
<p>åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œè¯·å°è¯•ä»¥ä¸‹æ“ä½œï¼š</p>
<ul>
<li>åœ¨ <code>struct Point</code> ä¸­æ·»åŠ  <code>String</code> å­—æ®µã€‚ç”±äº <code>String</code> ä¸å±äº <code>Copy</code> ç±»å‹ï¼Œå› æ­¤æ— æ³•ç¼–è¯‘ã€‚</li>
<li>Remove <code>Copy</code> from the <code>derive</code> attribute. The compiler error is now in the <code>println!</code> for <code>p1</code>.</li>
<li>æŒ‡å‡ºå¦‚æœä½ æ”¹ä¸ºå…‹éš† <code>p1</code>ï¼Œåˆ™å¯æŒ‰é¢„æœŸè¿è¡Œã€‚</li>
</ul>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-4" id="æ¢ç´¢æ›´å¤š-4">æ¢ç´¢æ›´å¤š</a></h1>
<ul>
<li>Shared references are <code>Copy</code>/<code>Clone</code>, mutable references are not. This is because Rust requires that mutable references be exclusive, so while it's valid to make a copy of a shared reference, creating a copy of a mutable reference would violate Rust's borrowing rules.</li>
</ul>
</details><h1><a class="header" href="#drop-ç‰¹å¾" id="drop-ç‰¹å¾"><code>Drop</code> ç‰¹å¾</a></h1>
<p>ç”¨äºå®ç° <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> çš„å€¼å¯ä»¥æŒ‡å®šåœ¨è¶…å‡ºèŒƒå›´æ—¶è¿è¡Œçš„ä»£ç ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping {}&quot;, self.name);
    }
}

fn main() {
    let a = Droppable { name: &quot;a&quot; };
    {
        let b = Droppable { name: &quot;b&quot; };
        {
            let c = Droppable { name: &quot;c&quot; };
            let d = Droppable { name: &quot;d&quot; };
            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Exiting block A&quot;);
    }
    drop(a);
    println!(&quot;Exiting main&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>è¯·æ³¨æ„ï¼Œ<code>std::mem::drop</code> ä¸ <code>std::ops::Drop::drop</code> ä¸åŒã€‚</li>
<li>å½“å€¼è¶…å‡ºèŒƒå›´æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†å…¶åˆ é™¤ã€‚</li>
<li>ä¸¢å¼ƒæŸä¸ªå€¼æ—¶ï¼Œå¦‚æœè¯¥å€¼å®ç°äº† <code>std::ops::Drop</code>ï¼Œåˆ™ä¼šè°ƒç”¨å…¶ <code>Drop::drop</code> å®ç°ã€‚</li>
<li>ç„¶åï¼Œè¯¥å€¼æ‰€æœ‰å­—æ®µä¹Ÿä¼šè¢«ä¸¢å¼ƒï¼Œæ— è®ºå…¶æ˜¯å¦å®ç°äº† <code>Drop</code>ã€‚</li>
<li><code>std::mem::drop</code> åªæ˜¯ä¸€ä¸ªé‡‡ç”¨ä»»ä½•å€¼çš„ç©ºå‡½æ•°ã€‚é‡è¦çš„æ˜¯å®ƒè·å¾—äº†å€¼çš„æ‰€æœ‰æƒï¼Œå› æ­¤åœ¨å…¶ä½œç”¨åŸŸç»“æŸæ—¶ä¾¿ä¼šè¢«ä¸¢å¼ƒã€‚å¦‚æ­¤æ‚¨å¯ä»¥è½»æ¾æå‰æ˜ç¡®åœ°ä¸¢å¼ƒå€¼ï¼Œè€Œä¸å¿…ç­‰åˆ°å€¼è¶…è¿‡èŒƒå›´çš„æ—¶å€™ã€‚
<ul>
<li>è¿™å¯¹äºé€šè¿‡ <code>drop</code> æ‰§è¡Œä»»åŠ¡çš„å¯¹è±¡æ¥è¯´éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚é‡Šæ”¾é”ã€å…³é—­æ–‡ä»¶ç­‰ã€‚</li>
</ul>
</li>
</ul>
<p>è®¨è®ºç‚¹ï¼š</p>
<ul>
<li>ä¸ºä»€ä¹ˆ <code>Drop::drop</code> ä¸ä½¿ç”¨ <code>self</code>ï¼Ÿ
<ul>
<li>ç®€ç­”ï¼šå¦‚æœè¿™æ ·çš„è¯ï¼Œç³»ç»Ÿä¼šåœ¨ä»£ç å—ç»“å°¾ è°ƒç”¨ <code>std::mem::drop</code>ï¼Œè¿›è€Œå¼•å‘å†ä¸€æ¬¡è°ƒç”¨ <code>Drop::drop</code>ï¼Œå¹¶å¼•å‘å †æ ˆ æº¢å‡ºï¼</li>
</ul>
</li>
<li>å°è¯•ç”¨ <code>a.drop()</code> æ›¿æ¢ <code>drop(a)</code>ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ç»ƒä¹ æ„å»ºå™¨ç±»å‹" id="ç»ƒä¹ æ„å»ºå™¨ç±»å‹">ç»ƒä¹ ï¼šæ„å»ºå™¨ç±»å‹</a></h1>
<p>åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªæ‹¥æœ‰å…¨éƒ¨æ•°æ®æ‰€æœ‰æƒçš„å¤æ‚æ•°æ®ç±»å‹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ â€œæ„å»ºå™¨æ¨¡å¼â€æ¥æ”¯æŒé€æ­¥æ„å»ºæ–°å€¼ï¼Œé€šè¿‡ä¾¿æ·å‡½æ•°æ¥å®ç°ã€‚</p>
<p>å¡«è¡¥ç¼ºå¤±çš„å†…å®¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust should_panic editable">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        todo!(&quot;1&quot;)
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        todo!(&quot;2&quot;)
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        todo!(&quot;3&quot;)
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        todo!(&quot;4&quot;)
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        todo!(&quot;5&quot;)
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new(&quot;base64&quot;).version(&quot;0.13&quot;).build();
    println!(&quot;base64: {base64:?}&quot;);
    let log =
        PackageBuilder::new(&quot;log&quot;).version(&quot;0.4&quot;).language(Language::Rust).build();
    println!(&quot;log: {log:?}&quot;);
    let serde = PackageBuilder::new(&quot;serde&quot;)
        .authors(vec![&quot;djmitche&quot;.into()])
        .version(String::from(&quot;4.0&quot;))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!(&quot;serde: {serde:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-10" id="è§£ç­”-10">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum Language {
    Rust,
    Java,
    Perl,
}

#[derive(Clone, Debug)]
struct Dependency {
    name: String,
    version_expression: String,
}

/// A representation of a software package.
#[derive(Debug)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
    dependencies: Vec&lt;Dependency&gt;,
    language: Option&lt;Language&gt;,
}

impl Package {
    /// Return a representation of this package as a dependency, for use in
    /// building other packages.
    fn as_dependency(&amp;self) -&gt; Dependency {
        Dependency {
            name: self.name.clone(),
            version_expression: self.version.clone(),
        }
    }
}

/// A builder for a Package. Use `build()` to create the `Package` itself.
struct PackageBuilder(Package);

impl PackageBuilder {
    fn new(name: impl Into&lt;String&gt;) -&gt; Self {
        Self(Package {
            name: name.into(),
            version: &quot;0.1&quot;.into(),
            authors: vec![],
            dependencies: vec![],
            language: None,
        })
    }

    /// Set the package version.
    fn version(mut self, version: impl Into&lt;String&gt;) -&gt; Self {
        self.0.version = version.into();
        self
    }

    /// Set the package authors.
    fn authors(mut self, authors: Vec&lt;String&gt;) -&gt; Self {
        self.0.authors = authors;
        self
    }

    /// Add an additional dependency.
    fn dependency(mut self, dependency: Dependency) -&gt; Self {
        self.0.dependencies.push(dependency);
        self
    }

    /// Set the language. If not set, language defaults to None.
    fn language(mut self, language: Language) -&gt; Self {
        self.0.language = Some(language);
        self
    }

    fn build(self) -&gt; Package {
        self.0
    }
}

fn main() {
    let base64 = PackageBuilder::new(&quot;base64&quot;).version(&quot;0.13&quot;).build();
    println!(&quot;base64: {base64:?}&quot;);
    let log =
        PackageBuilder::new(&quot;log&quot;).version(&quot;0.4&quot;).language(Language::Rust).build();
    println!(&quot;log: {log:?}&quot;);
    let serde = PackageBuilder::new(&quot;serde&quot;)
        .authors(vec![&quot;djmitche&quot;.into()])
        .version(String::from(&quot;4.0&quot;))
        .dependency(base64.as_dependency())
        .dependency(log.as_dependency())
        .build();
    println!(&quot;serde: {serde:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#æ™ºèƒ½æŒ‡é’ˆ" id="æ™ºèƒ½æŒ‡é’ˆ">æ™ºèƒ½æŒ‡é’ˆ</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a> æ˜¯æŒ‡å‘å †ä¸Šæ•°æ®çš„è‡ªæœ‰æŒ‡é’ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let five = Box::new(5);
    println!(&quot;five: {}&quot;, *five);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="288" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="288" height="176"></rect><rect x="36" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><circle cx="52" cy="88" r="3" class="nofill"></circle><rect x="196" y="72" width="48" height="32" class="solid nofill" rx="0"></rect><text x="218" y="92" >5</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="218" y="12" >Heap</text><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="232" y1="24" x2="240" y2="24" class="solid"></line><line x1="248" y1="24" x2="256" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><text x="42" y="60" >five</text><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="232" y1="152" x2="240" y2="152" class="solid"></line><line x1="248" y1="152" x2="256" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><path d="M 112,24 A 4,4 0,0,1 116,28" class="nofill"></path><line x1="116" y1="28" x2="116" y2="148" class="broken"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><path d="M 116,148 A 4,4 0,0,1 112,152" class="nofill"></path></g><g><path d="M 168,24 A 4,4 0,0,0 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="148" class="broken"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><path d="M 164,148 A 4,4 0,0,0 168,152" class="nofill"></path><line x1="168" y1="152" x2="176" y2="152" class="solid"></line></g><g><line x1="56" y1="88" x2="184" y2="88" class="solid"></line><polygon points="184,84 192,88 184,92" class="filled"></polygon></g><g><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 272,24 A 4,4 0,0,1 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="148" class="broken"></line><line x1="264" y1="152" x2="272" y2="152" class="solid"></line><path d="M 276,148 A 4,4 0,0,1 272,152" class="nofill"></path></g></svg></div>
<p><code>Box&lt;T&gt;</code> ä¼šå®ç° <code>Deref&lt;Target = T&gt;</code>ï¼Œè¿™æ„å‘³ç€æ‚¨å¯ä»¥<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">ç›´æ¥åœ¨ <code>Box&lt;T&gt;</code> ä¸Šé€šè¿‡ <code>T</code> è°ƒç”¨ç›¸åº”æ–¹æ³•</a>ã€‚</p>
<p>Recursive data types or data types with dynamic sizes cannot be stored inline without a pointer indirection. <code>Box</code> accomplishes that indirection:</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
enum List&lt;T&gt; {
    /// A non-empty list: first element and the rest of the list.
    Element(T, Box&lt;List&lt;T&gt;&gt;),
    /// An empty list.
    Nil,
}

fn main() {
    let list: List&lt;i32&gt; =
        List::Element(1, Box::new(List::Element(2, Box::new(List::Nil))));
    println!(&quot;{list:?}&quot;);
}
</code></pre></pre>
<div style='width:100%; height:176px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="696" height="176"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="696" height="176"></rect><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="266" y="12" >Heap</text><line x1="236" y1="28" x2="236" y2="148" class="broken"></line><text x="42" y="60" >list</text><text x="50" y="92" >Element</text><text x="130" y="92" >1</text><circle cx="172" cy="88" r="3" class="nofill"></circle><text x="338" y="92" >Element</text><text x="418" y="92" >2</text><circle cx="460" cy="88" r="3" class="nofill"></circle><text x="538" y="92" >Nil</text><line x1="600" y1="80" x2="592" y2="96" class="solid"></line><line x1="608" y1="80" x2="600" y2="96" class="solid"></line><line x1="640" y1="80" x2="632" y2="96" class="solid"></line><line x1="648" y1="80" x2="640" y2="96" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><line x1="304" y1="24" x2="312" y2="24" class="solid"></line><line x1="320" y1="24" x2="328" y2="24" class="solid"></line><line x1="336" y1="24" x2="344" y2="24" class="solid"></line><line x1="352" y1="24" x2="360" y2="24" class="solid"></line><line x1="368" y1="24" x2="376" y2="24" class="solid"></line><line x1="384" y1="24" x2="392" y2="24" class="solid"></line><line x1="400" y1="24" x2="408" y2="24" class="solid"></line><line x1="416" y1="24" x2="424" y2="24" class="solid"></line><line x1="432" y1="24" x2="440" y2="24" class="solid"></line><line x1="448" y1="24" x2="456" y2="24" class="solid"></line><line x1="464" y1="24" x2="472" y2="24" class="solid"></line><line x1="480" y1="24" x2="488" y2="24" class="solid"></line><line x1="496" y1="24" x2="504" y2="24" class="solid"></line><line x1="512" y1="24" x2="520" y2="24" class="solid"></line><line x1="528" y1="24" x2="536" y2="24" class="solid"></line><line x1="544" y1="24" x2="552" y2="24" class="solid"></line><line x1="560" y1="24" x2="568" y2="24" class="solid"></line><line x1="576" y1="24" x2="584" y2="24" class="solid"></line><line x1="592" y1="24" x2="600" y2="24" class="solid"></line><line x1="608" y1="24" x2="616" y2="24" class="solid"></line><line x1="624" y1="24" x2="632" y2="24" class="solid"></line><line x1="640" y1="24" x2="648" y2="24" class="solid"></line><line x1="656" y1="24" x2="664" y2="24" class="solid"></line><line x1="24" y1="152" x2="32" y2="152" class="solid"></line><line x1="40" y1="152" x2="48" y2="152" class="solid"></line><line x1="56" y1="152" x2="64" y2="152" class="solid"></line><line x1="72" y1="152" x2="80" y2="152" class="solid"></line><line x1="88" y1="152" x2="96" y2="152" class="solid"></line><line x1="104" y1="152" x2="112" y2="152" class="solid"></line><line x1="120" y1="152" x2="128" y2="152" class="solid"></line><line x1="136" y1="152" x2="144" y2="152" class="solid"></line><line x1="152" y1="152" x2="160" y2="152" class="solid"></line><line x1="168" y1="152" x2="176" y2="152" class="solid"></line><line x1="184" y1="152" x2="192" y2="152" class="solid"></line><line x1="200" y1="152" x2="208" y2="152" class="solid"></line><line x1="216" y1="152" x2="224" y2="152" class="solid"></line><line x1="304" y1="152" x2="312" y2="152" class="solid"></line><line x1="320" y1="152" x2="328" y2="152" class="solid"></line><line x1="336" y1="152" x2="344" y2="152" class="solid"></line><line x1="352" y1="152" x2="360" y2="152" class="solid"></line><line x1="368" y1="152" x2="376" y2="152" class="solid"></line><line x1="384" y1="152" x2="392" y2="152" class="solid"></line><line x1="400" y1="152" x2="408" y2="152" class="solid"></line><line x1="416" y1="152" x2="424" y2="152" class="solid"></line><line x1="432" y1="152" x2="440" y2="152" class="solid"></line><line x1="448" y1="152" x2="456" y2="152" class="solid"></line><line x1="464" y1="152" x2="472" y2="152" class="solid"></line><line x1="480" y1="152" x2="488" y2="152" class="solid"></line><line x1="496" y1="152" x2="504" y2="152" class="solid"></line><line x1="512" y1="152" x2="520" y2="152" class="solid"></line><line x1="528" y1="152" x2="536" y2="152" class="solid"></line><line x1="544" y1="152" x2="552" y2="152" class="solid"></line><line x1="560" y1="152" x2="568" y2="152" class="solid"></line><line x1="576" y1="152" x2="584" y2="152" class="solid"></line><line x1="592" y1="152" x2="600" y2="152" class="solid"></line><line x1="608" y1="152" x2="616" y2="152" class="solid"></line><line x1="624" y1="152" x2="632" y2="152" class="solid"></line><line x1="640" y1="152" x2="648" y2="152" class="solid"></line><line x1="656" y1="152" x2="664" y2="152" class="solid"></line><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="148" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,148 A 4,4 0,0,0 8,152" class="nofill"></path><line x1="8" y1="152" x2="16" y2="152" class="solid"></line></g><g><path d="M 288,24 A 4,4 0,0,0 284,28" class="nofill"></path><line x1="284" y1="28" x2="284" y2="148" class="broken"></line><line x1="288" y1="24" x2="296" y2="24" class="solid"></line><path d="M 284,148 A 4,4 0,0,0 288,152" class="nofill"></path><line x1="288" y1="152" x2="296" y2="152" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="104" class="solid"></line><line x1="116" y1="72" x2="116" y2="104" class="solid"></line><line x1="156" y1="72" x2="156" y2="104" class="solid"></line><line x1="196" y1="72" x2="196" y2="104" class="solid"></line><line x1="36" y1="104" x2="196" y2="104" class="solid"></line></g><g><line x1="324" y1="72" x2="484" y2="72" class="solid"></line><line x1="324" y1="72" x2="324" y2="104" class="solid"></line><line x1="404" y1="72" x2="404" y2="104" class="solid"></line><line x1="444" y1="72" x2="444" y2="104" class="solid"></line><line x1="484" y1="72" x2="484" y2="104" class="solid"></line><line x1="324" y1="104" x2="484" y2="104" class="solid"></line></g><g><line x1="524" y1="72" x2="660" y2="72" class="solid"></line><line x1="524" y1="72" x2="524" y2="104" class="solid"></line><line x1="580" y1="72" x2="580" y2="104" class="solid"></line><line x1="620" y1="72" x2="620" y2="104" class="solid"></line><line x1="660" y1="72" x2="660" y2="104" class="solid"></line><line x1="524" y1="104" x2="660" y2="104" class="solid"></line></g><g><line x1="176" y1="88" x2="312" y2="88" class="solid"></line><polygon points="312,84 320,88 312,92" class="filled"></polygon></g><g><line x1="464" y1="88" x2="512" y2="88" class="solid"></line><polygon points="512,84 520,88 512,92" class="filled"></polygon></g><g><line x1="672" y1="24" x2="680" y2="24" class="solid"></line><path d="M 680,24 A 4,4 0,0,1 684,28" class="nofill"></path><line x1="684" y1="28" x2="684" y2="148" class="broken"></line><line x1="672" y1="152" x2="680" y2="152" class="solid"></line><path d="M 684,148 A 4,4 0,0,1 680,152" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>
<p><code>Box</code> is like <code>std::unique_ptr</code> in C++, except that it's guaranteed to be not null.</p>
</li>
<li>
<p>åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œ<code>Box</code> å¯èƒ½ä¼šå¾ˆå®ç”¨ï¼š</p>
<ul>
<li>have a type whose size can't be known at compile time, but the Rust compiler wants to know an exact size.</li>
<li>æƒ³è¦è½¬è®©å¤§é‡æ•°æ®çš„æ‰€æœ‰æƒã€‚ä¸ºé¿å…åœ¨å †æ ˆä¸Šå¤åˆ¶å¤§é‡æ•°æ®ï¼Œè¯·æ”¹ä¸ºå°†æ•°æ®å­˜å‚¨åœ¨ <code>Box</code> ä¸­çš„å †ä¸Šï¼Œä»¥ä¾¿ä»…ç§»åŠ¨æŒ‡é’ˆã€‚</li>
</ul>
</li>
<li>
<p>If <code>Box</code> was not used and we attempted to embed a <code>List</code> directly into the <code>List</code>, the compiler would not be able to compute a fixed size for the struct in memory (the <code>List</code> would be of infinite size).</p>
</li>
<li>
<p><code>Box</code> å¤§å°ä¸ä¸€èˆ¬æŒ‡é’ˆç›¸åŒï¼Œå¹¶ä¸”åªä¼šæŒ‡å‘å †ä¸­çš„ä¸‹ä¸€ä¸ª <code>List</code> å…ƒç´ ï¼Œ å› æ­¤å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p>
</li>
<li>
<p>Remove the <code>Box</code> in the List definition and show the compiler error. We get the message &quot;recursive without indirection&quot;, because for data recursion, we have to use indirection, a <code>Box</code> or reference of some kind, instead of storing the value directly.</p>
</li>
<li>
<p>Though <code>Box</code> looks like <code>std::unique_ptr</code> in C++, it cannot be empty/null. This makes <code>Box</code> one of the types that allow the compiler to optimize storage of some enums (the &quot;niche optimization&quot;).</p>
</li>
</ul>
</details><h1><a class="header" href="#rc" id="rc"><code>Rc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc</code></a> æ˜¯å¼•ç”¨è®¡æ•°çš„å…±äº«æŒ‡é’ˆã€‚å¦‚æœæ‚¨éœ€è¦ä»å¤šä¸ªä½ç½® å¼•ç”¨ç›¸åŒçš„æ•°æ®ï¼Œè¯·ä½¿ç”¨æ­¤æŒ‡é’ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let a = Rc::new(10);
    let b = Rc::clone(&amp;a);

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<ul>
<li>See <a href="smart-pointers/../concurrency/shared-state/arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> if you are in a multi-threaded context.</li>
<li>æ‚¨å¯ä»¥å°†å…±äº«æŒ‡é’ˆ_é™çº§_ä¸º <a href="https://doc.rust-lang.org/std/rc/struct.Weak.html"><code>Weak</code></a> æŒ‡é’ˆï¼Œ ä»¥ä¾¿åˆ›å»ºä¹‹åä¼šè¢«èˆå¼ƒçš„å¾ªç¯å¼•ç”¨ã€‚</li>
</ul>
<details>
<ul>
<li><code>Rc</code> çš„è®¡æ•°å¯ç¡®ä¿åªè¦æœ‰å¼•ç”¨ï¼Œå†…å«çš„å€¼å°±ä¼šä¿æŒæœ‰æ•ˆã€‚</li>
<li>Rust ä¸­çš„â€œRcâ€ä¸ C++ ä¸­çš„â€œstd::shared_ptrâ€ç±»ä¼¼ã€‚</li>
<li><code>Rc::clone</code> çš„æˆæœ¬å¾ˆä½ï¼šè¿™ä¸ªåšæ³•ä¼šåˆ›å»ºæŒ‡å‘ç›¸åŒåˆ†é…çš„æŒ‡é’ˆï¼Œå¹¶å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè€Œä¸ä¼šäº§ç”Ÿæ·±å±‚çš„å…‹éš†ï¼Œæ’æŸ¥ä»£ç æ€§èƒ½é—®é¢˜æ—¶é€šå¸¸å¯ä»¥å¿½ç•¥ã€‚</li>
<li><code>make_mut</code> å®é™…ä¸Šä¼šåœ¨å¿…è¦æ—¶å…‹éš†å†…éƒ¨å€¼ï¼ˆâ€œclone-on-writeâ€ï¼‰ï¼Œå¹¶è¿”å›å¯å˜çš„å¼•ç”¨ã€‚</li>
<li>ä½¿ç”¨ <code>Rc::strong_count</code> å¯æŸ¥çœ‹å¼•ç”¨è®¡æ•°ã€‚</li>
<li><code>Rc::downgrade</code> gives you a <em>weakly reference-counted</em> object to create cycles that will be dropped properly (likely in combination with <code>RefCell</code>).</li>
</ul>
</details><h1><a class="header" href="#owned-trait-objects" id="owned-trait-objects">Owned Trait Objects</a></h1>
<p>We previously saw how trait objects can be used with references, e.g <code>&amp;dyn Pet</code>. However, we can also use trait objects with smart pointers like <code>Box</code> to create an owned trait object: <code>Box&lt;dyn Pet&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Dog {
    name: String,
    age: i8,
}
struct Cat {
    lives: i8,
}

trait Pet {
    fn talk(&amp;self) -&gt; String;
}

impl Pet for Dog {
    fn talk(&amp;self) -&gt; String {
        format!(&quot;Woof, my name is {}!&quot;, self.name)
    }
}

impl Pet for Cat {
    fn talk(&amp;self) -&gt; String {
        String::from(&quot;Miau!&quot;)
    }
}

fn main() {
    let pets: Vec&lt;Box&lt;dyn Pet&gt;&gt; = vec![
        Box::new(Cat { lives: 9 }),
        Box::new(Dog { name: String::from(&quot;Fido&quot;), age: 5 }),
    ];
    for pet in pets {
        println!(&quot;Hello, who are you? {}&quot;, pet.talk());
    }
}
</code></pre></pre>
<p>ä»¥ä¸‹æ˜¯åˆ†é… <code>pets</code> åçš„å†…å­˜å¸ƒå±€ï¼š</p>
<div style='width:100%; height:480px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="656" height="480"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="656" height="480"></rect><rect x="428" y="328" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="348" >&lt;Dog as Pet&gt;::talk</text><rect x="428" y="392" width="184" height="32" class="solid nofill" rx="0"></rect><text x="442" y="412" >&lt;Cat as Pet&gt;::talk</text><text x="10" y="12" >Stack</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><text x="282" y="12" >Heap</text><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><text x="482" y="76" >F</text><text x="522" y="76" >i</text><text x="562" y="76" >d</text><text x="602" y="76" >o</text><text x="50" y="92" >ptr</text><circle cx="164" cy="88" r="3" class="nofill"></circle><text x="314" y="92" >lives</text><text x="410" y="92" >9</text><text x="50" y="108" >len</text><text x="178" y="108" >2</text><text x="50" y="124" >capacity</text><text x="178" y="124" >2</text><text x="466" y="156" >data:</text><text x="474" y="188" >name</text><circle cx="548" cy="184" r="3" class="nofill"></circle><text x="554" y="188" >,</text><text x="570" y="188" >4,</text><text x="594" y="188" >4</text><circle cx="324" cy="200" r="3" class="nofill"></circle><circle cx="340" cy="200" r="3" class="nofill"></circle><circle cx="372" cy="200" r="3" class="nofill"></circle><circle cx="388" cy="200" r="3" class="nofill"></circle><text x="474" y="204" >age</text><text x="594" y="204" >5</text><line x1="424" y1="296" x2="432" y2="296" class="solid"></line><line x1="440" y1="296" x2="448" y2="296" class="solid"></line><line x1="456" y1="296" x2="464" y2="296" class="solid"></line><line x1="472" y1="296" x2="480" y2="296" class="solid"></line><text x="434" y="316" >vtable</text><text x="434" y="380" >vtable</text><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><line x1="168" y1="24" x2="176" y2="24" class="solid"></line><line x1="184" y1="24" x2="192" y2="24" class="solid"></line><line x1="200" y1="24" x2="208" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><line x1="168" y1="184" x2="176" y2="184" class="solid"></line><line x1="184" y1="184" x2="192" y2="184" class="solid"></line><line x1="200" y1="184" x2="208" y2="184" class="solid"></line><line x1="296" y1="248" x2="304" y2="248" class="solid"></line><line x1="336" y1="248" x2="344" y2="248" class="solid"></line><line x1="352" y1="248" x2="360" y2="248" class="solid"></line><line x1="392" y1="248" x2="400" y2="248" class="solid"></line><line x1="408" y1="248" x2="416" y2="248" class="solid"></line><line x1="424" y1="248" x2="432" y2="248" class="solid"></line><line x1="440" y1="248" x2="448" y2="248" class="solid"></line><line x1="456" y1="248" x2="464" y2="248" class="solid"></line><line x1="472" y1="248" x2="480" y2="248" class="solid"></line><line x1="488" y1="248" x2="496" y2="248" class="solid"></line><line x1="504" y1="248" x2="512" y2="248" class="solid"></line><line x1="520" y1="248" x2="528" y2="248" class="solid"></line><line x1="536" y1="248" x2="544" y2="248" class="solid"></line><line x1="552" y1="248" x2="560" y2="248" class="solid"></line><line x1="568" y1="248" x2="576" y2="248" class="solid"></line><line x1="584" y1="248" x2="592" y2="248" class="solid"></line><line x1="600" y1="248" x2="608" y2="248" class="solid"></line><line x1="616" y1="248" x2="624" y2="248" class="solid"></line><line x1="296" y1="296" x2="304" y2="296" class="solid"></line><line x1="336" y1="296" x2="344" y2="296" class="solid"></line><line x1="352" y1="296" x2="360" y2="296" class="solid"></line><line x1="392" y1="296" x2="400" y2="296" class="solid"></line><line x1="408" y1="296" x2="416" y2="296" class="solid"></line><line x1="488" y1="296" x2="496" y2="296" class="solid"></line><line x1="504" y1="296" x2="512" y2="296" class="solid"></line><line x1="520" y1="296" x2="528" y2="296" class="solid"></line><line x1="536" y1="296" x2="544" y2="296" class="solid"></line><line x1="552" y1="296" x2="560" y2="296" class="solid"></line><line x1="568" y1="296" x2="576" y2="296" class="solid"></line><line x1="584" y1="296" x2="592" y2="296" class="solid"></line><line x1="600" y1="296" x2="608" y2="296" class="solid"></line><line x1="616" y1="296" x2="624" y2="296" class="solid"></line><line x1="296" y1="456" x2="304" y2="456" class="solid"></line><line x1="312" y1="456" x2="320" y2="456" class="solid"></line><line x1="328" y1="456" x2="336" y2="456" class="solid"></line><line x1="344" y1="456" x2="352" y2="456" class="solid"></line><line x1="360" y1="456" x2="368" y2="456" class="solid"></line><line x1="376" y1="456" x2="384" y2="456" class="solid"></line><line x1="392" y1="456" x2="400" y2="456" class="solid"></line><line x1="408" y1="456" x2="416" y2="456" class="solid"></line><line x1="424" y1="456" x2="432" y2="456" class="solid"></line><line x1="440" y1="456" x2="448" y2="456" class="solid"></line><line x1="456" y1="456" x2="464" y2="456" class="solid"></line><line x1="472" y1="456" x2="480" y2="456" class="solid"></line><line x1="488" y1="456" x2="496" y2="456" class="solid"></line><line x1="504" y1="456" x2="512" y2="456" class="solid"></line><line x1="520" y1="456" x2="528" y2="456" class="solid"></line><line x1="536" y1="456" x2="544" y2="456" class="solid"></line><line x1="552" y1="456" x2="560" y2="456" class="solid"></line><line x1="568" y1="456" x2="576" y2="456" class="solid"></line><line x1="584" y1="456" x2="592" y2="456" class="solid"></line><line x1="600" y1="456" x2="608" y2="456" class="solid"></line><line x1="616" y1="456" x2="624" y2="456" class="solid"></line><text x="42" y="60" >pets: Vec&lt;dyn Pet&gt;</text><text x="306" y="60" >data: Cat</text><text x="506" y="156" >Dog</text><text x="554" y="284" >Program text</text><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="216" y1="24" x2="224" y2="24" class="solid"></line><path d="M 224,24 A 4,4 0,0,1 228,28" class="nofill"></path><line x1="228" y1="28" x2="228" y2="180" class="broken"></line><line x1="216" y1="184" x2="224" y2="184" class="solid"></line><path d="M 228,180 A 4,4 0,0,1 224,184" class="nofill"></path></g><g><path d="M 280,24 A 4,4 0,0,0 276,28" class="nofill"></path><line x1="276" y1="28" x2="276" y2="244" class="broken"></line><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><path d="M 276,244 A 4,4 0,0,0 280,248" class="nofill"></path><line x1="280" y1="248" x2="288" y2="248" class="solid"></line></g><g><line x1="468" y1="56" x2="628" y2="56" class="solid"></line><line x1="468" y1="56" x2="468" y2="88" class="solid"></line><line x1="508" y1="56" x2="508" y2="88" class="solid"></line><line x1="548" y1="56" x2="548" y2="88" class="solid"></line><line x1="588" y1="56" x2="588" y2="88" class="solid"></line><line x1="628" y1="56" x2="628" y2="88" class="solid"></line><line x1="468" y1="88" x2="628" y2="88" class="solid"></line></g><g><line x1="36" y1="72" x2="196" y2="72" class="solid"></line><line x1="36" y1="72" x2="36" y2="136" class="solid"></line><line x1="132" y1="72" x2="132" y2="136" class="solid"></line><line x1="196" y1="72" x2="196" y2="136" class="solid"></line><line x1="36" y1="136" x2="196" y2="136" class="solid"></line></g><g><line x1="300" y1="72" x2="428" y2="72" class="solid"></line><line x1="300" y1="72" x2="300" y2="104" class="solid"></line><line x1="364" y1="72" x2="364" y2="104" class="solid"></line><line x1="428" y1="72" x2="428" y2="104" class="solid"></line><line x1="300" y1="104" x2="428" y2="104" class="solid"></line></g><g><line x1="168" y1="88" x2="248" y2="88" class="solid"></line><path d="M 248,88 A 4,4 0,0,1 252,92" class="nofill"></path><line x1="252" y1="92" x2="252" y2="196" class="solid"></line><path d="M 252,196 A 4,4 0,0,0 256,200" class="nofill"></path><line x1="256" y1="200" x2="296" y2="200" class="solid"></line><polygon points="296,196 304,200 296,204" class="filled"></polygon></g><g><polygon points="480,108 484,96 488,108" class="filled"></polygon><line x1="484" y1="108" x2="484" y2="132" class="solid"></line><path d="M 484,132 A 4,4 0,0,0 488,136" class="nofill"></path><line x1="488" y1="136" x2="544" y2="136" class="solid"></line><path d="M 544,136 A 4,4 0,0,1 548,140" class="nofill"></path><line x1="548" y1="140" x2="548" y2="180" class="solid"></line></g><g><polygon points="336,124 340,112 344,124" class="filled"></polygon><line x1="340" y1="124" x2="340" y2="196" class="solid"></line></g><g><line x1="460" y1="168" x2="612" y2="168" class="solid"></line><line x1="460" y1="168" x2="460" y2="216" class="solid"></line><line x1="524" y1="168" x2="524" y2="216" class="solid"></line><line x1="612" y1="168" x2="612" y2="216" class="solid"></line><line x1="460" y1="216" x2="612" y2="216" class="solid"></line></g><g><line x1="308" y1="184" x2="404" y2="184" class="solid"></line><line x1="308" y1="184" x2="308" y2="216" class="solid"></line><line x1="356" y1="184" x2="356" y2="216" class="solid"></line><line x1="404" y1="184" x2="404" y2="216" class="solid"></line><line x1="308" y1="216" x2="404" y2="216" class="solid"></line></g><g><line x1="324" y1="204" x2="324" y2="404" class="solid"></line><line x1="312" y1="248" x2="324" y2="248" class="solid"></line><line x1="312" y1="296" x2="324" y2="296" class="solid"></line><path d="M 324,404 A 4,4 0,0,0 328,408" class="nofill"></path><line x1="328" y1="408" x2="416" y2="408" class="solid"></line><polygon points="416,404 424,408 416,412" class="filled"></polygon></g><g><line x1="372" y1="204" x2="372" y2="340" class="solid"></line><line x1="372" y1="248" x2="384" y2="248" class="solid"></line><line x1="372" y1="296" x2="384" y2="296" class="solid"></line><path d="M 372,340 A 4,4 0,0,0 376,344" class="nofill"></path><line x1="376" y1="344" x2="416" y2="344" class="solid"></line><polygon points="416,340 424,344 416,348" class="filled"></polygon></g><g><line x1="392" y1="200" x2="448" y2="200" class="solid"></line><polygon points="448,196 456,200 448,204" class="filled"></polygon></g><g><line x1="632" y1="24" x2="640" y2="24" class="solid"></line><path d="M 640,24 A 4,4 0,0,1 644,28" class="nofill"></path><line x1="644" y1="28" x2="644" y2="244" class="broken"></line><line x1="632" y1="248" x2="640" y2="248" class="solid"></line><path d="M 644,244 A 4,4 0,0,1 640,248" class="nofill"></path></g><g><path d="M 280,296 A 4,4 0,0,0 276,300" class="nofill"></path><line x1="276" y1="300" x2="276" y2="452" class="broken"></line><line x1="280" y1="296" x2="288" y2="296" class="solid"></line><path d="M 276,452 A 4,4 0,0,0 280,456" class="nofill"></path><line x1="280" y1="456" x2="288" y2="456" class="solid"></line></g><g><line x1="632" y1="296" x2="640" y2="296" class="solid"></line><path d="M 640,296 A 4,4 0,0,1 644,300" class="nofill"></path><line x1="644" y1="300" x2="644" y2="452" class="broken"></line><line x1="632" y1="456" x2="640" y2="456" class="solid"></line><path d="M 644,452 A 4,4 0,0,1 640,456" class="nofill"></path></g></svg></div>
<details>
<ul>
<li>å®ç°ç»™å®š trait çš„ç±»å‹å¯èƒ½å¤§å°ä¸åŒã€‚å› æ­¤ï¼Œä¸Šä¾‹ä¸­ä¸å¯èƒ½å…·æœ‰åƒ <code>Vec&lt;dyn Pet&gt;</code> è¿™æ ·çš„é¡¹ã€‚</li>
<li>å¯é€šè¿‡â€œdyn Petâ€è¿™ä¸ªæ–¹æ³•å‘ç¼–è¯‘å™¨å‘ŠçŸ¥å®ç°â€œPetâ€çš„åŠ¨æ€å¤§å°ç±»å‹ã€‚</li>
<li>åœ¨æœ¬ä¾‹ä¸­ï¼Œ<code>pets</code> åœ¨æ ˆä¸Šåˆ†é…å†…å­˜ï¼ŒçŸ¢é‡æ•°æ®å­˜å‚¨åœ¨å †ä¸Šã€‚è¿™ä¸¤ä¸ªçŸ¢é‡å…ƒç´ æ˜¯ <em>èƒ–æŒ‡é’ˆ</em>ï¼š
<ul>
<li>èƒ–æŒ‡é’ˆå±äºå…¨è§’æŒ‡é’ˆã€‚å®ƒåŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼šæŒ‡å‘å®é™…å¯¹è±¡çš„æŒ‡é’ˆï¼Œä»¥åŠæŒ‡å‘è¯¥ç‰¹å®šå¯¹è±¡çš„ <code>Pet</code> å®ç°çš„ <a href="https://en.wikipedia.org/wiki/Virtual_method_table">è™šæ‹Ÿæ–¹æ³•è¡¨</a> (vtable) çš„æŒ‡é’ˆã€‚</li>
<li><code>Dog</code>ï¼ˆåä¸º Fidoï¼‰ç±»å‹çš„æ•°æ®æ˜¯ <code>name</code> å’Œ <code>age</code> å­—æ®µã€‚<code>Cat</code> ç±»å‹åŒ…å«ä¸€ä¸ª <code>lives</code> å­—æ®µã€‚</li>
</ul>
</li>
<li>æ¯”è¾ƒä¸Šè¿°ç¤ºä¾‹ä¸­çš„è¿™äº›è¾“å‡ºï¼š
<pre><code class="language-rust ignore">println!(&quot;{} {}&quot;, std::mem::size_of::&lt;Dog&gt;(), std::mem::size_of::&lt;Cat&gt;());
println!(&quot;{} {}&quot;, std::mem::size_of::&lt;&amp;Dog&gt;(), std::mem::size_of::&lt;&amp;Cat&gt;());
println!(&quot;{}&quot;, std::mem::size_of::&lt;&amp;dyn Pet&gt;());
println!(&quot;{}&quot;, std::mem::size_of::&lt;Box&lt;dyn Pet&gt;&gt;());
</code></pre>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ äºŒå‰æ ‘" id="ç»ƒä¹ äºŒå‰æ ‘">ç»ƒä¹ ï¼šäºŒå‰æ ‘</a></h1>
<p>äºŒå…ƒæ ‘æ˜¯ä¸€ç§æ ‘å‹æ•°æ®ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼ˆå·¦ä¾§å’Œå³ä¾§ï¼‰ã€‚æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªæ ‘çŠ¶ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªå€¼ã€‚å¯¹äºç»™å®šçš„èŠ‚ç‚¹ Nï¼ŒN çš„å·¦ä¾§å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½åŒ…å«è¾ƒå°çš„å€¼ï¼Œè€Œ N çš„å³ä¾§å­æ ‘ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½å°†åŒ…å«è¾ƒå¤§çš„å€¼ã€‚</p>
<p>å®ç°ä»¥ä¸‹ç±»å‹ï¼Œä»¥ä¾¿é€šè¿‡æŒ‡å®šçš„æµ‹è¯•ã€‚</p>
<p>é¢å¤–æç¤ºï¼šå¯¹æŒ‰é¡ºåºè¿”å›å€¼çš„äºŒå…ƒæ ‘å®ç°è¿­ä»£å™¨ã€‚</p>
<pre><code class="language-rust editable ignore">/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

// Implement `new`, `insert`, `len`, and `has` for `Subtree`.

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}
</code></pre>
<h1><a class="header" href="#è§£ç­”-11" id="è§£ç­”-11">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::Ordering;

/// A node in the binary tree.
#[derive(Debug)]
struct Node&lt;T: Ord&gt; {
    value: T,
    left: Subtree&lt;T&gt;,
    right: Subtree&lt;T&gt;,
}

/// A possibly-empty subtree.
#[derive(Debug)]
struct Subtree&lt;T: Ord&gt;(Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;);

/// A container storing a set of values, using a binary tree.
///
/// If the same value is added multiple times, it is only stored once.
#[derive(Debug)]
pub struct BinaryTree&lt;T: Ord&gt; {
    root: Subtree&lt;T&gt;,
}

impl&lt;T: Ord&gt; BinaryTree&lt;T&gt; {
    fn new() -&gt; Self {
        Self { root: Subtree::new() }
    }

    fn insert(&amp;mut self, value: T) {
        self.root.insert(value);
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        self.root.has(value)
    }

    fn len(&amp;self) -&gt; usize {
        self.root.len()
    }
}

impl&lt;T: Ord&gt; Subtree&lt;T&gt; {
    fn new() -&gt; Self {
        Self(None)
    }

    fn insert(&amp;mut self, value: T) {
        match &amp;mut self.0 {
            None =&gt; self.0 = Some(Box::new(Node::new(value))),
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.insert(value),
                Ordering::Equal =&gt; {}
                Ordering::Greater =&gt; n.right.insert(value),
            },
        }
    }

    fn has(&amp;self, value: &amp;T) -&gt; bool {
        match &amp;self.0 {
            None =&gt; false,
            Some(n) =&gt; match value.cmp(&amp;n.value) {
                Ordering::Less =&gt; n.left.has(value),
                Ordering::Equal =&gt; true,
                Ordering::Greater =&gt; n.right.has(value),
            },
        }
    }

    fn len(&amp;self) -&gt; usize {
        match &amp;self.0 {
            None =&gt; 0,
            Some(n) =&gt; 1 + n.left.len() + n.right.len(),
        }
    }
}

impl&lt;T: Ord&gt; Node&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        Self { value, left: Subtree::new(), right: Subtree::new() }
    }
}

fn main() {
    let mut tree = BinaryTree::new();
    tree.insert(&quot;foo&quot;);
    assert_eq!(tree.len(), 1);
    tree.insert(&quot;bar&quot;);
    assert!(tree.has(&amp;&quot;foo&quot;));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn len() {
        let mut tree = BinaryTree::new();
        assert_eq!(tree.len(), 0);
        tree.insert(2);
        assert_eq!(tree.len(), 1);
        tree.insert(1);
        assert_eq!(tree.len(), 2);
        tree.insert(2); // not a unique item
        assert_eq!(tree.len(), 2);
    }

    #[test]
    fn has() {
        let mut tree = BinaryTree::new();
        fn check_has(tree: &amp;BinaryTree&lt;i32&gt;, exp: &amp;[bool]) {
            let got: Vec&lt;bool&gt; =
                (0..exp.len()).map(|i| tree.has(&amp;(i as i32))).collect();
            assert_eq!(&amp;got, exp);
        }

        check_has(&amp;tree, &amp;[false, false, false, false, false]);
        tree.insert(0);
        check_has(&amp;tree, &amp;[true, false, false, false, false]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(4);
        check_has(&amp;tree, &amp;[true, false, false, false, true]);
        tree.insert(3);
        check_has(&amp;tree, &amp;[true, false, false, true, true]);
    }

    #[test]
    fn unbalanced() {
        let mut tree = BinaryTree::new();
        for i in 0..100 {
            tree.insert(i);
        }
        assert_eq!(tree.len(), 100);
        assert!(tree.has(&amp;50));
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-2" id="welcome-back-2">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#å€Ÿç”¨" id="å€Ÿç”¨">å€Ÿç”¨</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å€Ÿç”¨å€¼" id="å€Ÿç”¨å€¼">å€Ÿç”¨å€¼</a></h1>
<p>As we saw before, instead of transferring ownership when calling a function, you can let a function <em>borrow</em> the value:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    Point(p1.0 + p2.0, p1.1 + p2.1)
}

fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
<ul>
<li><code>add</code> å‡½æ•°â€œå€Ÿç”¨â€ä¸¤ä¸ªç‚¹å¹¶è¿”å›ä¸€ä¸ªæ–°ç‚¹ã€‚</li>
<li>è°ƒç”¨æ–¹ä¼šä¿ç•™è¾“å…¥çš„æ‰€æœ‰æƒã€‚</li>
</ul>
<details>
<p>æ­¤å¹»ç¯ç‰‡æ˜¯å¯¹ç¬¬ 1 å¤©å¼•ç”¨ææ–™çš„å›é¡¾ï¼Œå¹¶ç¨ä½œäº†æ‰©å±•ï¼Œæ·»åŠ äº†å‡½æ•°å‚æ•°å’Œè¿”å›å€¼ã€‚</p>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-5" id="æ¢ç´¢æ›´å¤š-5">æ¢ç´¢æ›´å¤š</a></h1>
<p>Notes on stack returns and inlining:</p>
<ul>
<li>
<p>Demonstrate that the return from <code>add</code> is cheap because the compiler can eliminate the copy operation, by inlining the call to add into main. Change the above code to print stack addresses and run it on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=0cb13be1c05d7e3446686ad9947c4671">Playground</a> or look at the assembly in <a href="https://rust.godbolt.org/">Godbolt</a>. In the &quot;DEBUG&quot; optimization level, the addresses should change, while they stay the same when changing to the &quot;RELEASE&quot; setting:</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn add(p1: &amp;Point, p2: &amp;Point) -&gt; Point {
    let p = Point(p1.0 + p2.0, p1.1 + p2.1);
    println!(&quot;&amp;p.0: {:p}&quot;, &amp;p.0);
    p
}

pub fn main() {
    let p1 = Point(3, 4);
    let p2 = Point(10, 20);
    let p3 = add(&amp;p1, &amp;p2);
    println!(&quot;&amp;p3.0: {:p}&quot;, &amp;p3.0);
    println!(&quot;{p1:?} + {p2:?} = {p3:?}&quot;);
}
</code></pre></pre>
</li>
<li>
<p>The Rust compiler can do automatic inlining, that can be disabled on a function level with <code>#[inline(never)]</code>.</p>
</li>
<li>
<p>Once disabled, the printed address will change on all optimization levels. Looking at Godbolt or Playground, one can see that in this case, the return of the value depends on the ABI, e.g. on amd64 the two i32 that is making up the point will be returned in 2 registers (eax and edx).</p>
</li>
</ul>
</details>
<h1><a class="header" href="#å€Ÿç”¨æ£€æŸ¥" id="å€Ÿç”¨æ£€æŸ¥">å€Ÿç”¨æ£€æŸ¥</a></h1>
<p>Rust's <em>borrow checker</em> puts constraints on the ways you can borrow values. For a given value, at any time:</p>
<ul>
<li>You can have one or more shared references to the value, <em>or</em></li>
<li>You can have exactly one exclusive reference to the value.</li>
</ul>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut a: i32 = 10;
    let b: &amp;i32 = &amp;a;

    {
        let c: &amp;mut i32 = &amp;mut a;
        *c = 20;
    }

    println!(&quot;a: {a}&quot;);
    println!(&quot;b: {b}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>è¯·æ³¨æ„ï¼Œè¦æ±‚æ˜¯ç›¸å†²çªçš„å¼•ç”¨ä¸èƒ½ <em>åŒæ—¶å­˜åœ¨</em>ã€‚è€Œå¼•ç”¨çš„è§£å¼•ç”¨ä½ç½®æ— å…³ç´§è¦ã€‚</li>
<li>ä¸Šè¿°ä»£ç æ— æ³•ç¼–è¯‘ï¼Œå› ä¸º <code>a</code> åŒæ—¶ä½œä¸ºå¯å˜å€¼ï¼ˆé€šè¿‡ <code>c</code>ï¼‰å’Œä¸å¯å˜å€¼ï¼ˆé€šè¿‡ <code>b</code>ï¼‰è¢«å€Ÿç”¨ã€‚</li>
<li>å°†<code>b</code> çš„ <code>println!</code> è¯­å¥ç§»åˆ°å¼•å…¥ <code>c</code> çš„ä½œç”¨åŸŸä¹‹å‰ï¼Œè¿™æ®µä»£ç å°±å¯ä»¥ç¼–è¯‘ã€‚</li>
<li>è¿™æ ·æ›´æ”¹åï¼Œç¼–è¯‘å™¨ä¼šå‘ç° <code>b</code> åªåœ¨é€šè¿‡ <code>c</code> å¯¹ <code>a</code> è¿›è¡Œæ–°å¯å˜å€Ÿç”¨ä¹‹å‰ä½¿ç”¨è¿‡ã€‚è¿™æ˜¯å€Ÿç”¨æ£€æŸ¥å™¨çš„ä¸€ä¸ªåŠŸèƒ½ï¼Œåä¸ºâ€œéè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸâ€ã€‚</li>
<li>The exclusive reference constraint is quite strong. Rust uses it to ensure that data races do not occur. Rust also <em>relies</em> on this constraint to optimize code. For example, a value behind a shared reference can be safely cached in a register for the lifetime of that reference.</li>
<li>å€Ÿç”¨æ£€æŸ¥å™¨ä¸“ç”¨äºå¤„ç†è®¸å¤šå¸¸è§æ¨¡å¼ï¼Œä¾‹å¦‚åŒæ—¶å¯¹ç»“æ„ä½“ä¸­çš„ä¸åŒå­—æ®µè¿›è¡Œç‹¬å å¼•ç”¨ã€‚ä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒå¹¶ä¸èƒ½å®Œå…¨ â€œé¢†ä¼šâ€æ‚¨çš„æ„å›¾ï¼Œè¿™å¾€å¾€ä¼šå¯¼è‡´ â€œä¸å€Ÿç”¨æ£€æŸ¥å™¨è¿›è¡Œä¸€ç•ªæ–—äº‰â€ã€‚</li>
</ul>
</details><h1><a class="header" href="#borrow-errors" id="borrow-errors">Borrow Errors</a></h1>
<p>As a concrete example of how these borrowing rules prevent memory errors, consider the case of modifying a collection while there are references to its elements:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    let elem = &amp;vec[2];
    vec.push(6);
    println!(&quot;{elem}&quot;);
}
</code></pre></pre>
<p>Similarly, consider the case of iterator invalidation:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
    for elem in &amp;vec {
        vec.push(elem * 2);
    }
}
</code></pre></pre>
<details>
<ul>
<li>In both of these cases, modifying the collection by pushing new elements into it can potentially invalidate existing references to the collection's elements if the collection has to reallocate.</li>
</ul>
</details><h1><a class="header" href="#å†…éƒ¨å¯å˜æ€§" id="å†…éƒ¨å¯å˜æ€§">å†…éƒ¨å¯å˜æ€§</a></h1>
<p>In some situations, it's necessary to modify data behind a shared (read-only) reference. For example, a shared data structure might have an internal cache, and wish to update that cache from read-only methods.</p>
<p>The &quot;interior mutability&quot; pattern allows exclusive (mutable) access behind a shared reference. The standard library provides several ways to do this, all while still ensuring safety, typically by performing a runtime check.</p>
<h2><a class="header" href="#cell" id="cell"><code>Cell</code></a></h2>
<p><code>Cell</code> wraps a value and allows getting or setting the value using only a shared reference to the <code>Cell</code>. However, it does not allow any references to the inner value. Since there are no references, borrowing rules cannot be broken.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::Cell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = Cell::new(5);

    cell.set(123);
    println!(&quot;{}&quot;, cell.get());
}
</code></pre></pre>
<h2><a class="header" href="#refcell" id="refcell"><code>RefCell</code></a></h2>
<p><code>RefCell</code> allows accessing and mutating a wrapped value by providing alternative types <code>Ref</code> and <code>RefMut</code> that emulate <code>&amp;T</code>/<code>&amp;mut T</code> without actually being Rust references.</p>
<p>These types perform dynamic checks using a counter in the <code>RefCell</code> to prevent existence of a <code>RefMut</code> alongside another <code>Ref</code>/<code>RefMut</code>.</p>
<p>By implementing <code>Deref</code> (and <code>DerefMut</code> for <code>RefMut</code>), these types allow calling methods on the inner value without allowing references to escape.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;

fn main() {
    // Note that `cell` is NOT declared as mutable.
    let cell = RefCell::new(5);

    {
        let mut cell_ref = cell.borrow_mut();
        *cell_ref = 123;

        // This triggers an error at runtime.
        // let other = cell.borrow();
        // println!(&quot;{}&quot;, *other);
    }

    println!(&quot;{cell:?}&quot;);
}
</code></pre></pre>
<details>
<p>The main thing to take away from this slide is that Rust provides <em>safe</em> ways to modify data behind a shared reference. There are a variety of ways to ensure that safety, and <code>RefCell</code> and <code>Cell</code> are two of them.</p>
<ul>
<li>
<p><code>RefCell</code> enforces Rust's usual borrowing rules (either multiple shared references or a single exclusive reference) with a runtime check. In this case, all borrows are very short and never overlap, so the checks always succeed.</p>
<ul>
<li>The extra block in the <code>RefCell</code> example is to end the borrow created by the call to <code>borrow_mut</code> before we print the cell. Trying to print a borrowed <code>RefCell</code> just shows the message <code>&quot;{borrowed}&quot;</code>.</li>
</ul>
</li>
<li>
<p><code>Cell</code> is a simpler means to ensure safety: it has a <code>set</code> method that takes <code>&amp;self</code>. This needs no runtime check, but requires moving values, which can have its own cost.</p>
</li>
<li>
<p>Both <code>RefCell</code> and <code>Cell</code> are <code>!Sync</code>, which means <code>&amp;RefCell</code> and <code>&amp;Cell</code> can't be passed between threads. This prevents two threads trying to access the cell at once.</p>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ å¥åº·ç»Ÿè®¡" id="ç»ƒä¹ å¥åº·ç»Ÿè®¡">ç»ƒä¹ ï¼šå¥åº·ç»Ÿè®¡</a></h1>
<p>ä½ æ­£åœ¨å®ç°ä¸€ä¸ªå¥åº·ç›‘æ§ç³»ç»Ÿã€‚ä½œä¸ºå…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œä½ éœ€è¦å¯¹ç”¨æˆ·çš„å¥åº·ç»Ÿè®¡æ•°æ®è¿›è¡Œè¿½è¸ªã€‚</p>
<p>You'll start with a stubbed function in an <code>impl</code> block as well as a <code>User</code> struct definition. Your goal is to implement the stubbed out method on the <code>User</code> <code>struct</code> defined in the <code>impl</code> block.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and fill in the missing method:</p>
<pre><pre class="playground"><code class="language-rust">// TODO: remove this when you're done with your implementation.
#![allow(unused_variables, dead_code)]


#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        todo!(&quot;Update a user's statistics based on measurements from a visit to the doctor&quot;)
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-12" id="è§£ç­”-12">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">
#![allow(dead_code)]
pub struct User {
    name: String,
    age: u32,
    height: f32,
    visit_count: usize,
    last_blood_pressure: Option&lt;(u32, u32)&gt;,
}

pub struct Measurements {
    height: f32,
    blood_pressure: (u32, u32),
}

pub struct HealthReport&lt;'a&gt; {
    patient_name: &amp;'a str,
    visit_count: u32,
    height_change: f32,
    blood_pressure_change: Option&lt;(i32, i32)&gt;,
}

impl User {
    pub fn new(name: String, age: u32, height: f32) -&gt; Self {
        Self { name, age, height, visit_count: 0, last_blood_pressure: None }
    }

    pub fn visit_doctor(&amp;mut self, measurements: Measurements) -&gt; HealthReport {
        self.visit_count += 1;
        let bp = measurements.blood_pressure;
        let report = HealthReport {
            patient_name: &amp;self.name,
            visit_count: self.visit_count as u32,
            height_change: measurements.height - self.height,
            blood_pressure_change: match self.last_blood_pressure {
                Some(lbp) =&gt; {
                    Some((bp.0 as i32 - lbp.0 as i32, bp.1 as i32 - lbp.1 as i32))
                }
                None =&gt; None,
            },
        };
        self.height = measurements.height;
        self.last_blood_pressure = Some(bp);
        report
    }
}

fn main() {
    let bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    println!(&quot;I'm {} and my age is {}&quot;, bob.name, bob.age);
}

#[test]
fn test_visit() {
    let mut bob = User::new(String::from(&quot;Bob&quot;), 32, 155.2);
    assert_eq!(bob.visit_count, 0);
    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (120, 80) });
    assert_eq!(report.patient_name, &quot;Bob&quot;);
    assert_eq!(report.visit_count, 1);
    assert_eq!(report.blood_pressure_change, None);
    assert!((report.height_change - 0.9).abs() &lt; 0.00001);

    let report =
        bob.visit_doctor(Measurements { height: 156.1, blood_pressure: (115, 76) });

    assert_eq!(report.visit_count, 2);
    assert_eq!(report.blood_pressure_change, Some((-5, -4)));
    assert_eq!(report.height_change, 0.0);
}
</code></pre></pre>
<h1><a class="header" href="#ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ" id="ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ">ç»“æ„ä½“ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#ç”Ÿå‘½å‘¨æœŸæ³¨è§£" id="ç”Ÿå‘½å‘¨æœŸæ³¨è§£">ç”Ÿå‘½å‘¨æœŸæ³¨è§£</a></h1>
<p>A reference has a <em>lifetime</em>, which must not &quot;outlive&quot; the value it refers to. This is verified by the borrow checker.</p>
<p>The lifetime can be implicit - this is what we have seen so far. Lifetimes can also be explicit: <code>&amp;'a Point</code>, <code>&amp;'document str</code>. Lifetimes start with <code>'</code> and <code>'a</code> is a typical default name. Read <code>&amp;'a Point</code> as &quot;a borrowed <code>Point</code> which is valid for at least the lifetime <code>a</code>&quot;.</p>
<p>Lifetimes are always inferred by the compiler: you cannot assign a lifetime yourself. Explicit lifetime annotations create constraints where there is ambiguity; the compiler verifies that there is a valid solution.</p>
<p>å½“è€ƒè™‘å‘å‡½æ•°ä¼ é€’å€¼å’Œä»å‡½æ•°è¿”å›å€¼æ—¶ï¼Œç”Ÿå‘½å‘¨æœŸä¼šå˜å¾—æ›´åŠ å¤æ‚ã€‚</p>
<!-- The multi-line formatting by rustfmt in left_most is apparently
     intentional: https://github.com/rust-lang/rustfmt/issues/1908 -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[derive(Debug)]
struct Point(i32, i32);

fn left_most(p1: &amp;Point, p2: &amp;Point) -&gt; &amp;Point {
    if p1.0 &lt; p2.0 {
        p1
    } else {
        p2
    }
}

fn main() {
    let p1: Point = Point(10, 10);
    let p2: Point = Point(20, 20);
    let p3 = left_most(&amp;p1, &amp;p2); // What is the lifetime of p3?
    println!(&quot;p3: {p3:?}&quot;);
}
</code></pre></pre>
<details>
<p>In this example, the compiler does not know what lifetime to infer for <code>p3</code>. Looking inside the function body shows that it can only safely assume that <code>p3</code>'s lifetime is the shorter of <code>p1</code> and <code>p2</code>. But just like types, Rust requires explicit annotations of lifetimes on function arguments and return values.</p>
<p>å°† <code>'a</code> é€‚å½“æ·»åŠ åˆ° <code>left_most</code> ä¸­ï¼š</p>
<pre><code class="language-rust ignore">fn left_most&lt;'a&gt;(p1: &amp;'a Point, p2: &amp;'a Point) -&gt; &amp;'a Point {
</code></pre>
<p>è¿™è¡¨ç¤º.ï¼Œâ€œå‡è®¾ p1 å’Œ p2 çš„å­˜åœ¨æ—¶é—´éƒ½æ¯” <code>'a</code> æ›´é•¿ï¼Œåˆ™è¿”å›å€¼è‡³å°‘åœ¨ <code>'a</code> å†…æœ‰æ•ˆâ€ã€‚</p>
<p>åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯ä»¥çœç•¥ç”Ÿå‘½å‘¨æœŸï¼Œå¦‚ä¸‹ä¸€å¼ å¹»ç¯ç‰‡ä¸­æ‰€è¿°ã€‚</p>
</details><h1><a class="header" href="#å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ" id="å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ">å‡½æ•°è°ƒç”¨ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>Lifetimes for function arguments and return values must be fully specified, but Rust allows lifetimes to be elided in most cases with <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">a few simple rules</a>. This is not inference -- it is just a syntactic shorthand.</p>
<ul>
<li>æ¯ä¸ªæ²¡æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å‚æ•°éƒ½ä¼šæ·»åŠ ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚</li>
<li>å¦‚æœåªæœ‰ä¸€ä¸ªå‚æ•°ç”Ÿå‘½å‘¨æœŸï¼Œåˆ™å°†å…¶èµ‹äºˆæ‰€æœ‰æœªåŠ æ³¨è§£çš„è¿”å›å€¼ã€‚</li>
<li>å¦‚æœæœ‰å¤šä¸ªå‚æ•°ç”Ÿå‘½å‘¨æœŸï¼Œä½†ç¬¬ä¸€ä¸ªæ˜¯ç”¨äº <code>self</code> çš„ï¼Œåˆ™å°†è¯¥ç”Ÿå‘½å‘¨æœŸèµ‹äºˆæ‰€æœ‰æœªåŠ æ³¨è§£çš„è¿”å›å€¼ã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point(i32, i32);

fn cab_distance(p1: &amp;Point, p2: &amp;Point) -&gt; i32 {
    (p1.0 - p2.0).abs() + (p1.1 - p2.1).abs()
}

fn nearest&lt;'a&gt;(points: &amp;'a [Point], query: &amp;Point) -&gt; Option&lt;&amp;'a Point&gt; {
    let mut nearest = None;
    for p in points {
        if let Some((_, nearest_dist)) = nearest {
            let dist = cab_distance(p, query);
            if dist &lt; nearest_dist {
                nearest = Some((p, dist));
            }
        } else {
            nearest = Some((p, cab_distance(p, query)));
        };
    }
    nearest.map(|(p, _)| p)
}

fn main() {
    let points = &amp;[Point(1, 0), Point(1, 0), Point(-1, 0), Point(0, -1)];
    println!(&quot;{:?}&quot;, nearest(points, &amp;Point(0, 2)));
}
</code></pre></pre>
<details>
<p>åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œ<code>cab_distance</code> è¢«è½»æ˜“çœç•¥æ‰äº†ã€‚</p>
<p><code>nearest</code> å‡½æ•°æä¾›äº†å¦ä¸€ä¸ªå‡½æ•°ç¤ºä¾‹ï¼Œè¯¥å‡½æ•°çš„å‚æ•°ä¸­åŒ…å«å¤šä¸ªå¼•ç”¨ï¼Œéœ€è¦æ˜¾å¼æ³¨è§£ã€‚</p>
<p>è¯·å°è¯•å°†ç­¾åè°ƒæ•´ä¸º â€œè°æŠ¥â€äº†è¿”å›çš„ç”Ÿå‘½å‘¨æœŸï¼š</p>
<pre><code class="language-rust ignore">fn nearest&lt;'a, 'q&gt;(points: &amp;'a [Point], query: &amp;'q Point) -&gt; Option&lt;&amp;'q Point&gt; {
</code></pre>
<p>This won't compile, demonstrating that the annotations are checked for validity by the compiler. Note that this is not the case for raw pointers (unsafe), and this is a common source of errors with unsafe Rust.</p>
<p>Students may ask when to use lifetimes. Rust borrows <em>always</em> have lifetimes. Most of the time, elision and type inference mean these don't need to be written out. In more complicated cases, lifetime annotations can help resolve ambiguity. Often, especially when prototyping, it's easier to just work with owned data by cloning values where necessary.</p>
</details><h1><a class="header" href="#æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ" id="æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ">æ•°æ®ç»“æ„ä¸­çš„ç”Ÿå‘½å‘¨æœŸ</a></h1>
<p>å¦‚æœæ•°æ®ç±»å‹å­˜å‚¨äº†å€Ÿç”¨çš„æ•°æ®ï¼Œåˆ™å¿…é¡»å¯¹å…¶æ·»åŠ ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Highlight&lt;'doc&gt;(&amp;'doc str);

fn erase(text: String) {
    println!(&quot;Bye {text}!&quot;);
}

fn main() {
    let text = String::from(&quot;The quick brown fox jumps over the lazy dog.&quot;);
    let fox = Highlight(&amp;text[4..19]);
    let dog = Highlight(&amp;text[35..43]);
    // erase(text);
    println!(&quot;{fox:?}&quot;);
    println!(&quot;{dog:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œ<code>Highlight</code> æ³¨é‡Šä¼šå¼ºåˆ¶åŒ…å« <code>&amp;str</code> çš„åº•å±‚æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸè‡³å°‘ä¸ä½¿ç”¨è¯¥æ•°æ®çš„ä»»ä½• <code>Highlight</code> å®ä¾‹ä¸€æ ·é•¿ã€‚</li>
<li>å¦‚æœ <code>text</code> åœ¨ <code>fox</code>ï¼ˆæˆ– <code>dog</code>ï¼‰çš„ç”Ÿå‘½å‘¨æœŸç»“æŸå‰è¢«æ¶ˆè€—ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨å°†æŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚</li>
<li>å€Ÿç”¨æ•°æ®çš„ç±»å‹ä¼šè¿«ä½¿ç”¨æˆ·ä¿ç•™åŸå§‹æ•°æ®ã€‚è¿™å¯¹äºåˆ›å»ºè½»é‡çº§è§†å›¾å¾ˆæœ‰ç”¨ï¼Œä½†é€šå¸¸ä¼šä½¿å®ƒä»¬æ›´éš¾ä½¿ç”¨ã€‚</li>
<li>å¦‚æœ‰å¯èƒ½ï¼Œè®©æ•°æ®ç»“æ„ç›´æ¥æ‹¥æœ‰è‡ªå·±çš„æ•°æ®ã€‚</li>
<li>ä¸€äº›åŒ…å«å¤šä¸ªå¼•ç”¨çš„ç»“æ„å¯ä»¥æœ‰å¤šä¸ªç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚é™¤äº†ç»“æ„ä½“æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸä¹‹å¤–ï¼Œå¦‚æœéœ€è¦æè¿°å¼•ç”¨ä¹‹é—´çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»ï¼Œåˆ™å¯èƒ½éœ€è¦è¿™æ ·åšã€‚è¿™äº›éƒ½æ˜¯éå¸¸é«˜çº§çš„ç”¨ä¾‹ã€‚</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ protobuf-è§£æ" id="ç»ƒä¹ protobuf-è§£æ">ç»ƒä¹ ï¼šProtobuf è§£æ</a></h1>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæ‚¨å°†ä¸º <a href="https://protobuf.dev/programming-guides/encoding/">protobuf äºŒè¿›åˆ¶ç¼–ç </a> æ„å»ºä¸€ä¸ªè§£æå™¨ã€‚åˆ«æ‹…å¿ƒï¼Œå…¶å®éå¸¸ç®€å•ï¼è¿™å±•ç¤ºäº†ä¸€ç§å¸¸è§çš„è§£ææ¨¡å¼ï¼Œå³ä¼ é€’æ•°æ® sliceã€‚åº•å±‚æ•°æ®æœ¬èº«æ°¸è¿œä¸ä¼šè¢«å¤åˆ¶ã€‚</p>
<p>å¦‚è¦å®Œæ•´è§£æ protobuf æ¶ˆæ¯ï¼Œéœ€è¦çŸ¥é“å­—æ®µçš„ç±»å‹ï¼ˆæŒ‰å­—æ®µç¼–å·ç¼–å…¥ç´¢å¼•ï¼‰ã€‚è¿™é€šå¸¸ä¼šåœ¨ <code>proto</code> æ–‡ä»¶ä¸­æä¾›ã€‚åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬å°†æŠŠè¿™äº›ä¿¡æ¯ç¼–ç æˆå¤„ç†æ¯ä¸ªå­—æ®µæ‰€è°ƒç”¨çš„å‡½æ•°ä¸­çš„ <code>match</code> è¯­å¥ã€‚</p>
<p>æˆ‘ä»¬å°†ä½¿ç”¨ä»¥ä¸‹ protoï¼š</p>
<pre><code class="language-proto">message PhoneNumber {
  optional string number = 1;
  optional string type = 2;
}

message Person {
  optional string name = 1;
  optional int32 id = 2;
  repeated PhoneNumber phones = 3;
}
</code></pre>
<p>proto æ¶ˆæ¯è¢«ç¼–ç ä¸ºè¿ç»­çš„ä¸€ç³»åˆ—å­—æ®µã€‚æ¯ä¸ªå­—æ®µéƒ½é€šè¿‡ â€œæ ‡ç­¾â€åé¢ç´§è·Ÿå€¼çš„å½¢å¼æ¥å®ç°ã€‚æ ‡ç­¾åŒ…å«ä¸€ä¸ªå­—æ®µç¼–å·ï¼ˆä¾‹å¦‚<code>Person</code> æ¶ˆæ¯çš„ <code>id</code> å­—æ®µçš„å€¼ä¸º <code>2</code>ï¼‰å’Œçº¿å‹ï¼ˆç”¨äºå®šä¹‰åº”å¦‚ä½•ä»å­—èŠ‚æµç¡®å®šè½½è·ï¼‰ã€‚</p>
<p>æ•´æ•°ï¼ˆåŒ…æ‹¬æ ‡ç­¾ï¼‰ä½¿ç”¨åä¸º VARINT çš„å¯å˜é•¿åº¦ç¼–ç è¡¨ç¤ºã€‚å¹¸è¿çš„æ˜¯ï¼Œä¸‹é¢ä¸ºæ‚¨æä¾›äº† <code>parse_varint</code> çš„å®šä¹‰ã€‚è¯¥æŒ‡å®šä»£ç è¿˜å®šä¹‰äº†ä¸€äº›å›è°ƒï¼Œç”¨äºå¤„ç† <code>Person</code> å’Œ <code>PhoneNumber</code> å­—æ®µï¼Œå¹¶å°†æ¶ˆæ¯è§£æä¸ºå¯¹è¿™äº›å›è°ƒçš„ä¸€ç³»åˆ—è°ƒç”¨ã€‚</p>
<p>What remains for you is to implement the <code>parse_field</code> function and the <code>ProtoMessage</code> trait for <code>Person</code> and <code>PhoneNumber</code>.</p>
<!-- compile_fail because the stubbed out code has type inference errors. -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// A wire type as seen on the wire.
enum WireType {
    /// Varint WireType è¡¨æ˜è¯¥å€¼ä¸ºå•ä¸ª VARINTã€‚
    Varint,
    /// The I64 WireType indicates that the value is precisely 8 bytes in
    /// little-endian order containing a 64-bit signed integer or double type.
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    // The I32 WireType indicates that the value is precisely 4 bytes in
    // little-endian order containing a 32-bit signed integer or float type.
    //I32,  -- not needed for this exercise
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    //I32(i32),  -- not needed for this exercise
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            //5 =&gt; WireType::I32,  -- not needed for this exercise
            _ =&gt; panic!(&quot;Invalid wire type: {value}&quot;),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_str(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected string to be a `Len` field&quot;);
        };
        std::str::from_utf8(data).expect(&quot;Invalid string&quot;)
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected bytes to be a `Len` field&quot;);
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!(&quot;Expected `u64` to be a `Varint` field&quot;);
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!(&quot;Not enough bytes for varint&quot;);
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!(&quot;Too many bytes for varint&quot;);
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}


/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        _ =&gt; todo!(&quot;Based on the wire type, build a Field, consuming as many bytes as necessary.&quot;)
    };
    todo!(&quot;Return the field, and any un-consumed bytes.&quot;)
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

// TODO: Implement ProtoMessage for Person and PhoneNumber.

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!(&quot;{:#?}&quot;, person);
}
</code></pre></pre>
<details>
<ul>
<li>In this exercise there are various cases where protobuf parsing might fail, e.g. if you try to parse an <code>i32</code> when there are fewer than 4 bytes left in the data buffer. In normal Rust code we'd handle this with the <code>Result</code> enum, but for simplicity in this exercise we panic if any errors are encountered. On day 4 we'll cover error handling in Rust in more detail.</li>
</ul>
</details><h1><a class="header" href="#è§£ç­”-13" id="è§£ç­”-13">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// A wire type as seen on the wire.
enum WireType {
    /// Varint WireType è¡¨æ˜è¯¥å€¼ä¸ºå•ä¸ª VARINTã€‚
    Varint,
    /// The I64 WireType indicates that the value is precisely 8 bytes in
    /// little-endian order containing a 64-bit signed integer or double type.
    //I64,  -- not needed for this exercise
    /// The Len WireType indicates that the value is a length represented as a
    /// VARINT followed by exactly that number of bytes.
    Len,
    // The I32 WireType indicates that the value is precisely 4 bytes in
    // little-endian order containing a 32-bit signed integer or float type.
    //I32,  -- not needed for this exercise
}

#[derive(Debug)]
/// A field's value, typed based on the wire type.
enum FieldValue&lt;'a&gt; {
    Varint(u64),
    //I64(i64),  -- not needed for this exercise
    Len(&amp;'a [u8]),
    //I32(i32),  -- not needed for this exercise
}

#[derive(Debug)]
/// A field, containing the field number and its value.
struct Field&lt;'a&gt; {
    field_num: u64,
    value: FieldValue&lt;'a&gt;,
}

trait ProtoMessage&lt;'a&gt;: Default {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;);
}

impl From&lt;u64&gt; for WireType {
    fn from(value: u64) -&gt; Self {
        match value {
            0 =&gt; WireType::Varint,
            //1 =&gt; WireType::I64,  -- not needed for this exercise
            2 =&gt; WireType::Len,
            //5 =&gt; WireType::I32,  -- not needed for this exercise
            _ =&gt; panic!(&quot;Invalid wire type: {value}&quot;),
        }
    }
}

impl&lt;'a&gt; FieldValue&lt;'a&gt; {
    fn as_str(&amp;self) -&gt; &amp;'a str {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected string to be a `Len` field&quot;);
        };
        std::str::from_utf8(data).expect(&quot;Invalid string&quot;)
    }

    fn as_bytes(&amp;self) -&gt; &amp;'a [u8] {
        let FieldValue::Len(data) = self else {
            panic!(&quot;Expected bytes to be a `Len` field&quot;);
        };
        data
    }

    fn as_u64(&amp;self) -&gt; u64 {
        let FieldValue::Varint(value) = self else {
            panic!(&quot;Expected `u64` to be a `Varint` field&quot;);
        };
        *value
    }
}

/// Parse a VARINT, returning the parsed value and the remaining bytes.
fn parse_varint(data: &amp;[u8]) -&gt; (u64, &amp;[u8]) {
    for i in 0..7 {
        let Some(b) = data.get(i) else {
            panic!(&quot;Not enough bytes for varint&quot;);
        };
        if b &amp; 0x80 == 0 {
            // This is the last byte of the VARINT, so convert it to
            // a u64 and return it.
            let mut value = 0u64;
            for b in data[..=i].iter().rev() {
                value = (value &lt;&lt; 7) | (b &amp; 0x7f) as u64;
            }
            return (value, &amp;data[i + 1..]);
        }
    }

    // More than 7 bytes is invalid.
    panic!(&quot;Too many bytes for varint&quot;);
}

/// Convert a tag into a field number and a WireType.
fn unpack_tag(tag: u64) -&gt; (u64, WireType) {
    let field_num = tag &gt;&gt; 3;
    let wire_type = WireType::from(tag &amp; 0x7);
    (field_num, wire_type)
}

/// Parse a field, returning the remaining bytes
fn parse_field(data: &amp;[u8]) -&gt; (Field, &amp;[u8]) {
    let (tag, remainder) = parse_varint(data);
    let (field_num, wire_type) = unpack_tag(tag);
    let (fieldvalue, remainder) = match wire_type {
        WireType::Varint =&gt; {
            let (value, remainder) = parse_varint(remainder);
            (FieldValue::Varint(value), remainder)
        }
        WireType::Len =&gt; {
            let (len, remainder) = parse_varint(remainder);
            let len: usize = len.try_into().expect(&quot;len not a valid `usize`&quot;);
            if remainder.len() &lt; len {
                panic!(&quot;Unexpected EOF&quot;);
            }
            let (value, remainder) = remainder.split_at(len);
            (FieldValue::Len(value), remainder)
        }
    };
    (Field { field_num, value: fieldvalue }, remainder)
}

/// Parse a message in the given data, calling `T::add_field` for each field in
/// the message.
///
/// The entire input is consumed.
fn parse_message&lt;'a, T: ProtoMessage&lt;'a&gt;&gt;(mut data: &amp;'a [u8]) -&gt; T {
    let mut result = T::default();
    while !data.is_empty() {
        let parsed = parse_field(data);
        result.add_field(parsed.0);
        data = parsed.1;
    }
    result
}

#[derive(PartialEq)]
#[derive(Debug, Default)]
struct PhoneNumber&lt;'a&gt; {
    number: &amp;'a str,
    type_: &amp;'a str,
}

#[derive(PartialEq)]
#[derive(Debug, Default)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    id: u64,
    phone: Vec&lt;PhoneNumber&lt;'a&gt;&gt;,
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for Person&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.name = field.value.as_str(),
            2 =&gt; self.id = field.value.as_u64(),
            3 =&gt; self.phone.push(parse_message(field.value.as_bytes())),
            _ =&gt; {} // skip everything else
        }
    }
}

impl&lt;'a&gt; ProtoMessage&lt;'a&gt; for PhoneNumber&lt;'a&gt; {
    fn add_field(&amp;mut self, field: Field&lt;'a&gt;) {
        match field.field_num {
            1 =&gt; self.number = field.value.as_str(),
            2 =&gt; self.type_ = field.value.as_str(),
            _ =&gt; {} // skip everything else
        }
    }
}

fn main() {
    let person: Person = parse_message(&amp;[
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x77, 0x65, 0x6c, 0x6c, 0x10, 0x2a, 0x1a,
        0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35,
        0x2d, 0x31, 0x32, 0x31, 0x32, 0x12, 0x04, 0x68, 0x6f, 0x6d, 0x65, 0x1a,
        0x18, 0x0a, 0x0e, 0x2b, 0x31, 0x38, 0x30, 0x30, 0x2d, 0x38, 0x36, 0x37,
        0x2d, 0x35, 0x33, 0x30, 0x38, 0x12, 0x06, 0x6d, 0x6f, 0x62, 0x69, 0x6c,
        0x65,
    ]);
    println!(&quot;{:#?}&quot;, person);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_id() {
        let person_id: Person = parse_message(&amp;[0x10, 0x2a]);
        assert_eq!(person_id, Person { name: &quot;&quot;, id: 42, phone: vec![] });
    }

    #[test]
    fn test_name() {
        let person_name: Person = parse_message(&amp;[
            0x0a, 0x0e, 0x62, 0x65, 0x61, 0x75, 0x74, 0x69, 0x66, 0x75, 0x6c, 0x20,
            0x6e, 0x61, 0x6d, 0x65,
        ]);
        assert_eq!(
            person_name,
            Person { name: &quot;beautiful name&quot;, id: 0, phone: vec![] }
        );
    }

    #[test]
    fn test_just_person() {
        let person_name_id: Person =
            parse_message(&amp;[0x0a, 0x04, 0x45, 0x76, 0x61, 0x6e, 0x10, 0x16]);
        assert_eq!(person_name_id, Person { name: &quot;Evan&quot;, id: 22, phone: vec![] });
    }

    #[test]
    fn test_phone() {
        let phone: Person = parse_message(&amp;[
            0x0a, 0x00, 0x10, 0x00, 0x1a, 0x16, 0x0a, 0x0e, 0x2b, 0x31, 0x32, 0x33,
            0x34, 0x2d, 0x37, 0x37, 0x37, 0x2d, 0x39, 0x30, 0x39, 0x30, 0x12, 0x04,
            0x68, 0x6f, 0x6d, 0x65,
        ]);
        assert_eq!(
            phone,
            Person {
                name: &quot;&quot;,
                id: 0,
                phone: vec![PhoneNumber { number: &quot;+1234-777-9090&quot;, type_: &quot;home&quot; },],
            }
        );
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-to-day-4" id="welcome-to-day-4">Welcome to Day 4</a></h1>
<p>Today we will cover topics relating to building large-scale software in Rust:</p>
<ul>
<li>è¿­ä»£å™¨ï¼šæ·±å…¥äº†è§£ <code>Iterator</code> ç‰¹å¾ã€‚</li>
<li>æ¨¡å—å’Œå¯è§æ€§ã€‚</li>
<li>Testing.</li>
<li>é”™è¯¯å¤„ç†ï¼španicã€â€œResultâ€å’Œ try è¿ç®—ç¬¦â€œ?â€ã€‚</li>
<li>ä¸å®‰å…¨ Rustï¼šå½“æ— æ³•ç”¨å®‰å…¨ Rust è¡¨è¾¾æ‚¨çš„æ„å›¾æ—¶ï¼Œåˆ™å¯å°†å…¶ä½œä¸ºåº”æ€¥æ–¹æ³•ã€‚</li>
</ul>
<h2><a class="header" href="#æ—¶é—´è¡¨-3" id="æ—¶é—´è¡¨-3">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#è¿­ä»£å™¨" id="è¿­ä»£å™¨">è¿­ä»£å™¨</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#iterator" id="iterator"><code>Iterator</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">'Iterator'</a> trait æ”¯æŒè¿­ä»£é›†åˆä¸­çš„å€¼ã€‚å®ƒéœ€è¦ç”¨åˆ° <code>next</code> æ–¹æ³•ï¼Œå¹¶æä¾›å¾ˆå¤šæ–¹æ³•ã€‚è®¸å¤šæ ‡å‡†åº“ç±»å‹å‡èƒ½å®ç° <code>Iterator</code>ï¼Œæ‚¨ä¹Ÿå¯ä»¥è‡ªè¡Œå®ç°ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

impl Iterator for Fibonacci {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let new_next = self.curr + self.next;
        self.curr = self.next;
        self.next = new_next;
        Some(self.curr)
    }
}

fn main() {
    let fib = Fibonacci { curr: 0, next: 1 };
    for (i, n) in fib.enumerate().take(5) {
        println!(&quot;fib({i}): {n}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>Iterator</code> trait implements many common functional programming operations over collections (e.g. <code>map</code>, <code>filter</code>, <code>reduce</code>, etc). This is the trait where you can find all the documentation about them. In Rust these functions should produce the code as efficient as equivalent imperative implementations.</p>
</li>
<li>
<p><code>IntoIterator</code> æ˜¯è¿«ä½¿ for å¾ªç¯è¿ä½œçš„ç‰¹å¾ã€‚æ­¤ç‰¹å¾ç”±é›†åˆç±»å‹ ï¼ˆä¾‹å¦‚ <code>Vec&lt;T&gt;</code>ï¼‰å’Œç›¸å…³å¼•ç”¨ï¼ˆä¾‹å¦‚ <code>&amp;Vec&lt;T&gt;</code> å’Œ <code>&amp;[T]</code>ï¼‰è€Œå®ç°ã€‚æ­¤å¤–ï¼ŒèŒƒå›´ä¹Ÿä¼šå®ç°è¿™é¡¹ç‰¹å¾ã€‚å› æ­¤ï¼Œ æ‚¨å¯ä»¥ä½¿ç”¨ <code>for i in some_vec { .. }</code> æ¥éå†æŸçŸ¢é‡ï¼Œä½† <code>some_vec.next()</code> ä¸å­˜åœ¨ã€‚</p>
</li>
</ul>
</details>
<h1><a class="header" href="#intoiterator" id="intoiterator"><code>IntoIterator</code></a></h1>
<p>The <code>Iterator</code> trait tells you how to <em>iterate</em> once you have created an iterator. The related trait <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> defines how to create an iterator for a type. It is used automatically by the <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Grid {
    x_coords: Vec&lt;u32&gt;,
    y_coords: Vec&lt;u32&gt;,
}

impl IntoIterator for Grid {
    type Item = (u32, u32);
    type IntoIter = GridIter;
    fn into_iter(self) -&gt; GridIter {
        GridIter { grid: self, i: 0, j: 0 }
    }
}

struct GridIter {
    grid: Grid,
    i: usize,
    j: usize,
}

impl Iterator for GridIter {
    type Item = (u32, u32);

    fn next(&amp;mut self) -&gt; Option&lt;(u32, u32)&gt; {
        if self.i &gt;= self.grid.x_coords.len() {
            self.i = 0;
            self.j += 1;
            if self.j &gt;= self.grid.y_coords.len() {
                return None;
            }
        }
        let res = Some((self.grid.x_coords[self.i], self.grid.y_coords[self.j]));
        self.i += 1;
        res
    }
}

fn main() {
    let grid = Grid { x_coords: vec![3, 5, 7, 9], y_coords: vec![10, 20, 30, 40] };
    for (x, y) in grid {
        println!(&quot;point = {x}, {y}&quot;);
    }
}
</code></pre></pre>
<details>
<p>Click through to the docs for <code>IntoIterator</code>. Every implementation of <code>IntoIterator</code> must declare two types:</p>
<ul>
<li><code>Item</code>: the type to iterate over, such as <code>i8</code>,</li>
<li>â€œIntoIterâ€ï¼šâ€œinto_iterâ€æ–¹æ³•è¿”å›çš„â€œIteratorâ€ç±»å‹ã€‚</li>
</ul>
<p>Note that <code>IntoIter</code> and <code>Item</code> are linked: the iterator must have the same <code>Item</code> type, which means that it returns <code>Option&lt;Item&gt;</code></p>
<p>æ­¤ç¤ºä¾‹å¯¹ x åæ ‡å’Œ y åæ ‡çš„æ‰€æœ‰ç»„åˆè¿›è¡Œäº†è¿­ä»£ã€‚</p>
<p>è¯·å°è¯•åœ¨ <code>main</code> ä¸­å¯¹ç½‘æ ¼è¿›è¡Œä¸¤æ¬¡è¿­ä»£ã€‚ä¸ºä»€ä¹ˆä¼šå¤±è´¥ï¼Ÿè¯·æ³¨æ„ï¼Œ<code>IntoIterator::into_iter</code> è·å¾—äº† <code>self</code> çš„æ‰€æœ‰æƒã€‚</p>
<p>å¦‚è¦è§£å†³æ­¤é—®é¢˜ï¼Œè¯·ä¸º <code>&amp;Grid</code> å®ç° <code>IntoIterator</code>ï¼Œå¹¶åœ¨ <code>GridIter</code> ä¸­å­˜å‚¨å¯¹ <code>Grid</code> çš„å¼•ç”¨ã€‚</p>
<p>å¯¹äºæ ‡å‡†åº“ç±»å‹ï¼Œå¯èƒ½ä¼šå‡ºç°åŒæ ·çš„é—®é¢˜ï¼š<code>for e in some_vector</code> å°†è·å¾—<code> some_vector</code> çš„æ‰€æœ‰æƒï¼Œå¹¶è¿­ä»£è¯¥çŸ¢é‡ä¸­çš„è‡ªæœ‰å…ƒç´ ã€‚è¯·æ”¹ç”¨ <code>for e in &amp;some_vector</code> æ¥è¿­ä»£ <code>some_vector</code> çš„å…ƒç´ çš„å¼•ç”¨ã€‚</p>
</details><h1><a class="header" href="#fromiterator" id="fromiterator">FromIterator</a></h1>
<p><a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html"><code>FromIterator</code></a> è®©æ‚¨å¯é€šè¿‡ <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> æ„å»ºä¸€ä¸ªé›†åˆã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let primes = vec![2, 3, 5, 7];
    let prime_squares = primes.into_iter().map(|p| p * p).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;prime_squares: {prime_squares:?}&quot;);
}
</code></pre></pre>
<details>
<p><code>Iterator</code> implements</p>
<pre><code class="language-rust ignore">fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized
</code></pre>
<p>å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼ä¸ºæ­¤æ–¹æ³•æŒ‡å®š <code>B</code>ï¼š</p>
<ul>
<li>With the &quot;turbofish&quot;: <code>some_iterator.collect::&lt;COLLECTION_TYPE&gt;()</code>, as shown. The <code>_</code> shorthand used here lets Rust infer the type of the <code>Vec</code> elements.</li>
<li>ä½¿ç”¨ç±»å‹æ¨ç†åŠŸèƒ½æ—¶ï¼š<code>let prime_squares: Vec&lt;_&gt; = some_iterator.collect()</code>ã€‚å°†ç¤ºä¾‹é‡å†™æˆä½¿ç”¨è¿™ç§å½¢å¼ã€‚</li>
</ul>
<p>There are basic implementations of <code>FromIterator</code> for <code>Vec</code>, <code>HashMap</code>, etc. There are also more specialized implementations which let you do cool things like convert an <code>Iterator&lt;Item = Result&lt;V, E&gt;&gt;</code> into a <code>Result&lt;Vec&lt;V&gt;, E&gt;</code>.</p>
</details>
<h1><a class="header" href="#ç»ƒä¹ è¿­ä»£å™¨æ–¹æ³•é“¾" id="ç»ƒä¹ è¿­ä»£å™¨æ–¹æ³•é“¾">ç»ƒä¹ ï¼šè¿­ä»£å™¨æ–¹æ³•é“¾</a></h1>
<p>In this exercise, you will need to find and use some of the provided methods in the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a> trait to implement a complex calculation.</p>
<p>Copy the following code to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and make the tests pass. Use an iterator expression and <code>collect</code> the result to construct the return value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    unimplemented!()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#è§£ç­”-14" id="è§£ç­”-14">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">/// Calculate the differences between elements of `values` offset by `offset`,
/// wrapping around from the end of `values` to the beginning.
///
/// Element `n` of the result is `values[(n+offset)%len] - values[n]`.
fn offset_differences(offset: usize, values: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    let a = (&amp;values).into_iter();
    let b = (&amp;values).into_iter().cycle().skip(offset);
    a.zip(b).map(|(a, b)| *b - *a).collect()
}

#[test]
fn test_offset_one() {
    assert_eq!(offset_differences(1, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
    assert_eq!(offset_differences(1, vec![1, 3, 5]), vec![2, 2, -4]);
    assert_eq!(offset_differences(1, vec![1, 3]), vec![2, -2]);
}

#[test]
fn test_larger_offsets() {
    assert_eq!(offset_differences(2, vec![1, 3, 5, 7]), vec![4, 4, -4, -4]);
    assert_eq!(offset_differences(3, vec![1, 3, 5, 7]), vec![6, -2, -2, -2]);
    assert_eq!(offset_differences(4, vec![1, 3, 5, 7]), vec![0, 0, 0, 0]);
    assert_eq!(offset_differences(5, vec![1, 3, 5, 7]), vec![2, 2, 2, -6]);
}

#[test]
fn test_degenerate_cases() {
    assert_eq!(offset_differences(1, vec![0]), vec![0]);
    assert_eq!(offset_differences(1, vec![1]), vec![0]);
    let empty: Vec&lt;i32&gt; = vec![];
    assert_eq!(offset_differences(1, empty), vec![]);
}

fn main() {}
</code></pre></pre>
<h1><a class="header" href="#æ¨¡å—" id="æ¨¡å—">æ¨¡å—</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#æ¨¡å—-1" id="æ¨¡å—-1">æ¨¡å—</a></h1>
<p>æˆ‘ä»¬å·²çœ‹äº†â€œimplâ€å—å¦‚ä½•è®©æˆ‘ä»¬å°†å‡½æ•°çš„å‘½åç©ºé—´å»ºä¸ºä¸€ç§ç±»å‹ã€‚</p>
<p>åŒæ ·ï¼Œâ€œmodâ€è®©æˆ‘ä»¬å¯ä¸ºç±»å‹å’Œå‡½æ•°å»ºç«‹å‘½åç©ºé—´ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">mod foo {
    pub fn do_something() {
        println!(&quot;In the foo module&quot;);
    }
}

mod bar {
    pub fn do_something() {
        println!(&quot;In the bar module&quot;);
    }
}

fn main() {
    foo::do_something();
    bar::do_something();
}
</code></pre></pre>
<details>
<ul>
<li>åŒ…æä¾›åŠŸèƒ½ï¼Œå¹¶åŒ…å«ä¸€ä¸ªæè¿°å¦‚ä½•æ„å»ºåŒ…å« 1 ä¸ªä»¥ä¸Š crate çš„æ†ç»‘åŒ…çš„â€œCargo.tomlâ€æ–‡ä»¶ã€‚</li>
<li>crate æ˜¯ä¸€ç§æ¨¡å—æ ‘ï¼Œå…¶ä¸­çš„äºŒè¿›åˆ¶ crate ä¼šåˆ›å»ºä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè€Œåº“ crate ä¼šç¼–è¯‘ä¸ºåº“ã€‚</li>
<li>æ¨¡å—å®šä¹‰äº†ç»„ç»‡å’ŒèŒƒå›´ï¼Œå¹¶ä¸”æ˜¯æœ¬éƒ¨åˆ†çš„é‡ç‚¹ã€‚</li>
</ul>
</details><h1><a class="header" href="#æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„" id="æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„">æ–‡ä»¶ç³»ç»Ÿå±‚çº§ç»“æ„</a></h1>
<p>å¦‚æœçœç•¥æ¨¡å—å†…å®¹ï¼Œåˆ™ä¼šæŒ‡ç¤º Rust åœ¨å¦ä¸€ä¸ªæ–‡ä»¶ä¸­æŸ¥æ‰¾ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">mod garden;
</code></pre></pre>
<p>This tells Rust that the <code>garden</code> module content is found at <code>src/garden.rs</code>. Similarly, a <code>garden::vegetables</code> module can be found at <code>src/garden/vegetables.rs</code>.</p>
<p>â€œcrateâ€æ ¹ç›®å½•ä½äºï¼š</p>
<ul>
<li>â€œsrc/lib.rsâ€ï¼ˆå¯¹äºåº“ crateï¼‰</li>
<li>â€œsrc/main.rsâ€ï¼ˆå¯¹äºäºŒè¿›åˆ¶æ–‡ä»¶ crateï¼‰</li>
</ul>
<p>ä¹Ÿå¯ä»¥ä½¿ç”¨â€œå†…éƒ¨æ–‡æ¡£æ³¨é‡Šâ€å¯¹æ–‡ä»¶ä¸­å®šä¹‰çš„æ¨¡å—è¿›è¡Œè®°å½•ã€‚è¿™äº›ç”¨äºè®°å½•åŒ…å«å®ƒä»¬çš„é¡¹ï¼ˆåœ¨æœ¬ä¾‹ä¸­ä¸ºæ¨¡å—ï¼‰ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">//! This module implements the garden, including a highly performant germination
//! implementation.

// Re-export types from this module.
pub use garden::Garden;
pub use seeds::SeedPacket;

/// Sow the given seed packets.
pub fn sow(seeds: Vec&lt;SeedPacket&gt;) {
    todo!()
}

/// Harvest the produce in the garden that is ready.
pub fn harvest(garden: &amp;mut Garden) {
    todo!()
}
</code></pre></pre>
<details>
<ul>
<li>
<p>åœ¨ Rust 2018 ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ï¼Œæ¨¡å—éœ€è¦ä½äºâ€œmodule/mod.rsâ€è€Œéâ€œmodule.rsâ€ä¸­ï¼Œå¯¹äº 2018 å¹´ä¹‹åçš„ç‰ˆæœ¬è€Œè¨€ï¼Œè¿™ä»æ˜¯æœ‰æ•ˆçš„æ›¿ä»£æ–¹æ¡ˆã€‚</p>
</li>
<li>
<p>å¼•å…¥â€œfilename.rsâ€æ¥æ›¿ä»£â€œfilename/mod.rsâ€çš„ä¸»è¦åŸå› æ˜¯ï¼Œè®¸å¤šåä¸ºâ€œmod.rsâ€çš„æ–‡ä»¶åœ¨ IDE ä¸­å¯èƒ½éš¾ä»¥åŒºåˆ†ã€‚</p>
</li>
<li>
<p>å³ä½¿ä¸»æ¨¡å—æ˜¯æ–‡ä»¶ï¼Œæ›´æ·±å±‚çš„åµŒå¥—ä¹Ÿå¯ä»¥ä½¿ç”¨æ–‡ä»¶å¤¹ï¼š</p>
<pre><code class="language-ignore">src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ top_module.rs
â””â”€â”€ top_module/
    â””â”€â”€ sub_module.rs
</code></pre>
</li>
<li>
<p>Rust å¯»æ‰¾æ¨¡å—çš„ä½ç½®å¯é€šè¿‡ç¼–è¯‘å™¨æŒ‡ä»¤æ›´æ”¹ï¼š</p>
<pre><code class="language-rust ignore">#[path = &quot;some/path.rs&quot;]
mod some_module;
</code></pre>
<p>ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æƒ³å°†æŸä¸ªæ¨¡å—çš„æµ‹è¯•æ”¾åœ¨åä¸ºâ€œsome_module_test.rsâ€çš„æ–‡ä»¶ä¸­ï¼ˆç±»ä¼¼äº Go ä¸­çš„æƒ¯ä¾‹ï¼‰ï¼Œè¿™æ ·åšå¾ˆæœ‰ç”¨ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#å¯è§æ€§" id="å¯è§æ€§">å¯è§æ€§</a></h1>
<p>æ¨¡å—æ˜¯ä¸€ç§éšç§è¾¹ç•Œï¼š</p>
<ul>
<li>é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¨¡å—é¡¹æ˜¯ç§æœ‰çš„ï¼ˆéšè—å®ç°è¯¦æƒ…ï¼‰ã€‚</li>
<li>çˆ¶é¡¹å’ŒåŒçº§å­é¡¹å§‹ç»ˆå¯è§ã€‚</li>
<li>æ¢è¨€ä¹‹ï¼Œå¦‚æœæŸä¸ªé¡¹åœ¨æ¨¡å—â€œfooâ€ä¸­å¯è§ï¼Œé‚£ä¹ˆè¯¥é¡¹åœ¨â€œfooâ€çš„æ‰€æœ‰åä»£ä¸­å‡å¯è§ã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">mod outer {
    fn private() {
        println!(&quot;outer::private&quot;);
    }

    pub fn public() {
        println!(&quot;outer::public&quot;);
    }

    mod inner {
        fn private() {
            println!(&quot;outer::inner::private&quot;);
        }

        pub fn public() {
            println!(&quot;outer::inner::public&quot;);
            super::private();
        }
    }
}

fn main() {
    outer::public();
}
</code></pre></pre>
<details>
<ul>
<li>ä½¿ç”¨â€œpubâ€å…³é”®å­—å°†æ¨¡å—è®¾ä¸ºå…¬å¼€ã€‚</li>
</ul>
<p>æ­¤å¤–ï¼Œæ‚¨è¿˜å¯ä»¥ä½¿ç”¨é«˜çº§â€œpub(...)â€è¯´æ˜ç¬¦æ¥é™åˆ¶å…¬å¼€å¯è§çš„èŒƒå›´ã€‚</p>
<ul>
<li>è¯·å‚é˜… <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">Rust å‚è€ƒ</a>ã€‚</li>
<li>é…ç½®â€œpub(crate)â€å¯è§æ€§æ˜¯ä¸€ç§å¸¸è§æ¨¡å¼ã€‚</li>
<li>æ‚¨å¯ä»¥ä¸ºç‰¹å®šè·¯å¾„æˆäºˆå¯è§æ€§ï¼Œè¿™ç§æƒ…å†µä¸å¤ªå¸¸è§ã€‚</li>
<li>åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œéƒ½å¿…é¡»å‘ç¥–å…ˆæ¨¡å—ï¼ˆåŠå…¶æ‰€æœ‰åä»£ï¼‰æˆäºˆå¯è§æ€§ã€‚</li>
</ul>
</details><h1><a class="header" href="#usesuperself" id="usesuperself">useã€superã€self</a></h1>
<p>ä¸€ä¸ªæ¨¡å—å¯ä»¥ä½¿ç”¨â€œuseâ€å°†å¦ä¸€ä¸ªæ¨¡å—çš„ç¬¦å·å…¨éƒ¨çº³å…¥ã€‚æ‚¨é€šå¸¸åœ¨æ¯ä¸ªæ¨¡å—çš„é¡¶éƒ¨ä¼šçœ‹åˆ°å¦‚ä¸‹å†…å®¹ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashSet;
use std::process::abort;
</code></pre></pre>
<h2><a class="header" href="#è·¯å¾„" id="è·¯å¾„">è·¯å¾„</a></h2>
<p>è·¯å¾„è§£æå¦‚ä¸‹ï¼š</p>
<ol>
<li>
<p>ä½œä¸ºç›¸å¯¹è·¯å¾„ï¼š</p>
<ul>
<li><code>foo</code> æˆ– <code>self::foo</code> æ˜¯æŒ‡å½“å‰æ¨¡å—ä¸­çš„ <code>foo</code>ï¼Œ</li>
<li>â€œsuper::fooâ€æ˜¯æŒ‡çˆ¶æ¨¡å—ä¸­çš„â€œfooâ€ã€‚</li>
</ul>
</li>
<li>
<p>ä½œä¸ºç»å¯¹è·¯å¾„ï¼š</p>
<ul>
<li><code>crate::foo</code> æ˜¯æŒ‡å½“å‰ crate çš„æ ¹ä¸­çš„ <code>foo</code>ï¼Œ</li>
<li>â€œbar::fooâ€æ˜¯æŒ‡â€œbarâ€crate ä¸­çš„â€œfooâ€ã€‚</li>
</ul>
</li>
</ol>
<details>
<ul>
<li>
<p>é€šå¸¸ä½¿ç”¨è¾ƒçŸ­çš„è·¯å¾„æ¥ â€œé‡æ–°å¯¼å‡ºâ€ç¬¦å·ã€‚ä¾‹å¦‚ï¼Œcrate ä¸­çš„é¡¶å±‚ <code>lib.rs</code> æ–‡ä»¶å¯èƒ½ä¼š</p>
<pre><code class="language-rust ignore">mod storage;

pub use storage::disk::DiskStorage;
pub use storage::network::NetworkStorage;
</code></pre>
<p>é€šè¿‡ä¾¿æ·çš„çŸ­è·¯å¾„ï¼Œä½¿å¾— <code>DiskStorage</code> å’Œ <code>NetworkStorage</code> å¯ä¾›å…¶ä»– crate ä½¿ç”¨ã€‚</p>
</li>
<li>
<p>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œåªæœ‰æ¨¡å—ä¸­æ˜¾ç¤ºçš„é¡¹æ‰éœ€é€šè¿‡ <code>use</code> å¼•å…¥ã€‚ä¸è¿‡ï¼Œå³ä½¿å®ç°è¯¥ trait çš„ç±»å‹å·²å¤„äºä½œç”¨åŸŸå†…ï¼Œå¦‚è¦è°ƒç”¨è¯¥ trait çš„ä»»ä½•æ–¹æ³•ï¼Œä»éœ€å°†è¯¥ trait å¼•å…¥åˆ°ä½œç”¨åŸŸå†…ã€‚ä¾‹å¦‚ï¼Œå¦‚éœ€å¯¹å®ç° <code>Read</code> trait çš„ç±»å‹ä½¿ç”¨ <code>read_to_string</code> æ–¹æ³•ï¼Œæ‚¨éœ€è¦ä½¿ç”¨ <code>use std::io::Read</code> å¼•å…¥ã€‚</p>
</li>
<li>
<p><code>use</code> è¯­å¥å¯ä»¥åŒ…å«é€šé…ç¬¦ï¼š<code>use std::io::*</code>ã€‚ä½†ä¸æ¨èè¿™ç§åšæ³•ï¼Œå› ä¸ºä¸æ¸…æ¥šå¯¼å…¥äº†å“ªäº›é¡¹ï¼Œå¹¶ä¸”è¿™äº›å†…å®¹å¯èƒ½ä¼šéšæ—¶é—´è€Œå˜åŒ–ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ é¢å‘-gui-åº“çš„æ¨¡å—" id="ç»ƒä¹ é¢å‘-gui-åº“çš„æ¨¡å—">ç»ƒä¹ ï¼šé¢å‘ GUI åº“çš„æ¨¡å—</a></h1>
<p>In this exercise, you will reorganize a small GUI Library implementation. This library defines a <code>Widget</code> trait and a few implementations of that trait, as well as a <code>main</code> function.</p>
<p>It is typical to put each type or set of closely-related types into its own module, so each widget type should get its own module.</p>
<h2><a class="header" href="#cargo-setup" id="cargo-setup">Cargo Setup</a></h2>
<p>Rust Playground ä»…æ”¯æŒä¸€ä¸ªæ–‡ä»¶ï¼Œå› æ­¤æ‚¨éœ€è¦åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šåˆ›å»ºä¸€ä¸ª Cargo é¡¹ç›®ï¼š</p>
<pre><code class="language-shell">cargo init gui-modules
cd gui-modules
cargo run
</code></pre>
<p>Edit the resulting <code>src/main.rs</code> to add <code>mod</code> statements, and add additional files in the <code>src</code> directory.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>Here's the single-module implementation of the GUI library:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub struct Label {
    label: String,
}

impl Label {
    fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

pub struct Button {
    label: Label,
}

impl Button {
    fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: Change draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use the
        // ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        self.label.width() + 8 // add a bit of padding
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}

fn main() {
    let mut window = Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window.add_widget(Box::new(Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(Button::new(&quot;Click me!&quot;)));
    window.draw();
}
</code></pre></pre>
<details>
<p>é¼“åŠ±å­¦ç”ŸæŒ‰ç…§è‡ªå·±è®¤ä¸ºåˆé€‚çš„æ–¹å¼åˆ’åˆ†ä»£ç ï¼Œå¹¶ç†Ÿæ‚‰å¿…éœ€çš„ <code>mod</code>ã€<code>use</code> å’Œ <code>pub</code> å£°æ˜ã€‚ä¹‹åï¼Œè®¨è®ºå“ªäº›ç»„ç»‡æ–¹å¼æœ€ç¬¦åˆæƒ¯ä¾‹ã€‚</p>
</details><h1><a class="header" href="#è§£ç­”-15" id="è§£ç­”-15">è§£ç­”</a></h1>
<!--
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
-->
<pre><code class="language-ignore">src
â”œâ”€â”€ main.rs
â”œâ”€â”€ widgets
â”‚Â Â  â”œâ”€â”€ button.rs
â”‚Â Â  â”œâ”€â”€ label.rs
â”‚Â Â  â””â”€â”€ window.rs
â””â”€â”€ widgets.rs
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets.rs ----
mod button;
mod label;
mod window;

pub trait Widget {
    /// Natural width of `self`.
    fn width(&amp;self) -&gt; usize;

    /// Draw the widget into a buffer.
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write);

    /// Draw the widget on standard output.
    fn draw(&amp;self) {
        let mut buffer = String::new();
        self.draw_into(&amp;mut buffer);
        println!(&quot;{buffer}&quot;);
    }
}

pub use button::Button;
pub use label::Label;
pub use window::Window;
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/label.rs ----
use super::Widget;

pub struct Label {
    label: String,
}

impl Label {
    pub fn new(label: &amp;str) -&gt; Label {
        Label { label: label.to_owned() }
    }
}

impl Widget for Label {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Label-width
        self.label.lines().map(|line| line.chars().count()).max().unwrap_or(0)
    }

    // ANCHOR: Label-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Label-draw_into
        writeln!(buffer, &quot;{}&quot;, &amp;self.label).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/button.rs ----
use super::{Label, Widget};

pub struct Button {
    label: Label,
}

impl Button {
    pub fn new(label: &amp;str) -&gt; Button {
        Button { label: Label::new(label) }
    }
}

impl Widget for Button {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Button-width
        self.label.width() + 8 // add a bit of padding
    }

    // ANCHOR: Button-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Button-draw_into
        let width = self.width();
        let mut label = String::new();
        self.label.draw_into(&amp;mut label);

        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
        for line in label.lines() {
            writeln!(buffer, &quot;|{:^width$}|&quot;, &amp;line).unwrap();
        }
        writeln!(buffer, &quot;+{:-&lt;width$}+&quot;, &quot;&quot;).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/widgets/window.rs ----
use super::Widget;

pub struct Window {
    title: String,
    widgets: Vec&lt;Box&lt;dyn Widget&gt;&gt;,
}

impl Window {
    pub fn new(title: &amp;str) -&gt; Window {
        Window { title: title.to_owned(), widgets: Vec::new() }
    }

    pub fn add_widget(&amp;mut self, widget: Box&lt;dyn Widget&gt;) {
        self.widgets.push(widget);
    }

    fn inner_width(&amp;self) -&gt; usize {
        std::cmp::max(
            self.title.chars().count(),
            self.widgets.iter().map(|w| w.width()).max().unwrap_or(0),
        )
    }
}

impl Widget for Window {
    fn width(&amp;self) -&gt; usize {
        // ANCHOR_END: Window-width
        // Add 4 paddings for borders
        self.inner_width() + 4
    }

    // ANCHOR: Window-draw_into
    fn draw_into(&amp;self, buffer: &amp;mut dyn std::fmt::Write) {
        // ANCHOR_END: Window-draw_into
        let mut inner = String::new();
        for widget in &amp;self.widgets {
            widget.draw_into(&amp;mut inner);
        }

        let inner_width = self.inner_width();

        // TODO: after learning about error handling, you can change
        // draw_into to return Result&lt;(), std::fmt::Error&gt;. Then use
        // the ?-operator here instead of .unwrap().
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
        writeln!(buffer, &quot;| {:^inner_width$} |&quot;, &amp;self.title).unwrap();
        writeln!(buffer, &quot;+={:=&lt;inner_width$}=+&quot;, &quot;&quot;).unwrap();
        for line in inner.lines() {
            writeln!(buffer, &quot;| {:inner_width$} |&quot;, line).unwrap();
        }
        writeln!(buffer, &quot;+-{:-&lt;inner_width$}-+&quot;, &quot;&quot;).unwrap();
    }
}
</code></pre>
<pre><code class="language-rust ignore">// ---- src/main.rs ----
mod widgets;

use widgets::Widget;

fn main() {
    let mut window = widgets::Window::new(&quot;Rust GUI Demo 1.23&quot;);
    window
        .add_widget(Box::new(widgets::Label::new(&quot;This is a small text GUI demo.&quot;)));
    window.add_widget(Box::new(widgets::Button::new(&quot;Click me!&quot;)));
    window.draw();
}
</code></pre>
<h1><a class="header" href="#æµ‹è¯•" id="æµ‹è¯•">æµ‹è¯•</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å•å…ƒæµ‹è¯•" id="å•å…ƒæµ‹è¯•">å•å…ƒæµ‹è¯•</a></h1>
<p>Rust å’Œ Cargo éšé™„äº†ä¸€ä¸ªç®€å•çš„å•å…ƒæµ‹è¯•æ¡†æ¶ï¼š</p>
<ul>
<li>
<p>å•å…ƒæµ‹è¯•åœ¨æ‚¨çš„æ•´ä¸ªä»£ç ä¸­éƒ½å—æ”¯æŒã€‚</p>
</li>
<li>
<p>æ‚¨å¯ä»¥é€šè¿‡ <code>tests/</code> ç›®å½•æ¥æ”¯æŒé›†æˆæµ‹è¯•ã€‚</p>
</li>
</ul>
<p>Tests are marked with <code>#[test]</code>. Unit tests are often put in a nested <code>tests</code> module, using <code>#[cfg(test)]</code> to conditionally compile them only when building tests.</p>
<pre><code class="language-rust editable ignore">fn first_word(text: &amp;str) -&gt; &amp;str {
    match text.find(' ') {
        Some(idx) =&gt; &amp;text[..idx],
        None =&gt; &amp;text,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty() {
        assert_eq!(first_word(&quot;&quot;), &quot;&quot;);
    }

    #[test]
    fn test_single_word() {
        assert_eq!(first_word(&quot;Hello&quot;), &quot;Hello&quot;);
    }

    #[test]
    fn test_multiple_words() {
        assert_eq!(first_word(&quot;Hello World&quot;), &quot;Hello&quot;);
    }
}
</code></pre>
<ul>
<li>è¿™æ ·ä¸€æ¥ï¼Œæ‚¨å¯ä»¥å¯¹ä¸“ç”¨å¸®åŠ©ç¨‹åºè¿›è¡Œå•å…ƒæµ‹è¯•ã€‚</li>
<li>ä»…å½“æ‚¨è¿è¡Œ <code>cargo test</code> æ—¶ï¼Œ<code>#[cfg(test)]</code> å±æ€§æ‰æœ‰æ•ˆã€‚</li>
</ul>
<details>
<p>åœ¨ Playground ä¸­è¿è¡Œæµ‹è¯•æ˜¾ç¤ºæµ‹è¯•ç»“æœã€‚</p>
</details><h1><a class="header" href="#å…¶ä»–ç±»å‹çš„æµ‹è¯•" id="å…¶ä»–ç±»å‹çš„æµ‹è¯•">å…¶ä»–ç±»å‹çš„æµ‹è¯•</a></h1>
<h2><a class="header" href="#é›†æˆæµ‹è¯•" id="é›†æˆæµ‹è¯•">é›†æˆæµ‹è¯•</a></h2>
<p>å¦‚æœæ‚¨æƒ³è¦ä»¥å®¢æˆ·çš„èº«ä»½æµ‹è¯•æ‚¨çš„åº“ï¼Œè¯·ä½¿ç”¨é›†æˆæµ‹è¯•ã€‚</p>
<p>åœ¨ <code>tests/</code> ä¸‹æ–¹åˆ›å»ºä¸€ä¸ª <code>.rs</code> æ–‡ä»¶ï¼š</p>
<pre><code class="language-rust ignore">// tests/my_library.rs
use my_library::init;

#[test]
fn test_init() {
    assert!(init().is_ok());
}
</code></pre>
<p>è¿™äº›æµ‹è¯•åªèƒ½ä½¿ç”¨æ‚¨çš„ crate çš„å…¬å…± APIã€‚</p>
<h2><a class="header" href="#æ–‡æ¡£æµ‹è¯•" id="æ–‡æ¡£æµ‹è¯•">æ–‡æ¡£æµ‹è¯•</a></h2>
<p>Rust æœ¬èº«å°±æ”¯æŒæ–‡æ¡£æµ‹è¯•ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Shortens a string to the given length.
///
/// ```
/// # use playground::shorten_string;
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 5), &quot;Hello&quot;);
/// assert_eq!(shorten_string(&quot;Hello World&quot;, 20), &quot;Hello World&quot;);
/// ```
pub fn shorten_string(s: &amp;str, length: usize) -&gt; &amp;str {
    &amp;s[..std::cmp::min(length, s.len())]
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>///</code> æ³¨é‡Šä¸­çš„ä»£ç å—ä¼šè‡ªåŠ¨è¢«è§†ä¸º Rust ä»£ç ã€‚</li>
<li>ä»£ç ä¼šä½œä¸º <code>cargo test</code> çš„ä¸€éƒ¨åˆ†è¿›è¡Œç¼–è¯‘å’Œæ‰§è¡Œã€‚</li>
<li>Adding <code>#</code> in the code will hide it from the docs, but will still compile/run it.</li>
<li>åœ¨ <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ce2ad13ea1302f6572cb15cd96becf0">Rust Playground</a> ä¸Šæµ‹è¯•ä¸Šè¿°ä»£ç ã€‚</li>
</ul>
<h1><a class="header" href="#ç¼–è¯‘å™¨-lint-å’Œ-clippy" id="ç¼–è¯‘å™¨-lint-å’Œ-clippy">ç¼–è¯‘å™¨ Lint å’Œ Clippy</a></h1>
<p>Rust ç¼–è¯‘å™¨ä¼šç”Ÿæˆå‡ºè‰²çš„é”™è¯¯æ¶ˆæ¯ï¼Œå¹¶æä¾›å®ç”¨çš„å†…ç½® lint åŠŸèƒ½ã€‚<a href="https://doc.rust-lang.org/clippy/">Clippy</a> æä¾›äº†æ›´å¤š lint åŠŸèƒ½ï¼Œé‡‡ç”¨æŒ‰ç»„åˆ†ç±»æ–¹å¼ï¼Œå¹¶å¯æŒ‰é¡¹ç›®çµæ´»å¯ç”¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">#[deny(clippy::cast_possible_truncation)]
fn main() {
    let x = 3;
    while (x &lt; 70000) {
        x *= 2;
    }
    println!(&quot;X probably fits in a u16, right? {}&quot;, x as u16);
}
</code></pre></pre>
<details>
<p>è¿è¡Œä»£ç ç¤ºä¾‹å¹¶æ£€æŸ¥é”™è¯¯æ¶ˆæ¯ã€‚æ­¤å¤„è¿˜ä¼šæ˜¾ç¤ºä¸€äº› lintï¼Œä½†æ˜¯ä¸€æ—¦å®Œæˆä»£ç ç¼–è¯‘ï¼Œå°±ä¸ä¼šå†æ˜¾ç¤ºè¿™äº› lintã€‚åˆ‡æ¢åˆ° Playground ç½‘ç«™ä»¥æ˜¾ç¤ºè¿™äº› lintã€‚</p>
<p>è§£æå®Œ lint ä¹‹åï¼Œè¯·åœ¨ Playground ç½‘ç«™ä¸Šè¿è¡Œ <code>clippy</code>ï¼Œä»¥æ˜¾ç¤º clippy è­¦å‘Šã€‚Clippy æä¾›äº†å¤§é‡çš„ lint æ–‡æ¡£ï¼Œå¹¶ä¸”åœ¨ä¸æ–­æ·»åŠ æ–°çš„ lintï¼ˆåŒ…æ‹¬é»˜è®¤æ‹’ç» lintï¼‰ã€‚</p>
<p>è¯·æ³¨æ„ï¼Œå¸¦æœ‰ <code>help: ...</code> çš„é”™è¯¯æˆ–è­¦å‘Šå¯ä»¥é€šè¿‡ <code>cargo Fix</code> æˆ–ç¼–è¾‘å™¨è¿›è¡Œä¿®å¤ã€‚</p>
</details><h1><a class="header" href="#ç»ƒä¹ å¢æ©ç®—æ³•" id="ç»ƒä¹ å¢æ©ç®—æ³•">ç»ƒä¹ ï¼šå¢æ©ç®—æ³•</a></h1>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%A2%E6%81%A9%E7%AE%97%E6%B3%95">å¢æ©ç®—æ³•</a>ç”¨äºéªŒè¯ä¿¡ç”¨å¡å·ã€‚è¯¥ç®—æ³•å°†å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥å†…å®¹ï¼Œå¹¶æ‰§è¡Œä»¥ä¸‹æ“ä½œæ¥éªŒè¯ä¿¡ç”¨å¡å·ï¼š</p>
<ul>
<li>
<p>Ignore all spaces. Reject numbers with fewer than two digits.</p>
</li>
<li>
<p>ä»<strong>å³åˆ°å·¦</strong>ï¼Œå°†å¶æ•°ä½çš„æ•°å­—ä¹˜äºŒã€‚å¯¹äºæ•°å­—â€œ1234â€ï¼Œæˆ‘ä»¬å°†â€œ3â€å’Œâ€œ1â€ä¹˜äºŒï¼›å¯¹äºæ•°å­—â€œ98765â€ï¼Œå°†â€œ6â€å’Œâ€œ8â€ä¹˜äºŒã€‚</p>
</li>
<li>
<p>å°†ä¸€ä¸ªæ•°å­—ä¹˜äºŒåï¼Œå¦‚æœç»“æœå¤§äº 9ï¼Œåˆ™å°†æ¯ä½æ•°å­—ç›¸åŠ ã€‚å› æ­¤ï¼Œå°†â€œ7â€ä¹˜äºŒå¾—â€œ14â€ï¼Œç„¶åâ€œ1 + 4 = 5â€ã€‚</p>
</li>
<li>
<p>å°†æ‰€æœ‰æœªä¹˜äºŒå’Œå·²ä¹˜äºŒçš„æ•°å­—ç›¸åŠ ã€‚</p>
</li>
<li>
<p>å¦‚æœæ€»å’Œä»¥â€œ0â€ç»“å°¾ï¼Œåˆ™ä¿¡ç”¨å¡å·æœ‰æ•ˆã€‚</p>
</li>
</ul>
<p>The provided code provides a buggy implementation of the luhn algorithm, along with two basic unit tests that confirm that most of the algorithm is implemented correctly.</p>
<p>Copy the code below to <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> and write additional tests to uncover bugs in the provided implementation, fixing any bugs you find.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn(&quot;4263 9826 4026 9299&quot;));
        assert!(luhn(&quot;4539 3195 0343 6467&quot;));
        assert!(luhn(&quot;7992 7398 713&quot;));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
        assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
        assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#è§£ç­”-16" id="è§£ç­”-16">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">// This is the buggy version that appears in the problem.
#[cfg(never)]
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else {
            continue;
        }
    }

    sum % 10 == 0
}

// This is the solution and passes all of the tests below.
pub fn luhn(cc_number: &amp;str) -&gt; bool {
    let mut sum = 0;
    let mut double = false;
    let mut digits = 0;

    for c in cc_number.chars().rev() {
        if let Some(digit) = c.to_digit(10) {
            digits += 1;
            if double {
                let double_digit = digit * 2;
                sum +=
                    if double_digit &gt; 9 { double_digit - 9 } else { double_digit };
            } else {
                sum += digit;
            }
            double = !double;
        } else if c.is_whitespace() {
            // New: accept whitespace.
            continue;
        } else {
            // New: reject all other characters.
            return false;
        }
    }

    // New: check that we have at least two digits
    digits &gt;= 2 &amp;&amp; sum % 10 == 0
}

fn main() {
    let cc_number = &quot;1234 5678 1234 5670&quot;;
    println!(
        &quot;Is {cc_number} a valid credit card number? {}&quot;,
        if luhn(cc_number) { &quot;yes&quot; } else { &quot;no&quot; }
    );
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_valid_cc_number() {
        assert!(luhn(&quot;4263 9826 4026 9299&quot;));
        assert!(luhn(&quot;4539 3195 0343 6467&quot;));
        assert!(luhn(&quot;7992 7398 713&quot;));
    }

    #[test]
    fn test_invalid_cc_number() {
        assert!(!luhn(&quot;4223 9826 4026 9299&quot;));
        assert!(!luhn(&quot;4539 3195 0343 6476&quot;));
        assert!(!luhn(&quot;8273 1232 7352 0569&quot;));
    }

    #[test]
    fn test_non_digit_cc_number() {
        assert!(!luhn(&quot;foo&quot;));
        assert!(!luhn(&quot;foo 0 0&quot;));
    }

    #[test]
    fn test_empty_cc_number() {
        assert!(!luhn(&quot;&quot;));
        assert!(!luhn(&quot; &quot;));
        assert!(!luhn(&quot;  &quot;));
        assert!(!luhn(&quot;    &quot;));
    }

    #[test]
    fn test_single_digit_cc_number() {
        assert!(!luhn(&quot;0&quot;));
    }

    #[test]
    fn test_two_digit_cc_number() {
        assert!(luhn(&quot; 0 0 &quot;));
    }
}
</code></pre></pre>
<h1><a class="header" href="#welcome-back-3" id="welcome-back-3">Welcome Back</a></h1>
<p>{{%session outline}}</p>
<h1><a class="header" href="#é”™è¯¯å¤„ç†" id="é”™è¯¯å¤„ç†">é”™è¯¯å¤„ç†</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#panics" id="panics">Panics</a></h1>
<p>Rust é€šè¿‡ â€œpanicâ€æœºåˆ¶å¤„ç†ä¸¥é‡é”™è¯¯ã€‚</p>
<p>å¦‚æœè¿è¡Œæ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯ï¼ŒRust ä¼šè§¦å‘ panicï¼š</p>
<pre><pre class="playground"><code class="language-rust editable should_panic">fn main() {
    let v = vec![10, 20, 30];
    println!(&quot;v[100]: {}&quot;, v[100]);
}
</code></pre></pre>
<ul>
<li>Panic ç”¨äºæŒ‡ç¤ºä¸å¯æ¢å¤çš„æ„å¤–é”™è¯¯ã€‚
<ul>
<li>Panicåæ˜ äº†ç¨‹åºä¸­çš„ bug é—®é¢˜ã€‚</li>
<li>è¿è¡Œæ—¶å¤±è´¥ï¼ˆä¾‹å¦‚è¾¹ç•Œæ£€æŸ¥å¤±è´¥ï¼‰å¯èƒ½ä¼šè§¦å‘ panic</li>
<li>æ–­è¨€ï¼ˆä¾‹å¦‚ <code>assert!</code>ï¼‰åœ¨å¤±è´¥æ—¶ä¼šè§¦å‘ panic</li>
<li>é’ˆå¯¹ç‰¹å®šç”¨é€”çš„ panic å¯ä»¥ä½¿ç”¨ <code>panic!</code> å®ã€‚</li>
</ul>
</li>
<li>ä½¿ç”¨ panic ä¼š â€œå±•å¼€â€å †æ ˆï¼Œå¹¶ä¸¢å¼ƒå¯¹åº”çš„å€¼ï¼Œå°±åƒå‡½æ•°å·²ç»è¿”å›ä¸€æ ·ã€‚</li>
<li>å¦‚æœå´©æºƒä¸å¯æ¥å—ï¼Œè¯·ä½¿ç”¨ä¸ä¼šè§¦å‘ panic çš„ APIï¼ˆä¾‹å¦‚ <code>Vec::get</code>ï¼‰ã€‚</li>
</ul>
<details>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œpanic ä¼šå¯¼è‡´å †æ ˆå±•å¼€ã€‚æ‚¨å¯ä»¥æ•è·å±•å¼€ä¿¡æ¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::panic;

fn main() {
    let result = panic::catch_unwind(|| &quot;No problem here!&quot;);
    println!(&quot;{result:?}&quot;);

    let result = panic::catch_unwind(|| {
        panic!(&quot;oh no!&quot;);
    });
    println!(&quot;{result:?}&quot;);
}
</code></pre></pre>
<ul>
<li>æ•è·å¼‚å¸¸ï¼›è¯·å‹¿å°è¯•ä½¿ç”¨ <code>catch_unwind</code> å®ç°å¼‚å¸¸ï¼</li>
<li>å¦‚æœæœåŠ¡å™¨éœ€è¦æŒç»­è¿è¡Œï¼ˆå³ä½¿æ˜¯åœ¨è¯·æ±‚å‘ç”Ÿå´©æºƒçš„æƒ…å†µä¸‹ï¼‰ï¼Œ æ­¤æ–¹æ³•ååˆ†æœ‰ç”¨ã€‚</li>
<li>å¦‚æœæ‚¨åœ¨ <code>Cargo.toml</code> ä¸­è®¾ç½®äº† <code>panic = 'abort'</code>ï¼Œæ­¤æ–¹æ³•ä¸ä¼šç”Ÿæ•ˆã€‚</li>
</ul>
</details><h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>Our primary mechanism for error handling in Rust is the <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> enum, which we briefly saw when discussing standard library types.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fs::File;
use std::io::Read;

fn main() {
    let file: Result&lt;File, std::io::Error&gt; = File::open(&quot;diary.txt&quot;);
    match file {
        Ok(mut file) =&gt; {
            let mut contents = String::new();
            if let Ok(bytes) = file.read_to_string(&amp;mut contents) {
                println!(&quot;Dear diary: {contents} ({bytes} bytes)&quot;);
            } else {
                println!(&quot;Could not read file content&quot;);
            }
        }
        Err(err) =&gt; {
            println!(&quot;The diary could not be opened: {err}&quot;);
        }
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>Result</code> has two variants: <code>Ok</code> which contains the success value, and <code>Err</code> which contains an error value of some kind.</p>
</li>
<li>
<p>Whether or not a function can produce an error is encoded in the function's type signature by having the function return a <code>Result</code> value.</p>
</li>
<li>
<p>Like with <code>Option</code>, there is no way to forget to handle an error: You cannot access either the success value or the error value without first pattern matching on the <code>Result</code> to check which variant you have. Methods like <code>unwrap</code> make it easier to write quick-and-dirty code that doesn't do robust error handling, but means that you can always see in your source code where proper error handling is being skipped.</p>
</li>
</ul>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-6" id="æ¢ç´¢æ›´å¤š-6">æ¢ç´¢æ›´å¤š</a></h1>
<p>It may be helpful to compare error handling in Rust to error handling conventions that students may be familiar with from other programming languages.</p>
<h2><a class="header" href="#å¼‚å¸¸" id="å¼‚å¸¸">å¼‚å¸¸</a></h2>
<ul>
<li>
<p>Many languages use exceptions, e.g. C++, Java, Python.</p>
</li>
<li>
<p>In most languages with exceptions, whether or not a function can throw an exception is not visible as part of its type signature. This generally means that you can't tell when calling a function if it may throw an exception or not.</p>
</li>
<li>
<p>Exceptions generally unwind the call stack, propagating upward until a <code>try</code> block is reached. An error originating deep in the call stack may impact an unrelated function further up.</p>
</li>
</ul>
<h2><a class="header" href="#error-numbers" id="error-numbers">Error Numbers</a></h2>
<ul>
<li>
<p>Some languages have functions return an error number (or some other error value) separately from the successful return value of the function. Examples include C and Go.</p>
</li>
<li>
<p>Depending on the language it may be possible to forget to check the error value, in which case you may be accessing an uninitialized or otherwise invalid success value.</p>
</li>
</ul>
</details><h1><a class="header" href="#å°è¯•è¿ç®—ç¬¦" id="å°è¯•è¿ç®—ç¬¦">å°è¯•è¿ç®—ç¬¦</a></h1>
<p>Runtime errors like connection-refused or file-not-found are handled with the <code>Result</code> type, but matching this type on every call can be cumbersome. The try-operator <code>?</code> is used to return errors to the caller. It lets you turn the common</p>
<pre><code class="language-rust ignore">match some_expression {
    Ok(value) =&gt; value,
    Err(err) =&gt; return Err(err),
}
</code></pre>
<p>è½¬æ¢æˆæ›´ç®€å•çš„å‘½ä»¤</p>
<pre><code class="language-rust ignore">some_expression?
</code></pre>
<p>We can use this to simplify our error handling code:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::Read;
use std::{fs, io};

fn read_username(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = fs::File::open(path);
    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err),
    };

    let mut username = String::new();
    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;alice&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>ç®€åŒ– <code>read_username</code> å‡½æ•°ä»¥ä½¿ç”¨ <code>?</code>ã€‚</p>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li><code>username</code> å˜é‡å¯ä»¥æ˜¯ <code>Ok(string)</code> æˆ– <code>Err(error)</code>ã€‚</li>
<li>å¯ä»¥ä½¿ç”¨ <code>fs::write</code> è°ƒç”¨æ¥æµ‹è¯•ä¸åŒçš„åœºæ™¯ï¼šæ²¡æœ‰æ–‡ä»¶ã€ç©ºæ–‡ä»¶ã€åŒ…å«ç”¨æˆ·åçš„æ–‡ä»¶ã€‚</li>
<li>Note that <code>main</code> can return a <code>Result&lt;(), E&gt;</code> as long as it implements <code>std::process::Termination</code>. In practice, this means that <code>E</code> implements <code>Debug</code>. The executable will print the <code>Err</code> variant and return a nonzero exit status on error.</li>
</ul>
</details><h1><a class="header" href="#å°è¯•è½¬æ¢" id="å°è¯•è½¬æ¢">å°è¯•è½¬æ¢</a></h1>
<p><code>?</code> çš„æœ‰æ•ˆå±•å¼€æ¯”å‰é¢ä»‹ç»çš„å†…å®¹ç•¥å¾®å¤æ‚ä¸€äº›ï¼š</p>
<pre><code class="language-rust ignore">expression?
</code></pre>
<p>æ•ˆæœç­‰åŒäº</p>
<pre><code class="language-rust ignore">match expression {
    Ok(value) =&gt; value,
    Err(err)  =&gt; return Err(From::from(err)),
}
</code></pre>
<p>The <code>From::from</code> call here means we attempt to convert the error type to the type returned by the function. This makes it easy to encapsulate errors into higher-level errors.</p>
<h2><a class="header" href="#ç¤ºä¾‹-1" id="ç¤ºä¾‹-1">ç¤ºä¾‹</a></h2>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::io::Read;
use std::{fmt, fs, io};

#[derive(Debug)]
enum ReadUsernameError {
    IoError(io::Error),
    EmptyUsername(String),
}

impl Error for ReadUsernameError {}

impl fmt::Display for ReadUsernameError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Self::IoError(e) =&gt; write!(f, &quot;I/O error: {e}&quot;),
            Self::EmptyUsername(path) =&gt; write!(f, &quot;Found no username in {path}&quot;),
        }
    }
}

impl From&lt;io::Error&gt; for ReadUsernameError {
    fn from(err: io::Error) -&gt; Self {
        Self::IoError(err)
    }
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //std::fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    let username = read_username(&quot;config.dat&quot;);
    println!(&quot;username or error: {username:?}&quot;);
}
</code></pre></pre>
<details>
<p>The <code>?</code> operator must return a value compatible with the return type of the function. For <code>Result</code>, it means that the error types have to be compatible. A function that returns <code>Result&lt;T, ErrorOuter&gt;</code> can only use <code>?</code> on a value of type <code>Result&lt;U, ErrorInner&gt;</code> if <code>ErrorOuter</code> and <code>ErrorInner</code> are the same type or if <code>ErrorOuter</code> implements <code>From&lt;ErrorInner&gt;</code>.</p>
<p><code>From</code> å®ç°çš„å¸¸è§æ›¿ä»£æ–¹æ¡ˆæ˜¯ <code>Result::map_err</code>ï¼Œå°¤å…¶æ˜¯åªåœ¨ä¸€ä¸ªä½ç½®è¿›è¡Œè½¬æ¢æ—¶ã€‚</p>
<p>There is no compatibility requirement for <code>Option</code>. A function returning <code>Option&lt;T&gt;</code> can use the <code>?</code> operator on <code>Option&lt;U&gt;</code> for arbitrary <code>T</code> and <code>U</code> types.</p>
<p>A function that returns <code>Result</code> cannot use <code>?</code> on <code>Option</code> and vice versa. However, <code>Option::ok_or</code> converts <code>Option</code> to <code>Result</code> whereas <code>Result::ok</code> turns <code>Result</code> into <code>Option</code>.</p>
</details><h1><a class="header" href="#åŠ¨æ€é”™è¯¯ç±»å‹" id="åŠ¨æ€é”™è¯¯ç±»å‹">åŠ¨æ€é”™è¯¯ç±»å‹</a></h1>
<p>Sometimes we want to allow any type of error to be returned without writing our own enum covering all the different possibilities. The <code>std::error::Error</code> trait makes it easy to create a trait object that can contain any error.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;
use std::fs;
use std::io::Read;

fn read_count(path: &amp;str) -&gt; Result&lt;i32, Box&lt;dyn Error&gt;&gt; {
    let mut count_str = String::new();
    fs::File::open(path)?.read_to_string(&amp;mut count_str)?;
    let count: i32 = count_str.parse()?;
    Ok(count)
}

fn main() {
    fs::write(&quot;count.dat&quot;, &quot;1i3&quot;).unwrap();
    match read_count(&quot;count.dat&quot;) {
        Ok(count) =&gt; println!(&quot;Count: {count}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err}&quot;),
    }
}
</code></pre></pre>
<details>
<p><code>read_count</code> å‡½æ•°å¯ä»¥è¿”å› <code>std::io::Error</code>ï¼ˆé€šè¿‡æ–‡ä»¶æ“ä½œï¼‰æˆ– <code>std::num::ParseIntError</code>ï¼ˆé€šè¿‡ <code>String::parse</code>ï¼‰ã€‚</p>
<p>Boxing errors saves on code, but gives up the ability to cleanly handle different error cases differently in the program. As such it's generally not a good idea to use <code>Box&lt;dyn Error&gt;</code> in the public API of a library, but it can be a good option in a program where you just want to display the error message somewhere.</p>
<p>Make sure to implement the <code>std::error::Error</code> trait when defining a custom error type so it can be boxed.</p>
</details><h1><a class="header" href="#thiserror" id="thiserror"><code>thiserror</code></a></h1>
<p>The <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> crate provides macros to help avoid boilerplate when defining error types. It provides derive macros that assist in implementing <code>From&lt;T&gt;</code>, <code>Display</code>, and the <code>Error</code> trait.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io::Read;
use std::{fs, io};
use thiserror::Error;

#[derive(Debug, Error)]
enum ReadUsernameError {
    #[error(&quot;I/O error: {0}&quot;)]
    IoError(#[from] io::Error),
    #[error(&quot;Found no username in {0}&quot;)]
    EmptyUsername(String),
}

fn read_username(path: &amp;str) -&gt; Result&lt;String, ReadUsernameError&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)?.read_to_string(&amp;mut username)?;
    if username.is_empty() {
        return Err(ReadUsernameError::EmptyUsername(String::from(path)));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li>The <code>Error</code> derive macro is provided by <code>thiserror</code>, and has lots of useful attributes to help define error types in a compact way.</li>
<li>The message from <code>#[error]</code> is used to derive the <code>Display</code> trait.</li>
<li>Note that the (<code>thiserror::</code>)<code>Error</code> derive macro, while it has the effect of implementing the (<code>std::error::</code>)<code>Error</code> trait, is not the same this; traits and macros do not share a namespace.</li>
</ul>
</details><h1><a class="header" href="#anyhow" id="anyhow"><code>anyhow</code></a></h1>
<p>The <a href="https://docs.rs/anyhow/"><code>anyhow</code></a> crate provides a rich error type with support for carrying additional contextual information, which can be used to provide a semantic trace of what the program was doing leading up to the error.</p>
<p>This can be combined with the convenience macros from <a href="https://docs.rs/thiserror/"><code>thiserror</code></a> to avoid writing out trait impls explicitly for custom error types.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::{bail, Context, Result};
use std::fs;
use std::io::Read;
use thiserror::Error;

#[derive(Clone, Debug, Eq, Error, PartialEq)]
#[error(&quot;Found no username in {0}&quot;)]
struct EmptyUsernameError(String);

fn read_username(path: &amp;str) -&gt; Result&lt;String&gt; {
    let mut username = String::with_capacity(100);
    fs::File::open(path)
        .with_context(|| format!(&quot;Failed to open {path}&quot;))?
        .read_to_string(&amp;mut username)
        .context(&quot;Failed to read&quot;)?;
    if username.is_empty() {
        bail!(EmptyUsernameError(path.to_string()));
    }
    Ok(username)
}

fn main() {
    //fs::write(&quot;config.dat&quot;, &quot;&quot;).unwrap();
    match read_username(&quot;config.dat&quot;) {
        Ok(username) =&gt; println!(&quot;Username: {username}&quot;),
        Err(err) =&gt; println!(&quot;Error: {err:?}&quot;),
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>anyhow::Error</code> is essentially a wrapper around <code>Box&lt;dyn Error&gt;</code>. As such it's again generally not a good choice for the public API of a library, but is widely used in applications.</li>
<li><code>anyhow::Result&lt;V&gt;</code> is a type alias for <code>Result&lt;V, anyhow::Error&gt;</code>.</li>
<li>Functionality provided by <code>anyhow::Error</code> may be familiar to Go developers, as it provides similar behavior to the Go <code>error</code> type and <code>Result&lt;T, anyhow::Error&gt;</code> is much like a Go <code>(T, error)</code> (with the convention that only one element of the pair is meaningful).</li>
<li><code>anyhow::Context</code> is a trait implemented for the standard <code>Result</code> and <code>Option</code> types. <code>use anyhow::Context</code> is necessary to enable <code>.context()</code> and <code>.with_context()</code> on those types.</li>
</ul>
<h1><a class="header" href="#æ¢ç´¢æ›´å¤š-7" id="æ¢ç´¢æ›´å¤š-7">æ¢ç´¢æ›´å¤š</a></h1>
<ul>
<li><code>anyhow::Error</code> has support for downcasting, much like <code>std::any::Any</code>; the specific error type stored inside can be extracted for examination if desired with <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast"><code>Error::downcast</code></a>.</li>
</ul>
</details><h1><a class="header" href="#ç»ƒä¹ ä½¿ç”¨-result-è¿›è¡Œé‡å†™" id="ç»ƒä¹ ä½¿ç”¨-result-è¿›è¡Œé‡å†™">ç»ƒä¹ ï¼šä½¿ç”¨ Result è¿›è¡Œé‡å†™</a></h1>
<p>The following implements a very simple parser for an expression language. However, it handles errors by panicking. Rewrite it to instead use idiomatic error handling and propagate errors to a return from <code>main</code>. Feel free to use <a href="https://docs.rs/thiserror"><code>thiserror</code></a> and <a href="https://docs.rs/anyhow"><code>anyhow</code></a>.</p>
<blockquote>
<p><strong>Hint:</strong> start by fixing error handling in the <code>parse</code> function. Once that is working correctly, update <code>Tokenizer</code> to implement <code>Iterator&lt;Item=Result&lt;Token, TokenizerError&gt;&gt;</code> and handle that in the parser.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Token;

    fn next(&amp;mut self) -&gt; Option&lt;Token&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(self.collect_number(c)),
            'a'..='z' =&gt; Some(self.collect_identifier(c)),
            '+' =&gt; Some(Token::Operator(Op::Add)),
            '-' =&gt; Some(Token::Operator(Op::Sub)),
            _ =&gt; panic!(&quot;Unexpected character {c}&quot;),
        }
    }
}

fn parse(input: &amp;str) -&gt; Expression {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(tokens: &amp;mut Tokenizer&lt;'a&gt;) -&gt; Expression {
        let Some(tok) = tokens.next() else {
            panic!(&quot;Unexpected end of input&quot;);
        };
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse().expect(&quot;Invalid 32-bit integer&quot;);
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; panic!(&quot;Unexpected token {tok:?}&quot;),
        };
        // Look ahead to parse a binary operation if present.
        match tokens.next() {
            None =&gt; expr,
            Some(Token::Operator(op)) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)),
            ),
            Some(tok) =&gt; panic!(&quot;Unexpected token {tok:?}&quot;),
        }
    }

    parse_expr(&amp;mut tokens)
}

fn main() {
    let expr = parse(&quot;10+foo+20-30&quot;);
    println!(&quot;{expr:?}&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-17" id="è§£ç­”-17">è§£ç­”</a></h1>
<!-- compile_fail because `mdbook test` does not allow use of `thiserror` -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use thiserror::Error;
use std::iter::Peekable;
use std::str::Chars;

/// An arithmetic operator.
#[derive(Debug, PartialEq, Clone, Copy)]
enum Op {
    Add,
    Sub,
}

/// A token in the expression language.
#[derive(Debug, PartialEq)]
enum Token {
    Number(String),
    Identifier(String),
    Operator(Op),
}

/// An expression in the expression language.
#[derive(Debug, PartialEq)]
enum Expression {
    /// A reference to a variable.
    Var(String),
    /// A literal number.
    Number(u32),
    /// A binary operation.
    Operation(Box&lt;Expression&gt;, Op, Box&lt;Expression&gt;),
}

fn tokenize(input: &amp;str) -&gt; Tokenizer {
    return Tokenizer(input.chars().peekable());
}

#[derive(Debug, Error)]
enum TokenizerError {
    #[error(&quot;Unexpected character '{0}' in input&quot;)]
    UnexpectedCharacter(char),
}

struct Tokenizer&lt;'a&gt;(Peekable&lt;Chars&lt;'a&gt;&gt;);

impl&lt;'a&gt; Tokenizer&lt;'a&gt; {
    fn collect_number(&amp;mut self, first_char: char) -&gt; Token {
        let mut num = String::from(first_char);
        while let Some(&amp;c @ '0'..='9') = self.0.peek() {
            num.push(c);
            self.0.next();
        }
        Token::Number(num)
    }

    fn collect_identifier(&amp;mut self, first_char: char) -&gt; Token {
        let mut ident = String::from(first_char);
        while let Some(&amp;c @ ('a'..='z' | '_' | '0'..='9')) = self.0.peek() {
            ident.push(c);
            self.0.next();
        }
        Token::Identifier(ident)
    }
}

impl&lt;'a&gt; Iterator for Tokenizer&lt;'a&gt; {
    type Item = Result&lt;Token, TokenizerError&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Token, TokenizerError&gt;&gt; {
        let c = self.0.next()?;
        match c {
            '0'..='9' =&gt; Some(Ok(self.collect_number(c))),
            'a'..='z' | '_' =&gt; Some(Ok(self.collect_identifier(c))),
            '+' =&gt; Some(Ok(Token::Operator(Op::Add))),
            '-' =&gt; Some(Ok(Token::Operator(Op::Sub))),
            _ =&gt; Some(Err(TokenizerError::UnexpectedCharacter(c))),
        }
    }
}

#[derive(Debug, Error)]
enum ParserError {
    #[error(&quot;Tokenizer error: {0}&quot;)]
    TokenizerError(#[from] TokenizerError),
    #[error(&quot;Unexpected end of input&quot;)]
    UnexpectedEOF,
    #[error(&quot;Unexpected token {0:?}&quot;)]
    UnexpectedToken(Token),
    #[error(&quot;Invalid number&quot;)]
    InvalidNumber(#[from] std::num::ParseIntError),
}

fn parse(input: &amp;str) -&gt; Result&lt;Expression, ParserError&gt; {
    let mut tokens = tokenize(input);

    fn parse_expr&lt;'a&gt;(
        tokens: &amp;mut Tokenizer&lt;'a&gt;,
    ) -&gt; Result&lt;Expression, ParserError&gt; {
        let tok = tokens.next().ok_or(ParserError::UnexpectedEOF)??;
        let expr = match tok {
            Token::Number(num) =&gt; {
                let v = num.parse()?;
                Expression::Number(v)
            }
            Token::Identifier(ident) =&gt; Expression::Var(ident),
            Token::Operator(_) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        };
        // Look ahead to parse a binary operation if present.
        Ok(match tokens.next() {
            None =&gt; expr,
            Some(Ok(Token::Operator(op))) =&gt; Expression::Operation(
                Box::new(expr),
                op,
                Box::new(parse_expr(tokens)?),
            ),
            Some(Err(e)) =&gt; return Err(e.into()),
            Some(Ok(tok)) =&gt; return Err(ParserError::UnexpectedToken(tok)),
        })
    }

    parse_expr(&amp;mut tokens)
}

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let expr = parse(&quot;10+foo+20-30&quot;)?;
    println!(&quot;{expr:?}&quot;);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#ä¸å®‰å…¨-rust" id="ä¸å®‰å…¨-rust">ä¸å®‰å…¨ Rust</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#ä¸å®‰å…¨-rust-1" id="ä¸å®‰å…¨-rust-1">ä¸å®‰å…¨ Rust</a></h1>
<p>Rust è¯­è¨€åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼š</p>
<ul>
<li>**å®‰å…¨ Rustï¼š**å†…å­˜å®‰å…¨ï¼Œæ²¡æœ‰æ½œåœ¨çš„æœªå®šä¹‰è¡Œä¸ºã€‚</li>
<li>**ä¸å®‰å…¨ Rustï¼š**å¦‚æœè¿åäº†å‰ææ¡ä»¶ï¼Œå¯èƒ½ä¼šè§¦å‘æœªå®šä¹‰çš„è¡Œä¸ºã€‚</li>
</ul>
<p>We saw mostly safe Rust in this course, but it's important to know what Unsafe Rust is.</p>
<p>ä¸å®‰å…¨çš„ä»£ç é€šå¸¸å†…å®¹å¾ˆå°‘è€Œä¸”ä¸å…¶ä»–ä»£ç éš”ç¦»ï¼Œ å…¶æ­£ç¡®æ€§ä¹Ÿåº”å¾—åˆ°ä»”ç»†è®°å½•ã€‚è¿™ç±»ä»£ç é€šå¸¸å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡å±‚ä¸­ã€‚</p>
<p>ä¸å®‰å…¨ Rust æä¾›äº†äº”ç§æ–°åŠŸèƒ½ï¼š</p>
<ul>
<li>è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆã€‚</li>
<li>è®¿é—®æˆ–ä¿®æ”¹å¯å˜çš„é™æ€å˜é‡ã€‚</li>
<li>è®¿é—® <code>union</code> å­—æ®µã€‚</li>
<li>è°ƒç”¨ <code>unsafe</code> å‡½æ•°ï¼ŒåŒ…æ‹¬ <code>extern</code> å‡½æ•°ã€‚</li>
<li>å®ç° <code>unsafe</code> traitã€‚</li>
</ul>
<p>ä¸‹é¢ï¼Œæˆ‘ä»¬å°†ç®€è¦ä»‹ç»è¿™äº›ä¸å®‰å…¨åŠŸèƒ½ã€‚å¦‚éœ€äº†è§£å®Œæ•´è¯¦æƒ…ï¼Œè¯·å‚é˜… <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">ã€ŠRust æ‰‹å†Œã€‹ç¬¬ 19.1 ç« </a> å’Œ <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a>ã€‚</p>
<details>
<p>Unsafe Rust does not mean the code is incorrect. It means that developers have turned off some compiler safety features and have to write correct code by themselves. It means the compiler no longer enforces Rust's memory-safety rules.</p>
</details><h1><a class="header" href="#è§£å¼•ç”¨è£¸æŒ‡é’ˆ" id="è§£å¼•ç”¨è£¸æŒ‡é’ˆ">è§£å¼•ç”¨è£¸æŒ‡é’ˆ</a></h1>
<p>åˆ›å»ºæŒ‡é’ˆæ˜¯å®‰å…¨çš„æ“ä½œï¼Œä½†è§£å¼•ç”¨æŒ‡é’ˆéœ€è¦ä½¿ç”¨ <code>unsafe</code> æ–¹æ³•ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from(&quot;careful!&quot;);

    let r1 = &amp;raw mut s;
    let r2 = r1 as *const String;

    // SAFETY: r1 and r2 were obtained from references and so are guaranteed to
    // be non-null and properly aligned, the objects underlying the references
    // from which they were obtained are live throughout the whole unsafe
    // block, and they are not accessed either through the references or
    // concurrently through any other pointers.
    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        *r1 = String::from(&quot;uhoh&quot;);
        println!(&quot;r2 is: {}&quot;, *r2);
    }

    // NOT SAFE. DO NOT DO THIS.
    /*
    let r3: &amp;String = unsafe { &amp;*r1 };
    drop(s);
    println!(&quot;r3 is: {}&quot;, *r3);
    */
}
</code></pre></pre>
<details>
<p>æˆ‘ä»¬å»ºè®®ï¼ˆè€Œä¸” Android Rust æ ·å¼æŒ‡å—è¦æ±‚ï¼‰ä¸ºæ¯ä¸ª <code>unsafe</code> ä»£ç å—ç¼–å†™ä¸€æ¡æ³¨é‡Šï¼Œ è¯´æ˜è¯¥ä»£ç å—ä¸­çš„ä»£ç å¦‚ä½•æ»¡è¶³å…¶æ‰€æ‰§è¡Œçš„ä¸å®‰å…¨æ“ä½œçš„ å®‰å…¨è¦æ±‚ã€‚</p>
<p>å¯¹äºæŒ‡é’ˆè§£é™¤å¼•ç”¨ï¼Œè¿™æ„å‘³ç€æŒ‡é’ˆå¿…é¡»ä¸º <a href="https://doc.rust-lang.org/std/ptr/index.html#safety"><em>valid</em></a>ï¼Œå³ï¼š</p>
<ul>
<li>æŒ‡é’ˆå¿…é¡»ä¸ºé nullã€‚</li>
<li>æŒ‡é’ˆå¿…é¡»æ˜¯ <em>dereferenceable</em>ï¼ˆåœ¨å•ä¸ªå·²åˆ†é…å¯¹è±¡çš„è¾¹ç•Œå†…ï¼‰ã€‚</li>
<li>å¯¹è±¡ä¸å¾—å·²å–æ¶ˆåˆ†é…ã€‚</li>
<li>ä¸å¾—å¹¶å‘è®¿é—®ç›¸åŒä½ç½®ã€‚</li>
<li>å¦‚æœé€šè¿‡è½¬æ¢å¼•ç”¨ç±»å‹æ¥è·å–æŒ‡é’ˆï¼Œåˆ™åº•å±‚å¯¹è±¡å¿…é¡»å¤„äºæ´»è·ƒçŠ¶æ€ï¼Œ è€Œä¸”ä¸å¾—ä½¿ç”¨ä»»ä½•å¼•ç”¨æ¥è®¿é—®å†…å­˜ã€‚</li>
</ul>
<p>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒæŒ‡é’ˆè¿˜å¿…é¡»æ­£ç¡®å¯¹é½ã€‚</p>
<p>The &quot;NOT SAFE&quot; section gives an example of a common kind of UB bug: <code>*r1</code> has the <code>'static</code> lifetime, so <code>r3</code> has type <code>&amp;'static String</code>, and thus outlives <code>s</code>. Creating a reference from a pointer requires <em>great care</em>.</p>
</details><h1><a class="header" href="#å¯å˜çš„é™æ€å˜é‡" id="å¯å˜çš„é™æ€å˜é‡">å¯å˜çš„é™æ€å˜é‡</a></h1>
<p>è¯»å–ä¸å¯å˜çš„é™æ€å˜é‡æ˜¯å®‰å…¨çš„æ“ä½œï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;HELLO_WORLD: {HELLO_WORLD}&quot;);
}
</code></pre></pre>
<p>ä½†æ˜¯ï¼Œè¯»å–å’Œå†™å…¥å¯å˜çš„é™æ€å˜é‡æ˜¯ä¸å®‰å…¨çš„ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼š é€ æˆæ•°æ®äº‰ç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">static mut COUNTER: u32 = 0;

fn add_to_counter(inc: u32) {
    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_counter(42);

    // SAFETY: There are no other threads which could be accessing `COUNTER`.
    unsafe {
        println!(&quot;COUNTER: {COUNTER}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>æ­¤å¤„çš„ç¨‹åºæ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå®ƒæ˜¯å•çº¿ç¨‹çš„ã€‚ä¸è¿‡ï¼ŒRust ç¼–è¯‘å™¨æ¯”è¾ƒä¿å®ˆï¼Œä¼šåšå‡ºæœ€åçš„å‡è®¾ã€‚è¯·å°è¯•ç§»é™¤ <code>unsafe</code>ï¼Œçœ‹çœ‹ç¼–è¯‘å™¨å¦‚ä½•è§£é‡Šä»å¤šä¸ªçº¿ç¨‹ä¸­ä¿®æ”¹é™æ€å˜é‡æ˜¯ä¸€ç§æœªå®šä¹‰çš„è¡Œä¸ºã€‚</p>
</li>
<li>
<p>é€šå¸¸ï¼Œæˆ‘ä»¬ä¸å»ºè®®ä½¿ç”¨å¯å˜çš„é™æ€å˜é‡ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œåœ¨ä½å±‚çº§ <code>no_std</code> ä»£ç ä¸­å¯èƒ½éœ€è¦è¿™æ ·åšï¼Œ ä¾‹å¦‚å®ç°å †åˆ†é…å™¨æˆ–ä½¿ç”¨æŸäº› C APIã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#è”åˆä½“" id="è”åˆä½“">è”åˆä½“</a></h1>
<p>è”åˆä½“ä¸æšä¸¾ç±»ä¼¼ï¼Œä½†æ‚¨éœ€è¦è‡ªè¡Œè·Ÿè¸ªæ´»è·ƒå­—æ®µï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">#[repr(C)]
union MyUnion {
    i: u8,
    b: bool,
}

fn main() {
    let u = MyUnion { i: 42 };
    println!(&quot;int: {}&quot;, unsafe { u.i });
    println!(&quot;bool: {}&quot;, unsafe { u.b }); // Undefined behavior!
}
</code></pre></pre>
<details>
<p>åœ¨ Rust ä¸­å¾ˆå°‘éœ€è¦ç”¨åˆ°è”åˆä½“ï¼Œå› ä¸ºæ‚¨é€šå¸¸å¯ä»¥ä½¿ç”¨æšä¸¾ã€‚è”åˆä½“åªæ˜¯å¶å°”ç”¨äº ä¸ C åº“ API è¿›è¡Œäº¤äº’ã€‚</p>
<p>å¦‚æœæ‚¨åªæ˜¯æƒ³å°†å­—èŠ‚é‡æ–°è§£é‡Šä¸ºå…¶ä»–ç±»å‹ï¼Œåˆ™å¯èƒ½éœ€è¦ä½¿ç”¨ <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> æˆ– å®‰å…¨çš„å°è£…å®¹å™¨ï¼Œä¾‹å¦‚ <a href="https://crates.io/crates/zerocopy"><code>zerocopy</code></a> crateã€‚</p>
</details><h1><a class="header" href="#unsafe-å‡½æ•°" id="unsafe-å‡½æ•°">Unsafe å‡½æ•°</a></h1>
<h2><a class="header" href="#è°ƒç”¨-unsafe-å‡½æ•°" id="è°ƒç”¨-unsafe-å‡½æ•°">è°ƒç”¨ Unsafe å‡½æ•°</a></h2>
<p>å¦‚æœå‡½æ•°æˆ–æ–¹æ³•å…·æœ‰é¢å¤–çš„å‰ææ¡ä»¶ï¼Œæ‚¨å¿…é¡»éµå®ˆè¿™äº›å‰ææ¡ä»¶æ¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ åˆ™å¯ä»¥å°†è¯¥å‡½æ•°æˆ–æ–¹æ³•æ ‡è®°ä¸º <code>unsafe</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    let emojis = &quot;ğŸ—»âˆˆğŸŒ&quot;;

    // SAFETY: The indices are in the correct order, within the bounds of the
    // string slice, and lie on UTF-8 sequence boundaries.
    unsafe {
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(0..4));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(4..7));
        println!(&quot;emoji: {}&quot;, emojis.get_unchecked(7..11));
    }

    println!(&quot;char count: {}&quot;, count_chars(unsafe { emojis.get_unchecked(0..7) }));

    // SAFETY: `abs` doesn't deal with pointers and doesn't have any safety
    // requirements.
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }

    // Not upholding the UTF-8 encoding requirement breaks memory safety!
    // println!(&quot;emoji: {}&quot;, unsafe { emojis.get_unchecked(0..3) });
    // println!(&quot;char count: {}&quot;, count_chars(unsafe {
    // emojis.get_unchecked(0..3) }));
}

fn count_chars(s: &amp;str) -&gt; usize {
    s.chars().count()
}
</code></pre></pre>
<h2><a class="header" href="#ç¼–å†™-unsafe-å‡½æ•°" id="ç¼–å†™-unsafe-å‡½æ•°">ç¼–å†™ Unsafe å‡½æ•°</a></h2>
<p>å¦‚æœæ‚¨è‡ªå·±ç¼–å†™çš„å‡½æ•°éœ€è¦æ»¡è¶³ç‰¹å®šæ¡ä»¶ä»¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ æ‚¨å¯ä»¥å°†è¿™äº›å‡½æ•°æ ‡è®°ä¸º <code>unsafe</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">/// Swaps the values pointed to by the given pointers.
///
/// # Safety
///
/// The pointers must be valid and properly aligned.
unsafe fn swap(a: *mut u8, b: *mut u8) {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fn main() {
    let mut a = 42;
    let mut b = 66;

    // SAFETY: ...
    unsafe {
        swap(&amp;mut a, &amp;mut b);
    }

    println!(&quot;a = {}, b = {}&quot;, a, b);
}
</code></pre></pre>
<details>
<h2><a class="header" href="#è°ƒç”¨-unsafe-å‡½æ•°-1" id="è°ƒç”¨-unsafe-å‡½æ•°-1">è°ƒç”¨ Unsafe å‡½æ•°</a></h2>
<p><code>get_unchecked</code>, like most <code>_unchecked</code> functions, is unsafe, because it can create UB if the range is incorrect. <code>abs</code> is unsafe for a different reason: it is an external function (FFI). Calling external functions is usually only a problem when those functions do things with pointers which might violate Rust's memory model, but in general any C function might have undefined behaviour under any arbitrary circumstances.</p>
<p>æœ¬ä¾‹ä¸­çš„â€œCâ€æ˜¯ ABIï¼›<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»– ABI</a>ã€‚</p>
<h2><a class="header" href="#ç¼–å†™-unsafe-å‡½æ•°-1" id="ç¼–å†™-unsafe-å‡½æ•°-1">ç¼–å†™ Unsafe å‡½æ•°</a></h2>
<p>We wouldn't actually use pointers for a <code>swap</code> function - it can be done safely with references.</p>
<p>Note that unsafe code is allowed within an unsafe function without an <code>unsafe</code> block. We can prohibit this with <code>#[deny(unsafe_op_in_unsafe_fn)]</code>. Try adding it and see what happens. This will likely change in a future Rust edition.</p>
</details><h1><a class="header" href="#å®ç°-unsafe-trait-1" id="å®ç°-unsafe-trait-1">å®ç° Unsafe Trait</a></h1>
<p>ä¸å‡½æ•°ä¸€æ ·ï¼Œå¦‚æœæ‚¨åœ¨å®ç°æŸä¸ª trait æ—¶å¿…é¡»ä¿è¯ç‰¹å®šæ¡ä»¶æ¥é¿å…æœªå®šä¹‰çš„è¡Œä¸ºï¼Œ æ‚¨ä¹Ÿå¯ä»¥å°†è¯¥ trait æ ‡è®°ä¸º <code>unsafe</code>ã€‚</p>
<p>For example, the <code>zerocopy</code> crate has an unsafe trait that looks <a href="https://docs.rs/zerocopy/latest/zerocopy/trait.IntoBytes.html">something like this</a>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::{mem, slice};

/// ...
/// # Safety
/// The type must have a defined representation and no padding.
pub unsafe trait IntoBytes {
    fn as_bytes(&amp;self) -&gt; &amp;[u8] {
        let len = mem::size_of_val(self);
        unsafe { slice::from_raw_parts((&amp;raw const self).cast::&lt;u8&gt;(), len) }
    }
}

// SAFETY: `u32` has a defined representation and no padding.
unsafe impl IntoBytes for u32 {}
</code></pre></pre>
<details>
<p>åœ¨ Rustdoc ä¸­æœ‰å…³ trait çš„ç« èŠ‚ä¸‹ï¼Œæœ‰ä¸€ä¸ªæ ‡é¢˜ä¸º <code># å®‰å…¨</code> çš„éƒ¨åˆ†ä»‹ç»äº† å®‰å…¨å®ç° trait çš„è¦æ±‚ã€‚</p>
<p>The actual safety section for <code>IntoBytes</code> is rather longer and more complicated.</p>
<p>å†…ç½®çš„ <code>Send</code> å’Œ <code>Sync</code> trait éƒ½æ˜¯ä¸å®‰å…¨çš„ã€‚</p>
</details><h1><a class="header" href="#å®‰å…¨-ffi-å°è£…å®¹å™¨" id="å®‰å…¨-ffi-å°è£…å®¹å™¨">å®‰å…¨ FFI å°è£…å®¹å™¨</a></h1>
<p>Rust ä¸ºé€šè¿‡ <em>å¤–éƒ¨å‡½æ•°æ¥å£</em> (FFI) è°ƒç”¨å‡½æ•°æä¾›äº†å‡ºè‰²çš„æ”¯æŒã€‚æˆ‘ä»¬å°†ä½¿ç”¨å®ƒä¸º <code>libc</code> å‡½æ•°æ„å»ºä¸€ä¸ªå®‰å…¨å°è£…å®¹å™¨ï¼Œç”¨äºä» C ä»£ç ä¸­è¯»å–ç›®å½•ä¸­çš„æ–‡ä»¶åç§°ã€‚</p>
<p>å»ºè®®æ‚¨å‚è€ƒä»¥ä¸‹æ‰‹å†Œé¡µé¢ï¼š</p>
<ul>
<li><a href="https://man7.org/linux/man-pages/man3/opendir.3.html"><code>opendir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/readdir.3.html"><code>readdir(3)</code></a></li>
<li><a href="https://man7.org/linux/man-pages/man3/closedir.3.html"><code>closedir(3)</code></a></li>
</ul>
<p>æ‚¨è¿˜éœ€è¦æµè§ˆ<a href="https://doc.rust-lang.org/std/ffi/">â€œstd::ffiâ€</a>æ¨¡å—ã€‚åœ¨ä¸‹æ–¹ï¼Œæ‚¨ä¼šå‘ç°å®Œæˆè¿™ä¸ªç»ƒä¹ æ‰€éœ€çš„å¤šç§å­—ç¬¦ä¸²ç±»å‹ï¼š</p>
<table><thead><tr><th>ç±»å‹</th><th>ç¼–ç </th><th>ä½¿ç”¨</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/std/primitive.str.html">â€œstrâ€</a>å’Œ<a href="https://doc.rust-lang.org/std/string/struct.String.html">â€œStringâ€</a></td><td>UTF-8</td><td>ç”¨ Rust è¿›è¡Œæ–‡æœ¬å¤„ç†</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.CStr.html">â€œCStrâ€</a>å’Œ<a href="https://doc.rust-lang.org/std/ffi/struct.CString.html">â€œCStringâ€</a></td><td>ä»¥ç©ºå­—ç¬¦ç»“å°¾</td><td>ä¸ C å‡½æ•°é€šä¿¡</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">â€œOsStrâ€</a>å’Œ<a href="https://doc.rust-lang.org/std/ffi/struct.OsString.html">â€œOsStringâ€</a></td><td>ç‰¹å®šäºæ“ä½œç³»ç»Ÿ</td><td>ä¸æ“ä½œç³»ç»Ÿé€šä¿¡</td></tr>
</tbody></table>
<p>æ‚¨å°†åœ¨ä»¥ä¸‹æ‰€æœ‰ç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼š</p>
<ul>
<li>å°† <code>&amp;str</code> è½¬æ¢ä¸º <code>CString</code>ï¼šæ‚¨éœ€è¦ä¸ºå°¾éš <code>\0</code> å­—ç¬¦åˆ†é…ç©ºæ ¼ï¼Œ</li>
<li>å°† <code>CString</code> è½¬æ¢ä¸º <code>\*const i8</code> ï¼šæ‚¨éœ€è¦ä¸€ä¸ªæŒ‡é’ˆæ¥è°ƒç”¨ C å‡½æ•°ï¼Œ</li>
<li>å°† <code>\*const i8</code> è½¬æ¢ä¸º <code>&amp;CStr</code> ï¼šæ‚¨éœ€è¦ä¸€äº›èƒ½å¤Ÿæ‰¾åˆ°å°¾éš <code>\0</code> å­—ç¬¦çš„å†…å®¹ï¼Œ</li>
<li><code>&amp;CStr</code> to <code>&amp;[u8]</code>: a slice of bytes is the universal interface for &quot;some unknown data&quot;,</li>
<li>å°† <code>&amp;\[u8\]</code> è½¬æ¢ä¸º <code>&amp;OsStr</code> ï¼š<code>&amp;OsStr</code> æ˜¯å‘ <code>OsString</code> è¿ˆè¿›çš„ä¸€æ­¥ï¼Œè¯·ä½¿ç”¨<a href="https://doc.rust-lang.org/std/os/unix/ffi/trait.OsStrExt.html"><code>OsStrExt</code></a>æ¥åˆ›å»ºå®ƒï¼Œ</li>
<li>å°†â€œ&amp;OsStrâ€è½¬æ¢ä¸ºâ€œOsStringâ€ï¼šæ‚¨éœ€è¦å…‹éš†â€œ&amp;OsStrâ€ä¸­çš„æ•°æ®ï¼Œä»¥ä¾¿èƒ½å¤Ÿè¿”å›å®ƒå¹¶å†æ¬¡è°ƒç”¨â€œreaddirâ€ã€‚</li>
</ul>
<p><a href="https://doc.rust-lang.org/nomicon/ffi.html">ç§˜å…¸</a> ä¸­ä¹Ÿæœ‰ä¸€ä¸ªå…³äº FFI çš„éå¸¸å®ç”¨çš„ç« èŠ‚ã€‚</p>
<p>å°†ä»¥ä¸‹ä»£ç å¤åˆ¶åˆ° <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a>ï¼Œå¹¶å¡«å…¥ç¼ºå°‘çš„å‡½æ•°å’Œæ–¹æ³•ï¼š</p>
<pre><pre class="playground"><code class="language-rust should_panic">// TODO: remove this when you're done with your implementation.
#![allow(unused_imports, unused_variables, dead_code)]

mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    unsafe extern &quot;C&quot; {
        pub unsafe fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub unsafe fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        unimplemented!()
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        unimplemented!()
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        unimplemented!()
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#è§£ç­”-18" id="è§£ç­”-18">è§£ç­”</a></h1>
<pre><pre class="playground"><code class="language-rust editable">mod ffi {
    use std::os::raw::{c_char, c_int};
    #[cfg(not(target_os = &quot;macos&quot;))]
    use std::os::raw::{c_long, c_uchar, c_ulong, c_ushort};

    // Opaque type. See https://doc.rust-lang.org/nomicon/ffi.html.
    #[repr(C)]
    pub struct DIR {
        _data: [u8; 0],
        _marker: core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
    }

    // Layout according to the Linux man page for readdir(3), where ino_t and
    // off_t are resolved according to the definitions in
    // /usr/include/x86_64-linux-gnu/{sys/types.h, bits/typesizes.h}.
    #[cfg(not(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_ino: c_ulong,
        pub d_off: c_long,
        pub d_reclen: c_ushort,
        pub d_type: c_uchar,
        pub d_name: [c_char; 256],
    }

    // Layout according to the macOS man page for dir(5).
    #[cfg(all(target_os = &quot;macos&quot;))]
    #[repr(C)]
    pub struct dirent {
        pub d_fileno: u64,
        pub d_seekoff: u64,
        pub d_reclen: u16,
        pub d_namlen: u16,
        pub d_type: u8,
        pub d_name: [c_char; 1024],
    }

    unsafe extern &quot;C&quot; {
        pub unsafe fn opendir(s: *const c_char) -&gt; *mut DIR;

        #[cfg(not(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;)))]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        // See https://github.com/rust-lang/libc/issues/414 and the section on
        // _DARWIN_FEATURE_64_BIT_INODE in the macOS man page for stat(2).
        //
        // &quot;Platforms that existed before these updates were available&quot; refers
        // to macOS (as opposed to iOS / wearOS / etc.) on Intel and PowerPC.
        #[cfg(all(target_os = &quot;macos&quot;, target_arch = &quot;x86_64&quot;))]
        #[link_name = &quot;readdir$INODE64&quot;]
        pub unsafe fn readdir(s: *mut DIR) -&gt; *const dirent;

        pub unsafe fn closedir(s: *mut DIR) -&gt; c_int;
    }
}

use std::ffi::{CStr, CString, OsStr, OsString};
use std::os::unix::ffi::OsStrExt;

#[derive(Debug)]
struct DirectoryIterator {
    path: CString,
    dir: *mut ffi::DIR,
}

impl DirectoryIterator {
    fn new(path: &amp;str) -&gt; Result&lt;DirectoryIterator, String&gt; {
        // Call opendir and return a Ok value if that worked,
        // otherwise return Err with a message.
        let path =
            CString::new(path).map_err(|err| format!(&quot;Invalid path: {err}&quot;))?;
        // SAFETY: path.as_ptr() cannot be NULL.
        let dir = unsafe { ffi::opendir(path.as_ptr()) };
        if dir.is_null() {
            Err(format!(&quot;Could not open {path:?}&quot;))
        } else {
            Ok(DirectoryIterator { path, dir })
        }
    }
}

impl Iterator for DirectoryIterator {
    type Item = OsString;
    fn next(&amp;mut self) -&gt; Option&lt;OsString&gt; {
        // Keep calling readdir until we get a NULL pointer back.
        // SAFETY: self.dir is never NULL.
        let dirent = unsafe { ffi::readdir(self.dir) };
        if dirent.is_null() {
            // We have reached the end of the directory.
            return None;
        }
        // SAFETY: dirent is not NULL and dirent.d_name is NUL
        // terminated.
        let d_name = unsafe { CStr::from_ptr((*dirent).d_name.as_ptr()) };
        let os_str = OsStr::from_bytes(d_name.to_bytes());
        Some(os_str.to_owned())
    }
}

impl Drop for DirectoryIterator {
    fn drop(&amp;mut self) {
        // Call closedir as needed.
        // SAFETY: self.dir is never NULL.
        if unsafe { ffi::closedir(self.dir) } != 0 {
            panic!(&quot;Could not close {:?}&quot;, self.path);
        }
    }
}

fn main() -&gt; Result&lt;(), String&gt; {
    let iter = DirectoryIterator::new(&quot;.&quot;)?;
    println!(&quot;files: {:#?}&quot;, iter.collect::&lt;Vec&lt;_&gt;&gt;());
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::error::Error;

    #[test]
    fn test_nonexisting_directory() {
        let iter = DirectoryIterator::new(&quot;no-such-directory&quot;);
        assert!(iter.is_err());
    }

    #[test]
    fn test_empty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;]);
        Ok(())
    }

    #[test]
    fn test_nonempty_directory() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let tmp = tempfile::TempDir::new()?;
        std::fs::write(tmp.path().join(&quot;foo.txt&quot;), &quot;The Foo Diaries\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;bar.png&quot;), &quot;&lt;PNG&gt;\n&quot;)?;
        std::fs::write(tmp.path().join(&quot;crab.rs&quot;), &quot;//! Crab\n&quot;)?;
        let iter = DirectoryIterator::new(
            tmp.path().to_str().ok_or(&quot;Non UTF-8 character in path&quot;)?,
        )?;
        let mut entries = iter.collect::&lt;Vec&lt;_&gt;&gt;();
        entries.sort();
        assert_eq!(entries, &amp;[&quot;.&quot;, &quot;..&quot;, &quot;bar.png&quot;, &quot;crab.rs&quot;, &quot;foo.txt&quot;]);
        Ok(())
    }
}
</code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿æ¥åˆ°android-ä¸­çš„rust" id="æ¬¢è¿æ¥åˆ°android-ä¸­çš„rust">æ¬¢è¿æ¥åˆ°Android ä¸­çš„Rust</a></h1>
<p>Rust is supported for system software on Android. This means that you can write new services, libraries, drivers or even firmware in Rust (or improve existing code as needed).</p>
<details>
<p>é‰´äº Android ä¸­è¶Šæ¥è¶Šå¤šåœ°ä½¿ç”¨ Rustï¼Œæ¼”è®²è€…å¯èƒ½ä¼šæåˆ°ä»¥ä¸‹ä»»ä½•ä¸€é¡¹ï¼š</p>
<ul>
<li>
<p>Service example: <a href="https://security.googleblog.com/2022/07/dns-over-http3-in-android.html">DNS over HTTP</a>.</p>
</li>
<li>
<p>Libraries: <a href="https://crosvm.dev/book/appendix/rutabaga_gfx.html">Rutabaga Virtual Graphics Interface</a>.</p>
</li>
<li>
<p>Kernel Drivers: <a href="https://lore.kernel.org/rust-for-linux/20231101-rust-binder-v1-0-08ba9197f637@google.com/">Binder</a>.</p>
</li>
<li>
<p>Firmware: <a href="https://security.googleblog.com/2023/10/bare-metal-rust-in-android.html">pKVM firmware</a>.</p>
</li>
</ul>
</details><h1><a class="header" href="#è®¾ç½®" id="è®¾ç½®">è®¾ç½®</a></h1>
<p>We will be using a Cuttlefish Android Virtual Device to test our code. Make sure you have access to one or create a new one with:</p>
<pre><code class="language-shell">source build/envsetup.sh
lunch aosp_cf_x86_64_phone-trunk_staging-userdebug
acloud create
</code></pre>
<p>æ›´å¤šç»†èŠ‚è¯·å‚è€ƒ <a href="https://source.android.com/docs/setup/start">Android Developer Codelab</a>.</p>
<p>The code on the following pages can be found in the <a href="https://github.com/google/comprehensive-rust/tree/main/src/android"><code>src/android/</code> directory</a> of the course material. Please <code>git clone</code> the repository to follow along.</p>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>Cuttlefish is a reference Android device designed to work on generic Linux desktops. MacOS support is also planned.</p>
</li>
<li>
<p>Cuttlefish ç³»ç»Ÿæ˜ åƒä¼šä¿æŒåª²ç¾çœŸå®è®¾å¤‡çš„é«˜ä¿çœŸåº¦ï¼Œæ˜¯è¿è¡Œè®¸å¤š Rust ç”¨ä¾‹çš„ç†æƒ³æ¨¡æ‹Ÿå™¨ã€‚</p>
</li>
</ul>
</details>
<h1><a class="header" href="#æ„å»ºè§„åˆ™" id="æ„å»ºè§„åˆ™">æ„å»ºè§„åˆ™</a></h1>
<p>Android æ„å»ºç³»ç»Ÿï¼ˆSoongï¼‰é€šè¿‡ä¸€ç³»åˆ—æ¨¡å—æ¥æ”¯æŒRustï¼š</p>
<table><thead><tr><th>Module Type</th><th>æè¿°</th></tr></thead><tbody>
<tr><td><code>rust_binary</code></td><td>Produces a Rust binary.</td></tr>
<tr><td><code>rust_library</code></td><td>ç”Ÿæˆä¸€ä¸ª Rust åº“ï¼Œå¹¶æä¾› <code>rlib</code> å’Œ <code>dylib</code> ä¸¤ç§å˜ä½“ã€‚</td></tr>
<tr><td><code>rust_ffi</code></td><td>ç”Ÿæˆä¸€ä¸ªå¯ç”± <code>cc</code> æ¨¡å—ä½¿ç”¨çš„ Rust C åº“ï¼Œå¹¶æä¾›é™æ€å’Œå…±äº«ä¸¤ç§å˜ä½“ã€‚</td></tr>
<tr><td><code>rust_proc_macro</code></td><td>ç”Ÿæˆâ€œproc-macroâ€Rust åº“ã€‚è¿™äº›å®ä¸ç¼–è¯‘å™¨æ’ä»¶ç±»ä¼¼ã€‚</td></tr>
<tr><td><code>rust_test</code></td><td>ç”Ÿæˆä½¿ç”¨æ ‡å‡† Rust æµ‹è¯•æ¡†æ¶çš„ Rust æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</td></tr>
<tr><td><code>rust_fuzz</code></td><td>ç”Ÿæˆä½¿ç”¨ <code>libfuzzer</code> çš„ Rust æ¨¡ç³Šæµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</td></tr>
<tr><td><code>rust_protobuf</code></td><td>ç”Ÿæˆæºä»£ç å¹¶ç”Ÿæˆä¸ºç‰¹å®š protobuf æä¾›æ¥å£çš„ Rust åº“ã€‚</td></tr>
<tr><td><code>rust_bindgen</code></td><td>ç”Ÿæˆæºä»£ç å¹¶ç”ŸæˆåŒ…å« Rust ç»‘å®šåˆ° C åº“çš„ Rust åº“ã€‚</td></tr>
</tbody></table>
<p>ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ <code>rust_binary</code> å’Œ <code>rust_library</code>ã€‚</p>
<details>
<p>æ¼”è®²è€…å¯èƒ½ä¼šæåŠå…¶ä»–å†…å®¹ï¼š</p>
<ul>
<li>
<p>Cargo æœªé’ˆå¯¹å¤šè¯­è¨€ä»£ç åº“è¿›è¡Œä¼˜åŒ–ï¼Œå¹¶ä¸”ä»äº’è”ç½‘ä¸‹è½½è½¯ä»¶åŒ…ã€‚</p>
</li>
<li>
<p>For compliance and performance, Android must have crates in-tree. It must also interop with C/C++/Java code. Soong fills that gap.</p>
</li>
<li>
<p>Soong has many similarities to <a href="https://bazel.build/">Bazel</a>, which is the open-source variant of Blaze (used in google3).</p>
</li>
<li>
<p>è¶£å‘³å°çŸ¥è¯†ï¼šã€Šæ˜Ÿé™…è¿·èˆªã€‹ä¸­çš„æ•°æ®æ˜¯ Soong ç±»å‹çš„ Androidã€‚</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust-äºŒè¿›åˆ¶æ–‡ä»¶" id="rust-äºŒè¿›åˆ¶æ–‡ä»¶">Rust äºŒè¿›åˆ¶æ–‡ä»¶</a></h1>
<p>è®©æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•çš„åº”ç”¨ç¨‹åºå¼€å§‹ã€‚åœ¨ AOSP ç­¾å‡ºçš„æ ¹ç›®å½•ä¸‹ï¼Œåˆ›å»ºä»¥ä¸‹æ–‡ä»¶ï¼š</p>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust&quot;,
    crate_name: &quot;hello_rust&quot;,
    srcs: [&quot;src/main.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">//! Rust demo.

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;Hello from Rust!&quot;);
}
</code></pre></pre>
<p>ä½ ç°åœ¨å¯ä»¥æ„å»ºã€æ¨é€å’Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">m hello_rust
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust
</code></pre>
<pre><code class="language-text">Hello from Rust!
</code></pre>
<h1><a class="header" href="#rust-åº“" id="rust-åº“">Rust åº“</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ <code>rust_library</code> ä¸º Android åˆ›å»ºä¸€ä¸ªæ–°çš„ Rust åº“ã€‚</p>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å£°æ˜äº†å¯¹ä¸¤ä¸ªåº“çš„ä¾èµ–ï¼š</p>
<ul>
<li><code>libgreeting</code>, æˆ‘ä»¬åœ¨ä¸‹é¢è¿›è¡Œäº†å®šä¹‰ï¼Œ</li>
<li><code>libtextwrap</code>, ä¸€ä¸ªå·²ç»åœ¨ <a href="https://cs.android.com/android/platform/superproject/+/master:external/rust/crates/"><code>external/rust/crates/</code></a> ä¸­æä¾›çš„ crateã€‚</li>
</ul>
<p><em>hello_rust/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_with_dep&quot;,
    crate_name: &quot;hello_rust_with_dep&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libgreetings&quot;,
        &quot;libtextwrap&quot;,
    ],
    prefer_rlib: true, // Need this to avoid dynamic link error.
}

rust_library {
    name: &quot;libgreetings&quot;,
    crate_name: &quot;greetings&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}
</code></pre>
<p><em>hello_rust/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust demo.

use greetings::greeting;
use textwrap::fill;

/// Prints a greeting to standard output.
fn main() {
    println!(&quot;{}&quot;, fill(&amp;greeting(&quot;Bob&quot;), 24));
}
</code></pre>
<p><em>hello_rust/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">//! Greeting library.

/// Greet `name`.
pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {name}, it is very nice to meet you!&quot;)
}
</code></pre>
<p>æ‚¨å¯ä»¥åƒä¹‹å‰ä¸€æ ·æ„å»ºã€æ¨é€å’Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">m hello_rust_with_dep
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_with_dep&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust_with_dep
</code></pre>
<pre><code class="language-text">Hello Bob, it is very
nice to meet you!
</code></pre>
<h1><a class="header" href="#aidl" id="aidl">AIDL</a></h1>
<p>Rust æ”¯æŒ <a href="https://developer.android.com/guide/components/aidl">Android æ¥å£å®šä¹‰è¯­è¨€ (AIDL)</a>ï¼š</p>
<ul>
<li>Rust ä»£ç å¯ä»¥è°ƒç”¨ç°æœ‰çš„ AIDL æœåŠ¡å™¨ï¼Œ</li>
<li>æ‚¨å¯ä»¥åœ¨ Rust ä¸­åˆ›å»ºæ–°çš„ AIDL æœåŠ¡å™¨ã€‚</li>
</ul>
<h1><a class="header" href="#-birthday-service-interface-" id="-birthday-service-interface-">/** Birthday service interface. */</a></h1>
<p>To illustrate how to use Rust with Binder, we're going to walk through the process of creating a Binder interface. We're then going to both implement the described service and write client code that talks to that service.</p>
<h1><a class="header" href="#aidl-æ¥å£" id="aidl-æ¥å£">AIDL æ¥å£</a></h1>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ AIDL æ¥å£å£°æ˜æ‚¨çš„æœåŠ¡çš„ APIï¼š</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>birthday_service/aidl/Android.bp</em>:</p>
<pre><code class="language-javascript">aidl_interface {
    name: &quot;com.example.birthdayservice&quot;,
    srcs: [&quot;com/example/birthdayservice/*.aidl&quot;],
    unstable: true,
    backend: {
        rust: { // Rust is not enabled by default
            enabled: true,
        },
    },
}
</code></pre>
<details>
<ul>
<li>Note that the directory structure under the <code>aidl/</code> directory needs to match the package name used in the AIDL file, i.e. the package is <code>com.example.birthdayservice</code> and the file is at <code>aidl/com/example/IBirthdayService.aidl</code>.</li>
</ul>
</details>
<h1><a class="header" href="#generated-service-api" id="generated-service-api">Generated Service API</a></h1>
<p>Binder generates a trait corresponding to the interface definition. trait to talk to the service.</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years);
}
</code></pre>
<p><em>Generated trait</em>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt;;
}
</code></pre>
<p>Your service will need to implement this trait, and your client will use this trait to talk to the service.</p>
<details>
<ul>
<li>The generated bindings can be found at <code>out/soong/.intermediates/&lt;path to module&gt;/</code>.</li>
<li>Point out how the generated function signature, specifically the argument and return types, correspond the interface definition.
<ul>
<li><code>String</code> for an argument results in a different Rust type than <code>String</code> as a return type.</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#æœåŠ¡å®ç°" id="æœåŠ¡å®ç°">æœåŠ¡å®ç°</a></h1>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥å®ç°AIDLæœåŠ¡ï¼š</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

/// The `IBirthdayService` implementation.
pub struct BirthdayService;

impl binder::Interface for BirthdayService {}

impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(&amp;self, name: &amp;str, years: i32) -&gt; binder::Result&lt;String&gt; {
        Ok(format!(&quot;Happy Birthday {name}, congratulations with the {years} years!&quot;))
    }
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libbirthdayservice&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    crate_name: &quot;birthdayservice&quot;,
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
}
</code></pre>
<details>
<ul>
<li>Point out the path to the generated <code>IBirthdayService</code> trait, and explain why each of the segments is necessary.</li>
<li>TODO: What does the <code>binder::Interface</code> trait do? Are there methods to override? Where source?</li>
</ul>
</details>
<h1><a class="header" href="#aidl-æœåŠ¡å™¨" id="aidl-æœåŠ¡å™¨">AIDL æœåŠ¡å™¨</a></h1>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªæš´éœ²æœåŠ¡çš„æœåŠ¡å™¨ï¼š</p>
<p><em>birthday_service/src/server.rs</em>:</p>
<pre><code class="language-rust ignore">//! Birthday service.
use birthdayservice::BirthdayService;
use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::BnBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Entry point for birthday service.
fn main() {
    let birthday_service = BirthdayService;
    let birthday_service_binder = BnBirthdayService::new_binder(
        birthday_service,
        binder::BinderFeatures::default(),
    );
    binder::add_service(SERVICE_IDENTIFIER, birthday_service_binder.as_binder())
        .expect(&quot;Failed to register service&quot;);
    binder::ProcessState::join_thread_pool();
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_server&quot;,
    crate_name: &quot;birthday_server&quot;,
    srcs: [&quot;src/server.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
        &quot;libbirthdayservice&quot;,
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<details>
<p>The process for taking a user-defined service implementation (in this case the <code>BirthdayService</code> type, which implements the <code>IBirthdayService</code>) and starting it as a Binder service has multiple steps, and may appear more complicated than students are used to if they've used Binder from C++ or another language. Explain to students why each step is necessary.</p>
<ol>
<li>Create an instance of your service type (<code>BirthdayService</code>).</li>
<li>Wrap the service object in corresponding <code>Bn*</code> type (<code>BnBirthdayService</code> in this case). This type is generated by Binder and provides the common Binder functionality that would be provided by the <code>BnBinder</code> base class in C++. We don't have inheritance in Rust, so instead we use composition, putting our <code>BirthdayService</code> within the generated <code>BnBinderService</code>.</li>
<li>Call <code>add_service</code>, giving it a service identifier and your service object (the <code>BnBirthdayService</code> object in the example).</li>
<li>Call <code>join_thread_pool</code> to add the current thread to Binder's thread pool and start listening for connections.</li>
</ol>
</details>
<h1><a class="header" href="#éƒ¨ç½²" id="éƒ¨ç½²">éƒ¨ç½²</a></h1>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥æ„å»ºã€æ¨é€å’Œå¯åŠ¨æœåŠ¡ï¼š</p>
<pre><code class="language-shell">m birthday_server
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_server&quot; /data/local/tmp
adb root
adb shell /data/local/tmp/birthday_server
</code></pre>
<p>åœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­ï¼Œæ£€æŸ¥è¯¥æœåŠ¡æ˜¯å¦æ­£åœ¨è¿è¡Œï¼š</p>
<pre><code class="language-shell">adb shell service check birthdayservice
</code></pre>
<pre><code class="language-text">Service birthdayservice: found
</code></pre>
<p>æ‚¨è¿˜å¯ä»¥ä½¿ç”¨ <code>service call</code> å‘½ä»¤è°ƒç”¨è¯¥æœåŠ¡ï¼š</p>
<pre><code class="language-shell">adb shell service call birthdayservice 1 s16 Bob i32 24
</code></pre>
<pre><code class="language-text">Result: Parcel(
  0x00000000: 00000000 00000036 00610048 00700070 '....6...H.a.p.p.'
  0x00000010: 00200079 00690042 00740072 00640068 'y. .B.i.r.t.h.d.'
  0x00000020: 00790061 00420020 0062006f 0020002c 'a.y. .B.o.b.,. .'
  0x00000030: 006f0063 0067006e 00610072 00750074 'c.o.n.g.r.a.t.u.'
  0x00000040: 0061006c 00690074 006e006f 00200073 'l.a.t.i.o.n.s. .'
  0x00000050: 00690077 00680074 00740020 00650068 'w.i.t.h. .t.h.e.'
  0x00000060: 00320020 00200034 00650079 00720061 ' .2.4. .y.e.a.r.'
  0x00000070: 00210073 00000000                   's.!.....        ')
</code></pre>
<h1><a class="header" href="#aidl-å®¢æˆ·ç«¯" id="aidl-å®¢æˆ·ç«¯">AIDL å®¢æˆ·ç«¯</a></h1>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæˆ‘ä»¬çš„æ–°æœåŠ¡åˆ›å»ºä¸€ä¸ª Rust å®¢æˆ·ç«¯ã€‚</p>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">use com_example_birthdayservice::aidl::com::example::birthdayservice::IBirthdayService::IBirthdayService;
use com_example_birthdayservice::binder;

const SERVICE_IDENTIFIER: &amp;str = &quot;birthdayservice&quot;;

/// Call the birthday service.
fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let name = std::env::args().nth(1).unwrap_or_else(|| String::from(&quot;Bob&quot;));
    let years = std::env::args()
        .nth(2)
        .and_then(|arg| arg.parse::&lt;i32&gt;().ok())
        .unwrap_or(42);

    binder::ProcessState::start_thread_pool();
    let service = binder::get_interface::&lt;dyn IBirthdayService&gt;(SERVICE_IDENTIFIER)
        .map_err(|_| &quot;Failed to connect to BirthdayService&quot;)?;

    // Call the service.
    let msg = service.wishHappyBirthday(&amp;name, years)?;
    println!(&quot;{msg}&quot;);
}
</code></pre>
<p><em>birthday_service/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;birthday_client&quot;,
    crate_name: &quot;birthday_client&quot;,
    srcs: [&quot;src/client.rs&quot;],
    rustlibs: [
        &quot;com.example.birthdayservice-rust&quot;,
        &quot;libbinder_rs&quot;,
    ],
    prefer_rlib: true, // To avoid dynamic link error.
}
</code></pre>
<p>è¯·æ³¨æ„ï¼Œå®¢æˆ·ç«¯ä¸ä¾èµ–äº <code>libbirthdayservice</code>ã€‚</p>
<p>åœ¨æ‚¨çš„è®¾å¤‡ä¸Šæ„å»ºã€æ¨é€å¹¶è¿è¡Œå®¢æˆ·ç«¯ï¼š</p>
<pre><code class="language-shell">m birthday_client
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/birthday_client&quot; /data/local/tmp
adb shell /data/local/tmp/birthday_client Charlie 60
</code></pre>
<pre><code class="language-text">Happy Birthday Charlie, congratulations with the 60 years!
</code></pre>
<details>
<ul>
<li><code>Strong&lt;dyn IBirthdayService&gt;</code> is the trait object representing the service that the client has connected to.
<ul>
<li><code>Strong</code> is a custom smart pointer type for Binder. It handles both an in-process ref count for the service trait object, and the global Binder ref count that tracks how many processes have a reference to the object.</li>
<li>Note that the trait object that the client uses to talk to the service uses the exact same trait that the server implements. For a given Binder interface, there is a single Rust trait generated that both client and server use.</li>
</ul>
</li>
<li>Use the same service identifier used when registering the service. This should ideally be defined in a common crate that both the client and server can depend on.</li>
</ul>
</details>
<h1><a class="header" href="#æ›´æ”¹-api" id="æ›´æ”¹-api">æ›´æ”¹ API</a></h1>
<p>è®©æˆ‘ä»¬æ‰©å±•APIä»¥æä¾›æ›´å¤šåŠŸèƒ½ï¼šæˆ‘ä»¬å¸Œæœ›å…è®¸å®¢æˆ·ç«¯æŒ‡å®šç”Ÿæ—¥è´ºå¡çš„è¡Œåˆ—è¡¨ï¼š</p>
<pre><code class="language-java">package com.example.birthdayservice;

/** Birthday service interface. */
interface IBirthdayService {
    /** Generate a Happy Birthday message. */
    String wishHappyBirthday(String name, int years, in String[] text);
}
</code></pre>
<p>This results in an updated trait definition for <code>IBirthdayService</code>:</p>
<pre><code class="language-rust ignore">trait IBirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt;;
}
</code></pre>
<details>
<ul>
<li>Note how the <code>String[]</code> in the AIDL definition is translated as a <code>&amp;[String]</code> in Rust, i.e. that idiomatic Rust types are used in the generated bindings wherever possible:
<ul>
<li><code>in</code> array arguments are translated to slices.</li>
<li><code>out</code> and <code>inout</code> args are translated to <code>&amp;mut Vec&lt;T&gt;</code>.</li>
<li>Return values are translated to returning a <code>Vec&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#updating-client-and-service" id="updating-client-and-service">Updating Client and Service</a></h1>
<p>Update the client and server code to account for the new API.</p>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishHappyBirthday(
        &amp;self,
        name: &amp;str,
        years: i32,
        text: &amp;[String],
    ) -&gt; binder::Result&lt;String&gt; {
        let mut msg = format!(
            &quot;Happy Birthday {name}, congratulations with the {years} years!&quot;,
        );

        for line in text {
            msg.push('\n');
            msg.push_str(line);
        }

        Ok(msg)
    }
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">let msg = service.wishHappyBirthday(
    &amp;name,
    years,
    &amp;[
        String::from(&quot;Habby birfday to yuuuuu&quot;),
        String::from(&quot;And also: many more&quot;),
    ],
)?;
</code></pre>
<details>
<ul>
<li>TODO: Move code snippets into project files where they'll actually be built?</li>
</ul>
</details>
<h1><a class="header" href="#working-with-aidl-types" id="working-with-aidl-types">Working With AIDL Types</a></h1>
<p>AIDL types translate into the appropriate idiomatic Rust type:</p>
<ul>
<li>Primitive types map (mostly) to idiomatic Rust types.</li>
<li>Collection types like slices, <code>Vec</code>s and string types are supported.</li>
<li>References to AIDL objects and file handles can be sent between clients and services.</li>
<li>File handles and parcelables are fully supported.</li>
</ul>
<h1><a class="header" href="#primitive-types" id="primitive-types">Primitive Types</a></h1>
<p>Primitive types map (mostly) idiomatically:</p>
<table><thead><tr><th>AIDL Type</th><th>Rust Type</th><th>Note</th></tr></thead><tbody>
<tr><td><code>boolean</code></td><td><code>bool</code></td><td></td></tr>
<tr><td><code>byte</code></td><td><code>i8</code></td><td>Note that bytes are signed.</td></tr>
<tr><td><code>char</code></td><td><code>u16</code></td><td>Note the usage of <code>u16</code>, NOT <code>u32</code>.</td></tr>
<tr><td><code>int</code></td><td><code>i32</code></td><td></td></tr>
<tr><td><code>long</code></td><td><code>i64</code></td><td></td></tr>
<tr><td><code>float</code></td><td><code>f32</code></td><td></td></tr>
<tr><td><code>double</code></td><td><code>f64</code></td><td></td></tr>
<tr><td>String</td><td>String</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#æ•°ç»„arrays-1" id="æ•°ç»„arrays-1">æ•°ç»„ï¼ˆArraysï¼‰</a></h1>
<p>The array types (<code>T[]</code>, <code>byte[]</code>, and <code>List&lt;T&gt;</code>) get translated to the appropriate Rust array type depending on how they are used in the function signature:</p>
<table><thead><tr><th>Position</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><code>in</code> argument</td><td><code>&amp;[T]</code></td></tr>
<tr><td><code>out</code>/<code>inout</code> argument</td><td><code>&amp;mut Vec&lt;T&gt;</code></td></tr>
<tr><td>Return</td><td><code>Vec&lt;T&gt;</code></td></tr>
</tbody></table>
<details>
<ul>
<li>In Android 13 or higher, fixed-size arrays are supported, i.e. <code>T[N]</code> becomes <code>[T; N]</code>. Fixed-size arrays can have multiple dimensions (e.g. <code>int[3][4]</code>). In the Java backend, fixed-size arrays are represented as array types.</li>
<li>Arrays in parcelable fields always get translated to <code>Vec&lt;T&gt;</code>.</li>
</ul>
</details>
<h1><a class="header" href="#ç‰¹å¾å¯¹è±¡" id="ç‰¹å¾å¯¹è±¡">ç‰¹å¾å¯¹è±¡</a></h1>
<p>AIDL objects can be sent either as a concrete AIDL type or as the type-erased <code>IBinder</code> interface:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayInfoProvider.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

interface IBirthdayInfoProvider {
    String name();
    int years();
}
</code></pre>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">import com.example.birthdayservice.IBirthdayInfoProvider;

interface IBirthdayService {
    /** The same thing, but using a binder object. */
    String wishWithProvider(IBirthdayInfoProvider provider);

    /** The same thing, but using `IBinder`. */
    String wishWithErasedProvider(IBinder provider);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">/// Rust struct implementing the `IBirthdayInfoProvider` interface.
struct InfoProvider {
    name: String,
    age: u8,
}

impl binder::Interface for InfoProvider {}

impl IBirthdayInfoProvider for InfoProvider {
    fn name(&amp;self) -&gt; binder::Result&lt;String&gt; {
        Ok(self.name.clone())
    }

    fn years(&amp;self) -&gt; binder::Result&lt;i32&gt; {
        Ok(self.age as i32)
    }
}

fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    // Create a binder object for the `IBirthdayInfoProvider` interface.
    let provider = BnBirthdayInfoProvider::new_binder(
        InfoProvider { name: name.clone(), age: years as u8 },
        BinderFeatures::default(),
    );

    // Send the binder object to the service.
    service.wishWithProvider(&amp;provider)?;

    // Perform the same operation but passing the provider as an `SpIBinder`.
    service.wishWithErasedProvider(&amp;provider.as_binder())?;
}
</code></pre>
<details>
<ul>
<li>Note the usage of <code>BnBirthdayInfoProvider</code>. This serves the same purpose as <code>BnBirthdayService</code> that we saw previously.</li>
</ul>
</details>
<h1><a class="header" href="#å˜é‡-1" id="å˜é‡-1">å˜é‡</a></h1>
<p>Binder for Rust supports sending parcelables directly:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/BirthdayInfo.aidl</em>:</p>
<pre><code class="language-java">package com.example.birthdayservice;

parcelable BirthdayInfo {
    String name;
    int years;
}
</code></pre>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">import com.example.birthdayservice.BirthdayInfo;

interface IBirthdayService {
    /** The same thing, but with a parcelable. */
    String wishWithInfo(in BirthdayInfo info);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    let info = BirthdayInfo { name: &quot;Alice&quot;.into(), years: 123 };
    service.wishWithInfo(&amp;info)?;
}
</code></pre>
<h1><a class="header" href="#sending-files" id="sending-files">Sending Files</a></h1>
<p>Files can be sent between Binder clients/servers using the <code>ParcelFileDescriptor</code> type:</p>
<p><em>birthday_service/aidl/com/example/birthdayservice/IBirthdayService.aidl</em>:</p>
<pre><code class="language-java">interface IBirthdayService {
    /** The same thing, but loads info from a file. */
    String wishFromFile(in ParcelFileDescriptor infoFile);
}
</code></pre>
<p><em>birthday_service/src/client.rs</em>:</p>
<pre><code class="language-rust ignore">fn main() {
    binder::ProcessState::start_thread_pool();
    let service = connect().expect(&quot;Failed to connect to BirthdayService&quot;);

    // Open a file and put the birthday info in it.
    let mut file = File::create(&quot;/data/local/tmp/birthday.info&quot;).unwrap();
    writeln!(file, &quot;{name}&quot;)?;
    writeln!(file, &quot;{years}&quot;)?;

    // Create a `ParcelFileDescriptor` from the file and send it.
    let file = ParcelFileDescriptor::new(file);
    service.wishFromFile(&amp;file)?;
}
</code></pre>
<p><em>birthday_service/src/lib.rs</em>:</p>
<pre><code class="language-rust ignore">impl IBirthdayService for BirthdayService {
    fn wishFromFile(
        &amp;self,
        info_file: &amp;ParcelFileDescriptor,
    ) -&gt; binder::Result&lt;String&gt; {
        // Convert the file descriptor to a `File`. `ParcelFileDescriptor` wraps
        // an `OwnedFd`, which can be cloned and then used to create a `File`
        // object.
        let mut info_file = info_file
            .as_ref()
            .try_clone()
            .map(File::from)
            .expect(&quot;Invalid file handle&quot;);

        let mut contents = String::new();
        info_file.read_to_string(&amp;mut contents).unwrap();

        let mut lines = contents.lines();
        let name = lines.next().unwrap();
        let years: i32 = lines.next().unwrap().parse().unwrap();

        Ok(format!(&quot;Happy Birthday {name}, congratulations with the {years} years!&quot;))
    }
}
</code></pre>
<details>
<ul>
<li><code>ParcelFileDescriptor</code> wraps an <code>OwnedFd</code>, and so can be created from a <code>File</code> (or any other type that wraps an <code>OwnedFd</code>), and can be used to create a new <code>File</code> handle on the other side.</li>
<li>Other types of file descriptors can be wrapped and sent, e.g. TCP, UDP, and UNIX sockets.</li>
</ul>
</details>
<h1><a class="header" href="#testing-in-android" id="testing-in-android">Testing in Android</a></h1>
<p>Building on <a href="android/../testing.html">Testing</a>, we will now look at how unit tests work in AOSP. Use the <code>rust_test</code> module for your unit tests:</p>
<p><em>testing/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_library {
    name: &quot;libleftpad&quot;,
    crate_name: &quot;leftpad&quot;,
    srcs: [&quot;src/lib.rs&quot;],
}

rust_test {
    name: &quot;libleftpad_test&quot;,
    crate_name: &quot;leftpad_test&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    host_supported: true,
    test_suites: [&quot;general-tests&quot;],
}
</code></pre>
<p><em>testing/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Left-padding library.

/// Left-pad `s` to `width`.
pub fn leftpad(s: &amp;str, width: usize) -&gt; String {
    format!(&quot;{s:&gt;width$}&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn short_string() {
        assert_eq!(leftpad(&quot;foo&quot;, 5), &quot;  foo&quot;);
    }

    #[test]
    fn long_string() {
        assert_eq!(leftpad(&quot;foobar&quot;, 6), &quot;foobar&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can now run the test with</p>
<pre><code class="language-shell">atest --host libleftpad_test
</code></pre>
<p>The output looks like this:</p>
<pre><code class="language-text">INFO: Elapsed time: 2.666s, Critical Path: 2.40s
INFO: 3 processes: 2 internal, 1 linux-sandbox.
INFO: Build completed successfully, 3 total actions
//comprehensive-rust-android/testing:libleftpad_test_host            PASSED in 2.3s
    PASSED  libleftpad_test.tests::long_string (0.0s)
    PASSED  libleftpad_test.tests::short_string (0.0s)
Test cases: finished with 2 passing and 0 failing out of 2 test cases
</code></pre>
<p>Notice how you only mention the root of the library crate. Tests are found recursively in nested modules.</p>
<h1><a class="header" href="#googletest" id="googletest">GoogleTest</a></h1>
<p>The <a href="https://docs.rs/googletest/">GoogleTest</a> crate allows for flexible test assertions using <em>matchers</em>:</p>
<pre><code class="language-rust ignore">use googletest::prelude::*;

#[googletest::test]
fn test_elements_are() {
    let value = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
    expect_that!(value, elements_are!(eq(&amp;&quot;foo&quot;), lt(&amp;&quot;xyz&quot;), starts_with(&quot;b&quot;)));
}
</code></pre>
<p>å¦‚æœæˆ‘ä»¬å°†æœ€åä¸€ä¸ªå…ƒç´ æ›´æ”¹ä¸º <code>&quot;!&quot;</code>ï¼Œæµ‹è¯•å°†å¤±è´¥ï¼Œå¹¶ä¼šæä¾›è¯¦ç»†çš„é”™è¯¯æ¶ˆæ¯æ¥æŒ‡å‡ºé”™è¯¯çš„ä½ç½®ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">---- test_elements_are stdout ----
Value of: value
Expected: has elements:
  0. is equal to &quot;foo&quot;
  1. is less than &quot;xyz&quot;
  2. starts with prefix &quot;!&quot;
Actual: [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;],
  where element #2 is &quot;baz&quot;, which does not start with &quot;!&quot;
  at src/testing/googletest.rs:6:5
Error: See failure output above
</code></pre>
<details>
<ul>
<li>
<p>GoogleTest ä¸æ˜¯ Rust Playground çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤æ‚¨éœ€è¦åœ¨æœ¬åœ°ç¯å¢ƒä¸­è¿è¡Œæ­¤ç¤ºä¾‹ã€‚ä½¿ç”¨ <code>cargo add googletest</code> å¿«é€Ÿå°†å…¶æ·»åŠ åˆ°ç°æœ‰ Cargo é¡¹ç›®ä¸­ã€‚</p>
</li>
<li>
<p><code>use googletest::prelude::*;</code> è¡Œä¼šå¯¼å…¥ä¸€äº› <a href="https://docs.rs/googletest/latest/googletest/prelude/index.html">å¸¸ç”¨çš„å®å’Œç±»å‹</a>ã€‚</p>
</li>
<li>
<p>This just scratches the surface, there are many builtin matchers. Consider going through the first chapter of <a href="https://rust-exercises.com/advanced-testing/">&quot;Advanced testing for Rust applications&quot;</a>, a self-guided Rust course: it provides a guided introduction to the library, with exercises to help you get comfortable with <code>googletest</code> macros, its matchers and its overall philosophy.</p>
</li>
<li>
<p>A particularly nice feature is that mismatches in multi-line strings are shown as a diff:</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_multiline_string_diff() {
    let haiku = &quot;Memory safety found,\n\
                 Rust's strong typing guides the way,\n\
                 Secure code you'll write.&quot;;
    assert_that!(
        haiku,
        eq(&quot;Memory safety found,\n\
            Rust's silly humor guides the way,\n\
            Secure code you'll write.&quot;)
    );
}
</code></pre>
<p>æ˜¾ç¤ºç”¨é¢œè‰²æ ‡è¯†çš„å·®å¼‚ï¼ˆæ­¤å¤„æœªæ˜¾ç¤ºé¢œè‰²ï¼‰ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-text">    Value of: haiku
Expected: is equal to &quot;Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write.&quot;
Actual: &quot;Memory safety found,\nRust's strong typing guides the way,\nSecure code you'll write.&quot;,
  which isn't equal to &quot;Memory safety found,\nRust's silly humor guides the way,\nSecure code you'll write.&quot;
Difference(-actual / +expected):
 Memory safety found,
-Rust's strong typing guides the way,
+Rust's silly humor guides the way,
 Secure code you'll write.
  at src/testing/googletest.rs:17:5
</code></pre>
<ul>
<li>crate æ˜¯ <a href="https://google.github.io/googletest/">é€‚ç”¨äº C++ çš„ GoogleTest</a> çš„ Rust ç§»æ¤ç‰ˆã€‚</li>
</ul>
</details><h1><a class="header" href="#æ¨¡æ‹Ÿ" id="æ¨¡æ‹Ÿ">æ¨¡æ‹Ÿ</a></h1>
<p>å¯¹äºæ¨¡æ‹Ÿï¼Œ<a href="https://docs.rs/mockall/">Mockall</a> æ˜¯ä¸€ä¸ªå¹¿æ³›ä½¿ç”¨çš„åº“ã€‚æ‚¨éœ€è¦é‡æ„ä»£ç æ‰èƒ½ä½¿ç”¨ traitï¼Œç„¶åä¾¿å¯å¾ˆå¿«åœ°å¯¹å…¶è¿›è¡Œæ¨¡æ‹Ÿï¼š</p>
<pre><code class="language-rust ignore">use std::time::Duration;

#[mockall::automock]
pub trait Pet {
    fn is_hungry(&amp;self, since_last_meal: Duration) -&gt; bool;
}

#[test]
fn test_robot_dog() {
    let mut mock_dog = MockPet::new();
    mock_dog.expect_is_hungry().return_const(true);
    assert_eq!(mock_dog.is_hungry(Duration::from_secs(10)), true);
}
</code></pre>
<details>
<ul>
<li>
<p>Mockall is the recommended mocking library in Android (AOSP). There are other <a href="https://crates.io/keywords/mock">mocking libraries available on crates.io</a>, in particular in the area of mocking HTTP services. The other mocking libraries work in a similar fashion as Mockall, meaning that they make it easy to get a mock implementation of a given trait.</p>
</li>
<li>
<p>è¯·æ³¨æ„ï¼Œæ¨¡æ‹Ÿåœ¨æŸç§ç¨‹åº¦ä¸Šå…·æœ‰ <em>äº‰è®®æ€§</em>ï¼šå€ŸåŠ©æ¨¡æ‹Ÿï¼Œæ‚¨å¯ä»¥å°†æµ‹è¯•ä¸å…¶ä¾èµ–é¡¹å®Œå…¨éš”ç¦»ã€‚æœ€ç«‹ç«¿è§å½±çš„æ˜¯ï¼Œæµ‹è¯•ä½œä¸šä¼šæ›´å¿«ä¸”æ›´ç¨³å®šã€‚å¦ä¸€æ–¹é¢ï¼Œæ¨¡æ‹Ÿå¯¹è±¡çš„é…ç½®å¯èƒ½å‡ºç°é”™è¯¯ï¼Œå¹¶è¿”å›ä¸çœŸå®ä¾èµ–é¡¹ä¸åŒçš„è¾“å‡ºã€‚</p>
<p>å»ºè®®æ‚¨å°½å¯èƒ½ä½¿ç”¨çœŸå®ä¾èµ–é¡¹ã€‚ä¾‹å¦‚ï¼Œè®¸å¤šæ•°æ®åº“éƒ½æ”¯æŒæ‚¨é…ç½®å†…å­˜åç«¯ã€‚è¿™æ„å‘³ç€ï¼Œæ‚¨å¯ä»¥åœ¨æµ‹è¯•ä¸­è·å¾—æ­£ç¡®çš„åŠŸèƒ½è¡Œä¸ºï¼Œè€Œä¸”æµ‹è¯•é€Ÿåº¦ä¼šå¾ˆå¿«å¹¶ä¼šè‡ªåŠ¨æ¸…ç†ã€‚</p>
<p>åŒæ ·ï¼Œè®¸å¤š Web æ¡†æ¶éƒ½æ”¯æŒæ‚¨å¯åŠ¨è¿›ç¨‹å†…æœåŠ¡å™¨ï¼Œè¯¥æœåŠ¡å™¨ä¼šç»‘å®šåˆ° <code>localhost</code> ä¸Šçš„éšæœºç«¯å£ã€‚ç›¸æ¯”æ¨¡æ‹Ÿæ¡†æ¶ï¼Œè¯·å§‹ç»ˆä¼˜å…ˆé€‰æ‹©è¿™ç§æ–¹å¼ï¼Œå› ä¸ºè¿™æœ‰åŠ©äºæ‚¨åœ¨çœŸå®ç¯å¢ƒä¸­æµ‹è¯•ä»£ç ã€‚</p>
</li>
<li>
<p>Mockall ä¸æ˜¯ Rust Playground çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤æ‚¨éœ€è¦åœ¨æœ¬åœ°ç¯å¢ƒä¸­è¿è¡Œæ­¤ç¤ºä¾‹ã€‚ä½¿ç”¨ <code>cargo add mockall</code> å¿«é€Ÿå°† Mockall æ·»åŠ åˆ°ç°æœ‰ Cargo é¡¹ç›®ä¸­ã€‚</p>
</li>
<li>
<p>Mockall å…·æœ‰æ›´å¤šåŠŸèƒ½ã€‚å…·ä½“è€Œè¨€ï¼Œæ‚¨å¯ä»¥è®¾ç½®åŸºäºä¼ é€’å‚æ•°çš„é¢„æœŸå€¼ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨è¯¥åŠŸèƒ½æ¥æ¨¡æ‹Ÿä¸€åªçŒ«ï¼Œå®ƒåœ¨ä¸Šæ¬¡è¢«å–‚é£Ÿçš„ 3 å°æ—¶åä¼šæ„Ÿåˆ°é¥¥é¥¿ï¼š</p>
</li>
</ul>
<pre><code class="language-rust ignore">#[test]
fn test_robot_cat() {
    let mut mock_cat = MockPet::new();
    mock_cat
        .expect_is_hungry()
        .with(mockall::predicate::gt(Duration::from_secs(3 * 3600)))
        .return_const(true);
    mock_cat.expect_is_hungry().return_const(false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(1 * 3600)), false);
    assert_eq!(mock_cat.is_hungry(Duration::from_secs(5 * 3600)), true);
}
</code></pre>
<ul>
<li>æ‚¨å¯ä»¥ä½¿ç”¨ <code>.times(n)</code> å°†è°ƒç”¨æ¨¡æ‹Ÿæ–¹æ³•çš„æ¬¡æ•°é™åˆ¶ä¸º <code>n</code>ï¼Œå¦‚æœä¸æ»¡è¶³æ­¤æ¡ä»¶ï¼Œæ¨¡æ‹Ÿå¯¹è±¡è¢«é‡Šæ”¾æ—¶ä¼šè‡ªåŠ¨ panicã€‚</li>
</ul>
</details><h1><a class="header" href="#æ—¥å¿—è®°å½•" id="æ—¥å¿—è®°å½•">æ—¥å¿—è®°å½•</a></h1>
<p>ä½ åº”è¯¥ä½¿ç”¨ <code>log</code> crate æ¥è‡ªåŠ¨è®°å½•æ—¥å¿—åˆ° <code>logcat</code> ï¼ˆè®¾å¤‡ä¸Šï¼‰æˆ– <code>stdout</code>ï¼ˆä¸»æœºä¸Šï¼‰ï¼š</p>
<p><em>hello_rust_logs/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;hello_rust_logs&quot;,
    crate_name: &quot;hello_rust_logs&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;liblog_rust&quot;,
        &quot;liblogger&quot;,
    ],
    host_supported: true,
}
</code></pre>
<p><em>hello_rust_logs/src/main.rs</em>:</p>
<pre><code class="language-rust ignore">//! Rust logging demo.

use log::{debug, error, info};

/// Logs a greeting.
fn main() {
    logger::init(
        logger::Config::default()
            .with_tag_on_device(&quot;rust&quot;)
            .with_max_level(log::LevelFilter::Trace),
    );
    debug!(&quot;Starting program.&quot;);
    info!(&quot;Things are going fine.&quot;);
    error!(&quot;Something went wrong!&quot;);
}
</code></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m hello_rust_logs
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/hello_rust_logs&quot; /data/local/tmp
adb shell /data/local/tmp/hello_rust_logs
</code></pre>
<p>æ—¥å¿—å°†ä¼šåœ¨ <code>adb logcat</code> ä¸­æ˜¾ç¤ºï¼š</p>
<pre><code class="language-shell">adb logcat -s rust
</code></pre>
<pre><code class="language-text">09-08 08:38:32.454  2420  2420 D rust: hello_rust_logs: Starting program.
09-08 08:38:32.454  2420  2420 I rust: hello_rust_logs: Things are going fine.
09-08 08:38:32.454  2420  2420 E rust: hello_rust_logs: Something went wrong!
</code></pre>
<details>
<ul>
<li>The logger implementation in <code>liblogger</code> is only needed in the final binary, if you're logging from a library you only need the <code>log</code> facade crate.</li>
</ul>
</details>
<h1><a class="header" href="#äº’æ“ä½œæ€§" id="äº’æ“ä½œæ€§">äº’æ“ä½œæ€§</a></h1>
<p>Rust å¯¹äºä¸å…¶ä»–ç¼–ç¨‹è¯­è¨€çš„äº’æ“ä½œæ€§æœ‰ç€å‡ºè‰²çš„æ”¯æŒã€‚è¿™æ„å‘³ç€æ‚¨å¯ä»¥ï¼š</p>
<ul>
<li>ä»å…¶ä»–è¯­è¨€è°ƒç”¨ Rust å‡½æ•°ã€‚</li>
<li>ä» Rust è°ƒç”¨ç”¨å…¶ä»–è¯­è¨€ç¼–å†™çš„å‡½æ•°ã€‚</li>
</ul>
<p>å½“æ‚¨ä»å¤–éƒ¨è¯­è¨€è°ƒç”¨å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºä½¿ç”¨ <strong>å¤–éƒ¨å‡½æ•°æ¥å£</strong>ï¼ˆ<em>Foreign Function Interface</em>ï¼Œ FFIï¼‰ã€‚</p>
<h1><a class="header" href="#ä¸-c-çš„äº’æ“ä½œæ€§" id="ä¸-c-çš„äº’æ“ä½œæ€§">ä¸ C çš„äº’æ“ä½œæ€§</a></h1>
<p>Rust å¯¹ä½¿ç”¨ C è°ƒç”¨çº¦å®šé“¾æ¥ç›®æ ‡æ–‡ä»¶æä¾›äº†å®Œæ•´çš„æ”¯æŒã€‚åŒæ ·åœ°ï¼Œä½ å¯ä»¥å¯¼å‡º Rust å‡½æ•°å¹¶ä» C ä¸­è°ƒç”¨å®ƒä»¬ã€‚</p>
<p>å¦‚æœä½ æ„¿æ„çš„è¯ï¼Œä½ å¯ä»¥æ‰‹å·¥å®Œæˆå®ƒï¼š</p>
<pre><pre class="playground"><code class="language-rust">unsafe extern &quot;C&quot; {
    safe fn abs(x: i32) -&gt; i32;
}

fn main() {
    let x = -42;
    let abs_x = abs(x);
    println!(&quot;{x}, {abs_x}&quot;);
}
</code></pre></pre>
<p>We already saw this in the <a href="android/interoperability/../../unsafe-rust/exercise.html">Safe FFI Wrapper exercise</a>.</p>
<blockquote>
<p>è¿™å‡è®¾å¯¹ç›®æ ‡å¹³å°æ‹¥æœ‰å……åˆ†çš„äº†è§£ï¼Œä¸å»ºè®®ç”¨äºç”Ÿäº§ç¯å¢ƒã€‚</p>
</blockquote>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬å°†æ¢è®¨æ›´å¥½çš„é€‰æ‹©ã€‚</p>
<h1><a class="header" href="#ä½¿ç”¨-bindgen" id="ä½¿ç”¨-bindgen">ä½¿ç”¨ Bindgen</a></h1>
<p><a href="https://rust-lang.github.io/rust-bindgen/introduction.html">bindgen</a> å·¥å…·å¯ä»¥è‡ªåŠ¨ç”Ÿæˆ C å¤´æ–‡ä»¶çš„ç»‘å®šä»£ç ã€‚</p>
<p>é¦–å…ˆåˆ›å»ºä¸€ä¸ªå°å‹çš„ C è¯­è¨€åº“ï¼š</p>
<p>interoperability/bindgen/libbirthday.h:</p>
<pre><code class="language-c">typedef struct card {
  const char* name;
  int years;
} card;

void print_card(const card* card);
</code></pre>
<p><em>interoperability/bindgen/libbirthday.c</em>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;libbirthday.h&quot;

void print_card(const card* card) {
  printf(&quot;+--------------\n&quot;);
  printf(&quot;| Happy Birthday %s!\n&quot;, card-&gt;name);
  printf(&quot;| Congratulations with the %i years!\n&quot;, card-&gt;years);
  printf(&quot;+--------------\n&quot;);
}
</code></pre>
<p>å°†è¯¥åº“æ·»åŠ åˆ°ä½ çš„ <code>Android.bp</code> æ–‡ä»¶ä¸­ï¼š</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">cc_library {
    name: &quot;libbirthday&quot;,
    srcs: [&quot;libbirthday.c&quot;],
}
</code></pre>
<p>ä¸ºè¯¥åº“åˆ›å»ºä¸€ä¸ªåŒ…è£…å¤´æ–‡ä»¶ï¼ˆåœ¨æ­¤ç¤ºä¾‹ä¸­ä¸æ˜¯å¿…éœ€çš„ï¼‰ï¼š</p>
<p><em>interoperability/bindgen/libbirthday_wrapper.h</em>:</p>
<pre><code class="language-c">#include &quot;libbirthday.h&quot;
</code></pre>
<p>æ‚¨ç°åœ¨å¯ä»¥è‡ªåŠ¨ç”Ÿæˆç»‘å®šä»£ç ï¼š</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_bindgen {
    name: &quot;libbirthday_bindgen&quot;,
    crate_name: &quot;birthday_bindgen&quot;,
    wrapper_src: &quot;libbirthday_wrapper.h&quot;,
    source_stem: &quot;bindings&quot;,
    static_libs: [&quot;libbirthday&quot;],
}
</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ Rust ç¨‹åºä¸­ä½¿ç”¨è¿™äº›ç»‘å®šï¼š</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;print_birthday_card&quot;,
    srcs: [&quot;main.rs&quot;],
    rustlibs: [&quot;libbirthday_bindgen&quot;],
}
</code></pre>
<p><em>interoperability/bindgen/main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">//! Bindgen demo.

use birthday_bindgen::{card, print_card};

fn main() {
    let name = std::ffi::CString::new(&quot;Peter&quot;).unwrap();
    let card = card { name: name.as_ptr(), years: 42 };
    // SAFETY: The pointer we pass is valid because it came from a Rust
    // reference, and the `name` it contains refers to `name` above which also
    // remains valid. `print_card` doesn't store either pointer to use later
    // after it returns.
    unsafe {
        print_card(&amp;card as *const card);
    }
}
</code></pre></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m print_birthday_card
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/print_birthday_card&quot; /data/local/tmp
adb shell /data/local/tmp/print_birthday_card
</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬å¯ä»¥è¿è¡Œè‡ªåŠ¨ç”Ÿæˆçš„æµ‹è¯•æ¥ç¡®ä¿ç»‘å®šä»£ç æ­£å¸¸å·¥ä½œï¼š</p>
<p><em>interoperability/bindgen/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_test {
    name: &quot;libbirthday_bindgen_test&quot;,
    srcs: [&quot;:libbirthday_bindgen&quot;],
    crate_name: &quot;libbirthday_bindgen_test&quot;,
    test_suites: [&quot;general-tests&quot;],
    auto_gen_config: true,
    clippy_lints: &quot;none&quot;, // Generated file, skip linting
    lints: &quot;none&quot;,
}
</code></pre>
<pre><code class="language-shell">atest libbirthday_bindgen_test
</code></pre>
<h1><a class="header" href="#è°ƒç”¨-rust" id="è°ƒç”¨-rust">è°ƒç”¨ Rust</a></h1>
<p>å°† Rust å‡½æ•°å’Œç±»å‹å¯¼å‡ºåˆ° C å¾ˆç®€å•ï¼š</p>
<p><em>interoperability/rust/libanalyze/analyze.rs</em></p>
<pre><pre class="playground"><code class="language-rust editable">//! Rust FFI demo.
#![deny(improper_ctypes_definitions)]

use std::os::raw::c_int;

/// Analyze the numbers.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;C&quot; fn analyze_numbers(x: c_int, y: c_int) {
    if x &lt; y {
        println!(&quot;x ({x}) is smallest!&quot;);
    } else {
        println!(&quot;y ({y}) is probably larger than x ({x})&quot;);
    }
}
</code></pre></pre>
<p><em>interoperability/rust/libanalyze/analyze.h</em></p>
<pre><code class="language-c">#ifndef ANALYSE_H
#define ANALYSE_H

void analyze_numbers(int x, int y);

#endif
</code></pre>
<p><em>interoperability/rust/libanalyze/Android.bp</em></p>
<pre><code class="language-javascript">rust_ffi {
    name: &quot;libanalyze_ffi&quot;,
    crate_name: &quot;analyze_ffi&quot;,
    srcs: [&quot;analyze.rs&quot;],
    include_dirs: [&quot;.&quot;],
}
</code></pre>
<p>æˆ‘ä»¬ç°åœ¨å¯ä»¥ä»ä¸€ä¸ª C äºŒè¿›åˆ¶æ–‡ä»¶ä¸­è°ƒç”¨å®ƒï¼š</p>
<p><em>interoperability/rust/analyze/main.c</em></p>
<pre><code class="language-c">#include &quot;analyze.h&quot;

int main() {
  analyze_numbers(10, 20);
  analyze_numbers(123, 123);
  return 0;
}
</code></pre>
<p><em>interoperability/rust/analyze/Android.bp</em></p>
<pre><code class="language-javascript">cc_binary {
    name: &quot;analyze_numbers&quot;,
    srcs: [&quot;main.c&quot;],
    static_libs: [&quot;libanalyze_ffi&quot;],
}
</code></pre>
<p>åœ¨ä½ çš„è®¾å¤‡ä¸Šæ„å»ºï¼Œæ¨é€ï¼Œå¹¶è¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ ï¼š</p>
<pre><code class="language-shell">m analyze_numbers
adb push &quot;$ANDROID_PRODUCT_OUT/system/bin/analyze_numbers&quot; /data/local/tmp
adb shell /data/local/tmp/analyze_numbers
</code></pre>
<details>
<p><code>#[unsafe(no_mangle)]</code> disables Rust's usual name mangling, so the exported symbol will just be the name of the function. You can also use <code>#[unsafe(export_name = &quot;some_name&quot;)]</code> to specify whatever name you want.</p>
</details>
<h1><a class="header" href="#ä¸-c-äº¤äº’" id="ä¸-c-äº¤äº’">ä¸ C++ äº¤äº’</a></h1>
<p><a href="https://cxx.rs/">CXX crate</a> ä½¿å¾—åœ¨ Rust å’Œ C++ ä¹‹é—´è¿›è¡Œå®‰å…¨çš„äº’æ“ä½œæˆä¸ºå¯èƒ½ã€‚</p>
<p>æ•´ä½“çš„æ–¹æ³•å¦‚ä¸‹ï¼š</p>
<img src="android/interoperability/cpp/overview.svg">
<h1><a class="header" href="#æ¡¥æ¥æ¨¡å—" id="æ¡¥æ¥æ¨¡å—">æ¡¥æ¥æ¨¡å—</a></h1>
<p>CXXä¾èµ–äºæä¾›çš„å‡½æ•°ç­¾åè¯´æ˜ï¼Œè¿™äº›ç­¾åä¼šåœ¨ä¸ç”¨è¯­è¨€ä¹‹é—´è¿›è¡Œäº¤äº’ä½¿ç”¨ã€‚æ‚¨å¯ä»¥åœ¨å¸¦æœ‰ <code>#[cxx::bridge]</code> å±æ€§å®æ³¨è§£çš„ Rust æ¨¡å—ä¸­ä½¿ç”¨ extern ä»£ç å—æä¾›æ­¤è¯´æ˜ã€‚</p>
<pre><code class="language-rust ignore">#[allow(unsafe_op_in_unsafe_fn)]
#[cxx::bridge(namespace = &quot;org::blobstore&quot;)]
mod ffi {
    // Shared structs with fields visible to both languages.
    struct BlobMetadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    // C++ types and signatures exposed to Rust.
    unsafe extern &quot;C++&quot; {
        include!(&quot;include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}
</code></pre>
<details>
<ul>
<li>æ¡¥æ¥é€šå¸¸åœ¨æ‚¨çš„ crate å†…çš„ <code>ffi</code> æ¨¡å—ä¸­å£°æ˜ã€‚</li>
<li>æ ¹æ®åœ¨æ¡¥æ¥æ¨¡å—ä¸­è¿›è¡Œçš„å£°æ˜ï¼ŒCXX å°†ç”ŸæˆåŒ¹é…çš„ Rust å’Œ C++ ç±»å‹/å‡½æ•°å®šä¹‰ï¼Œä»¥ä¾¿å°†è¿™äº›å†…å®¹å…¬å¼€ç»™è¿™ä¸¤ç§è¯­è¨€ã€‚</li>
<li>å¦‚éœ€æŸ¥çœ‹ç”Ÿæˆçš„ Rust ä»£ç ï¼Œè¯·ä½¿ç”¨ <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> æŸ¥çœ‹å±•å¼€åçš„ proc å®ã€‚å¯¹äºå¤§å¤šæ•°ç¤ºä¾‹ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ <code>cargo expand ::ffi</code> æ¥ä»…å±•å¼€ <code>ffi</code> æ¨¡å—ï¼ˆä½†è¿™ä¸é€‚ç”¨äº Android é¡¹ç›®ï¼‰ã€‚</li>
<li>å¦‚éœ€æŸ¥çœ‹ç”Ÿæˆçš„ C++ ä»£ç ï¼Œè¯·åœ¨ <code>target/cxxbridge</code> ä¸­æŸ¥æ‰¾ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#rust-bridge-declarations" id="rust-bridge-declarations">Rust Bridge Declarations</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        type MyType; // Opaque type
        fn foo(&amp;self); // Method on `MyType`
        fn bar() -&gt; Box&lt;MyType&gt;; // Free function
    }
}

struct MyType(i32);

impl MyType {
    fn foo(&amp;self) {
        println!(&quot;{}&quot;, self.0);
    }
}

fn bar() -&gt; Box&lt;MyType&gt; {
    Box::new(MyType(123))
}
</code></pre>
<details>
<ul>
<li><code>extern &quot;Rust&quot;</code> ä¸­å£°æ˜çš„å†…å®¹å¼•ç”¨äº†çˆ¶çº§æ¨¡å—ä¸­ä½œç”¨åŸŸå†…çš„å†…å®¹ã€‚</li>
<li>CXX ä»£ç ç”Ÿæˆå™¨ä½¿ç”¨ <code>extern &quot;Rust&quot;</code> éƒ¨åˆ†ç”ŸæˆåŒ…å«ç›¸åº” C++ å£°æ˜çš„ C++ å¤´æ–‡ä»¶ã€‚ç”Ÿæˆçš„å¤´æ–‡ä»¶ä¸åŒ…å«æ¡¥æ¥çš„ Rust æºæ–‡ä»¶çš„è·¯å¾„ç›¸åŒï¼Œä½†æ–‡ä»¶æ‰©å±•åä¸º .rs.hã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ç”Ÿæˆçš„-c-ä»£ç " id="ç”Ÿæˆçš„-c-ä»£ç ">ç”Ÿæˆçš„ C++ ä»£ç </a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // Rust types and signatures exposed to C++.
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }
}
</code></pre>
<p>å¤§è‡´ç”Ÿæˆä»¥ä¸‹ C++ï¼š</p>
<pre><code class="language-cpp">struct MultiBuf final : public ::rust::Opaque {
  ~MultiBuf() = delete;

private:
  friend ::rust::layout;
  struct layout {
    static ::std::size_t size() noexcept;
    static ::std::size_t align() noexcept;
  };
};

::rust::Slice&lt;::std::uint8_t const&gt; next_chunk(::org::blobstore::MultiBuf &amp;buf) noexcept;
</code></pre>
<h1><a class="header" href="#c-æ¡¥æ¥å£°æ˜" id="c-æ¡¥æ¥å£°æ˜">C++ æ¡¥æ¥å£°æ˜</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    // C++ types and signatures exposed to Rust.
    unsafe extern &quot;C++&quot; {
        include!(&quot;include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: Pin&lt;&amp;mut BlobstoreClient&gt;, parts: &amp;mut MultiBuf) -&gt; u64;
        fn tag(self: Pin&lt;&amp;mut BlobstoreClient&gt;, blobid: u64, tag: &amp;str);
        fn metadata(&amp;self, blobid: u64) -&gt; BlobMetadata;
    }
}
</code></pre>
<p>å¤§è‡´ç”Ÿæˆä»¥ä¸‹ Rustï¼š</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct BlobstoreClient {
    _private: ::cxx::private::Opaque,
}

pub fn new_blobstore_client() -&gt; ::cxx::UniquePtr&lt;BlobstoreClient&gt; {
    extern &quot;C&quot; {
        #[link_name = &quot;org$blobstore$cxxbridge1$new_blobstore_client&quot;]
        fn __new_blobstore_client() -&gt; *mut BlobstoreClient;
    }
    unsafe { ::cxx::UniquePtr::from_raw(__new_blobstore_client()) }
}

impl BlobstoreClient {
    pub fn put(&amp;self, parts: &amp;mut MultiBuf) -&gt; u64 {
        extern &quot;C&quot; {
            #[link_name = &quot;org$blobstore$cxxbridge1$BlobstoreClient$put&quot;]
            fn __put(
                _: &amp;BlobstoreClient,
                parts: *mut ::cxx::core::ffi::c_void,
            ) -&gt; u64;
        }
        unsafe {
            __put(self, parts as *mut MultiBuf as *mut ::cxx::core::ffi::c_void)
        }
    }
}

// ...
</code></pre>
<details>
<ul>
<li>ç¨‹åºå‘˜æ— éœ€æ‰¿è¯ºä»–ä»¬è¾“å…¥çš„ç­¾åå‡†ç¡®æ— è¯¯ã€‚CXX ä¼šæ‰§è¡Œé™æ€æ–­è¨€ï¼Œç¡®è®¤ç­¾åä¸ C++ ä¸­å£°æ˜çš„å†…å®¹å®Œå…¨ä¸€è‡´ã€‚</li>
<li>å€ŸåŠ© <code>unsafe extern</code> ä»£ç å—ï¼Œæ‚¨å¯ä»¥å£°æ˜å¯ä» Rust å®‰å…¨è°ƒç”¨çš„ C++ å‡½æ•°ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å…±äº«ç±»å‹-1" id="å…±äº«ç±»å‹-1">å…±äº«ç±»å‹</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    #[derive(Clone, Debug, Hash)]
    struct PlayingCard {
        suit: Suit,
        value: u8,  // A=1, J=11, Q=12, K=13
    }

    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
</code></pre>
<details>
<ul>
<li>ä»…æ”¯æŒç±»ä¼¼ C å‡½æ•°ï¼ˆå•å…ƒï¼‰çš„æšä¸¾ã€‚</li>
<li>å…±äº«ç±»å‹çš„ <code>#[derive()]</code> æ”¯æŒæœ‰é™æ•°é‡çš„ traitã€‚ç³»ç»Ÿè¿˜ä¼šé’ˆå¯¹ C++ ä»£ç ç”Ÿæˆç›¸åº”çš„åŠŸèƒ½ï¼Œä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æ´¾ç”Ÿäº† <code>Hash</code>ï¼Œè¿˜ä¼šä¸ºç›¸åº”çš„ C++ ç±»å‹ç”Ÿæˆ <code>std::hash</code> å®ç°ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å…±äº«æšä¸¾" id="å…±äº«æšä¸¾">å…±äº«æšä¸¾</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    enum Suit {
        Clubs,
        Diamonds,
        Hearts,
        Spades,
    }
}
</code></pre>
<p>Generated Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct Suit {
    pub repr: u8,
}

#[allow(non_upper_case_globals)]
impl Suit {
    pub const Clubs: Self = Suit { repr: 0 };
    pub const Diamonds: Self = Suit { repr: 1 };
    pub const Hearts: Self = Suit { repr: 2 };
    pub const Spades: Self = Suit { repr: 3 };
}
<span class="boring">}
</span></code></pre></pre>
<p>Generated C++:</p>
<pre><code class="language-c++">enum class Suit : uint8_t {
  Clubs = 0,
  Diamonds = 1,
  Hearts = 2,
  Spades = 3,
};
</code></pre>
<details>
<ul>
<li>åœ¨ Rust ç«¯ï¼Œä¸ºå…±äº«æšä¸¾ç”Ÿæˆçš„ä»£ç å®é™…ä¸Šæ˜¯å°è£…æ•°å€¼çš„ç»“æ„ä½“ã€‚è¿™æ˜¯å› ä¸ºåœ¨ C++ ä¸­ï¼Œæšä¸¾ç±»å­˜å‚¨ä¸æ‰€æœ‰å·²åˆ—å˜ä½“ä¸åŒçš„å€¼ä¸å±äº UBï¼Œè€Œ Rust è¡¨ç¤ºæ³•éœ€è¦å…·æœ‰ç›¸åŒçš„è¡Œä¸ºã€‚</li>
</ul>
</details>
<h1><a class="header" href="#rust-é”™è¯¯å¤„ç†" id="rust-é”™è¯¯å¤„ç†">Rust é”™è¯¯å¤„ç†</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn fallible(depth: usize) -&gt; anyhow::Result&lt;String&gt; {
    if depth == 0 {
        return Err(anyhow::Error::msg(&quot;fallible1 requires depth &gt; 0&quot;));
    }

    Ok(&quot;Success!&quot;.into())
}
</code></pre>
<details>
<ul>
<li>åœ¨ C++ æ–¹é¢ï¼Œè¿”å› <code>Result</code> çš„ Rust å‡½æ•°ä¼šè¢«ç¿»è¯‘ä¸ºå¼‚å¸¸ã€‚</li>
<li>æŠ›å‡ºçš„å¼‚å¸¸å§‹ç»ˆæ˜¯ <code>rust::Error</code> ç±»å‹ï¼Œè¯¥ç±»å‹ä¸»è¦ç”¨äºæä¾›è·å–é”™è¯¯æ¶ˆæ¯å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚é”™è¯¯æ¶ˆæ¯å°†ç”±é”™è¯¯ç±»å‹çš„ <code>Display</code> impl æä¾›ã€‚</li>
<li>å½“ panic ä» Rust å±•å¼€åˆ° C++ æ—¶ï¼Œä¼šå§‹ç»ˆå¯¼è‡´è¿›ç¨‹ç«‹å³ç»ˆæ­¢ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#c-é”™è¯¯å¤„ç†" id="c-é”™è¯¯å¤„ç†">C++ é”™è¯¯å¤„ç†</a></h1>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    unsafe extern &quot;C++&quot; {
        include!(&quot;example/include/example.h&quot;);
        fn fallible(depth: usize) -&gt; Result&lt;String&gt;;
    }
}

fn main() {
    if let Err(err) = ffi::fallible(99) {
        eprintln!(&quot;Error: {}&quot;, err);
        process::exit(1);
    }
}
</code></pre>
<details>
<ul>
<li>å£°æ˜ç”¨äºè¿”å› <code>Result</code> çš„ C++ å‡½æ•°å°†æ•è· C++ ç«¯æŠ›å‡ºçš„ä»»ä½•å¼‚å¸¸ï¼Œå¹¶å°†å…¶ä½œä¸º <code>Err</code> å€¼è¿”å›ç»™è°ƒç”¨ Rust å‡½æ•°ã€‚</li>
<li>å¦‚æœå¤–éƒ¨ â€œC++â€å‡½æ•°æŠ›å‡ºläº†å¼‚å¸¸ï¼Œä½† CXX æ¡¥æ¥ä¸­æœªå£°æ˜è¯¥å‡½æ•°ç”¨äºè¿”å› <code>Result</code>ï¼Œåˆ™ç¨‹åºä¼šè°ƒç”¨ C++ çš„ <code>std::terminate</code>ã€‚æ­¤è¡Œä¸ºç­‰åŒäºé€šè¿‡ C++ å‡½æ•° <code>nowithout</code> æŠ›å‡ºäº†ç›¸åŒçš„å¼‚å¸¸ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å…¶ä»–ç±»å‹" id="å…¶ä»–ç±»å‹">å…¶ä»–ç±»å‹</a></h1>
<table><thead><tr><th>Rust Type</th><th>C++ Type</th></tr></thead><tbody>
<tr><td>String</td><td><code>rust::String</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>rust::Str</code></td></tr>
<tr><td><code>CxxString</code></td><td><code>std::string</code></td></tr>
<tr><td><code>&amp;[T]</code>/<code>&amp;mut [T]</code></td><td><code>rust::Slice</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>rust::Box&lt;T&gt;</code></td></tr>
<tr><td><code>UniquePtr&lt;T&gt;</code></td><td><code>std::unique_ptr&lt;T&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>rust::Vec&lt;T&gt;</code></td></tr>
<tr><td><code>CxxVector&lt;T&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td></tr>
</tbody></table>
<details>
<ul>
<li>è¿™äº›ç±»å‹å¯ç”¨äºå…±äº«ç»“æ„ä½“çš„å­—æ®µä»¥åŠå¤–éƒ¨å‡½æ•°çš„å‚æ•°å’Œè¿”å›ç»“æœã€‚</li>
<li>è¯·æ³¨æ„ï¼ŒRust çš„ <code>String</code> ä¸ä¼šç›´æ¥æ˜ å°„åˆ° <code>std::string</code>ã€‚å¯¼è‡´è¿™ç§æƒ…å†µçš„åŸå› æœ‰ä»¥ä¸‹å‡ ç§ï¼š
<ul>
<li><code>std::string</code> ä¸éµå¾ª <code>String</code> æ‰€éœ€çš„ UTF-8 ä¸å˜æ€§ã€‚</li>
<li>è¿™ä¸¤ç§ç±»å‹çš„å†…å­˜å¸ƒå±€ä¸åŒï¼Œå› æ­¤æ— æ³•ç›´æ¥åœ¨è¯­è¨€ä¹‹é—´è¿›è¡Œä¼ é€’ã€‚</li>
<li><code>std::string</code> éœ€è¦ä¸ Rust çš„ç§»åŠ¨è¯­ä¹‰ä¸åŒ¹é…çš„ move æ„é€ å‡½æ•°ï¼Œå› æ­¤ <code>std::string</code> æ— æ³•æŒ‰å€¼ä¼ é€’ç»™ Rustã€‚</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android" id="building-in-android">Building in Android</a></h1>
<p>åˆ›å»º <code>cc_library_static</code> ä»¥æ„å»º C++ åº“ï¼ŒåŒ…æ‹¬ CXX ç”Ÿæˆçš„å¤´æ–‡ä»¶å’Œæºæ–‡ä»¶ã€‚</p>
<pre><code class="language-javascript">cc_library_static {
    name: &quot;libcxx_test_cpp&quot;,
    srcs: [&quot;cxx_test.cpp&quot;],
    generated_headers: [
        &quot;cxx-bridge-header&quot;,
        &quot;libcxx_test_bridge_header&quot;
    ],
    generated_sources: [&quot;libcxx_test_bridge_code&quot;],
}
</code></pre>
<details>
<ul>
<li>æŒ‡å‡º <code>libcxx_test_bridge_header</code> å’Œ <code>libcxx_test_bridge_code</code> æ˜¯ CXX ç”Ÿæˆçš„ C++ ç»‘å®šçš„ä¾èµ–é¡¹ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€å¼ å¹»ç¯ç‰‡ä¸­ä»‹ç»å…·ä½“çš„è®¾ç½®æ–¹æ³•ã€‚</li>
<li>è¯·æ³¨æ„ï¼Œæ‚¨è¿˜éœ€è¦ä¾é  <code>cxx-bridge-header</code> åº“æ‰èƒ½æå–å¸¸è§çš„ CXX å®šä¹‰ã€‚</li>
<li>å¦‚éœ€äº†è§£å¦‚ä½•åœ¨ Android ä¸­ä½¿ç”¨ CXX çš„å®Œæ•´æ–‡æ¡£ï¼Œè¯·å‚é˜… <a href="https://source.android.com/docs/setup/build/rust/building-rust-modules/android-rust-patterns#rust-cpp-interop-using-cxx">Android æ–‡æ¡£</a>ã€‚å»ºè®®æ‚¨ä¸å…¨ç­åŒå­¦åˆ†äº«è¯¥é“¾æ¥ï¼Œä»¥ä¾¿å­¦ç”ŸçŸ¥é“æ—¥åå¯ä»¥åœ¨å“ªé‡Œæ‰¾åˆ°è¿™äº›è¯´æ˜ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android-1" id="building-in-android-1">Building in Android</a></h1>
<p>åˆ›å»ºä¸¤ä¸ª genruleï¼šä¸€ä¸ªç”¨äºç”Ÿæˆ CXX å¤´æ–‡ä»¶ï¼Œå¦ä¸€ä¸ªç”¨äºç”Ÿæˆ CXX æºæ–‡ä»¶ã€‚ç„¶åï¼Œè¿™äº›å†…å®¹ä¼šè¢«ç”¨ä½œ <code>cc_library_static</code> çš„è¾“å…¥ã€‚</p>
<pre><code class="language-javascript">// Generate a C++ header containing the C++ bindings
// to the Rust exported functions in lib.rs.
genrule {
    name: &quot;libcxx_test_bridge_header&quot;,
    tools: [&quot;cxxbridge&quot;],
    cmd: &quot;$(location cxxbridge) $(in) --header &gt; $(out)&quot;,
    srcs: [&quot;lib.rs&quot;],
    out: [&quot;lib.rs.h&quot;],
}

// Generate the C++ code that Rust calls into.
genrule {
    name: &quot;libcxx_test_bridge_code&quot;,
    tools: [&quot;cxxbridge&quot;],
    cmd: &quot;$(location cxxbridge) $(in) &gt; $(out)&quot;,
    srcs: [&quot;lib.rs&quot;],
    out: [&quot;lib.rs.cc&quot;],
}
</code></pre>
<details>
<ul>
<li><code>cxxbridge</code> å·¥å…·æ˜¯ä¸€æ¬¾ç‹¬ç«‹å·¥å…·ï¼Œç”¨äºç”Ÿæˆæ¡¥æ¥æ¨¡å—çš„ C++ ç«¯ã€‚å®ƒåŒ…å«åœ¨ Android ä¸­ï¼Œå¹¶ä½œä¸º Soong å·¥å…·æä¾›ã€‚</li>
<li>æŒ‰ç…§æƒ¯ä¾‹ï¼Œå¦‚æœæ‚¨çš„ Rust æºæ–‡ä»¶æ˜¯ <code>lib.rs</code>ï¼Œåˆ™å¤´æ–‡ä»¶å°†å‘½åä¸º <code>lib.rs.h</code>ï¼Œæºæ–‡ä»¶å°†å‘½åä¸º <code>lib.rs.cc</code>ã€‚ä¸è¿‡ï¼Œç³»ç»Ÿå¹¶ä¸å¼ºåˆ¶æ‰§è¡Œæ­¤å‘½åæƒ¯ä¾‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#building-in-android-2" id="building-in-android-2">Building in Android</a></h1>
<p>åˆ›å»ºä¸€ä¸ªä¾èµ–äº <code>libcxx</code> å’Œ <code>cc_library_static</code> çš„ <code>rust_binary</code>ã€‚</p>
<pre><code class="language-javascript">rust_binary {
    name: &quot;cxx_test&quot;,
    srcs: [&quot;lib.rs&quot;],
    rustlibs: [&quot;libcxx&quot;],
    static_libs: [&quot;libcxx_test_cpp&quot;],
}
</code></pre>
<h1><a class="header" href="#ä¸-java-çš„äº’æ“ä½œæ€§" id="ä¸-java-çš„äº’æ“ä½œæ€§">ä¸ Java çš„äº’æ“ä½œæ€§</a></h1>
<p>Javaå¯ä»¥é€šè¿‡ <a href="https://en.wikipedia.org/wiki/Java_Native_Interface"> Java æœ¬åœ°æ¥å£ (JNI)</a> åŠ è½½å…±äº«å¯¹è±¡ã€‚<a href="https://docs.rs/jni/"><code>jni</code> crate</a> å…è®¸æ‚¨åˆ›å»ºä¸€ä¸ªå…¼å®¹çš„åº“ã€‚</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¯ä»¥å¯¼å‡ºåˆ° Java çš„ Rust å‡½æ•°ï¼š</p>
<p><em>interoperability/java/src/lib.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Rust &lt;-&gt; Java FFI demo.

use jni::objects::{JClass, JString};
use jni::sys::jstring;
use jni::JNIEnv;

/// HelloWorld::hello method implementation.
// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;system&quot; fn Java_HelloWorld_hello(
    mut env: JNIEnv,
    _class: JClass,
    name: JString,
) -&gt; jstring {
    let input: String = env.get_string(&amp;name).unwrap().into();
    let greeting = format!(&quot;Hello, {input}!&quot;);
    let output = env.new_string(greeting).unwrap();
    output.into_raw()
}
<span class="boring">}
</span></code></pre></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">rust_ffi_shared {
    name: &quot;libhello_jni&quot;,
    crate_name: &quot;hello_jni&quot;,
    srcs: [&quot;src/lib.rs&quot;],
    rustlibs: [&quot;libjni&quot;],
}
</code></pre>
<p>We then call this function from Java:</p>
<p><em>interoperability/java/HelloWorld.java</em>:</p>
<pre><code class="language-java">class HelloWorld {
    private static native String hello(String name);

    static {
        System.loadLibrary(&quot;hello_jni&quot;);
    }

    public static void main(String[] args) {
        String output = HelloWorld.hello(&quot;Alice&quot;);
        System.out.println(output);
    }
}
</code></pre>
<p><em>interoperability/java/Android.bp</em>:</p>
<pre><code class="language-javascript">java_binary {
    name: &quot;helloworld_jni&quot;,
    srcs: [&quot;HelloWorld.java&quot;],
    main_class: &quot;HelloWorld&quot;,
    required: [&quot;libhello_jni&quot;],
}
</code></pre>
<p>æœ€åï¼Œæ‚¨å¯ä»¥æ„å»ºã€åŒæ­¥å’Œè¿è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">m helloworld_jni
adb sync  # requires adb root &amp;&amp; adb remount
adb shell /system/bin/helloworld_jni
</code></pre>
<h1><a class="header" href="#welcome-to-rust-in-chromium" id="welcome-to-rust-in-chromium">Welcome to Rust in Chromium</a></h1>
<p>Chromium ä¸­çš„ç¬¬ä¸‰æ–¹åº“æ”¯æŒ Rustï¼Œå¹¶ä½¿ç”¨ç¬¬ä¸€æ–¹ç²˜åˆä»£ç è¿æ¥ Rust å’Œç°æœ‰ Chromium C++ ä»£ç ã€‚</p>
<blockquote>
<p>ä»Šå¤©ï¼Œæˆ‘ä»¬å°†è°ƒç”¨ Rust å¯¹å­—ç¬¦ä¸²è¿›è¡Œä¸€äº›æœ‰è¶£çš„æ“ä½œã€‚å¦‚æœæ‚¨çš„ä»£ç ä¸­æŸä¸ªéƒ¨åˆ†æ˜¯ç”¨äºå‘ç”¨æˆ·å±•ç¤º UTF8 å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ä»£ç åº“ä¸­çš„å¯¹åº”éƒ¨åˆ†æŒ‰ç…§è¿™ä¸ªæ­¥éª¤æ¥æ“ä½œï¼Œè€Œä¸ä¸€å®šè¦åœ¨æˆ‘ä»¬æ‰€è®¨è®ºçš„ç¡®åˆ‡éƒ¨åˆ†ã€‚</p>
</blockquote>
<h1><a class="header" href="#è®¾ç½®-1" id="è®¾ç½®-1">è®¾ç½®</a></h1>
<p>è¯·ç¡®ä¿æ‚¨å¯ä»¥æ„å»ºå¹¶è¿è¡Œ Chromiumã€‚åªè¦æ‚¨çš„ä»£ç è¾ƒæ–°ï¼ˆæäº¤ä½ç½®å§‹äº 1223636ï¼Œå¯¹åº”äº 2023 å¹´ 11 æœˆï¼‰ï¼Œåˆ™å¯åœ¨ä»»ä½•å¹³å°å’Œä»»ä½•ä¸€ç»„ build æ ‡å¿—ä¸‹è¿è¡Œã€‚</p>
<pre><code class="language-shell">gn gen out/Debug
autoninja -C out/Debug chrome
out/Debug/chrome # or on Mac, out/Debug/Chromium.app/Contents/MacOS/Chromium
</code></pre>
<p>ï¼ˆå»ºè®®ä½¿ç”¨è°ƒè¯• build ç»„ä»¶ï¼Œä»¥ç¼©çŸ­è¿­ä»£æ—¶é—´ã€‚è¿™æ˜¯é»˜è®¤å€¼ï¼ï¼‰</p>
<p>å¦‚æœæ‚¨ä¸å…·å¤‡è¿™ç‚¹ï¼Œè¯·å‚é˜… <a href="https://www.chromium.org/developers/how-tos/get-the-code/">å¦‚ä½•æ„å»º Chromium</a>ã€‚æ³¨æ„ï¼šè®¾ç½® build Chromium éœ€è¦èŠ±äº›æ—¶é—´ã€‚</p>
<p>æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å»ºè®®æ‚¨å®‰è£… Visual Studio ä»£ç ã€‚</p>
<h1><a class="header" href="#about-the-exercises" id="about-the-exercises">About the exercises</a></h1>
<p>æœ¬è¯¾ç¨‹çš„è¿™ä¸€éƒ¨åˆ†åŒ…å«ä¸€ç³»åˆ—ç»ƒä¹ ï¼Œå®ƒä»¬ä¹‹é—´æ˜¯ç›¸è¾…ç›¸æˆçš„ã€‚æˆ‘ä»¬å°†åœ¨æ•´ä¸ªè¯¾ç¨‹ä¸­è¿›è¡Œè¿™äº›ç»ƒä¹ ï¼Œè€Œä¸ä»…ä»…æ˜¯åœ¨æœ€åé˜¶æ®µå®Œæˆã€‚å¦‚æœæ‚¨æ²¡æœ‰æ—¶é—´å®ŒæˆæŸä¸ªéƒ¨åˆ†ï¼Œä¹Ÿæ— éœ€æ‹…å¿ƒï¼šå¯ä»¥åœ¨ä¸‹ä¸€é˜¶æ®µèµ¶ä¸Šè¿›åº¦ã€‚</p>
<h1><a class="header" href="#chromium-å’Œ-cargo-çš„ç”Ÿæ€å¯¹æ¯”" id="chromium-å’Œ-cargo-çš„ç”Ÿæ€å¯¹æ¯”">Chromium å’Œ Cargo çš„ç”Ÿæ€å¯¹æ¯”</a></h1>
<p>The Rust community typically uses <code>cargo</code> and libraries from <a href="https://crates.io/">crates.io</a>. Chromium is built using <code>gn</code> and <code>ninja</code> and a curated set of dependencies.</p>
<p>ä½¿ç”¨ Rust ç¼–å†™ä»£ç æ—¶ï¼Œæ‚¨å¯ä»¥é€‰æ‹©ï¼š</p>
<ul>
<li>å€ŸåŠ© <code>//build/rust/*.gni</code> æ¨¡æ¿ï¼ˆä¾‹å¦‚ <code>rust_static_library</code>ï¼Œæˆ‘ä»¬ç¨åä¼šä»‹ç»ï¼‰ä½¿ç”¨ <code>gn</code> å’Œ <code>ninja</code>ã€‚è¯¥æ“ä½œä¼šä½¿ç”¨ç»è¿‡å®¡æ ¸çš„ Chromium å·¥å…·é“¾å’Œ crateã€‚</li>
<li>ä½¿ç”¨ <code>cargo</code>ï¼Œä½† <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Using-cargo">ä»…é™äºç»è¿‡å®¡æ ¸çš„ Chromium å·¥å…·é“¾å’Œ crate</a></li>
<li>ä½¿ç”¨ <code>cargo</code>ï¼Œä¿¡ä»» <a href="https://rustup.rs/">å·¥å…·é“¾</a> å’Œ/æˆ– <a href="https://crates.io/">ä»äº’è”ç½‘ä¸‹è½½çš„ crate</a></li>
</ul>
<p>From here on we'll be focusing on <code>gn</code> and <code>ninja</code>, because this is how Rust code can be built into the Chromium browser. At the same time, Cargo is an important part of the Rust ecosystem and you should keep it in your toolbox.</p>
<h2><a class="header" href="#mini-exercise" id="mini-exercise">Mini exercise</a></h2>
<p>åˆ†æˆå„ä¸ªå°ç»„å¼€å±•ä»¥ä¸‹æ´»åŠ¨ï¼š</p>
<ul>
<li>æ€è€ƒ <code>cargo</code> åœ¨å“ªäº›åœºæ™¯ä¸‹å…·æœ‰ä¼˜åŠ¿ï¼Œå¹¶è¯„ä¼°è¿™äº›åœºæ™¯çš„é£é™©çŠ¶å†µã€‚</li>
<li>è®¨è®ºåœ¨ä½¿ç”¨ <code>gn</code> å’Œ <code>ninja</code> ä»¥åŠç¦»çº¿ <code>cargo</code> ç­‰æ—¶ï¼Œéœ€è¦ä¿¡ä»»å“ªäº›å·¥å…·ã€åº“å’Œäººç¾¤ã€‚</li>
</ul>
<details>
<p>Ask students to avoid peeking at the speaker notes before completing the exercise. Assuming folks taking the course are physically together, ask them to discuss in small groups of 3-4 people.</p>
<p>ä¸ç¬¬ä¸€éƒ¨åˆ†ç»ƒä¹ ç›¸å…³çš„å¤‡æ³¨/æç¤ºï¼ˆâ€œCargo å¯èƒ½å…·æœ‰ä¼˜åŠ¿çš„åœºæ™¯â€ï¼‰ï¼š</p>
<ul>
<li>
<p>It's fantastic that when writing a tool, or prototyping a part of Chromium, one has access to the rich ecosystem of crates.io libraries. There is a crate for almost anything and they are usually quite pleasant to use. (<code>clap</code> for command-line parsing, <code>serde</code> for serializing/deserializing to/from various formats, <code>itertools</code> for working with iterators, etc.).</p>
<ul>
<li>å€ŸåŠ© <code>cargo</code>ï¼Œæ‚¨ä¾¿å¯ä»¥è½»æ¾è¯•ç”¨åº“ï¼ˆåªéœ€å‘ `Cargo.toml`` æ·»åŠ ä¸€è¡Œä»£ç ç„¶åå¼€å§‹ç¼–å†™å³å¯ï¼‰</li>
<li>ä¸å¦¨æ¯”è¾ƒä¸‹ CPAN æ˜¯å¦‚ä½•å¸®åŠ© <code>perl</code> æˆä¸ºçƒ­é—¨ä¹‹é€‰çš„ã€‚æˆ–è€…ä¸ <code>python</code> + <code>pip</code> è¿›è¡Œæ¯”è¾ƒã€‚</li>
</ul>
</li>
<li>
<p>Development experience is made really nice not only by core Rust tools (e.g. using <code>rustup</code> to switch to a different <code>rustc</code> version when testing a crate that needs to work on nightly, current stable, and older stable) but also by an ecosystem of third-party tools (e.g. Mozilla provides <code>cargo vet</code> for streamlining and sharing security audits; <code>criterion</code> crate gives a streamlined way to run benchmarks).</p>
<ul>
<li>å€ŸåŠ© <code>cargo</code>ï¼Œæ‚¨å¯é€šè¿‡ <code>cargo install --locked cargo-vet</code> è½»æ¾æ·»åŠ å·¥å…·ã€‚</li>
<li>ä¸å¦¨ä¸ Chrome æ‰©å±•ç¨‹åºæˆ– VScode æ‰©å±•ç¨‹åºè¿›è¡Œæ¯”è¾ƒã€‚</li>
</ul>
</li>
<li>
<p>ä»¥ä¸‹æ˜¯ä¸€äº›é€‚åˆé€‰ç”¨ <code>cargo</code>ï¼Œè¾ƒä¸ºå®½æ³›çš„é€šç”¨é¡¹ç›®ç¤ºä¾‹ï¼š</p>
<ul>
<li>Perhaps surprisingly, Rust is becoming increasingly popular in the industry for writing command line tools. The breadth and ergonomics of libraries is comparable to Python, while being more robust (thanks to the rich typesystem) and running faster (as a compiled, rather than interpreted language).</li>
<li>å¦‚è¦åŠ å…¥ Rust ç”Ÿæ€ç³»ç»Ÿï¼Œå¿…é¡»ä½¿ç”¨ Cargo ç­‰æ ‡å‡† Rust å·¥å…·ã€‚å¦‚æœå¸Œæœ›åº“è·å¾—å¤–éƒ¨è´¡çŒ®ï¼Œå¹¶ä¸”èƒ½å¤Ÿç”¨äºé™¤ Chromium ä¹‹å¤–ï¼ˆä¾‹å¦‚ç”¨äº Bazel æˆ– Android/Soong æ„å»ºç¯å¢ƒï¼‰çš„é¡¹ç›®ï¼Œåˆ™åº”è¯¥ä½¿ç”¨ Cargoã€‚</li>
</ul>
</li>
<li>
<p>åŸºäº <code>cargo</code>\ çš„ Chromium ç›¸å…³é¡¹ç›®ç¤ºä¾‹ï¼š</p>
<ul>
<li><code>serde_json_lenient</code>ï¼ˆå·²åœ¨ Google çš„å…¶ä»–éƒ¨åˆ†è¿›è¡Œäº†å®éªŒï¼Œç»“æœæ˜¯èƒ½ä½¿ PR æ€§èƒ½å¾—åˆ°æå‡ï¼‰</li>
<li>å­—ä½“åº“ï¼ˆä¾‹å¦‚ <code>font-types</code>ï¼‰</li>
<li><code>gnrt</code> å·¥å…·ï¼ˆæˆ‘ä»¬å°†åœ¨æœ¬è¯¾ç¨‹ç¨åçš„éƒ¨åˆ†ä¸­åŠ ä»¥ä»‹ç»ï¼‰ä½¿ç”¨ <code>clap</code> è¿›è¡Œå‘½ä»¤è¡Œè§£æï¼Œä½¿ç”¨ <code>toml</code> å¤„ç†é…ç½®æ–‡ä»¶ã€‚
<ul>
<li>Disclaimer: a unique reason for using <code>cargo</code> was unavailability of <code>gn</code> when building and bootstrapping Rust standard library when building Rust toolchain.</li>
<li><code>run_gnrt.py</code> uses Chromium's copy of <code>cargo</code> and <code>rustc</code>. <code>gnrt</code> depends on third-party libraries downloaded from the internet, but <code>run_gnrt.py</code> asks <code>cargo</code> that only <code>--locked</code> content is allowed via <code>Cargo.lock</code>.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>å­¦ç”Ÿå¯å°†ä»¥ä¸‹å†…å®¹è®¤å®šä¸ºéšå¼ä¿¡ä»»æˆ–æ˜ç¡®ä¿¡ä»»ï¼š</p>
<ul>
<li><code>rustc</code>ï¼ˆRust ç¼–è¯‘å™¨ï¼‰åˆ™ä¾èµ–äº LLVM åº“ã€Clang ç¼–è¯‘å™¨ã€â€œrustcâ€æºä»£ç ï¼ˆä» GitHub è·å–ï¼Œå¹¶ç”± Rust ç¼–è¯‘å™¨å›¢é˜Ÿå®¡æ ¸ï¼‰ã€ä¸ºå¼•å¯¼è€Œä¸‹è½½çš„äºŒè¿›åˆ¶ Rust ç¼–è¯‘å™¨</li>
<li><code>rustup</code>ï¼ˆå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ<code>rustup</code> æ˜¯åœ¨ https://github.com/rust-lang/ ä¿æŠ¤ä¸‹ç»„ç»‡å¼€å‘çš„ï¼Œä¸ <code>rustc</code> ç›¸åŒã€‚ï¼‰</li>
<li><code>cargo</code>ã€<code>rustfmt</code> ç­‰</li>
<li>å„ç§å†…éƒ¨åŸºç¡€æ¶æ„ï¼ˆç”¨äºæ„å»º <code>rustc</code> çš„èŠå¤©æœºå™¨äººã€ç”¨äºå°†é¢„æ„å»ºå·¥å…·é“¾åˆ†å‘ç»™ Chromium å·¥ç¨‹å¸ˆçš„ç³»ç»Ÿç­‰ã€‚ï¼‰</li>
<li><code>cargo Audit</code>ã€<code>cargo vet</code> ç­‰ Cargo å·¥å…·</li>
<li>åŒ…å«åˆ° <code>//third_party/rust</code> çš„ Rust åº“ï¼ˆç”± security@chromium.org è¿›è¡Œå®¡æ ¸ï¼‰</li>
<li>å…¶ä»– Rust åº“ï¼ˆä¸€äº›å°ä¼—ä½†å¾ˆå—æ¬¢è¿åˆå¸¸ç”¨çš„åº“ï¼‰</li>
</ul>
</details>
<h1><a class="header" href="#chromium-rust-æ”¿ç­–" id="chromium-rust-æ”¿ç­–">Chromium Rust æ”¿ç­–</a></h1>
<p>Chromium å°šä¸æ”¯æŒä½¿ç”¨ç¬¬ä¸€æ–¹ Rustï¼Œé™¤éæ˜¯ç»è¿‡ <a href="https://source.chromium.org/chromium/chromium/src/+/main:ATL_OWNERS">åŒºåŸŸæŠ€æœ¯ä¸»ç®¡</a> æ‰¹å‡†çš„ç‰¹æ®Šæƒ…å†µã€‚</p>
<p>æœ‰å…³ Chromium çš„ç¬¬ä¸‰æ–¹åº“æ”¿ç­–ï¼Œè¯·å‚é˜… <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#rust">æ­¤å¤„</a>ã€‚æ ¹æ®è¯¥è¿™äº›æ”¿ç­–ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹å…è®¸å°† Rust ä½œä¸ºç¬¬ä¸‰æ–¹åº“ä½¿ç”¨ï¼ŒåŒ…æ‹¬æ— è®ºæ˜¯åœ¨æ€§èƒ½è¿˜æ˜¯å®‰å…¨æ–¹é¢ï¼Œå®ƒä»¬éƒ½æ˜¯ç†æƒ³ä¹‹é€‰ã€‚</p>
<p>é²œå°‘æœ‰ Rust åº“ä¼šç›´æ¥å…¬å¼€ C/C++ APIï¼Œè¿™æ„å‘³ç€å‡ ä¹æ‰€æœ‰æ­¤ç±»åº“éƒ½éœ€è¦ä½¿ç”¨å°‘é‡çš„ç¬¬ä¸€æ–¹ç²˜åˆä»£ç ã€‚</p>
<div style='width:100%; height:208px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="640" height="208"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="640" height="208"></rect><rect x="20" y="88" width="128" height="64" class="solid nofill" rx="0"></rect><circle cx="100" cy="120" r="3" class="nofill"></circle><rect x="276" y="88" width="136" height="64" class="solid nofill" rx="0"></rect><circle cx="396" cy="120" r="3" class="nofill"></circle><rect x="500" y="88" width="112" height="64" class="solid nofill" rx="0"></rect><text x="258" y="12" >Rust</text><line x1="280" y1="24" x2="288" y2="24" class="solid"></line><text x="498" y="60" >Existing</text><text x="498" y="76" >crate</text><text x="178" y="140" >Language</text><text x="426" y="140" >Crate</text><text x="178" y="156" >boundary</text><text x="426" y="156" >API</text><line x1="24" y1="24" x2="32" y2="24" class="solid"></line><line x1="40" y1="24" x2="48" y2="24" class="solid"></line><line x1="56" y1="24" x2="64" y2="24" class="solid"></line><line x1="72" y1="24" x2="80" y2="24" class="solid"></line><line x1="88" y1="24" x2="96" y2="24" class="solid"></line><line x1="104" y1="24" x2="112" y2="24" class="solid"></line><line x1="120" y1="24" x2="128" y2="24" class="solid"></line><line x1="136" y1="24" x2="144" y2="24" class="solid"></line><line x1="296" y1="24" x2="304" y2="24" class="solid"></line><line x1="312" y1="24" x2="320" y2="24" class="solid"></line><line x1="328" y1="24" x2="336" y2="24" class="solid"></line><line x1="344" y1="24" x2="352" y2="24" class="solid"></line><line x1="360" y1="24" x2="368" y2="24" class="solid"></line><line x1="376" y1="24" x2="384" y2="24" class="solid"></line><line x1="392" y1="24" x2="400" y2="24" class="solid"></line><line x1="408" y1="24" x2="416" y2="24" class="solid"></line><line x1="424" y1="24" x2="432" y2="24" class="solid"></line><line x1="440" y1="24" x2="448" y2="24" class="solid"></line><line x1="456" y1="24" x2="464" y2="24" class="solid"></line><line x1="472" y1="24" x2="480" y2="24" class="solid"></line><line x1="488" y1="24" x2="496" y2="24" class="solid"></line><line x1="504" y1="24" x2="512" y2="24" class="solid"></line><line x1="520" y1="24" x2="528" y2="24" class="solid"></line><line x1="536" y1="24" x2="544" y2="24" class="solid"></line><line x1="552" y1="24" x2="560" y2="24" class="solid"></line><line x1="568" y1="24" x2="576" y2="24" class="solid"></line><line x1="584" y1="24" x2="592" y2="24" class="solid"></line><line x1="600" y1="24" x2="608" y2="24" class="solid"></line><text x="18" y="60" >Existing</text><text x="90" y="60" >Chromium</text><text x="282" y="60" >Chromium</text><text x="354" y="60" >Rust</text><text x="570" y="60" >Rust</text><line x1="24" y1="184" x2="32" y2="184" class="solid"></line><line x1="40" y1="184" x2="48" y2="184" class="solid"></line><line x1="56" y1="184" x2="64" y2="184" class="solid"></line><line x1="72" y1="184" x2="80" y2="184" class="solid"></line><line x1="88" y1="184" x2="96" y2="184" class="solid"></line><line x1="104" y1="184" x2="112" y2="184" class="solid"></line><line x1="120" y1="184" x2="128" y2="184" class="solid"></line><line x1="136" y1="184" x2="144" y2="184" class="solid"></line><line x1="280" y1="184" x2="288" y2="184" class="solid"></line><line x1="296" y1="184" x2="304" y2="184" class="solid"></line><line x1="312" y1="184" x2="320" y2="184" class="solid"></line><line x1="328" y1="184" x2="336" y2="184" class="solid"></line><line x1="344" y1="184" x2="352" y2="184" class="solid"></line><line x1="360" y1="184" x2="368" y2="184" class="solid"></line><line x1="376" y1="184" x2="384" y2="184" class="solid"></line><line x1="392" y1="184" x2="400" y2="184" class="solid"></line><line x1="408" y1="184" x2="416" y2="184" class="solid"></line><line x1="424" y1="184" x2="432" y2="184" class="solid"></line><line x1="440" y1="184" x2="448" y2="184" class="solid"></line><line x1="456" y1="184" x2="464" y2="184" class="solid"></line><line x1="472" y1="184" x2="480" y2="184" class="solid"></line><line x1="488" y1="184" x2="496" y2="184" class="solid"></line><line x1="504" y1="184" x2="512" y2="184" class="solid"></line><line x1="520" y1="184" x2="528" y2="184" class="solid"></line><line x1="536" y1="184" x2="544" y2="184" class="solid"></line><line x1="552" y1="184" x2="560" y2="184" class="solid"></line><line x1="568" y1="184" x2="576" y2="184" class="solid"></line><line x1="584" y1="184" x2="592" y2="184" class="solid"></line><line x1="600" y1="184" x2="608" y2="184" class="solid"></line><text x="2" y="12" >C++</text><text x="18" y="76" >C++</text><text x="282" y="76" >wrapper</text><g><line x1="152" y1="24" x2="160" y2="24" class="solid"></line><path d="M 160,24 A 4,4 0,0,1 164,28" class="nofill"></path><line x1="164" y1="28" x2="164" y2="180" class="broken"></line><line x1="152" y1="184" x2="160" y2="184" class="solid"></line><path d="M 164,180 A 4,4 0,0,1 160,184" class="nofill"></path></g><g><path d="M 264,24 A 4,4 0,0,0 260,28" class="nofill"></path><line x1="260" y1="28" x2="260" y2="180" class="broken"></line><line x1="264" y1="24" x2="272" y2="24" class="solid"></line><path d="M 260,180 A 4,4 0,0,0 264,184" class="nofill"></path><line x1="264" y1="184" x2="272" y2="184" class="solid"></line></g><g><line x1="104" y1="120" x2="288" y2="120" class="solid"></line><polygon points="288,116 296,120 288,124" class="filled"></polygon></g><g><line x1="400" y1="120" x2="520" y2="120" class="solid"></line><polygon points="520,116 528,120 520,124" class="filled"></polygon></g><g><path d="M 8,24 A 4,4 0,0,0 4,28" class="nofill"></path><line x1="4" y1="28" x2="4" y2="180" class="broken"></line><line x1="8" y1="24" x2="16" y2="24" class="solid"></line><path d="M 4,180 A 4,4 0,0,0 8,184" class="nofill"></path><line x1="8" y1="184" x2="16" y2="184" class="solid"></line></g><g><line x1="616" y1="24" x2="624" y2="24" class="solid"></line><path d="M 624,24 A 4,4 0,0,1 628,28" class="nofill"></path><line x1="628" y1="28" x2="628" y2="180" class="broken"></line><line x1="616" y1="184" x2="624" y2="184" class="solid"></line><path d="M 628,180 A 4,4 0,0,1 624,184" class="nofill"></path></g></svg></div>
<blockquote>
<p>ç‰¹å®šç¬¬ä¸‰æ–¹ crate çš„ç¬¬ä¸€æ–¹ Rust ç²˜åˆä»£ç é€šå¸¸åº”æ”¾åœ¨ <code>third_party/rust/&lt;crate&gt;/&lt;version&gt;/wrapper</code> ç›®å½•ä¸­ã€‚</p>
</blockquote>
<p>å› æ­¤ï¼Œä»Šå¤©çš„è¯¾ç¨‹å°†é‡ç‚¹ä»‹ç»ä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>å¼•å…¥ç¬¬ä¸‰æ–¹ Rust åº“ (&quot;crates&quot;)</li>
<li>ç¼–å†™ç²˜åˆä»£ç ï¼Œä»¥ä¾¿èƒ½å¤Ÿä» Chromium C++ ä¸­ä½¿ç”¨è¿™äº› crateã€‚</li>
</ul>
<p>å¦‚æœæ­¤æ”¿ç­–éšæ—¶é—´è€Œå‘ç”Ÿå˜åŒ–ï¼Œåˆ™æœ¬è¯¾ç¨‹ä¹Ÿä¼šéšä¹‹æ›´æ–°ã€‚</p>
<h1><a class="header" href="#build-rules" id="build-rules">Build rules</a></h1>
<p>Rust ä»£ç é€šå¸¸ä½¿ç”¨ <code>cargo</code> æ„å»ºè€Œæˆã€‚ä¸ºæé«˜æ•ˆç‡ï¼ŒChromium ä½¿ç”¨ <code>gn</code> å’Œ <code>ninja</code> è¿›è¡Œæ„å»ºï¼Œå…¶é™æ€è§„åˆ™æ”¯æŒå®ç°æœ€å¤§ç¨‹åº¦çš„å¹¶è¡Œå¤„ç†ã€‚Rust ä¹Ÿä¸ä¾‹å¤–ã€‚</p>
<h2><a class="header" href="#adding-rust-code-to-chromium" id="adding-rust-code-to-chromium">Adding Rust code to Chromium</a></h2>
<p>åœ¨ä¸€äº›ç°æœ‰çš„ Chromium <code>BUILD.gn</code> æ–‡ä»¶ä¸­ï¼Œå£°æ˜ <code>rust_static_library</code>ï¼š</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
}
</code></pre>
<p>æ‚¨è¿˜å¯ä»¥åœ¨å…¶ä»– Rust ç›®æ ‡ä¸Šæ·»åŠ  <code>deps</code>ã€‚ç¨åï¼Œæˆ‘ä»¬é€šè¿‡è¯¥æ“ä½œæ¥ä½¿ç”¨ç¬¬ä¸‰æ–¹ä»£ç ã€‚</p>
<details>
<p>æ‚¨å¿…é¡» <em>åŒæ—¶</em> æŒ‡å®š crate æ ¹ç›®å½• <em>å’Œ</em> å®Œæ•´çš„æºä»£ç åˆ—è¡¨ã€‚<code>crate_root</code> æ˜¯ä¾› Rust ç¼–è¯‘å™¨ä½¿ç”¨çš„æ–‡ä»¶ï¼Œè¡¨ç¤ºç¼–è¯‘å•å…ƒçš„æ ¹æ–‡ä»¶ï¼Œé€šå¸¸ä¸º <code>lib.rs</code>ã€‚<code>sources</code> æ˜¯æ‰€æœ‰æºæ–‡ä»¶çš„å®Œæ•´åˆ—è¡¨ï¼Œ<code>ninja</code> éœ€è¦ç”¨å®ƒæ¥ç¡®å®šä½•æ—¶è¯¥è¿›è¡Œé‡æ–°æ„å»ºã€‚</p>
<p>ï¼ˆåœ¨ Rust ä¸­ï¼Œå¹¶ä¸å­˜åœ¨æ‰€è°“çš„ Rust <code>source_set</code>ï¼Œå› ä¸ºæ•´ä¸ª crate å°±æ˜¯ä¸€ä¸ªç¼–è¯‘å•å…ƒã€‚<code>static_library</code> æ˜¯æœ€å°çš„å•å…ƒã€‚ï¼‰</p>
<p>å­¦ç”Ÿå¯èƒ½ä¼šç–‘æƒ‘ä¸ºä½•æˆ‘ä»¬éœ€è¦ gn æ¨¡æ¿ï¼Œè€Œä¸ä½¿ç”¨ <a href="https://gn.googlesource.com/gn/+/main/docs/reference.md#func_static_library">gn å†…ç½®çš„ Rust é™æ€åº“æ”¯æŒ</a> è¿›è¡Œæ“ä½œã€‚åŸå› æ˜¯æ­¤æ¨¡æ¿æ”¯æŒ CXX äº’æ“ä½œæ€§ã€å„é¡¹ Rust åŠŸèƒ½ä»¥åŠå•å…ƒæµ‹è¯•ï¼Œæˆ‘ä»¬ç¨åä¾¿ä¼šç”¨åˆ°å…¶ä¸­çš„ä¸€äº›åŠŸèƒ½ã€‚</p>
</details>
<h1><a class="header" href="#including-unsafe-rust-code" id="including-unsafe-rust-code">Including <code>unsafe</code> Rust Code</a></h1>
<p>é»˜è®¤æƒ…å†µä¸‹ï¼Œç¦æ­¢åœ¨ <code>rust_static_library</code> ä¸­ä½¿ç”¨ä¸å®‰å…¨çš„ Rust ä»£ç ï¼Œå› ä¸ºæ­¤ç±»ä»£ç æ— æ³•ç¼–è¯‘ã€‚å¦‚éœ€ä½¿ç”¨ä¸å®‰å…¨çš„ Rust ä»£ç ï¼Œè¯·å°† <code>allow_unsafe = true</code> æ·»åŠ åˆ° gn ç›®æ ‡ä¸­ã€‚ï¼ˆåœ¨æœ¬è¯¾ç¨‹çš„ç¨åéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä»‹ç»åœ¨å“ªäº›æƒ…å½¢ä¸‹å¿…é¡»è¿™æ ·åšã€‚ï¼‰</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [
    &quot;lib.rs&quot;,
    &quot;hippopotamus.rs&quot;
  ]
  allow_unsafe = true
}
</code></pre>
<h1><a class="header" href="#åœ¨-chromium-c-ä¸­å¯¼å…¥-rust-ä»£ç " id="åœ¨-chromium-c-ä¸­å¯¼å…¥-rust-ä»£ç ">åœ¨ Chromium C++ ä¸­å¯¼å…¥ Rust ä»£ç </a></h1>
<p>åªéœ€å°†ä¸Šè¿°ç›®æ ‡æ·»åŠ åˆ°æŸäº› Chromium C++ ç›®æ ‡çš„ <code>deps</code> ä¸­å³å¯ã€‚</p>
<pre><code class="language-gn">import(&quot;//build/rust/rust_static_library.gni&quot;)

rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
}

# or source_set, static_library etc.
component(&quot;preexisting_cpp&quot;) {
  deps = [ &quot;:my_rust_lib&quot; ]
}
</code></pre>
<details>
We'll see that this relationship only works if the Rust code exposes plain C APIs
which can be called from C++, or if we use a C++/Rust interop tool.
</details>
<h1><a class="header" href="#visual-studio-code" id="visual-studio-code">Visual Studio Code</a></h1>
<p>åœ¨ Rust ä»£ç ä¸­ï¼Œé€šå¸¸ä¼šçœç•¥ç±»å‹ï¼Œè¿™ä½¿å¾—æ‹¥æœ‰å¼ºå¤§çš„ IDE ç”šè‡³æ¯” C++ æ›´ä¸ºæœ‰ç”¨ã€‚Visual Studio Code éå¸¸é€‚ç”¨äºåœ¨ Chromium ä¸­å¤„ç† Rust ä»£ç ã€‚å¦‚éœ€ä½¿ç”¨æ­¤åŠŸèƒ½ï¼Œ</p>
<ul>
<li>è¯·ç¡®ä¿æ‚¨çš„ VSCode å®‰è£…äº† <code>rust-analyzer</code> æ‰©å±•ç¨‹åºï¼Œè€Œä¸æ˜¯è¾ƒæ—©ç‰ˆæœ¬çš„ Rust æ”¯æŒæ’ä»¶ã€‚</li>
<li><code>gn gen out/Debug --export-rust-project</code>ï¼ˆæˆ–è¾“å‡ºç›®å½•çš„ç­‰æ•ˆé¡¹ï¼‰</li>
<li><code>In -s out/Debug/rust-project.json rust-project.json</code></li>
</ul>
<img src="chromium/build-rules/vscode.png" style="border: 1px solid black;" alt="Example screenshot from VSCode">
<details>
<p>å¦‚æœå—ä¼—ç¾¤ä½“å¯¹ IDE æŒæœ‰æ€€ç–‘æ€åº¦ï¼Œä¸å¦¨æ¼”ç¤ºä¸‹ rust-analyzer çš„éƒ¨åˆ†ä»£ç æ³¨è§£å’Œæ¢ç´¢åŠŸèƒ½ï¼Œæˆ–è®¸èƒ½è®©ä»–ä»¬æ”¹è§‚ã€‚</p>
<p>ä»¥ä¸‹æ­¥éª¤å¯èƒ½ä¼šå¯¹æ¼”ç¤ºæœ‰æ‰€å¸®åŠ©ï¼ˆä½†æ‚¨ä¹Ÿå¯ä»¥é€‰ç”¨ä¸€æ®µæœ€ä¸ºç†Ÿæ‚‰çš„ Chromium ç›¸å…³ Rust ä»£ç ï¼‰ï¼š</p>
<ul>
<li>æ‰“å¼€ <code>components/qr_code_generator/qr_code_generator_ffi_glue.rs</code></li>
<li>å°†å…‰æ ‡ç½®äº `qr_code_generator_ffi_glue.rs ä¸­çš„ <code>QrCode::new</code> è°ƒç”¨ï¼ˆå¤§çº¦ç¬¬ 26 è¡Œï¼‰ä¸Š</li>
<li>Demo <strong>show documentation</strong> (typical bindings: vscode = ctrl k i; vim/CoC = K).</li>
<li>Demo <strong>go to definition</strong> (typical bindings: vscode = F12; vim/CoC = g d). (This will take you to <code>//third_party/rust/.../qr_code-.../src/lib.rs</code>.)</li>
<li>æ¼”ç¤º <strong>outline</strong> å¹¶å‰å¾€ <code>QrCode::with_bits</code> æ–¹æ³•ï¼ˆå¤§çº¦ç¬¬ 164 è¡Œï¼›å¤§çº²ä½äº vscode ä¸­çš„æ–‡ä»¶èµ„æºç®¡ç†å™¨çª—æ ¼ä¸­ï¼›å…¸å‹ç»‘å®šï¼švim/CoC = space oï¼‰</li>
<li>Demo <strong>type annotations</strong> (there are quite a few nice examples in the <code>QrCode::with_bits</code> method)</li>
</ul>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¿®æ”¹ <code>BUILD.gn</code> æ–‡ä»¶åï¼Œéœ€è¦é‡æ–°è¿è¡Œ <code>gn gen ... --export-rust-project</code>ï¼ˆæˆ‘ä»¬å°†åœ¨æœ¬è¯¾ç¨‹çš„ç»ƒä¹ ä¸­å¤šæ¬¡æ‰§è¡Œè¯¥æ“ä½œï¼‰ã€‚</p>
</details>
<h1><a class="header" href="#build-rules-exercise" id="build-rules-exercise">Build rules exercise</a></h1>
<p>åœ¨ Chromium build ä¸­ï¼Œå‘ <code>//ui/base/BUILD.gn</code> æ·»åŠ æ–°çš„ Rust ç›®æ ‡ï¼Œå…¶ä¸­åŒ…å«ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
pub extern &quot;C&quot; fn hello_from_rust() {
    println!(&quot;Hello from Rust!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Important</strong>: note that <code>no_mangle</code> here is considered a type of unsafety by the Rust compiler, so you'll need to allow unsafe code in your <code>gn</code> target.</p>
<p>å°†è¿™ä¸ªæ–°çš„ Rust ç›®æ ‡æ·»åŠ ä¸º <code>//ui/base:base</code> çš„ä¾èµ–é¡¹ã€‚åœ¨ <code>ui/base/resource/resource_bundle.cc</code> é¡¶éƒ¨å£°æ˜æ­¤å‡½æ•°ï¼ˆç¨åï¼Œæˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•é€šè¿‡ç»‘å®šç”Ÿæˆå·¥å…·æ¥è‡ªåŠ¨æ‰§è¡Œæ­¤æ“ä½œï¼‰ï¼š</p>
<pre><code class="language-cpp">extern &quot;C&quot; void hello_from_rust();
</code></pre>
<p>ä» <code>ui/base/resource/resource_bundle.cc</code> ä¸­çš„æŸä¸ªä½ç½®è°ƒç”¨æ­¤å‡½æ•°ï¼Œæˆ‘ä»¬å»ºè®®åœ¨ä» <code>ResourceBundle::MaybeMangleLocalizedString</code> çš„é¡¶éƒ¨è°ƒç”¨æ­¤å‡½æ•°ã€‚æ„å»ºå¹¶è¿è¡Œ Chromiumï¼Œå¹¶ç¡®ä¿å¤šæ¬¡æ˜¾ç¤º &quot;Hello from Rust!&quot;ã€‚</p>
<p>å¦‚æœæ‚¨ä½¿ç”¨ VSCodeï¼Œç°åœ¨å°±è¯·è®¾ç½® Rustï¼Œä»¥ä¾¿å…¶èƒ½åœ¨ VSCode ä¸­æ­£å¸¸è¿è¡Œã€‚è¿™å¯¹åç»­ç»ƒä¹ ä¼šå¾ˆæœ‰å¸®åŠ©ã€‚å¦‚æœæ“ä½œæˆåŠŸï¼Œåˆ™å¯ä½¿ç”¨å³é”®ç‚¹å‡» <code>println!</code> ä¸Šçš„ &quot;Go to definition&quot;ã€‚</p>
<h2><a class="header" href="#å¦‚ä½•è·å–å¸®åŠ©" id="å¦‚ä½•è·å–å¸®åŠ©">å¦‚ä½•è·å–å¸®åŠ©</a></h2>
<ul>
<li>é€‚ç”¨äº [<code>rust_static_library</code> gn æ¨¡æ¿] çš„é€‰é¡¹ (https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16)</li>
<li>Information about <a href="https://doc.rust-lang.org/beta/reference/abi.html#the-no_mangle-attribute"><code>#[unsafe(no_mangle)]</code></a></li>
<li>å…³äº [<code>extern &quot;C&quot;</code>] çš„è¯¦ç»†ä¿¡æ¯ (https://doc.rust-lang.org/std/keyword.extern.html)</li>
<li>å…³äº gn çš„ [<code>--export-rust-project</code>] å¼€å…³çš„è¯¦ç»†ä¿¡æ¯ (https://gn.googlesource.com/gn/+/main/docs/reference.md#compilation-database)</li>
<li><a href="https://code.visualstudio.com/docs/languages/rust">å¦‚ä½•åœ¨ VSCode ä¸­å®‰è£… rust-analyzer</a></li>
</ul>
<details>
It's really important that students get this running, because future exercises
will build on it.
<p>æ­¤ç¤ºä¾‹å¾ˆç‹¬ç‰¹ï¼Œå› ä¸ºå…¶å½’æ ¹ç»“åº•æ˜¯æœ€é€šç”¨çš„äº’æ“ä½œè¯­è¨€ï¼Œå³ C è¯­è¨€ã€‚C++ å’Œ Rust æœ¬èº«éƒ½å¯ä»¥å£°æ˜å’Œè°ƒç”¨ C ABI å‡½æ•°ã€‚åœ¨æœ¬è¯¾ç¨‹çš„ç¨åéƒ¨åˆ†ï¼Œæˆ‘ä»¬ä¼šç›´æ¥å°† C++ å’Œ Rust å…³è”èµ·æ¥ã€‚</p>
<p><code>allow_unsafe = true</code> is required here because <code>#[unsafe(no_mangle)]</code> might allow Rust to generate two functions with the same name, and Rust can no longer guarantee that the right one is called.</p>
<p>å¦‚æœéœ€è¦çº¯ Rust å¯æ‰§è¡Œæ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ <code>rust_executable</code> gn æ¨¡æ¿æ‰§è¡Œæ­¤æ“ä½œã€‚</p>
</details>
<h1><a class="header" href="#æµ‹è¯•-1" id="æµ‹è¯•-1">æµ‹è¯•</a></h1>
<p>Rust community typically authors unit tests in a module placed in the same source file as the code being tested. This was covered <a href="chromium/../testing.html">earlier</a> in the course and looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn my_test() {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Chromium we place unit tests in a separate source file and we continue to follow this practice for Rust --- this makes tests consistently discoverable and helps to avoid rebuilding <code>.rs</code> files a second time (in the <code>test</code> configuration).</p>
<p>This results in the following options for testing Rust code in Chromium:</p>
<ul>
<li>Native Rust tests (i.e. <code>#[test]</code>). Discouraged outside of <code>//third_party/rust</code>.</li>
<li><code>gtest</code> tests authored in C++ and exercising Rust via FFI calls. Sufficient when Rust code is just a thin FFI layer and the existing unit tests provide sufficient coverage for the feature.</li>
<li><code>gtest</code> tests authored in Rust and using the crate under test through its public API (using <code>pub mod for_testing { ... }</code> if needed). This is the subject of the next few slides.</li>
</ul>
<details>
<p>Mention that native Rust tests of third-party crates should eventually be exercised by Chromium bots. (Such testing is needed rarely --- only after adding or updating third-party crates.)</p>
<p>Some examples may help illustrate when C++ <code>gtest</code> vs Rust <code>gtest</code> should be used:</p>
<ul>
<li>
<p>QR has very little functionality in the first-party Rust layer (it's just a thin FFI glue) and therefore uses the existing C++ unit tests for testing both the C++ and the Rust implementation (parameterizing the tests so they enable or disable Rust using a <code>ScopedFeatureList</code>).</p>
</li>
<li>
<p>Hypothetical/WIP PNG integration may need to implement memory-safe implementation of pixel transformations that are provided by <code>libpng</code> but missing in the <code>png</code> crate - e.g. RGBA =&gt; BGRA, or gamma correction. Such functionality may benefit from separate tests authored in Rust.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#rust_gtest_interop-åº“" id="rust_gtest_interop-åº“"><code>rust_gtest_interop</code> åº“</a></h1>
<p>The <a href="https://chromium.googlesource.com/chromium/src/+/main/testing/rust_gtest_interop/README.md"><code>rust_gtest_interop</code></a> library provides a way to:</p>
<ul>
<li>Use a Rust function as a <code>gtest</code> testcase (using the <code>#[gtest(...)]</code> attribute)</li>
<li>Use <code>expect_eq!</code> and similar macros (similar to <code>assert_eq!</code> but not panicking and not terminating the test when the assertion fails).</li>
</ul>
<p>Example:</p>
<pre><code class="language-rust ignore">use rust_gtest_interop::prelude::*;

#[gtest(MyRustTestSuite, MyAdditionTest)]
fn test_addition() {
    expect_eq!(2 + 2, 4);
}
</code></pre>
<h1><a class="header" href="#rust-æµ‹è¯•çš„-gn-è§„åˆ™" id="rust-æµ‹è¯•çš„-gn-è§„åˆ™">Rust æµ‹è¯•çš„ GN è§„åˆ™</a></h1>
<p>The simplest way to build Rust <code>gtest</code> tests is to add them to an existing test binary that already contains tests authored in C++. For example:</p>
<pre><code class="language-gn">test(&quot;ui_base_unittests&quot;) {
  ...
  sources += [ &quot;my_rust_lib_unittest.rs&quot; ]
  deps += [ &quot;:my_rust_lib&quot; ]
}
</code></pre>
<p>Authoring Rust tests in a separate <code>static_library</code> also works, but requires manually declaring the dependency on the support libraries:</p>
<pre><code class="language-gn">rust_static_library(&quot;my_rust_lib_unittests&quot;) {
  testonly = true
  is_gtest_unittests = true
  crate_root = &quot;my_rust_lib_unittest.rs&quot;
  sources = [ &quot;my_rust_lib_unittest.rs&quot; ]
  deps = [
    &quot;:my_rust_lib&quot;,
    &quot;//testing/rust_gtest_interop&quot;,
  ]
}

test(&quot;ui_base_unittests&quot;) {
  ...
  deps += [ &quot;:my_rust_lib_unittests&quot; ]
}
</code></pre>
<h1><a class="header" href="#chromiumimport-å®" id="chromiumimport-å®"><code>chromium::import!</code> å®</a></h1>
<p>After adding <code>:my_rust_lib</code> to GN <code>deps</code>, we still need to learn how to import and use <code>my_rust_lib</code> from <code>my_rust_lib_unittest.rs</code>. We haven't provided an explicit <code>crate_name</code> for <code>my_rust_lib</code> so its crate name is computed based on the full target path and name. Fortunately we can avoid working with such an unwieldy name by using the <code>chromium::import!</code> macro from the automatically-imported <code>chromium</code> crate:</p>
<pre><code class="language-rust ignore">chromium::import! {
    &quot;//ui/base:my_rust_lib&quot;;
}

use my_rust_lib::my_function_under_test;
</code></pre>
<p>Under the covers the macro expands to something similar to:</p>
<pre><code class="language-rust ignore">extern crate ui_sbase_cmy_urust_ulib as my_rust_lib;

use my_rust_lib::my_function_under_test;
</code></pre>
<p>More information can be found in <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/chromium_prelude/chromium_prelude.rs?q=f:chromium_prelude.rs%20pub.use.*%5Cbimport%5Cb;%20-f:third_party&amp;ss=chromium%2Fchromium%2Fsrc">the doc comment</a> of the <code>chromium::import</code> macro.</p>
<details>
<p><code>rust_static_library</code> supports specifying an explicit name via <code>crate_name</code> property, but doing this is discouraged. And it is discouraged because the crate name has to be globally unique. crates.io guarantees uniqueness of its crate names so <code>cargo_crate</code> GN targets (generated by the <code>gnrt</code> tool covered in a later section) use short crate names.</p>
</details>
<h1><a class="header" href="#testing-exercise" id="testing-exercise">Testing exercise</a></h1>
<p>Time for another exercise!</p>
<p>In your Chromium build:</p>
<ul>
<li>Add a testable function next to <code>hello_from_rust</code>. Some suggestions: adding two integers received as arguments, computing the nth Fibonacci number, summing integers in a slice, etc.</li>
<li>Add a separate <code>..._unittest.rs</code> file with a test for the new function.</li>
<li>Add the new tests to <code>BUILD.gn</code>.</li>
<li>Build the tests, run them, and verify that the new test works.</li>
</ul>
<h1><a class="header" href="#ä¸-c-çš„äº’æ“ä½œæ€§-1" id="ä¸-c-çš„äº’æ“ä½œæ€§-1">ä¸ C++ çš„äº’æ“ä½œæ€§</a></h1>
<p>Rust ç¤¾åŒºæä¾›äº†å¤šç§ C++/Rust äº’æ“ä½œé€‰é¡¹ï¼Œå¹¶ä¸”ä¸€ç›´åœ¨ä¸æ–­å¼€å‘æ–°å·¥å…·ã€‚ç›®å‰ï¼ŒChromium ä½¿ç”¨ä¸€ç§åä¸º CXX çš„å·¥å…·ã€‚</p>
<p>æ‚¨å¯ä»¥ä½¿ç”¨æ¥å£å®šä¹‰è¯­è¨€ï¼ˆä¸ Rust æä¸ºç›¸ä¼¼ï¼‰æè¿°æ•´ä¸ªè¯­è¨€è¾¹ç•Œï¼Œç„¶å CXX å·¥å…·ä¼šæ®æ­¤ç”Ÿæˆ Rust å’Œ C++ å‡½æ•°åŠç±»å‹çš„å£°æ˜ã€‚</p>
<img src="chromium/../android/interoperability/cpp/overview.svg" alt="Overview diagram of cxx, showing that the same interface definition is used to create both C++ and Rust side code which then communicate via a lowest common denominator C API">
<p>See the <a href="https://cxx.rs/tutorial.html">CXX tutorial</a> for a full example of using this.</p>
<details>
<p>è¯·ä»”ç»†ç ”ç©¶è¿™ä¸ªå›¾è¡¨ã€‚è§£é‡ŠèƒŒåçš„åŸç†å’Œæ‚¨ä¹‹å‰æ‰€åšçš„å®Œå…¨ç›¸åŒã€‚è¯´æ˜è‡ªåŠ¨æ‰§è¡Œè¿™ä¸€æµç¨‹å…·æœ‰ä»¥ä¸‹å¥½å¤„ï¼š</p>
<ul>
<li>ä½¿ç”¨è¯¥å·¥å…·å¯ä¿è¯ C++ ç«¯å’Œ Rust ç«¯ç›¸åŒ¹é…ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœ <code>#[cxx::bridge]</code> ä¸å®é™…çš„ C++ æˆ– Rust å®šä¹‰ä¸åŒ¹é…ï¼Œåˆ™ä¼šå‡ºç°ç¼–è¯‘é”™è¯¯ã€‚ä½†ä½¿ç”¨ä¸åŒæ­¥çš„æ‰‹åŠ¨ç»‘å®šï¼Œå¯èƒ½ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼‰</li>
<li>è¯¥å·¥å…·è¿˜å¯è‡ªåŠ¨ç”Ÿæˆ FFI thunkï¼ˆå³å°å‹ä½†å¯å…¼å®¹ C-ABI çš„è‡ªç”±å‡½æ•°ï¼‰ï¼Œä»¥ä¾¿é€‚åº”é C è¯­è¨€ç‰¹æ€§ï¼ˆä¾‹å¦‚ï¼Œå¯ç”¨å¯¹ Rust æˆ– C++ æ–¹æ³•çš„ FFI è°ƒç”¨ï¼›è€Œæ‰‹åŠ¨å®ç°ç»‘å®šä¸€èˆ¬éœ€è¦è‡ªè¡Œç¼–å†™è¿™ç§é¡¶çº§çš„è‡ªç”±å‡½æ•°ï¼‰</li>
<li>è¯¥å·¥å…·å’Œåº“å¯ä»¥å¤„ç†ä¸€ç³»åˆ—æ ¸å¿ƒç±»å‹ï¼Œä¾‹å¦‚ï¼š
<ul>
<li><code>&amp;[T]</code> å¯ä»¥è·¨ FFI è¾¹ç•Œè¿›è¡Œä¼ é€’ï¼Œå³ä½¿å®ƒæ— æ³•ä¿è¯ä»»ä½•ç‰¹å®šçš„ ABI æˆ–å†…å­˜å¸ƒå±€ä¸€è‡´æ— è¯¯ã€‚è¿›è¡Œæ‰‹åŠ¨ç»‘å®šæ—¶ï¼Œå¿…é¡»æ‰‹åŠ¨è§£æ„ <code>std::span&lt;T&gt;</code> / <code>&amp;[T]</code>ï¼Œå¹¶æ ¹æ®æŒ‡é’ˆå’Œé•¿åº¦è¿›è¡Œé‡æ–°æ„å»ºï¼Œä½†è¿™å¾ˆå®¹æ˜“å‡ºé”™ï¼Œå› ä¸ºæ¯ç§è¯­è¨€å¯¹äºç©º slice çš„è¡¨ç¤ºæ–¹å¼ç•¥æœ‰ä¸åŒ</li>
<li>ç³»ç»Ÿå¯¹ <code>std::unique_ptr&lt;T&gt;</code>ã€<code>std::shared_ptr&lt;T&gt;</code> å’Œ/æˆ– <code>Box</code> ç­‰æ™ºèƒ½æŒ‡é’ˆæä¾›åŸç”Ÿæ”¯æŒã€‚å¦‚æœä½¿ç”¨æ‰‹åŠ¨ç»‘å®šï¼Œåˆ™å¿…é¡»ä¼ é€’å¯å…¼å®¹ C-ABI çš„åŸå§‹æŒ‡é’ˆï¼Œè¿™ä¼šå¢åŠ ç”Ÿå‘½å‘¨æœŸå’Œå†…å­˜å®‰å…¨é£é™©ã€‚</li>
<li><code>rust::String</code> å’Œ <code>CxxString</code> ç±»å‹èƒ½å¤Ÿè¯†åˆ«å¹¶å¤„ç†ä¸åŒè¯­è¨€ä¹‹é—´åœ¨å­—ç¬¦ä¸²è¡¨ç¤ºæ–¹é¢çš„å·®å¼‚ï¼ˆä¾‹å¦‚ï¼Œ<code>rust::String::lossy</code> å¯ä»¥é€šè¿‡é UTF8 è¾“å…¥æ„å»º Rust å­—ç¬¦ä¸²ï¼›<code>rust::String::c_str</code> å¯ä»¥ä¸ºå­—ç¬¦ä¸²åŠ ä¸Š NUL ç»ˆæ­¢ç¬¦ï¼‰ã€‚</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#ç»‘å®šç¤ºä¾‹" id="ç»‘å®šç¤ºä¾‹">ç»‘å®šç¤ºä¾‹</a></h1>
<p>CXX requires that the whole C++/Rust boundary is declared in <code>cxx::bridge</code> modules inside <code>.rs</code> source code.</p>
<pre><code class="language-rust ignore">#[cxx::bridge]
mod ffi {
    extern &quot;Rust&quot; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    unsafe extern &quot;C++&quot; {
        include!(&quot;example/include/blobstore.h&quot;);

        type BlobstoreClient;

        fn new_blobstore_client() -&gt; UniquePtr&lt;BlobstoreClient&gt;;
        fn put(self: &amp;BlobstoreClient, buf: &amp;mut MultiBuf) -&gt; Result&lt;u64&gt;;
    }
}

// Definitions of Rust types and functions go here
</code></pre>
<details>
<p>æŒ‡å‡ºï¼š</p>
<ul>
<li>Although this looks like a regular Rust <code>mod</code>, the <code>#[cxx::bridge]</code> procedural macro does complex things to it. The generated code is quite a bit more sophisticated - though this does still result in a <code>mod</code> called <code>ffi</code> in your code.</li>
<li>Native support for C++'s <code>std::unique_ptr</code> in Rust</li>
<li>Native support for Rust slices in C++</li>
<li>ä» C++ è°ƒç”¨ Rustï¼Œå¹¶ä½¿ç”¨ Rust ç±»å‹ï¼ˆé¡¶éƒ¨ä½ç½®ï¼‰</li>
<li>ä» Rust è°ƒç”¨ C++ï¼Œå¹¶ä½¿ç”¨ C++ ç±»å‹ï¼ˆåº•éƒ¨ä½ç½®ï¼‰</li>
</ul>
<p><strong>å¸¸è§è¯¯è§£</strong>ï¼šè¿™ <em>çœ‹ä¼¼</em> Rust åœ¨è§£æ C++ å¤´æ–‡ä»¶ï¼Œå…¶å®å…·æœ‰è¯¯å¯¼æ€§ã€‚Rust ä¸ä¼šå¯¹æ­¤å¤´æ–‡ä»¶è¿›è¡Œè§£é‡Šï¼Œåªæ˜¯åœ¨ç”Ÿæˆçš„ C++ ä»£ç ä¸­æ·»åŠ  <code>#include</code>ï¼Œä»¥ä¾¿äº C++ ç¼–è¯‘å™¨ ä½¿ç”¨ã€‚</p>
</details>
<h2><a class="header" href="#cxx-çš„å±€é™æ€§" id="cxx-çš„å±€é™æ€§">CXX çš„å±€é™æ€§</a></h2>
<p>By far the most useful page when using CXX is the <a href="https://cxx.rs/bindings.html">type reference</a>.</p>
<p>CXX åŸºæœ¬é€‚ç”¨äºä»¥ä¸‹æƒ…å†µï¼š</p>
<ul>
<li>æ‚¨çš„ Rust-C++ æ¥å£éå¸¸ç®€å•ï¼Œå¯ä»¥å£°æ˜å…¶ä¸­çš„å…¨éƒ¨å†…å®¹ã€‚</li>
<li>ç›®å‰ï¼Œæ‚¨åªä½¿ç”¨äº† CXX æä¾›åŸç”Ÿæ”¯æŒçš„ç±»å‹ï¼Œä¾‹å¦‚ <code>std::unique_ptr</code>ã€<code>std::string</code>ã€<code>&amp;[u8]</code> ç­‰ã€‚</li>
</ul>
<p>è¿™æ ·å…·æœ‰å¾ˆå¤šå±€é™æ€§ï¼Œä¾‹å¦‚ç¼ºå°‘å¯¹ Rust çš„ <code>Option</code> ç±»å‹çš„æ”¯æŒã€‚</p>
<p>ç”±äºè¿™äº›å±€é™ï¼Œæˆ‘ä»¬åœ¨ Chromium ä¸­åªèƒ½å°† Rust ç”¨äºéš”ç¦»ç´§å¯†çš„ â€œå¶èŠ‚ç‚¹â€ï¼Œè€Œæ— æ³•ç”¨äºä»»æ„çš„ Rust-C++ äº’æ“ä½œã€‚å½“æ‚¨æ‰“ç®—åœ¨ Chromium ä¸­æ¢ç´¢ Rust çš„åº”ç”¨åœºæ™¯æ—¶ï¼Œæ¨èå…ˆä»æ‹Ÿå®šé’ˆå¯¹è¯­è¨€è¾¹ç•Œçš„ CXX ç»‘å®šå…¥æ‰‹ï¼Œä»¥æŸ¥çœ‹è¯¥è¯­è¨€è¾¹ç•Œæ˜¯å¦è¶³å¤Ÿç®€å•æ˜äº†ã€‚</p>
<details>
In addition, right now, Rust code in one component cannot depend on Rust
code in another, due to linking details in our component build. That's another
reason to restrict Rust to use in leaf nodes.
<p>æ­¤å¤–ï¼Œè¿˜åº”è®¨è®ºä½¿ç”¨ CXX æ—¶çš„å…¶ä»–ä¸€äº›å›°éš¾ä¹‹å¤„ï¼Œä¾‹å¦‚ï¼š</p>
<ul>
<li>å…¶æ ¹æ® C++ å¼‚å¸¸æ¥è¿›è¡Œé”™è¯¯å¤„ç†ï¼ˆä¸‹ä¸€å¼ å¹»ç¯ç‰‡ä¸­å°†åŠ ä»¥ä»‹ç»ï¼‰</li>
<li>å‡½æ•°æŒ‡é’ˆä½¿ç”¨èµ·æ¥å¾ˆä¸æ–¹ä¾¿ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#cxx-é”™è¯¯å¤„ç†" id="cxx-é”™è¯¯å¤„ç†">CXX é”™è¯¯å¤„ç†</a></h1>
<p>CXX's <a href="https://cxx.rs/binding/result.html">support for <code>Result&lt;T,E&gt;</code></a> relies on C++ exceptions, so we can't use that in Chromium. Alternatives:</p>
<ul>
<li>
<p>The <code>T</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned via out parameters (e.g. via <code>&amp;mut T</code>). This requires that <code>T</code> can be passed across the FFI boundary - for example <code>T</code> has to be:
<ul>
<li>A primitive type (like <code>u32</code> or <code>usize</code>)</li>
<li>A type natively supported by <code>cxx</code> (like <code>UniquePtr&lt;T&gt;</code>) that has a suitable default value to use in a failure case (<em>unlike</em> <code>Box&lt;T&gt;</code>).</li>
</ul>
</li>
<li>Retained on the Rust side, and exposed via reference. This may be needed when <code>T</code> is a Rust type, which cannot be passed across the FFI boundary, and cannot be stored in <code>UniquePtr&lt;T&gt;</code>.</li>
</ul>
</li>
<li>
<p>The <code>E</code> part of <code>Result&lt;T, E&gt;</code> can be:</p>
<ul>
<li>Returned as a boolean (e.g. <code>true</code> representing success, and <code>false</code> representing failure)</li>
<li>Preserving error details is in theory possible, but so far hasn't been needed in practice.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#cxx-error-handling-qr-example" id="cxx-error-handling-qr-example">CXX Error Handling: QR Example</a></h1>
<p>The QR code generator is <a href="https://source.chromium.org/chromium/chromium/src/+/main:components/qr_code_generator/qr_code_generator_ffi_glue.rs;l=13-18;drc=7bf1b75b910ca430501b9c6a74c1d18a0223ecca">an example</a> where a boolean is used to communicate success vs failure, and where the successful result can be passed across the FFI boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = &quot;qr_code_generator&quot;)]
mod ffi {
    extern &quot;Rust&quot; {
        fn generate_qr_code_using_rust(
            data: &amp;[u8],
            min_version: i16,
            out_pixels: Pin&lt;&amp;mut CxxVector&lt;u8&gt;&gt;,
            out_qr_size: &amp;mut usize,
        ) -&gt; bool;
    }
}
</code></pre>
<details>
<p>Students may be curious about the semantics of the <code>out_qr_size</code> output. This is not the size of the vector, but the size of the QR code (and admittedly it is a bit redundant - this is the square root of the size of the vector).</p>
<p>It may be worth pointing out the importance of initializing <code>out_qr_size</code> before calling into the Rust function. Creation of a Rust reference that points to uninitialized memory results in Undefined Behavior (unlike in C++, when only the act of dereferencing such memory results in UB).</p>
<p>If students ask about <code>Pin</code>, then explain why CXX needs it for mutable references to C++ data: the answer is that C++ data canâ€™t be moved around like Rust data, because it may contain self-referential pointers.</p>
</details>
<h1><a class="header" href="#cxx-error-handling-png-example" id="cxx-error-handling-png-example">CXX Error Handling: PNG Example</a></h1>
<p>A prototype of a PNG decoder illustrates what can be done when the successful result cannot be passed across the FFI boundary:</p>
<pre><code class="language-rust ignore">#[cxx::bridge(namespace = &quot;gfx::rust_bindings&quot;)]
mod ffi {
    extern &quot;Rust&quot; {
        /// This returns an FFI-friendly equivalent of `Result&lt;PngReader&lt;'a&gt;,
        /// ()&gt;`.
        fn new_png_reader&lt;'a&gt;(input: &amp;'a [u8]) -&gt; Box&lt;ResultOfPngReader&lt;'a&gt;&gt;;

        /// C++ bindings for the `crate::png::ResultOfPngReader` type.
        type ResultOfPngReader&lt;'a&gt;;
        fn is_err(self: &amp;ResultOfPngReader) -&gt; bool;
        fn unwrap_as_mut&lt;'a, 'b&gt;(
            self: &amp;'b mut ResultOfPngReader&lt;'a&gt;,
        ) -&gt; &amp;'b mut PngReader&lt;'a&gt;;

        /// C++ bindings for the `crate::png::PngReader` type.
        type PngReader&lt;'a&gt;;
        fn height(self: &amp;PngReader) -&gt; u32;
        fn width(self: &amp;PngReader) -&gt; u32;
        fn read_rgba8(self: &amp;mut PngReader, output: &amp;mut [u8]) -&gt; bool;
    }
}
</code></pre>
<details>
<p><code>PngReader</code> and <code>ResultOfPngReader</code> are Rust types --- objects of these types cannot cross the FFI boundary without indirection of a <code>Box&lt;T&gt;</code>. We can't have an <code>out_parameter: &amp;mut PngReader</code>, because CXX doesn't allow C++ to store Rust objects by value.</p>
<p>This example illustrates that even though CXX doesn't support arbitrary generics nor templates, we can still pass them across the FFI boundary by manually specializing / monomorphizing them into a non-generic type. In the example <code>ResultOfPngReader</code> is a non-generic type that forwards into appropriate methods of <code>Result&lt;T, E&gt;</code> (e.g. into <code>is_err</code>, <code>unwrap</code>, and/or <code>as_mut</code>).</p>
</details>
<h2><a class="header" href="#using-cxx-in-chromium" id="using-cxx-in-chromium">Using cxx in Chromium</a></h2>
<p>åœ¨ Chromium ä¸­ï¼Œé’ˆå¯¹æ¯ä¸ªéœ€è¦ä½¿ç”¨ Rust çš„å¶èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å®šä¹‰ç‹¬ç«‹çš„ <code>#[cxx::bridge] mod</code>ã€‚é€šå¸¸ï¼Œæ¯ä¸ª <code>rust_static_library</code> éƒ½æœ‰å¯¹åº”çš„å®šä¹‰ã€‚åªéœ€å°†</p>
<pre><code class="language-gn">cxx_bindings = [ &quot;my_rust_file.rs&quot; ]
   # list of files containing #[cxx::bridge], not all source files
allow_unsafe = true
</code></pre>
<p>æ·»åŠ åˆ°æ‚¨ç°æœ‰çš„ <code>rust_static_library</code> ä»¥åŠ <code>crate_root</code> å’Œ <code>sources</code> çš„ç›®æ ‡ä¸­ã€‚</p>
<p>C++ å¤´æ–‡ä»¶ä¼šåœ¨åˆç†çš„ä½ç½®ç”Ÿæˆï¼Œå› æ­¤æ‚¨åªéœ€</p>
<pre><code class="language-cpp">#include &quot;ui/base/my_rust_file.rs.h&quot;
</code></pre>
<p>æ‚¨ä¼šå‘ç°ï¼Œ<code>//base</code> ä¸­æä¾›äº†ä¸€äº›å®ç”¨å‡½æ•°ï¼Œå¯å°† Chromium C++ ç±»å‹ä¸ CXX Rust ç±»å‹ç›¸äº’è½¬æ¢ï¼Œä¾‹å¦‚ <a href="https://source.chromium.org/chromium/chromium/src/+/main:base/containers/span_rust.h;l=21"><code>SpanToRustSlice</code></a>ã€‚</p>
<details>
<p>å­¦ç”Ÿå¯èƒ½ä¼šé—®ï¼šä¸ºä»€ä¹ˆæˆ‘ä»¬ä»ç„¶éœ€è¦ <code>allow_unsafe = true</code>ï¼Ÿ</p>
<p>æ€»çš„æ¥è¯´ï¼ŒæŒ‰ç…§å¸¸è§„ Rust æ ‡å‡†ï¼Œæ²¡æœ‰ä»»ä½• C/C++ ä»£ç æ˜¯ â€œå®‰å…¨â€çš„ã€‚åœ¨ Rust ä¸­æ¥å›è°ƒç”¨ C/C++ å¯èƒ½ä¼šå¯¹å†…å­˜æ‰§è¡Œä»»æ„æ“ä½œï¼Œå¹¶å±åŠ Rust è‡ªèº«æ•°æ®å¸ƒå±€çš„å®‰å…¨æ€§ã€‚å¦‚æœ C/C++ äº’æ“ä½œæ€§ä¸­å‡ºç° <em>è¿‡å¤š</em> çš„ <code>unsafe</code> å…³é”®å­—ï¼Œå¯èƒ½ä¼šæŸå®³æ­¤ç±»å…³é”®å­—çš„ä¿¡å™ªæ¯”ï¼Œå¹¶ä¸” <a href="https://steveklabnik.com/writing/the-cxx-debate">å­˜åœ¨äº‰è®®</a>ã€‚ä½†ä¸¥æ ¼åœ°è¯´ï¼Œå°†ä»»ä½•å¤–éƒ¨ä»£ç å¼•å…¥ Rust äºŒè¿›åˆ¶æ–‡ä»¶å¯èƒ½ä¼šå¯¼è‡´ Rust ä¸­å‡ºç°æ„å¤–è¡Œä¸ºã€‚</p>
<p>The narrow answer lies in the diagram at the top of <a href="chromium/interoperability-with-cpp/../interoperability-with-cpp.html">this page</a> --- behind the scenes, CXX generates Rust <code>unsafe</code> and <code>extern &quot;C&quot;</code> functions just like we did manually in the previous section.</p>
</details>
<h1><a class="header" href="#exercise-interoperability-with-c" id="exercise-interoperability-with-c">Exercise: Interoperability with C++</a></h1>
<h2><a class="header" href="#ç¬¬ä¸€éƒ¨åˆ†" id="ç¬¬ä¸€éƒ¨åˆ†">ç¬¬ä¸€éƒ¨åˆ†</a></h2>
<ul>
<li>åœ¨æ‚¨ä¹‹å‰åˆ›å»ºçš„ Rust æ–‡ä»¶ä¸­ï¼Œæ·»åŠ  <code>#[cxx::bridge]</code> æ¥æŒ‡å®šä¸€ä¸ªå°†ä» C++ è°ƒç”¨çš„å‡½æ•°ï¼ˆåä¸º <code>hello_from_rust</code>ï¼‰ï¼Œè¯¥å‡½æ•°ä¸æ¥å—ä»»ä½•å‚æ•°ä¹Ÿä¸è¿”å›ä»»ä½•å€¼ã€‚</li>
<li>Modify your previous <code>hello_from_rust</code> function to remove <code>extern &quot;C&quot;</code> and <code>#[unsafe(no_mangle)]</code>. This is now just a standard Rust function.</li>
<li>è¯·ä¿®æ”¹ <code>gn</code> ç›®æ ‡ä»¥æ„å»ºè¿™äº›ç»‘å®šã€‚</li>
<li>åœ¨ C++ ä»£ç ä¸­ï¼Œç§»é™¤ <code>hello_from_rust</code> çš„æ­£å‘å£°æ˜ï¼Œç„¶åæ·»åŠ ç”Ÿæˆçš„å¤´æ–‡ä»¶ã€‚</li>
<li>Build and run!</li>
</ul>
<h2><a class="header" href="#ç¬¬äºŒéƒ¨åˆ†" id="ç¬¬äºŒéƒ¨åˆ†">ç¬¬äºŒéƒ¨åˆ†</a></h2>
<p>å»ºè®®å°è¯•æ“ä½œä¸€ä¸‹ CXXã€‚è¿™æœ‰åŠ©äºæ‚¨æ›´å¥½åœ°ç†è§£ Rust åœ¨Chromium ä¸­çš„çµæ´»æ€§ã€‚</p>
<p>Some things to try:</p>
<ul>
<li>ä» Rust å›è°ƒåˆ° C++ã€‚æ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š
<ul>
<li>åˆ›å»ºä¸€ä¸ªé™„åŠ å¤´æ–‡ä»¶ï¼Œä¸”æ‚¨å¯ä»¥ä» <code>cxx::bridge</code> å¯¹å…¶è¿›è¡Œ <code>include!</code> æ“ä½œã€‚æ‚¨éœ€è¦åœ¨è¿™ä¸ªæ–°çš„å¤´æ–‡ä»¶ä¸­å£°æ˜è¦è°ƒç”¨çš„ C++ å‡½æ•°ã€‚</li>
<li>åˆ›å»ºä¸€ä¸ª <code>unsafe</code> ä»£ç å—ï¼Œç”¨äºè°ƒç”¨æ­¤ç±»å‡½æ•°ï¼Œä¹Ÿå¯ä»¥åœ¨ <code>#[cxx::bridge]</code> ä¸­æŒ‡å®š <code>unsafe</code> å…³é”®å­—ï¼Œ<a href="https://cxx.rs/extern-c++.html#functions-and-member-functions">å¦‚æ­¤å¤„æ‰€è¿°</a>ã€‚</li>
<li>æ‚¨å¯èƒ½è¿˜éœ€è¦æ·»åŠ  <code>#include &quot;third_party/rust/cxx/v1/crate/include/cxx.h&quot;</code></li>
</ul>
</li>
<li>å°† C++ å­—ç¬¦ä¸²ä» C++ ä¼ é€’åˆ° Rustã€‚</li>
<li>å°†å¯¹ C++ å¯¹è±¡çš„å¼•ç”¨ä¼ é€’åˆ° Rustã€‚</li>
<li>åˆ»æ„è®© Rust å‡½æ•°ç­¾åä¸ <code>#[cxx::bridge]</code> ä¸åŒ¹é…ï¼Œå¹¶é€æ¸ç†Ÿæ‚‰æ‰€çœ‹åˆ°çš„é”™è¯¯ä¿¡æ¯ã€‚</li>
<li>åˆ»æ„è®© C++ å‡½æ•°ç­¾åä¸ <code>#[cxx::bridge]</code> ä¸åŒ¹é…ï¼Œå¹¶é€‚åº”æ‚¨çœ‹åˆ°çš„é”™è¯¯ã€‚</li>
<li>å°†æŸä¸ªç±»å‹çš„ <code>std::unique_ptr</code> ä» C++ ä¼ é€’åˆ° Rustï¼Œä»¥ä¾¿ Rust æ‹¥æœ‰æŸä¸ª C++ å¯¹è±¡çš„æ‰€æœ‰æƒã€‚</li>
<li>åˆ›å»ºä¸€ä¸ª Rust å¯¹è±¡å¹¶å°†å…¶ä¼ é€’åˆ° C++ï¼Œä»¥ä¾¿ C++ æ‹¥æœ‰å®ƒçš„æ‰€æœ‰æƒã€‚ï¼ˆæç¤ºï¼šæ‚¨éœ€è¦ä½¿ç”¨ <code>Box</code>ï¼‰ã€‚</li>
<li>å£°æ˜è°ƒç”¨æŸä¸ª C++ ç±»å‹çš„æ–¹æ³•ã€‚ä» Rust è°ƒç”¨å®ƒä»¬ã€‚</li>
<li>å£°æ˜è°ƒç”¨æŸä¸ª Rust ç±»å‹çš„æ–¹æ³•ã€‚ä» C++ è°ƒç”¨å®ƒä»¬ã€‚</li>
</ul>
<h2><a class="header" href="#ç¬¬ä¸‰éƒ¨åˆ†" id="ç¬¬ä¸‰éƒ¨åˆ†">ç¬¬ä¸‰éƒ¨åˆ†</a></h2>
<p>ç°åœ¨ï¼Œæ‚¨å·²ç»äº†è§£äº† CXX äº’æ“ä½œæ€§çš„ä¼˜åŠ¿å’Œå±€é™ï¼Œè¯·æ€è€ƒå‡ ä¸ª Rust åœ¨ Chromium ä¸­çš„åº”ç”¨åœºæ™¯ï¼Œå…¶ä¸­æ¥å£è¦è¶³å¤Ÿç®€å•æ„æ€è¯¥å¦‚ä½•å®šä¹‰è¯¥æ¥å£ã€‚</p>
<h2><a class="header" href="#å¦‚ä½•è·å–å¸®åŠ©-1" id="å¦‚ä½•è·å–å¸®åŠ©-1">å¦‚ä½•è·å–å¸®åŠ©</a></h2>
<ul>
<li>The <a href="https://cxx.rs/bindings.html"><code>cxx</code> binding reference</a></li>
<li><a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_static_library.gni;l=16"><code>rust_static_library</code> gn æ¨¡æ¿</a></li>
</ul>
<details>
As students explore Part Two, they're bound to have lots of questions about how
to achieve these things, and also how CXX works behind the scenes.
<p>æ‚¨å¯èƒ½ä¼šé‡åˆ°ä»¥ä¸‹é—®é¢˜ï¼š</p>
<ul>
<li>å½“æˆ‘ç”¨ç±»å‹ Y åˆå§‹åŒ–ç±»å‹ X çš„å˜é‡æ—¶ï¼Œå‡ºç°äº†åˆå§‹åŒ–é—®é¢˜ï¼Œå…¶ä¸­ X å’Œ Y éƒ½æ˜¯å‡½æ•°ç±»å‹ã€‚è¿™æ˜¯å› ä¸ºæ‚¨çš„ C++ å‡½æ•°å®ç°ä¸ <code>cxx::bridge</code> ä¸­çš„å£°æ˜å¹¶ä¸å®Œå…¨ä¸€è‡´ã€‚</li>
<li>æˆ‘å¥½åƒèƒ½éšæ„å°† C++ å¼•ç”¨è½¬æ¢ä¸º Rust å¼•ç”¨ã€‚è¿™æ ·ä¸ä¼šå¯¼è‡´ UB é£é™©å—ï¼Ÿå¯¹äº CXX çš„_ä¸é€æ˜_ç±»å‹ï¼Œç­”æ¡ˆä¸ºå¦ï¼Œå› ä¸ºå®ƒä»¬çš„å¤§å°ä¸ºé›¶ã€‚å¯¹äº CXX çš„åŸºæœ¬ç±»å‹ï¼Œç¡®å®_æœ‰å¯èƒ½_å¯¼è‡´ UBï¼Œä½†é‰´äº CXX çš„è®¾è®¡ç­–ç•¥ï¼Œè¦æ„å»ºèƒ½å¯¼è‡´è¿™ç§æƒ…å†µçš„ç¤ºä¾‹é¢‡ä¸ºå›°éš¾ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#æ·»åŠ ç¬¬ä¸‰æ–¹-crate" id="æ·»åŠ ç¬¬ä¸‰æ–¹-crate">æ·»åŠ ç¬¬ä¸‰æ–¹ Crate</a></h1>
<p>Rust åº“è¢«ç§°ä¸º <code>crate</code>ï¼Œå¯åœ¨ <a href="https://crates.io">crates.io</a> ä¸­æ‰¾åˆ°ã€‚Rust çš„ crate ä¹‹é—´éå¸¸å®¹æ˜“ç›¸äº’ä¾èµ–ã€‚äº‹å®è¯æ˜ï¼Œä»–ä»¬ç¡®å®å¦‚æ­¤ï¼</p>
<table><thead><tr><th>å±æ€§</th><th>C++ library</th><th>Rust crate</th></tr></thead><tbody>
<tr><td>Build system</td><td>å¾ˆå¤š</td><td>ä¿æŒä¸€è‡´ï¼š<code>Cargo.toml</code></td></tr>
<tr><td>å…¸å‹åº“çš„å¤§å°</td><td>å¤§</td><td>å°</td></tr>
<tr><td>ä¼ é€’ä¾èµ–é¡¹</td><td>å¾ˆå°‘</td><td>å¾ˆå¤š</td></tr>
</tbody></table>
<p>å¯¹äº Chromium å·¥ç¨‹å¸ˆæ¥è¯´ï¼Œè¿™ç§ä¾èµ–å…³ç³»å…·æœ‰ä»¥ä¸‹åˆ©å¼Šï¼š</p>
<ul>
<li>æ‰€æœ‰ crate éƒ½ä½¿ç”¨å…±åŒçš„æ„å»ºç³»ç»Ÿï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è‡ªåŠ¨å°†å…¶æ”¶å½•åˆ° Chromium ä¸­...</li>
<li>...ä½†æ˜¯ï¼Œcrate é€šå¸¸å…·æœ‰ä¼ é€’ä¾èµ–é¡¹ï¼Œå› æ­¤å¯èƒ½éœ€è¦å¼•å…¥å¤šä¸ªåº“ã€‚</li>
</ul>
<p>æˆ‘ä»¬å°†è®¨è®ºä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>å¦‚ä½•å°† crate æ·»åŠ åˆ° Chromium æºä»£ç æ ‘ä¸­</li>
<li>å¦‚ä½•ä¸ºå…¶åˆ¶å®š <code>gn</code> æ„å»ºè§„åˆ™</li>
<li>å¦‚ä½•å®¡æ ¸å…¶æºä»£ç ä»¥ç¡®ä¿è¶³å¤Ÿçš„å®‰å…¨æ€§ã€‚</li>
</ul>
<details>
All of the things in the table on this slide are generalizations, and
counter-examples can be found. But in general it's important for students
to understand that most Rust code depends on other Rust libraries, because
it's easy to do so, and that this has both benefits and costs.
</details>
<h1><a class="header" href="#é…ç½®-cargotom-æ–‡ä»¶ä»¥æ·»åŠ -crate" id="é…ç½®-cargotom-æ–‡ä»¶ä»¥æ·»åŠ -crate">é…ç½® <code>Cargo.tom</code> æ–‡ä»¶ä»¥æ·»åŠ  crate</a></h1>
<p>Chromium å…·æœ‰ä¸€ç»„é›†ä¸­ç®¡ç†çš„ç›´æ¥ crate ä¾èµ–é¡¹ã€‚è¿™äº›ä¾èµ–é¡¹é€šè¿‡å•ç‹¬çš„ <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/Cargo.toml"><code>Cargo.toml</code></a> æ–‡ä»¶è¿›è¡Œç®¡ç†ï¼š</p>
<pre><code class="language-toml">[dependencies]
bitflags = &quot;1&quot;
cfg-if = &quot;1&quot;
cxx = &quot;1&quot;
# lots more...
</code></pre>
<p>ä¸ä»»ä½•å…¶ä»– <code>Cargo.toml</code> ä¸€æ ·ï¼Œæ‚¨å¯ä»¥æŒ‡å®š <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">æœ‰å…³ä¾èµ–é¡¹çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯</a>ã€‚æœ€å¸¸è§çš„æ˜¯ï¼Œæ‚¨éœ€è¦æŒ‡å®šè¦åœ¨ crate ä¸­å¯ç”¨çš„ <code>features</code>ã€‚</p>
<p>å‘ Chromium ä¸­æ·»åŠ  crate æ—¶ï¼Œé€šå¸¸éœ€è¦åœ¨é™„åŠ æ–‡ä»¶ <code>gnrt_config.toml</code> ä¸­æä¾›ä¸€äº›é¢å¤–çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹æ–‡ä¸­åŠ ä»¥ä»‹ç»ã€‚</p>
<h1><a class="header" href="#é…ç½®-gnrt_configtoml" id="é…ç½®-gnrt_configtoml">é…ç½® <code>gnrt_config.toml</code></a></h1>
<p>ä¸ <code>Cargo.toml</code> ä¸€èµ·ä½¿ç”¨çš„æ˜¯ <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/gnrt_config.toml"><code>gnrt_config.toml</code></a>ã€‚æ­¤æ–‡ä»¶åŒ…å« Chromium ä¸“ç”¨æ‰©å±•ç¨‹åºï¼Œå¯ç”¨äºå¤„ç† crateã€‚</p>
<p>å¦‚æœæ·»åŠ æ–°çš„ crateï¼Œè‡³å°‘è¦æ˜ç¡®æŒ‡å®š <code>group</code>ã€‚å¯ä»¥ä¸ºä»¥ä¸‹é€‰é¡¹ä¹‹ä¸€ï¼š</p>
<pre><code class="language-toml">#   'safe': The library satisfies the rule-of-2 and can be used in any process.
#   'sandbox': The library does not satisfy the rule-of-2 and must be used in
#              a sandboxed process such as the renderer or a utility process.
#   'test': The library is only used in tests.
</code></pre>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class="language-toml">[crate.my-new-crate]
group = 'test' # only used in test code
</code></pre>
<p>æ ¹æ® crate æºä»£ç å¸ƒå±€ï¼Œæ‚¨å¯èƒ½è¿˜éœ€è¦ä½¿ç”¨æ­¤æ–‡ä»¶æŒ‡å®šå…¶ <code>LICENSE</code> æ–‡ä»¶çš„æ‰€åœ¨ä½ç½®ã€‚</p>
<p>ç¨åï¼Œæˆ‘ä»¬å°†ä»‹ç»éœ€è¦åœ¨æ­¤æ–‡ä»¶ä¸­é…ç½®çš„å…¶ä»–å†…å®¹ï¼Œä»¥ä¾¿èƒ½å¤Ÿè§£å†³é—®é¢˜ã€‚</p>
<h1><a class="header" href="#ä¸‹è½½-crate" id="ä¸‹è½½-crate">ä¸‹è½½ Crate</a></h1>
<p>æœ‰ä¸€æ¬¾åä¸º <code>gnrt</code> çš„å·¥å…·ï¼Œå…·æœ‰ä¸‹è½½ crate ä»¥åŠç”Ÿæˆ <code>BUILD.gn</code> è§„åˆ™çš„åŠŸèƒ½ã€‚</p>
<p>é¦–å…ˆï¼ŒæŒ‰å¦‚ä¸‹æ‰€ç¤ºä¸‹è½½æ‰€éœ€çš„ crateï¼š</p>
<pre><code class="language-shell">cd chromium/src
vpython3 tools/crates/run_gnrt.py -- vendor
</code></pre>
<blockquote>
<p>è™½ç„¶ <code>gnrt</code> å·¥å…·æ˜¯ Chromium æºä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œä½†é€šè¿‡è¿è¡Œæ­¤å‘½ä»¤ï¼Œæ‚¨å¯ä»¥ä» <code>crates.io</code> ä¸‹è½½å¹¶è¿è¡Œå…¶ä¾èµ–é¡¹ã€‚æœ‰å…³è¯¥å®‰å…¨å†³ç­–çš„è®¨è®ºï¼Œè¯·å‚é˜… <a href="chromium/adding-third-party-crates/../cargo.html">å‰é¢çš„éƒ¨åˆ†</a>ã€‚</p>
</blockquote>
<p>è¿è¡Œæ­¤ <code>vendor</code> å‘½ä»¤å¯èƒ½ä¼šä¸‹è½½ä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>Your crate</li>
<li>ç›´æ¥ä¾èµ–é¡¹å’Œä¼ é€’ä¾èµ–é¡¹</li>
<li><code>cargo</code> è¦æ±‚çš„å…¶ä»– crate çš„æ–°ç‰ˆæœ¬ï¼Œç”¨äºè§£æ Chromium æ‰€éœ€çš„å…¨éƒ¨ crateã€‚</li>
</ul>
<p>Chromium ä¼šä¿®å¤ä¸€äº› crate çš„è¡¥ä¸ï¼Œå¹¶å°†å…¶ä¿å­˜åœ¨ <code>//third_party/rust/chromium_crates_io/patches</code> ä¸­ã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨é‡æ–°åº”ç”¨è¿™äº›è¡¥ä¸ï¼Œä½†å¦‚æœè¡¥ä¸åº”ç”¨å¤±è´¥ï¼Œæ‚¨å¯èƒ½éœ€è¦è¿›è¡Œæ‰‹åŠ¨æ“ä½œã€‚</p>
<h1><a class="header" href="#ç”Ÿæˆ-gn-æ„å»ºè§„åˆ™" id="ç”Ÿæˆ-gn-æ„å»ºè§„åˆ™">ç”Ÿæˆ <code>gn</code> æ„å»ºè§„åˆ™</a></h1>
<p>ä¸‹è½½ crate åï¼ŒæŒ‰å¦‚ä¸‹æ–¹å¼ç”Ÿæˆ <code>BUILD.gn</code> æ–‡ä»¶ï¼š</p>
<pre><code class="language-shell">vpython3 tools/crates/run_gnrt.py -- gen
</code></pre>
<p>ç°åœ¨ï¼Œè¿è¡Œ <code>git status</code>ã€‚æ‚¨åº”è¯¥ä¼šçœ‹åˆ°ï¼š</p>
<ul>
<li><code>third_party/rust/chromium_crates_io/vendor</code> ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ–°çš„ crate æºä»£ç </li>
<li><code>third_party/rust/&lt;crate name&gt;/v&lt;major semver version&gt;</code> ä¸­è‡³å°‘åŒ…å«ä¸€ä¸ªæ–°çš„ <code>BUILD.gn</code></li>
<li>ç›¸åº”çš„ <code>README.chromium</code></li>
</ul>
<p>The &quot;major semver version&quot; is a <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Rust &quot;semver&quot; version number</a>.</p>
<p>è¯·ä»”ç»†è§‚å¯Ÿï¼Œå°¤å…¶æ˜¯ <code>third_party/rust</code> ä¸­ç”Ÿæˆçš„å†…å®¹ã€‚</p>
<details>
<p>æµ…è°ˆä¸‹ semverï¼Œç‰¹åˆ«æ˜¯åœ¨ Chromium ä¸­ï¼Œå®ƒæ”¯æŒä½¿ç”¨å¤šä¸ªä¸å…¼å®¹çš„ crate ç‰ˆæœ¬ã€‚è™½ç„¶åœ¨ Cargo ç”Ÿæ€ç³»ç»Ÿä¸­ä¸é¼“åŠ±è¿™ç§æ–¹å¼ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹å´æ˜¯å¿…è¦çš„ã€‚</p>
</detail>
<h1><a class="header" href="#è§£å†³é—®é¢˜" id="è§£å†³é—®é¢˜">è§£å†³é—®é¢˜</a></h1>
<p>å¦‚æœæ„å»ºå¤±è´¥ï¼Œå¯èƒ½æ˜¯ <code>build.rs</code> æ–‡ä»¶æ‰€è‡´ï¼šè¿™äº›ç¨‹åºåœ¨æ„å»ºè¿‡ç¨‹ä¸­æ‰§è¡Œäº†ä»»æ„æ“ä½œã€‚è¿™ä¸ <code>gn</code> å’Œ <code>ninja</code> çš„è®¾è®¡å®Œå…¨ä¸ç›¸ç¬¦ï¼Œå®ƒä»¬æ—¨åœ¨å®ç°é™æ€ã€ç¡®å®šæ€§çš„æ„å»ºè§„åˆ™ï¼Œä»¥æœ€å¤§é™åº¦åœ°æé«˜æ„å»ºçš„å¹¶è¡Œæ€§å’Œå¯é‡å¤æ€§ã€‚</p>
<p>ç³»ç»Ÿæ”¯æŒè‡ªåŠ¨è¿›è¡ŒæŸäº› <code>build.rs</code> æ“ä½œï¼›è€Œæœ‰äº›éœ€è¦è¿›è¡Œé¢å¤–çš„å¤„ç†ï¼š</p>
<table><thead><tr><th>æ„å»ºè„šæœ¬æ•ˆæœ</th><th>æˆ‘ä»¬çš„ gn æ¨¡æ¿å‡æ”¯æŒ</th><th>æ‚¨éœ€è¦å®Œæˆçš„å·¥ä½œ</th></tr></thead><tbody>
<tr><td>æ£€æŸ¥ rustc ç‰ˆæœ¬ä»¥é…ç½®å¯ç”¨å’Œåœç”¨åŠŸèƒ½</td><td>æ˜¯</td><td>æ— </td></tr>
<tr><td>æ£€æŸ¥å¹³å°æˆ– CPU ä»¥é…ç½®å¯ç”¨å’Œåœç”¨åŠŸèƒ½</td><td>æ˜¯</td><td>æ— </td></tr>
<tr><td>Generating code</td><td>æ˜¯</td><td>æ˜¯çš„ï¼Œåœ¨ <code>gnrt_config.toml</code> ä¸­æŒ‡å®š</td></tr>
<tr><td>æ„å»º C/C++</td><td>å¦</td><td>è¿›è¡Œè¡¥ä¸ä¿®å¤</td></tr>
<tr><td>Arbitrary other actions</td><td>å¦</td><td>è¿›è¡Œè¡¥ä¸ä¿®å¤</td></tr>
</tbody></table>
<p>å¹¸è¿çš„æ˜¯ï¼Œå¤§å¤šæ•° crate ä¸åŒ…å«æ„å»ºè„šæœ¬ï¼Œè€Œä¸”å¤§å¤šæ•°çš„æ„å»ºè„šæœ¬åªæ‰§è¡Œå‰ä¸¤é¡¹æ“ä½œã€‚</p>
<h1><a class="header" href="#æ„å»ºç”¨äºç”Ÿæˆä»£ç çš„è„šæœ¬" id="æ„å»ºç”¨äºç”Ÿæˆä»£ç çš„è„šæœ¬">æ„å»ºç”¨äºç”Ÿæˆä»£ç çš„è„šæœ¬</a></h1>
<p>å¦‚æœ <code>ninja</code> æç¤ºæœ‰æ–‡ä»¶ç¼ºå¤±ï¼Œè¯·æ£€æŸ¥ <code>build.rs</code>ï¼Œç¡®è®¤å…¶æ˜¯å¦å†™å…¥äº†æºä»£ç æ–‡ä»¶ã€‚</p>
<p>å¦‚æœæ˜¯ï¼Œè¯·ä¿®æ”¹ <a href="chromium/adding-third-party-crates/resolving-problems/../configuring-gnrt-config-toml.html"><code>gnrt_config.toml</code></a>ï¼Œå°† <code>build-script-outputs</code> æ·»åŠ åˆ° crateã€‚å¦‚æœè¿™æ˜¯ä¸€ä¸ªä¼ é€’ä¾èµ–é¡¹ï¼ˆå³ Chromium ä»£ç ä¸åº”ç›´æ¥ä¾èµ–çš„ä¾èµ–é¡¹ï¼‰ï¼Œè¿˜è¦æ·»åŠ  <code>allow-first-party-usage=false</code>ã€‚è¯¥æ–‡ä»¶ä¸­å·²ç»æä¾›äº†è‹¥å¹²ç¤ºä¾‹ï¼š</p>
<pre><code class="language-toml">[crate.unicode-linebreak]
allow-first-party-usage = false
build-script-outputs = [&quot;tables.rs&quot;]
</code></pre>
<p>ç°åœ¨ï¼Œè¯·é‡æ–°è¿è¡Œ <a href="chromium/adding-third-party-crates/resolving-problems/../generating-gn-build-rules.html"><code>gnrt.py -- gen</code></a>ï¼Œé‡æ–°ç”Ÿæˆ <code>BUILD.gn</code> æ–‡ä»¶ï¼Œä»¥é€šçŸ¥ ninja æ­¤ç‰¹å®šè¾“å‡ºæ–‡ä»¶å°†è¢«ç”¨ä½œåç»­æ„å»ºæ­¥éª¤çš„è¾“å…¥ã€‚</p>
<h1><a class="header" href="#æ„å»ºç”¨äºæ„å»º-c-æˆ–æ‰§è¡Œä»»æ„æ“ä½œçš„è„šæœ¬" id="æ„å»ºç”¨äºæ„å»º-c-æˆ–æ‰§è¡Œä»»æ„æ“ä½œçš„è„šæœ¬">æ„å»ºç”¨äºæ„å»º C++ æˆ–æ‰§è¡Œä»»æ„æ“ä½œçš„è„šæœ¬</a></h1>
<p>æœ‰äº› crate ä½¿ç”¨ <a href="https://crates.io/crates/cc"><code>cc</code></a> crate æ¥æ„å»ºå’Œå…³è” C/C++ åº“ã€‚å…¶ä»– crate ä¼šåœ¨å…¶æ„å»ºè„šæœ¬ä¸­ä½¿ç”¨ <a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> è§£æ C/C++ã€‚Chromium ç¯å¢ƒä¸­ä¸æ”¯æŒè¿›è¡Œè¿™äº›æ“ä½œï¼Œå› ä¸ºæˆ‘ä»¬çš„ gnã€ninja å’Œ LLVM æ„å»ºç³»ç»Ÿåœ¨è¡¨è¾¾æ„å»ºæ“ä½œä¹‹é—´çš„å…³ç³»æ–¹é¢å…·æœ‰éå¸¸ä¸¥æ ¼å…·ä½“çš„è¦æ±‚ã€‚</p>
<p>å› æ­¤ï¼Œæ‚¨å¯ä»¥é€‰æ‹©ï¼š</p>
<ul>
<li>é¿å¼€è¿™äº› crate</li>
<li>å¯¹ crate åº”ç”¨è¡¥ä¸ã€‚</li>
</ul>
<p>è¡¥ä¸åº”ä¿å­˜åœ¨ <code>third_party/rust/chromium_crates_io/patches/&lt;crate&gt;</code> ä¸­ï¼Œè¯·å‚é˜… <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/rust/chromium_crates_io/patches/cxx/">é¢å‘ <code>cxx</code> crate çš„è¡¥ä¸</a> ä¸­çš„ç¤ºä¾‹ã€‚æ¯å½“ <code>gnrt</code> å‡çº§è¯¥ crate æ—¶ï¼Œå°†ä¼šè‡ªåŠ¨åº”ç”¨è¡¥ä¸æ–‡ä»¶ã€‚</p>
<h1><a class="header" href="#ä¾èµ–äº-crate" id="ä¾èµ–äº-crate">ä¾èµ–äº Crate</a></h1>
<p>æ·»åŠ ç¬¬ä¸‰æ–¹ crate å¹¶ç”Ÿæˆæ„å»ºè§„åˆ™åï¼Œå°±å¯è½»æ¾ä½¿ç”¨è¯¥ crateã€‚è¯·æ‰¾åˆ° <code>rust_static_library</code> ç›®æ ‡ï¼Œå¹¶åœ¨ crate ä¸­çš„ <code>:lib</code> ç›®æ ‡ä¸Šæ·»åŠ  <code>dep</code>ã€‚</p>
<p>Specifically,</p>
<div style='width:100%; height:64px;'><style type="text/css">svg { width: 100% !important; }</style><svg xmlns="http://www.w3.org/2000/svg" width="528" height="64"><style>line, path, circle, rect, polygon{stroke:var(--fg);stroke-width:2;stroke-opacity:1;fill-opacity:1;stroke-linecap:round;stroke-linejoin:miter;}text{font-family:Iosevka Fixed, monospace;font-size:14px;}rect.backdrop{stroke:none;fill:transparent;}.broken{stroke-dasharray:8;}.filled{fill:black;}.bg_filled{fill:transparent;}.nofill{fill:transparent;}.end_marked_arrow{marker-end:url(#arrow);}.start_marked_arrow{marker-start:url(#arrow);}.end_marked_diamond{marker-end:url(#diamond);}.start_marked_diamond{marker-start:url(#diamond);}.end_marked_circle{marker-end:url(#circle);}.start_marked_circle{marker-start:url(#circle);}.end_marked_open_circle{marker-end:url(#open_circle);}.start_marked_open_circle{marker-start:url(#open_circle);}.end_marked_big_open_circle{marker-end:url(#big_open_circle);}.start_marked_big_open_circle{marker-start:url(#big_open_circle);}<!--separator--></style><defs><marker id="arrow" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,0 0,4 4,2 0,0"></polygon></marker><marker id="diamond" viewBox="-2 -2 8 8" refX="4" refY="2" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><polygon points="0,2 2,0 4,2 2,4 0,2"></polygon></marker><marker id="circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="filled"></circle></marker><marker id="open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="2" class="bg_filled"></circle></marker><marker id="big_open_circle" viewBox="0 0 8 8" refX="4" refY="4" markerWidth="7" markerHeight="7" orient="auto-start-reverse"><circle cx="4" cy="4" r="3" class="bg_filled"></circle></marker></defs><rect class="backdrop" x="0" y="0" width="528" height="64"></rect><rect x="172" y="8" width="104" height="32" class="solid nofill" rx="0"></rect><text x="186" y="28" >crate</text><text x="234" y="28" >name</text><rect x="332" y="8" width="184" height="32" class="solid nofill" rx="0"></rect><text x="346" y="28" >major</text><text x="394" y="28" >semver</text><text x="450" y="28" >version</text><text x="2" y="28" >//third_party/rust</text><text x="290" y="28" >/v</text><text x="530" y="28" >:lib</text></svg></div>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class="language-gn">rust_static_library(&quot;my_rust_lib&quot;) {
  crate_root = &quot;lib.rs&quot;
  sources = [ &quot;lib.rs&quot; ]
  deps = [ &quot;//third_party/rust/example_rust_crate/v1:lib&quot; ]
}
</code></pre>
<h1><a class="header" href="#auditing-third-party-crates" id="auditing-third-party-crates">Auditing Third Party Crates</a></h1>
<p>æ·»åŠ æ–°åº“é¡»éµå®ˆ Chromium çš„æ ‡å‡† <a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/rust.md#Third_party-review">æ”¿ç­–</a>ï¼Œå½“ç„¶ä¹Ÿè¦éµå®ˆå®‰å…¨å®¡æ ¸æ ‡å‡†ã€‚æ‚¨å¯èƒ½ä¸ä»…è¦å¼•å…¥å•ä¸ª crateï¼Œè€Œä¸”è¿˜è¦å¼•å…¥ä¼ é€’ä¾èµ–é¡¹ï¼Œå› æ­¤å¯èƒ½éœ€è¦å®¡æ ¸å¤§é‡ä»£ç ã€‚å¦ä¸€æ–¹é¢ï¼Œå®‰å…¨çš„ Rust ä»£ç å¯èƒ½äº§ç”Ÿçš„å‰¯ä½œç”¨æœ‰é™ã€‚åº”å¦‚ä½•å¯¹å…¶è¿›è¡Œå®¡æ ¸ï¼Ÿ</p>
<p>éšç€æ—¶é—´çš„æ¨ç§»ï¼ŒChromium è®¡åˆ’é€æ­¥é‡‡ç”¨ä»¥ <a href="https://mozilla.github.io/cargo-vet/">cargo vet</a> ä¸ºæ ¸å¿ƒçš„å¤„ç†æµç¨‹ã€‚</p>
<p>ä¸æ­¤åŒæ—¶ï¼Œæ¯å½“æ·»åŠ æ–°çš„ crate æ—¶ï¼Œæˆ‘ä»¬éƒ½ä¼šæ£€æŸ¥ä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>äº†è§£æ¯ä¸ª crate çš„ç”¨é€”ã€‚crate ä¹‹é—´å­˜åœ¨ä»€ä¹ˆå…³ç³»ï¼Ÿå¦‚æœæ¯ä¸ª crate çš„æ„å»ºç³»ç»Ÿéƒ½åŒ…å« <code>build.rs</code> æˆ–è¿‡ç¨‹å®ï¼Œè¯·ç¡®å®šå®ƒä»¬çš„ç”¨é€”ã€‚å®ƒä»¬èƒ½å¦ä¸ Chromium çš„æ­£å¸¸æ„å»ºæ–¹å¼ç›¸å…¼å®¹ã€‚</li>
<li>æ£€æŸ¥æ¯ä¸ª crate æ˜¯å¦å¾—åˆ°åˆç†ç»´æŠ¤ã€‚</li>
<li>ä½¿ç”¨ <code>cd third-party/rust/chromium_crates_io; cargo review</code> æ£€æŸ¥å·²çŸ¥æ¼æ´ï¼ˆé¦–å…ˆéœ€è¦è¿è¡Œ <code>cargo install cargo-audit</code>ï¼Œä»¤äººæ„å¤–çš„æ˜¯ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦ä»äº’è”ç½‘ä¸‹è½½å¤§é‡çš„ä¾èµ–é¡¹ <a href="chromium/adding-third-party-crates/../cargo.html">2</a>ï¼‰</li>
<li>ç¡®ä¿æ‰€æœ‰ <code>unsafe</code> ä»£ç éƒ½ç¬¦åˆ <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/security/rule-of-2.md#unsafe-code-in-safe-languages">ä¸¤å¤§è§„åˆ™</a> çš„è¦æ±‚</li>
<li>æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº† <code>fs</code> æˆ– <code>net</code> API</li>
<li>å°½å¯èƒ½åœ°ä»”ç»†é˜…è¯»æ‰€æœ‰ä»£ç ï¼ŒæŸ¥æ‰¾ä»»ä½•å¯èƒ½å±äºæ¶æ„æ’å…¥ï¼Œç¨æ˜¾å¼‚å¸¸çš„åœ°æ–¹ã€‚ï¼ˆä½†ç°å®ä¸­ï¼Œæ‚¨ä¸å¯èƒ½åšåˆ°ç™¾æ— é—æ¼ï¼Œå› ä¸ºä»£ç é‡é€šå¸¸å¤ªåºå¤§äº†ã€‚ï¼‰</li>
</ul>
<p>ä»¥ä¸‹åªæ˜¯ä¸€äº›æŒ‡å¯¼å»ºè®®ï¼Œè¯·ä¸ <code>security@chromium.org</code> çš„å®¡æ ¸è€…åˆç§Ÿï¼Œå…±åŒæ‰¾å‡ºèƒ½å¤Ÿç¡®ä¿ crate å®‰å…¨çš„æ­£ç¡®æ–¹æ³•ã€‚</p>
<h1><a class="header" href="#checking-crates-into-chromium-source-code" id="checking-crates-into-chromium-source-code">Checking Crates into Chromium Source Code</a></h1>
<p><code>git status</code> åº”æ˜¾ç¤ºä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li><code>//third_party/rust/chromium_crates_io</code> ä¸­çš„ crate ä»£ç </li>
<li><code>//third_party/rust/&lt;crate&gt;/&lt;version&gt;</code> ä¸­çš„å…ƒæ•°æ®ï¼ˆ<code>BUILD.gn</code> å’Œ <code>README.chromium</code>ï¼‰</li>
</ul>
<p>æ­¤å¤–ï¼Œè¯·åœ¨åé¢çš„ä½ç½®æ·»åŠ  <code>OWNERS</code> æ–‡ä»¶ã€‚</p>
<p>æ‚¨åº”å°†æ‰€æœ‰è¿™äº›å†…å®¹ï¼Œä»¥åŠå¯¹ <code>Cargo.toml</code> å’Œ <code>gnrt_config.toml</code> çš„æ›´æ”¹ä¸€èµ·æäº¤åˆ° Chromium ä»“åº“ä¸­ã€‚</p>
<p><strong>é‡è¦æç¤º</strong>ï¼šæ‚¨éœ€è¦ä½¿ç”¨ <code>git add -f</code> å‘½ä»¤ï¼Œå¦åˆ™ <code>.gitignore</code> æ–‡ä»¶å¯èƒ½ä¼šå¯¼è‡´æŸäº›æ–‡ä»¶è¢«è·³è¿‡ã€‚</p>
<p>åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæ‚¨å¯èƒ½ä¼šå‘ç°ç”±äºä½¿ç”¨äº†éåŒ…å®¹æ€§è¯­è¨€ï¼Œå¯¼è‡´æäº¤å‰æ£€æŸ¥å¤±è´¥ã€‚è¿™æ˜¯å› ä¸º Rust crate æ•°æ®å¾€å¾€åŒ…å« git åˆ†æ”¯çš„åç§°ï¼Œè€Œè®¸å¤šé¡¹ç›®ä»ç„¶åœ¨ä½¿ç”¨éåŒ…å®¹æ€§æœ¯è¯­ã€‚å› æ­¤ï¼Œæ‚¨éœ€è¦è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š</p>
<pre><code class="language-shell">infra/update_inclusive_language_presubmit_exempt_dirs.sh &gt; infra/inclusive_language_presubmit_exempt_dirs.txt
git add -p infra/inclusive_language_presubmit_exempt_dirs.txt # add whatever changes are yours
</code></pre>
<h1><a class="header" href="#åŠæ—¶æ›´æ–°-crate" id="åŠæ—¶æ›´æ–°-crate">åŠæ—¶æ›´æ–° Crate</a></h1>
<p>ä½œä¸ºä»»ä½•ç¬¬ä¸‰æ–¹ Chromium ä¾èµ–é¡¹çš„æ‰€æœ‰è€…ï¼Œæ‚¨ <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/adding_to_third_party.md#add-owners">åº”ä½¿ç”¨ä»»ä½•å®‰å…¨ä¿®å¤ç¨‹åºï¼Œç¡®ä¿è¯¥ä¾èµ–é¡¹å¤„äºæœ€æ–°çŠ¶æ€</a>ã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå°½å¿«å®ç°å¯¹ Rust crate è‡ªåŠ¨æ‰§è¡Œæ­¤æ“ä½œï¼Œä½†ç›®å‰ä»ç”±æ‚¨è´Ÿè´£æ‰§è¡Œï¼Œå°±åƒå¯¹å¾…ä»»ä½•å…¶ä»–ç¬¬ä¸‰æ–¹ä¾èµ–é¡¹ä¸€æ ·ã€‚</p>
<h1><a class="header" href="#ç»ƒä¹ " id="ç»ƒä¹ ">ç»ƒä¹ </a></h1>
<p>å°† <a href="https://crates.io/crates/uwuify">uwuify</a> æ·»åŠ åˆ° Chromiumï¼Œä»¥åœç”¨ crate çš„ <a href="https://doc.rust-lang.org/cargo/reference/features.html#the-default-feature">é»˜è®¤åŠŸèƒ½</a>ã€‚å‡è®¾è¯¥ crate ä¼šäº¤ä»˜ Chromium æ—¶è¢«ä½¿ç”¨ï¼Œä½†ä¸ä¼šç”¨äºå¤„ç†ä¸å¯ä¿¡çš„è¾“å…¥å†…å®¹ã€‚</p>
<p>ï¼ˆåœ¨ä¸‹ä¸€ä¸ªç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Chromium ä¸­çš„ uwuifyï¼›ä½†æ‚¨ä¹Ÿå¯ä»¥è·³è¿‡è¿™ä¸€æ­¥ï¼Œç°åœ¨å°±å¼€å§‹æ­¤æ“ä½œã€‚æˆ–è€…ï¼Œæ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªä½¿ç”¨ <code>uwuify</code> çš„æ–° <a href="https://source.chromium.org/chromium/chromium/src/+/main:build/rust/rust_executable.gni"><code>rust_executable</code> ç›®æ ‡</a>ã€‚</p>
<details>
<p>Students will need to download lots of transitive dependencies.</p>
<p>The total crates needed are:</p>
<ul>
<li><code>instant</code>,</li>
<li><code>lock_api</code>,</li>
<li><code>parking_lot</code>,</li>
<li><code>parking_lot_core</code>,</li>
<li><code>redox_syscall</code>,</li>
<li><code>scopeguard</code>,</li>
<li><code>smallvec</code>, and</li>
<li><code>uwuify</code>.</li>
</ul>
<p>If students are downloading even more than that, they probably forgot to turn off the default features.</p>
<p>Thanks to <a href="https://github.com/Daniel-Liu-c0deb0t">Daniel Liu</a> for this crate!</p>
</details>
<h1><a class="header" href="#bringing-it-together-----exercise" id="bringing-it-together-----exercise">Bringing It Together --- Exercise</a></h1>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæ‚¨å°†è¿ç”¨ä¹‹å‰æ‰€å­¦çš„å…¨éƒ¨çŸ¥è¯†ï¼Œæ·»åŠ ä¸€é¡¹å…¨æ–°çš„ Chromium åŠŸèƒ½ã€‚</p>
<h2><a class="header" href="#the-brief-from-product-management" id="the-brief-from-product-management">The Brief from Product Management</a></h2>
<p>åœ¨ååƒ»çš„çƒ­å¸¦é›¨æ—ä¸­ï¼Œå‘ç°ä½ç€ä¸€ç¾¤å°ç²¾çµã€‚æˆ‘ä»¬åŠ¡å¿…å°½å¿«åˆ›å»ºä¸€æ¬¾ç²¾çµç‰ˆ Chromiumï¼Œäº¤ä»˜ç»™ä»–ä»¬ã€‚</p>
<p>è¦æ±‚æ˜¯å°† Chromium çš„æ‰€æœ‰ç•Œé¢å­—ç¬¦ä¸²ç¿»è¯‘ä¸ºç²¾çµè¯­ã€‚</p>
<p>ç”±äºæ—¶é—´ç´§è¿«ï¼Œæ— æ³•ç­‰å¾…å‡†ç¡®çš„ç¿»è¯‘ã€‚ä½†å¹¸è¿çš„æ˜¯ï¼Œç²¾çµè¯­ä¸è‹±è¯­éå¸¸æ¥è¿‘ï¼Œç„¶åæˆ‘ä»¬å‘ç°æœ‰ä¸€ä¸ª Rust crate å¯ä»¥æ‰§è¡Œæ­¤ç¿»è¯‘ä»»åŠ¡ã€‚</p>
<p>äº‹å®ä¸Šï¼Œæ‚¨å·²ç» <a href="https://crates.io/crates/uwuify">åœ¨ä¸Šä¸€ä¸ªç»ƒä¹ ä¸­å¯¼å…¥äº†è¯¥ crate</a>ã€‚</p>
<p>ï¼ˆæ˜¾ç„¶ï¼Œå¯¹ Chrome è¿›è¡Œå‡†ç¡®æ°å½“çš„ç¿»è¯‘ï¼Œéœ€è¦åšåˆ°æåº¦ç»†è‡´å’Œå…¨åŠ›ä»¥èµ´ã€‚è¯·å‹¿äº¤ä»˜æ­¤äº§å“ï¼ï¼‰</p>
<h2><a class="header" href="#æ­¥éª¤" id="æ­¥éª¤">æ­¥éª¤</a></h2>
<p>ä¿®æ”¹ <code>ResourceBundle::MaybeMangleLocalizedString</code>ï¼Œåœ¨æ˜¾ç¤ºä¹‹å‰å¯¹æ‰€æœ‰å­—ç¬¦ä¸²è¿›è¡Œ uwu å¤„ç†ã€‚åœ¨è¿™ä¸ªç‰¹æ®Šçš„ Chromium ç‰ˆæœ¬ä¸­ï¼Œæ— è®º <code>mangle_localized_strings_</code> çš„è®¾ç½®å¦‚ä½•ï¼Œéƒ½åº”è¯¥å§‹ç»ˆæ‰§è¡Œæ­¤æ“ä½œã€‚</p>
<p>å¦‚æœæ‚¨æ­£ç¡®å®Œæˆäº†è¿™äº›ç»ƒä¹ ä¸­çš„æ‰€æœ‰æ“ä½œï¼Œé‚£ä¹ˆæ­å–œæ‚¨å·²ç»æˆåŠŸåˆ›å»ºäº†ä¸€æ¬¾ç²¾çµç‰ˆ Chromeï¼</p>
<img src="exercises/chromium/chwomium.png" alt="Chromium UI screenshot with uwu language">
<details>
Students will likely need some hints here. Hints include:
<ul>
<li>UTF16 ä¸ UTF8ã€‚å­¦ç”Ÿåº”æ³¨æ„ï¼ŒRust å­—ç¬¦ä¸²å§‹ç»ˆé‡‡ç”¨ UTF8 ç¼–ç ï¼Œå®ƒä»¬å¯èƒ½ä¼šå†³å®šåœ¨ C++ ç«¯ä½¿ç”¨ <code>base::UTF16ToUTF8</code> è¿›è¡Œè½¬æ¢ï¼Œç„¶åå†è¿›è¡Œåå‘è½¬æ¢ã€‚</li>
<li>å¦‚æœå­¦ç”Ÿå†³å®šåœ¨ Rust ç«¯è¿›è¡Œè½¬æ¢ï¼Œåˆ™éœ€è¦è€ƒè™‘ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf16"><code>String::from_utf16</code></a> æ–¹æ³•ï¼ŒåŒæ—¶æ³¨æ„é”™è¯¯å¤„ç†ï¼Œå¹¶ç¡®å®šå“ªäº› <a href="https://cxx.rs/binding/slice.html">CXX æ”¯æŒçš„ç±»å‹å¯ä»¥ä¼ è¾“å¤§é‡ u16s</a>ã€‚</li>
<li>å­¦ç”Ÿå¯ä»¥é€šè¿‡å¤šç§æ–¹å¼è®¾è®¡ C++/Rust è¾¹ç•Œï¼Œä¾‹å¦‚æŒ‰å€¼ä¼ é€’å’Œè¿”å›å­—ç¬¦ä¸²ï¼Œæˆ–å¯¹å­—ç¬¦ä¸²é‡‡å–å¯å˜å¼•ç”¨ã€‚å¦‚æœä½¿ç”¨å¯å˜å¼•ç”¨ï¼ŒCXX å¯èƒ½ä¼šæç¤ºå­¦ç”Ÿéœ€è¦ä½¿ç”¨ <a href="https://doc.rust-lang.org/std/pin/"><code>Pin</code></a> æ–¹æ³•ã€‚æ‚¨å¯èƒ½éœ€è¦è§£é‡Šâ€œPinâ€çš„ç”¨é€”ï¼Œä»¥åŠä¸ºä½• CXX éœ€è¦å®ƒæ¥å¯¹ C++ æ•°æ®è¿›è¡Œå¯å˜å¼•ç”¨ï¼šåŸå› æ˜¯ C++ æ•°æ®æ— æ³•åƒ Rust æ•°æ®é‚£æ ·è‡ªç”±ç§»åŠ¨ï¼Œå®ƒå¯èƒ½åŒ…å«è‡ªå¼•ç”¨æŒ‡é’ˆã€‚</li>
<li>å¯¹äºåŒ…å« <code>ResourceBundle::MaybeMangleLocalizedString</code> çš„ C++ ç›®æ ‡ï¼Œéœ€è¦ä¾èµ–äº <code>rust_static_library</code> ç›®æ ‡ã€‚å­¦ç”Ÿå¯èƒ½å·²ç»æ‰§è¡Œäº†æ­¤æ“ä½œã€‚</li>
<li><code>rust_static_library</code> ç›®æ ‡éœ€è¦ä¾èµ–äº <code>//third_party/rust/uwuify/v0_2:lib</code>ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ç»ƒä¹ è§£ç­”" id="ç»ƒä¹ è§£ç­”">ç»ƒä¹ è§£ç­”</a></h1>
<p>Solutions to the Chromium exercises can be found in <a href="https://chromium-review.googlesource.com/c/chromium/src/+/5096560">this series of CLs</a>.</p>
<h1><a class="header" href="#welcome-to-bare-metal-rust" id="welcome-to-bare-metal-rust">Welcome to Bare Metal Rust</a></h1>
<p>è¿™æ˜¯å•ç‹¬ä¸ºè£¸æœº Rust å¼€è®¾çš„è¯¾ç¨‹ï¼Œä¸ºæœŸä¸€å¤©ï¼Œä¸»è¦é¢å‘ç†Ÿæ‚‰ Rust åŸºç¡€çŸ¥è¯†çš„äººå‘˜ï¼ˆä¾‹å¦‚å·²å­¦å®Œ Comprehensive Rustï¼‰ï¼Œæœ€å¥½ä¹Ÿæœ‰ä¸€äº›ä½¿ç”¨å…¶ä»–è¯­è¨€ï¼ˆä¾‹å¦‚ Cï¼‰è¿›è¡Œè£¸æœºç¼–ç¨‹çš„ç»éªŒã€‚</p>
<p>ä»Šå¤©ï¼Œæˆ‘ä»¬å°†æ¢è®¨ <code>bare-metal</code> Rustï¼šå³åœ¨æ²¡æœ‰æ“ä½œç³»ç»Ÿæ”¯æŒçš„æƒ…å†µä¸‹è¿è¡Œ Rust ä»£ç ã€‚è¯¥éƒ¨åˆ†ä¸»è¦åˆ†ä¸ºä»¥ä¸‹å†…å®¹ï¼š</p>
<ul>
<li>ä»€ä¹ˆæ˜¯ <code>no_std</code> Rustï¼Ÿ</li>
<li>ç¼–å†™å¾®æ§åˆ¶å™¨å›ºä»¶ã€‚</li>
<li>ä¸ºåº”ç”¨å¤„ç†å™¨ç¼–å†™å¼•å¯¼åŠ è½½ç¨‹åº / å†…æ ¸ä»£ç ã€‚</li>
<li>æœ‰åŠ©äºè£¸æœº Rust å¼€å‘çš„ä¸€äº›å®ç”¨ crateã€‚</li>
</ul>
<p>For the microcontroller part of the course we will use the <a href="https://microbit.org/">BBC micro:bit</a> v2 as an example. It's a <a href="https://tech.microbit.org/hardware/">development board</a> based on the Nordic nRF52833 microcontroller with some LEDs and buttons, an I2C-connected accelerometer and compass, and an on-board SWD debugger.</p>
<p>é¦–å…ˆï¼Œè¯·å®‰è£…æˆ‘ä»¬ç¨åéœ€è¦ç”¨åˆ°çš„ä¸€äº›å·¥å…·ã€‚åœ¨ gLinux æˆ– Debian ä¸Šï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">sudo apt install gdb-multiarch libudev-dev picocom pkg-config qemu-system-arm
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<p>ç„¶åï¼Œå‘ <code>plugdev</code> ç»„ä¸­çš„ç”¨æˆ·æˆäºˆ micro:bit ç¼–ç¨‹å™¨çš„è®¿é—®æƒé™ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">echo 'SUBSYSTEM==&quot;hidraw&quot;, ATTRS{idVendor}==&quot;0d28&quot;, MODE=&quot;0660&quot;, GROUP=&quot;logindev&quot;, TAG+=&quot;uaccess&quot;' |\
  sudo tee /etc/udev/rules.d/50-microbit.rules
sudo udevadm control --reload-rules
</code></pre>
<p>åœ¨ MacOS ä¸Šï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-bash">xcode-select --install
brew install gdb picocom qemu
rustup update
rustup target add aarch64-unknown-none thumbv7em-none-eabihf
rustup component add llvm-tools-preview
cargo install cargo-binutils
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh
</code></pre>
<h1><a class="header" href="#no_std" id="no_std"><code>no_std</code></a></h1>
<table>
<tr>
<th>
<p><code>core</code></p>
</th>
<th>
<p><code>alloc</code></p>
</th>
<th>
<p><code>std</code></p>
</th>
</tr>
<tr valign="top">
<td>
<ul>
<li>Sliceã€<code>&amp;str</code>ã€<code>CStr</code></li>
<li><code>NonZeroU8</code>...</li>
<li><code>Option</code>ã€<code>Result</code></li>
<li><code>Display</code>ã€<code>Debug</code>ã€<code>write!</code>...</li>
<li><code>Iterator</code></li>
<li><code>Error</code></li>
<li><code>panic!</code>ã€<code>assert_eq!</code>...</li>
<li><code>NonNull</code> å’Œæ‰€æœ‰å¸¸è§çš„æŒ‡é’ˆç›¸å…³å‡½æ•°</li>
<li><code>Future</code> å’Œ <code>async</code>/<code>await</code></li>
<li><code>fence</code>ã€<code>AtomicBool</code>ã€<code>AtomicPtr</code>ã€<code>AtomicU32</code>...</li>
<li><code>Duration</code></li>
</ul>
</td>
<td>
<ul>
<li><code>Box</code>ã€<code>Cow</code>ã€<code>Arc</code>ã€<code>Rc</code></li>
<li><code>Vec</code>ã€<code>BinaryHeap</code>ã€<code>BtreeMap</code>ã€<code>LinkedList</code>ã€<code>VecDeque</code></li>
<li><code>String</code>ã€<code>CString</code>ã€<code>format!</code></li>
</ul>
</td>
<td>
<ul>
<li><code>HashMap</code></li>
<li><code>Mutex</code>ã€<code>Condvar</code>ã€<code>Barrier</code>ã€<code>Once</code>ã€<code>RwLock</code>ã€<code>mpsc</code></li>
<li><code>File</code> å’Œ <code>fs</code> çš„å…¶ä½™éƒ¨åˆ†</li>
<li><code>println!</code>ã€<code>Read</code>ã€<code>Write</code>ã€<code>Stdin</code>ã€<code>Stdout</code> ä»¥åŠ <code>io</code> çš„å…¶ä½™éƒ¨åˆ†</li>
<li><code>Path</code>, <code>OsString</code></li>
<li><code>net</code></li>
<li><code>Command</code>ã€<code>Child</code>ã€<code>ExitCode</code></li>
<li><code>spawn</code>ã€<code>sleep</code> å’Œ <code>thread</code> çš„å…¶ä½™éƒ¨åˆ†</li>
<li><code>SystemTime</code>ã€<code>Instant</code></li>
</ul>
</td>
</tr>
</table>
<details>
<ul>
<li><code>HashMap</code> ä¾èµ–äº RNGã€‚</li>
<li><code>std</code> ä¼šé‡æ–°å¯¼å‡º <code>core</code> å’Œ <code>alloc</code> çš„å†…å®¹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#æå°çš„-no_std-ç¨‹åº" id="æå°çš„-no_std-ç¨‹åº">æå°çš„ <code>no_std</code> ç¨‹åº</a></h1>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>è¿™å°†ç¼–è¯‘ä¸ºç©ºäºŒè¿›åˆ¶æ–‡ä»¶ã€‚</li>
<li><code>std</code> æä¾›äº†ä¸€ä¸ª panic å¤„ç†ç¨‹åºï¼›å¦‚æœæ²¡æœ‰å®ƒï¼Œæˆ‘ä»¬å°±å¿…é¡»è‡ªè¡Œæä¾›ã€‚</li>
<li>å…¶ä»– crateï¼ˆä¾‹å¦‚ <code>panic-halt</code>ï¼‰ä¹Ÿå¯ä»¥æä¾›è¯¥å¤„ç†ç¨‹åºã€‚</li>
<li>æ ¹æ®ç›®æ ‡ä¸åŒï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨ <code>panic = &quot;abort&quot;</code> è¿›è¡Œç¼–è¯‘ï¼Œä»¥é¿å…å‡ºç°ä¸ <code>eh_personality</code> ç›¸å…³çš„é”™è¯¯ã€‚</li>
<li>è¯·æ³¨æ„ï¼Œæœªæä¾› <code>main</code> å‡½æ•°æˆ–ä»»ä½•å…¶ä»–å…¥å£ç‚¹ï¼›æ‚¨å¯ä»¥è‡ªè¡Œå®šä¹‰å…¥å£ç‚¹ã€‚é€šå¸¸éœ€è¦ä½¿ç”¨é“¾æ¥å™¨è„šæœ¬å’Œä¸€äº›æ±‡ç¼–ä»£ç è¿›è¡Œè®¾ç½®å·¥ä½œï¼Œä»¥ä¾¿ Rust ä»£ç èƒ½å¤Ÿé¡ºåˆ©è¿è¡Œã€‚</li>
</ul>
</details>
<h1><a class="header" href="#alloc" id="alloc"><code>alloc</code></a></h1>
<p>å¦‚éœ€ä½¿ç”¨ <code>alloc</code>ï¼Œæ‚¨å¿…é¡»å®ç° <a href="https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html">å…¨å±€ï¼ˆå †ï¼‰åˆ†é…å™¨</a>ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate alloc;
extern crate panic_halt as _;

use alloc::string::ToString;
use alloc::vec::Vec;
use buddy_system_allocator::LockedHeap;

#[global_allocator]
static HEAP_ALLOCATOR: LockedHeap&lt;32&gt; = LockedHeap::&lt;32&gt;::new();

static mut HEAP: [u8; 65536] = [0; 65536];

pub fn entry() {
    // SAFETY: `HEAP` is only used here and `entry` is only called once.
    unsafe {
        // Give the allocator some memory to allocate.
        HEAP_ALLOCATOR.lock().init(HEAP.as_mut_ptr() as usize, HEAP.len());
    }

    // Now we can do things that require heap allocation.
    let mut v = Vec::new();
    v.push(&quot;A string&quot;.to_string());
}
</code></pre></pre>
<details>
<ul>
<li><code>buddy_system_allocator</code> æ˜¯ç¬¬ä¸‰æ–¹ crateï¼Œç”¨äºå®ç°åŸºæœ¬ä¼™ä¼´ç³»ç»Ÿåˆ†é…å™¨ã€‚è¿˜å¯ä»¥ä½¿ç”¨å…¶ä»– crateï¼Œæˆ–è€…è‡ªè¡Œç¼–å†™ crateï¼Œæˆ–è€…æ¥å…¥ç°æœ‰åˆ†é…å™¨ã€‚</li>
<li><code>LockedHeap</code> çš„å¸¸é‡å‚æ•°æ˜¯åˆ†é…å™¨çš„æœ€å¤§é˜¶æ•°ï¼›å³åœ¨æœ¬ä¾‹ä¸­ï¼Œå®ƒå¯ä»¥æœ€å¤šåˆ†é… 2**32 å­—èŠ‚å¤§å°çš„åŒºåŸŸã€‚</li>
<li>å¦‚æœä¾èµ–é¡¹æ ‘ä¸­çš„æ‰€æœ‰ crate éƒ½ä¾èµ–äº <code>alloc</code>ï¼Œåˆ™æ‚¨å¿…é¡»åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­æ˜ç¡®å®šä¹‰ä¸€ä¸ªå…¨å±€åˆ†é…å™¨ã€‚é€šå¸¸ï¼Œåœ¨é¡¶çº§äºŒè¿›åˆ¶ crate ä¸­å®Œæˆæ­¤æ“ä½œã€‚</li>
<li>ä¸ºäº†ç¡®ä¿èƒ½å¤ŸæˆåŠŸå…³è” <code>panic_halt</code> crateï¼Œä»¥ä¾¿æˆ‘ä»¬è·å–å…¶ panic å¤„ç†ç¨‹åºï¼Œå¿…é¡»ä½¿ç”¨ <code>extern crate panic_halt as _</code> æ–¹æ³•ã€‚</li>
<li>æˆ‘ä»¬å¯ä»¥æ„å»ºè¯¥ç¤ºä¾‹ï¼Œä½†ç”±äºæ²¡æœ‰å…¥å£ç‚¹ï¼Œæ— æ³•è¿è¡Œã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å¾®æ§åˆ¶å™¨" id="å¾®æ§åˆ¶å™¨">å¾®æ§åˆ¶å™¨</a></h1>
<p><code>cortex_m_rt</code> crate æä¾›é’ˆå¯¹ Cortex M å¾®æ§åˆ¶å™¨çš„é‡ç½®å¤„ç†ç¨‹åºï¼ˆä»¥åŠå…¶ä»–å†…å®¹ï¼‰ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {}
}
</code></pre></pre>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬çœ‹çœ‹éšç€æŠ½è±¡å±‚çº§çš„ä¸æ–­æå‡ï¼Œè¯¥å¦‚ä½•è®¿é—®å¤–å›´è®¾å¤‡ã€‚</p>
<details>
<ul>
<li><code>cortex_m_rt::entry</code> å®è¦æ±‚å‡½æ•°çš„ç±»å‹ä¸º <code>fn() -&gt; !</code>ï¼Œå› ä¸ºè¿”å›é‡ç½®å¤„ç†ç¨‹åºä¼šæ¯«æ— æ„ä¹‰ã€‚</li>
<li>ä½¿ç”¨ <code>cargo embed --bin minimum</code> è¿è¡Œè¯¥ç¤ºä¾‹</li>
</ul>
</details>
<h1><a class="header" href="#åŸå§‹-mmio" id="åŸå§‹-mmio">åŸå§‹ MMIO</a></h1>
<p>å¤§å¤šæ•°å¾®æ§åˆ¶å™¨é€šè¿‡å†…å­˜æ˜ å°„ IO è®¿é—®å¤–å›´è®¾å¤‡ã€‚ç°åœ¨è¯•ç€å¼€å¯ micro:bit ä¸Šçš„ LED æŒ‡ç¤ºç¯ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

mod interrupts;

use core::mem::size_of;
use cortex_m_rt::entry;

/// GPIO port 0 peripheral address
const GPIO_P0: usize = 0x5000_0000;

// GPIO peripheral offsets
const PIN_CNF: usize = 0x700;
const OUTSET: usize = 0x508;
const OUTCLR: usize = 0x50c;

// PIN_CNF fields
const DIR_OUTPUT: u32 = 0x1;
const INPUT_DISCONNECT: u32 = 0x1 &lt;&lt; 1;
const PULL_DISABLED: u32 = 0x0 &lt;&lt; 2;
const DRIVE_S0S1: u32 = 0x0 &lt;&lt; 8;
const SENSE_DISABLED: u32 = 0x0 &lt;&lt; 16;

#[entry]
fn main() -&gt; ! {
    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let pin_cnf_21 = (GPIO_P0 + PIN_CNF + 21 * size_of::&lt;u32&gt;()) as *mut u32;
    let pin_cnf_28 = (GPIO_P0 + PIN_CNF + 28 * size_of::&lt;u32&gt;()) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        pin_cnf_21.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
        pin_cnf_28.write_volatile(
            DIR_OUTPUT
                | INPUT_DISCONNECT
                | PULL_DISABLED
                | DRIVE_S0S1
                | SENSE_DISABLED,
        );
    }

    // Set pin 28 low and pin 21 high to turn the LED on.
    let gpio0_outset = (GPIO_P0 + OUTSET) as *mut u32;
    let gpio0_outclr = (GPIO_P0 + OUTCLR) as *mut u32;
    // SAFETY: The pointers are to valid peripheral control registers, and no
    // aliases exist.
    unsafe {
        gpio0_outclr.write_volatile(1 &lt;&lt; 28);
        gpio0_outset.write_volatile(1 &lt;&lt; 21);
    }

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>å°† GPIO 0 çš„å¼•è„š 21 è¿æ¥åˆ° LED çŸ©é˜µçš„ç¬¬ä¸€åˆ—ï¼Œå°†å¼•è„š 28 è¿æ¥åˆ°ç¬¬ä¸€è¡Œã€‚</li>
</ul>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œè¯¥ç¤ºä¾‹ï¼š</p>
<pre><code class="language-sh">cargo embed --bin mmio
</code></pre>
</details>
<h1><a class="header" href="#å¤–å›´è®¾å¤‡è®¿é—®-crate" id="å¤–å›´è®¾å¤‡è®¿é—®-crate">å¤–å›´è®¾å¤‡è®¿é—® crate</a></h1>
<p><a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> ä½¿ç”¨ <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">CMSIS-SVD</a> æ–‡ä»¶ä¸ºå†…å­˜æ˜ å°„å¤–å›´è®¾å¤‡ç”Ÿæˆäº†å¤§éƒ¨åˆ†å®‰å…¨çš„ Rust å°è£…å®¹å™¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use nrf52833_pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p.P0;

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    gpio0.pin_cnf[21].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });
    gpio0.pin_cnf[28].write(|w| {
        w.dir().output();
        w.input().disconnect();
        w.pull().disabled();
        w.drive().s0s1();
        w.sense().disabled();
        w
    });

    // Set pin 28 low and pin 21 high to turn the LED on.
    gpio0.outclr.write(|w| w.pin28().clear());
    gpio0.outset.write(|w| w.pin21().set());

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>SVDï¼ˆç³»ç»Ÿè§†å›¾æè¿°ï¼‰æ–‡ä»¶é€šå¸¸æ˜¯ç”±èŠ¯ç‰‡ä¾›åº”å•†æä¾›çš„ XML æ–‡ä»¶ï¼Œç”¨äºæè¿°è®¾å¤‡çš„å†…å­˜æ˜ å°„ã€‚
<ul>
<li>è¿™äº›æ–‡ä»¶æŒ‰ç…§å¤–å›´è®¾å¤‡ã€å¯„å­˜å™¨ã€å­—æ®µå’Œå€¼è¿›è¡Œç»„ç»‡åˆ†ç±»ï¼Œå…¶ä¸­åŒ…å«åç§°ã€å†…å®¹æè¿°ã€åœ°å€ç­‰ä¿¡æ¯ã€‚</li>
<li>ç”±äº SVD æ–‡ä»¶å¸¸å¸¸å­˜åœ¨é”™è¯¯å’Œä¸å®Œæ•´çš„æƒ…å†µï¼Œå› æ­¤æœ‰è®¸å¤šé¡¹ç›®ä¼šä¿®å¤è¿™äº›é”™è¯¯ï¼Œè¡¥å……ç¼ºå¤±çš„ç›¸å…³ä¿¡æ¯ï¼Œå¹¶å‘å¸ƒç”Ÿæˆçš„ crateã€‚</li>
</ul>
</li>
<li><code>cortex-m-rt</code> æä¾›çŸ¢é‡è¡¨ä»¥åŠå…¶ä»–åŠŸèƒ½ã€‚</li>
<li>å¦‚æœæ‚¨ä½¿ç”¨ <code>cargo install cargo-binutils</code>ï¼Œåˆ™å¯ä»¥è¿è¡Œ <code>cargo objdump --bin pac -- -d --no-show-raw-insn</code>ï¼ŒæŸ¥çœ‹ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</li>
</ul>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œè¯¥ç¤ºä¾‹ï¼š</p>
<pre><code class="language-sh">cargo embed --bin pac
</code></pre>
</details>
<h1><a class="header" href="#hal-crates" id="hal-crates">HAL crates</a></h1>
<p>è®¸å¤šå¾®æ§åˆ¶å™¨çš„ <a href="https://github.com/rust-embedded/awesome-embedded-rust#hal-implementation-crates">HAL crate</a> ä¸ºå„ç§å¤–å›´è®¾å¤‡æä¾›äº†å°è£…å®¹å™¨ã€‚é€šå¸¸ï¼Œè¿™äº›å°è£…å®¹å™¨å¯ä»¥å®ç° <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> ä¸­çš„å„ç§ traitã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use nrf52833_hal::gpio::{p0, Level};
use nrf52833_hal::pac::Peripherals;

#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();

    // Create HAL wrapper for GPIO port 0.
    let gpio0 = p0::Parts::new(p.P0);

    // Configure GPIO 0 pins 21 and 28 as push-pull outputs.
    let mut col1 = gpio0.p0_28.into_push_pull_output(Level::High);
    let mut row1 = gpio0.p0_21.into_push_pull_output(Level::Low);

    // Set pin 28 low and pin 21 high to turn the LED on.
    col1.set_low().unwrap();
    row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li><code>set_low</code> å’Œ <code>set_high</code> æ˜¯ <code>embedded_hal</code> <code>OutputPin</code> trait ä¸Šçš„æ–¹æ³•ã€‚</li>
<li>HAL crate è¢«å¹¿æ³›ç”¨äºè®¸å¤š Cortex-M å’Œ RISC-V è®¾å¤‡ï¼ŒåŒ…æ‹¬å„ç§ STM32ã€GD32ã€nRFã€NXPã€MSP430ã€AVR å’Œ PIC å¾®æ§åˆ¶å™¨ã€‚</li>
</ul>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œè¯¥ç¤ºä¾‹ï¼š</p>
<pre><code class="language-sh">cargo embed --bin hal
</code></pre>
</details>
<h1><a class="header" href="#board-support-crates" id="board-support-crates">Board support crates</a></h1>
<p>ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œæ¿çº§æ”¯æŒ crate ä¸ºç‰¹å®šå¼€å‘æ¿æä¾›äº†æ›´é«˜çº§åˆ«çš„å°è£…åŠŸèƒ½ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use cortex_m_rt::entry;
use embedded_hal::digital::OutputPin;
use microbit::Board;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    board.display_pins.col1.set_low().unwrap();
    board.display_pins.row1.set_high().unwrap();

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>åœ¨æœ¬ä¾‹ä¸­ï¼Œè¯¥æ¿çº§æ”¯æŒ crate ä»…æä¾›äº†ä¸€äº›å®ç”¨çš„åç§°å’Œåˆå§‹åŒ–åŠŸèƒ½ã€‚</li>
<li>é™¤å¾®æ§åˆ¶å™¨ä»¥å¤–ï¼Œè¯¥ crate è¿˜åŒ…å«ä¸€äº›å¯ç”¨äºæ¿è½½è®¾å¤‡çš„é©±åŠ¨ç¨‹åºã€‚
<ul>
<li><code>microbit-v2</code> åŒ…å«ä¸€ä¸ªå¯ç”¨äº LED çŸ©é˜µçš„ç®€å•é©±åŠ¨ç¨‹åºã€‚</li>
</ul>
</li>
</ul>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œè¯¥ç¤ºä¾‹ï¼š</p>
<pre><code class="language-sh">cargo embed --bin board_support
</code></pre>
</details>
<h1><a class="header" href="#ç±»å‹çŠ¶æ€æ¨¡å¼" id="ç±»å‹çŠ¶æ€æ¨¡å¼">ç±»å‹çŠ¶æ€æ¨¡å¼</a></h1>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[entry]
fn main() -&gt; ! {
    let p = Peripherals::take().unwrap();
    let gpio0 = p0::Parts::new(p.P0);

    let pin: P0_01&lt;Disconnected&gt; = gpio0.p0_01;

    // let gpio0_01_again = gpio0.p0_01; // Error, moved.
    let mut pin_input: P0_01&lt;Input&lt;Floating&gt;&gt; = pin.into_floating_input();
    if pin_input.is_high().unwrap() {
        // ...
    }
    let mut pin_output: P0_01&lt;Output&lt;OpenDrain&gt;&gt; = pin_input
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    pin_output.set_high().unwrap();
    // pin_input.is_high(); // Error, moved.

    let _pin2: P0_02&lt;Output&lt;OpenDrain&gt;&gt; = gpio0
        .p0_02
        .into_open_drain_output(OpenDrainConfig::Disconnect0Standard1, Level::Low);
    let _pin3: P0_03&lt;Output&lt;PushPull&gt;&gt; =
        gpio0.p0_03.into_push_pull_output(Level::Low);

    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>å¼•è„šæ— æ³•å®ç° <code>Copy</code> æˆ– <code>Clone</code>ï¼Œå› æ­¤ï¼Œæ¯ä¸ªå¼•è„šåªèƒ½å­˜åœ¨ä¸€ä¸ªå®ä¾‹ã€‚ä¸€æ—¦æŸä¸ªå¼•è„šä»ç«¯å£ç»“æ„ä½“ç§»å‡ºï¼Œä»»ä½•äººéƒ½æ— æ³•å†ä½¿ç”¨å®ƒã€‚</li>
<li>æ›´æ”¹å¼•è„šçš„é…ç½®ä¼šä½¿æ—§çš„å¼•è„šå®ä¾‹å¤±æ•ˆï¼Œå› æ­¤æ‚¨æ— æ³•å†ç»§ç»­ä½¿ç”¨æ—§å®ä¾‹ã€‚</li>
<li>å€¼çš„ç±»å‹è¡¨ç¤ºå…¶æ‰€å¤„çŠ¶æ€ï¼šä¾‹å¦‚ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œè¡¨ç¤º GPIO å¼•è„šçš„é…ç½®çŠ¶æ€ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯å°†çŠ¶æ€æœºç¼–ç æˆç±»å‹ç³»ç»Ÿï¼Œå¹¶ç¡®ä¿åœ¨æœªæ­£ç¡®å®Œæˆå¼•è„šé…ç½®ä¹‹å‰ï¼Œä¸ä¼šå°è¯•ä»¥æŸç§æ–¹å¼ä½¿ç”¨å¼•è„šã€‚ç¼–è¯‘æ—¶æ•è·äº†éæ³•çŠ¶æ€è½¬æ¢ã€‚</li>
<li>æ‚¨å¯ä»¥åœ¨è¾“å…¥å¼•è„šä¸Šè°ƒç”¨ <code>is_high</code>ï¼Œåœ¨è¾“å‡ºå¼•è„šä¸Šè°ƒç”¨ <code>set_high</code>ï¼Œåä¹‹åˆ™ä¸è¡Œã€‚</li>
<li>è®¸å¤š HAL crate éƒ½éµå¾ªæ­¤æ¨¡å¼ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#embedded-hal" id="embedded-hal"><code>embedded-hal</code></a></h1>
<p>The <a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> crate provides a number of traits covering common microcontroller peripherals:</p>
<ul>
<li>GPIO</li>
<li>PWM</li>
<li>Delay timers</li>
<li>I2C and SPI buses and devices</li>
</ul>
<p>Similar traits for byte streams (e.g. UARTs), CAN buses and RNGs and broken out into <a href="https://crates.io/crates/embedded-io"><code>embedded-io</code></a>, <a href="https://crates.io/crates/embedded-can"><code>embedded-can</code></a> and <a href="https://crates.io/crates/rand_core"><code>rand_core</code></a> respectively.</p>
<p>Other crates then implement <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">drivers</a> in terms of these traits, e.g. an accelerometer driver might need an I2C or SPI device instance.</p>
<details>
<ul>
<li>The traits cover using the peripherals but not initialising or configuring them, as initialisation and configuration is usually highly platform-specific.</li>
<li>è¿˜æœ‰é€‚ç”¨äºè®¸å¤šå¾®æ§åˆ¶å™¨ä»¥åŠå…¶ä»–å¹³å°ï¼ˆä¾‹å¦‚ Raspberry Pi ä¸Šçš„ Linuxï¼‰çš„å®ç°ã€‚</li>
<li><a href="https://crates.io/crates/embedded-hal-async"><code>embedded-hal-async</code></a> provides async versions of the traits.</li>
<li><a href="https://crates.io/crates/embedded-hal-nb"><code>embedded-hal-nb</code></a> provides another approach to non-blocking I/O, based on the <a href="https://crates.io/crates/nb"><code>nb</code></a> crate.</li>
</ul>
</details>
<h1><a class="header" href="#probe-rs-å’Œ-cargo-embed" id="probe-rs-å’Œ-cargo-embed"><code>probe-rs</code> å’Œ <code>cargo-embed</code></a></h1>
<p><a href="https://probe.rs/">probe-rs</a> æ˜¯ä¸€ä¸ªæ–¹ä¾¿çš„åµŒå…¥å¼è°ƒè¯•å·¥å…·é›†ï¼Œè·Ÿ OpenOCD è¾ƒä¸ºç›¸ä¼¼ï¼Œä½†é›†æˆåº¦æ›´é«˜ã€‚</p>
<ul>
<li>é€šè¿‡ CMSIS-DAPã€ST-Link å’Œ J-Link æ¢é’ˆå®ç° SWDï¼ˆä¸²è¡Œè°ƒè¯•ï¼‰å’Œ JTAG</li>
<li>GDB æ¡©å’Œ Microsoft DAPï¼ˆè°ƒè¯•é€‚é…å™¨åè®®ï¼‰æœåŠ¡å™¨</li>
<li>Cargo integration</li>
</ul>
<p><code>cargo-embed</code> æ˜¯ä¸€ä¸ª cargo å­å‘½ä»¤ï¼Œç”¨äºæ„å»ºå’Œåˆ·å†™äºŒè¿›åˆ¶æ–‡ä»¶ã€è®°å½• RTTï¼ˆå®æ—¶ä¼ è¾“ï¼‰è¾“å‡ºä»¥åŠè¿æ¥ GDBã€‚æ‚¨å¯é€šè¿‡é¡¹ç›®ç›®å½•ä¸­çš„ <code>Embed.toml</code> æ–‡ä»¶å¯¹å…¶è¿›è¡Œé…ç½®ã€‚</p>
<details>
<ul>
<li><a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html">CMSIS-DAP</a> æ˜¯ä¸€é¡¹åŸºäº USB çš„ Arm æ ‡å‡†åè®®ï¼Œä½¿å¾—ç”µè·¯å†…è°ƒè¯•ç¨‹åºèƒ½å¤Ÿæ¥å…¥å„ç§ Arm Cortex å¤„ç†å™¨çš„ CoreSight è°ƒè¯•è®¿é—®ç«¯å£ã€‚BBC micro:bit çš„æ¿è½½è°ƒè¯•ç¨‹åºæ‰€ä½¿ç”¨çš„ä¾¿æ˜¯æ­¤åè®®ã€‚</li>
<li>ST-Link å±äº ST Microelectronics äº§å“ç³»åˆ—ï¼ŒJ-Link æ˜¯ SEGGER ç³»åˆ—ã€‚</li>
<li>è°ƒè¯•è®¿é—®ç«¯å£é€šå¸¸ä¸º 5 é’ˆ JTAG æ¥å£æˆ– 2 é’ˆä¸²è¡Œçº¿è°ƒè¯•æ¥å£ã€‚</li>
<li>probe-rs æ˜¯ä¸€ä¸ªåº“ï¼Œå¦‚æœ‰éœ€è¦ï¼Œå¯ä»¥å°†å…¶é›†æˆåˆ°æ‚¨çš„å·¥å…·ä¸­ã€‚</li>
<li>å€ŸåŠ© <a href="https://microsoft.github.io/debug-adapter-protocol/">Microsoft è°ƒè¯•é€‚é…å™¨åè®®</a>ï¼ŒVSCode å’Œå…¶ä»– IDE å¯ä»¥è°ƒè¯•ä»»ä½•å—æ”¯æŒçš„å¾®æ§åˆ¶å™¨ä¸Šè¿è¡Œçš„ä»£ç ã€‚</li>
<li>cargo-embed æ˜¯ä½¿ç”¨ probe-rs åº“æ„å»ºçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</li>
<li>RTTï¼ˆå®æ—¶ä¼ è¾“ï¼‰æ˜¯ä¸€ç§é€šè¿‡å¤šä¸ªç¯å½¢ç¼“å†²åŒºï¼Œåœ¨è°ƒè¯•ä¸»æœºå’Œç›®æ ‡ä¹‹é—´è¿›è¡Œæ•°æ®ä¼ è¾“çš„æœºåˆ¶ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#è°ƒè¯•" id="è°ƒè¯•">è°ƒè¯•</a></h1>
<p><em>Embed.toml</em>:</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true
</code></pre>
<p>åœ¨ <code>src/bare-metal/microcontrollers/examples/</code> ç›®å½•ä¸‹æŸä¸ªç»ˆç«¯ä¸­ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">cargo embed --bin board_support debug
</code></pre>
<p>åœ¨åŒä¸€ç›®å½•ä¸‹çš„å¦ä¸€ä¸ªç»ˆç«¯ä¸­ï¼š</p>
<p>åœ¨ gLinux æˆ– Debian ä¸Šï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">gdb-multiarch target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<p>åœ¨ MacOS ä¸Šï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">arm-none-eabi-gdb target/thumbv7em-none-eabihf/debug/board_support --eval-command=&quot;target remote :1337&quot;
</code></pre>
<details>
<p>åœ¨ GDB ä¸­ï¼Œè¯·å°è¯•è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-gdb">b src/bin/board_support.rs:29
b src/bin/board_support.rs:30
b src/bin/board_support.rs:32
c
c
c
</code></pre>
</details>
<h1><a class="header" href="#other-projects" id="other-projects">Other projects</a></h1>
<ul>
<li><a href="https://rtic.rs/">RTIC</a>
<ul>
<li>&quot;Real-Time Interrupt-driven Concurrency&quot;.</li>
<li>Shared resource management, message passing, task scheduling, timer queue.</li>
</ul>
</li>
<li><a href="https://embassy.dev/">Embassy</a>
<ul>
<li><code>async</code> executors with priorities, timers, networking, USB.</li>
</ul>
</li>
<li><a href="https://www.tockos.org/documentation/getting-started">TockOS</a>
<ul>
<li>Security-focused RTOS with preemptive scheduling and Memory Protection Unit support.</li>
</ul>
</li>
<li><a href="https://hubris.oxide.computer/">Hubris</a>
<ul>
<li>Microkernel RTOS from Oxide Computer Company with memory protection, unprivileged drivers, IPC.</li>
</ul>
</li>
<li><a href="https://github.com/lobaro/FreeRTOS-rust">Bindings for FreeRTOS</a>.</li>
</ul>
<p>æœ‰äº›å¹³å°å¯ä»¥å®ç° <code>std</code>ï¼Œä¾‹å¦‚ <a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">esp-idf</a>ã€‚</p>
<details>
<ul>
<li>RTIC å¯è¢«è§†ä¸º RTOS æˆ–å¹¶å‘æ¡†æ¶ï¼Œ
<ul>
<li>ä½†ä¸åŒ…å«ä»»ä½• HALã€‚</li>
<li>å®ƒä½¿ç”¨ Cortex-M NVICï¼ˆåµŒå¥—è™šæ‹Ÿä¸­æ–­æ§åˆ¶å™¨ï¼‰è¿›è¡Œè°ƒåº¦ï¼Œè€Œä¸æ˜¯é€‰ç”¨é€‚åˆçš„å†…æ ¸ã€‚</li>
<li>ä»…é™ Cortex-Mã€‚</li>
</ul>
</li>
<li>Google åœ¨ Haven å¾®æ§åˆ¶å™¨ä¸Šä½¿ç”¨ TockOS ä½œä¸º Titan å®‰å…¨å¯†é’¥çš„æ“ä½œç³»ç»Ÿã€‚</li>
<li>FreeRTOS ä¸»è¦ä½¿ç”¨ C è¯­è¨€ç¼–å†™ï¼Œä½†ä¹Ÿæä¾›äº†ä¸“ç”¨äºç¼–å†™åº”ç”¨çš„ Rust ç»‘å®šã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ä¹ é¢˜" id="ä¹ é¢˜">ä¹ é¢˜</a></h1>
<p>æˆ‘ä»¬å°†ä» I2C ç½—ç›˜è¯»å–æ–¹å‘ï¼Œå¹¶å°†è¯»æ•°è®°å½•åˆ°ä¸²è¡Œç«¯å£ã€‚</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-morning.html">solutions</a> provided.</p>
</details>
<h1><a class="header" href="#ç½—ç›˜" id="ç½—ç›˜">ç½—ç›˜</a></h1>
<p>æˆ‘ä»¬å°†ä» I2C ç½—ç›˜è¯»å–æ–¹å‘ï¼Œå¹¶å°†è¯»æ•°è®°å½•åˆ°ä¸²è¡Œç«¯å£ã€‚å¦‚æœ‰æ—¶é—´ï¼Œè¯·å°è¯•é€šè¿‡ LED ç¯äº®èµ·çš„æ–¹å¼ï¼Œæˆ–è€…ä½¿ç”¨æŒ‰é’®æ¥æ˜¾ç¤ºæ–¹å‘ã€‚</p>
<p>æç¤ºï¼š</p>
<ul>
<li>è¯·å‚é˜… <a href="https://docs.rs/lsm303agr/latest/lsm303agr/"><code>lsm303agr</code></a> å’Œ <a href="https://docs.rs/microbit-v2/latest/microbit/"><code>microbit-v2</code></a> crateï¼Œä»¥åŠ <a href="https://tech.microbit.org/hardware/">micro:bit ç¡¬ä»¶</a> ç›¸å…³æ–‡æ¡£ã€‚</li>
<li>LSM303AGR æƒ¯æ€§æµ‹é‡è£…ç½®ä¸å†…éƒ¨ I2C æ€»çº¿ç›¸è¿æ¥ã€‚</li>
<li>TWI æ˜¯ I2C çš„åˆ«ç§°ï¼Œå› æ­¤ I2C ä¸»å¤–å›´è®¾å¤‡ç§°ä¸º TWIMã€‚</li>
<li>The LSM303AGR driver needs something implementing the <code>embedded_hal::i2c::I2c</code> trait. The <a href="https://docs.rs/microbit-v2/latest/microbit/hal/struct.Twim.html"><code>microbit::hal::Twim</code></a> struct implements this.</li>
<li>æ‚¨æ‹¥æœ‰ä¸€ä¸ª <a href="https://docs.rs/microbit-v2/latest/microbit/struct.Board.html"><code>microbit::Board</code></a> ç»“æ„ä½“ï¼Œå…¶ä¸­åŒ…å«å„ç§å¼•è„šå’Œå¤–å›´è®¾å¤‡çš„å­—æ®µã€‚</li>
<li>å¦‚æœ‰éœ€è¦ï¼Œæ‚¨è¿˜å¯ä»¥æŸ¥çœ‹ <a href="https://infocenter.nordicsemi.com/pdf/nRF52833_PS_v1.5.pdf">nRF52833 æ•°æ®è¡¨</a>ï¼Œä½†å¯¹æœ¬ç»ƒä¹ æ¥è¯´è¿™ä¸æ˜¯å¿…éœ€çš„ã€‚</li>
</ul>
<p>ä¸‹è½½ <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">ç»ƒä¹ æ¨¡æ¿</a> å¹¶åœ¨ <code>compass</code> ç›®å½•ä¸­æŸ¥æ‰¾ä»¥ä¸‹æ–‡ä»¶ã€‚</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use microbit::{hal::{Delay, uarte::{Baudrate, Parity, Uarte}}, Board};

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    // TODO

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        // TODO
    }
}
</code></pre></pre>
<p><em>Cargo.toml</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;compass&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
cortex-m-rt = &quot;0.7.5&quot;
embedded-hal = &quot;1.0.0&quot;
lsm303agr = &quot;1.1.0&quot;
microbit-v2 = &quot;0.15.1&quot;
panic-halt = &quot;1.0.0&quot;
</code></pre>
<p><em>Embed.toml</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File Embed.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[default.general]
chip = &quot;nrf52833_xxAA&quot;

[debug.gdb]
enabled = true

[debug.reset]
halt_afterwards = true
</code></pre>
<p><em>.cargo/config.toml</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4F

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]
</code></pre>
<p>è¿è¡Œä»¥ä¸‹å‘½ä»¤æŸ¥çœ‹ Linux ä¸Šçš„ä¸²è¡Œè¾“å‡ºï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/ttyACM0
</code></pre>
<p>æˆ–è€…åœ¨ Mac OS ä¸Šï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼ˆè®¾å¤‡åç§°å¯èƒ½ç•¥æœ‰ä¸åŒï¼‰ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-sh">picocom --baud 115200 --imap lfcrlf /dev/tty.usbmodem14502
</code></pre>
<p>ä½¿ç”¨ Ctrl+A Ctrl+Q é€€å‡º picocomã€‚</p>
<h1><a class="header" href="#è£¸æœº-rust-ä¸Šåˆç»ƒä¹ " id="è£¸æœº-rust-ä¸Šåˆç»ƒä¹ ">è£¸æœº Rust ä¸Šåˆç»ƒä¹ </a></h1>
<h2><a class="header" href="#ç½—ç›˜-1" id="ç½—ç›˜-1">ç½—ç›˜</a></h2>
<p>(<a href="exercises/bare-metal/compass.html">è¿”å›ç»ƒä¹ </a>)</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

extern crate panic_halt as _;

use core::fmt::Write;
use cortex_m_rt::entry;
use core::cmp::{max, min};
use embedded_hal::digital::InputPin;
use lsm303agr::{
    AccelMode, AccelOutputDataRate, Lsm303agr, MagMode, MagOutputDataRate,
};
use microbit::display::blocking::Display;
use microbit::hal::twim::Twim;
use microbit::hal::uarte::{Baudrate, Parity, Uarte};
use microbit::hal::{Delay, Timer};
use microbit::pac::twim0::frequency::FREQUENCY_A;
use microbit::Board;

const COMPASS_SCALE: i32 = 30000;
const ACCELEROMETER_SCALE: i32 = 700;

#[entry]
fn main() -&gt; ! {
    let mut board = Board::take().unwrap();

    // Configure serial port.
    let mut serial = Uarte::new(
        board.UARTE0,
        board.uart.into(),
        Parity::EXCLUDED,
        Baudrate::BAUD115200,
    );

    // Use the system timer as a delay provider.
    let mut delay = Delay::new(board.SYST);

    // Set up the I2C controller and Inertial Measurement Unit.
    writeln!(serial, &quot;Setting up IMU...&quot;).unwrap();
    let i2c = Twim::new(board.TWIM0, board.i2c_internal.into(), FREQUENCY_A::K100);
    let mut imu = Lsm303agr::new_with_i2c(i2c);
    imu.init().unwrap();
    imu.set_mag_mode_and_odr(
        &amp;mut delay,
        MagMode::HighResolution,
        MagOutputDataRate::Hz50,
    )
    .unwrap();
    imu.set_accel_mode_and_odr(
        &amp;mut delay,
        AccelMode::Normal,
        AccelOutputDataRate::Hz50,
    )
    .unwrap();
    let mut imu = imu.into_mag_continuous().ok().unwrap();

    // Set up display and timer.
    let mut timer = Timer::new(board.TIMER0);
    let mut display = Display::new(board.display_pins);

    let mut mode = Mode::Compass;
    let mut button_pressed = false;

    writeln!(serial, &quot;Ready.&quot;).unwrap();

    loop {
        // Read compass data and log it to the serial port.
        while !(imu.mag_status().unwrap().xyz_new_data()
            &amp;&amp; imu.accel_status().unwrap().xyz_new_data())
        {}
        let compass_reading = imu.magnetic_field().unwrap();
        let accelerometer_reading = imu.acceleration().unwrap();
        writeln!(
            serial,
            &quot;{},{},{}\t{},{},{}&quot;,
            compass_reading.x_nt(),
            compass_reading.y_nt(),
            compass_reading.z_nt(),
            accelerometer_reading.x_mg(),
            accelerometer_reading.y_mg(),
            accelerometer_reading.z_mg(),
        )
        .unwrap();

        let mut image = [[0; 5]; 5];
        let (x, y) = match mode {
            Mode::Compass =&gt; (
                scale(-compass_reading.x_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
                scale(compass_reading.y_nt(), -COMPASS_SCALE, COMPASS_SCALE, 0, 4)
                    as usize,
            ),
            Mode::Accelerometer =&gt; (
                scale(
                    accelerometer_reading.x_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
                scale(
                    -accelerometer_reading.y_mg(),
                    -ACCELEROMETER_SCALE,
                    ACCELEROMETER_SCALE,
                    0,
                    4,
                ) as usize,
            ),
        };
        image[y][x] = 255;
        display.show(&amp;mut timer, image, 100);

        // If button A is pressed, switch to the next mode and briefly blink all LEDs
        // on.
        if board.buttons.button_a.is_low().unwrap() {
            if !button_pressed {
                mode = mode.next();
                display.show(&amp;mut timer, [[255; 5]; 5], 200);
            }
            button_pressed = true;
        } else {
            button_pressed = false;
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
enum Mode {
    Compass,
    Accelerometer,
}

impl Mode {
    fn next(self) -&gt; Self {
        match self {
            Self::Compass =&gt; Self::Accelerometer,
            Self::Accelerometer =&gt; Self::Compass,
        }
    }
}

fn scale(value: i32, min_in: i32, max_in: i32, min_out: i32, max_out: i32) -&gt; i32 {
    let range_in = max_in - min_in;
    let range_out = max_out - min_out;
    cap(min_out + range_out * (value - min_in) / range_in, min_out, max_out)
}

fn cap(value: i32, min_value: i32, max_value: i32) -&gt; i32 {
    max(min_value, min(value, max_value))
}
</code></pre></pre>
<h1><a class="header" href="#åº”ç”¨å¤„ç†å™¨" id="åº”ç”¨å¤„ç†å™¨">åº”ç”¨å¤„ç†å™¨</a></h1>
<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»è®¨è®ºäº†å¾®æ§åˆ¶å™¨ï¼Œä¾‹å¦‚ Arm Cortex-M ç³»åˆ—ã€‚ç°åœ¨ï¼Œå°è¯•ä¸º Cortex-A ç¼–å†™ä¸€äº›ä»£ç ã€‚ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬åªä½¿ç”¨ QEMU çš„ aarch64 <a href="https://qemu-project.gitlab.io/qemu/system/arm/virt.html"><code>virt</code></a> å¼€å‘æ¿ è¿›è¡Œç¼–å†™ã€‚</p>
<details>
<ul>
<li>ä¸€èˆ¬æ¥è¯´ï¼Œå¾®æ§åˆ¶å™¨ä¸å…·å¤‡ MMU æˆ–å¤šçº§ç‰¹æƒï¼ˆä¾‹å¦‚ï¼ŒArm CPU ä¸­çš„å¼‚å¸¸çº§åˆ«ï¼Œx86 ä¸­çš„é“ƒå£°çº§åˆ«ï¼‰çš„åŠŸèƒ½ï¼Œè€Œåº”ç”¨å¤„ç†å™¨åˆ™å…·å¤‡è¿™äº›åŠŸèƒ½ã€‚</li>
<li>QEMU æ”¯æŒé’ˆå¯¹æ¯ç§æ¶æ„æ¨¡æ‹Ÿä¸åŒçš„æœºå™¨æˆ–æ¿çº§æ¨¡å‹ã€‚â€œè™šæ‹Ÿâ€å¼€å‘æ¿å¹¶ä¸é€‚ç”¨äºä»»ä½•ç‰¹å®šçš„çœŸå®ç¡¬ä»¶ï¼Œè€Œæ˜¯ä¸“ä¸ºè™šæ‹Ÿæœºè®¾è®¡çš„ã€‚</li>
</ul>
</details><h1><a class="header" href="#å‡†å¤‡ä½¿ç”¨-rust" id="å‡†å¤‡ä½¿ç”¨-rust">å‡†å¤‡ä½¿ç”¨ Rust</a></h1>
<p>åœ¨å¼€å§‹è¿è¡Œ Rust ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›åˆå§‹åŒ–è®¾ç½®ã€‚</p>
<pre><code class="language-armasm">.section .init.entry, &quot;ax&quot;
.global entry
entry:
    /*
     * Load and apply the memory management configuration, ready to
     * enable MMU and caches.
     */
    adrp x30, idmap
    msr ttbr0_el1, x30

    mov_i x30, .Lmairval
    msr mair_el1, x30

    mov_i x30, .Ltcrval
    /* Copy the supported PA range into TCR_EL1.IPS. */
    mrs x29, id_aa64mmfr0_el1
    bfi x30, x29, #32, #4

    msr tcr_el1, x30

    mov_i x30, .Lsctlrval

    /*
     * Ensure everything before this point has completed, then
     * invalidate any potentially stale local TLB entries before they
     * start being used.
     */
    isb
    tlbi vmalle1
    ic iallu
    dsb nsh
    isb

    /*
     * Configure sctlr_el1 to enable MMU and cache and don't proceed
     * until this has completed.
     */
    msr sctlr_el1, x30
    isb

    /* Disable trapping floating point access in EL1. */
    mrs x30, cpacr_el1
    orr x30, x30, #(0x3 &lt;&lt; 20)
    msr cpacr_el1, x30
    isb

    /* Zero out the bss section. */
    adr_l x29, bss_begin
    adr_l x30, bss_end
0:  cmp x29, x30
    b.hs 1f
    stp xzr, xzr, [x29], #16
    b 0b

1:  /* Prepare the stack. */
    adr_l x30, boot_stack_end
    mov sp, x30

    /* Set up exception vector. */
    adr x30, vector_table_el1
    msr vbar_el1, x30

    /* Call into Rust code. */
    bl main

    /* Loop forever waiting for interrupts. */
2:  wfi
    b 2b
</code></pre>
<details>
<ul>
<li>è¿™ä¸ C è¯­è¨€çš„æƒ…å†µç›¸åŒï¼šåˆå§‹åŒ–å¤„ç†å™¨çŠ¶æ€ï¼Œå°† BSS æ¸…é›¶ï¼Œç„¶åè®¾ç½®å †æ ˆæŒ‡é’ˆã€‚
<ul>
<li>BSSï¼ˆç”±äºå†å²åŸå› ï¼Œç§°ä¸ºä»£ç å—èµ·å§‹ç¬¦ï¼‰å±äºå¯¹è±¡æ–‡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­åŒ…å«é™æ€åˆ†é…çš„å˜é‡ï¼Œè¿™äº›å˜é‡è¢«åˆå§‹åŒ–ä¸ºé›¶ã€‚å›¾åƒä¸­çœç•¥äº†è¿™äº›ç¬¦å·ï¼Œä»¥é¿å…å› å­˜å‚¨é›¶å€¼è€Œå ç”¨è¿‡å¤šç©ºé—´ã€‚ç¼–è¯‘å™¨å‡å®šåŠ è½½å™¨ä¼šè´Ÿè´£å°†å®ƒä»¬æ¸…é›¶ã€‚</li>
</ul>
</li>
<li>BSS å¯èƒ½å·²ç»è¢«æ¸…é›¶ï¼Œå…·ä½“å–å†³äºå†…å­˜çš„åˆå§‹åŒ–æ–¹å¼ä»¥åŠå›¾åƒçš„åŠ è½½æ–¹å¼ï¼Œä½†ä¸ºäº†ç¡®ä¿èµ·è§ï¼Œæˆ‘ä»¬ä¼šå°†å…¶æ‰‹åŠ¨æ¸…é›¶ã€‚</li>
<li>æˆ‘ä»¬éœ€è¦å…ˆå¯ç”¨ MMU å’Œç¼“å­˜åŠŸèƒ½ï¼Œç„¶åæ‰èƒ½è¯»å–æˆ–å†™å…¥ä»»ä½•å†…å­˜ã€‚å¦åˆ™ï¼š
<ul>
<li>éå¯¹é½è®¿é—®å°†ä¼šå‡ºé”™ã€‚æˆ‘ä»¬ä¸º <code>aarch64-unknown-none</code> ç›®æ ‡æ„å»º Rust ä»£ç ï¼Œè¯¥ç›®æ ‡ä¼šè®¾ç½® <code>+Strict-align</code> ä»¥é˜²æ­¢ç¼–è¯‘å™¨ç”Ÿæˆéå¯¹é½è®¿é—®ï¼Œå› æ­¤åœ¨æœ¬ä¾‹ä¸­åº”è¯¥æ²¡æœ‰é—®é¢˜ï¼Œä½†ä¸€èˆ¬æƒ…å†µä¸‹å¹¶ä¸ä¸€å®šå¦‚æ­¤ã€‚</li>
<li>å¦‚æœæ˜¯åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œè¯¥å‘½ä»¤ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜ã€‚é—®é¢˜åœ¨äºï¼Œè™šæ‹Ÿæœºæ˜¯åœ¨ç¦ç”¨ç¼“å­˜çš„æƒ…å†µä¸‹ç›´æ¥è®¿é—®å†…å­˜ï¼Œè€Œä¸»æœºå…·æœ‰åŒä¸€å†…å­˜çš„ç¼“å­˜åˆ«åã€‚å³ä½¿ä¸»æœºå¹¶æ²¡æœ‰æ˜ç¡®è®¿é—®è¯¥å†…å­˜ï¼Œæ¨æµ‹æ€§è®¿é—®ä»ç„¶ä¼šå¯¼è‡´ç¼“å­˜è¢«å¡«å……ï¼Œç„¶ååœ¨æ¸…é™¤ç¼“å­˜æˆ–è™šæ‹Ÿæœºå¯ç”¨ç¼“å­˜æ—¶ï¼Œä»»ä½•ä¸€æ–¹å¯¹äºè¯¥å†…å­˜è¿›è¡Œçš„æ›´æ”¹å°±ä¼šä¸¢å¤±ã€‚ï¼ˆä½¿ç”¨ç‰©ç†åœ°å€æ¥é”®æ§ç¼“å­˜ï¼Œè€Œ VA æˆ– IPAã€‚ï¼‰</li>
</ul>
</li>
<li>ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬åªä½¿ç”¨ç¡¬ç¼–ç çš„åˆ†é¡µè¡¨ï¼ˆè¯·å‚é˜… <code>dmap.S</code>ï¼‰ï¼Œå…¶é€šè¿‡èº«ä»½æ˜ å°„å°†å‰ä¸€ä¸ª 1 GiB çš„åœ°å€ç©ºé—´ç”¨äºè®¾å¤‡ï¼Œç´§æ¥ç€çš„ 1 GiB ç”¨äº DRAMï¼Œç„¶ååœ¨æ›´é«˜ä½ç½®é¢„ç•™äº† 1 GiB ç»™å…¶ä»–è®¾å¤‡ã€‚è¿™ä¸ QEMU ä½¿ç”¨çš„å†…å­˜å¸ƒå±€ä¸€è‡´ã€‚</li>
<li>æˆ‘ä»¬è¿˜è®¾ç½®äº†å¼‚å¸¸çŸ¢é‡ (<code>vbar_el1</code>)ï¼Œç¨åä¼šå¯¹æ­¤è¿›è¡Œè¯¦ç»†ä»‹ç»ã€‚</li>
<li>ä»Šå¤©ä¸‹åˆçš„æ‰€æœ‰ç¤ºä¾‹éƒ½å‡å®šæˆ‘ä»¬å°†åœ¨å¼‚å¸¸çº§åˆ« 1 (EL1) ä¸‹è¿è¡Œã€‚å¦‚æœæ‚¨éœ€è¦åœ¨å…¶ä»–å¼‚å¸¸çº§åˆ«ä¸‹è¿è¡Œï¼Œåˆ™éœ€è¦ä¿®æ”¹ç›¸åº”çš„ <code>entry.S</code>ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å†…åµŒæ±‡ç¼–" id="å†…åµŒæ±‡ç¼–">å†…åµŒæ±‡ç¼–</a></h1>
<p>æœ‰æ—¶ï¼Œå¦‚æœæ— æ³•é€šè¿‡ Rust ä»£ç å®ç°æŸäº›æ“ä½œï¼Œæˆ‘ä»¬å°±éœ€è¦ä½¿ç”¨æ±‡ç¼–æ¥è§£å†³ã€‚ä¾‹å¦‚ï¼Œå¦‚éœ€å‘å‡º HVCï¼ˆHypervisor è°ƒç”¨ï¼‰æ¥æŒ‡ç¤ºå›ºä»¶å…³é—­ç³»ç»Ÿï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

use core::arch::asm;
use core::panic::PanicInfo;

mod exceptions;

const PSCI_SYSTEM_OFF: u32 = 0x84000008;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(_x0: u64, _x1: u64, _x2: u64, _x3: u64) {
    // SAFETY: this only uses the declared registers and doesn't do anything
    // with memory.
    unsafe {
        asm!(&quot;hvc #0&quot;,
            inout(&quot;w0&quot;) PSCI_SYSTEM_OFF =&gt; _,
            inout(&quot;w1&quot;) 0 =&gt; _,
            inout(&quot;w2&quot;) 0 =&gt; _,
            inout(&quot;w3&quot;) 0 =&gt; _,
            inout(&quot;w4&quot;) 0 =&gt; _,
            inout(&quot;w5&quot;) 0 =&gt; _,
            inout(&quot;w6&quot;) 0 =&gt; _,
            inout(&quot;w7&quot;) 0 =&gt; _,
            options(nomem, nostack)
        );
    }

    loop {}
}
</code></pre></pre>
<p>ï¼ˆå¦‚æœç¡®å®æƒ³è¦è¿™æ ·åšï¼Œè¯·ä½¿ç”¨ <a href="https://crates.io/crates/smccc"><code>smccc</code></a> crateï¼Œå…¶ä¸­åŒ…å«é€‚ç”¨äºæ‰€æœ‰è¿™äº›å‡½æ•°çš„å°è£…å®¹å™¨ã€‚ï¼‰</p>
<details>
<ul>
<li>PSCI æ˜¯ Arm ç”µæºçŠ¶æ€åè°ƒæ¥å£ï¼Œä¸ºä¸€ç»„æ ‡å‡†å‡½æ•°ï¼Œç”¨äºç®¡ç†ç³»ç»Ÿå’Œ CPU ç”µæºçŠ¶æ€ç­‰ã€‚åœ¨è®¸å¤šç³»ç»Ÿä¸­ï¼Œé€šè¿‡ EL3 å›ºä»¶å’Œ Hypervisor æ¥å®ç°è¯¥å‡½æ•°ã€‚</li>
<li><code>0 =&gt; _</code> è¯­æ³•è¡¨ç¤ºåœ¨è¿è¡Œå†…åµŒæ±‡ç¼–ä»£ç ä¹‹å‰å°†å¯„å­˜å™¨åˆå§‹åŒ–ä¸º 0ï¼Œå¹¶åœ¨ä¹‹åå¿½ç•¥å¯„å­˜å™¨ä¸­çš„å†…å®¹ã€‚æˆ‘ä»¬éœ€è¦ä½¿ç”¨ <code>inout</code> è€Œé <code>in</code>ï¼Œå› ä¸ºè¯¥è°ƒç”¨æ“ä½œå¯èƒ½ä¼šç ´åå¯„å­˜å™¨ä¸­çš„å†…å®¹ã€‚</li>
<li>This <code>main</code> function needs to be <code>#[unsafe(no_mangle)]</code> and <code>extern &quot;C&quot;</code> because it is called from our entry point in <code>entry.S</code>.</li>
<li><code>_x0</code>â€“<code>_x3</code> è¡¨ç¤ºå¯„å­˜å™¨ <code>x0</code>-<code>x3</code> çš„å€¼ï¼Œå¼•å¯¼åŠ è½½ç¨‹åºé€šå¸¸ä½¿ç”¨è¿™äº›å€¼æ¥ä¼ é€’å„ç§å†…å®¹ï¼ˆä¾‹å¦‚å°†æŒ‡é’ˆä¼ é€’åˆ°è®¾å¤‡æ ‘ï¼‰ã€‚æ ¹æ®æ ‡å‡†çš„ aarch64 è°ƒç”¨è§„èŒƒï¼ˆ<code>extern &quot;C&quot;</code>æŒ‡å®šä½¿ç”¨æ­¤è§„èŒƒï¼‰ï¼Œéœ€è¦ä½¿ç”¨å¯„å­˜å™¨ <code>x0</code>-<code>x7</code> å°†å‰ 8 ä¸ªå‚æ•°ä¼ é€’ç»™å‡½æ•°ï¼Œå› æ­¤ <code>entry.S</code> æ— éœ€æ‰§è¡Œä»»ä½•ç‰¹æ®Šæ“ä½œï¼Œåªè¦ç¡®ä¿ä¸ä¼šæ›´æ”¹è¿™äº›å¯„å­˜å™¨ã€‚</li>
<li>åœ¨ QEMU ä¸­ï¼Œä½¿ç”¨ <code>src/bare-metal/aps/examples</code> ç›®å½•ä¸‹çš„ <code>make qemu_psci</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#mmio-çš„æ˜“å¤±æ€§å†…å­˜è®¿é—®" id="mmio-çš„æ˜“å¤±æ€§å†…å­˜è®¿é—®">MMIO çš„æ˜“å¤±æ€§å†…å­˜è®¿é—®</a></h1>
<ul>
<li>Use <a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.read_volatile"><code>pointer::read_volatile</code></a> and <a href="https://doc.rust-lang.org/stable/core/primitive.pointer.html#method.write_volatile"><code>pointer::write_volatile</code></a>.</li>
<li>åˆ‡å‹¿æåŠå¼•ç”¨ã€‚</li>
<li>Use <code>&amp;raw</code> to get fields of structs without creating an intermediate reference.</li>
</ul>
<details>
<ul>
<li>æ˜“å¤±æ€§è®¿é—®ï¼šæ‰§è¡Œè¯»å–æˆ–å†™å…¥æ“ä½œå¯èƒ½ä¼šäº§ç”Ÿå‰¯ä½œç”¨ï¼Œå› æ­¤åº”é˜»æ­¢ç¼–è¯‘å™¨æˆ–ç¡¬ä»¶å¯¹è¿™äº›æ“ä½œè¿›è¡Œé‡æ–°æ’åºã€å¤åˆ¶æˆ–çœç•¥ã€‚
<ul>
<li>é€šå¸¸æƒ…å†µä¸‹ï¼Œå¦‚æœæ‚¨å…ˆå†™å…¥æ“ä½œï¼Œç´§æ¥ç€è¿›è¡Œè¯»å–æ“ä½œï¼ˆä¾‹å¦‚é€šè¿‡å¯å˜å¼•ç”¨ï¼‰ï¼Œåˆ™ç¼–è¯‘å™¨å¯èƒ½ä¼šè®¤ä¸ºè¯»å–çš„å€¼æ˜¯æœ€æ–°å†™å…¥çš„å€¼ï¼Œå°±ä¸å†æ‰§è¡Œå®é™…çš„å†…å­˜è¯»å–è¿‡ç¨‹ã€‚</li>
</ul>
</li>
<li>è™½ç„¶åœ¨å¯¹ç¡¬ä»¶è¿›è¡Œæ˜“å¤±æ€§è®¿é—®æ—¶ï¼Œä¸€äº› crate ç¡®å®ä¼šæåŠå¼•ç”¨ï¼Œä½†è¿™å¾ˆä¸å®‰å…¨ã€‚åªè¦å­˜åœ¨å¼•ç”¨ï¼Œç¼–è¯‘å™¨å°±ä¼šé€‰æ‹©å¯¹å…¶è¿›è¡Œè§£å¼•ç”¨æ“ä½œã€‚</li>
<li>Use <code>&amp;raw</code> to get struct field pointers from a pointer to the struct.</li>
<li>For compatibility with old versions of Rust you can use the <a href="https://doc.rust-lang.org/stable/core/ptr/macro.addr_of.html"><code>addr_of!</code></a> macro instead.</li>
</ul>
</details>
<h1><a class="header" href="#ç¼–å†™-uart-é©±åŠ¨ç¨‹åº" id="ç¼–å†™-uart-é©±åŠ¨ç¨‹åº">ç¼–å†™ UART é©±åŠ¨ç¨‹åº</a></h1>
<p>QEMU â€œè™šæ‹Ÿæœºâ€å…·æœ‰ <a href="https://developer.arm.com/documentation/ddi0183/g">PL011</a> UARTï¼Œç°åœ¨ä¸ºå…¶ç¼–å†™é©±åŠ¨ç¨‹åºã€‚</p>
<pre><pre class="playground"><code class="language-rust editable">const FLAG_REGISTER_OFFSET: usize = 0x18;
const FR_BUSY: u8 = 1 &lt;&lt; 3;
const FR_TXFF: u8 = 1 &lt;&lt; 5;

/// Minimal driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    base_address: *mut u8,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u8) -&gt; Self {
        Self { base_address }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register() &amp; FR_TXFF != 0 {}

        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            self.base_address.write_volatile(byte);
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register() &amp; FR_BUSY != 0 {}
    }

    fn read_flag_register(&amp;self) -&gt; u8 {
        // SAFETY: We know that the base address points to the control
        // registers of a PL011 device which is appropriately mapped.
        unsafe { self.base_address.add(FLAG_REGISTER_OFFSET).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>è¯·æ³¨æ„ï¼Œä½¿ç”¨ <code>Uart::new</code> æ–¹æ³•ä¸å®‰å…¨ï¼Œè€Œå…¶ä»–æ–¹æ³•åˆ™å®‰å…¨ã€‚åŸå› åœ¨äºï¼Œåªè¦ <code>Uart::new</code> çš„è°ƒç”¨æ–¹ä¿è¯æ»¡è¶³å…¶å®‰å…¨è¦æ±‚ï¼ˆå³æ‰€æŒ‡å®šçš„ UART åªæœ‰ä¸€ä¸ªé©±åŠ¨ç¨‹åºå®ä¾‹ï¼Œä¸”æ²¡æœ‰å…¶ä»–å†…å®¹ä¸å…¶åœ°å€ç©ºé—´å­˜åœ¨é‡å ï¼‰ï¼Œé‚£ä¹ˆåç»­è°ƒç”¨ <code>write_byte</code> å§‹ç»ˆæ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæˆ‘ä»¬å‡å®šéœ€è¦æ»¡è¶³çš„å‰ææ¡ä»¶ã€‚</li>
<li>æˆ‘ä»¬ä¹Ÿå¯ä»¥é‡‡ç”¨ç›¸åçš„æ–¹å¼ï¼ˆå³ç¡®ä¿ <code>new</code> å®‰å…¨ï¼Œä½† <code>write_byte</code> ä¸å®‰å…¨ï¼‰ï¼Œä¸è¿‡è¿™æ ·ä¼šå¾ˆä¸æ–¹ä¾¿ï¼Œå› ä¸ºæ¯å½“è°ƒç”¨ <code>write_byte</code> æ—¶éƒ½éœ€è¦æ¨æ–­æ˜¯å¦å®‰å…¨ã€‚</li>
<li>è¿™æ˜¯å®‰å…¨åœ°å°è£…ä¸å®‰å…¨ä»£ç æ—¶å¸¸è§çš„ç­–ç•¥ï¼šå³åœ¨å°‘æ•°è°ƒç”¨ä»£ç çš„åœ°æ–¹è¿›è¡Œå®‰å…¨éªŒè¯ï¼Œè€Œä¸æ˜¯åœ¨å¾ˆå¤šåœ°æ–¹è¿›è¡Œã€‚</li>
</ul>
</details>
<h1><a class="header" href="#æ›´å¤š-trait-1" id="æ›´å¤š-trait-1">æ›´å¤š trait</a></h1>
<p>å·²ç»æ´¾ç”Ÿäº† <code>Debug</code> traitã€‚å¦‚æœå†å®ç°æ›´å¤š traitï¼Œä¼šå¤§æœ‰å¸®åŠ©ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use core::fmt::{self, Write};

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// SAFETY: `Uart` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
</code></pre></pre>
<details>
<ul>
<li>é€šè¿‡å®ç° <code>Write</code>ï¼Œæˆ‘ä»¬å¯ä»¥å°† <code>write!</code> å’Œ <code>writeln!</code> å®ä¸ <code>Uart</code> ç±»å‹æ­é…ä½¿ç”¨ã€‚</li>
<li>åœ¨ QEMU ä¸­ï¼Œä½¿ç”¨ <code>src/bare-metal/aps/examples</code> ç›®å½•ä¸‹çš„ <code>make qemu_minimal</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#æ›´å¥½çš„-uart-é©±åŠ¨ç¨‹åº" id="æ›´å¥½çš„-uart-é©±åŠ¨ç¨‹åº">æ›´å¥½çš„ UART é©±åŠ¨ç¨‹åº</a></h1>
<p>äº‹å®ä¸Šï¼ŒPL011 å…·æœ‰ <a href="https://developer.arm.com/documentation/ddi0183/g/programmers-model/summary-of-registers">å¾ˆå¤šé¢å¤–çš„å¯„å­˜å™¨</a>ï¼Œä½†é€šè¿‡æ·»åŠ åç§»é‡æ„å»ºæŒ‡é’ˆçš„æ–¹å¼æ¥è®¿é—®è¿™äº›å¯„å­˜å™¨ï¼Œæ—¢å®¹æ˜“å‡ºé”™åˆéš¾ä»¥è¯»å–ã€‚æ­¤å¤–ï¼Œå…¶ä¸­æœ‰äº›å¯„å­˜å™¨æ˜¯ä½å­—æ®µï¼Œéå¸¸ä¾¿äºä»¥ç»“æ„åŒ–æ–¹å¼è®¿é—®ã€‚</p>
<table><thead><tr><th>åç§»</th><th>å¯„å­˜å™¨åç§°</th><th>å®½åº¦</th></tr></thead><tbody>
<tr><td>0x00</td><td>DR</td><td>12</td></tr>
<tr><td>0x04</td><td>RSR</td><td>4</td></tr>
<tr><td>0x18</td><td>FR</td><td>9</td></tr>
<tr><td>0x20</td><td>ILPR</td><td>8</td></tr>
<tr><td>0x24</td><td>IBRD</td><td>16</td></tr>
<tr><td>0x28</td><td>FBRD</td><td>6</td></tr>
<tr><td>0x2c</td><td>LCR_H</td><td>8</td></tr>
<tr><td>0x30</td><td>CR</td><td>16</td></tr>
<tr><td>0x34</td><td>IFLS</td><td>6</td></tr>
<tr><td>0x38</td><td>IMSC</td><td>11</td></tr>
<tr><td>0x3c</td><td>RIS</td><td>11</td></tr>
<tr><td>0x40</td><td>MIS</td><td>11</td></tr>
<tr><td>0x44</td><td>ICR</td><td>11</td></tr>
<tr><td>0x48</td><td>DMACR</td><td>3</td></tr>
</tbody></table>
<details>
<ul>
<li>ä¸ºç®€æ´èµ·è§ï¼Œæˆ‘ä»¬çœç•¥äº†ä¸€äº› ID å¯„å­˜å™¨ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#bitflags" id="bitflags">Bitflags</a></h1>
<p><a href="https://crates.io/crates/bitflags"><code>bitflags</code></a> crate éå¸¸é€‚ç”¨äºå¤„ç† bitflagã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
</code></pre></pre>
<details>
<ul>
<li><code>bitflags!</code> å®ä¼šåˆ›å»ºç±»ä¼¼äº <code>Flags(u16)</code> çš„æ–°ç±»å‹ï¼Œä»¥åŠä¸€ç³»åˆ—ç”¨äºè·å–å’Œè®¾ç½®æ ‡è®°çš„æ–¹æ³•å®ç°ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å¤šä¸ªå¯„å­˜å™¨" id="å¤šä¸ªå¯„å­˜å™¨">å¤šä¸ªå¯„å­˜å™¨</a></h1>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ¥è¡¨ç¤º UART å¯„å­˜å™¨çš„å†…å­˜å¸ƒå±€ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
</code></pre></pre>
<details>
<ul>
<li>é€šè¿‡è¿è¡Œ <a href="https://doc.rust-lang.org/reference/type-layout.html#the-c-representation"><code>#[repr(C)]</code></a> å‘½ä»¤ï¼ŒæŒ‡ç¤ºç¼–è¯‘å™¨æŒ‰é¡ºåºå¸ƒç½®ç»“æ„ä½“å­—æ®µï¼Œéµå¾ªä¸ C è¯­è¨€ç›¸åŒçš„è§„åˆ™ã€‚è¿™æ˜¯ç¡®ä¿ç»“æ„ä½“å…·æœ‰å¯é¢„æµ‹å¸ƒå±€çš„å¿…è¦æ¡ä»¶ï¼Œå› ä¸ºé»˜è®¤çš„ Rust è¡¨ç¤ºæ³•å…è®¸ç¼–è¯‘å™¨ï¼ˆä»¥åŠå…¶ä»–å†…å®¹ï¼‰æŒ‰ç…§å…¶è®¤ä¸ºåˆé€‚çš„æ–¹å¼é‡æ–°æ’åˆ—å­—æ®µã€‚</li>
</ul>
</details>
<h1><a class="header" href="#é©±åŠ¨ç¨‹åº" id="é©±åŠ¨ç¨‹åº">é©±åŠ¨ç¨‹åº</a></h1>
<p>ç°åœ¨å°†æ–°çš„ <code>Registers</code> ç»“æ„ä½“ç”¨äºæˆ‘ä»¬çš„é©±åŠ¨ç¨‹åºã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the 8 MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            (&amp;raw mut (*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { (&amp;raw const (*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).fr).read_volatile() }
    }
}
</code></pre></pre>
<details>
<ul>
<li>Note the use of <code>&amp;raw const</code> / <code>&amp;raw mut</code> to get pointers to individual fields without creating an intermediate reference, which would be unsound.</li>
</ul>
</details>
<h1><a class="header" href="#å¼€å§‹ä½¿ç”¨" id="å¼€å§‹ä½¿ç”¨">å¼€å§‹ä½¿ç”¨</a></h1>
<p>ä½¿ç”¨é©±åŠ¨ç¨‹åºç¼–å†™ä¸€ä¸ªå°ç¨‹åºï¼Œå°†æ•°æ®å†™å…¥ä¸²è¡Œæ§åˆ¶å°ï¼Œå¹¶å›æ˜¾ä¼ å…¥çš„å­—èŠ‚ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod pl011;

use crate::pl011::Uart;
use core::fmt::Write;
use core::panic::PanicInfo;
use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let mut uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };

    writeln!(uart, &quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;).unwrap();

    loop {
        if let Some(byte) = uart.read_byte() {
            uart.write_byte(byte);
            match byte {
                b'\r' =&gt; {
                    uart.write_byte(b'\n');
                }
                b'q' =&gt; break,
                _ =&gt; continue,
            }
        }
    }

    writeln!(uart, &quot;\n\nBye!&quot;).unwrap();
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>ä¸ <a href="bare-metal/aps/better-uart/../inline-assembly.html">å†…åµŒæ±‡ç¼–</a> ç¤ºä¾‹ä¸€æ ·ï¼Œä» <code>entry.S</code> ä¸­çš„å…¥å£ç‚¹ä»£ç è°ƒç”¨æ­¤ <code>main</code> å‡½æ•°ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼Œè¯·å‚é˜…æ¼”è®²è€…å¤‡æ³¨ã€‚</li>
<li>åœ¨ QEMU ä¸­ï¼Œä½¿ç”¨ <code>src/bare-metal/aps/examples</code> ç›®å½•ä¸‹çš„ <code>make qemu</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#æ—¥å¿—è®°å½•-1" id="æ—¥å¿—è®°å½•-1">æ—¥å¿—è®°å½•</a></h1>
<p>æœ€å¥½èƒ½å¤Ÿä½¿ç”¨ <a href="https://crates.io/crates/log"><code>log</code></a> crate ä¸­çš„æ—¥å¿—è®°å½•å®ã€‚å¯ä»¥é€šè¿‡å®ç°â€œLogâ€trait æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>ä½¿ç”¨ <code>log</code> è¿›è¡Œè§£å°è£…æ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¼šåœ¨è°ƒç”¨ <code>set_logger</code> ä¹‹å‰åˆå§‹åŒ– <code>LOGGER</code>ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å¼€å§‹ä½¿ç”¨-1" id="å¼€å§‹ä½¿ç”¨-1">å¼€å§‹ä½¿ç”¨</a></h1>
<p>éœ€è¦å…ˆåˆå§‹åŒ–æ—¥å¿—è®°å½•å™¨ï¼Œç„¶åæ‰èƒ½ä½¿ç”¨å®ƒã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use core::panic::PanicInfo;
use log::{error, info, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({x0:#x}, {x1:#x}, {x2:#x}, {x3:#x})&quot;);

    assert_eq!(x1, 42);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<details>
<ul>
<li>è¯·æ³¨æ„ï¼Œpanic ç´§æ€¥å¤„ç†ç¨‹åºç°åœ¨å¯ä»¥è®°å½•å„ç±» panic è¯¦ç»†ä¿¡æ¯ã€‚</li>
<li>åœ¨ QEMU ä¸­ï¼Œä½¿ç”¨ <code>src/bare-metal/aps/examples</code> ç›®å½•ä¸‹çš„ <code>make qemu_logger</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#å¼‚å¸¸-1" id="å¼‚å¸¸-1">å¼‚å¸¸</a></h1>
<p>AArch64 å®šä¹‰äº†ä¸€ä¸ªåŒ…å« 16 ä¸ªæ¡ç›®çš„å¼‚å¸¸çŸ¢é‡è¡¨ï¼Œé€‚ç”¨äºå¤„ç† 4 ç§çŠ¶æ€ï¼ˆå½“å‰ EL ä½¿ç”¨ SP0ï¼Œå½“å‰ EL ä½¿ç”¨ SPxï¼Œè¾ƒä½ EL ä½¿ç”¨ AArch64ï¼Œè¾ƒä½ EL ä½¿ç”¨ AArch32ï¼‰ä¸‹çš„ 4 ç§å¼‚å¸¸ï¼ˆåŒæ­¥ã€IRQã€FIQã€SErrorï¼‰ã€‚å¯ä»¥é€šè¿‡æ±‡ç¼–æ–¹å¼å®ç°è¿™ä¸€æ“ä½œï¼Œä»¥ä¾¿åœ¨è°ƒç”¨ Rust ä»£ç ä¹‹å‰å°†æ˜“å¤±æ€§å¯„å­˜å™¨ä¿å­˜åˆ°å †æ ˆï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use log::error;
use smccc::psci::system_off;
use smccc::Hvc;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    error!(&quot;irq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
</code></pre></pre>
<details>
<ul>
<li>EL æŒ‡å¼‚å¸¸çº§åˆ«ï¼›æˆ‘ä»¬ä»Šå¤©ä¸‹åˆçš„æ‰€æœ‰ç¤ºä¾‹éƒ½åœ¨ EL1 çº§åˆ«ä¸‹è¿è¡Œã€‚</li>
<li>ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬æ²¡æœ‰åŒºåˆ†å½“å‰ EL å¼‚å¸¸ä¸­çš„ SP0 å’Œ SPxï¼Œä¹Ÿæ²¡æœ‰åŒºåˆ†è¾ƒä½ EL å¼‚å¸¸ä¸­çš„ AArch32 å’Œ AArch64ã€‚</li>
<li>åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œåªéœ€è®°å½•å¼‚å¸¸å¹¶è¿›è¡Œå…³æœºæ“ä½œï¼Œå› ä¸ºé¢„è®¡ä¸ä¼šå‘ç”Ÿä»»ä½•æ­¤ç±»å¼‚å¸¸ã€‚</li>
<li>æˆ‘ä»¬å¯ä»¥å°†å¼‚å¸¸å¤„ç†ç¨‹åºå’Œä¸»æ‰§è¡Œä¸Šä¸‹æ–‡è§†ä¸ºä¸åŒçš„çº¿ç¨‹ã€‚é€šè¿‡ <a href="bare-metal/aps/../../concurrency/send-sync.html"><code>Send</code> å’Œ <code>Sync</code></a> æ§åˆ¶å®ƒä»¬ä¹‹é—´å¯ä»¥å…±äº«çš„å†…å®¹ï¼Œå°±åƒä½¿ç”¨çº¿ç¨‹è¿›è¡Œå…±äº«ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæƒ³åœ¨å¼‚å¸¸å¤„ç†ç¨‹åºå’Œç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ä¹‹é—´å…±äº«æŸä¸ªå€¼ï¼Œå¹¶ä¸”ä½¿ç”¨ <code>Send</code> è€Œé <code>Sync</code>ï¼Œåˆ™éœ€è¦å°†è¯¥å€¼å°è£…åœ¨è¯¸å¦‚ <code>Mutex</code> ä¹‹ç±»çš„å†…å®¹ä¸­ï¼Œå¹¶æ”¾å…¥é™æ€å˜é‡ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#other-projects-1" id="other-projects-1">Other projects</a></h1>
<ul>
<li><a href="https://github.com/oreboot/oreboot">oreboot</a>
<ul>
<li>&quot;coreboot without the C&quot;.</li>
<li>æ”¯æŒ x86ã€aarch64 å’Œ RISC-Vã€‚</li>
<li>ä¾èµ–äº LinuxBootï¼Œè€Œä¸æ˜¯è®¸å¤šé©±åŠ¨ç¨‹åºæœ¬èº«ã€‚</li>
</ul>
</li>
<li><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">Rust RaspberryPi æ“ä½œç³»ç»Ÿæ•™ç¨‹</a>
<ul>
<li>Initialisation, UART driver, simple bootloader, JTAG, exception levels, exception handling, page tables.</li>
<li>åœ¨ Rust ä¸­ï¼Œæœ‰äº›ç”¨äºå¤„ç†ç¼“å­˜ç»´æŠ¤å’Œåˆå§‹åŒ–çš„æ–¹æ³•å¹¶ä¸å®‰å…¨ï¼Œä¸é€‚å®œç…§æ¬åˆ°æ­£å¼ç‰ˆä»£ç ä¸­ã€‚</li>
</ul>
</li>
<li><a href="https://crates.io/crates/cargo-call-stack"><code>cargo-call-stack</code></a>
<ul>
<li>ä½¿ç”¨é™æ€åˆ†ææ¥ç¡®å®šå †æ ˆç”¨é‡ä¸Šé™ã€‚</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>åœ¨ RaspberryPi æ“ä½œç³»ç»Ÿæ•™ç¨‹ä¸­ï¼Œå…ˆè¿è¡Œ Rust ä»£ç ç„¶åå¯ç”¨ MMU å’Œç¼“å­˜ã€‚æ­¤æ“ä½œä¼šè¯»å–å’Œå†™å…¥å†…å­˜ï¼ˆä¾‹å¦‚å †æ ˆï¼‰ã€‚ä¸è¿‡ï¼š
<ul>
<li>å¦‚æœä¸å¯ç”¨ MMU å’Œç¼“å­˜ï¼Œéå¯¹é½è®¿é—®å°†ä¼šå‡ºé”™ã€‚å®ƒä½¿ç”¨ <code>aarch64-unknown-none</code> è¿›è¡Œæ„å»ºï¼Œåè€…ä¼šè®¾ç½® <code>+strict-align</code> ä»¥é˜²æ­¢ç¼–è¯‘å™¨ç”Ÿæˆéå¯¹é½è®¿é—®ï¼Œå› æ­¤åº”è¯¥æ²¡æœ‰é—®é¢˜ï¼Œä½†ä¸€èˆ¬æƒ…å†µä¸‹å¹¶ä¸ä¸€å®šå¦‚æ­¤ã€‚</li>
<li>å¦‚æœæ˜¯åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œè¯¥å‘½ä»¤ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç¼“å­˜ä¸€è‡´æ€§é—®é¢˜ã€‚é—®é¢˜åœ¨äºï¼Œè™šæ‹Ÿæœºæ˜¯åœ¨ç¦ç”¨ç¼“å­˜çš„æƒ…å†µä¸‹ç›´æ¥è®¿é—®å†…å­˜ï¼Œè€Œä¸»æœºå…·æœ‰åŒä¸€å†…å­˜çš„ç¼“å­˜åˆ«åã€‚å³ä½¿ä¸»æœºå¹¶æ²¡æœ‰æ˜ç¡®è®¿é—®è¯¥å†…å­˜ï¼Œæ¨æµ‹æ€§è®¿é—®ä»ç„¶ä¼šå¯¼è‡´ç¼“å­˜è¢«å¡«å……ï¼Œç„¶åä»»ä½•ä¸€æ–¹å¯¹äºè¯¥å†…å­˜è¿›è¡Œçš„æ›´æ”¹å°±ä¼šä¸¢å¤±ã€‚å†æ¬¡å¼ºè°ƒï¼Œå°½ç®¡åœ¨æ­¤ç‰¹å®šç¤ºä¾‹ä¸­ï¼ˆå³åœ¨ç¡¬ä»¶ä¸Šç›´æ¥è¿è¡Œä¸”æ—  Hypervisorï¼‰è¿™ç§åšæ³•æ˜¯å¯è¡Œçš„ï¼Œä½†æ€»çš„æ¥è¯´ï¼Œè¿™å¹¶éä¸€ç§è‰¯å¥½ç­–ç•¥ã€‚</li>
</ul>
</li>
</ul>
</details>
<h1><a class="header" href="#useful-crates" id="useful-crates">Useful crates</a></h1>
<p>æ¥ä¸‹æ¥ä»‹ç»å‡ ä¸ª crateï¼Œç”¨äºè§£å†³è£¸æœºç¼–ç¨‹ä¸­çš„ä¸€äº›å¸¸è§é—®é¢˜ã€‚</p>
<h1><a class="header" href="#zerocopy" id="zerocopy"><code>zerocopy</code></a></h1>
<p><a href="https://docs.rs/zerocopy/"><code>zerocopy</code></a> crateï¼ˆæºè‡ª Fuchsiaï¼‰æä¾›äº† trait å’Œå®ï¼Œç”¨äºç¡®ä¿åœ¨å­—èŠ‚åºåˆ—å’Œå…¶ä»–ç±»å‹ä¹‹é—´è¿›è¡Œå®‰å…¨è½¬æ¢ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use zerocopy::{Immutable, IntoBytes};

#[repr(u32)]
#[derive(Debug, Default, Immutable, IntoBytes)]
enum RequestType {
    #[default]
    In = 0,
    Out = 1,
    Flush = 4,
}

#[repr(C)]
#[derive(Debug, Default, Immutable, IntoBytes)]
struct VirtioBlockRequest {
    request_type: RequestType,
    reserved: u32,
    sector: u64,
}

fn main() {
    let request = VirtioBlockRequest {
        request_type: RequestType::Flush,
        sector: 42,
        ..Default::default()
    };

    assert_eq!(
        request.as_bytes(),
        &amp;[4, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0]
    );
}
</code></pre></pre>
<p>è¿™ä¸é€‚ç”¨äº MMIOï¼ˆå› ä¸ºå®ƒä¸ä½¿ç”¨æ˜“å¤±æ€§è¯»å–å’Œå†™å…¥ï¼‰ï¼Œä½†åœ¨ä¸ç¡¬ä»¶å…±äº«çš„ç»“æ„ï¼ˆä¾‹å¦‚é€šè¿‡ DMA ä¼ è¾“æˆ–å‘é€åˆ°å¤–éƒ¨æ¥å£ï¼‰ä¸­è¿›è¡Œæ“ä½œæ—¶ä¼šå¾ˆæœ‰ç”¨ã€‚</p>
<details>
<ul>
<li>å¯¹äºå¯ä»¥æ¥å—ä»»ä½•å­—èŠ‚æ¨¡å¼çš„ç±»å‹ï¼Œéƒ½å¯ä»¥å®ç° <code>FromBytes</code>æ–¹æ³•ï¼Œå› æ­¤å¯ä»¥å¯¹ä¸å—ä¿¡ä»»çš„å­—èŠ‚åºåˆ—è¿›è¡Œå®‰å…¨è½¬æ¢ã€‚</li>
<li>å¦‚æœå°è¯•ä¸ºè¿™äº›ç±»å‹æ´¾ç”Ÿ <code>FromBytes</code>ï¼Œéƒ½å°†ä¼šå¤±è´¥ï¼Œå› ä¸º <code>RequestType</code> ä¸ä¼šå°†æ‰€æœ‰å¯èƒ½çš„ u32 å€¼ç”¨ä½œåˆ¤åˆ«æ ‡è¯†ï¼Œæ‰€ä»¥å¹¶éæ‰€æœ‰çš„å­—èŠ‚æ¨¡å¼éƒ½æœ‰æ•ˆã€‚</li>
<li><code>zerocopy::byteorder</code> æä¾›äº†é€‚ç”¨äºå­—èŠ‚é¡ºåºæ„ŸçŸ¥çš„æ•°å­—åŸºå…ƒç±»å‹ã€‚</li>
<li>ä½¿ç”¨ <code>src/bare-metal/useful-crates/zerocopy-example/</code> ç›®å½•ä¸‹çš„ <code>cargo run</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚ï¼ˆç”±äºå­˜åœ¨ crate ä¾èµ–é¡¹ï¼Œæ— æ³•åœ¨ Playground ä¸­è¿è¡Œè¯¥ç¤ºä¾‹ã€‚ï¼‰</li>
</ul>
</details>
<h1><a class="header" href="#aarch64-paging" id="aarch64-paging"><code>aarch64-paging</code></a></h1>
<p>å€ŸåŠ© <a href="https://crates.io/crates/aarch64-paging"><code>aarch64-paging</code></a> crateï¼Œæ‚¨å¯æ ¹æ® AArch64 è™šæ‹Ÿå†…å­˜ç³»ç»Ÿæ¶æ„åˆ›å»ºåˆ†é¡µè¡¨ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use aarch64_paging::{
    idmap::IdMap,
    paging::{Attributes, MemoryRegion},
};

const ASID: usize = 1;
const ROOT_LEVEL: usize = 1;

// Create a new page table with identity mapping.
let mut idmap = IdMap::new(ASID, ROOT_LEVEL);
// Map a 2 MiB region of memory as read-only.
idmap.map_range(
    &amp;MemoryRegion::new(0x80200000, 0x80400000),
    Attributes::NORMAL | Attributes::NON_GLOBAL | Attributes::READ_ONLY,
).unwrap();
// Set `TTBR0_EL1` to activate the page table.
idmap.activate();
</code></pre></pre>
<details>
<ul>
<li>ç›®å‰ï¼Œè¯¥æ–¹æ³•ä»…æ”¯æŒ EL1 çº§åˆ«ï¼Œä½†ä¹Ÿå¯ä»¥ç›´æ¥æ·»åŠ å¯¹å…¶ä»–å¼‚å¸¸çº§åˆ«çš„æ”¯æŒã€‚</li>
<li>åœ¨ Android ä¸­ï¼Œè¯¥æ–¹æ³•é€‚ç”¨äº <a href="https://cs.android.com/android/platform/superproject/+/master:packages/modules/Virtualization/pvmfw/">å—ä¿æŠ¤çš„è™šæ‹Ÿæœºå›ºä»¶</a>ã€‚</li>
<li>ç”±äºæ­¤ç¤ºä¾‹éœ€è¦åœ¨çœŸå®ç¡¬ä»¶ä¸Šæˆ–åœ¨ QEMU ä¸­è¿è¡Œï¼Œå› æ­¤æ²¡æœ‰ç®€å•çš„è¿è¡Œæ–¹æ³•å¯ç”¨ã€‚</li>
</ul>
</details>
<h1><a class="header" href="#buddy_system_allocator" id="buddy_system_allocator"><code>buddy_system_allocator</code></a></h1>
<p><a href="https://crates.io/crates/buddy_system_allocator"><code>buddy_system_allocator</code></a> æ˜¯ç¬¬ä¸‰æ–¹ crateï¼Œç”¨äºå®ç°åŸºæœ¬ä¼™ä¼´ç³»ç»Ÿåˆ†é…å™¨ã€‚åŒæ—¶ï¼Œä¹Ÿå¯å°†å…¶ç”¨äº <a href="https://docs.rs/buddy_system_allocator/0.9.0/buddy_system_allocator/struct.LockedHeap.html"><code>LockedHeap</code></a> ä»¥å®ç° <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>ï¼Œè¿™æ ·ä¾¿å¯ä»¥ä½¿ç”¨æ ‡å‡†çš„ <code>alloc</code> crateï¼ˆæ­£å¦‚åœ¨ <a href="bare-metal/useful-crates/../alloc.html">ä¹‹å‰éƒ¨åˆ†</a> ä¸­æ‰€ç¤ºï¼‰ï¼Œæˆ–è€…ç”¨äºåˆ†é…å…¶ä»–åœ°å€ç©ºé—´ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ä¸º PCI BAR åˆ†é… MMIO ç©ºé—´ï¼š</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use buddy_system_allocator::FrameAllocator;
use core::alloc::Layout;

fn main() {
    let mut allocator = FrameAllocator::&lt;32&gt;::new();
    allocator.add_frame(0x200_0000, 0x400_0000);

    let layout = Layout::from_size_align(0x100, 0x100).unwrap();
    let bar = allocator
        .alloc_aligned(layout)
        .expect(&quot;Failed to allocate 0x100 byte MMIO region&quot;);
    println!(&quot;Allocated 0x100 byte MMIO region at {:#x}&quot;, bar);
}
</code></pre></pre>
<details>
<ul>
<li>PCI BAR çš„å¯¹é½æ–¹å¼å§‹ç»ˆä¸å…¶å¤§å°ç›¸ç­‰ã€‚</li>
<li>ä½¿ç”¨ <code>src/bare-metal/useful-crates/allocator-example/</code> ç›®å½•ä¸‹çš„ <code>cargo run</code> è¿è¡Œè¯¥ç¤ºä¾‹ã€‚ï¼ˆç”±äºå­˜åœ¨ crate ä¾èµ–é¡¹ï¼Œæ— æ³•åœ¨ Playground ä¸­è¿è¡Œè¯¥ç¤ºä¾‹ã€‚ï¼‰</li>
</ul>
</details>
<h1><a class="header" href="#tinyvec" id="tinyvec"><code>tinyvec</code></a></h1>
<p>æœ‰æ—¶ï¼Œéœ€è¦ä¸€äº›åƒ <code>Vec</code> ä¸€æ ·èƒ½å¤Ÿè°ƒæ•´å¤§å°çš„ç‰¹æ€§ï¼Œä½†æ— éœ€è¿›è¡Œå †åˆ†é…ã€‚<a href="https://crates.io/crates/tinyvec"><code>tinyvec</code></a> æä¾›äº†ä»¥ä¸‹ç‰¹æ€§ï¼šç”±æ•°ç»„æˆ– slice æ”¯æŒçš„çŸ¢é‡ï¼Œè¯¥çŸ¢é‡æ”¯æŒè¿›è¡Œé™æ€åˆ†é…æˆ–å †åˆ†é…ï¼›ç”¨äºè·Ÿè¸ªä½¿ç”¨çš„å…ƒç´ æ•°é‡ï¼Œå¦‚æœå…ƒç´ ä½¿ç”¨é‡è¶…è¿‡äº†åˆ†é…é¢åº¦ï¼Œåˆ™ä¼šå‡ºç° panicã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tinyvec::{array_vec, ArrayVec};

fn main() {
    let mut numbers: ArrayVec&lt;[u32; 5]&gt; = array_vec!(42, 66);
    println!(&quot;{numbers:?}&quot;);
    numbers.push(7);
    println!(&quot;{numbers:?}&quot;);
    numbers.remove(1);
    println!(&quot;{numbers:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>æ ¹æ® <code>tinyvec</code>è¦æ±‚ï¼Œå…ƒç´ ç±»å‹éœ€å®ç°åˆå§‹åŒ– <code>Default</code>ã€‚</li>
<li>Rust Playground ä¸­åŒ…å« <code>tinyvec</code>ï¼Œå› æ­¤æœ¬ç¤ºä¾‹å°†ä»¥å†…åµŒæ–¹å¼æ­£å¸¸è¿è¡Œã€‚</li>
</ul>
</details>
<h1><a class="header" href="#spin" id="spin"><code>spin</code></a></h1>
<p>åœ¨ <code>core</code> æˆ– <code>alloc</code> ä¸­æ— æ³•ä½¿ç”¨ <code>std::sync::Mutex</code> å’Œ <code>std::sync</code> ä¸­çš„å…¶ä»–åŒæ­¥åŸºå…ƒã€‚é‚£ä¹ˆè¯¥å¦‚ä½•ç®¡ç†åŒæ­¥æˆ–å†…éƒ¨å¯å˜æ€§ï¼Œä¾‹å¦‚åœ¨ä¸åŒ CPU ä¹‹é—´å…±äº«çŠ¶æ€ï¼Ÿ</p>
<p><a href="https://crates.io/crates/spin"><code>spin</code></a> crate ä¸ºè®¸å¤šåŸºå…ƒæä¾›äº†åŸºäºè‡ªæ—‹é”çš„ç­‰æ•ˆæ–¹æ³•ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust editable compile_fail">use spin::mutex::SpinMutex;

static counter: SpinMutex&lt;u32&gt; = SpinMutex::new(0);

fn main() {
    println!(&quot;count: {}&quot;, counter.lock());
    *counter.lock() += 2;
    println!(&quot;count: {}&quot;, counter.lock());
}
</code></pre></pre>
<details>
<ul>
<li>åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­è¿›è¡Œé”å®šæ“ä½œæ—¶ï¼Œè¯·æ³¨æ„é¿å…å‡ºç°æ­»é”çš„æƒ…å†µã€‚</li>
<li><code>spin</code> also has a ticket lock mutex implementation; equivalents of <code>RwLock</code>, <code>Barrier</code> and <code>Once</code> from <code>std::sync</code>; and <code>Lazy</code> for lazy initialisation.</li>
<li><a href="https://crates.io/crates/once_cell"><code>once_cell</code></a> crate ä¹Ÿæä¾›äº†ä¸€äº›é€‚ç”¨äºå»¶è¿Ÿåˆå§‹åŒ–çš„å®ç”¨ç±»å‹ï¼Œå®ƒä»¬ä¸ <code>spin::once::Once</code> æ‰€ç”¨æ–¹æ³•ç•¥æœ‰ä¸åŒã€‚</li>
<li>Rust Playground ä¸­åŒ…å« <code>spin</code>ï¼Œå› æ­¤æœ¬ç¤ºä¾‹å°†ä»¥å†…åµŒæ–¹å¼æ­£å¸¸è¿è¡Œã€‚</li>
</ul>
</details>
<h1><a class="header" href="#bare-metal-on-android" id="bare-metal-on-android">Bare-Metal on Android</a></h1>
<p>å¦‚éœ€åœ¨ AOSP ä¸­æ„å»ºè£¸æœº Rust äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œåº”ä½¿ç”¨ <code>rust_ffi_static</code> Soong è§„åˆ™æ¥æ„å»º Rust ä»£ç ï¼Œç„¶åé€šè¿‡ <code>cc_binary</code> å’Œé“¾æ¥å™¨è„šæœ¬ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶æœ¬èº«ï¼Œå†ä½¿ç”¨ <code>raw_binary</code> å°† ELF è½¬æ¢ä¸ºå¯ä»¥æ­£å¸¸è¿è¡Œçš„åŸå§‹äºŒè¿›åˆ¶æ–‡ä»¶ã€‚</p>
<!-- mdbook-xgettext: skip -->
<pre><code class="language-soong">rust_ffi_static {
    name: &quot;libvmbase_example&quot;,
    defaults: [&quot;vmbase_ffi_defaults&quot;],
    crate_name: &quot;vmbase_example&quot;,
    srcs: [&quot;src/main.rs&quot;],
    rustlibs: [
        &quot;libvmbase&quot;,
    ],
}

cc_binary {
    name: &quot;vmbase_example&quot;,
    defaults: [&quot;vmbase_elf_defaults&quot;],
    srcs: [
        &quot;idmap.S&quot;,
    ],
    static_libs: [
        &quot;libvmbase_example&quot;,
    ],
    linker_scripts: [
        &quot;image.ld&quot;,
        &quot;:vmbase_sections&quot;,
    ],
}

raw_binary {
    name: &quot;vmbase_example_bin&quot;,
    stem: &quot;vmbase_example.bin&quot;,
    src: &quot;:vmbase_example&quot;,
    enabled: false,
    target: {
        android_arm64: {
            enabled: true,
        },
    },
}
</code></pre>
<h1><a class="header" href="#vmbase" id="vmbase">vmbase</a></h1>
<p>For VMs running under crosvm on aarch64, the <a href="https://android.googlesource.com/platform/packages/modules/Virtualization/+/refs/heads/main/libs/libvmbase/">vmbase</a> library provides a linker script and useful defaults for the build rules, along with an entry point, UART console logging and more.</p>
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

use vmbase::{main, println};

main!(main);

pub fn main(arg0: u64, arg1: u64, arg2: u64, arg3: u64) {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>main!</code> å®ç”¨äºæ ‡è®°éœ€ä» <code>vmbase</code> å…¥å£ç‚¹è°ƒç”¨çš„ main å‡½æ•°ã€‚</li>
<li><code>vmbase</code> å…¥å£ç‚¹ç”¨äºå¤„ç†æ§åˆ¶å°åˆå§‹åŒ–ï¼Œå¹¶åœ¨ main å‡½æ•°è¿”å›æ—¶å‘é€ PSCI_SYSTEM_OFF å‘½ä»¤ä»¥å…³é—­è™šæ‹Ÿæœºã€‚</li>
</ul>
</details>
<h1><a class="header" href="#ä¹ é¢˜-1" id="ä¹ é¢˜-1">ä¹ é¢˜</a></h1>
<p>æˆ‘ä»¬å°†ä¸º PL031 å®æ—¶æ—¶é’Ÿè®¾å¤‡ç¼–å†™é©±åŠ¨ç¨‹åºã€‚</p>
<details>
<p>After looking at the exercises, you can look at the <a href="exercises/bare-metal/solutions-afternoon.html">solutions</a> provided.</p>
</details>
<h1><a class="header" href="#rtc-é©±åŠ¨ç¨‹åº" id="rtc-é©±åŠ¨ç¨‹åº">RTC é©±åŠ¨ç¨‹åº</a></h1>
<p>QEMU aarch64 è™šæ‹Ÿæœºåœ¨ 0x9010000 åœ°å€å¤„ é…å¤‡äº† <a href="https://developer.arm.com/documentation/ddi0224/c">PL031</a> å®æ—¶æ—¶é’Ÿã€‚å¯¹äºæœ¬ç»ƒä¹ ï¼Œåº”è¯¥ä¸ºå…¶ç¼–å†™é©±åŠ¨ç¨‹åºã€‚</p>
<ol>
<li>ä½¿ç”¨è¯¥æ—¶é’Ÿå¯å°†å½“å‰æ—¶é—´è¾“å‡ºåˆ°ä¸²è¡Œæ§åˆ¶å°ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ <a href="https://crates.io/crates/chrono"><code>chrono</code></a> crate è®¾ç½®æ—¥æœŸ/æ—¶é—´æ ¼å¼ã€‚</li>
<li>é€šè¿‡åŒ¹é…å¯„å­˜å™¨å’ŒåŸå§‹ä¸­æ–­çŠ¶æ€ï¼Œä½¿å¾—ç³»ç»Ÿåœ¨æŸæ®µæŒ‡å®šçš„æ—¶é—´å†…ä¸€ç›´è¿›è¡Œç¹å¿™ç­‰å¾…ï¼ˆä¾‹å¦‚ 3 ç§’åï¼‰ã€‚ï¼ˆåœ¨å¾ªç¯æ“ä½œä¸­è°ƒç”¨ <a href="https://doc.rust-lang.org/core/hint/fn.spin_loop.html"><code>core::hint::spin_loop</code></a>ã€‚ï¼‰</li>
<li>_è¿›è¡Œæ‰©å±•ï¼ˆå¦‚æœ‰æ—¶é—´ï¼‰ï¼š_å¯ç”¨å¹¶å¤„ç†ç”± RTC åŒ¹é…äº§ç”Ÿçš„ä¸­æ–­ã€‚å¯ä»¥ä½¿ç”¨ <a href="https://docs.rs/arm-gic/"><code>arm-gic</code></a> crate ä¸­æä¾›çš„é©±åŠ¨ç¨‹åºæ¥é…ç½® Arm é€šç”¨ä¸­æ–­æ§åˆ¶å™¨ã€‚
<ul>
<li>è¯·ä½¿ç”¨ RTC ä¸­æ–­ï¼Œå°†å…¶ä½œä¸º <code>IntId::spi(2)</code> è¿æ¥åˆ° GICã€‚</li>
<li>å¯ç”¨ä¸­æ–­åï¼Œå¯ä»¥é€šè¿‡ <code>arm_gic::wfi()</code> è®©æ ¸å¿ƒè¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œç›´åˆ°å®ƒæ”¶åˆ°ä¸­æ–­ä¿¡å·ã€‚</li>
</ul>
</li>
</ol>
<p>ä¸‹è½½ <a href="exercises/bare-metal/../../comprehensive-rust-exercises.zip">ç»ƒä¹ æ¨¡æ¿</a> å¹¶åœ¨ <code>rtc</code> ç›®å½•ä¸­æŸ¥æ‰¾ä»¥ä¸‹æ–‡ä»¶ã€‚</p>
<p><em>src/main.rs</em>:</p>
<!-- File src/main.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;

use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // TODO: Create instance of RTC driver and print current time.

    // TODO: Wait for 3 seconds.

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>src/exceptions.rs</em>ï¼ˆåªéœ€åœ¨æœ¬ç»ƒä¹ çš„ç¬¬ 3 éƒ¨åˆ†æ›´æ”¹æ­¤é¡¹ï¼‰ï¼š</p>
<!-- File src/exceptions.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use arm_gic::gicv3::GicV3;
use log::{error, info, trace};
use smccc::psci::system_off;
use smccc::Hvc;

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_exception_current(_elr: u64, _spsr: u64) {
    error!(&quot;sync_exception_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_current(_elr: u64, _spsr: u64) {
    trace!(&quot;irq_current&quot;);
    let intid =
        GicV3::get_and_acknowledge_interrupt().expect(&quot;No pending interrupt&quot;);
    info!(&quot;IRQ {intid:?}&quot;);
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_current(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_current(_elr: u64, _spsr: u64) {
    error!(&quot;serr_current&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn sync_lower(_elr: u64, _spsr: u64) {
    error!(&quot;sync_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn irq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;irq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn fiq_lower(_elr: u64, _spsr: u64) {
    error!(&quot;fiq_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn serr_lower(_elr: u64, _spsr: u64) {
    error!(&quot;serr_lower&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/logger.rs</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File src/logger.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ANCHOR: main
use crate::pl011::Uart;
use core::fmt::Write;
use log::{LevelFilter, Log, Metadata, Record, SetLoggerError};
use spin::mutex::SpinMutex;

static LOGGER: Logger = Logger { uart: SpinMutex::new(None) };

struct Logger {
    uart: SpinMutex&lt;Option&lt;Uart&gt;&gt;,
}

impl Log for Logger {
    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool {
        true
    }

    fn log(&amp;self, record: &amp;Record) {
        writeln!(
            self.uart.lock().as_mut().unwrap(),
            &quot;[{}] {}&quot;,
            record.level(),
            record.args()
        )
        .unwrap();
    }

    fn flush(&amp;self) {}
}

/// Initialises UART logger.
pub fn init(uart: Uart, max_level: LevelFilter) -&gt; Result&lt;(), SetLoggerError&gt; {
    LOGGER.uart.lock().replace(uart);

    log::set_logger(&amp;LOGGER)?;
    log::set_max_level(max_level);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>src/pl011.rs</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File src/pl011.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(unused)]

use core::fmt::{self, Write};

// ANCHOR: Flags
use bitflags::bitflags;

bitflags! {
    /// Flags from the UART flag register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct Flags: u16 {
        /// Clear to send.
        const CTS = 1 &lt;&lt; 0;
        /// Data set ready.
        const DSR = 1 &lt;&lt; 1;
        /// Data carrier detect.
        const DCD = 1 &lt;&lt; 2;
        /// UART busy transmitting data.
        const BUSY = 1 &lt;&lt; 3;
        /// Receive FIFO is empty.
        const RXFE = 1 &lt;&lt; 4;
        /// Transmit FIFO is full.
        const TXFF = 1 &lt;&lt; 5;
        /// Receive FIFO is full.
        const RXFF = 1 &lt;&lt; 6;
        /// Transmit FIFO is empty.
        const TXFE = 1 &lt;&lt; 7;
        /// Ring indicator.
        const RI = 1 &lt;&lt; 8;
    }
}
// ANCHOR_END: Flags

bitflags! {
    /// Flags from the UART Receive Status Register / Error Clear Register.
    #[repr(transparent)]
    #[derive(Copy, Clone, Debug, Eq, PartialEq)]
    struct ReceiveStatus: u16 {
        /// Framing error.
        const FE = 1 &lt;&lt; 0;
        /// Parity error.
        const PE = 1 &lt;&lt; 1;
        /// Break error.
        const BE = 1 &lt;&lt; 2;
        /// Overrun error.
        const OE = 1 &lt;&lt; 3;
    }
}

// ANCHOR: Registers
#[repr(C, align(4))]
struct Registers {
    dr: u16,
    _reserved0: [u8; 2],
    rsr: ReceiveStatus,
    _reserved1: [u8; 19],
    fr: Flags,
    _reserved2: [u8; 6],
    ilpr: u8,
    _reserved3: [u8; 3],
    ibrd: u16,
    _reserved4: [u8; 2],
    fbrd: u8,
    _reserved5: [u8; 3],
    lcr_h: u8,
    _reserved6: [u8; 3],
    cr: u16,
    _reserved7: [u8; 3],
    ifls: u8,
    _reserved8: [u8; 3],
    imsc: u16,
    _reserved9: [u8; 2],
    ris: u16,
    _reserved10: [u8; 2],
    mis: u16,
    _reserved11: [u8; 2],
    icr: u16,
    _reserved12: [u8; 2],
    dmacr: u8,
    _reserved13: [u8; 3],
}
// ANCHOR_END: Registers

// ANCHOR: Uart
/// Driver for a PL011 UART.
#[derive(Debug)]
pub struct Uart {
    registers: *mut Registers,
}

impl Uart {
    /// Constructs a new instance of the UART driver for a PL011 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL011 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Writes a single byte to the UART.
    pub fn write_byte(&amp;self, byte: u8) {
        // Wait until there is room in the TX buffer.
        while self.read_flag_register().contains(Flags::TXFF) {}

        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe {
            // Write to the TX buffer.
            (&amp;raw mut (*self.registers).dr).write_volatile(byte.into());
        }

        // Wait until the UART is no longer busy.
        while self.read_flag_register().contains(Flags::BUSY) {}
    }

    /// Reads and returns a pending byte, or `None` if nothing has been
    /// received.
    pub fn read_byte(&amp;self) -&gt; Option&lt;u8&gt; {
        if self.read_flag_register().contains(Flags::RXFE) {
            None
        } else {
            // SAFETY: We know that self.registers points to the control
            // registers of a PL011 device which is appropriately mapped.
            let data = unsafe { (&amp;raw const (*self.registers).dr).read_volatile() };
            // TODO: Check for error conditions in bits 8-11.
            Some(data as u8)
        }
    }

    fn read_flag_register(&amp;self) -&gt; Flags {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL011 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).fr).read_volatile() }
    }
}
// ANCHOR_END: Uart

impl Write for Uart {
    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
        for c in s.as_bytes() {
            self.write_byte(*c);
        }
        Ok(())
    }
}

// Safe because it just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Uart {}
<span class="boring">}
</span></code></pre></pre>
<p><em>Cargo.toml</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File Cargo.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[workspace]

[package]
name = &quot;rtc&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
arm-gic = &quot;0.1.2&quot;
bitflags = &quot;2.6.0&quot;
chrono = { version = &quot;0.4.38&quot;, default-features = false }
log = &quot;0.4.22&quot;
smccc = &quot;0.1.1&quot;
spin = &quot;0.9.8&quot;

[build-dependencies]
cc = &quot;1.2.2&quot;
</code></pre>
<p><em>build.rs</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File build.rs -->
<!-- mdbook-xgettext: skip -->
<pre><pre class="playground"><code class="language-rust compile_fail">// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use cc::Build;
use std::env;

fn main() {
    env::set_var(&quot;CROSS_COMPILE&quot;, &quot;aarch64-none-elf&quot;);
    env::set_var(&quot;CC&quot;, &quot;clang&quot;);

    Build::new()
        .file(&quot;entry.S&quot;)
        .file(&quot;exceptions.S&quot;)
        .file(&quot;idmap.S&quot;)
        .compile(&quot;empty&quot;)
}
</code></pre></pre>
<p><em>entry.S</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File entry.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.macro adr_l, reg:req, sym:req
	adrp \reg, \sym
	add \reg, \reg, :lo12:\sym
.endm

.macro mov_i, reg:req, imm:req
	movz \reg, :abs_g3:\imm
	movk \reg, :abs_g2_nc:\imm
	movk \reg, :abs_g1_nc:\imm
	movk \reg, :abs_g0_nc:\imm
.endm

.set .L_MAIR_DEV_nGnRE,	0x04
.set .L_MAIR_MEM_WBWA,	0xff
.set .Lmairval, .L_MAIR_DEV_nGnRE | (.L_MAIR_MEM_WBWA &lt;&lt; 8)

/* 4 KiB granule size for TTBR0_EL1. */
.set .L_TCR_TG0_4KB, 0x0 &lt;&lt; 14
/* 4 KiB granule size for TTBR1_EL1. */
.set .L_TCR_TG1_4KB, 0x2 &lt;&lt; 30
/* Disable translation table walk for TTBR1_EL1, generating a translation fault instead. */
.set .L_TCR_EPD1, 0x1 &lt;&lt; 23
/* Translation table walks for TTBR0_EL1 are inner sharable. */
.set .L_TCR_SH_INNER, 0x3 &lt;&lt; 12
/*
 * Translation table walks for TTBR0_EL1 are outer write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_OWB, 0x1 &lt;&lt; 10
/*
 * Translation table walks for TTBR0_EL1 are inner write-back read-allocate write-allocate
 * cacheable.
 */
.set .L_TCR_RGN_IWB, 0x1 &lt;&lt; 8
/* Size offset for TTBR0_EL1 is 2**39 bytes (512 GiB). */
.set .L_TCR_T0SZ_512, 64 - 39
.set .Ltcrval, .L_TCR_TG0_4KB | .L_TCR_TG1_4KB | .L_TCR_EPD1 | .L_TCR_RGN_OWB
.set .Ltcrval, .Ltcrval | .L_TCR_RGN_IWB | .L_TCR_SH_INNER | .L_TCR_T0SZ_512

/* Stage 1 instruction access cacheability is unaffected. */
.set .L_SCTLR_ELx_I, 0x1 &lt;&lt; 12
/* SP alignment fault if SP is not aligned to a 16 byte boundary. */
.set .L_SCTLR_ELx_SA, 0x1 &lt;&lt; 3
/* Stage 1 data access cacheability is unaffected. */
.set .L_SCTLR_ELx_C, 0x1 &lt;&lt; 2
/* EL0 and EL1 stage 1 MMU enabled. */
.set .L_SCTLR_ELx_M, 0x1 &lt;&lt; 0
/* Privileged Access Never is unchanged on taking an exception to EL1. */
.set .L_SCTLR_EL1_SPAN, 0x1 &lt;&lt; 23
/* SETEND instruction disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_SED, 0x1 &lt;&lt; 8
/* Various IT instructions are disabled at EL0 in aarch32 mode. */
.set .L_SCTLR_EL1_ITD, 0x1 &lt;&lt; 7
.set .L_SCTLR_EL1_RES1, (0x1 &lt;&lt; 11) | (0x1 &lt;&lt; 20) | (0x1 &lt;&lt; 22) | (0x1 &lt;&lt; 28) | (0x1 &lt;&lt; 29)
.set .Lsctlrval, .L_SCTLR_ELx_M | .L_SCTLR_ELx_C | .L_SCTLR_ELx_SA | .L_SCTLR_EL1_ITD | .L_SCTLR_EL1_SED
.set .Lsctlrval, .Lsctlrval | .L_SCTLR_ELx_I | .L_SCTLR_EL1_SPAN | .L_SCTLR_EL1_RES1

/**
 * This is a generic entry point for an image. It carries out the operations required to prepare the
 * loaded image to be run. Specifically, it zeroes the bss section using registers x25 and above,
 * prepares the stack, enables floating point, and sets up the exception vector. It preserves x0-x3
 * for the Rust entry point, as these may contain boot parameters.
 */
.section .init.entry, &quot;ax&quot;
.global entry
entry:
	/* Load and apply the memory management configuration, ready to enable MMU and caches. */
	adrp x30, idmap
	msr ttbr0_el1, x30

	mov_i x30, .Lmairval
	msr mair_el1, x30

	mov_i x30, .Ltcrval
	/* Copy the supported PA range into TCR_EL1.IPS. */
	mrs x29, id_aa64mmfr0_el1
	bfi x30, x29, #32, #4

	msr tcr_el1, x30

	mov_i x30, .Lsctlrval

	/*
	 * Ensure everything before this point has completed, then invalidate any potentially stale
	 * local TLB entries before they start being used.
	 */
	isb
	tlbi vmalle1
	ic iallu
	dsb nsh
	isb

	/*
	 * Configure sctlr_el1 to enable MMU and cache and don't proceed until this has completed.
	 */
	msr sctlr_el1, x30
	isb

	/* Disable trapping floating point access in EL1. */
	mrs x30, cpacr_el1
	orr x30, x30, #(0x3 &lt;&lt; 20)
	msr cpacr_el1, x30
	isb

	/* Zero out the bss section. */
	adr_l x29, bss_begin
	adr_l x30, bss_end
0:	cmp x29, x30
	b.hs 1f
	stp xzr, xzr, [x29], #16
	b 0b

1:	/* Prepare the stack. */
	adr_l x30, boot_stack_end
	mov sp, x30

	/* Set up exception vector. */
	adr x30, vector_table_el1
	msr vbar_el1, x30

	/* Call into Rust code. */
	bl main

	/* Loop forever waiting for interrupts. */
2:	wfi
	b 2b
</code></pre>
<p><em>exceptions.S</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File exceptions.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Saves the volatile registers onto the stack. This currently takes 14
 * instructions, so it can be used in exception handlers with 18 instructions
 * left.
 *
 * On return, x0 and x1 are initialised to elr_el2 and spsr_el2 respectively,
 * which can be used as the first and second arguments of a subsequent call.
 */
.macro save_volatile_to_stack
	/* Reserve stack space and save registers x0-x18, x29 &amp; x30. */
	stp x0, x1, [sp, #-(8 * 24)]!
	stp x2, x3, [sp, #8 * 2]
	stp x4, x5, [sp, #8 * 4]
	stp x6, x7, [sp, #8 * 6]
	stp x8, x9, [sp, #8 * 8]
	stp x10, x11, [sp, #8 * 10]
	stp x12, x13, [sp, #8 * 12]
	stp x14, x15, [sp, #8 * 14]
	stp x16, x17, [sp, #8 * 16]
	str x18, [sp, #8 * 18]
	stp x29, x30, [sp, #8 * 20]

	/*
	 * Save elr_el1 &amp; spsr_el1. This such that we can take nested exception
	 * and still be able to unwind.
	 */
	mrs x0, elr_el1
	mrs x1, spsr_el1
	stp x0, x1, [sp, #8 * 22]
.endm

/**
 * Restores the volatile registers from the stack. This currently takes 14
 * instructions, so it can be used in exception handlers while still leaving 18
 * instructions left; if paired with save_volatile_to_stack, there are 4
 * instructions to spare.
 */
.macro restore_volatile_from_stack
	/* Restore registers x2-x18, x29 &amp; x30. */
	ldp x2, x3, [sp, #8 * 2]
	ldp x4, x5, [sp, #8 * 4]
	ldp x6, x7, [sp, #8 * 6]
	ldp x8, x9, [sp, #8 * 8]
	ldp x10, x11, [sp, #8 * 10]
	ldp x12, x13, [sp, #8 * 12]
	ldp x14, x15, [sp, #8 * 14]
	ldp x16, x17, [sp, #8 * 16]
	ldr x18, [sp, #8 * 18]
	ldp x29, x30, [sp, #8 * 20]

	/* Restore registers elr_el1 &amp; spsr_el1, using x0 &amp; x1 as scratch. */
	ldp x0, x1, [sp, #8 * 22]
	msr elr_el1, x0
	msr spsr_el1, x1

	/* Restore x0 &amp; x1, and release stack space. */
	ldp x0, x1, [sp], #8 * 24
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SP0. It behaves similarly to the SPx case by first switching to SPx, doing
 * the work, then switching back to SP0 before returning.
 *
 * Switching to SPx and calling the Rust handler takes 16 instructions. To
 * restore and return we need an additional 16 instructions, so we can implement
 * the whole handler within the allotted 32 instructions.
 */
.macro current_exception_sp0 handler:req
	msr spsel, #1
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	msr spsel, #0
	eret
.endm

/**
 * This is a generic handler for exceptions taken at the current EL while using
 * SPx. It saves volatile registers, calls the Rust handler, restores volatile
 * registers, then returns.
 *
 * This also works for exceptions taken from EL0, if we don't care about
 * non-volatile registers.
 *
 * Saving state and jumping to the Rust handler takes 15 instructions, and
 * restoring and returning also takes 15 instructions, so we can fit the whole
 * handler in 30 instructions, under the limit of 32.
 */
.macro current_exception_spx handler:req
	save_volatile_to_stack
	bl \handler
	restore_volatile_from_stack
	eret
.endm

.section .text.vector_table_el1, &quot;ax&quot;
.global vector_table_el1
.balign 0x800
vector_table_el1:
sync_cur_sp0:
	current_exception_sp0 sync_exception_current

.balign 0x80
irq_cur_sp0:
	current_exception_sp0 irq_current

.balign 0x80
fiq_cur_sp0:
	current_exception_sp0 fiq_current

.balign 0x80
serr_cur_sp0:
	current_exception_sp0 serr_current

.balign 0x80
sync_cur_spx:
	current_exception_spx sync_exception_current

.balign 0x80
irq_cur_spx:
	current_exception_spx irq_current

.balign 0x80
fiq_cur_spx:
	current_exception_spx fiq_current

.balign 0x80
serr_cur_spx:
	current_exception_spx serr_current

.balign 0x80
sync_lower_64:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_64:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_64:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_64:
	current_exception_spx serr_lower

.balign 0x80
sync_lower_32:
	current_exception_spx sync_lower

.balign 0x80
irq_lower_32:
	current_exception_spx irq_lower

.balign 0x80
fiq_lower_32:
	current_exception_spx fiq_lower

.balign 0x80
serr_lower_32:
	current_exception_spx serr_lower
</code></pre>
<p><em>idmap.S</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰</p>
<!-- File idmap.S -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-armasm">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

.set .L_TT_TYPE_BLOCK, 0x1
.set .L_TT_TYPE_PAGE,  0x3
.set .L_TT_TYPE_TABLE, 0x3

/* Access flag. */
.set .L_TT_AF, 0x1 &lt;&lt; 10
/* Not global. */
.set .L_TT_NG, 0x1 &lt;&lt; 11
.set .L_TT_XN, 0x3 &lt;&lt; 53

.set .L_TT_MT_DEV, 0x0 &lt;&lt; 2			// MAIR #0 (DEV_nGnRE)
.set .L_TT_MT_MEM, (0x1 &lt;&lt; 2) | (0x3 &lt;&lt; 8)	// MAIR #1 (MEM_WBWA), inner shareable

.set .L_BLOCK_DEV, .L_TT_TYPE_BLOCK | .L_TT_MT_DEV | .L_TT_AF | .L_TT_XN
.set .L_BLOCK_MEM, .L_TT_TYPE_BLOCK | .L_TT_MT_MEM | .L_TT_AF | .L_TT_NG

.section &quot;.rodata.idmap&quot;, &quot;a&quot;, %progbits
.global idmap
.align 12
idmap:
	/* level 1 */
	.quad		.L_BLOCK_DEV | 0x0		    // 1 GiB of device mappings
	.quad		.L_BLOCK_MEM | 0x40000000	// 1 GiB of DRAM
	.fill		254, 8, 0x0			// 254 GiB of unmapped VA space
	.quad		.L_BLOCK_DEV | 0x4000000000 // 1 GiB of device mappings
	.fill		255, 8, 0x0			// 255 GiB of remaining VA space
</code></pre>
<p><em>image.ld</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File image.ld -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-ld">/*
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Code will start running at this symbol which is placed at the start of the
 * image.
 */
ENTRY(entry)

MEMORY
{
	image : ORIGIN = 0x40080000, LENGTH = 2M
}

SECTIONS
{
	/*
	 * Collect together the code.
	 */
	.init : ALIGN(4096) {
		text_begin = .;
		*(.init.entry)
		*(.init.*)
	} &gt;image
	.text : {
		*(.text.*)
	} &gt;image
	text_end = .;

	/*
	 * Collect together read-only data.
	 */
	.rodata : ALIGN(4096) {
		rodata_begin = .;
		*(.rodata.*)
	} &gt;image
	.got : {
		*(.got)
	} &gt;image
	rodata_end = .;

	/*
	 * Collect together the read-write data including .bss at the end which
	 * will be zero'd by the entry code.
	 */
	.data : ALIGN(4096) {
		data_begin = .;
		*(.data.*)
		/*
		 * The entry point code assumes that .data is a multiple of 32
		 * bytes long.
		 */
		. = ALIGN(32);
		data_end = .;
	} &gt;image

	/* Everything beyond this point will not be included in the binary. */
	bin_end = .;

	/* The entry point code assumes that .bss is 16-byte aligned. */
	.bss : ALIGN(16)  {
		bss_begin = .;
		*(.bss.*)
		*(COMMON)
		. = ALIGN(16);
		bss_end = .;
	} &gt;image

	.stack (NOLOAD) : ALIGN(4096) {
		boot_stack_begin = .;
		. += 40 * 4096;
		. = ALIGN(4096);
		boot_stack_end = .;
	} &gt;image

	. = ALIGN(4K);
	PROVIDE(dma_region = .);

	/*
	 * Remove unused sections from the image.
	 */
	/DISCARD/ : {
		/* The image loads itself so doesn't need these sections. */
		*(.gnu.hash)
		*(.hash)
		*(.interp)
		*(.eh_frame_hdr)
		*(.eh_frame)
		*(.note.gnu.build-id)
	}
}
</code></pre>
<p><em>Makefile</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File Makefile -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-makefile"># Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

.PHONY: build qemu_minimal qemu qemu_logger

all: rtc.bin

build:
	cargo build

rtc.bin: build
	cargo objcopy -- -O binary $@

qemu: rtc.bin
	qemu-system-aarch64 -machine virt,gic-version=3 -cpu max -serial mon:stdio -display none -kernel $&lt; -s

clean:
	cargo clean
	rm -f *.bin
</code></pre>
<p><em>.cargo/config.toml</em>ï¼ˆæ— éœ€å¯¹æ­¤è¿›è¡Œæ›´æ”¹ï¼‰ï¼š</p>
<!-- File .cargo/config.toml -->
<!-- mdbook-xgettext: skip -->
<pre><code class="language-toml">[build]
target = &quot;aarch64-unknown-none&quot;
rustflags = [&quot;-C&quot;, &quot;link-arg=-Timage.ld&quot;]
</code></pre>
<p>ä½¿ç”¨ <code>make qemu</code> åœ¨ QEMU ä¸­è¿è¡Œä»£ç ã€‚</p>
<h1><a class="header" href="#åµŒå…¥å¼-rustè¿›é˜¶ç¯‡" id="åµŒå…¥å¼-rustè¿›é˜¶ç¯‡">åµŒå…¥å¼ Rustï¼šè¿›é˜¶ç¯‡</a></h1>
<h2><a class="header" href="#rtc-é©±åŠ¨ç¨‹åº-1" id="rtc-é©±åŠ¨ç¨‹åº-1">RTC é©±åŠ¨ç¨‹åº</a></h2>
<p>(<a href="exercises/bare-metal/rtc.html">è¿”å›ç»ƒä¹ </a>)</p>
<p><em>main.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#![no_main]
#![no_std]

mod exceptions;
mod logger;
mod pl011;
mod pl031;

use crate::pl031::Rtc;
use arm_gic::gicv3::{IntId, Trigger};
use arm_gic::{irq_enable, wfi};
use chrono::{TimeZone, Utc};
use core::hint::spin_loop;
use crate::pl011::Uart;
use arm_gic::gicv3::GicV3;
use core::panic::PanicInfo;
use log::{error, info, trace, LevelFilter};
use smccc::psci::system_off;
use smccc::Hvc;

/// Base addresses of the GICv3.
const GICD_BASE_ADDRESS: *mut u64 = 0x800_0000 as _;
const GICR_BASE_ADDRESS: *mut u64 = 0x80A_0000 as _;

/// Base address of the primary PL011 UART.
const PL011_BASE_ADDRESS: *mut u32 = 0x900_0000 as _;

/// Base address of the PL031 RTC.
const PL031_BASE_ADDRESS: *mut u32 = 0x901_0000 as _;
/// The IRQ used by the PL031 RTC.
const PL031_IRQ: IntId = IntId::spi(2);

// SAFETY: There is no other global function of this name.
#[unsafe(no_mangle)]
extern &quot;C&quot; fn main(x0: u64, x1: u64, x2: u64, x3: u64) {
    // SAFETY: `PL011_BASE_ADDRESS` is the base address of a PL011 device, and
    // nothing else accesses that address range.
    let uart = unsafe { Uart::new(PL011_BASE_ADDRESS) };
    logger::init(uart, LevelFilter::Trace).unwrap();

    info!(&quot;main({:#x}, {:#x}, {:#x}, {:#x})&quot;, x0, x1, x2, x3);

    // SAFETY: `GICD_BASE_ADDRESS` and `GICR_BASE_ADDRESS` are the base
    // addresses of a GICv3 distributor and redistributor respectively, and
    // nothing else accesses those address ranges.
    let mut gic = unsafe { GicV3::new(GICD_BASE_ADDRESS, GICR_BASE_ADDRESS) };
    gic.setup();

    // SAFETY: `PL031_BASE_ADDRESS` is the base address of a PL031 device, and
    // nothing else accesses that address range.
    let mut rtc = unsafe { Rtc::new(PL031_BASE_ADDRESS) };
    let timestamp = rtc.read();
    let time = Utc.timestamp_opt(timestamp.into(), 0).unwrap();
    info!(&quot;RTC: {time}&quot;);

    GicV3::set_priority_mask(0xff);
    gic.set_interrupt_priority(PL031_IRQ, 0x80);
    gic.set_trigger(PL031_IRQ, Trigger::Level);
    irq_enable();
    gic.enable_interrupt(PL031_IRQ, true);

    // Wait for 3 seconds, without interrupts.
    let target = timestamp + 3;
    rtc.set_match(target);
    info!(&quot;Waiting for {}&quot;, Utc.timestamp_opt(target.into(), 0).unwrap());
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.matched() {
        spin_loop();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    // Wait another 3 seconds for an interrupt.
    let target = timestamp + 6;
    info!(&quot;Waiting for {}&quot;, Utc.timestamp_opt(target.into(), 0).unwrap());
    rtc.set_match(target);
    rtc.clear_interrupt();
    rtc.enable_interrupt(true);
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    while !rtc.interrupt_pending() {
        wfi();
    }
    trace!(
        &quot;matched={}, interrupt_pending={}&quot;,
        rtc.matched(),
        rtc.interrupt_pending()
    );
    info!(&quot;Finished waiting&quot;);

    system_off::&lt;Hvc&gt;().unwrap();
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    error!(&quot;{info}&quot;);
    system_off::&lt;Hvc&gt;().unwrap();
    loop {}
}
</code></pre></pre>
<p><em>pl031.rs</em>ï¼š</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, align(4))]
struct Registers {
    /// Data register
    dr: u32,
    /// Match register
    mr: u32,
    /// Load register
    lr: u32,
    /// Control register
    cr: u8,
    _reserved0: [u8; 3],
    /// Interrupt Mask Set or Clear register
    imsc: u8,
    _reserved1: [u8; 3],
    /// Raw Interrupt Status
    ris: u8,
    _reserved2: [u8; 3],
    /// Masked Interrupt Status
    mis: u8,
    _reserved3: [u8; 3],
    /// Interrupt Clear Register
    icr: u8,
    _reserved4: [u8; 3],
}

/// Driver for a PL031 real-time clock.
#[derive(Debug)]
pub struct Rtc {
    registers: *mut Registers,
}

impl Rtc {
    /// Constructs a new instance of the RTC driver for a PL031 device at the
    /// given base address.
    ///
    /// # Safety
    ///
    /// The given base address must point to the MMIO control registers of a
    /// PL031 device, which must be mapped into the address space of the process
    /// as device memory and not have any other aliases.
    pub unsafe fn new(base_address: *mut u32) -&gt; Self {
        Self { registers: base_address as *mut Registers }
    }

    /// Reads the current RTC value.
    pub fn read(&amp;self) -&gt; u32 {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw const (*self.registers).dr).read_volatile() }
    }

    /// Writes a match value. When the RTC value matches this then an interrupt
    /// will be generated (if it is enabled).
    pub fn set_match(&amp;mut self, value: u32) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).mr).write_volatile(value) }
    }

    /// Returns whether the match register matches the RTC value, whether or not
    /// the interrupt is enabled.
    pub fn matched(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { (&amp;raw const (*self.registers).ris).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Returns whether there is currently an interrupt pending.
    ///
    /// This should be true if and only if `matched` returns true and the
    /// interrupt is masked.
    pub fn interrupt_pending(&amp;self) -&gt; bool {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        let ris = unsafe { (&amp;raw const (*self.registers).mis).read_volatile() };
        (ris &amp; 0x01) != 0
    }

    /// Sets or clears the interrupt mask.
    ///
    /// When the mask is true the interrupt is enabled; when it is false the
    /// interrupt is disabled.
    pub fn enable_interrupt(&amp;mut self, mask: bool) {
        let imsc = if mask { 0x01 } else { 0x00 };
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).imsc).write_volatile(imsc) }
    }

    /// Clears a pending interrupt, if any.
    pub fn clear_interrupt(&amp;mut self) {
        // SAFETY: We know that self.registers points to the control registers
        // of a PL031 device which is appropriately mapped.
        unsafe { (&amp;raw mut (*self.registers).icr).write_volatile(0x01) }
    }
}

// SAFETY: `Rtc` just contains a pointer to device memory, which can be
// accessed from any context.
unsafe impl Send for Rtc {}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘" id="æ¬¢è¿äº†è§£-rust-ä¸­çš„å¹¶å‘">æ¬¢è¿äº†è§£ Rust ä¸­çš„å¹¶å‘</a></h1>
<p>Rust å®Œå…¨æ”¯æŒä½¿ç”¨å¸¦æœ‰äº’æ–¥é”å’Œé€šé“çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹è¿›è¡Œå¹¶å‘ã€‚</p>
<p>Rust ç±»å‹ç³»ç»Ÿèƒ½å¸®åŠ©æˆ‘ä»¬æŠŠè®¸å¤šå¹¶å‘bugè½¬æ¢ä¸ºç¼–è¯‘æœŸbug å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è¿™é€šå¸¸ç§°ä¸ºâ€œæ— ç•å¹¶å‘â€ï¼Œå› ä¸ºä½ å¯ä»¥ä¾é ç¼–è¯‘å™¨æ¥ç¡®ä¿ è¿è¡Œæ—¶çš„æ­£ç¡®æ€§ã€‚</p>
<h2><a class="header" href="#æ—¶é—´è¡¨-4" id="æ—¶é—´è¡¨-4">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<details>
<ul>
<li>Rust lets us access OS concurrency toolkit: threads, sync. primitives, etc.</li>
<li>The type system gives us safety for concurrency without any special features.</li>
<li>The same tools that help with &quot;concurrent&quot; access in a single thread (e.g., a called function that might mutate an argument or save references to it to read later) save us from multi-threading issues.</li>
</ul>
</details><h1><a class="header" href="#çº¿ç¨‹" id="çº¿ç¨‹">çº¿ç¨‹</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#plain-threads" id="plain-threads">Plain Threads</a></h1>
<p>Rust çº¿ç¨‹çš„è¿ä½œæ–¹å¼ä¸å…¶ä»–è¯­è¨€ä¸­çš„çº¿ç¨‹ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 0..10 {
            println!(&quot;Count in thread: {i}!&quot;);
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 0..5 {
        println!(&quot;Main thread: {i}&quot;);
        thread::sleep(Duration::from_millis(5));
    }
}
</code></pre></pre>
<ul>
<li>Spawning new threads does not automatically delay program termination at the end of <code>main</code>.</li>
<li>çº¿ç¨‹ç´§æ€¥è­¦æŠ¥ (panic) æ˜¯å½¼æ­¤ç‹¬ç«‹çš„ã€‚
<ul>
<li>Panics can carry a payload, which can be unpacked with <a href="https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref"><code>Any::downcast_ref</code></a>.</li>
</ul>
</li>
</ul>
<details>
<ul>
<li>
<p>Run the example.</p>
<ul>
<li>5ms timing is loose enough that main and spawned threads stay mostly in lockstep.</li>
<li>Notice that the program ends before the spawned thread reaches 10!</li>
<li>This is because <code>main</code> ends the program and spawned threads do not make it persist.
<ul>
<li>Compare to <code>pthreads</code>/C++ <code>std::thread</code>/<code>boost::thread</code> if desired.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How do we wait around for the spawned thread to complete?</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a> returns a <code>JoinHandle</code>. Look at the docs.</p>
<ul>
<li><code>JoinHandle</code> has a <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> method that blocks.</li>
</ul>
</li>
<li>
<p>Use <code>let handle = thread::spawn(...)</code> and later <code>handle.join()</code> to wait for the thread to finish and have the program count all the way to 10.</p>
</li>
<li>
<p>Now what if we want to return a value?</p>
</li>
<li>
<p>Look at docs again:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>'s closure returns <code>T</code></li>
<li><code>JoinHandle</code> <a href="https://doc.rust-lang.org/std/thread/struct.JoinHandle.html#method.join"><code>.join()</code></a> returns <code>thread::Result&lt;T&gt;</code></li>
</ul>
</li>
<li>
<p>Use the <code>Result</code> return value from <code>handle.join()</code> to get access to the returned value.</p>
</li>
<li>
<p>Ok, what about the other case?</p>
<ul>
<li>Trigger a panic in the thread. Note that this doesn't panic <code>main</code>.</li>
<li>Access the panic payload. This is a good time to talk about <a href="https://doc.rust-lang.org/std/any/index.html"><code>Any</code></a>.</li>
</ul>
</li>
<li>
<p>Now we can return values from threads! What about taking inputs?</p>
<ul>
<li>Capture something by reference in the thread closure.</li>
<li>An error message indicates we must move it.</li>
<li>Move it in, see we can compute and then return a derived value.</li>
</ul>
</li>
<li>
<p>If we want to borrow?</p>
<ul>
<li>Main kills child threads when it returns, but another function would just return and leave them running.</li>
<li>That would be stack use-after-return, which violates memory safety!</li>
<li>How do we avoid this? See next slide.</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#èŒƒå›´çº¿ç¨‹" id="èŒƒå›´çº¿ç¨‹">èŒƒå›´çº¿ç¨‹</a></h1>
<p>å¸¸è§„çº¿ç¨‹ä¸èƒ½ä»å®ƒä»¬æ‰€å¤„çš„ç¯å¢ƒä¸­å€Ÿç”¨ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::spawn(|| {
        println!(&quot;Length: {}&quot;, s.len());
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<p>ä¸è¿‡ï¼Œä½ å¯ä»¥ä½¿ç”¨<a href="https://doc.rust-lang.org/std/thread/fn.scope.html">èŒƒå›´çº¿ç¨‹</a>æ¥å®ç°æ­¤ç›®çš„ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn foo() {
    let s = String::from(&quot;Hello&quot;);
    thread::scope(|scope| {
        scope.spawn(|| {
            println!(&quot;Length: {}&quot;, s.len());
        });
    });
}

fn main() {
    foo();
}
</code></pre></pre>
<details>
<ul>
<li>å…¶åŸå› åœ¨äºï¼Œåœ¨ <code>thread::scope</code> å‡½æ•°å®Œæˆåï¼Œå¯ä¿è¯æ‰€æœ‰çº¿ç¨‹éƒ½å·²è”ç»“åœ¨ä¸€èµ·ï¼Œä½¿å¾—çº¿ç¨‹èƒ½å¤Ÿè¿”å›å€Ÿç”¨çš„æ•°æ®ã€‚</li>
<li>æ­¤æ—¶é¡»éµå®ˆå¸¸è§„ Rust å€Ÿç”¨è§„åˆ™ï¼šä½ å¯ä»¥é€šè¿‡ä¸€ä¸ªçº¿ç¨‹ä»¥å¯å˜çš„æ–¹å¼å€Ÿç”¨ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä»»æ„æ•°é‡çš„çº¿ç¨‹ä»¥ä¸å¯å˜çš„æ–¹å¼å€Ÿç”¨ã€‚</li>
</ul>
</details><h1><a class="header" href="#é€šé“" id="é€šé“">é€šé“</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#senders-and-receivers" id="senders-and-receivers">Senders and Receivers</a></h1>
<p>Rust channels have two parts: a <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html"><code>Sender&lt;T&gt;</code></a> and a <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html"><code>Receiver&lt;T&gt;</code></a>. The two parts are connected via the channel, but you only see the end-points.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    tx.send(10).unwrap();
    tx.send(20).unwrap();

    println!(&quot;Received: {:?}&quot;, rx.recv());
    println!(&quot;Received: {:?}&quot;, rx.recv());

    let tx2 = tx.clone();
    tx2.send(30).unwrap();
    println!(&quot;Received: {:?}&quot;, rx.recv());
}
</code></pre></pre>
<details>
<ul>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>mpsc</code></a> stands for Multi-Producer, Single-Consumer. <code>Sender</code> and <code>SyncSender</code> implement <code>Clone</code> (so you can make multiple producers) but <code>Receiver</code> does not.</li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send"><code>send()</code></a> and <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv()</code></a> return <code>Result</code>. If they return <code>Err</code>, it means the counterpart <code>Sender</code> or <code>Receiver</code> is dropped and the channel is closed.</li>
</ul>
</details>
<h1><a class="header" href="#æ— ç•Œé€šé“" id="æ— ç•Œé€šé“">æ— ç•Œé€šé“</a></h1>
<p>You get an unbounded and asynchronous channel with <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#æœ‰ç•Œé€šé“" id="æœ‰ç•Œé€šé“">æœ‰ç•Œé€šé“</a></h1>
<p>With bounded (synchronous) channels, <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.SyncSender.html#method.send"><code>send()</code></a> can block the current thread:</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::sync_channel(3);

    thread::spawn(move || {
        let thread_id = thread::current().id();
        for i in 0..10 {
            tx.send(format!(&quot;Message {i}&quot;)).unwrap();
            println!(&quot;{thread_id:?}: sent Message {i}&quot;);
        }
        println!(&quot;{thread_id:?}: done&quot;);
    });
    thread::sleep(Duration::from_millis(100));

    for msg in rx.iter() {
        println!(&quot;Main: got {msg}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>Calling <code>send()</code> will block the current thread until there is space in the channel for the new message. The thread can be blocked indefinitely if there is nobody who reads from the channel.</li>
<li>A call to <code>send()</code> will abort with an error (that is why it returns <code>Result</code>) if the channel is closed. A channel is closed when the receiver is dropped.</li>
<li>A bounded channel with a size of zero is called a &quot;rendezvous channel&quot;. Every send will block the current thread until another thread calls <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>recv()</code></a>.</li>
</ul>
</details>
<h1><a class="header" href="#send-å’Œ-sync" id="send-å’Œ-sync"><code>Send</code> å’Œ <code>Sync</code></a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#marker-traits" id="marker-traits">Marker Traits</a></h1>
<p>How does Rust know to forbid shared access across threads? The answer is in two traits:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>ï¼šå¦‚æœè·¨çº¿ç¨‹è¾¹ç•Œç§»åŠ¨ <code>T</code> æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <code>Send</code>ã€‚</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>ï¼šå¦‚æœè·¨çº¿ç¨‹è¾¹ç•Œç§»åŠ¨ <code>&amp;T</code> æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <code>Sync</code>ã€‚</li>
</ul>
<p><code>Send</code> and <code>Sync</code> are <a href="concurrency/send-sync/../../unsafe-rust/unsafe-traits.html">unsafe traits</a>. The compiler will automatically derive them for your types as long as they only contain <code>Send</code> and <code>Sync</code> types. You can also implement them manually when you know it is valid.</p>
<details>
<ul>
<li>ä¸å¦¨å°†è¿™äº›ç‰¹å¾è§†ä¸ºç±»å‹åŒ…å«æŸäº›çº¿ç¨‹å®‰å…¨å±æ€§çš„æ ‡è®°ã€‚</li>
<li>å®ƒä»¬å¯ä»¥åœ¨æ³›å‹çº¦æŸä¸­ä½œä¸ºå¸¸è§„ç‰¹å¾ä½¿ç”¨ã€‚</li>
</ul>
</details><h1><a class="header" href="#send" id="send"><code>Send</code></a></h1>
<blockquote>
<p>å¦‚æœå°† <code>T</code> å€¼ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>ã€‚</p>
</blockquote>
<p>å°†æ‰€æœ‰æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹çš„å½±å“æ˜¯ï¼Œâ€œææ„å‡½æ•°â€å°†åœ¨ç›¸åº”çº¿ç¨‹ä¸­ è¿è¡Œã€‚å› æ­¤ï¼Œé—®é¢˜åœ¨äºä½ ä½•æ—¶å¯ä»¥åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­åˆ†é…æŸä¸ªå€¼ï¼Œç„¶ååœ¨ å¦ä¸€ä¸ªçº¿ç¨‹ä¸­å–æ¶ˆåˆ†é…è¯¥å€¼ã€‚</p>
<details>
<p>ä¾‹å¦‚ï¼Œä¸ SQLite åº“çš„è¿æ¥åªèƒ½é€šè¿‡ å•ä¸ªçº¿ç¨‹è®¿é—®ã€‚</p>
</details><h1><a class="header" href="#sync" id="sync"><code>Sync</code></a></h1>
<blockquote>
<p>å¦‚æœåŒæ—¶ä»å¤šä¸ªçº¿ç¨‹è®¿é—® <code>T</code> å€¼æ˜¯å®‰å…¨çš„ï¼Œåˆ™ç±»å‹ <code>T</code> ä¸º <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>ã€‚</p>
</blockquote>
<p>æ›´å‡†ç¡®åœ°è¯´ï¼Œå®šä¹‰æ˜¯ï¼š</p>
<blockquote>
<p>å½“ä¸”ä»…å½“ <code>&amp;T</code> ä¸º <code>Send</code> æ—¶ï¼Œ<code>T</code> ä¸º <code>Sync</code></p>
</blockquote>
<details>
<p>è¯¥è¯­å¥å®è´¨ä¸Šæ˜¯ä¸€ç§ç®€å†™å½¢å¼ï¼Œè¡¨ç¤ºå¦‚æœæŸä¸ªç±»å‹å¯¹äºå…±äº«ä½¿ç”¨æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé‚£ä¹ˆè·¨çº¿ç¨‹ä¼ é€’å¯¹è¯¥ç±»å‹çš„å¼•ç”¨ä¹Ÿæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚</p>
<p>è¿™æ˜¯å› ä¸ºå¦‚æœæŸä¸ªç±»å‹ä¸º Syncï¼Œåˆ™æ„å‘³ç€å®ƒå¯ä»¥åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«ï¼Œè€Œä¸å­˜åœ¨æ•°æ®äº‰ç”¨æˆ–å…¶ä»–åŒæ­¥é—®é¢˜çš„é£é™©ï¼Œå› æ­¤å°†å…¶ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ˜¯å®‰å…¨çš„ã€‚å¯¹è¯¥ç±»å‹çš„å¼•ç”¨åŒæ ·å¯ä»¥å®‰å…¨åœ°ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œå› ä¸ºå®ƒå¼•ç”¨çš„æ•°æ®å¯ä»¥ä»ä»»ä½•çº¿ç¨‹å®‰å…¨åœ°è®¿é—®ã€‚</p>
</details><h1><a class="header" href="#ç¤ºä¾‹-2" id="ç¤ºä¾‹-2">ç¤ºä¾‹</a></h1>
<h2><a class="header" href="#send--sync" id="send--sync"><code>Send + Sync</code></a></h2>
<p>ä½ é‡åˆ°çš„ç±»å‹å¤§éƒ½å±äº <code>Send + Sync</code>ï¼š</p>
<ul>
<li><code>i8</code>ã€<code>f32</code>ã€<code>bool</code>ã€<code>char</code>ã€<code>&amp;str</code>â€¦</li>
<li><code>(T1, T2)</code>ã€<code>[T; N]</code>ã€<code>&amp;[T]</code>ã€<code>struct { x: T }</code>â€¦</li>
<li><code>String</code>ã€<code>Option&lt;T&gt;</code>ã€<code>Vec&lt;T&gt;</code>ã€<code>Box&lt;T&gt;</code>â€¦</li>
<li><code>Arc&lt;T&gt;</code>ï¼šæ˜ç¡®é€šè¿‡åŸå­å¼•ç”¨è®¡æ•°å®ç°çº¿ç¨‹å®‰å…¨ã€‚</li>
<li><code>Mutex&lt;T&gt;</code>ï¼šæ˜ç¡®é€šè¿‡å†…éƒ¨é”å®šå®ç°çº¿ç¨‹å®‰å…¨ã€‚</li>
<li><code>mpsc::Sender&lt;T&gt;</code>: As of 1.72.0.</li>
<li><code>AtomicBool</code>ã€<code>AtomicU8</code>â€¦ï¼šä½¿ç”¨ç‰¹æ®Šçš„åŸå­æŒ‡ä»¤ã€‚</li>
</ul>
<p>å½“ç±»å‹å‚æ•°ä¸º <code>Send + Sync</code> æ—¶ï¼Œæ³›å‹ç±»å‹é€šå¸¸ ä¸º <code>Send + Sync</code>ã€‚</p>
<h2><a class="header" href="#send--sync-1" id="send--sync-1"><code>Send + !Sync</code></a></h2>
<p>è¿™äº›ç±»å‹å¯ä»¥ç§»åŠ¨åˆ°å…¶ä»–çº¿ç¨‹ï¼Œä½†å®ƒä»¬ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ è¿™é€šå¸¸æ˜¯ç”±å†…éƒ¨å¯å˜æ€§é€ æˆçš„ï¼š</p>
<ul>
<li><code>mpsc::Receiver&lt;T&gt;</code></li>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<h2><a class="header" href="#send--sync-2" id="send--sync-2"><code>!Send + Sync</code></a></h2>
<p>These types are safe to access (via shared references) from multiple threads, but they cannot be moved to another thread:</p>
<ul>
<li><code>MutexGuard&lt;T: Sync&gt;</code>: Uses OS level primitives which must be deallocated on the thread which created them. However, an already-locked mutex can have its guarded variable read by any thread with which the guard is shared.</li>
</ul>
<h2><a class="header" href="#send--sync-3" id="send--sync-3"><code>!Send + !Sync</code></a></h2>
<p>è¿™äº›ç±»å‹ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä¸èƒ½ç§»åŠ¨åˆ°å…¶ä»–çº¿ç¨‹ï¼š</p>
<ul>
<li><code>Rc&lt;T&gt;</code>ï¼šæ¯ä¸ª <code>Rc&lt;T&gt;</code> éƒ½å…·æœ‰å¯¹ <code>RcBox&lt;T&gt;</code> çš„å¼•ç”¨ï¼Œå…¶ä¸­åŒ…å« éåŸå­å¼•ç”¨è®¡æ•°ã€‚</li>
<li><code>*const T</code>ã€<code>*mut T</code>ï¼šRust ä¼šå‡å®šåŸå§‹æŒ‡é’ˆå¯èƒ½ åœ¨å¹¶å‘æ–¹é¢æœ‰ç‰¹æ®Šçš„æ³¨æ„äº‹é¡¹ã€‚</li>
</ul>
<h1><a class="header" href="#å…±äº«çŠ¶æ€" id="å…±äº«çŠ¶æ€">å…±äº«çŠ¶æ€</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#arc" id="arc"><code>Arc</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> å…è®¸é€šè¿‡ <code>Arc::clone</code> å®ç°å…±äº«åªè¯»æƒé™ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Arc;
use std::thread;

fn main() {
    let v = Arc::new(vec![10, 20, 30]);
    let mut handles = Vec::new();
    for _ in 0..5 {
        let v = Arc::clone(&amp;v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(&quot;{thread_id:?}: {v:?}&quot;);
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<ul>
<li><code>Arc</code> ä»£è¡¨â€œåŸå­å¼•ç”¨è®¡æ•°â€ï¼Œå®ƒæ˜¯ä½¿ç”¨åŸå­æ“ä½œçš„ <code>Rc</code> çš„ çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ã€‚</li>
<li><code>Arc&lt;T&gt;</code> implements <code>Clone</code> whether or not <code>T</code> does. It implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements them both.</li>
<li><code>Arc::clone()</code> åœ¨æ‰§è¡ŒåŸå­æ“ä½œæ–¹é¢æœ‰å¼€é”€ï¼Œä½†åœ¨æ­¤ä¹‹åï¼Œ<code>T</code> ä¾¿å¯ éšæ„ä½¿ç”¨ï¼Œè€Œæ²¡æœ‰ä»»ä½•å¼€é”€ã€‚</li>
<li>è¯·è­¦æƒ•å¼•ç”¨å¾ªç¯ï¼Œ<code>Arc</code> ä¸ä¼šä½¿ç”¨åƒåœ¾å›æ”¶å™¨æ£€æµ‹å¼•ç”¨å¾ªç¯ã€‚
<ul>
<li><code>std::sync::Weak</code> å¯¹æ­¤æœ‰æ‰€å¸®åŠ©ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#äº’æ–¥å™¨mutex" id="äº’æ–¥å™¨mutex">äº’æ–¥å™¨ï¼ˆ<code>Mutex</code>ï¼‰</a></h1>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> ensures mutual exclusion <em>and</em> allows mutable access to <code>T</code> behind a read-only interface (another form of <a href="concurrency/shared-state/../../borrowing/interior-mutability.html">interior mutability</a>):</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Mutex;

fn main() {
    let v = Mutex::new(vec![10, 20, 30]);
    println!(&quot;v: {:?}&quot;, v.lock().unwrap());

    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }

    println!(&quot;v: {:?}&quot;, v.lock().unwrap());
}
</code></pre></pre>
<p>è¯·æ³¨æ„æˆ‘ä»¬å¦‚ä½•è®¾ç½® <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#impl-Sync-for-Mutex%3CT%3E"><code>impl&lt;T: Send&gt; Sync for Mutex&lt;T&gt;</code></a> é€šç”¨ å®ç°ã€‚</p>
<details>
<ul>
<li><code>Mutex</code> in Rust looks like a collection with just one element --- the protected data.
<ul>
<li>åœ¨è®¿é—®å—ä¿æŠ¤çš„æ•°æ®ä¹‹å‰ä¸å¯èƒ½å¿˜è®°è·å–äº’æ–¥é‡ã€‚</li>
</ul>
</li>
<li>ä½ å¯ä»¥é€šè¿‡è·å–é”ï¼Œä» <code>&amp;Mutex&lt;T&gt;</code> ä¸­è·å– <code>&amp;mut T</code>ã€‚<code>MutexGuard</code> èƒ½å¤Ÿç¡®ä¿ <code>&amp;mut T</code> å­˜åœ¨çš„æ—¶é—´ä¸ä¼šæ¯”æŒæœ‰é”çš„æ—¶é—´æ›´é•¿ã€‚</li>
<li><code>Mutex&lt;T&gt;</code> implements both <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements <code>Send</code>.</li>
<li>A read-write lock counterpart: <code>RwLock</code>.</li>
<li>Why does <code>lock()</code> return a <code>Result</code>?
<ul>
<li>å¦‚æœæŒæœ‰ <code>Mutex</code> çš„çº¿ç¨‹å‘ç”Ÿpanicï¼Œ<code>Mutex</code> ä¾¿ä¼šâ€œä¸­æ¯’â€å¹¶å‘å‡ºä¿¡å·ï¼Œ è¡¨æ˜å…¶æ‰€ä¿æŠ¤çš„æ•°æ®å¯èƒ½å¤„äºä¸ä¸€è‡´çŠ¶æ€ã€‚å¯¹ä¸­æ¯’çš„äº’æ–¥é‡è°ƒç”¨ <code>lock()</code> å°†ä¼šå¤±è´¥ï¼Œ å¹¶å°†æ˜¾ç¤º <a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html"><code>PoisonError</code></a>ã€‚æ— è®ºå¦‚ä½•ï¼Œä½ å¯ä»¥å¯¹è¯¥é”™è¯¯è°ƒç”¨ <code>into_inner()</code> æ¥ æ¢å¤æ•°æ®ã€‚</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#ç¤ºä¾‹-3" id="ç¤ºä¾‹-3">ç¤ºä¾‹</a></h1>
<p>è®©æˆ‘ä»¬çœ‹çœ‹ <code>Arc</code> å’Œ <code>Mutex</code> çš„å®é™…æ•ˆæœï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::thread;
// use std::sync::{Arc, Mutex};

fn main() {
    let v = vec![10, 20, 30];
    let handle = thread::spawn(|| {
        v.push(10);
    });
    v.push(1000);

    handle.join().unwrap();
    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<details>
<p>å¯èƒ½æœ‰ç”¨çš„è§£å†³æ–¹æ¡ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let v = Arc::new(Mutex::new(vec![10, 20, 30]));

    let v2 = Arc::clone(&amp;v);
    let handle = thread::spawn(move || {
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });

    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }

    handle.join().unwrap();

    println!(&quot;v: {v:?}&quot;);
}
</code></pre></pre>
<p>å€¼å¾—æ³¨æ„çš„éƒ¨åˆ†ï¼š</p>
<ul>
<li><code>Arc</code> å’Œ <code>Mutex</code> ä¸­éƒ½å°è£…äº† <code>v</code>ï¼Œå› ä¸ºå®ƒä»¬çš„å…³æ³¨ç‚¹æ˜¯æ­£äº¤çš„ã€‚
<ul>
<li>å°† <code>Mutex</code> å°è£…åœ¨ <code>Arc</code> ä¸­æ˜¯ä¸€ç§åœ¨çº¿ç¨‹ä¹‹é—´å…±äº«å¯å˜çŠ¶æ€çš„å¸¸è§æ¨¡å¼ã€‚</li>
</ul>
</li>
<li><code>v: Arc&lt;_&gt;</code> å¿…é¡»å…ˆå…‹éš†ä¸º <code>v2</code>ï¼Œç„¶åæ‰èƒ½ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¸­ã€‚è¯·æ³¨æ„ï¼Œlambda ç­¾åä¸­æ·»åŠ äº† <code>move</code>ã€‚</li>
<li>æˆ‘ä»¬å¼•å…¥äº†å—ï¼Œä»¥å°½å¯èƒ½ç¼©å° <code>LockGuard</code> çš„ä½œç”¨åŸŸã€‚</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-2" id="ä¹ é¢˜-2">ä¹ é¢˜</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å“²å­¦å®¶å°±é¤é—®é¢˜" id="å“²å­¦å®¶å°±é¤é—®é¢˜">å“²å­¦å®¶å°±é¤é—®é¢˜</a></h1>
<p>å“²å­¦å®¶ç”¨é¤ç¤ºä¾‹æ˜¯ä¸€ä¸ªå…¸å‹çš„å¹¶å‘é—®é¢˜ï¼š</p>
<blockquote>
<p>äº”ä½å“²å­¦å®¶åœ¨åŒä¸€æ¡Œå­ä¸Šç”¨é¤ã€‚æ¯ä½å“²å­¦å®¶åœ¨æ¡Œå‰éƒ½æœ‰è‡ªå·±çš„åº§ä½ã€‚æ¯ä¸ªç›˜å­ä¹‹é—´éƒ½æœ‰ä¸€æŠŠå‰å­ã€‚ä¸Šçš„èœå“æ˜¯ä¸€ç§æ„å¤§åˆ©é¢ï¼Œéœ€è¦ç”¨ä¸¤æŠŠå‰å­æ‰èƒ½åƒã€‚æ¯ä½å“²å­¦å®¶åªèƒ½äº¤æ›¿è¿›è¡Œæ€è€ƒå’Œç”¨é¤ã€‚æ­¤å¤–ï¼Œåªæœ‰å½“å“²å­¦å®¶ä»¬åŒæ—¶æ‹¿åˆ°å·¦è¾¹å’Œå³è¾¹çš„å‰å­æ‰èƒ½åƒè¿™ä¸ªæ„å¤§åˆ©é¢ã€‚å› æ­¤ï¼Œåªæœ‰å½“ä¸¤æ—åç€çš„äººåœ¨æ€è€ƒï¼Œè€Œéåœ¨åƒé¢æ—¶ï¼Œä»–ä»¬æ‰èƒ½ä½¿ç”¨ä¸¤æŠŠå‰å­ã€‚æ¯ä½å“²å­¦å®¶åƒå®Œé¥­åï¼Œå°±ä¼šæ”¾ä¸‹æ‰‹ä¸­çš„ä¸¤æŠŠå‰å­ã€‚</p>
</blockquote>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œéœ€è¦ä½¿ç”¨æœ¬åœ° <a href="concurrency/sync-exercises/../../cargo/running-locally.html">Cargo å®‰è£…</a>ã€‚å°†ä»¥ä¸‹ä»£ç å¤åˆ¶åˆ°åä¸º <code>src/main.rs</code> çš„æ–‡ä»¶ä¸­ï¼Œå¹¶å¡«å†™ç©ºç™½çš„åœ°æ–¹ï¼Œç„¶åæµ‹è¯• <code>cargo run</code> ä¸ä¼šæ­»é”ï¼š</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        // Pick up forks...
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

fn main() {
    // Create forks

    // Create philosophers

    // Make each of them think and eat 100 times

    // Output their thoughts
}
</code></pre></pre>
<p>æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ <code>Cargo.toml</code>ï¼š</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
</code></pre>
<h1><a class="header" href="#å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨" id="å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨">å¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å™¨</a></h1>
<p>è¿ç”¨æŒæ¡çš„æ–°çŸ¥è¯†åˆ›å»ºä¸€ä¸ªå¤šçº¿ç¨‹é“¾æ¥æ£€æŸ¥å·¥å…·ã€‚åº”å…ˆä»ç½‘é¡µå…¥æ‰‹ï¼Œå¹¶æ£€æŸ¥ç½‘é¡µä¸Šçš„é“¾æ¥æ˜¯å¦æœ‰æ•ˆã€‚è¯¥å·¥å…·åº”ä»¥é€’å½’æ–¹å¼æ£€æŸ¥åŒä¸€ç½‘åŸŸä¸­çš„å…¶ä»–ç½‘é¡µï¼Œå¹¶ä¸”ä¸€ç›´æ‰§è¡Œæ­¤æ“ä½œï¼Œç›´åˆ°æ‰€æœ‰ç½‘é¡µéƒ½é€šè¿‡éªŒè¯ã€‚</p>
<p>For this, you will need an HTTP client such as <a href="https://docs.rs/reqwest/"><code>reqwest</code></a>. You will also need a way to find links, we can use <a href="https://docs.rs/scraper/"><code>scraper</code></a>. Finally, we'll need some way of handling errors, we will use <a href="https://docs.rs/thiserror/"><code>thiserror</code></a>.</p>
<p>Create a new Cargo project and <code>reqwest</code> it as a dependency with:</p>
<pre><code class="language-shell">cargo new link-checker
cd link-checker
cargo add --features blocking,rustls-tls reqwest
cargo add scraper
cargo add thiserror
</code></pre>
<blockquote>
<p>å¦‚æœ <code>cargo add</code> æ“ä½œå¤±è´¥å¹¶æ˜¾ç¤º <code>error: no such subcommand</code>ï¼Œè¯·æ‰‹åŠ¨ä¿®æ”¹ <code>Cargo.toml</code> æ–‡ä»¶ã€‚æ·»åŠ ä¸‹é¢åˆ—å‡ºçš„ä¾èµ–é¡¹ã€‚</p>
</blockquote>
<p><code>cargo add</code> è°ƒç”¨ä¼šå°† <code>Cargo.toml</code> æ–‡ä»¶æ›´æ–°ä¸ºå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;link-checker&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
publish = false

[dependencies]
reqwest = { version = &quot;0.11.12&quot;, features = [&quot;blocking&quot;, &quot;rustls-tls&quot;] }
scraper = &quot;0.13.0&quot;
thiserror = &quot;1.0.37&quot;
</code></pre>
<p>æ‚¨ç°åœ¨å¯ä»¥ä¸‹è½½åˆå§‹é¡µäº†ã€‚è¯·å°è¯•ä½¿ç”¨ä¸€ä¸ªå°ç½‘ç«™ï¼Œä¾‹å¦‚ <code>https://www.google.org/</code>ã€‚</p>
<p>æ‚¨çš„ <code>src/main.rs</code> æ–‡ä»¶åº”å¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

fn main() {
    let client = Client::new();
    let start_url = Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let crawl_command = CrawlCommand{ url: start_url, extract_links: true };
    match visit_page(&amp;client, &amp;crawl_command) {
        Ok(links) =&gt; println!(&quot;Links: {links:#?}&quot;),
        Err(err) =&gt; println!(&quot;Could not extract links: {err:#}&quot;),
    }
}
</code></pre></pre>
<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿è¡Œ <code>src/main.rs</code> ä¸­çš„ä»£ç </p>
<pre><code class="language-shell">cargo run
</code></pre>
<h2><a class="header" href="#ä»»åŠ¡" id="ä»»åŠ¡">ä»»åŠ¡</a></h2>
<ul>
<li>é€šè¿‡çº¿ç¨‹å¹¶è¡Œæ£€æŸ¥é“¾æ¥ï¼šå°†è¦æ£€æŸ¥çš„ç½‘å€å‘é€åˆ°æŸä¸ªé€šé“ï¼Œç„¶åä½¿ç”¨å¤šä¸ªçº¿ç¨‹å¹¶è¡Œæ£€æŸ¥è¿™äº›ç½‘å€ã€‚</li>
<li>æ‚¨å¯ä»¥å¯¹æ­¤è¿›è¡Œæ‰©å±•ï¼Œä»¥é€’å½’æ–¹å¼ä» <code>www.google.org</code> ç½‘åŸŸçš„æ‰€æœ‰ç½‘é¡µä¸­æå–é“¾æ¥ã€‚è®¾ç½®ç½‘é¡µä¸Šé™ï¼ˆä¾‹å¦‚ 100 ä¸ªï¼‰ï¼Œä»¥å…è¢«ç½‘ç«™å±è”½ã€‚</li>
</ul>
<h1><a class="header" href="#è§£ç­”-19" id="è§£ç­”-19">è§£ç­”</a></h1>
<h2><a class="header" href="#å“²å­¦å®¶å°±é¤é—®é¢˜-1" id="å“²å­¦å®¶å°±é¤é—®é¢˜-1">å“²å­¦å®¶å°±é¤é—®é¢˜</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::Duration;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::SyncSender&lt;String&gt;,
}

impl Philosopher {
    fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .unwrap();
    }

    fn eat(&amp;self) {
        println!(&quot;{} is trying to eat&quot;, &amp;self.name);
        let _left = self.left_fork.lock().unwrap();
        let _right = self.right_fork.lock().unwrap();

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        thread::sleep(Duration::from_millis(10));
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

fn main() {
    let (tx, rx) = mpsc::sync_channel(10);

    let forks = (0..PHILOSOPHERS.len())
        .map(|_| Arc::new(Mutex::new(Fork)))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for i in 0..forks.len() {
        let tx = tx.clone();
        let mut left_fork = Arc::clone(&amp;forks[i]);
        let mut right_fork = Arc::clone(&amp;forks[(i + 1) % forks.len()]);

        // To avoid a deadlock, we have to break the symmetry
        // somewhere. This will swap the forks without deinitializing
        // either of them.
        if i == forks.len() - 1 {
            std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
        }

        let philosopher = Philosopher {
            name: PHILOSOPHERS[i].to_string(),
            thoughts: tx,
            left_fork,
            right_fork,
        };

        thread::spawn(move || {
            for _ in 0..100 {
                philosopher.eat();
                philosopher.think();
            }
        });
    }

    drop(tx);
    for thought in rx {
        println!(&quot;{thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#link-checker" id="link-checker">Link Checker</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::{mpsc, Arc, Mutex};
use std::thread;

use reqwest::blocking::Client;
use reqwest::Url;
use scraper::{Html, Selector};
use thiserror::Error;

#[derive(Error, Debug)]
enum Error {
    #[error(&quot;request error: {0}&quot;)]
    ReqwestError(#[from] reqwest::Error),
    #[error(&quot;bad http response: {0}&quot;)]
    BadResponse(String),
}

#[derive(Debug)]
struct CrawlCommand {
    url: Url,
    extract_links: bool,
}

fn visit_page(client: &amp;Client, command: &amp;CrawlCommand) -&gt; Result&lt;Vec&lt;Url&gt;, Error&gt; {
    println!(&quot;Checking {:#}&quot;, command.url);
    let response = client.get(command.url.clone()).send()?;
    if !response.status().is_success() {
        return Err(Error::BadResponse(response.status().to_string()));
    }

    let mut link_urls = Vec::new();
    if !command.extract_links {
        return Ok(link_urls);
    }

    let base_url = response.url().to_owned();
    let body_text = response.text()?;
    let document = Html::parse_document(&amp;body_text);

    let selector = Selector::parse(&quot;a&quot;).unwrap();
    let href_values = document
        .select(&amp;selector)
        .filter_map(|element| element.value().attr(&quot;href&quot;));
    for href in href_values {
        match base_url.join(href) {
            Ok(link_url) =&gt; {
                link_urls.push(link_url);
            }
            Err(err) =&gt; {
                println!(&quot;On {base_url:#}: ignored unparsable {href:?}: {err}&quot;);
            }
        }
    }
    Ok(link_urls)
}

struct CrawlState {
    domain: String,
    visited_pages: std::collections::HashSet&lt;String&gt;,
}

impl CrawlState {
    fn new(start_url: &amp;Url) -&gt; CrawlState {
        let mut visited_pages = std::collections::HashSet::new();
        visited_pages.insert(start_url.as_str().to_string());
        CrawlState { domain: start_url.domain().unwrap().to_string(), visited_pages }
    }

    /// Determine whether links within the given page should be extracted.
    fn should_extract_links(&amp;self, url: &amp;Url) -&gt; bool {
        let Some(url_domain) = url.domain() else {
            return false;
        };
        url_domain == self.domain
    }

    /// Mark the given page as visited, returning false if it had already
    /// been visited.
    fn mark_visited(&amp;mut self, url: &amp;Url) -&gt; bool {
        self.visited_pages.insert(url.as_str().to_string())
    }
}

type CrawlResult = Result&lt;Vec&lt;Url&gt;, (Url, Error)&gt;;
fn spawn_crawler_threads(
    command_receiver: mpsc::Receiver&lt;CrawlCommand&gt;,
    result_sender: mpsc::Sender&lt;CrawlResult&gt;,
    thread_count: u32,
) {
    let command_receiver = Arc::new(Mutex::new(command_receiver));

    for _ in 0..thread_count {
        let result_sender = result_sender.clone();
        let command_receiver = command_receiver.clone();
        thread::spawn(move || {
            let client = Client::new();
            loop {
                let command_result = {
                    let receiver_guard = command_receiver.lock().unwrap();
                    receiver_guard.recv()
                };
                let Ok(crawl_command) = command_result else {
                    // The sender got dropped. No more commands coming in.
                    break;
                };
                let crawl_result = match visit_page(&amp;client, &amp;crawl_command) {
                    Ok(link_urls) =&gt; Ok(link_urls),
                    Err(error) =&gt; Err((crawl_command.url, error)),
                };
                result_sender.send(crawl_result).unwrap();
            }
        });
    }
}

fn control_crawl(
    start_url: Url,
    command_sender: mpsc::Sender&lt;CrawlCommand&gt;,
    result_receiver: mpsc::Receiver&lt;CrawlResult&gt;,
) -&gt; Vec&lt;Url&gt; {
    let mut crawl_state = CrawlState::new(&amp;start_url);
    let start_command = CrawlCommand { url: start_url, extract_links: true };
    command_sender.send(start_command).unwrap();
    let mut pending_urls = 1;

    let mut bad_urls = Vec::new();
    while pending_urls &gt; 0 {
        let crawl_result = result_receiver.recv().unwrap();
        pending_urls -= 1;

        match crawl_result {
            Ok(link_urls) =&gt; {
                for url in link_urls {
                    if crawl_state.mark_visited(&amp;url) {
                        let extract_links = crawl_state.should_extract_links(&amp;url);
                        let crawl_command = CrawlCommand { url, extract_links };
                        command_sender.send(crawl_command).unwrap();
                        pending_urls += 1;
                    }
                }
            }
            Err((url, error)) =&gt; {
                bad_urls.push(url);
                println!(&quot;Got crawling error: {:#}&quot;, error);
                continue;
            }
        }
    }
    bad_urls
}

fn check_links(start_url: Url) -&gt; Vec&lt;Url&gt; {
    let (result_sender, result_receiver) = mpsc::channel::&lt;CrawlResult&gt;();
    let (command_sender, command_receiver) = mpsc::channel::&lt;CrawlCommand&gt;();
    spawn_crawler_threads(command_receiver, result_sender, 16);
    control_crawl(start_url, command_sender, result_receiver)
}

fn main() {
    let start_url = reqwest::Url::parse(&quot;https://www.google.org&quot;).unwrap();
    let bad_urls = check_links(start_url);
    println!(&quot;Bad URLs: {:#?}&quot;, bad_urls);
}
</code></pre></pre>
<h1><a class="header" href="#æ¬¢è¿" id="æ¬¢è¿">æ¬¢è¿</a></h1>
<p>â€œå¼‚æ­¥â€æ˜¯ä¸€ç§å¹¶å‘æ¨¡å‹ï¼Œå¯ä»¥åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡ã€‚å…·ä½“åšæ³•æ˜¯é€ä¸ªæ‰§è¡Œä»»åŠ¡ç›´è‡³é˜»å¡ï¼Œç„¶ååˆ‡æ¢åˆ°å¦ä¸€é¡¹å¯ä»¥ç»§ç»­è¿›è¡Œçš„ä»»åŠ¡ã€‚è¯¥æ¨¡å‹æ”¯æŒåœ¨æœ‰é™æ•°é‡çš„çº¿ç¨‹ä¸Šè¿è¡Œæ›´å¤šä»»åŠ¡ã€‚åŸå› åœ¨äºï¼Œæ¯ä¸ªä»»åŠ¡çš„å¼€é”€é€šå¸¸å¾ˆä½ï¼Œå¹¶ä¸”æ“ä½œç³»ç»Ÿæä¾›äº†åŸºå…ƒæ¥é«˜æ•ˆè¯†åˆ«èƒ½å¤Ÿæ‰§è¡Œçš„ I/O ä»»åŠ¡ã€‚</p>
<p>Rust çš„å¼‚æ­¥æ“ä½œåŸºäº &quot;Futures&quot; æ¥å®ç°ï¼Œå³è¡¨ç¤ºæœªæ¥å¯èƒ½å®Œæˆçš„å·¥ä½œã€‚ç³»ç»Ÿä¼šå¯¹è¿™äº› Future è¿›è¡Œ â€œè½®è¯¢â€ï¼Œç›´åˆ°æ˜¾ç¤ºå…¨éƒ¨å·²å®Œæˆã€‚</p>
<p>ç”±å¼‚æ­¥è¿è¡Œæ—¶å¯¹è¿™äº› Future è¿›è¡Œè½®è¯¢ï¼Œå¹¶ä¸”æœ‰å¤šç§ä¸åŒçš„è¿è¡Œæ—¶å¯ä¾›é€‰æ‹©ã€‚</p>
<h2><a class="header" href="#æ¯”è¾ƒ-1" id="æ¯”è¾ƒ-1">æ¯”è¾ƒ</a></h2>
<ul>
<li>
<p>Python çš„ <code>asyncio</code> ä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„æ¨¡å‹ã€‚ä¸è¿‡ï¼Œå…¶ <code>Future</code> ç±»å‹åŸºäºå›è°ƒçš„å®ç°æ–¹å¼ï¼Œè€Œéé€šè¿‡è½®è¯¢ã€‚ä½¿ç”¨å¼‚æ­¥ Python ç¨‹åºéœ€è¦ç±»ä¼¼äº Rust ä¸­è¿è¡Œæ—¶çš„ â€œå¾ªç¯â€ è¿›è¡Œç®¡ç†ã€‚</p>
</li>
<li>
<p>JavaScript çš„ <code>Promise</code> ä¸ä¹‹ç±»ä¼¼ï¼Œä½†åŒæ ·åŸºäºå›è°ƒçš„å®ç°æ–¹å¼ã€‚è¯­è¨€è¿è¡Œæ—¶å®ç°äº†äº‹ä»¶å¾ªç¯ï¼Œå› æ­¤è®¸å¤šä¸ Promise è§£æç›¸å…³çš„ç»†èŠ‚è¢«éšè—èµ·æ¥ã€‚</p>
</li>
</ul>
<h2><a class="header" href="#æ—¶é—´è¡¨-5" id="æ—¶é—´è¡¨-5">æ—¶é—´è¡¨</a></h2>
<p>{{%session outline}}</p>
<h1><a class="header" href="#å¼‚æ­¥åŸºç¡€" id="å¼‚æ­¥åŸºç¡€">å¼‚æ­¥åŸºç¡€</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#asyncawait" id="asyncawait"><code>async</code>/<code>await</code></a></h1>
<p>ä»é«˜å±‚æ¬¡ä¸Šçœ‹ï¼Œå¼‚æ­¥ Rust ä»£ç ä¸â€œæ­£å¸¸â€çš„é¡ºåºä»£ç éå¸¸ç±»ä¼¼ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::executor::block_on;

async fn count_to(count: i32) {
    for i in 0..count {
        println!(&quot;Count is: {i}!&quot;);
    }
}

async fn async_main(count: i32) {
    count_to(count).await;
}

fn main() {
    block_on(async_main(10));
}
</code></pre></pre>
<details>
<p>å…³é”®ç‚¹ï¼š</p>
<ul>
<li>
<p>è¯·æ³¨æ„ï¼Œè¿™åªæ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œç”¨äºå±•ç¤ºè¯­æ³•ã€‚å…¶ä¸­æ²¡æœ‰é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œæˆ–ä»»ä½•çœŸæ­£çš„å¹¶å‘ï¼</p>
</li>
<li>
<p>The &quot;async&quot; keyword is syntactic sugar. The compiler replaces the return type with a future.</p>
</li>
<li>
<p>ä½ ä¸èƒ½å°† <code>main</code> å£°æ˜ä¸ºå¼‚æ­¥å‡½æ•°ï¼Œé™¤éåœ¨ç¼–è¯‘å™¨ä¸­åŠ å…¥é¢å¤–çš„æŒ‡ä»¤æ¥å‘Šè¯‰å®ƒå¦‚ä½•ä½¿ç”¨è¿”å›çš„ futureã€‚</p>
</li>
<li>
<p>You need an executor to run async code. <code>block_on</code> blocks the current thread until the provided future has run to completion.</p>
</li>
<li>
<p><code>.await</code> ä¼šå¼‚æ­¥åœ°ç­‰å¾…å¦ä¸€ä¸ªæ“ä½œçš„å®Œæˆã€‚ä¸ <code>block_on</code> ä¸åŒï¼Œ<code>.await</code> ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ã€‚</p>
</li>
<li>
<p><code>.await</code> can only be used inside an <code>async</code> function (or block; these are introduced later).</p>
</li>
</ul>
</details><h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p><a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> æ˜¯ä¸€ç§ traitï¼Œç”±è¡¨ç¤ºå°šæœªå®Œæˆçš„æ“ä½œçš„å¯¹è±¡æ‰€å®ç°ã€‚å¯ä»¥è½®è¯¢ Futureï¼Œå¹¶ä¸” <code>poll</code> ä¼šè¿”å› ä¸€ä¸ª <a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a> å¯¹è±¡ã€‚</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::pin::Pin;
use std::task::Context;

pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}

pub enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>å¼‚æ­¥å‡½æ•°ä¼šè¿”å› <code>impl Future</code>ã€‚å¯¹äºè‡ªå®šä¹‰çš„ç±»å‹ï¼Œä¹Ÿå¯ä»¥å®ç° <code>Future</code>ï¼ˆä½†ä¸å¸¸è§ï¼‰ã€‚ä¾‹å¦‚ï¼Œä» <code>tokio::spawn</code> è¿”å›çš„ <code>JoinHandle</code> ä¼šå®ç° <code>Future</code>ï¼Œä»¥å…è®¸åŠ å…¥è¯¥ä»»åŠ¡ã€‚</p>
<p>åœ¨ Future ä¸­ä½¿ç”¨ <code>.await</code> å…³é”®å­—ä¼šå¯¼è‡´å½“å‰å¼‚æ­¥å‡½æ•°æš‚åœï¼Œç›´åˆ°è¯¥ Future å‡†å¤‡å°±ç»ªï¼Œç„¶åè®¡ç®—å…¶è¾“å‡ºã€‚</p>
<details>
<ul>
<li>
<p><code>Future</code> å’Œ <code>Poll</code> ç±»å‹çš„å®ç°å®Œå…¨å¦‚ä¸‹æ‰€ç¤ºï¼šè¯·ç‚¹å‡»é“¾æ¥æŸ¥çœ‹æ–‡æ¡£ä¸­çš„å®ç°ã€‚</p>
</li>
<li>
<p>æˆ‘ä»¬çš„é‡ç‚¹åœ¨äºç¼–å†™å¼‚æ­¥ä»£ç ï¼Œè€Œä¸æ˜¯æ„å»ºæ–°çš„å¼‚æ­¥åŸºå…ƒï¼Œå› æ­¤ä¸ä¼šæ¶‰åŠ <code>Pin</code> å’Œ <code>Context</code>ã€‚ç®€è¨€ä¹‹ï¼š</p>
<ul>
<li>
<p>é€šè¿‡ <code>Context</code>ï¼ŒFuture åœ¨äº‹ä»¶å‘ç”Ÿæ—¶å¯è‡ªè¡Œå®‰æ’é‡æ–°è¿›è¡Œè½®è¯¢ã€‚</p>
</li>
<li>
<p><code>Pin</code> ç¡®ä¿ Future ä¸ä¼šç§»åˆ°å†…å­˜ä¸­ï¼Œä»¥ä¾¿æŒ‡å‘è¯¥ Future çš„æŒ‡é’ˆä»ç„¶æœ‰æ•ˆã€‚ä¸ºäº†ç¡®ä¿ä½¿ç”¨ <code>.await</code> ä¹‹åå¼•ç”¨ä¾ç„¶æœ‰æ•ˆï¼Œå¿…é¡»æ‰§è¡Œæ­¤æ“ä½œã€‚</p>
</li>
</ul>
</li>
</ul>
</details><h1><a class="header" href="#runtimes" id="runtimes">Runtimes</a></h1>
<p><em>è¿è¡Œæ—¶</em> æ”¯æŒå¼‚æ­¥æ‰§è¡Œæ“ä½œï¼ˆå³ _ååº”å™¨ï¼‰ï¼Œå¹¶è´Ÿè´£æ‰§è¡Œ Future ï¼ˆå³ _æ‰§è¡Œå™¨ï¼‰ã€‚Rust æ²¡æœ‰ â€œå†…ç½®â€è¿è¡Œæ—¶ï¼Œä½†æœ‰ä»¥ä¸‹å‡ ä¸ªé€‰é¡¹å¯ä¾›é€‰æ‹©ï¼š</p>
<ul>
<li><a href="https://tokio.rs/">Tokio</a>ï¼šæ€§èƒ½å‡ºè‰²ï¼Œæ‹¥æœ‰æˆç†Ÿçš„åŠŸèƒ½ç”Ÿæ€ç³»ç»Ÿï¼Œä¾‹å¦‚é€‚ç”¨äº HTTP çš„ <a href="https://hyper.rs/">Hyper</a> æˆ– é€‚ç”¨äº gRPC çš„ <a href="https://github.com/hyperium/tonic">Tonic</a>ã€‚</li>
<li><a href="https://async.rs/">async-std</a>ï¼šæ—¨åœ¨æˆä¸º â€œå¼‚æ­¥ç¼–ç¨‹çš„æ ‡å‡†åº“â€ï¼Œå¹¶åœ¨ <code>async::task</code> ä¸­åŒ…å«åŸºæœ¬è¿è¡Œæ—¶ã€‚</li>
<li><a href="https://docs.rs/smol/latest/smol/">smol</a>ï¼šç®€å•ä¸”è½»é‡</li>
</ul>
<p>æœ‰äº›å¤§å‹åº”ç”¨å…·æœ‰è‡ªå·±çš„è¿è¡Œæ—¶ã€‚ä¾‹å¦‚ï¼Œ<a href="https://fuchsia.googlesource.com/fuchsia/+/refs/heads/main/src/lib/fuchsia-async/src/lib.rs">Fuchsia</a> å·²æœ‰ä¸€ä¸ªè¿è¡Œæ—¶ã€‚</p>
<details>
<ul>
<li>
<p>è¯·æ³¨æ„ï¼Œåœ¨åˆ—å‡ºçš„è¿è¡Œæ—¶ä¸­ï¼ŒRust Playground ä»…æ”¯æŒ Tokioã€‚è¯¥ Playground ä¹Ÿä¸æ”¯æŒä»»ä½• I/O æ“ä½œï¼Œå› æ­¤å¤§å¤šæ•°æœ‰è¶£çš„å¼‚æ­¥æ“ä½œæ— æ³•åœ¨è¯¥å¹³å°ä¸Šè¿è¡Œã€‚</p>
</li>
<li>
<p>Future æ˜¯ â€œæƒ¯æ€§â€çš„ï¼Œé™¤éæœ‰æ‰§è¡Œç¨‹åºå¯¹å…¶è¿›è¡Œè½®è¯¢ï¼Œå¦åˆ™å®ƒä»¬ä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œï¼ˆç”šè‡³ä¸ä¼šå¯åŠ¨ I/O æ“ä½œï¼‰ã€‚è¿™ä¸ JS promise ä¸åŒï¼Œä¾‹å¦‚ï¼Œåè€…å³ä½¿ä»æœªä½¿ç”¨ä¹Ÿä¼šå®Œæˆè¿è¡Œè¿‡ç¨‹ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#tokio" id="tokio">Tokio</a></h1>
<p>Tokio provides:</p>
<ul>
<li>ç”¨äºæ‰§è¡Œå¼‚æ­¥ä»£ç çš„å¤šçº¿ç¨‹è¿è¡Œæ—¶ã€‚</li>
<li>An asynchronous version of the standard library.</li>
<li>åºå¤§çš„åº“ç”Ÿæ€ç³»ç»Ÿã€‚</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::time;

async fn count_to(count: i32) {
    for i in 0..count {
        println!(&quot;Count in task: {i}!&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_to(10));

    for i in 0..5 {
        println!(&quot;Main task: {i}&quot;);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>å€ŸåŠ© <code>tokio::main</code> å®ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å°† <code>main</code> è®¾ä¸ºå¼‚æ­¥å‡½æ•°ã€‚</p>
</li>
<li>
<p><code>spawn</code> å‡½æ•°ä¼šåˆ›å»ºæ–°çš„å¹¶å‘ â€œä»»åŠ¡â€ã€‚</p>
</li>
<li>
<p>æ³¨æ„ï¼š<code>spawn</code> ä½¿ç”¨ <code>Future</code> æ–¹æ³•å®ç°ï¼Œè€Œä¸æ˜¯å¯¹ <code>count_to</code> è°ƒç”¨ <code>.await</code>ã€‚</p>
</li>
</ul>
<p><strong>æ·±å…¥æ¢ç´¢</strong>ï¼š</p>
<ul>
<li>
<p>ä¸ºä½• <code>count_to</code> é€šå¸¸æ— æ³•è®¡æ•°åˆ° 10ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥å–æ¶ˆçš„ç¤ºä¾‹ã€‚<code>tokio::spawn</code> ä¼šè¿”å›ä¸€ä¸ªå¥æŸ„ï¼Œå¯ä»¥ç­‰å¾…è¯¥å¥æŸ„ç›´è‡³å…¶ä»£è¡¨çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ã€‚</p>
</li>
<li>
<p>å°è¯•ä½¿ç”¨ <code>count_to(10).await</code>ï¼Œè€Œä¸æ˜¯æ´¾ç”Ÿæ–¹æ³•ã€‚</p>
</li>
<li>
<p>å°è¯•ç­‰å¾… <code>tokio::spawn</code> è¿”å›çš„ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ã€‚</p>
</li>
</ul>
</details>
<h1><a class="header" href="#ä»»åŠ¡-1" id="ä»»åŠ¡-1">ä»»åŠ¡</a></h1>
<p>Rust æœ‰ä¸€ä¸ªä»»åŠ¡ç³»ç»Ÿï¼Œè¿™æ˜¯ä¸€ç§è½»é‡çº§çº¿ç¨‹å¤„ç†å½¢å¼ã€‚</p>
<p>æ¯ä¸ªä»»åŠ¡åªæœ‰ä¸€ä¸ªé¡¶çº§ Futureï¼Œæ‰§è¡Œå™¨ä¼šå¯¹æ­¤è¿›è¡Œè½®è¯¢æ¥æ¨è¿›ä»»åŠ¡è¿›åº¦ã€‚è¯¥ Future å¯èƒ½åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªåµŒå¥—çš„ Futureï¼Œå¯ä»¥é€šè¿‡å…¶ <code>poll</code> æ–¹æ³•å¯¹å®ƒä»¬è¿›è¡Œè½®è¯¢ï¼Œç±»ä¼¼äºè°ƒç”¨å †æ ˆã€‚å¯ä»¥é€šè¿‡è½®è¯¢å¤šä¸ªå­ Futureï¼ˆä¾‹å¦‚äº‰ç”¨å®šæ—¶å™¨å’Œ I/O æ“ä½œï¼‰åœ¨ä»»åŠ¡å†…éƒ¨å®ç°å¹¶å‘æ“ä½œã€‚</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:0&quot;).await?;
    println!(&quot;listening on port {}&quot;, listener.local_addr()?.port());

    loop {
        let (mut socket, addr) = listener.accept().await?;

        println!(&quot;connection from {addr:?}&quot;);

        tokio::spawn(async move {
            socket.write_all(b&quot;Who are you?\n&quot;).await.expect(&quot;socket error&quot;);

            let mut buf = vec![0; 1024];
            let name_size = socket.read(&amp;mut buf).await.expect(&quot;socket error&quot;);
            let name = std::str::from_utf8(&amp;buf[..name_size]).unwrap().trim();
            let reply = format!(&quot;Thanks for dialing in, {name}!\n&quot;);
            socket.write_all(reply.as_bytes()).await.expect(&quot;socket error&quot;);
        });
    }
}
</code></pre></pre>
<details>
<p>å°†æ­¤ç¤ºä¾‹å¤åˆ¶åˆ°å‡†å¤‡å¥½çš„ <code>src/main.rs</code> æ–‡ä»¶ä¸­ï¼Œå¹¶ä»è¯¥æ–‡ä»¶è¿è¡Œå®ƒã€‚</p>
<p>è¯·å°è¯•ä½¿ç”¨åƒ <a href="https://www.unix.com/man-page/linux/1/nc/">nc</a> æˆ– <a href="https://www.unix.com/man-page/linux/1/telnet/">telnet</a> è¿™æ ·çš„ TCP è¿æ¥å·¥å…·è¿›è¡Œè¿æ¥ã€‚</p>
<ul>
<li>
<p>è®©å­¦ç”Ÿæƒ³è±¡ä¸€ä¸‹ï¼Œå½“è¿æ¥å¤šä¸ªå®¢æˆ·ç«¯æ—¶ï¼Œç¤ºä¾‹æœåŠ¡å™¨ä¼šè¾¾åˆ°æ€æ ·çš„çŠ¶æ€ã€‚å­˜åœ¨å“ªäº›ä»»åŠ¡ï¼Ÿå…·æœ‰å“ªäº› Futureï¼Ÿ</p>
</li>
<li>
<p>This is the first time we've seen an <code>async</code> block. This is similar to a closure, but does not take any arguments. Its return value is a Future, similar to an <code>async fn</code>.</p>
</li>
<li>
<p>Refactor the async block into a function, and improve the error handling using <code>?</code>.</p>
</li>
</ul>
</details><h1><a class="header" href="#channels-and-control-flow" id="channels-and-control-flow">Channels and Control Flow</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#å¼‚æ­¥é€šé“" id="å¼‚æ­¥é€šé“">å¼‚æ­¥é€šé“</a></h1>
<p>æœ‰äº› crate æ”¯æŒä½¿ç”¨å¼‚æ­¥é€šé“ã€‚ä¾‹å¦‚ <code>tokio</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc;

async fn ping_handler(mut input: mpsc::Receiver&lt;()&gt;) {
    let mut count: usize = 0;

    while let Some(_) = input.recv().await {
        count += 1;
        println!(&quot;Received {count} pings so far.&quot;);
    }

    println!(&quot;ping_handler complete&quot;);
}

#[tokio::main]
async fn main() {
    let (sender, receiver) = mpsc::channel(32);
    let ping_handler_task = tokio::spawn(ping_handler(receiver));
    for i in 0..10 {
        sender.send(()).await.expect(&quot;Failed to send ping.&quot;);
        println!(&quot;Sent {} pings so far.&quot;, i + 1);
    }

    drop(sender);
    ping_handler_task.await.expect(&quot;Something went wrong in ping handler task.&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>å°†é€šé“å¤§å°æ›´æ”¹ä¸º <code>3</code>ï¼Œç„¶åçœ‹çœ‹å¯¹æ“ä½œæ‰§è¡Œä¼šæœ‰ä»€ä¹ˆå½±å“ã€‚</p>
</li>
<li>
<p>Overall, the interface is similar to the <code>sync</code> channels as seen in the <a href="concurrency/async-control-flow/../channels.html">morning class</a>.</p>
</li>
<li>
<p>å°è¯•ç§»é™¤ <code>std::mem::drop</code> è°ƒç”¨ã€‚ä¼šå‡ºç°ä»€ä¹ˆæƒ…å†µï¼Ÿè¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿ</p>
</li>
<li>
<p><a href="https://docs.rs/flume/latest/flume/">Flume</a> crate åŒ…å«å¯ä»¥åŒæ—¶å®ç° <code>sync</code>ã€<code>async</code> <code>send</code> å’Œ <code>recv</code> çš„æ¸ é“ï¼Œä¸ºæ¶‰åŠ IO å’Œå¤§é‡ CPU å¤„ç†ä»»åŠ¡çš„å¤æ‚åº”ç”¨æä¾›äº†æå¤§ä¾¿åˆ©ã€‚</p>
</li>
<li>
<p>ä½¿ç”¨ <code>async</code> é€šé“çš„ä¼˜åŠ¿åœ¨äºï¼Œæˆ‘ä»¬èƒ½å¤Ÿå°†å®ƒä»¬ä¸å…¶ä»– <code>future</code> ç»“åˆèµ·æ¥ï¼Œä»è€Œåˆ›å»ºå¤æ‚çš„æ§åˆ¶æµã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#åŠ å…¥" id="åŠ å…¥">åŠ å…¥</a></h1>
<p>è”æ¥æ“ä½œä¼šç­‰å¾…ä¸€ç»„ Future å…¨éƒ¨å°±ç»ªï¼Œç„¶åè¿”å›å®ƒä»¬çš„ç»“æœé›†åˆã€‚è¿™ç±»ä¼¼äº JavaScript ä¸­çš„ <code>Promise.al</code> æˆ– Python ä¸­çš„ <code>asyncio.gather</code>ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;

async fn size_of_page(url: &amp;str) -&gt; Result&lt;usize&gt; {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&amp;str; 4] = [
        &quot;https://google.com&quot;,
        &quot;https://httpbin.org/ip&quot;,
        &quot;https://play.rust-lang.org/&quot;,
        &quot;BAD_URL&quot;,
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_sizes_dict: HashMap&lt;&amp;str, Result&lt;usize&gt;&gt; =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(&quot;{page_sizes_dict:?}&quot;);
}
</code></pre></pre>
<details>
<p>å°†æ­¤ç¤ºä¾‹å¤åˆ¶åˆ°å‡†å¤‡å¥½çš„ <code>src/main.rs</code> æ–‡ä»¶ä¸­ï¼Œå¹¶ä»è¯¥æ–‡ä»¶è¿è¡Œå®ƒã€‚</p>
<ul>
<li>
<p>å¯¹äºå¤šä¸ªç±»å‹ä¸ç›¸äº¤çš„ Futureï¼Œå¯ä»¥ä½¿ç”¨ <code>std::future::join!</code> è¿›è¡Œå¤„ç†ï¼Œä½†å¿…é¡»è¦ç¡®å®šåœ¨ç¼–è¯‘æ—¶ Future çš„æ•°é‡ã€‚ç›®å‰ï¼Œå¯åœ¨ <code>futures</code> crate ä¸­ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œä½†å¾ˆå¿«ä¹Ÿä¼šåœ¨ <code>std::future</code> ä¸­æ­£å¼å‘å¸ƒã€‚</p>
</li>
<li>
<p>The risk of <code>join</code> is that one of the futures may never resolve, this would cause your program to stall.</p>
</li>
<li>
<p>è¿˜å¯ä»¥å°† <code>join_all</code> ä¸ <code>join!</code> ç»“åˆä½¿ç”¨ï¼Œå¹¶è¡Œå¤„ç†æ‰€æœ‰å¯¹ http æœåŠ¡çš„è¯·æ±‚å’Œæ•°æ®åº“æŸ¥è¯¢ã€‚å°è¯•ä½¿ç”¨ <code>futures::join!</code> å°† <code>tokio::time::sleep</code> æ·»åŠ åˆ° Future ä¸­ã€‚è¿™ä¸æ˜¯ä¸€ä¸ªè¶…æ—¶æ“ä½œï¼ˆå…¶éœ€è¦ä½¿ç”¨ <code>select!</code>ï¼Œä¸‹ä¸€ç« ä¼šè¯¦ç»†ä»‹ç»ï¼‰ï¼Œè€Œæ˜¯å±•ç¤ºäº† <code>join!</code> çš„ä½¿ç”¨æ–¹å¼ã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#é€‰æ‹©" id="é€‰æ‹©">é€‰æ‹©</a></h1>
<p>é€‰æ‹©æ“ä½œä¼šç­‰å¾…ä¸€ç»„ Future ä¸­çš„ä»»æ„ä¸€ä¸ªå°±ç»ªï¼Œå¹¶å¯¹ Future äº§ç”Ÿçš„ç»“æœè¿›è¡Œå“åº”ã€‚åœ¨ JavaScript ä¸­ï¼Œè¯¥æ“ä½œç±»ä¼¼äº <code>Promise.race</code>ã€‚åœ¨ Python ä¸­ï¼Œå®ƒç›¸å½“äº <code>asyncio.wait(task_set, return_when=asyncio.FIRST_COMPLETED)</code>ã€‚</p>
<p>Similar to a match statement, the body of <code>select!</code> has a number of arms, each of the form <code>pattern = future =&gt; statement</code>. When a <code>future</code> is ready, its return value is destructured by the <code>pattern</code>. The <code>statement</code> is then run with the resulting variables. The <code>statement</code> result becomes the result of the <code>select!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let listener = tokio::spawn(async move {
        tokio::select! {
            Some(msg) = rx.recv() =&gt; println!(&quot;got: {msg}&quot;),
            _ = sleep(Duration::from_millis(50)) =&gt; println!(&quot;timeout&quot;),
        };
    });
    sleep(Duration::from_millis(10)).await;
    tx.send(String::from(&quot;Hello!&quot;)).await.expect(&quot;Failed to send greeting&quot;);

    listener.await.expect(&quot;Listener failed&quot;);
}
</code></pre></pre>
<details>
<ul>
<li>
<p>The <code>listener</code> async block here is a common form: wait for some async event, or for a timeout. Change the <code>sleep</code> to sleep longer to see it fail. Why does the <code>send</code> also fail in this situation?</p>
</li>
<li>
<p><code>select!</code> is also often used in a loop in &quot;actor&quot; architectures, where a task reacts to events in a loop. That has some pitfalls, which will be discussed in the next segment.</p>
</li>
</ul>
</details><h1><a class="header" href="#è¯¯åŒº" id="è¯¯åŒº">è¯¯åŒº</a></h1>
<p>Async / await provides convenient and efficient abstraction for concurrent asynchronous programming. However, the async/await model in Rust also comes with its share of pitfalls and footguns. We illustrate some of them in this chapter.</p>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#é˜»å¡æ‰§è¡Œå™¨" id="é˜»å¡æ‰§è¡Œå™¨">é˜»å¡æ‰§è¡Œå™¨</a></h1>
<p>å¤§å¤šæ•°å¼‚æ­¥è¿è¡Œæ—¶æ”¯æŒå¹¶å‘è¿è¡Œ IO ä»»åŠ¡ã€‚è¿™æ„å‘³ç€ CPU çš„é˜»å¡æ€§ä»»åŠ¡ä¼šé˜»å¡æ‰§è¡Œå™¨ï¼Œå¹¶é˜»æ­¢æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯ï¼Œå°½å¯èƒ½ä½¿ç”¨å¼‚æ­¥ç­‰æ•ˆæ–¹æ³•ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use futures::future::join_all;
use std::time::Instant;

async fn sleep_ms(start: &amp;Instant, id: u64, duration_ms: u64) {
    std::thread::sleep(std::time::Duration::from_millis(duration_ms));
    println!(
        &quot;future {id} slept for {duration_ms}ms, finished after {}ms&quot;,
        start.elapsed().as_millis()
    );
}

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn main() {
    let start = Instant::now();
    let sleep_futures = (1..=10).map(|t| sleep_ms(&amp;start, t, t * 10));
    join_all(sleep_futures).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p>è¿è¡Œè¯¥ä»£ç ï¼Œæ‚¨ä¼šå‘ç°ä¼‘çœ æ“ä½œæ˜¯è¿ç»­å‘ç”Ÿçš„ï¼Œè€Œä¸æ˜¯å¹¶å‘è¿›è¡Œçš„ã€‚</p>
</li>
<li>
<p><code>&quot;current_thread&quot;</code> å˜ç§å°†æ‰€æœ‰ä»»åŠ¡æ”¾åœ¨å•ä¸ªçº¿ç¨‹ä¸Šã€‚è¿™æ ·åšæ•ˆæœä¼šæ›´æ˜æ˜¾ï¼Œä½† bug ä»ç„¶å­˜åœ¨äºå¤šçº¿ç¨‹å˜ç§ä¸­ã€‚</p>
</li>
<li>
<p>å°† <code>std::thread::sleep</code> åˆ‡æ¢ä¸º <code>tokio::time::sleep</code>ï¼Œå¹¶ç­‰å¾…ç»“æœã€‚</p>
</li>
<li>
<p>å¦ä¸€ä¸ªä¿®å¤æ–¹æ¡ˆæ˜¯ <code>tokio::task::spawn_blocking</code>ï¼Œå…¶ä¼šç”Ÿæˆå®é™…çº¿ç¨‹å¹¶å°†å¥æŸ„è½¬æ¢ä¸º Futureï¼Œä¸”ä¸ä¼šé˜»å¡æ‰§è¡Œå™¨ã€‚</p>
</li>
<li>
<p>ä¸åº”å°†ä»»åŠ¡è§†ä¸ºæ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚å®ƒä»¬ä¹‹é—´å¹¶éä¸€å¯¹ä¸€çš„æ˜ å°„å…³ç³»ï¼Œå¹¶ä¸”å¤§å¤šæ•°æ‰§è¡Œå™¨éƒ½æ”¯æŒåœ¨å•ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ä¸Šè¿è¡Œå¤šä¸ªä»»åŠ¡ã€‚å°¤å…¶æ˜¯é€šè¿‡ FFI ä¸å…¶ä»–åº“äº¤äº’æ—¶ï¼Œä¼šæ›´å®¹æ˜“å‡ºç°é—®é¢˜ï¼Œå› ä¸ºåœ¨ FFI ä¸­ï¼Œå› ä¸ºè¯¥åº“å¯èƒ½ä¾èµ–äºçº¿ç¨‹æœ¬åœ°å­˜å‚¨æˆ–æ˜ å°„åˆ°ç‰¹å®šçš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼ˆä¾‹å¦‚ï¼ŒCUDAï¼‰ã€‚åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œé¦–é€‰ <code>tokio::task::spawn_blocking</code>ã€‚</p>
</li>
<li>
<p>è¯·è°¨æ…ä½¿ç”¨åŒæ­¥äº’æ–¥æ“ä½œã€‚å¯¹ <code>.await</code> ä¸€ç›´æ‰§è¡Œäº’æ–¥æ“ä½œèƒ½ä¼šå¯¼è‡´å¦ä¸€ä¸ªä»»åŠ¡é˜»å¡ï¼Œå¹¶ä¸”è¯¥ä»»åŠ¡å¯èƒ½ä¸å…¶åœ¨åŒä¸€çº¿ç¨‹ä¸Šè¿è¡Œã€‚</p>
</li>
</ul>
</details><h1><a class="header" href="#pin" id="pin"><code>Pin</code></a></h1>
<p>Async blocks and functions return types implementing the <code>Future</code> trait. The type returned is the result of a compiler transformation which turns local variables into data stored inside the future.</p>
<p>Some of those variables can hold pointers to other local variables. Because of that, the future should never be moved to a different memory location, as it would invalidate those pointers.</p>
<p>To prevent moving the future type in memory, it can only be polled through a pinned pointer. <code>Pin</code> is a wrapper around a reference that disallows all operations that would move the instance it points to into a different memory location.</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use tokio::sync::{mpsc, oneshot};
use tokio::task::spawn;
use tokio::time::{sleep, Duration};

// A work item. In this case, just sleep for the given time and respond
// with a message on the `respond_on` channel.
#[derive(Debug)]
struct Work {
    input: u32,
    respond_on: oneshot::Sender&lt;u32&gt;,
}

// A worker which listens for work on a queue and performs it.
async fn worker(mut work_queue: mpsc::Receiver&lt;Work&gt;) {
    let mut iterations = 0;
    loop {
        tokio::select! {
            Some(work) = work_queue.recv() =&gt; {
                sleep(Duration::from_millis(10)).await; // Pretend to work.
                work.respond_on
                    .send(work.input * 1000)
                    .expect(&quot;failed to send response&quot;);
                iterations += 1;
            }
            // TODO: report number of iterations every 100ms
        }
    }
}

// A requester which requests work and waits for it to complete.
async fn do_work(work_queue: &amp;mpsc::Sender&lt;Work&gt;, input: u32) -&gt; u32 {
    let (tx, rx) = oneshot::channel();
    work_queue
        .send(Work { input, respond_on: tx })
        .await
        .expect(&quot;failed to send on work queue&quot;);
    rx.await.expect(&quot;failed waiting for response&quot;)
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);
    spawn(worker(rx));
    for i in 0..100 {
        let resp = do_work(&amp;tx, i).await;
        println!(&quot;work result for iteration {i}: {resp}&quot;);
    }
}
</code></pre></pre>
<details>
<ul>
<li>
<p>æ‚¨å¯èƒ½è®¤ä¸ºè¿™æ˜¯æ‰§è¡Œå™¨æ¨¡å¼çš„ä¸€ä¸ªç¤ºä¾‹ã€‚æ‰§è¡Œå™¨é€šå¸¸ä¼šå¾ªç¯è°ƒç”¨ <code>select!</code>ã€‚</p>
</li>
<li>
<p>æœ¬éƒ¨åˆ†æ˜¯å¯¹å‰é¢å‡ èŠ‚è¯¾çš„æ€»ç»“ï¼Œå› æ­¤è¯·å¤šèŠ±æ—¶é—´ç”¨å¿ƒå­¦ä¹ ã€‚</p>
<ul>
<li>
<p>åªæ˜¯å•çº¯åœ°åœ¨ <code>select!</code> ä¸­æ·»åŠ  <code>_ = sleep(Duration::from_millis(100)) =&gt; { println!(..) }</code>ï¼Œè¯¥è¡Œä»£ç å°†ä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿ</p>
</li>
<li>
<p>è¯·æ”¹ä¸ºåœ¨ <code>loop</code> å¤–éƒ¨æ·»åŠ åŒ…å«è¯¥ Future çš„ <code>timeout_fut</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let timeout_fut = sleep(Duration::from_millis(100));
loop {
    select! {
        ..,
        _ = timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>è¿™ä»ç„¶ä¸èµ·ä½œç”¨ã€‚æ ¹æ®ç¼–è¯‘å™¨æç¤ºçš„é”™è¯¯ï¼Œé€šè¿‡å‘ <code>select!</code> ä¸­çš„ <code>timeout_fut</code> æ·»åŠ  <code>&amp;mut</code> è§£å†³ç§»åŠ¨é—®é¢˜ï¼Œç„¶åä½¿ç”¨ <code>Box::pin</code>ï¼š</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        ..,
        _ = &amp;mut timeout_fut =&gt; { println!(..); },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>This compiles, but once the timeout expires it is <code>Poll::Ready</code> on every iteration (a fused future would help with this). Update to reset <code>timeout_fut</code> every time it expires:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
loop {
    select! {
        _ = &amp;mut timeout_fut =&gt; {
            println!(..);
            timeout_fut = Box::pin(sleep(Duration::from_millis(100)));
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p>Box åœ¨å †ä¸Šè¿›è¡Œåˆ†é…ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä½¿ç”¨ <code>std::pin::pin!</code>ï¼ˆæœ€è¿‘æ‰æ­£å¼å‘å¸ƒï¼Œè¾ƒæ—§çš„ä»£ç é€šå¸¸ä½¿ç”¨ <code>tokio::pin!</code>ï¼‰ï¼Œä½†å¯¹äºé‡æ–°åˆ†é…çš„ Futureï¼Œä½¿ç”¨æ­¤åŠŸèƒ½è¾ƒä¸ºå›°éš¾ã€‚</p>
</li>
<li>
<p>å¦ä¸€ç§æ›¿ä»£æ–¹æ¡ˆæ˜¯å®Œå…¨ä¸ä½¿ç”¨ <code>pin</code>ï¼Œè€Œæ˜¯ç”Ÿæˆå¦ä¸€ä¸ªä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡æ¯éš” 100 æ¯«ç§’å°±ä¼šå‘é€åˆ° <code>oneshot</code> é€šé“ã€‚</p>
</li>
<li>
<p>Data that contains pointers to itself is called self-referential. Normally, the Rust borrow checker would prevent self-referential data from being moved, as the references cannot outlive the data they point to. However, the code transformation for async blocks and functions is not verified by the borrow checker.</p>
</li>
<li>
<p><code>Pin</code> is a wrapper around a reference. An object cannot be moved from its place using a pinned pointer. However, it can still be moved through an unpinned pointer.</p>
</li>
<li>
<p>The <code>poll</code> method of the <code>Future</code> trait uses <code>Pin&lt;&amp;mut Self&gt;</code> instead of <code>&amp;mut Self</code> to refer to the instance. That's why it can only be called on a pinned pointer.</p>
</li>
</ul>
</details><h1><a class="header" href="#å¼‚æ­¥ç‰¹å¾" id="å¼‚æ­¥ç‰¹å¾">å¼‚æ­¥ç‰¹å¾</a></h1>
<p>Async methods in traits are were stabilized in the 1.75 release. This required support for using return-position <code>impl Trait</code> in traits, as the desugaring for <code>async fn</code> includes <code>-&gt; impl Future&lt;Output = ...&gt;</code>.</p>
<p>However, even with the native support, there are some pitfalls around <code>async fn</code>:</p>
<ul>
<li>
<p>Return-position <code>impl Trait</code> captures all in-scope lifetimes (so some patterns of borrowing cannot be expressed).</p>
</li>
<li>
<p>Async traits cannot be used with <a href="concurrency/async-pitfalls/../../smart-pointers/trait-objects.html">trait objects</a> (<code>dyn Trait</code> support).</p>
</li>
</ul>
<p>The <a href="https://docs.rs/async-trait/">async_trait</a> crate provides a workaround for <code>dyn</code> support through a macro, with some caveats:</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use async_trait::async_trait;
use std::time::Instant;
use tokio::time::{sleep, Duration};

#[async_trait]
trait Sleeper {
    async fn sleep(&amp;self);
}

struct FixedSleeper {
    sleep_ms: u64,
}

#[async_trait]
impl Sleeper for FixedSleeper {
    async fn sleep(&amp;self) {
        sleep(Duration::from_millis(self.sleep_ms)).await;
    }
}

async fn run_all_sleepers_multiple_times(
    sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt;,
    n_times: usize,
) {
    for _ in 0..n_times {
        println!(&quot;Running all sleepers...&quot;);
        for sleeper in &amp;sleepers {
            let start = Instant::now();
            sleeper.sleep().await;
            println!(&quot;Slept for {} ms&quot;, start.elapsed().as_millis());
        }
    }
}

#[tokio::main]
async fn main() {
    let sleepers: Vec&lt;Box&lt;dyn Sleeper&gt;&gt; = vec![
        Box::new(FixedSleeper { sleep_ms: 50 }),
        Box::new(FixedSleeper { sleep_ms: 100 }),
    ];
    run_all_sleepers_multiple_times(sleepers, 5).await;
}
</code></pre></pre>
<details>
<ul>
<li>
<p><code>async_trait</code> æ˜“äºä½¿ç”¨ï¼Œä½†è¯·æ³¨æ„ï¼Œå®ƒé€šè¿‡å †åˆ†é…æ¥å®ç°è¿™ä¸€ç‚¹ã€‚è¿™ç§å †åˆ†é…ä¼šäº§ç”Ÿæ€§èƒ½å¼€é”€ã€‚</p>
</li>
<li>
<p>The challenges in language support for <code>async trait</code> are too deep to describe in-depth in this class. See <a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">this blog post</a> by Niko Matsakis if you are interested in digging deeper. See also these keywords:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/types/impl-trait.html#abstract-return-types">RPIT</a>: short for <a href="concurrency/async-pitfalls/../../generics/impl-trait.html">return-position <code>impl Trait</code></a>.</li>
<li><a href="https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html">RPITIT</a>: short for return-position <code>impl Trait</code> in trait (RPIT in trait).</li>
</ul>
</li>
<li>
<p>Try creating a new sleeper struct that will sleep for a random amount of time and adding it to the <code>Vec</code>.</p>
</li>
</ul>
</details>
<h1><a class="header" href="#æ¶ˆé™¤" id="æ¶ˆé™¤">æ¶ˆé™¤</a></h1>
<p>ä¸¢å¼ƒ Future æ„å‘³ç€æ— æ³•å†å¯¹å…¶è¿›è¡Œè½®è¯¢ã€‚è¿™ç§°ä¸º <em>å–æ¶ˆ</em>ï¼Œåœ¨ä»»ä½• <code>await</code> ç‚¹éƒ½å¯èƒ½å‘ç”Ÿã€‚è¯·åŠ¡å¿…å°å¿ƒè°¨æ…ï¼Œç¡®ä¿å³ä½¿ Future ä»»åŠ¡è¢«å–æ¶ˆï¼Œç³»ç»Ÿä¹Ÿèƒ½æ­£å¸¸è¿è¡Œã€‚ä¾‹å¦‚ï¼Œç³»ç»Ÿä¸åº”æ­»é”æˆ–ä¸¢å¤±æ•°æ®ã€‚</p>
<pre><pre class="playground"><code class="language-rust editable compile_fail">use std::io;
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt, DuplexStream};

struct LinesReader {
    stream: DuplexStream,
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream }
    }

    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        let mut bytes = Vec::new();
        let mut buf = [0];
        while self.stream.read(&amp;mut buf[..]).await? != 0 {
            bytes.push(buf[0]);
            if buf[0] == b'\n' {
                break;
            }
        }
        if bytes.is_empty() {
            return Ok(None);
        }
        let s = String::from_utf8(bytes)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        Ok(Some(s))
    }
}

async fn slow_copy(source: String, mut dest: DuplexStream) -&gt; io::Result&lt;()&gt; {
    for b in source.bytes() {
        dest.write_u8(b).await?;
        tokio::time::sleep(Duration::from_millis(10)).await
    }
    Ok(())
}

#[tokio::main]
async fn main() -&gt; io::Result&lt;()&gt; {
    let (client, server) = tokio::io::duplex(5);
    let handle = tokio::spawn(slow_copy(&quot;hi\nthere\n&quot;.to_owned(), client));

    let mut lines = LinesReader::new(server);
    let mut interval = tokio::time::interval(Duration::from_millis(60));
    loop {
        tokio::select! {
            _ = interval.tick() =&gt; println!(&quot;tick!&quot;),
            line = lines.next() =&gt; if let Some(l) = line? {
                print!(&quot;{}&quot;, l)
            } else {
                break
            },
        }
    }
    handle.await.unwrap()?;
    Ok(())
}
</code></pre></pre>
<details>
<ul>
<li>
<p>ç¼–è¯‘å™¨æ— æ³•ç¡®ä¿å–æ¶ˆæ“ä½œçš„å®‰å…¨æ€§ã€‚æ‚¨éœ€è¦é˜…è¯» API æ–‡æ¡£ï¼Œå¹¶è€ƒè™‘ <code>async fn</code> æ‰€æŒçŠ¶æ€ã€‚</p>
</li>
<li>
<p>ä¸ <code>panic</code> å’Œ <code>?</code> ä¸åŒï¼Œå–æ¶ˆå±äºæ­£å¸¸æ§åˆ¶æµçš„ä¸€éƒ¨åˆ†ï¼ˆè€Œéé”™è¯¯å¤„ç†ï¼‰ã€‚</p>
</li>
<li>
<p>è¯¥ç¤ºä¾‹ä¸¢å¤±äº†å­—ç¬¦ä¸²çš„æŸäº›éƒ¨åˆ†ã€‚</p>
<ul>
<li>
<p>æ¯å½“ <code>tick()</code> åˆ†æ”¯å…ˆå®Œæˆæ“ä½œæ—¶ï¼Œ<code>next() åŠå…¶ </code>buf` å‡ä¼šè¢«ä¸¢å¼ƒã€‚</p>
</li>
<li>
<p>é€šè¿‡å°† <code>buf</code> æ•´åˆåˆ°ç»“æ„ä½“ä¸­ï¼Œ`LinesReader å¯ä»¥ç¡®ä¿å–æ¶ˆæ“ä½œçš„å®‰å…¨æ€§ï¼š</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LinesReader {
    stream: DuplexStream,
    bytes: Vec&lt;u8&gt;,
    buf: [u8; 1],
}

impl LinesReader {
    fn new(stream: DuplexStream) -&gt; Self {
        Self { stream, bytes: Vec::new(), buf: [0] }
    }
    async fn next(&amp;mut self) -&gt; io::Result&lt;Option&lt;String&gt;&gt; {
        // prefix buf and bytes with self.
        // ...
        let raw = std::mem::take(&amp;mut self.bytes);
        let s = String::from_utf8(raw)
            .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, &quot;not UTF-8&quot;))?;
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/time/struct.Interval.html#method.tick"><code>Interval::tick</code></a> is cancellation-safe because it keeps track of whether a tick has been 'delivered'.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncReadExt.html#method.read"><code>AsyncReadExt::read</code></a> is cancellation-safe because it either returns or doesn't read data.</p>
</li>
<li>
<p><a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncBufReadExt.html#method.read_line"><code>AsyncBufReadExt::read_line</code></a> is similar to the example and <em>isn't</em> cancellation-safe. See its documentation for details and alternatives.</p>
</li>
</ul>
</details><h1><a class="header" href="#ä¹ é¢˜-3" id="ä¹ é¢˜-3">ä¹ é¢˜</a></h1>
<p>{{%segment outline}}</p>
<h1><a class="header" href="#dining-philosophers-----async" id="dining-philosophers-----async">Dining Philosophers --- Async</a></h1>
<p>See <a href="concurrency/async-exercises/../sync-exercises/dining-philosophers.html">dining philosophers</a> for a description of the problem.</p>
<p>As before, you will need a local <a href="concurrency/async-exercises/../../cargo/running-locally.html">Cargo installation</a> for this exercise. Copy the code below to a file called <code>src/main.rs</code>, fill out the blanks, and test that <code>cargo run</code> does not deadlock:</p>
<!-- File src/main.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    // left_fork: ...
    // right_fork: ...
    // thoughts: ...
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks

    // Create philosophers

    // Make them think and eat

    // Output their thoughts
}
</code></pre></pre>
<p>å› ä¸ºè¿™æ¬¡æ‚¨æ­£åœ¨ä½¿ç”¨å¼‚æ­¥Rustï¼Œæ‚¨å°†éœ€è¦ä¸€ä¸ª <code>tokio</code> ä¾èµ–ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹çš„ <code>Cargo.toml</code>ï¼š</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;dining-philosophers-async-dine&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
tokio = { version = &quot;1.26.0&quot;, features = [&quot;sync&quot;, &quot;time&quot;, &quot;macros&quot;, &quot;rt-multi-thread&quot;] }
</code></pre>
<p>å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œè¿™æ¬¡æ‚¨å¿…é¡»ä½¿ç”¨æ¥è‡ª <code>tokio</code> åŒ…çš„ <code>Mutex</code> å’Œ <code>mpsc</code> æ¨¡å—ã€‚</p>
<details>
<ul>
<li>Can you make your implementation single-threaded?</li>
</ul>
</details><h1><a class="header" href="#å¹¿æ’­èŠå¤©åº”ç”¨" id="å¹¿æ’­èŠå¤©åº”ç”¨">å¹¿æ’­èŠå¤©åº”ç”¨</a></h1>
<p>åœ¨æœ¬ç»ƒä¹ ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨æˆ‘ä»¬çš„æ–°çŸ¥è¯†æ¥å®ç°ä¸€ä¸ªå¹¿æ’­èŠå¤©åº”ç”¨ã€‚æˆ‘ä»¬æœ‰ä¸€ä¸ªèŠå¤©æœåŠ¡å™¨ï¼Œå®¢æˆ·ç«¯è¿æ¥åˆ°è¯¥æœåŠ¡å™¨å¹¶å‘å¸ƒä»–ä»¬çš„æ¶ˆæ¯ã€‚å®¢æˆ·ç«¯ä»æ ‡å‡†è¾“å…¥è¯»å–ç”¨æˆ·æ¶ˆæ¯ï¼Œå¹¶å°†å…¶å‘é€åˆ°æœåŠ¡å™¨ã€‚èŠå¤©æœåŠ¡å™¨å°†æ”¶åˆ°çš„æ¯æ¡æ¶ˆæ¯å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯ã€‚</p>
<p>For this, we use <a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/fn.channel.html">a broadcast channel</a> on the server, and <a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a> for the communication between the client and the server.</p>
<p>åˆ›å»ºä¸€ä¸ªæ–°çš„ Cargo é¡¹ç›®å¹¶æ·»åŠ ä»¥ä¸‹ä¾èµ–ï¼š</p>
<p><em>Cargo.toml</em>:</p>
<!-- File Cargo.toml -->
<pre><code class="language-toml">[package]
name = &quot;chat-async&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
futures-util = { version = &quot;0.3.31&quot;, features = [&quot;sink&quot;] }
http = &quot;1.1.0&quot;
tokio = { version = &quot;1.41.1&quot;, features = [&quot;full&quot;] }
tokio-websockets = { version = &quot;0.10.1&quot;, features = [&quot;client&quot;, &quot;fastrand&quot;, &quot;server&quot;, &quot;sha1_smol&quot;] }
</code></pre>
<h2><a class="header" href="#æ‰€éœ€çš„api" id="æ‰€éœ€çš„api">æ‰€éœ€çš„API</a></h2>
<p>You are going to need the following functions from <code>tokio</code> and <a href="https://docs.rs/tokio-websockets/"><code>tokio_websockets</code></a>. Spend a few minutes to familiarize yourself with the API.</p>
<ul>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/stream/trait.StreamExt.html#method.next">StreamExt::next()</a> implemented by <code>WebSocketStream</code>: for asynchronously reading messages from a Websocket Stream.</li>
<li><a href="https://docs.rs/futures-util/0.3.28/futures_util/sink/trait.SinkExt.html#method.send">SinkExt::send()</a> implemented by <code>WebSocketStream</code>: for asynchronously sending messages on a Websocket Stream.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/io/struct.Lines.html#method.next_line">Lines::next_line()</a>: for asynchronously reading user messages from the standard input.</li>
<li><a href="https://docs.rs/tokio/latest/tokio/sync/broadcast/struct.Sender.html#method.subscribe">Sender::subscribe()</a>ï¼šç”¨äºè®¢é˜…å¹¿æ’­é¢‘é“ã€‚</li>
</ul>
<h2><a class="header" href="#ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶" id="ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶">ä¸¤ä¸ªå¯æ‰§è¡Œæ–‡ä»¶</a></h2>
<p>Normally in a Cargo project, you can have only one binary, and one <code>src/main.rs</code> file. In this project, we need two binaries. One for the client, and one for the server. You could potentially make them two separate Cargo projects, but we are going to put them in a single Cargo project with two binaries. For this to work, the client and the server code should go under <code>src/bin</code> (see the <a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries">documentation</a>).</p>
<p>Copy the following server and client code into <code>src/bin/server.rs</code> and <code>src/bin/client.rs</code>, respectively. Your task is to complete these files as described below.</p>
<p><em>src/bin/server.rs</em>:</p>
<!-- File src/bin/server.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    // TODO: For a hint, see the description of the task below.

}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<!-- File src/bin/client.rs -->
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();


    // TODO: For a hint, see the description of the task below.

}
</code></pre></pre>
<h2><a class="header" href="#è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶" id="è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶">è¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶</a></h2>
<p>Run the server with:</p>
<pre><code class="language-shell">cargo run --bin server
</code></pre>
<p>and the client with:</p>
<pre><code class="language-shell">cargo run --bin client
</code></pre>
<h2><a class="header" href="#ä»»åŠ¡-2" id="ä»»åŠ¡-2">ä»»åŠ¡</a></h2>
<ul>
<li>åœ¨ <code>src/bin/server.rs</code> ä¸­å®ç° <code>handle_connection</code> å‡½æ•°ã€‚
<ul>
<li>æç¤ºï¼šä½¿ç”¨ <code>tokio::select!</code> åœ¨ä¸€ä¸ªè¿ç»­çš„å¾ªç¯ä¸­å¹¶å‘æ‰§è¡Œä¸¤ä¸ªä»»åŠ¡ã€‚ä¸€ä¸ªä»»åŠ¡ä»å®¢æˆ·ç«¯æ¥æ”¶æ¶ˆæ¯å¹¶å¹¿æ’­å®ƒä»¬ã€‚å¦ä¸€ä¸ªä»»åŠ¡å°†æœåŠ¡å™¨æ¥æ”¶åˆ°çš„æ¶ˆæ¯å‘é€ç»™å®¢æˆ·ç«¯ã€‚</li>
</ul>
</li>
<li>å®Œæˆ <code>src/bin/client.rs</code> ä¸­çš„ <code>main</code> å‡½æ•°ã€‚
<ul>
<li>Hint: As before, use <code>tokio::select!</code> in a continuous loop for concurrently performing two tasks: (1) reading user messages from standard input and sending them to the server, and (2) receiving messages from the server, and displaying them for the user.</li>
</ul>
</li>
<li>Optional: Once you are done, change the code to broadcast messages to all clients, but the sender of the message.</li>
</ul>
<h1><a class="header" href="#è§£ç­”-20" id="è§£ç­”-20">è§£ç­”</a></h1>
<h2><a class="header" href="#dining-philosophers-----async-1" id="dining-philosophers-----async-1">Dining Philosophers --- Async</a></h2>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};
use tokio::time;

struct Fork;

struct Philosopher {
    name: String,
    left_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    right_fork: Arc&lt;Mutex&lt;Fork&gt;&gt;,
    thoughts: mpsc::Sender&lt;String&gt;,
}

impl Philosopher {
    async fn think(&amp;self) {
        self.thoughts
            .send(format!(&quot;Eureka! {} has a new idea!&quot;, &amp;self.name))
            .await
            .unwrap();
    }

    async fn eat(&amp;self) {
        // Keep trying until we have both forks
        // Pick up forks...
        let _left_fork = self.left_fork.lock().await;
        let _right_fork = self.right_fork.lock().await;

        println!(&quot;{} is eating...&quot;, &amp;self.name);
        time::sleep(time::Duration::from_millis(5)).await;

        // The locks are dropped here
    }
}

static PHILOSOPHERS: &amp;[&amp;str] =
    &amp;[&quot;Socrates&quot;, &quot;Hypatia&quot;, &quot;Plato&quot;, &quot;Aristotle&quot;, &quot;Pythagoras&quot;];

#[tokio::main]
async fn main() {
    // Create forks
    let mut forks = vec![];
    (0..PHILOSOPHERS.len()).for_each(|_| forks.push(Arc::new(Mutex::new(Fork))));

    // Create philosophers
    let (philosophers, mut rx) = {
        let mut philosophers = vec![];
        let (tx, rx) = mpsc::channel(10);
        for (i, name) in PHILOSOPHERS.iter().enumerate() {
            let mut left_fork = Arc::clone(&amp;forks[i]);
            let mut right_fork = Arc::clone(&amp;forks[(i + 1) % PHILOSOPHERS.len()]);
            if i == PHILOSOPHERS.len() - 1 {
                std::mem::swap(&amp;mut left_fork, &amp;mut right_fork);
            }
            philosophers.push(Philosopher {
                name: name.to_string(),
                left_fork,
                right_fork,
                thoughts: tx.clone(),
            });
        }
        (philosophers, rx)
        // tx is dropped here, so we don't need to explicitly drop it later
    };

    // Make them think and eat
    for phil in philosophers {
        tokio::spawn(async move {
            for _ in 0..100 {
                phil.think().await;
                phil.eat().await;
            }
        });
    }

    // Output their thoughts
    while let Some(thought) = rx.recv().await {
        println!(&quot;Here is a thought: {thought}&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#å¹¿æ’­èŠå¤©åº”ç”¨-1" id="å¹¿æ’­èŠå¤©åº”ç”¨-1">å¹¿æ’­èŠå¤©åº”ç”¨</a></h2>
<p><em>src/bin/server.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::sink::SinkExt;
use futures_util::stream::StreamExt;
use std::error::Error;
use std::net::SocketAddr;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::broadcast::{channel, Sender};
use tokio_websockets::{Message, ServerBuilder, WebSocketStream};

async fn handle_connection(
    addr: SocketAddr,
    mut ws_stream: WebSocketStream&lt;TcpStream&gt;,
    bcast_tx: Sender&lt;String&gt;,
) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {

    ws_stream
        .send(Message::text(&quot;Welcome to chat! Type a message&quot;.to_string()))
        .await?;
    let mut bcast_rx = bcast_tx.subscribe();

    // A continuous loop for concurrently performing two tasks: (1) receiving
    // messages from `ws_stream` and broadcasting them, and (2) receiving
    // messages on `bcast_rx` and sending them to the client.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From client {addr:?} {text:?}&quot;);
                            bcast_tx.send(text.into())?;
                        }
                    }
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            msg = bcast_rx.recv() =&gt; {
                ws_stream.send(Message::text(msg?)).await?;
            }
        }
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {
    let (bcast_tx, _) = channel(16);

    let listener = TcpListener::bind(&quot;127.0.0.1:2000&quot;).await?;
    println!(&quot;listening on port 2000&quot;);

    loop {
        let (socket, addr) = listener.accept().await?;
        println!(&quot;New connection from {addr:?}&quot;);
        let bcast_tx = bcast_tx.clone();
        tokio::spawn(async move {
            // Wrap the raw TCP stream into a websocket.
            let ws_stream = ServerBuilder::new().accept(socket).await?;

            handle_connection(addr, ws_stream, bcast_tx).await
        });
    }
}
</code></pre></pre>
<p><em>src/bin/client.rs</em>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">use futures_util::stream::StreamExt;
use futures_util::SinkExt;
use http::Uri;
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio_websockets::{ClientBuilder, Message};

#[tokio::main]
async fn main() -&gt; Result&lt;(), tokio_websockets::Error&gt; {
    let (mut ws_stream, _) =
        ClientBuilder::from_uri(Uri::from_static(&quot;ws://127.0.0.1:2000&quot;))
            .connect()
            .await?;

    let stdin = tokio::io::stdin();
    let mut stdin = BufReader::new(stdin).lines();

    // Continuous loop for concurrently sending and receiving messages.
    loop {
        tokio::select! {
            incoming = ws_stream.next() =&gt; {
                match incoming {
                    Some(Ok(msg)) =&gt; {
                        if let Some(text) = msg.as_text() {
                            println!(&quot;From server: {}&quot;, text);
                        }
                    },
                    Some(Err(err)) =&gt; return Err(err.into()),
                    None =&gt; return Ok(()),
                }
            }
            res = stdin.next_line() =&gt; {
                match res {
                    Ok(None) =&gt; return Ok(()),
                    Ok(Some(line)) =&gt; ws_stream.send(Message::text(line.to_string())).await?,
                    Err(err) =&gt; return Err(err.into()),
                }
            }

        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#è°¢è°¢" id="è°¢è°¢">è°¢è°¢ï¼</a></h1>
<p><em>Thank you for taking Comprehensive Rust ğŸ¦€!</em> We hope you enjoyed it and that it was useful.</p>
<p>ç»„ç»‡è¿™é—¨è¯¾ç¨‹è®©æˆ‘ä»¬æ”¶è·äº†å¾ˆå¤šä¹è¶£ã€‚æœ¬è¯¾ç¨‹å¹¶éå®Œç¾æ— ç¼ºï¼Œå› æ­¤ï¼Œå¦‚æœæ‚¨å‘ç°ä»»ä½•é”™è¯¯æˆ–æœ‰ä»»ä½•æ”¹è¿›å»ºè®®ï¼Œè¯·<a href="https://github.com/google/comprehensive-rust/discussions">åœ¨ GitHub ä¸Šä¸æˆ‘ä»¬è”ç³»</a>ã€‚æˆ‘ä»¬æœŸå¾…æ”¶åˆ°æ‚¨çš„å®è´µæ„è§ã€‚</p>
<!-- i18n:comment Please keep { #glossary } untranslated. -->
<h1><a class="header" href="#è¯æ±‡è¡¨--glossary-" id="è¯æ±‡è¡¨--glossary-">è¯æ±‡è¡¨ { #glossary }</a></h1>
<p>æœ¬é¡µé¢çš„è¯æ±‡è¡¨æä¾›äº†è®¸å¤š Rust æœ¯è¯­çš„ç®€è¦å®šä¹‰ã€‚åŒæ—¶æä¾›ç¿»è¯‘ç‰ˆæœ¬å’Œè‹±è¯­åŸæ–‡çš„å¯¹åº”ã€‚</p>
<style>
h1#glossary ~ ul {
    list-style: none;
    padding-inline-start: 0;
}

h1#glossary ~ ul > li {
    /* Simplify with "text-indent: 2em hanging" when supported:
       https://caniuse.com/mdn-css_properties_text-indent_hanging */
    padding-left: 2em;
    text-indent: -2em;
}

h1#glossary ~ ul > li:first-line {
    font-weight: bold;
}
</style>
<!-- i18n:comment Please add the English term in italic after your -->
<!-- i18n:comment translated term. Also, please keep the hard line -->
<!-- i18n:comment breaks to ensure a nice formatting. -->
<ul>
<li>allocate:<br />
Dynamic memory allocation on <a href="memory-management/review.html">the heap</a>.</li>
<li>å‚æ•°ï¼ˆargumentï¼‰ï¼š<br />
ä¼ å…¥æŸä¸ªå‡½æ•°æˆ–æ–¹æ³•ä¸­çš„ä¿¡æ¯ã€‚</li>
<li>associated type:<br />
A type associated with a specific trait. Useful for defining the relationship between types.</li>
<li>è£¸æœº Rustï¼ˆBare-metal Rustï¼‰ï¼š<br />
åº•å±‚ Rust å¼€å‘æ–¹å¼ï¼Œé€šå¸¸éƒ¨ç½²äºæ²¡æœ‰æ“ä½œç³»ç»Ÿçš„ç³»ç»Ÿã€‚è¯·å‚é˜… <a href="bare-metal.html">è£¸æœº Rust</a>ã€‚</li>
<li>block:<br />
See <a href="control-flow-basics/blocks-and-scopes.html">Blocks</a> and <em>scope</em>.</li>
<li>borrow:<br />
See <a href="borrowing/shared.html">Borrowing</a>.</li>
<li>å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆborrow checkerï¼‰ï¼š<br />
Rust ç¼–è¯‘å™¨çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºæ£€æŸ¥æ‰€æœ‰å€Ÿç”¨æ“ä½œæ˜¯å¦æœ‰æ•ˆã€‚</li>
<li>å¤§æ‹¬å·ï¼ˆbraceï¼‰ï¼š<br />
<code>{</code> å’Œ <code>}</code>ã€‚ä¹Ÿç§°ä¸º <strong>èŠ±æ‹¬å·</strong>ï¼Œç”¨äºåˆ†éš” <strong>ä»£ç å—</strong>ã€‚</li>
<li>æ„å»ºï¼ˆbuildï¼‰ï¼š<br />
å°†æºä»£ç è½¬æ¢ä¸ºå¯æ‰§è¡Œä»£ç æˆ–å¯ç”¨ç¨‹åºçš„è¿‡ç¨‹ã€‚</li>
<li>è°ƒç”¨ï¼ˆcallï¼‰ï¼š<br />
è°ƒç”¨æˆ–æ‰§è¡ŒæŸä¸ªå‡½æ•°æˆ–æ–¹æ³•ã€‚</li>
<li>é€šé“ï¼ˆchannelï¼‰ï¼š<br />
ç”¨äºå®‰å…¨åœ° <a href="concurrency/channels.html">åœ¨çº¿ç¨‹ä¹‹é—´</a> ä¼ é€’æ¶ˆæ¯ã€‚</li>
<li>Comprehensive Rust ğŸ¦€ï¼š<br />
æœ¬è¯¾ç¨‹ç»Ÿç§°ä¸º Comprehensive Rust ğŸ¦€ã€‚</li>
<li>å¹¶å‘ï¼ˆconcurrencyï¼‰ï¼š<br />
åŒæ—¶æ‰§è¡Œå¤šä¸ªä»»åŠ¡æˆ–è¿›ç¨‹ã€‚</li>
<li>Concurrency in Rust:<br />
See <a href="concurrency/welcome.html">Concurrency in Rust</a>.</li>
<li>å¸¸é‡ï¼ˆconstantï¼‰ï¼š<br />
åœ¨ç¨‹åºæ‰§è¡ŒæœŸé—´ä¸ä¼šæ”¹å˜çš„å€¼ã€‚</li>
<li>æ§åˆ¶æµï¼ˆcontrol flowï¼‰ï¼š<br />
ç¨‹åºä¸­å„ä¸ªè¯­å¥æˆ–æŒ‡ä»¤çš„æ‰§è¡Œé¡ºåºã€‚</li>
<li>å´©æºƒï¼ˆcrashï¼‰ï¼š<br />
ç¨‹åºå‡ºç°æ„å¤–çš„ã€æœªå¤„ç†çš„æ•…éšœæˆ–ç»ˆæ­¢ã€‚</li>
<li>æšä¸¾ï¼ˆenumerationï¼‰ï¼š<br />
ä¸€ç§ç”¨äºä¿å­˜å¤šä¸ªå·²å‘½åå¸¸é‡ä¸­çš„ä¸€ä¸ªçš„æ•°æ®ç±»å‹ï¼Œå¯èƒ½è¿˜æœ‰ä¸€ä¸ªç›¸å…³çš„å…ƒç»„æˆ–ç»“æ„ä½“ã€‚</li>
<li>é”™è¯¯ï¼ˆerrorï¼‰ï¼š<br />
ä¸é¢„æœŸè¡Œä¸ºå­˜åœ¨åå·®çš„æ„å¤–æƒ…å†µæˆ–ç»“æœã€‚</li>
<li>é”™è¯¯å¤„ç†ï¼ˆerror handlingï¼‰ï¼š<br />
å¯¹ç¨‹åºæ‰§è¡ŒæœŸé—´å‘ç”Ÿçš„é”™è¯¯è¿›è¡Œç®¡ç†å’Œå“åº”çš„è¿‡ç¨‹ã€‚</li>
<li>ç»ƒä¹ ï¼ˆexerciseï¼‰ï¼š<br />
ä¸“ä¸ºç»ƒä¹ å’Œæµ‹è¯•ç¼–ç¨‹æŠ€èƒ½è€Œè®¾è®¡çš„ä»»åŠ¡æˆ–é—®é¢˜ã€‚</li>
<li>å‡½æ•°ï¼ˆfunctionï¼‰ï¼š<br />
ç”¨äºæ‰§è¡Œç‰¹å®šä»»åŠ¡ä¸”å¯é‡å¤ä½¿ç”¨çš„ä»£ç å—ã€‚</li>
<li>åƒåœ¾å›æ”¶å™¨ï¼ˆgarbage collectorï¼‰ï¼š<br />
ä¸€ç§è‡ªåŠ¨é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å¯¹è±¡æ‰€å å†…å­˜çš„æœºåˆ¶ã€‚</li>
<li>æ³›å‹ï¼ˆgenericsï¼‰ï¼š<br />
è¿™é¡¹åŠŸèƒ½æ”¯æŒä½¿ç”¨ç±»å‹å ä½ç¬¦ç¼–å†™ä»£ç ï¼Œæ”¯æŒå¯¹ä¸åŒæ•°æ®ç±»å‹çš„ä»£ç è¿›è¡Œé‡å¤ä½¿ç”¨ã€‚</li>
<li>ä¸å¯å˜ï¼ˆimmutableï¼‰ï¼š<br />
åˆ›å»ºåæ— æ³•å†è¿›è¡Œæ›´æ”¹ã€‚</li>
<li>é›†æˆæµ‹è¯•ï¼ˆintegration testï¼‰ï¼š<br />
ä¸€ç§éªŒè¯ç³»ç»Ÿä¸åŒéƒ¨åˆ†æˆ–ç»„ä»¶ä¹‹é—´äº¤äº’çš„æµ‹è¯•ç±»å‹ã€‚</li>
<li>å…³é”®å­—ï¼ˆkeywordï¼‰ï¼š<br />
ç¼–ç¨‹è¯­è¨€ä¸­çš„ä¿ç•™å­—ï¼Œå…·æœ‰ç‰¹å®šå«ä¹‰ä¸”ä¸èƒ½ç”¨ä½œæ ‡è¯†ç¬¦ã€‚</li>
<li>åº“ï¼ˆlibraryï¼‰ï¼š<br />
ç¨‹åºå¯ä»¥ä½¿ç”¨çš„ä¸€ç»„é¢„ç¼–è¯‘ä¾‹ç¨‹æˆ–ä»£ç ã€‚</li>
<li>å®ï¼ˆmacroï¼‰ï¼š<br />
Rust å®å¯é€šè¿‡åç§°ä¸­çš„ <code>!</code> ç¬¦å·è¯†åˆ«ã€‚å½“æ™®é€šå‡½æ•°æ— æ³•æ»¡è¶³éœ€æ±‚æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å®ã€‚ä¸€ä¸ªå…¸å‹ç¤ºä¾‹æ˜¯ <code>format!</code>ï¼Œå…¶æ¥å—å¯å˜æ•°é‡çš„å‚æ•°ï¼Œä½† Rust å‡½æ•°ä¸æ”¯æŒè¿™ç§ç±»å‹ã€‚</li>
<li><code>main</code> å‡½æ•°ï¼ˆ<code>main</code> functionï¼‰ï¼š<br />
Rust ç¨‹åºä» <code>main</code> å‡½æ•°å¼€å§‹æ‰§è¡Œã€‚</li>
<li>åŒ¹é…ï¼ˆmatchï¼‰ï¼š<br />
Rust ä¸­çš„æ§åˆ¶æµç»“æ„ï¼Œå…è®¸å¯¹è¡¨è¾¾å¼çš„å€¼è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚</li>
<li>å†…å­˜æ³„æ¼ï¼ˆmemory leakï¼‰ï¼š<br />
ç¨‹åºæ— æ³•é‡Šæ”¾ä¸å†ä¸è¦çš„å†…å­˜çš„æƒ…å†µï¼Œä¼šå¯¼è‡´å†…å­˜ç”¨é‡ä¸æ–­å¢åŠ ã€‚</li>
<li>æ–¹æ³•ï¼ˆmethodï¼‰ï¼š<br />
ä¸ Rust ä¸­çš„æŸä¸ªå¯¹è±¡æˆ–ç±»å‹ç›¸å…³è”çš„å‡½æ•°ã€‚</li>
<li>æ¨¡å—ï¼ˆmoduleï¼‰ï¼š<br />
Rust ä¸­ç”¨äºå½’çº³æ•´ç†ä»£ç çš„å‘½åç©ºé—´ï¼Œå…¶ä¸­åŒ…å«å‡½æ•°ã€ç±»å‹æˆ–ç‰¹æ€§ç­‰å®šä¹‰ã€‚</li>
<li>ç§»åŠ¨ï¼ˆmoveï¼‰ï¼š<br />
åœ¨ Rust ä¸­ï¼Œå°†å€¼çš„æ‰€æœ‰æƒä»ä¸€ä¸ªå˜é‡è½¬ç§»åˆ°å¦ä¸€ä¸ªå˜é‡ã€‚</li>
<li>å¯å˜ï¼ˆmutableï¼‰ï¼š<br />
Rust ä¸­çš„ä¸€ä¸ªå±æ€§ï¼Œæ”¯æŒåœ¨å£°æ˜å˜é‡åå¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚</li>
<li>æ‰€æœ‰æƒï¼ˆownershipï¼‰ï¼š<br />
Rust ä¸­çš„æ¦‚å¿µï¼Œç”¨äºå®šä¹‰ä»£ç ä¸­çš„å“ªä¸€éƒ¨åˆ†è´Ÿè´£ç®¡ç†ä¸å€¼å…³è”çš„å†…å­˜ã€‚</li>
<li>panicï¼š<br />
Rust ä¸­å¯¼è‡´ç¨‹åºç»ˆæ­¢ä¸”ä¸å¯æ¢å¤çš„é”™è¯¯æƒ…å†µã€‚</li>
<li>å‚æ•°ï¼ˆparameterï¼‰ï¼š<br />
åœ¨è°ƒç”¨å‡½æ•°æˆ–æ–¹æ³•æ—¶ä¼ å…¥å‡½æ•°æˆ–æ–¹æ³•çš„å€¼ã€‚</li>
<li>æ¨¡å¼ï¼ˆpatternï¼‰ï¼š<br />
Rust ä¸­å¯ä¸è¡¨è¾¾å¼åŒ¹é…çš„å€¼ã€å­—é¢é‡æˆ–ç»“æ„çš„ç»„åˆã€‚</li>
<li>è½½è·ï¼ˆpayloadï¼‰ï¼š<br />
æ¶ˆæ¯ã€äº‹ä»¶æˆ–æ•°æ®ç»“æ„æ‰€æºå¸¦çš„æ•°æ®æˆ–ä¿¡æ¯ã€‚</li>
<li>ç¨‹åºï¼ˆprogramï¼‰ï¼š<br />
è®¡ç®—æœºä¸ºæ‰§è¡Œç‰¹å®šä»»åŠ¡æˆ–è§£å†³ç‰¹å®šé—®é¢˜è€Œæ‰§è¡Œçš„ä¸€ç»„æŒ‡ä»¤ã€‚</li>
<li>ç¼–ç¨‹è¯­è¨€ï¼ˆprogramming languageï¼‰ï¼š<br />
ç”¨äºå‘è®¡ç®—æœºä¼ é€’æŒ‡ä»¤çš„æ­£å¼ç³»ç»Ÿï¼Œä¾‹å¦‚ Rustã€‚</li>
<li>æ¥æ”¶å™¨ï¼ˆreceiverï¼‰ï¼š<br />
Rust æ–¹æ³•ä¸­çš„é¦–ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºæ­£åœ¨è°ƒç”¨è¯¥æ–¹æ³•çš„å®ä¾‹ã€‚</li>
<li>å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰ï¼š<br />
ä¸€ç§å†…å­˜ç®¡ç†æ–¹æ³•ï¼Œå¯ä»¥è·Ÿè¸ªæŸä¸ªå¯¹è±¡çš„å¼•ç”¨æ•°é‡ï¼Œå¹¶åœ¨è®¡æ•°ä¸ºé›¶æ—¶é‡Šæ”¾è¯¥å¯¹è±¡ã€‚</li>
<li>è¿”å›ï¼ˆreturnï¼‰ï¼š<br />
Rust ä¸­çš„ä¸€ä¸ªå…³é”®å­—ï¼Œç”¨äºè¡¨ç¤ºä»å‡½æ•°è¿”å›çš„å€¼ã€‚</li>
<li>Rustï¼š<br />
ä¸€ç§ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œä¸“æ³¨äºå®‰å…¨æ€§ã€æ€§èƒ½å’Œå¹¶å‘æ€§ã€‚</li>
<li>Rust åŸºç¡€ï¼ˆRust Fundamentalsï¼‰ï¼š<br />
æœ¬è¯¾ç¨‹ç¬¬ 1 å¤©åˆ°ç¬¬ 4 å¤©çš„å†…å®¹ã€‚</li>
<li>Android ä¸­çš„ Rustï¼ˆRust in Androidï¼‰ï¼š<br />
è¯·å‚é˜… <a href="android.html">Android ä¸­çš„ Rust</a>.</li>
<li>Chromium ä¸­çš„ Rustï¼ˆRust in Chromiumï¼‰:<br />
è¯·å‚é˜… <a href="chromium.html">Chromium ä¸­çš„ Rust</a>.</li>
<li>å®‰å…¨ï¼ˆsafeï¼‰ï¼š<br />
æŒ‡ä»£ç éµå¾ª Rust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™ï¼Œä»¥é˜²æ­¢å‡ºç°ä¸å†…å­˜ç›¸å…³çš„é”™è¯¯ã€‚</li>
<li>ä½œç”¨åŸŸï¼ˆscopeï¼‰ï¼š<br />
ç¨‹åºä¸­å˜é‡æœ‰æ•ˆä¸”å¯ä½¿ç”¨çš„åŒºåŸŸã€‚</li>
<li>æ ‡å‡†åº“ï¼ˆstandard libraryï¼‰ï¼š<br />
Rust ä¸­æä¾›åŸºæœ¬åŠŸèƒ½çš„ä¸€ç³»åˆ—æ¨¡å—ã€‚</li>
<li>é™æ€ï¼ˆstaticï¼‰ï¼š<br />
Rust ä¸­çš„å…³é”®å­—ï¼Œç”¨äºå®šä¹‰å…·æœ‰ <code>'static</code> ç”Ÿå‘½å‘¨æœŸçš„é™æ€å˜é‡æˆ–é¡¹ã€‚</li>
<li>string:<br />
A data type storing textual data. See <a href="references/strings.html">Strings</a> for more.</li>
<li>ç»“æ„ä½“ï¼ˆstructï¼‰ï¼š<br />
Rust ä¸­çš„å¤åˆæ•°æ®ç±»å‹ï¼Œå¯å°†ä¸åŒç±»å‹çš„å˜é‡å½’åˆ°åŒä¸€åç§°ä¸‹ã€‚</li>
<li>æµ‹è¯•ï¼ˆtestï¼‰ï¼š<br />
Rust ä¸­çš„æ¨¡å—ï¼Œå…¶ä¸­åŒ…å«ç”¨äºæµ‹è¯•å…¶ä»–å‡½æ•°æ˜¯å¦æ­£ç¡®çš„å‡½æ•°ã€‚</li>
<li>çº¿ç¨‹ï¼ˆthreadï¼‰ï¼š<br />
ç¨‹åºä¸­çš„å•ç‹¬æ‰§è¡Œé¡ºåºï¼Œæ”¯æŒå¹¶å‘æ‰§è¡Œã€‚</li>
<li>çº¿ç¨‹å®‰å…¨ï¼ˆthread safetyï¼‰ï¼š<br />
ä¸€ç§ç¨‹åºå±æ€§ï¼Œç”¨äºç¡®ä¿å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„è¡Œä¸ºæ­£ç¡®æ— è¯¯ã€‚</li>
<li>ç‰¹å¾ï¼ˆtraitï¼‰ï¼š<br />
ç”¨äºå®šä¹‰æœªçŸ¥ç±»å‹çš„ä¸€ç³»åˆ—æ–¹æ³•ï¼Œä¸ºåœ¨ Rust ä¸­å®ç°å¤šæ€æ€§æä¾›äº†æ–¹æ³•ã€‚</li>
<li>ç‰¹å¾çº¦æŸï¼ˆtrait boundï¼‰:<br />
ä¸€ç§å¯ä»¥è¦æ±‚ç±»å‹å®ç°ä¸€äº›æ„Ÿå…´è¶£çš„ç‰¹æ€§çš„æŠ½è±¡ã€‚</li>
<li>å…ƒç»„ï¼ˆtupleï¼‰ï¼š<br />
åŒ…å«ä¸åŒç±»å‹å˜é‡çš„å¤åˆæ•°æ®ç±»å‹ã€‚å…ƒç»„çš„å­—æ®µæ²¡æœ‰åç§°ï¼Œéœ€è¦é€šè¿‡åºå·è®¿é—®ã€‚</li>
<li>ç±»å‹ï¼ˆtypeï¼‰ï¼š<br />
ä¸€ç§åˆ†ç±»æ–¹å¼ï¼Œç”¨äºæŒ‡å®šå¯ä»¥å¯¹ Rust ä¸­ç‰¹å®šç±»å‹çš„å€¼æ‰§è¡Œå“ªäº›æ“ä½œã€‚</li>
<li>ç±»å‹æ¨å¯¼ï¼ˆtype inferenceï¼‰ï¼š<br />
Rust ç¼–è¯‘å™¨èƒ½å¤Ÿæ¨æ–­å˜é‡æˆ–è¡¨è¾¾å¼çš„ç±»å‹ã€‚</li>
<li>æœªå®šä¹‰è¡Œä¸ºï¼ˆundefined behaviorï¼‰ï¼š<br />
Rust ä¸­æœªæŒ‡å®šç»“æœçš„æ“ä½œæˆ–æ¡ä»¶ï¼Œé€šå¸¸ä¼šå¯¼è‡´ä¸å¯é¢„æµ‹çš„ç¨‹åºè¡Œä¸ºã€‚</li>
<li>è”åˆä½“ï¼ˆunionï¼‰ï¼š<br />
ä¸€ç§æ•°æ®ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ï¼Œä½†ä¸€æ¬¡åªèƒ½ä¿å­˜ä¸€ä¸ªå€¼ã€‚</li>
<li>å•å…ƒæµ‹è¯•ï¼ˆunit testï¼‰ï¼š<br />
Rust å†…ç½®äº†è¿è¡Œå°å‹å•å…ƒæµ‹è¯•å’Œå¤§å‹é›†æˆæµ‹è¯•çš„æ”¯æŒåŠŸèƒ½ã€‚è¯·å‚é˜… <a href="testing/unit-tests.html">å•å…ƒæµ‹è¯•</a>ã€‚</li>
<li>å•å…ƒç±»å‹ï¼ˆunit typeï¼‰:<br />
ä¸ä¿å­˜æ•°æ®çš„ç±»å‹ï¼Œå†™ä¸ºæ²¡æœ‰æˆå‘˜çš„å…ƒç»„ã€‚</li>
<li>unsafe:<br />
The subset of Rust which allows you to trigger <em>undefined behavior</em>. See <a href="unsafe-rust/unsafe.html">Unsafe Rust</a>.</li>
<li>å˜é‡ï¼ˆvariableï¼‰ï¼š<br />
ç”¨äºå­˜å‚¨æ•°æ®çš„å†…å­˜ä½ç½®ã€‚å˜é‡åœ¨ <strong>ä½œç”¨åŸŸ</strong> å†…æœ‰æ•ˆã€‚</li>
</ul>
<h1><a class="header" href="#å…¶ä»–-rust-èµ„æº" id="å…¶ä»–-rust-èµ„æº">å…¶ä»– Rust èµ„æº</a></h1>
<p>Rust ç¤¾åŒºå·²ç»åˆ›é€ äº†ä¸°å¯Œçš„é«˜è´¨é‡å…è´¹èµ„æºåœ¨çº¿æä¾›ã€‚</p>
<h2><a class="header" href="#å®˜æ–¹æ–‡æ¡£" id="å®˜æ–¹æ–‡æ¡£">å®˜æ–¹æ–‡æ¡£</a></h2>
<p>Rust é¡¹ç›®æä¾›äº†è®¸å¤šèµ„æºã€‚è¿™äº›èµ„æºæ¶µç›–äº† Rust çš„ä¸€èˆ¬å†…å®¹ï¼š</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust ç¨‹åºè®¾è®¡è¯­è¨€</a>ï¼šä¸€éƒ¨æœ‰å…³ Rust çš„å…è´¹æƒå¨å›¾ä¹¦ã€‚ä¹¦ä¸­è¯¦ç»†ä»‹ç»äº†è¯¥è¯­è¨€ï¼Œå¹¶åŒ…å«ä¸€äº›å¯ä¾›è¯»è€…æ„å»ºçš„é¡¹ç›®ã€‚</li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">é€šè¿‡ä¾‹å­å­¦ Rust</a>ï¼šé€šè¿‡ä¸€ç³»åˆ—å±•ç¤ºä¸åŒç»“æ„çš„ç¤ºä¾‹ä»‹ç» Rust è¯­æ³•ã€‚æœ‰æ—¶ä¼šåŒ…æ‹¬ä¸€äº›å°ç»ƒä¹ ï¼Œä¼šè¦æ±‚æ‚¨å……åˆ†åœ°é˜è¿°ç¤ºä¾‹ä¸­çš„ä»£ç ã€‚</li>
<li><a href="https://doc.rust-lang.org/std/">Rust æ ‡å‡†åº“</a>ï¼šRust æ ‡å‡†åº“çš„å®Œæ•´æ–‡æ¡£ã€‚</li>
<li><a href="https://doc.rust-lang.org/reference/">Rust å‚è€ƒæ‰‹å†Œ</a>ï¼šä¸€æœ¬æœªå®Œæˆçš„ä¹¦ï¼Œä»‹ç»äº† Rust è¯­æ³•å’Œå†…å­˜æ¨¡å‹ã€‚</li>
</ul>
<p>Rust å®˜æ–¹ç½‘ç«™ä¸Šæœ‰æ›´å¤šä¸“ä¸šæŒ‡å—ï¼š</p>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/">Rust ç§˜å…¸</a>ï¼šä»‹ç»äº†ä¸å®‰å…¨ Rustï¼ŒåŒ…æ‹¬ä½¿ç”¨åŸå§‹æŒ‡é’ˆä»¥åŠä¸å…¶ä»–è¯­è¨€ (FFI) äº¤äº’ã€‚</li>
<li><a href="https://rust-lang.github.io/async-book/">Rust ä¸­çš„å¼‚æ­¥ç¼–ç¨‹</a>ï¼šä»‹ç»äº†åœ¨ã€ŠRust ç¨‹åºè®¾è®¡è¯­è¨€ã€‹æˆä¹¦åå¼•å…¥çš„æ–°å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ã€‚</li>
<li><a href="https://doc.rust-lang.org/stable/embedded-book/">åµŒå…¥å¼ Rust ä¹‹ä¹¦</a>ï¼šä»‹ç»å¦‚ä½•åœ¨æ²¡æœ‰æ“ä½œç³»ç»Ÿçš„åµŒå…¥å¼è®¾å¤‡ä¸Šä½¿ç”¨ Rustã€‚</li>
</ul>
<h2><a class="header" href="#éå®˜æ–¹å­¦ä¹ èµ„æ–™" id="éå®˜æ–¹å­¦ä¹ èµ„æ–™">éå®˜æ–¹å­¦ä¹ èµ„æ–™</a></h2>
<p>å…¶ä»– Rust æŒ‡å—å’Œæ•™ç¨‹çš„å°é€‰é›†ï¼š</p>
<ul>
<li><a href="http://cliffle.com/p/dangerust/">Learn Rust the Dangerous Wayï¼ˆä»¥å±é™©çš„æ–¹å¼å­¦ Rustï¼‰</a>ï¼šä»ä½çº§ C è¯­è¨€ç¨‹åºå‘˜çš„è§’åº¦ä»‹ç» Rustã€‚</li>
<li><a href="https://opentitan.org/book/doc/rust_for_c_devs.html">Rust for Embedded C Programmers</a>: covers Rust from the perspective of developers who write firmware in C.</li>
<li><a href="https://overexact.com/rust-for-professionals/">Rust for professionalsï¼ˆé¢å‘ä¸“ä¸šäººå£«çš„ Rustï¼‰</a>ï¼šé€šè¿‡ä¸å…¶ä»–è¯­è¨€ï¼ˆä¾‹å¦‚ Cã€C++ã€Javaã€JavaScript å’Œ Pythonï¼‰è¿›è¡Œå¹¶æ’æ¯”è¾ƒï¼Œä»‹ç» Rust çš„è¯­æ³•ã€‚</li>
<li><a href="https://exercism.org/tracks/rust">Rust on Exercismï¼ˆåœ¨ Exercism ä¸Šå­¦ Rustï¼‰</a>ï¼š100 å¤šé¡¹ç»ƒä¹ åŠ©æ‚¨å­¦ä¹  Rustã€‚</li>
<li><a href="https://ferrous-systems.github.io/teaching-material/index.html">Ferrous Teaching Material</a>ï¼šä¸€ç³»åˆ—å°æ¼”ç¤ºæ–‡ç¨¿ï¼Œæ¶µç›– Rust è¯­è¨€çš„åŸºç¡€çŸ¥è¯†å’Œé«˜çº§éƒ¨åˆ†ã€‚è¿˜æ¶µç›–äº† WebAssembly å’Œ async/await ç­‰å…¶ä»–ä¸»é¢˜ã€‚</li>
<li><a href="https://rust-exercises.com/advanced-testing/">Advanced testing for Rust applications</a>: a self-paced workshop that goes beyond Rust's built-in testing framework. It covers <code>googletest</code>, snapshot testing, mocking as well as how to write your own custom test harness.</li>
<li><a href="https://docs.microsoft.com/zh-cn/shows/beginners-series-to-rust/">é¢å‘ Rust çš„åˆå­¦è€…ç³»åˆ—</a>å’Œ<a href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">ä½¿ç”¨ Rust è¿ˆå‡ºç¬¬ä¸€æ­¥</a>ï¼šä¸¤ä¸ªé¢å‘æ–°æ‰‹å¼€å‘è€…çš„ Rust æŒ‡å—ã€‚ç¬¬ä¸€ä¸ªæŒ‡å—åŒ…å« 35 ä¸ªè§†é¢‘ï¼Œç¬¬äºŒä¸ªæŒ‡å—åŒ…å« 11 ä¸ªæ¨¡å—ï¼Œå†…å®¹æ¶µç›– Rust è¯­æ³•å’ŒåŸºæœ¬ç»“æ„ã€‚</li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">é€šè¿‡å¤§é‡çš„é“¾è¡¨å­¦ä¹ Rust</a>ï¼šé€šè¿‡å®ç°å‡ ç§ä¸åŒç±»å‹çš„åˆ—è¡¨ç»“æ„ï¼Œæ·±å…¥æ¢ç´¢ Rust çš„å†…å­˜ç®¡ç†è§„åˆ™ã€‚</li>
</ul>
<p>å¦‚éœ€æ›´å¤š Rust å›¾ä¹¦ï¼Œè¯·æŸ¥çœ‹ <a href="https://lborb.github.io/book/">Rust å°å†Œ</a>ã€‚</p>
<h1><a class="header" href="#é¸£è°¢" id="é¸£è°¢">é¸£è°¢</a></h1>
<p>æœ¬è¯¾ä¸­çš„èµ„æ–™ä»¥ä¼—å¤šä¼˜ç§€çš„ Rust æ–‡æ¡£èµ„æºä¸ºåŸºç¡€ã€‚ å¦‚éœ€æŸ¥çœ‹å®ç”¨èµ„æºçš„å®Œæ•´åˆ—è¡¨ï¼Œ è¯·å‚é˜…å…³äº<a href="other-resources.html">å…¶ä»–èµ„æº</a>çš„é¡µé¢ã€‚</p>
<p>The material of Comprehensive Rust is licensed under the terms of the Apache 2.0 license, please see <a href="https://github.com/google/comprehensive-rust/blob/main/LICENSE"><code>LICENSE</code></a> for details.</p>
<h2><a class="header" href="#rust-ç¤ºä¾‹" id="rust-ç¤ºä¾‹">Rust ç¤ºä¾‹</a></h2>
<p>éƒ¨åˆ†ç¤ºä¾‹å’Œç»ƒä¹ å¤åˆ¶å¹¶ æ”¹ç¼–è‡ª<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯ æ¡æ¬¾ï¼‰ï¼Œè¯·å‚é˜… <code>third_party/rust-by-example/</code> ç›®å½•ã€‚</p>
<h2><a class="header" href="#rust-on-exercism" id="rust-on-exercism">Rust on Exercism</a></h2>
<p>éƒ¨åˆ†ç»ƒä¹ å¤åˆ¶å¹¶ æ”¹ç¼–è‡ª <a href="https://exercism.org/tracks/rust">Rust on Exercism</a>ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯ æ¡æ¬¾ï¼‰ï¼Œè¯·å‚é˜… <code>third_party/rust-on-exercism/</code> ç›®å½•ã€‚</p>
<h2><a class="header" href="#cxx" id="cxx">CXX</a></h2>
<p>â€œ<a href="android/interoperability/cpp.html">ä¸ C++ çš„äº’æ“ä½œæ€§</a>â€éƒ¨åˆ†å¼•ç”¨äº†ä¸€å¼  æ¥è‡ª <a href="https://cxx.rs/">CXX</a> çš„å›¾ç‰‡ã€‚å¦‚éœ€äº†è§£è¯¦æƒ…ï¼ˆåŒ…æ‹¬è®¸å¯æ¡æ¬¾ï¼‰ï¼Œ è¯·å‚é˜… <code>third_party/cxx/</code> ç›®å½•ã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script>
            window.playground_line_numbers = true;
        </script>
        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>
        

        
        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        
        <script src="theme/speaker-notes.js"></script>
        

        
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </div>
    </body>
</html>
