<!DOCTYPE HTML>
<html lang="zh-Hans" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 秘典（死灵书）</title>
        
        <meta name="robots" content="noindex">
        
        


        <!-- Custom HTML head -->
        <meta name="keywords" content="Rust, 秘典, nomicon, 死灵书, 中文, 翻译, Rustonomicon, unsafe">
<meta name="author" content="Pure White">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FFJKFQ4JX4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FFJKFQ4JX4');
</script>
<!-- 百度统计 -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6342f4a7e260f8ada187c3b7bf87e56f";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- Clarity tracking code for https://nomicon.purewhite.io/ -->
<script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i+"?ref=bwt";
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "8mgxa5h4sc");
</script>
<!-- 头条搜索 -->
<script>
(function(){
var el = document.createElement("script");
el.src = "https://lf1-cdn-tos.bytegoofy.com/goofy/ttzz/push.js?89c3e1b9546c0b1fe304a3bd37debc6720dd0166be5ad303fb3f12e317cfad8b45f9b46c8c41e6235de98982cdddb9785e566c8c06b0b36aec55fccc04fff972a6c09517809143b97aad1198018b8352";
el.id = "ttzz";
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(el, s);
})(window)
</script>


        <meta name="description" content="高级 Unsafe Rust 编程的黑科技指南">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/nomicon.css">
        
        <link rel="stylesheet" href="theme/language-picker.css">
        

        
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">介绍</a></li><li class="chapter-item expanded "><a href="meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> 认识安全和不安全</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> 安全和不安全如何交互</a></li><li class="chapter-item expanded "><a href="what-unsafe-does.html"><strong aria-hidden="true">1.2.</strong> Unsafe Rust 能做什么</a></li><li class="chapter-item expanded "><a href="working-with-unsafe.html"><strong aria-hidden="true">1.3.</strong> 使用 Unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="data.html"><strong aria-hidden="true">2.</strong> Rust 中的数据布局</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li class="chapter-item expanded "><a href="exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> 非正常大小的类型</a></li><li class="chapter-item expanded "><a href="other-reprs.html"><strong aria-hidden="true">2.3.</strong> 可选的数据布局</a></li></ol></li><li class="chapter-item expanded "><a href="ownership.html"><strong aria-hidden="true">3.</strong> 所有权</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">3.1.</strong> 引用</a></li><li class="chapter-item expanded "><a href="aliasing.html"><strong aria-hidden="true">3.2.</strong> 别名</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">3.3.</strong> 生命周期</a></li><li class="chapter-item expanded "><a href="lifetime-mismatch.html"><strong aria-hidden="true">3.4.</strong> 生命周期的局限</a></li><li class="chapter-item expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">3.5.</strong> 生命周期推导</a></li><li class="chapter-item expanded "><a href="unbounded-lifetimes.html"><strong aria-hidden="true">3.6.</strong> 不受约束的生命周期</a></li><li class="chapter-item expanded "><a href="hrtb.html"><strong aria-hidden="true">3.7.</strong> Higher-Rank Trait Bounds</a></li><li class="chapter-item expanded "><a href="subtyping.html"><strong aria-hidden="true">3.8.</strong> 子类型化和变异性</a></li><li class="chapter-item expanded "><a href="dropck.html"><strong aria-hidden="true">3.9.</strong> 丢弃检查</a></li><li class="chapter-item expanded "><a href="phantom-data.html"><strong aria-hidden="true">3.10.</strong> 幽灵数据</a></li><li class="chapter-item expanded "><a href="borrow-splitting.html"><strong aria-hidden="true">3.11.</strong> 拆分 Borrows</a></li></ol></li><li class="chapter-item expanded "><a href="conversions.html"><strong aria-hidden="true">4.</strong> 类型转换</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="coercions.html"><strong aria-hidden="true">4.1.</strong> 强转</a></li><li class="chapter-item expanded "><a href="dot-operator.html"><strong aria-hidden="true">4.2.</strong> 点运算符</a></li><li class="chapter-item expanded "><a href="casts.html"><strong aria-hidden="true">4.3.</strong> Casts</a></li><li class="chapter-item expanded "><a href="transmutes.html"><strong aria-hidden="true">4.4.</strong> Transmutes</a></li></ol></li><li class="chapter-item expanded "><a href="uninitialized.html"><strong aria-hidden="true">5.</strong> 未初始化内存</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="checked-uninit.html"><strong aria-hidden="true">5.1.</strong> Checked</a></li><li class="chapter-item expanded "><a href="drop-flags.html"><strong aria-hidden="true">5.2.</strong> 丢弃标志</a></li><li class="chapter-item expanded "><a href="unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> Unchecked</a></li></ol></li><li class="chapter-item expanded "><a href="obrm.html"><strong aria-hidden="true">6.</strong> 基于所有权的资源管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="constructors.html"><strong aria-hidden="true">6.1.</strong> 构造</a></li><li class="chapter-item expanded "><a href="destructors.html"><strong aria-hidden="true">6.2.</strong> 析构</a></li><li class="chapter-item expanded "><a href="leaking.html"><strong aria-hidden="true">6.3.</strong> 泄漏</a></li></ol></li><li class="chapter-item expanded "><a href="unwinding.html"><strong aria-hidden="true">7.</strong> Unwinding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exception-safety.html"><strong aria-hidden="true">7.1.</strong> 异常安全</a></li><li class="chapter-item expanded "><a href="poisoning.html"><strong aria-hidden="true">7.2.</strong> Poisoning</a></li></ol></li><li class="chapter-item expanded "><a href="concurrency.html"><strong aria-hidden="true">8.</strong> 并发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="races.html"><strong aria-hidden="true">8.1.</strong> 数据竞争</a></li><li class="chapter-item expanded "><a href="send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send 和 Sync</a></li><li class="chapter-item expanded "><a href="atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li></ol></li><li class="chapter-item expanded "><a href="vec/vec.html"><strong aria-hidden="true">9.</strong> 实现 Vec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vec/vec-layout.html"><strong aria-hidden="true">9.1.</strong> 布局</a></li><li class="chapter-item expanded "><a href="vec/vec-alloc.html"><strong aria-hidden="true">9.2.</strong> 分配内存</a></li><li class="chapter-item expanded "><a href="vec/vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push 和 Pop</a></li><li class="chapter-item expanded "><a href="vec/vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> 释放内存</a></li><li class="chapter-item expanded "><a href="vec/vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li class="chapter-item expanded "><a href="vec/vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> 插入和删除</a></li><li class="chapter-item expanded "><a href="vec/vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="vec/vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li class="chapter-item expanded "><a href="vec/vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li class="chapter-item expanded "><a href="vec/vec-zsts.html"><strong aria-hidden="true">9.10.</strong> 处理零大小的类型</a></li><li class="chapter-item expanded "><a href="vec/vec-final.html"><strong aria-hidden="true">9.11.</strong> 最终代码</a></li></ol></li><li class="chapter-item expanded "><a href="arc-mutex/arc-and-mutex.html"><strong aria-hidden="true">10.</strong> 实现 Arc 和 Mutex</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arc-mutex/arc.html"><strong aria-hidden="true">10.1.</strong> 实现 Arc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="arc-mutex/arc-layout.html"><strong aria-hidden="true">10.1.1.</strong> 布局</a></li><li class="chapter-item expanded "><a href="arc-mutex/arc-base.html"><strong aria-hidden="true">10.1.2.</strong> 基本代码</a></li><li class="chapter-item expanded "><a href="arc-mutex/arc-clone.html"><strong aria-hidden="true">10.1.3.</strong> 克隆</a></li><li class="chapter-item expanded "><a href="arc-mutex/arc-drop.html"><strong aria-hidden="true">10.1.4.</strong> 丢弃</a></li><li class="chapter-item expanded "><a href="arc-mutex/arc-final.html"><strong aria-hidden="true">10.1.5.</strong> 最终代码</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ffi.html"><strong aria-hidden="true">11.</strong> 外部函数接口（FFI）</a></li><li class="chapter-item expanded "><a href="beneath-std.html"><strong aria-hidden="true">12.</strong> 标准库之下</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="panic-handler.html"><strong aria-hidden="true">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="展开/收起目录" aria-label="展开/收起目录" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="更换主题" aria-label="更换主题" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="全书搜索 (快捷键: s)" aria-label="显示/隐藏搜索框" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 秘典（死灵书）</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button icon-button-wrapper" type="button"
                                title="切换语言 / Change language" aria-label="切换语言 / Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="语言 / Languages" role="menu">
                            <li role="none"><a role="menuitem" class="theme theme-link" id="en">英文原版 (English)</a></li>
                            <li role="none"><a role="menuitem" class="theme theme-link" id="zh-Hans">中文译本</a></li>
                        </ul>
                        <script>
                            let langToggle = document.getElementById("language-toggle");
                            let langList = document.getElementById("language-list");

                            const langId = "zh-Hans";
                            let selectedLang = document.getElementById(langId);
                            if (selectedLang) {
                                selectedLang.classList.add("theme-selected");
                            }

                            function hideLangList() {
                                langList.style.display = "none";
                                langToggle.setAttribute('aria-expanded', false);
                                langToggle.focus();
                            }

                            langToggle.addEventListener("click", (event) => {
                                if (langList.style.display === "block") {
                                    hideLangList();
                                } else {
                                    langList.style.display = "block";
                                    langToggle.setAttribute('aria-expanded', true);
                                    langList.querySelector("a#" + langId).focus();
                                }
                            });

                            langList.addEventListener('focusout', function(e) {
                                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                                if (!!e.relatedTarget && !langToggle.contains(e.relatedTarget) && !langList.contains(e.relatedTarget)) {
                                    hideLangList();
                                }
                            });

                            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang/mdBook/issues/628
                            document.addEventListener('click', function(e) {
                                if (langList.style.display === 'block' && !langToggle.contains(e.target) && !langList.contains(e.target)) {
                                    hideLangList();
                                }
                            });

                            document.addEventListener('keydown', function (e) {
                                if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) { return; }
                                if (!langList.contains(e.target)) { return; }

                                switch (e.key) {
                                    case 'Escape':
                                        e.preventDefault();
                                        hideLangList();
                                        break;
                                    case 'ArrowUp':
                                        e.preventDefault();
                                        var li = document.activeElement.parentElement;
                                        if (li && li.previousElementSibling) {
                                            li.previousElementSibling.querySelector('a').focus();
                                        }
                                        break;
                                    case 'ArrowDown':
                                        e.preventDefault();
                                        var li = document.activeElement.parentElement;
                                        if (li && li.nextElementSibling) {
                                            li.nextElementSibling.querySelector('a').focus();
                                        }
                                        break;
                                    case 'Home':
                                        e.preventDefault();
                                        langList.querySelector('li:first-child a').focus();
                                        break;
                                    case 'End':
                                        e.preventDefault();
                                        langList.querySelector('li:last-child a').focus();
                                        break;
                                }
                            });

                            // The path to the root, taking the current
                            // language into account.
                                
                                let full_path_to_root = "";
                                
                            // The page path (mdbook only gives us
                            // access to the path to the Markdown file).
                            let path = "print.md".replace(/\.md$/, ".html");
                            for (let lang of langList.querySelectorAll("a")) {
                                if (lang.id == "zh-Hans") {
                                    lang.href = `${full_path_to_root}${path}`;
                                } else {
                                    lang.href = `${full_path_to_root}${lang.id}/${path}`;
                                }
                            }
                        </script>
                        
                        <a href="print.html" title="打印本书" aria-label="打印本书">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-cn/nomicon-zh-Hans" title="Git repo" aria-label="Git repo">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-秘典" id="rust-秘典">Rust 秘典</a></h1>
<div class="warning">
<p>警告。
这本书是不完整的。
记录所有内容和重写过时的部分需要一段时间。
请参见<a href="https://github.com/rust-lang/nomicon/issues">issue tracker</a>以检查哪些内容缺失/过时，如果有任何错误或想法仍未被报告，欢迎随时提一个新 Issue。</p>
</div>
<blockquote>
<p>译者的话：首先，限于译者自身姿势水平，翻译有可能无法做到完全信达雅，并且有一些专业术语不知道如何翻译到中文，在这里先向大家道歉，请多包涵。</p>
<p>不过，译者保证所有翻译的内容都是译者阅读并调整过多次的，并且译者会努力将内容调整到满足<strong>能看懂</strong>的要求，并且做到不遗漏原文内容。</p>
<p>如果大家对于翻译有更好的建议或者想法，欢迎直接 PR~</p>
<p>目前翻译基于 commit：6ecf95c5f2bfa0e6314dfe282bf775fd1405f7e9，基于时间：2024/8/12</p>
<p>Q：为什么不基于之前已有的中文版进行改进？</p>
<p>A：因为翻译成中文版后，很难再回过头去看和现在的英文版原文到底差了啥，所以还不如完全重新翻译一遍。</p>
<p>Q：那会不会有一天你的这个版本也过期了？</p>
<p>A：希望没有那一天。我 watch 了英文原版的所有 pr，如果有变更（希望）能及时更新。当然，也欢迎大家一起贡献 PR。</p>
</blockquote>
<h2><a class="header" href="#不安全-rust-的黑魔法" id="不安全-rust-的黑魔法">不安全 Rust 的黑魔法</a></h2>
<blockquote>
<p>这些知识是“按原样”提供的，没有任何形式的明示或暗示的保证，包括但不限于释放难以描述的恐怖，粉碎你的心灵，让你的思想漂流在不可知的无限宇宙中。</p>
</blockquote>
<p>Rust 秘典挖掘了你在编写不安全 Rust 程序时需要了解的所有可怕的细节。</p>
<p>如果你希望在编写 Rust 程序的过程中获得长久而快乐的职业生涯，你应该现在回头，忘记你曾经看过这本书。
它没有必要。
然而，如果你打算编写不安全代码——或者只是想深入了解语言的内涵——这本书包含了很多有用的信息。</p>
<p>与 <em><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></em> 不同的是，我们将假设你有相当多的前期知识。
特别是，你应该对基本的系统编程和 Rust 非常熟悉。
如果你对这些主题感到困惑，你应该考虑先阅读<a href="https://doc.rust-lang.org/book/">The Book</a>。
也就是说，我们不会假定你已经读过了，而且我们会注意偶尔在适当的时候对基础知识进行复习。
如果你想的话，你可以直接跳过<a href="https://doc.rust-lang.org/book/">The Book</a>来看这本书：但你需要知道我们不会从头到尾地详细解释一切。</p>
<p>本书主要是作为<a href="https://doc.rust-lang.org/reference/index.html">The Reference</a>的高级配套读物而存在。
《The Reference》的存在是为了详细说明语言的每一部分的语法和语义，而《Rust 秘典》的存在是为了描述如何将这些部分结合起来使用，以及你在这样做时将会遇到的问题。</p>
<p>《The Reference》会告诉你引用、析构器和 unwind 的语法和语义，但它不会告诉你如何将它们结合起来导致异常安全问题，或如何处理这些问题。</p>
<p>需要注意的是，我们没有很好地同步 The Rustnomicon 和 The Reference，所以它们可能有重复的内容。
一般来说，如果这两个文档有分歧，应该认为《The Reference》是正确的（它还没有被认为是规范性的，只是维护得更好）。</p>
<p>本书范围内的主题包括：（不）安全的含义、语言和标准库提供的不安全基础、用这些不安全基础创建安全抽象的技术、子类型和可变性（variance）、异常安全（恐慌/unwind 安全性）、与未初始化的内存相关的工作、类型转换、并发、与其他语言的互操作（FFI）、优化技巧、如何构建低级到编译器/操作系统/硬件的基元（primitives）、如何<strong>不使</strong>内存模型程序员生气、如何<strong>使</strong>内存模型程序员生气、以及更多。</p>
<p>Rust 秘典不是一个详尽描述标准库中每一个 API 的语义和保证的地方，也不是一个详尽描述 Rust 的每一个特性的地方。</p>
<p>除非另有说明，本书中的 Rust 代码使用 Rust 2021 版。</p>
<h1><a class="header" href="#认识-safe-与-unsafe" id="认识-safe-与-unsafe">认识 Safe 与 Unsafe</a></h1>
<p><img src="img/safeandunsafe.svg" alt="safe and unsafe" /></p>
<p>我们都不想关心底层的实现细节。谁会关心空元组占用了多少空间呢？可悲的是，它有时很重要，我们需要担心这个问题。开发人员开始关心实现细节的最常见的原因是性能，但更重要的是，当与硬件、操作系统或其他语言直接交互时，这些细节就是关乎对错的问题。</p>
<p>当实现细节在安全的编程语言中开始变得重要时，程序员通常有三种选择。</p>
<ul>
<li>调整代码以鼓励编译器/运行时进行优化</li>
<li>采用一种更不规范或更繁琐的设计来获得所需的实现</li>
<li>用一种能让你处理这些细节的语言重写实现</li>
</ul>
<p>对于最后一种选择，程序员往往使用的语言是<em>C</em>。这对于对接那些只声明 C 语言接口的系统来说往往是必要的。</p>
<p>不幸的是，C 语言使用起来非常不安全（尽管有时有很好的理由），当试图与另一种语言交互时，这种危险会被放大。我们必须小心翼翼地确保 C 语言和其他语言的一致性，以使它们不会越俎代庖。</p>
<p>那么，这与 Rust 有什么关系呢？</p>
<p>嗯，与 C 不同，Rust 是一种安全的编程语言。</p>
<p>但是，和 C 语言一样，Rust 也是一种不安全的编程语言。</p>
<p>更准确地说，Rust 同时<em>包含</em>了一种安全和一种不安全的编程语言。</p>
<p>Rust 可以被认为是两种编程语言的结合。<em>Safe Rust</em> 和<em>Unsafe Rust</em>。顾名思义，Safe Rust 是安全的。Unsafe Rust 是，嗯，不安全的。事实上，Unsafe Rust 让我们做一些<em>真正</em>不安全的事情。Rust 的作者会恳求你不要做这些事情，但我们还是要做。</p>
<p>Safe Rust 是<em>真正</em>的 Rust 编程语言。如果你只写 Safe Rust，你将永远不必担心类型安全或内存安全的问题。你永远不会遇见悬空的指针，释放后使用（use-after-free），或任何其他类型的未定义行为。</p>
<p>标准库也为你提供了足够多的开箱即用的工具，你将能够用纯粹的Safe Rust 编写高性能的应用程序和库。</p>
<p>但是，也许你想调用另一种语言，也许你正在写一个标准库没有暴露的低级抽象，也许你正在<em>写</em>标准库（它完全是用 Rust 写的），也许你需要做点类型系统看不懂的<em>底层数据操作</em>。也许你需要Unsafe Rust。</p>
<p>Unsafe Rust 与Safe Rust 完全一样，具有所有相同的规则和语义。它只是允许你做一些<em>额外的</em>、绝对不安全的事情（我们将在下一节中定义）。</p>
<p>这种分离的价值在于，我们获得了使用像 C 这样的不安全语言的好处——获得对底层实现细节的控制——而与其他安全语言交互时却没有那么多问题了。</p>
<p>仍然有一些问题——最明显的是，我们必须意识到类型系统有一些程序必须遵守的假设的规则，且认真审核任何与 Unsafe Rust 交互的代码以遵守规则。这就是本书的目的：教你了解这些规则以及如何遵守它们。</p>
<h1><a class="header" href="#safe-和-unsafe-如何交互" id="safe-和-unsafe-如何交互">Safe 和 Unsafe 如何交互</a></h1>
<p>Safe Rust 和 Unsafe Rust 之间有什么关系？它们又是如何交互的？</p>
<p>Safe Rust 和 Unsafe Rust 之间的边界由<code>unsafe</code>关键字控制，<code>unsafe</code>是承接了它们之间交互的桥梁。这就是为什么我们可以说 Safe Rust 是一种安全的语言：所有不安全的部分都被限制在“unsafe”边界之内。如果你愿意，你甚至可以把<code>#![forbid(unsafe_code)]</code>扔进你的代码库，以静态地保证你只写 Safe Rust。</p>
<p><code>unsafe</code>关键字有两个用途：声明编译器不会保证这些代码的安全性，以及声明程序员已经确保这些代码是安全的。</p>
<p>在 <em>函数</em> 和 <em>trait 声明</em> 上添加<code>unsafe</code>前缀表示其中存在未经检查的约束。对于函数，<code>unsafe</code>意味着函数的用户必须仔细阅读该函数的文档，以确保他们的使用方式遵循了该函数规定的约束。对于 trait 声明，<code>unsafe</code>意味着 trait 的实现者必须仔细阅读 trait 文档，以确保他们的实现遵循了该 trait 规定的约束。</p>
<p>在代码块上添加<code>unsafe</code>前缀可以声明在其中执行的所有不安全操作都经过了验证（遵循了内部不安全操作所规定的约束）。传递给<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a>的索引在边界内时，就是一个可以这样添加<code>unsafe</code>前缀的例子。</p>
<p>在 trait 实现上添加<code>unsafe</code>前缀可以声明该实现满足了 trait 所规定的约束。例如，当一个类型的值移动到另一个线程是真正安全的时，便可在<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>的实现前添加<code>unsafe</code>前缀。</p>
<p>标准库中有许多 unsafe 的函数，包括：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a>，它不会检查传入索引的有效性，允许违反内存安全的规则。</li>
<li><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute</code></a>将一些数据重新解释为给定的类型，绕过类型安全的规则（详见<a href="conversions.html">conversions</a>）。</li>
<li>每一个指向一个 Sized 类型的原始指针都有一个<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset"><code>offset</code></a>方法，如果传递的偏移量不在<a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset">“界内”</a>，则该调用是未定义行为。</li>
<li>所有 FFI（外部函数接口 Foreign Function Interface）函数的调用都是<code>unsafe</code>的，因为 Rust 编译器无法检查其他语言的操作。</li>
</ul>
<p>从 Rust 1.29.2 开始，标准库定义了以下 unsafe trait（还有其他 trait，但还没有稳定下来，有些可能永远不会稳定下来）：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> 是一个标记 trait（一个没有 API 的 trait），用于保证实现了<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>的类型可以安全地发送（移动）到另一个线程。</li>
<li><a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a> 是一个标记 trait，用于保证线程间可以通过共享引用安全地共享实现了<a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>的类型。</li>
<li><a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>允许自定义整个程序的内存分配器。</li>
</ul>
<p>Rust 标准库也有很多地方在内部使用了 Unsafe Rust。这些实现一般都经过严格的人工检查，所以建立在这些实现之上的 Safe Rust 接口可以被认为是安全的。</p>
<p>之所以要像这样分离 Safe 和 Unsafe，归根到底在于 Safe Rust 的一个根本属性，即<em>可靠性</em>。</p>
<p><strong>无论怎样，Safe Rust 都不能导致未定义行为。</strong></p>
<p>Safe 与 Unsafe 分离的设计意味着 Safe Rust 和 Unsafe Rust 之间存在着不对等的信任关系。一方面， Safe Rust 本质上必须相信它所接触的任何 Unsafe Rust 都是正确编写的。另一方面，Unsafe Rust 在信任 Safe Rust 时必须非常小心。</p>
<p>例如，Rust 有<a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>和<a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a> trait 来区分“偏序”比较的类型和“全序”比较的类型（前者仅能进行比较而未必得出大小关系，而后者意味着每一个比较都有合理的结果）。</p>
<p><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>以没有定义全序关系的类型作为 key 是没有意义的，因此它要求其 key 实现<code>Ord</code>。然而，<code>BTreeMap</code>的实现中包含了 Unsafe 的代码。由于（用 Safe 代码就能写出的）不靠谱的<code>Ord</code>实现导致未定义行为是不可接受的，因此，BTreeMap 中的 Unsafe 代码必须健壮到这个地步：对于实际上并非全序关系的<code>Ord</code>实现也不会导致未定义行为——尽管我们指定<code>Ord</code>约束就是为了得到全序关系。</p>
<p>Unsafe Rust 代码不能信任 Safe Rust 代码逻辑无误。话虽如此，如果你输入的值，其类型并没有全序关系，<code>BTreeMap</code>仍然会变得乱七八糟。上一段只是说明它不会导致未定义行为。</p>
<p>有人可能会问，如果<code>BTreeMap</code>不能基于“它是 Safe 代码编写的”这一理由而信任<code>Ord</code>，那还有<em>什么</em> Safe 代码是能信任的呢？例如，<code>BTreeMap</code>依赖于整数和切片的正确实现。这些也是 Safe Rust 编写的，不是么？</p>
<p>区别在于范围的不同。当<code>BTreeMap</code>依赖于整数和切片时，它依赖于一个完全特定的实现。这里的风险经过评估可以与收益相权衡。在这个特定场景下，风险基本为零；如果整数和切片出了问题，<em>什么东西</em>都会出问题，因此不可能被忽视。而且，它们和<code>BTreeMap</code>是由同一批人维护的，所以很容易对它们进行监控。</p>
<p>另一方面，<code>BTreeMap</code>的 key 类型是泛型的。信任它的<code>Ord</code>实现意味着信任过去、现在和未来的每一个<code>Ord</code>实现。这里的风险很高：总有人会犯错误，把<code>Ord</code>实现坏，甚至直接谎称提供了一个全序关系，因为“这个实现看上去够用”。对于这种情况，<code>BTreeMap</code>需要有备无患。</p>
<p>同样的逻辑也适用于信任一个传递给你的闭包的行为是正确的。</p>
<p>问题是能否无限信任泛型类型参数？<code>unsafe</code> trait 应运而生。理论上，<code>BTreeMap</code>类型可以要求 key 实现一个新的 trait，称为<code>UnsafeOrd</code>，而不是<code>Ord</code>，它可能看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;

unsafe trait UnsafeOrd {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering;
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，为一个类型实现<code>UnsafeOrd</code>就要带上<code>unsafe</code>前缀，表明开发者已经确保他们的实现遵循了该 trait 所预期的任何约束。在这种情况下，<code>BTreeMap</code>内部的 Unsafe Rust 有理由相信 key 类型的<code>UnsafeOrd</code>实现是正确的。否则错就在 unsafe trait 的实现，这与 Rust 的安全保证是一致的。</p>
<p>是否将 trait 标记为<code>unsafe</code>是 API 设计取舍的问题。Safe trait 实现起来更轻松，但任何依赖它的 Unsafe 代码面临不正确的实现也不能引发未定义行为。将 trait 标记为<code>unsafe</code>会将这个责任转移到实现者身上。按照 Rust 传统，往往避免将 trait 标记为<code>unsafe</code>，否则 Unsafe Rust 会无处不在，我们并不想看到这个结果。</p>
<p><code>Send</code>和<code>Sync</code>被标记为 unsafe，是因为线程安全是一个<em>根本的属性</em>，要像应对一个有缺陷的<code>Ord</code>实现一样应对线程安全问题，对 unsafe 代码来说是不可能的。同理，<code>GlobalAlloc</code>被用于管理程序中所有的内存分配，诸如<code>Box</code>或<code>Vec</code>都建立在它的基础上。如果<code>GlobalAlloc</code>不正常了（例如把一块还被占用着的内存返回给了另一个请求），是绝无可能靠检测来补救的。</p>
<p>是否将你自己的 trait 标记为<code>unsafe</code>，也要基于类似的考虑做出决定。如果<code>unsafe</code>代码无法有效应对 trait 的错误实现，那么将 trait 标记为<code>unsafe</code>合情合理。</p>
<p>顺便一提，虽然<code>Send</code>和<code>Sync</code>是<code>unsafe</code> trait，但是当类型系统可以证明派生<code>Send</code>/<code>Sync</code>安全时，它们<em>也会</em>被自动实现。每个字段类型都满足<code>Send</code>的类型会自动派生<code>Send</code>。每个字段类型都满足<code>Sync</code>的类型会自动派生<code>Sync</code>。通过这种方式，这两个 trait 扩散<code>unsafe</code>的影响被控制到最小。而对于内存分配器，没多少人会去<em>实现</em>它们（说起来，直接使用内存分配器的人都很少）。</p>
<p>上文展示了 Safe Rust 和 Unsafe Rust 之间的平衡。将两者分离的设计，目的是让使用 Safe Rust 尽可能符合工效，反过来在编写 Unsafe Rust 时则需要额外的努力和细心。本书的其余部分主要是讨论需要什么形式的细心，以及Unsafe Rust 必须遵循什么约束。</p>
<h1><a class="header" href="#unsafe-rust-能做什么" id="unsafe-rust-能做什么">Unsafe Rust 能做什么</a></h1>
<p>在 Unsafe Rust 中唯一不同的是，你可以：</p>
<ul>
<li>对原始指针进行解引用</li>
<li>调用 “Unsafe” 的函数（包括 C 函数、编译器的内建指令和原始分配器。</li>
<li>实现 “Unsafe” trait</li>
<li>访问或者修改可变的静态变量</li>
<li>访问 “union” 的字段</li>
</ul>
<p>这就是全部了。这些操作被归入 unsafe 的原因是，误用其中的任何一项都会引起可怕的未定义行为。调用“未定义行为”使编译器有充分的权利对你的程序做任何坏事。你绝对_不能_调用“未定义行为”。</p>
<p>与 C 语言不同，Rust 中的“未定义行为”的范围相当有限。核心语言中，你只需要关心防止以下事情：</p>
<ul>
<li>解除引用（使用<code>*</code>运算符）悬空或不对齐的指针（见下文）</li>
<li>破坏<a href="references.html">指针别名规则</a></li>
<li>调用一个 ABI 错误的函数，或者从一个 unwind ABI 错误的函数中 unwinding</li>
<li>引起<a href="races.html">数据竞争</a></li>
<li>执行用当前执行线程不支持的<a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-target_feature-attribute">目标特性</a>编译的代码</li>
<li>产生无效的值（无论是单独的还是作为一个复合类型的字段，如<code>enum</code>/<code>struct</code>/<code>array</code>/<code>tuple</code>）
<ul>
<li>一个不是 0 或 1 的<code>bool</code></li>
<li>一个具有无效判别符的<code>enum</code></li>
<li>一个空的<code>fn</code>指针</li>
<li>一个超出[0x0, 0xD7FF]和[0xE000, 0x10FFFF]范围的<code>char</code></li>
<li>一个<code>!</code>（所有的值对这个类型都是无效的）</li>
<li>一个从<a href="uninitialized.html">未初始化的内存</a>读出的整数(<code>i*</code>/<code>u*</code>)、浮点值(<code>f*</code>)或原始指针，或<code>str</code>中的未初始化的内存</li>
<li>一个悬空的、不对齐的、或指向无效值的引用/<code>Box</code></li>
<li>一个胖指针、<code>Box</code>或原始指针，具有无效的元数据：
<ul>
<li>如果一个<code>dyn Trait</code>指针 / 引用指向的 vtable 和对应 Trait 的 vtable 不匹配，那么<code>dyn Trait</code>的元数据是无效的</li>
<li>如果 Slice 的长度不是有效的 usize（比如，从未初始化的内存中读取的 usize），那么 Slice 的元数据是无效的</li>
</ul>
</li>
<li>一个由类型自定义的无效值，比如在标准库中的<a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code>NonNull</code></a>和<code>NonZero*</code>(自定义无效值是一个不稳定的特性，但一些稳定的 libstd 类型，如<code>NonNull</code>使用了这个特性)。</li>
</ul>
</li>
</ul>
<p>如果你想要了解更多关于“未定义行为”的信息，可以参考 <a href="https://www.rustwiki.org.cn/zh-CN/reference/behavior-considered-undefined.html">Rust 参考手册</a>。</p>
<p>赋值、传递给一个函数/原始操作、从一个函数/原始操作返回的时候，都会“产生”一个值。</p>
<p>如果一个引用/指针是空的，或者它所指向的地址并非都是合法的地址（合法地址都应该是已分配内存的），那么它就是<code>悬垂</code>的。它所指向的范围是由指针值和被指向类型的大小决定的（使用<code>size_of_val</code>）。因此，如果指向的范围是空的，<code>悬垂</code>与<code>空</code>是一样的。要注意，切片和字符串指向它们的整个范围，所以它们元数据中的长度不能太大。内存分配的长度、切片和字符串的长度不能大于<code>isize::MAX</code>字节。如果因为某些原因，这太麻烦了，可以考虑使用原始指针。</p>
<p>这就是所有 Rust 中可能会导致未定义行为的原因。当然，unsafe 的函数和 trait 可以自由地声明任意的其他约束，程序必须保持这些约束以避免未定义行为。例如，分配器 API 声明，释放未分配的内存是未定义行为。</p>
<p>然而，对这些约束的违反通常只会导致上述问题中的一个，一些额外的约束也可能来自于编译器，编译器为优化代码做出了特殊的假设。例如，Vec 和 Box 使用了内建指令，要求他们的指针在任何时候都是非空的。</p>
<p>Rust 在其他方面对其他可疑的操作是相当宽容的。Rust 认为以下情况是“安全的”：</p>
<ul>
<li>死锁</li>
<li>有一个<a href="races.html">数据竞争</a></li>
<li>内存泄漏</li>
<li>整数溢出（使用内置的运算符，比如“+”）</li>
<li>中止程序</li>
<li>删除生产数据库</li>
</ul>
<p>如果你想了解更多信息，可以参考 <a href="https://www.rustwiki.org.cn/zh-CN/reference/behavior-not-considered-unsafe.html">Rust 参考手册</a>。</p>
<p>然而任何真正可能做这种事情的程序都是<em>可能</em>不正确的，Rust 提供了很多工具来尽可能检查出这些问题，但要这些问题完全被预防是不现实的。</p>
<h1><a class="header" href="#使用-unsafe" id="使用-unsafe">使用 Unsafe</a></h1>
<p>Rust 通常让我们以作用域的方式来限制 unsafe 代码块。不幸的是，现实要比这复杂得多。例如，考虑下面这个玩具函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt; arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个函数是安全和正确的。我们先检查索引是否在界内，如果是，就以不检查的方式索引到数组中。我们说，这样一个正确实现的 unsafe 函数是<em>健全</em>的，这意味着安全代码不能通过它引起未定义行为（记住，这是安全 Rust 的唯一基本属性）。</p>
<p>但即使在这样一个微不足道的函数中，不安全的代码块也是值得怀疑的，比如将<code>&lt;</code>改为<code>&lt;=</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn index(idx: usize, arr: &amp;[u8]) -&gt; Option&lt;u8&gt; {
    if idx &lt;= arr.len() {
        unsafe {
            Some(*arr.get_unchecked(idx))
        }
    } else {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个程序现在是<em>不健全</em>的，Safe Rust 会导致未定义行为，尽管<em>我们只修改了安全代码</em>。这就是安全的基本问题：它是并非只是局部的问题。我们的 unsafe 操作的健壮性必然取决于由其他 “safe” 操作建立的状态。</p>
<p>Safe 是模块化的，你不需要考虑任何其它的 Unsafe 块带来的潜在问题。例如，对一个切片使用一个未经检查的索引并不意味着你突然需要担心这个分片是空的或者包含未初始化的内存。没有任何根本性的变化。然而，Safe 又<em>不是</em>模块化的，因为程序本身是有状态的，你的 unsafe 操作可能依赖于任意状态。</p>
<p>当我们加入实际的持久化状态时，这种非局部性会变得更糟糕。例如，让我们看一下<code>Vec</code>的一个简单实现：</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr;

// 注意：这个定义十分简单。参考实现 Vec 的章节
pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

// 注意：这个实现未考虑大小为 `0` 的类型。参考实现 Vec 的章节
impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap {
            // 这里并不重要
            self.reallocate();
        }
        unsafe {
            ptr::write(self.ptr.add(self.len), elem);
            self.len += 1;
        }
    }
<span class="boring">    fn reallocate(&amp;mut self) { }
</span>}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>这段代码很简单，可以很简单地确认和验证，但是现在我们添加以下方法：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn make_room(&amp;mut self) {
    // 增加容量
    self.cap += 1;
}
</code></pre>
<p>这段代码是 100% 安全的 Rust，但它也是完全不健全的。改变容量违反了 Vec 的不变性（即<code>cap</code>反映了 Vec 中分配的空间）。这不是 Vec 的其他部分所能防范的。它<em>不得不</em>相信容量字段，因为没有办法验证它。</p>
<p>因为它依赖于一个结构字段的不变性，这段 “unsafe” 的代码不仅仅污染了整个函数：它污染了整个<em>模块</em>。一般来说，限制不安全代码的范围的唯一方法是在模块边界上设置权限。</p>
<p>然而，其实这个改动是可以<em>完美地</em>工作的。<code>make_room</code>的存在对于 Vec 的健全性来说<em>不是</em>个问题，因为我们没有把它标记为公共的。只有定义了这个函数的模块可以调用它。另外，<code>make_room</code>直接访问了 Vec 的私有字段，所以它只能写在与 Vec 相同的模块中。</p>
<p>因此，我们有可能基于复杂的不变性，编写一个完全安全的抽象。这对 Safe Rust 和 Unsafe Rust 之间的关系是<em>非常重要</em>的。</p>
<p>我们已经看到， unsafe 代码必须<em>一部分</em>信任 safe 代码，但不应该完全信任 safe 代码。出于类似的原因，访问控制对不安全代码也很重要：它可以防止我们不得不信任宇宙中所有的 safe 代码，防止它们扰乱我们的信任状态。</p>
<p>安全万岁！</p>
<h1><a class="header" href="#rust-中的数据布局" id="rust-中的数据布局">Rust 中的数据布局</a></h1>
<p>低层编程非常关心数据布局，这是个大问题。它也无孔不入地影响着语言的其他部分，所以我们将从挖掘数据在 Rust 中的布局方式开始。</p>
<p>本章最好与《The Reference》中的<a href="https://doc.rust-lang.org/reference/type-layout.html">类型布局</a>部分保持一致，并使之成为仅仅是多渲染了一份。本书刚写的时候，《The Reference》已经完全失修，而 Rust 秘典试图作为《The Reference》的部分替代。现在的情况不再是这样了，所以这一整章最好可以删除。</p>
<p>我们会把这一章再保留一段时间，但理想的情况是，你应该把任何新的事实或改进贡献给《The Reference》。</p>
<h1><a class="header" href="#reprrust" id="reprrust">repr(Rust)</a></h1>
<p>首先，所有类型都有一个以字节为单位的对齐方式，一个类型的对齐方式指定了哪些地址可以用来存储该值。一个具有对齐方式<code>n</code>的值只能存储在<code>n</code>的倍数的地址上。所以对齐方式 2 意味着你必须存储在一个偶数地址，而 1 意味着你可以存储在任何地方。对齐至少是 1，而且总是 2 的幂。</p>
<p>基础类型通常按照其大小对齐，尽管这是特定平台的行为。例如，在 x86 上<code>u64</code>和<code>f64</code>通常被对齐到 4 字节（32 位）。</p>
<p>一个类型的大小必须始终是其对齐方式的倍数（零是任何对齐方式的有效大小），这就保证了该类型的数组总是可以通过偏移其大小的倍数来进行索引。注意，在<a href="exotic-sizes.html#dynamically-sized-types-dsts">动态大小的类型</a>的情况下，一个类型的大小和对齐方式可能不是静态的。</p>
<p>Rust 给你提供了以下方式来布置复合数据。</p>
<ul>
<li>structs （命名复合类型 named product types）</li>
<li>tuples （匿名复合类型 anonymous product types）</li>
<li>arrays （同质复合类型 homogeneous product types）</li>
<li>enums （命名总和类型 —— 有标签的联合体 named sum types -- tagged unions）</li>
<li>unions （无标签的联合体 untagged unions）</li>
</ul>
<p>如果一个枚举的所有变体都没有相关联的数据，那么它就被称为<em>无字段(field-less)</em>。</p>
<p>默认情况下，复合结构的对齐方式等于其字段对齐方式的最大值。因此，Rust 会在必要时插入填充，以确保所有字段都正确对齐，并且整个类型的大小是其对齐的倍数。比如说：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    b: u32,
    c: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>将在目标上以 32 位对齐，将这些基本类型对齐到它们各自的大小。因此，整个结构的大小将是 32 位的倍数。它可能变成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: u8,
    _pad1: [u8; 3], // 需要和 `b` 内存对齐
    b: u32,
    c: u16,
    _pad2: [u8; 2], // 让总体的大小是 4 的倍数
}
<span class="boring">}
</span></code></pre></pre>
<p>或者：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    b: u32,
    c: u16,
    a: u8,
    _pad: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>所有数据都如同C语言中的一样，直接存储在结构里。然而，除了数组（密集排列且有序）之外，数据的布局在默认情况下都不是确定的。给出以下两个结构的定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    a: i32,
    b: u64,
}

struct B {
    a: i32,
    b: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust <em>确实</em>保证 A 的两个实例的数据布局完全相同。然而，Rust 目前<em>并不</em>保证 A 的实例与 B 的实例具有相同的字段排序或填充。</p>
<p>对于我们编写的 A 和 B 来说，这一点似乎是没有必要的，但是 Rust 的其他几个特性使得该语言有必要以复杂的方式来处理数据布局。</p>
<p>例如，考虑这个结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;T, U&gt; {
    count: u16,
    data1: T,
    data2: U,
}
<span class="boring">}
</span></code></pre></pre>
<p>现在考虑一下<code>Foo&lt;u32, u16&gt;</code>和<code>Foo&lt;u16, u32&gt;</code>的单态化的结果。如果 Rust 按照指定的顺序排列字段，我们希望它能对结构中的值进行填充以满足其对齐要求。因此，如果 Rust 不对字段重新排序，我们希望它能产生以下结果：</p>
<!-- ignore: explanation code -->
<pre><code class="language-rust ignore">struct Foo&lt;u16, u32&gt; {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo&lt;u32, u16&gt; {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}
</code></pre>
<p>后一种情况很显然浪费了空间，更高效地利用空间要求不同的单体有<em>不同的字段排序</em>。</p>
<p>枚举使情况变得更加复杂，直观地说，一个枚举如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
<span class="boring">}
</span></code></pre></pre>
<p>可能会被布局成：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FooRepr {
    data: u64, // 根据 tag 的不同，这一项可以为 u64，u32，或者 u8
    tag: u8,   // 0 = A，1 = B， 2 = C
}
<span class="boring">}
</span></code></pre></pre>
<p>事实上，这正是它的布局方式（根据<code>tag</code>的大小和位置来调整）。</p>
<p>然而，在一些情况下，这样的表述是低效的。这方面的典型案例是 Rust 的“空指针优化”：一个由单个外部单元变量（例如<code>None</code>）和一个（可能嵌套的）非空指针变量（例如<code>Some(&amp;T)</code>）组成的枚举，使得标签没有必要。空指针可以安全地被解释为单位（<code>None</code>）的变体。这导致的结果是，<code>size_of::&lt;Option&lt;&amp;T&gt;&gt;() == size_of::&lt;&amp;T&gt;()</code>。</p>
<p>在 Rust 中，有许多类型会包含不可为空的指针，如<code>Box&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>String</code>、<code>&amp;T</code>和<code>&amp;mut T</code>。同理，我们可以想象嵌套的枚举将它们的标记集中到一个单一的字段中，因为根据定义，它们的有效值范围有限。原则上，枚举可以使用相当复杂的算法，在整个嵌套类型中用禁止使用的值来存储枚举类型。因此，我们不指定枚举布局是<em>特别</em>值得的。</p>
<h1><a class="header" href="#非正常大小的类型" id="非正常大小的类型">非正常大小的类型</a></h1>
<p>大多数的时候，我们期望类型在编译时能够有一个静态已知的非零大小，但这并不总是 Rust 的常态。</p>
<h2><a class="header" href="#dynamically-sized-types-dsts" id="dynamically-sized-types-dsts">Dynamically Sized Types (DSTs)</a></h2>
<p>Rust 支持动态大小的类型（DST）：这些类型没有静态（编译时）已知的大小或者布局。从表面上看这有点离谱：Rust <em>必须</em>知道一个东西的大小和布局，才能正确地进行处理。从这个角度上看，DST 不是一个普通的类型，因为它们没有编译时静态可知的大小，它们只能存在于一个指针之后。任何指向 DST 的指针都会变成一个包含了完善 DST 类型信息的胖指针（详情见下方）。</p>
<p>Rust 暴露了两种主要的 DST 类型：</p>
<ul>
<li>trait objects：<code>dyn MyTrait</code></li>
<li>slices：<a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>[T]</code></a>、<a href="https://doc.rust-lang.org/std/primitive.str.html"><code>str</code></a>及其他</li>
</ul>
<p>Trait 对象代表某种类型，实现了它所指定的 Trait。确切的原始类型被<em>删除</em>，以利于运行时的反射，其中包含使用该类型的所有必要信息的 vtable。补全 Trait 对象指针所需的信息是 vtable 指针，被指向的对象的运行时的大小可以从 vtable 中动态地获取。</p>
<p>一个 slice 只是一些只读的连续存储——通常是一个数组或<code>Vec</code>。补全一个 slice 指针所需的信息只是它所指向的元素的数量，指针的运行时大小只是静态已知元素的大小乘以元素的数量。</p>
<p>结构实际上可以直接存储一个 DST 作为其最后一个字段，但这也会使它们自身成为一个 DST：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不能直接存储在栈上
struct MySuperSlice {
    info: u32,
    data: [u8],
}
<span class="boring">}
</span></code></pre></pre>
<p>如果这样的类型没有方法来构造它，那么它在很大程度上来看是没啥用的。目前，唯一支持的创建自定义 DST 的方法是使你的类型成为泛型，并执行<em>非固定大小转换（unsizing coercion）</em>：</p>
<pre><pre class="playground"><code class="language-rust">struct MySuperSliceable&lt;T: ?Sized&gt; {
    info: u32,
    data: T,
}

fn main() {
    let sized: MySuperSliceable&lt;[u8; 8]&gt; = MySuperSliceable {
        info: 17,
        data: [0; 8],
    };

    let dynamic: &amp;MySuperSliceable&lt;[u8]&gt; = &amp;sized;

    // 输出：&quot;17 [0, 0, 0, 0, 0, 0, 0, 0]&quot;
    println!(&quot;{} {:?}&quot;, dynamic.info, &amp;dynamic.data);
}
</code></pre></pre>
<p>（是的，自定义 DST 目前仅仅是一个基本半成品的功能。）</p>
<h2><a class="header" href="#零大小类型-zsts" id="零大小类型-zsts">零大小类型 (ZSTs)</a></h2>
<p>Rust 也允许类型指定他们不占空间：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Nothing; // 无字段意味着没有大小

// 所有字段都无大小意味着整个结构体无大小
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // 空元组无大小
    baz: [u8; 0], // 空数组无大小
}
<span class="boring">}
</span></code></pre></pre>
<p>就其本身而言，零尺寸类型（ZSTs）由于显而易见的原因是相当无用的。然而，就像 Rust 中许多奇怪的布局选择一样，它们的潜力在通用语境中得以实现。在 Rust 中，任何产生或存储 ZST 的操作都可以被简化为无操作（no-op）。首先，存储它甚至没有意义——它不占用任何空间。另外，这种类型的值只有一个，所以任何加载它的操作都可以直接凭空产生它——这也是一个无操作（no-op），因为它不占用任何空间。</p>
<p>这方面最极端的例子之一是 Set 和 Map。给定一个<code>Map&lt;Key, Value&gt;</code>，通常可以实现一个<code>Set&lt;Key&gt;</code>，作为<code>Map&lt;Key, UselessJunk&gt;</code>的一个薄封装。在许多语言中，这将需要为无用的封装分配空间，并进行存储和加载无用封装的工作，然后将其丢弃。对于编译器来说，证明这一点是不必要的，是一个困难的分析。</p>
<p>然而在 Rust 中，我们可以直接说<code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>。现在 Rust 静态地知道每个加载和存储都是无用的，而且没有分配有任何大小。其结果是，单例化的代码基本上是 HashSet 的自定义实现，而没有 HashMap 要支持值所带来的开销。</p>
<p>安全的代码不需要担心 ZST，但是<em>不安全的</em>代码必须小心没有大小的类型的后果。特别是，指针偏移是无操作的，而分配器通常<a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.alloc">需要一个非零的大小</a>。</p>
<p>请注意，对 ZST 的引用（包括空片），就像所有其他的引用一样，必须是非空的，并且适当地对齐。解引用 ZST 的空指针或未对齐指针是<a href="what-unsafe-does.html">未定义的行为</a>，就像其他类型的引用一样。</p>
<h2><a class="header" href="#空类型" id="空类型">空类型</a></h2>
<p>Rust 还允许声明<em>不能被实例化</em>的类型。这些类型只能在类型层讨论，而不能在值层讨论。空类型可以通过指定一个没有变体的枚举来声明：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {} // 没有变体的类型 = 空类型
<span class="boring">}
</span></code></pre></pre>
<p>空类型甚至比 ZST 更加边缘化。空类型的主要作用是为了让某个类型不可达。例如，假设一个 API 需要在一般情况下返回一个结果，但一个特定的情况实际上是不可能的。实际上可以通过返回一个<code>Result&lt;T, Void&gt;</code>来在类型级别上传达这个信息。API 的消费者可以放心地 unwrap 这样一个结果，因为他们知道这个值在本质上不可能是<code>Err</code>，因为这需要提供一个<code>Void</code>类型的值。</p>
<p>原则上，Rust 可以基于这个事实做一些有趣的分析和优化，例如，<code>Result&lt;T, Void&gt;</code>只表示为<code>T</code>，因为<code>Err</code>的情况实际上并不存在（严格来说，这只是一种优化，并不保证，所以例如将一个转化为另一个仍然是 UB）。</p>
<p>下面的例子是可以编译的:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}

let res: Result&lt;u32, Void&gt; = Ok(0);

// 不存在 Err 的情况，所以 Ok 实际上永远都能匹配成功
let Ok(num) = res;
<span class="boring">}
</span></code></pre></pre>
<p>关于空类型的最后一个微妙的细节是，构造一个指向它们的原始指针实际上是有效的，但对它们的解引用是未定义行为，因为那是没有意义的。</p>
<p>我们建议不要用<code>*const Void</code>来模拟 C 的<code>void*</code>类型。很多人之前这样做，但很快就遇到了麻烦，因为 Rust 没有任何安全防护措施来防止用不安全的代码来实例化空类型，如果你这样做了，就是未定义行为。因为开发者有将原始指针转换为引用的习惯，而构造一个<code>&amp;Void</code><em>也</em>是未定义行为，所以这尤其成问题。</p>
<p><code>*const ()</code>（或等价物）对<code>void*</code>来说效果相当好，可以做成引用而没有任何安全问题。它仍然不能阻止你试图读取或写入数值，但至少它可以编译成一个 no-op 而不是 UB。</p>
<h2><a class="header" href="#外部类型" id="外部类型">外部类型</a></h2>
<p>有一个<a href="https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md">已被接受的 RFC</a> 来增加具有未知大小的适当类型，称为 <em>extern 类型</em>，这将让 Rust 开发人员更准确地模拟像 C 的<code>void*</code>和其他“声明但从未定义”的类型。然而，截至 Rust 2018，<a href="https://github.com/rust-lang/rust/issues/43467">该功能在<code>size_of_val::&lt;MyExternType&gt;()</code>应该如何表现方面遇到了一些问题</a>。</p>
<h1><a class="header" href="#可选的数据布局" id="可选的数据布局">可选的数据布局</a></h1>
<p>Rust 允许你指定不同于默认的数据布局策略，并为你提供了<a href="%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%AE%83%E6%98%AF**%E9%9D%9E**%E6%AD%A3%E5%BC%8F%E7%9A%84">不安全代码指南</a>。</p>
<h2><a class="header" href="#reprc" id="reprc">repr(C)</a></h2>
<p>这是最重要的“repr”。它的意图相当简单：做 C 所做的事。字段的顺序、大小和对齐方式与你在 C 或 C++ 中期望的完全一样。任何你期望通过 FFI 边界的类型都应该有<code>repr(C)</code>，因为 C 是编程世界的语言框架。这对于合理地使用数据布局做更多的技巧也是必要的，比如将值重新解释为不同的类型。</p>
<p>我们强烈建议使用<a href="https://rust-lang.github.io/rust-bindgen/">rust-bindgen</a>和/或<a href="https://github.com/eqrion/cbindgen">cbindgen</a>来为你管理 FFI 的边界。Rust 团队与这些项目紧密合作，以确保它们能够稳健地工作，并与当前和未来关于类型布局和 <code>repr</code>s 的保证兼容。</p>
<p>必须记住<code>repr(C)</code>与 Rust 更奇特的数据布局功能的互动。由于它具有“用于 FFI”和“用于布局控制”的双重目的，<code>repr(C)</code>可以应用于那些如果通过 FFI 边界就会变得无意义或有问题的类型：</p>
<ul>
<li>ZST 仍然是零大小，尽管这不是 C 语言的标准行为，而且明确违背了 C++ 中空类型的行为，即它们仍然应该消耗一个字节的空间</li>
<li>DST 指针（宽指针）和 tuple 在 C 语言中没有对应的概念，因此从来不是 FFI 安全的</li>
<li>带有字段的枚举在 C 或 C++ 中也没有对应的概念，但是类型的有效桥接<a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">是被定义的</a></li>
<li>如果<code>T</code>是一个<a href="ffi.html#%E7%A9%BA%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96">FFI 安全的非空指针类型</a>，<code>Option&lt;T&gt;</code>被保证具有与<code>T</code>相同的布局和 ABI，因此也是 FFI 安全的。截至目前，这包括<code>&amp;</code>、<code>&amp;mut</code>和函数指针，所有这些都不能为空。</li>
<li>就<code>repr(C)</code>而言，元组结构和结构一样，因为与结构的唯一区别是字段没有命名。</li>
<li><code>repr(C)</code>相当于无字段枚举的<code>repr(u*)</code>之一（见下一节）。选择的大小和符号类型是目标平台的 C 应用二进制接口（ABI）的默认枚举大小与符号类型。请注意，C 语言中的枚举表示法是实现定义的，所以这实际上是一个“最佳猜测”。特别是，当对应的 C 代码在编译时带有某些标志时，这可能是不正确的。</li>
<li>带有<code>repr(C)</code>或<code>repr(u*)</code>的无字段枚举仍然不能在没有相应变量的情况下设置为整数值，尽管这在 C 或 C++ 中是允许的行为。如果（不安全地）构造一个枚举的实例，但不与它的一个变体相匹配，这是未定义的行为(这使得详尽的匹配可以继续被编写和编译为正常行为)。</li>
</ul>
<h2><a class="header" href="#reprtransparent" id="reprtransparent">repr(transparent)</a></h2>
<p><code>#[repr(transparent)]</code>只能用于只有单个非零大小字段（可能还有其他零大小字段）的结构或者单变体 enum 中。其效果是，整个结构的布局和 ABI 被保证与该字段相同。</p>
<blockquote>
<p>注意：有一个叫做<code>transparent_unions</code>的 nightly 的特性，可以让你对 union 指定<code>repr(transparent)</code>。不过由于设计上的一些顾虑，这个特性目前还未稳定，参考<a href="issue-60405">issue-60405</a>。</p>
</blockquote>
<p>我们的目标是使单一字段和结构/枚举之间的转换成为可能。一个例子是<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>，它可以被转换为它所包装的类型。（<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>也用了一个不稳定的特性<a href="https://github.com/rust-lang/rust/pull/68491">no_niche</a>，所以当它嵌套其它类型的时候，它的 ABI 也并没有一个稳定的保证。）</p>
<p>另外，当我们通过 FFI 传递结构/枚举，并且其中内部字段类型是另一端所需的类型时，我们能保证这是正确的。特别是，这对于<code>struct Foo(f32)</code>或者<code>enum Foo { Bar(f32) }</code>总是具有与<code>f32</code>相同的 ABI 是必要的。</p>
<p>只有在唯一的字段为<code>pub</code>或其内存布局在文档中所承诺的情况下，该 repr 才被视为一个类型的公共 ABI 的一部分。否则，该内存布局不应被其他 crate 所依赖。</p>
<p>更多细节可以参考<a href="https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md">RFC 1758</a>和<a href="https://rust-lang.github.io/rfcs/2645-transparent-unions.html">RFC 2645</a>。</p>
<h2><a class="header" href="#repru-repri" id="repru-repri">repr(u*), repr(i*)</a></h2>
<p>这些指定了使无字段枚举的大小和符号类型。如果判别符超过了它可以容纳的整数，就会产生一个编译时错误。你可以通过将溢出的元素明确设置为 0 来手动要求 Rust 允许这样做。</p>
<p>术语“无字段枚举”仅意味着该枚举在其任何变体中都没有数据。没有<code>repr(u*)</code>或<code>repr(C)</code>的无字段枚举仍然是一个 Rust 本地类型，没有稳定的 ABI 表示。添加<code>repr</code>会使它在 ABI 上被视为与指定的整数类型大小完全相同。</p>
<p>如果枚举有字段，其效果类似于<code>repr(C)</code>的效果，因为该类型有一个定义的布局。这使得将枚举传递给 C 代码或者访问该类型的原始表示并直接操作其标记和字段成为可能，详见<a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">RFC</a>。</p>
<p>这些“repr”对结构（struct）没有作用。</p>
<p>在含有字段的枚举中加入明确的<code>repr(u*)</code>、<code>repr(i*)</code>或<code>repr(C)</code>可以抑制空指针优化，比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::size_of;
</span>enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

#[repr(u8)]
enum MyReprOption&lt;T&gt; {
    Some(T),
    None,
}

assert_eq!(8, size_of::&lt;MyOption&lt;&amp;u16&gt;&gt;());
assert_eq!(16, size_of::&lt;MyReprOption&lt;&amp;u16&gt;&gt;());
<span class="boring">}
</span></code></pre></pre>
<p>空指针优化针对无字段且拥有<code>repr(u*)</code>、<code>repr(i*)</code>或<code>repr(C)</code>的枚举仍然生效。</p>
<h2><a class="header" href="#reprpacked" id="reprpacked">repr(packed)</a></h2>
<p><code>repr(packed)</code>强制 Rust 去掉任何填充，只将类型对齐到一个字节。这可能会改善内存占用，但可能会有其他负面的副作用。</p>
<p>特别是，大多数架构<em>强烈地</em>希望数值被对齐。这可能意味着不对齐的加载会受到惩罚（x86），甚至会出现故障（一些 ARM 芯片）。对于简单的情况，如直接加载或存储一个已打包的字段，编译器可能能够用移位和掩码来解决对齐问题。然而，如果你对一个已打包的字段进行引用，编译器就不太可能发出代码来避免无对齐的加载。</p>
<p><a href="https://github.com/rust-lang/rust/issues/27060">由于这可能导致未定义的行为</a>，我们在 Lint 中已经实现了对应的检查，并且该行为会被认为是错误。</p>
<p><code>repr(packed)</code>是不能轻易使用的，除非你有极端的要求，否则不应该使用这个。</p>
<p>这个 repr 是对<code>repr(C)</code>和<code>repr(Rust)</code>的修改。</p>
<h2><a class="header" href="#repralignn" id="repralignn">repr(align(n))</a></h2>
<p><code>repr(align(n))</code>(其中<code>n</code>是 2 的幂)强制类型<em>至少</em>按照 n 对齐。</p>
<p>这可以实现一些技巧，比如确保数组中的相邻元素不会彼此共享同一个缓存行（这可能会加快某些类型的并发代码）。</p>
<p>这是<code>repr(C)</code>和<code>repr(Rust)</code>的一个修改版本，它与<code>repr(packed)</code>不兼容。</p>
<h1><a class="header" href="#所有权和生命周期" id="所有权和生命周期">所有权和生命周期</a></h1>
<p>所有权是 Rust 的突破性功能。它使 Rust 能够做到完全的内存安全和高效，同时避免了垃圾回收。在详细介绍所有权系统之前，我们将考虑这一设计的动机。</p>
<p>我们将假设你同意垃圾收集（GC）并不总是一个最佳解决方案，而且在某些情况下手动管理内存更为适合。如果你不接受这一点，我是否可以让你对另一种语言感兴趣？</p>
<p>不管你对 GC 的看法如何，它显然是一个使代码更安全的<em>好办法</em>，你永远不必担心你的对象会在引用失效前就被释放。这是一个 C 和 C++ 程序需要处理的普遍存在的问题。比如下面这个简单的错误，我们所有使用过非 GC 语言的人都曾经犯过：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_str(data: &amp;u32) -&gt; &amp;str {
    // 计算出字符串
    let s = format!(&quot;{}&quot;, data);

    // 不好！我们返回了一个仅仅在函数中存在的变量的引用!
    // 悬挂指针！释放后使用！哎呀！
    //（这在 Rust 中无法编译通过）
    &amp;s
}
<span class="boring">}
</span></code></pre></pre>
<p>这正是 Rust 的所有权系统所要解决的问题。Rust 知道<code>&amp;s</code>所在的范围，因此可以防止它逃逸。然而，这是一个简单的案例，即使是 C 语言的编译器也能合理地抓住。随着代码越来越大，指针被送入各种函数，事情变得越来越复杂。最终，C 语言编译器会倒下，无法进行足够的转义分析来证明你的代码不健全。因此，它将被迫接受你的程序，假设它是正确的。</p>
<p>这种情况永远不会发生在 Rust 上，Rust 要求程序员来向编译器证明一切是正确的。</p>
<p>当然，Rust 围绕所有权的故事要比仅仅验证引用不脱离其所有者的范围要复杂得多，这是因为确保指针始终有效要比这复杂得多。例如，在这段代码中：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
// 获取内部元素的引用
let x = &amp;data[0];

// 不好！ `push` 操作导致 `data` 的存储空间重新分配了
// 悬挂指针！释放后使用！哎呀！
//（这在 Rust 中无法编译通过）
data.push(4);

println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>简单的作用域分析不足以防止这个 bug，因为<code>data</code>事实上确实存活得足够久，满足我们的需求。然而，当我们对它有一个引用时，它被<em>改变</em>了。这就是为什么 Rust 要求任何引用都要冻结引用者和其所有者。</p>
<h1><a class="header" href="#引用" id="引用">引用</a></h1>
<p>有两种类型的引用：</p>
<ul>
<li>共享的引用：<code>&amp;</code></li>
<li>可变引用：<code>&amp;mut</code></li>
</ul>
<p>它们遵守以下规则：</p>
<ul>
<li>一个引用的生命周期不能超过它所引用对象的生命周期</li>
<li>一个可变的引用不能有别名</li>
</ul>
<p>这就是引用所遵循的整个模型。</p>
<p>当然，我们也许应该定义<em>别名</em>的含义：</p>
<pre><code class="language-text">error[E0425]: cannot find value `aliased` in this scope
 --&gt; &lt;rust.rs&gt;:2:20
  |
2 |     println!(&quot;{}&quot;, aliased);
  |                    ^^^^^^^ not found in this scope

error: aborting due to previous error
</code></pre>
<p>不幸的是，Rust 还没有真正定义其别名模型。🙀</p>
<p>在我们等待 Rust 的设计者明确他们语言的语义时，让我们用下一节来讨论下在一般场景下别名到底是什么，以及它为什么重要。</p>
<h1><a class="header" href="#别名" id="别名">别名</a></h1>
<p>首先，让我们先说一些重要的注意事项：</p>
<ul>
<li>
<p>为了便于讨论，我们将使用最广泛的别名定义。Rust 的定义可能会有更多限制，以考虑到可变性和有效性。</p>
</li>
<li>
<p>我们将假设一个单线程的、无中断的执行，我们还将忽略像内存映射硬件这样的东西。Rust 假定这些事情不会发生，除非你明确告诉它会发生。更多细节，请参阅<a href="concurrency.html">并发性章节</a>。</p>
</li>
</ul>
<p>所以，我们现行的定义是：如果变量和指针指向内存的重叠区域，那么它们就是<em>别名</em>。</p>
<h2><a class="header" href="#为什么别名很重要" id="为什么别名很重要">为什么别名很重要</a></h2>
<p>为什么我们需要关注别名呢？</p>
<p>让我们看下这个例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    if *input &gt; 10 {
        *output = 1;
    }
    if *input &gt; 5 {
        *output *= 2;
    }
    // 记住一点: 如果 `input&gt;10`，那么 `output` 永远为 `2`
}
<span class="boring">}
</span></code></pre></pre>
<p>我们<em>希望</em>能够把它优化成下面这样的函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    let cached_input = *input; // 将 `*input` 中的内容保存在寄存器中
    if cached_input &gt; 10 {
        // 如果输入比 10 大, 优化之前的代码会将 output 设置为 1，然后乘以 2，
        // 结果一定返回 `2` （因为 `&gt;10` 包括了 `&gt;5` 的情况），
        // 因此这里可以进行优化，
        // 不对 output 重复赋值，直接将其设置为 2
        *output = 2;
    } else if cached_input &gt; 5 {
        *output *= 2;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，这种优化应该是可行的。但对于几乎任何其他语言来说，它都不是这样的（除非是全局分析）。这是因为这个优化依赖于知道别名不会发生，而大多数语言在这方面是相当宽松的。具体来说，我们需要担心那些使“输入”和“输出”重叠的函数参数，如<code>compute(&amp;x, &amp;mut x)</code>。</p>
<p>如果按照这样的输入，我们实际上执行的代码如下：</p>
<!-- ignore: expanded code -->
<pre><code class="language-rust ignore">                    //  input ==  output == 0xabad1dea
                    // *input == *output == 20
if *input &gt; 10 {    // true  (*input == 20)
    *output = 1;    // 同时覆盖了 input 引用的内容，因为它们实际上引用了同一块内存
}
if *input &gt; 5 {     // false (*input == 1)
    *output *= 2;
}
                    // *input == *output == 1
</code></pre>
<p>我们的优化函数对于这个输入会产生<code>*output == 2</code>，所以在这种情况下，我们的优化就无法实现了。</p>
<p>在 Rust 中，我们知道这个输入是不可能的，因为<code>&amp;mut</code>不允许被别名。所以我们可以安全地认为这种情况不会发生，并执行这个优化。在大多数其他语言中，这种输入是完全可能的，因此必须加以考虑。</p>
<p>这就是为什么别名分析很重要的原因：它可以让编译器进行有用的优化! 比如：</p>
<ul>
<li>通过证明没有指针访问该值的内存来保持寄存器中的值</li>
<li>通过证明某些内存在我们上次读取后没有被写入，来消除读取</li>
<li>通过证明某些内存在下一次写入之前从未被读过，来消除写入</li>
<li>通过证明读和写之间不相互依赖来对指令进行移动或重排序</li>
</ul>
<p>这些优化也用于证明更大的优化的合理性，如循环矢量化、常数传播和死代码消除。</p>
<p>在前面的例子中，我们利用<code>&amp;mut u32</code>不能被别名的事实来证明对<code>*output</code>的写入不可能影响<code>*input</code>。这让我们把<code>*input</code>缓存在一个寄存器中，省去了读的过程。</p>
<p>通过缓存这个读，我们知道在<code>&gt; 10</code>分支中的写不能影响我们是否采取<code>&gt; 5</code>分支，使我们在<code>*input &gt; 10</code>时也能消除一个读-修改-写（加倍<code>*output</code>）。</p>
<p>关于别名分析，需要记住的关键一点是，写是优化的主要危险。也就是说，阻止我们将读移到程序的任何其他部分的唯一原因是我们有可能将其与写到同一位置重新排序。</p>
<p>例如，在下面这个修改后的函数中，我们不需要担心别名问题，因为我们已经将唯一一个写到<code>*output</code>的地方移到了函数的最后。这使得我们可以自由地重新排序在它之前发生的对<code>*input</code>的读取：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute(input: &amp;u32, output: &amp;mut u32) {
    let mut temp = *output;
    if *input &gt; 10 {
        temp = 1;
    }
    if *input &gt; 5 {
        temp *= 2;
    }
    *output = temp;
}
<span class="boring">}
</span></code></pre></pre>
<p>我们仍然依靠别名分析来假设<code>temp</code>没有别名<code>input</code>，但是证明要简单得多：局部变量的值不能被在它被声明之前就存在的东西所别名。这是每一种语言都可以自由做出的假设，因此这个版本的函数可以在任何语言中按照我们想要的方式进行优化。</p>
<p>这就是为什么 Rust 将使用的“别名”的定义可能涉及到一些有效性和可变性的概念：如果没有任何实际写入内存的情况发生，我们实际上并不关心别名是否发生。</p>
<p>当然，Rust 的完整别名模型还必须考虑到函数调用（可能会改变我们看不到的东西）、原始指针（它本身没有别名要求）和 UnsafeCell（它让<code>&amp;</code>的引用被改变）等东西。</p>
<h1><a class="header" href="#生命周期" id="生命周期">生命周期</a></h1>
<p>Rust 通过<em>生命周期</em>来执行相关的规则。生命周期是指一个引用必须有效的代码区域，这些区域可能相当复杂，因为它们对应着程序中的执行路径。这些执行路径中甚至可能存在空洞(译者注: 空洞是指一个引用的生命周期可能不是一个连续的代码区域，中间可能有跳跃)，因为我们可能会先使一个引用失效，之后再重新初始化并使用它。包含引用（或假装包含）的类型也可以用生命周期来标记，这样 Rust 就可以防止它们也被失效。</p>
<p>在我们大多数例子中，生命周期将与作用域重合，这是因为我们的例子很简单。下面将介绍它们不重合的更复杂的情况。</p>
<p>在一个函数体中，Rust 通常不需要你明确地命名所涉及的生命周期。这是因为一般来说，在本地环境中谈论生命周期是没有必要的；Rust 拥有所有的信息，并且可以尽可能地以最佳方式解决所有问题。Rust 还会引入许多匿名作用域和临时变量, 你不必显式写出它们, 代码也可以跑通。</p>
<p>然而，一旦你跨越了函数的边界，你就需要开始考虑生命周期了。生命周期是用撇号表示的：<code>'a</code>、<code>'static</code>。为了尝试使用生命周期，我们将假装我们被允许用生命周期来标记作用域，并尝试手动解一下本章开头例子的语法糖。</p>
<p>我们之前的例子使用了一种<em>激进</em>的语法糖——甚至是高果糖玉米糖浆——因为明确地写出所有东西是<em>非常繁琐</em>的。所有的 Rust 代码都依赖于积极的推理和对“显而易见”的东西的删除。</p>
<p>一个特别有趣的语法糖是，每个<code>let</code>语句都隐含地引入了一个作用域。在大多数情况下，这其实并不重要。然而，这对那些相互引用的变量来说确实很重要。作为一个简单的例子，让我们对这段简单的 Rust 代码进行完全解糖：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let y = &amp;x;
let z = &amp;y;
<span class="boring">}
</span></code></pre></pre>
<p>借用检查器总是试图最小化生命周期的范围，所以它很可能会脱糖为以下内容：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">// NOTE: `'a: {` 和 `&amp;'b x` 不是有效的语法，这里只是为了说明 lifetime 的概念
'a: {
    let x: i32 = 0;
    'b: {
        // y 的生命周期为 'b，因为这已经足够好
        let y: &amp;'b i32 = &amp;'b x;
        'c: {
            // 'c 同上所示
            let z: &amp;'c &amp;'b i32 = &amp;'c y; // &quot;a reference to a reference to an i32&quot; (with lifetimes annotated)
        }
    }
}
</code></pre>
<p>哇，这真是……太可怕了！让我们花点时间感谢 Rust 让这一切变得简单。</p>
<p>实际上，传递一个引用到外部作用域将导致 Rust 推断出一个更大的生命周期。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0;
let z;
let y = &amp;x;
z = y;
<span class="boring">}
</span></code></pre></pre>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">'a: {
    let x: i32 = 0;
    'b: {
        let z: &amp;'b i32;
        'c: {
            // y 的生命周期一定为 'b，因为对 x 的引用被传递到了 'b 这个作用域
            let y: &amp;'b i32 = &amp;'b x;
            z = y;
        }
    }
}
</code></pre>
<h2><a class="header" href="#例子超出所有者生命周期的引用" id="例子超出所有者生命周期的引用">例子：超出所有者生命周期的引用</a></h2>
<p>让我们看看之前的那些例子：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_str(data: &amp;u32) -&gt; &amp;str {
    let s = format!(&quot;{}&quot;, data);
    &amp;s
}
<span class="boring">}
</span></code></pre></pre>
<p>解语法糖后：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!(&quot;{}&quot;, data);
        return &amp;'a s;
    }
}
</code></pre>
<p><code>as_str</code>的这个签名接收了一个具有<em>某个</em>生命周期的 u32 的引用，并返回一个可以<em>存活同样长</em>的 str 的引用。我们已经大致能猜到为什么这个函数签名可能是个麻烦了，这意味着我们要找的那个 str 要在 u32 的引用所处的作用域上，或者<em>甚至在更大的作用域上</em>。这要求有点高。</p>
<p>然后我们继续计算字符串<code>s</code>，并返回它的一个引用。由于我们的函数的契约规定这个引用必须超过<code>'a</code>，这就是我们推断出的引用的生命周期。不幸的是，<code>s</code>被定义在作用域<code>'b</code>中，所以唯一合理的方法是<code>'b</code>包含<code>'a</code>，这显然是错误的，因为<code>'a</code>必须包含函数调用本身。因此，我们创建了一个引用，它的生命周期超过了它的引用者，这正是我们所说的引用不能做的第一件事。编译器理所当然地直接报错。</p>
<p>为了更清楚地说明这一点，我们可以扩展这个例子：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">fn as_str&lt;'a&gt;(data: &amp;'a u32) -&gt; &amp;'a str {
    'b: {
        let s = format!(&quot;{}&quot;, data);
        return &amp;'a s
    }
}

fn main() {
    'c: {
        let x: u32 = 0;
        'd: {
            // 这里引入了一个匿名作用域，因为借用不需要在整个 x 的作用域内生效，
            // 这个函数必须返回一个在函数调用之前就存在的某个字符串的引用，事实显然不是这样
            println!(&quot;{}&quot;, as_str::&lt;'d&gt;(&amp;'d x));
        }
    }
}
</code></pre>
<p>当然，这个函数的正确写法是这样的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_string(data: &amp;u32) -&gt; String {
    format!(&quot;{}&quot;, data)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们必须在函数里面产生一个拥有所有权的值才能返回! 我们唯一可以返回一个<code>&amp;'a str</code>的方法是，它在<code>&amp;'a u32</code>的一个字段中，但显然不是这样的。</p>
<p>（实际上我们也可以直接返回一个字符串字面量，作为一个全局的字面量可以被认为是在堆栈的底部；尽管这对我们的实现<em>有一点</em>限制）。</p>
<h2><a class="header" href="#示例别名一个可变引用" id="示例别名一个可变引用">示例：别名一个可变引用</a></h2>
<p>来看另一个例子：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];
data.push(4);
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">'a: {
    let mut data: Vec&lt;i32&gt; = vec![1, 2, 3];
    'b: {
        // 'b 这个生命周期范围如我们所愿地小（刚好够 println!）
        let x: &amp;'b i32 = Index::index::&lt;'b&gt;(&amp;'b data, 0);
        'c: {
            // 这里有一个临时作用域，我们不需要更长时间的 &amp;mut 借用
            Vec::push(&amp;'c mut data, 4);
        }
        println!(&quot;{}&quot;, x);
    }
}
</code></pre>
<p>这里的问题更微妙、更有趣。我们希望 Rust 拒绝这个程序，理由如下：我们有一个存活的共享引用<code>x</code>到<code>data</code>的一个子集，当我们试图把<code>data</code>的可变引用传给<code>push</code>时。这将创建一个可变引用的别名，而这将违反引用的<em>第二条</em>规则。</p>
<p>然而，这根本不是 Rust 认为这个程序有问题的原因。Rust 不理解<code>x</code>是对<code>data</code>的一个子集的引用。它根本就不理解<code>Vec</code>。它看到的是，<code>x</code>必须在<code>'b</code>范围内保持存活才能被打印；接下来，<code>Index::index</code>的签名要求我们对<code>data</code>的引用必须在<code>'b</code>范围内存活。当我们试图调用<code>push</code>时，它看到我们试图构造一个<code>&amp;'c mut data</code>。Rust 知道<code>'c</code>包含在<code>'b</code>中，并拒绝了我们的程序，因为<code>&amp;'b data</code>必然还存活着！</p>
<p>在这里我们看到，和我们真正想要保证的引用规则语义相比，生命周期系统要粗略得多。在大多数情况下，<em>这完全没问题</em>，因为它使我们不用花整天的时间向编译器解释我们的程序。然而，这确实意味着有部分程序对于 Rust 的<em>真正的</em>语义来说是完全正确的，但却被拒绝了，因为 lifetime 太傻了。</p>
<h2><a class="header" href="#生命周期所覆盖的区域" id="生命周期所覆盖的区域">生命周期所覆盖的区域</a></h2>
<p>一个引用（有时称为<em>borrow</em>）从它被创建到最后一次使用都是<em>存活</em>的。被 borrow 的值的生命周期只需要超过引用的生命周期就行。这看起来很简单，但有一些微妙之处。</p>
<p>下面的代码可以成功编译，因为在打印完<code>x</code>之后，它就不再需要了，所以它是悬空的还是别名的都无所谓（尽管变量<code>x</code><em>技术上</em>一直存活到作用域的最后）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];
println!(&quot;{}&quot;, x);
// 这是可行的，因为不再使用 x，编译器也就缩短了 x 的生命周期
data.push(4);
<span class="boring">}
</span></code></pre></pre>
<p>然而，如果该值有一个析构器，析构器就会在作用域的末端运行。而运行析构器被认为是一种使用——显然是最后一次使用。所以，这将会编译报错：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct X&lt;'a&gt;(&amp;'a i32);

impl Drop for X&lt;'_&gt; {
    fn drop(&amp;mut self) {}
}

let mut data = vec![1, 2, 3];
let x = X(&amp;data[0]);
println!(&quot;{:?}&quot;, x);
data.push(4);
// 编译器会在这里自动插入 drop 函数，也就意味着我们会访问 x 中引用的变量，因此编译失败
<span class="boring">}
</span></code></pre></pre>
<p>让编译器相信<code>x</code>不再有效的一个方法是在<code>data.push(4)</code>之前使用<code>drop(x)</code>。</p>
<p>此外，可能会有多种最后一次的引用使用，例如在一个条件的每个分支中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn some_condition() -&gt; bool { true }
</span>let mut data = vec![1, 2, 3];
let x = &amp;data[0];

if some_condition() {
    println!(&quot;{}&quot;, x); // 这是该分支中最后一次使用 x 这个引用
    data.push(4);      // 因此在这里 push 操作是可行的
} else {
    // 这里不存在对 x 的使用，对于这个分支来说，
    // x 创建即销毁
    data.push(5);
}
<span class="boring">}
</span></code></pre></pre>
<p>生命周期中可以有暂停，或者你可以把它看成是两个不同的借用，只是被绑在同一个局部变量上。这种情况经常发生在循环周围（在循环结束时写入一个变量的新值，并在下一次迭代的顶部最后一次使用它）。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = vec![1, 2, 3];
// x 是可变的（通过 mut 声明），因此我们可以修改 x 指向的内容
let mut x = &amp;data[0];

println!(&quot;{}&quot;, x); // 最后一次使用这个引用
data.push(4);
x = &amp;data[3]; // x 在这里借用了新的变量
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>Rust 曾经一直保持着借用的生命，直到作用域结束，所以这些例子在旧的编译器中可能无法编译。此外，还有一些边界条件，Rust 不能正确地缩短借用的有效部分，即使看起来应该这样做，也不能编译。这些问题将随着时间的推移得到解决。</p>
<h1><a class="header" href="#生命周期的局限" id="生命周期的局限">生命周期的局限</a></h1>
<p>让我们来看以下代码：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&amp;mut self) -&gt; &amp;Self { &amp;*self }
    fn share(&amp;self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
    println!(&quot;{:?}&quot;, loan);
}
</code></pre></pre>
<p>人们可能期望它能被编译成功，我们调用<code>mutate_and_share</code>，它可以暂时可变借用<code>foo</code>，但随后只返回一个共享引用。因此我们期望<code>foo.share()</code>能够成功，因为<code>foo</code>不应该被可变借用。</p>
<p>然而，当我们试图编译它时：</p>
<pre><code class="language-text">error[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable
  --&gt; src/main.rs:12:5
   |
11 |     let loan = foo.mutate_and_share();
   |                --- mutable borrow occurs here
12 |     foo.share();
   |     ^^^ immutable borrow occurs here
13 |     println!(&quot;{:?}&quot;, loan);
</code></pre>
<p>这是为啥？好吧，我们得到的推理和<a href="lifetimes.html#%E7%A4%BA%E4%BE%8B%E5%88%AB%E5%90%8D%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">上一节例 2</a>完全一样。我们对程序进行解语法糖后，可以得到如下结果：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">struct Foo;

impl Foo {
    fn mutate_and_share&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a Self { &amp;'a *self }
    fn share&lt;'a&gt;(&amp;'a self) {}
}

fn main() {
    'b: {
        let mut foo: Foo = Foo;
        'c: {
            let loan: &amp;'c Foo = Foo::mutate_and_share::&lt;'c&gt;(&amp;'c mut foo);
            'd: {
                Foo::share::&lt;'d&gt;(&amp;'d foo);
            }
            println!(&quot;{:?}&quot;, loan);
        }
    }
}
</code></pre>
<p>由于<code>loan</code>的生命周期和<code>mutate_and_share</code>的签名，生命周期系统被迫将<code>&amp;mut foo</code>扩展为<code>'c</code>的生命周期。然后当我们试图调用<code>share</code>时，它看到我们试图别名<code>&amp;'c mut foo</code>，然后就炸了！</p>
<p>根据我们真正关心的引用语义，这个程序显然是正确的，但是生命周期系统太蠢了(原话是粗糙)，无法处理这个问题。</p>
<h2><a class="header" href="#不正确地缩减借用" id="不正确地缩减借用">不正确地缩减借用</a></h2>
<p>下面的代码无法编译成功，因为 Rust 发现<code>map</code>变量被借用了两次，并且不能推断出在第二次借用之前，第一次借用已经不需要了，所以保守地退回到使用整个作用域作为第一次借用的生命周期。不过不用担心，这个问题最终会得到解决：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::hash::Hash;
</span>fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
where
    K: Clone + Eq + Hash,
    V: Default,
{
    match map.get_mut(&amp;key) {
        Some(value) =&gt; value,
        None =&gt; {
            map.insert(key.clone(), V::default());
            map.get_mut(&amp;key).unwrap()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>由于所施加的生命周期限制，<code>&amp;mut map</code>的生命周期与其他可变的借用重叠，导致编译错误：</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*map` as mutable more than once at a time
  --&gt; src/main.rs:12:13
   |
4  |   fn get_default&lt;'m, K, V&gt;(map: &amp;'m mut HashMap&lt;K, V&gt;, key: K) -&gt; &amp;'m mut V
   |                  -- lifetime `'m` defined here
...
9  |       match map.get_mut(&amp;key) {
   |       -     --- first mutable borrow occurs here
   |  _____|
   | |
10 | |         Some(value) =&gt; value,
11 | |         None =&gt; {
12 | |             map.insert(key.clone(), V::default());
   | |             ^^^ second mutable borrow occurs here
13 | |             map.get_mut(&amp;key).unwrap()
14 | |         }
15 | |     }
   | |_____- returning this value requires that `*map` is borrowed for `'m`
</code></pre>
<h1><a class="header" href="#生命周期省略" id="生命周期省略">生命周期省略</a></h1>
<p>为了使常见的模式更符合人体工程学，Rust 允许在函数签名中<em>省略</em>生命周期。</p>
<p><em>生命周期位置</em>是指在一个类型中可以写入生命周期的任何地方。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">&amp;'a T
&amp;'a mut T
T&lt;'a&gt;
</code></pre>
<p>生命周期位置可以作为“输入”或“输出”出现：</p>
<ul>
<li>对于<code>fn</code>定义、<code>fn</code>类型以及 Trait <code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>，输入是指形式参数的类型，而输出是指结果类型。所以<code>fn foo(s: &amp;str) -&gt; (&amp;str, &amp;str)</code>在输入位置有一个生命周期，在输出位置有两个生命周期。请注意，<code>fn</code>方法定义的输入位置不包括方法的<code>impl</code>头中出现的生命周期（对于默认方法，也不包括 trait 头中出现的生命周期）</li>
<li>对于<code>impl</code>头，所有类型都是输入。所以<code>impl Trait&lt;&amp;T&gt; for Struct&lt;&amp;T&gt;</code>在输入位置上省略了两个生命周期，而<code>impl Struct&lt;&amp;T&gt;</code>则省略了一个</li>
</ul>
<p>省略规则如下：</p>
<ul>
<li>在输入位置的每一个被省略的生命周期都成为一个独立的生命周期参数</li>
<li>如果正好有一个输入生命周期的位置（无论是否被省略），该生命周期将被分配给<em>所有</em>被省略的输出生命周期</li>
<li>如果有多个输入生命周期位置，但其中一个是<code>&amp;self</code>或<code>&amp;mut self</code>，那么<code>self</code>的生命周期将被分配给<em>所有</em>被省略的输出生命周期</li>
<li>否则，省略一个输出生命周期是一个错误</li>
</ul>
<p>示例：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn print(s: &amp;str);                                      // elided
fn print&lt;'a&gt;(s: &amp;'a str);                               // expanded

fn debug(lvl: usize, s: &amp;str);                          // elided
fn debug&lt;'a&gt;(lvl: usize, s: &amp;'a str);                   // expanded

fn substr(s: &amp;str, until: usize) -&gt; &amp;str;               // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;     // expanded

fn get_str() -&gt; &amp;str;                                   // ILLEGAL

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // ILLEGAL

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T;              // expanded

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command                  // elided
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter;                    // elided
fn new(buf: &amp;mut [u8]) -&gt; BufWriter&lt;'_&gt;;                // elided (with `rust_2018_idioms`)
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;          // expanded
</code></pre>
<h1><a class="header" href="#不受约束的生命周期" id="不受约束的生命周期">不受约束的生命周期</a></h1>
<p>不安全的代码经常会凭空产生引用或生命周期，这种生命周期是以<em>无约束</em>的形式出现在世界中的。最常见的原因是对原始指针的解引用，这产生了一个具有无约束生命周期的引用。这样的生命周期会随着上下文的要求而变大。这实际上比简单地标记为<code>'static</code>更强大，因为例如<code>&amp;'static &amp;'a T</code>将无法通过类型检查，但无约束的生命周期将根据需要完美地塑造为<code>&amp;'a &amp;'a T</code>。然而，对于大多数意图和目的来说，这样的无约束生命周期可以被看作是<code>'static</code>。</p>
<p>几乎没有引用是<code>'static</code>的，所以这可能是错误的。<code>transmute</code>和<code>transmute_copy</code>是另外两个主要的违规者。我们应该尽可能快地约束一个无约束的生命周期，特别是当跨越函数边界的时候。</p>
<p>给定一个函数，任何不来自输入的输出生命周期都是无约束的，比如说：</p>
<!-- no_run: This example exhibits undefined behavior. -->
<pre><pre class="playground"><code class="language-rust no_run">fn get_str&lt;'a&gt;(s: *const String) -&gt; &amp;'a str {
    unsafe { &amp;*s }
}
fn main() {
    let soon_dropped = String::from(&quot;hello&quot;);
    let dangling = get_str(&amp;soon_dropped);
    drop(soon_dropped);
    println!(&quot;Invalid str: {}&quot;, dangling); // Invalid str: gӚ_`
}
</code></pre></pre>
<p>避免无约束生命周期的最简单方法是在函数边界使用生命周期省略。如果一个输出的生命周期被省略了，那么它<em>必须</em>被一个输入的生命周期所约束。当然，它也可能被错误的生命周期所约束，但这通常只会引起编译错误，而不是让内存安全被简单地违反。</p>
<p>在一个函数中，对生命周期的约束更容易出错。约束生命周期的最安全和最简单的方法是从一个具有约束的生命周期的函数中返回它。然而，如果这样做是不可接受的，可以将引用放在一个有特定生命周期的位置。不幸的是，我们不可能命名一个函数中涉及的所有生命周期。</p>
<h1><a class="header" href="#higher-rank-trait-bounds-hrtbs" id="higher-rank-trait-bounds-hrtbs">Higher-Rank Trait Bounds (HRTBs)</a></h1>
<p>Rust 的<code>Fn</code> trait 有一些黑魔法，例如，我们可以写出下面的代码：</p>
<pre><pre class="playground"><code class="language-rust">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    where F: Fn(&amp;(u8, u16)) -&gt; &amp;u8,
{
    fn call(&amp;self) -&gt; &amp;u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it(data: &amp;(u8, u16)) -&gt; &amp;u8 { &amp;data.0 }

fn main() {
    let clo = Closure { data: (0, 1), func: do_it };
    println!(&quot;{}&quot;, clo.call());
}
</code></pre></pre>
<p>如果我们试图天真地用与<a href="lifetimes.html">生命周期</a>部分相同的方式来对这段代码进行解语法糖，我们会遇到一些麻烦：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">// NOTE: `&amp;'b data.0` and `'x: {` is not valid syntax!
struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}

impl&lt;F&gt; Closure&lt;F&gt;
    // where F: Fn(&amp;'??? (u8, u16)) -&gt; &amp;'??? u8,
{
    fn call&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a u8 {
        (self.func)(&amp;self.data)
    }
}

fn do_it&lt;'b&gt;(data: &amp;'b (u8, u16)) -&gt; &amp;'b u8 { &amp;'b data.0 }

fn main() {
    'x: {
        let clo = Closure { data: (0, 1), func: do_it };
        println!(&quot;{}&quot;, clo.call());
    }
}
</code></pre>
<p>我们究竟应该如何表达<code>F</code>的 trait 约束上的生命周期？我们需要在那里提供一些生命周期，但是我们关心的生命周期在进入<code>call</code>的主体之前是不能被命名的! 而且，这并不是什么固定的生命周期；<code>call</code>可以与<code>&amp;self</code>在这一时刻上的<em>任一</em>生命周期一起使用。</p>
<p>要完成这个事情，需要使用到高阶 Trait 约束（HRTB）的魔力。我们的解语法糖方式如下：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">where for&lt;'a&gt; F: Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,
</code></pre>
<p>或者：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">where F: for&lt;'a&gt; Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,
</code></pre>
<p>（其中<code>Fn(a, b, c) -&gt; d</code>本身只是不稳定的<em>真正的</em><code>*Fn</code>特性的语法糖）</p>
<p><code>for&lt;'a&gt;</code>可以理解为“对于所有<code>'a</code>的可能”，并且基本上产生一个<em>无限的</em> F 必须满足的 trait 约束的列表。不过不用紧张，在<code>Fn</code> trait 之外，我们遇到 HRTB 的地方不多，即使是那些地方，我们也有一个很好的魔法糖来处理普通的情况。</p>
<p>最终，我们可以把原本的代码重写成更加显式的样子：</p>
<pre><pre class="playground"><code class="language-rust">struct Closure&lt;F&gt; {
    data: (u8, u16),
    func: F,
}
impl&lt;F&gt; Closure&lt;F&gt;
    where for&lt;'a&gt; F: Fn(&amp;'a (u8, u16)) -&gt; &amp;'a u8,
{
    fn call(&amp;self) -&gt; &amp;u8 {
        (self.func)(&amp;self.data)
    }
}
fn do_it(data: &amp;(u8, u16)) -&gt; &amp;u8 { &amp;data.0 }
fn main() {
    let clo = Closure { data: (0, 1), func: do_it };
    println!(&quot;{}&quot;, clo.call());
}
</code></pre></pre>
<h1><a class="header" href="#子类型化和变异性" id="子类型化和变异性">子类型化和变异性</a></h1>
<p>Rust 使用生命周期来追踪借用和所有权。
但是，原生的生命周期实现可能过于严格，或者会允许未定义行为。</p>
<p>为了实现对生命周期的灵活使用并防止滥用，Rust 使用 <strong>子类型</strong> 和 <strong>变异</strong>。</p>
<p>让我们从一个例子开始。</p>
<pre><pre class="playground"><code class="language-rust">// 注意：debug 需要两个具有相同生命周期的参数
fn debug&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) {
    println!(&quot;a = {a:?} b = {b:?}&quot;);
}

fn main() {
    let hello: &amp;'static str = &quot;hello&quot;;
    {
        let world = String::from(&quot;world&quot;);
        let world = &amp;world; // 'world 的生命周期比 'static 短
        debug(hello, world);
    }
}
</code></pre></pre>
<p>在一个保守的生命周期实现中，由于 <code>hello</code> 和 <code>world</code> 有不同的生命周期，我们可能会看到以下错误：</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:10:16
   |
10 |         debug(hello, world);
   |                      ^
   |                      |
   |                      expected `&amp;'static str`, found struct `&amp;'world str`
</code></pre>
<p>这是相当不幸的。在这种情况下，我们希望接受的类型的生命周期至少要和 <code>'world</code> 一样长。
让我们尝试使用生命周期进行子类型化。</p>
<h2><a class="header" href="#子类型化" id="子类型化">子类型化</a></h2>
<p>子类型化是指一种类型可以替代另一种类型的概念。</p>
<p>我们定义 <code>Sub</code> 是 <code>Super</code> 的子类型（在本章中我们将其表示为 <code>Sub &lt;: Super</code>）。</p>
<p>这表示生命周期 <code>Sub</code> 的范围要包含 <code>Super</code> 的范围，并且 <code>Sub</code> 的范围有可能更大。</p>
<p>现在，为了使生命周期子类型化，我们需要先定义一个生命周期：</p>
<blockquote>
<p><code>'a</code> 定义了一段代码区域。</p>
</blockquote>
<p>然后我们就可以定义它们之间的关系：</p>
<blockquote>
<p>当且仅当 <code>'long</code> 是一个 <strong>完全包含</strong> <code>'short</code> 的代码区域时，<code>'long &lt;: 'short</code>。</p>
</blockquote>
<p><code>'long</code> 可能定义了一个比 <code>'short</code> 更大的区域，但这仍符合我们的定义。</p>
<blockquote>
<p>虽然在本章后面，子类型化比这要复杂和微妙得多，但这个简单的规则在大多数情况下都适用。除非您编写不安全的代码，否则编译器将为您自动处理所有的特殊情况。</p>
</blockquote>
<blockquote>
<p>但这是 Rustonomicon。我们正在编写不安全的代码，所以我们需要了解这些东西是如何真正工作的，以及我们如何搞乱它。</p>
</blockquote>
<p>回到我们上面的例子，我们可以说 <code>'static</code> 是 <code>'world</code> 的子类型，而又因为生命周期可以通过引用传递（更多内容请参见 <a href="subtyping.html#%E5%8F%98%E5%BC%82%E6%80%A7">变异性</a>），所以<code>&amp;'static str</code> 是 <code>&amp;'world str</code> 的子类型，通过下文讲述的 <em>变异性</em> 我们可以将 <code>&amp;'static str</code> 的生命周期收缩为 <code>&amp;'world str</code>。如此，上面的示例可以编译：</p>
<pre><pre class="playground"><code class="language-rust">fn debug&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) {
    println!(&quot;a = {a:?} b = {b:?}&quot;);
}

fn main() {
    let hello: &amp;'static str = &quot;hello&quot;;
    {
        let world = String::from(&quot;world&quot;);
        let world = &amp;world; // 'world 的生命周期比 'static 短
        debug(hello, world); // hello 从 `&amp;'static str` 静默收缩为 `&amp;'world str`
    }
}
</code></pre></pre>
<h2><a class="header" href="#变异性" id="变异性">变异性</a></h2>
<p>在上面，我们简单地说明了 <code>'static &lt;: 'b</code> 静默地暗示了 <code>&amp;'static T &lt;: &amp;'b T</code> 。这使用了一个名为 <em>变异</em> 的性质。然而，这并不总是像这个例子那样简单。为了理解这一点，让我们尝试稍微改变这个例子：</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597">fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}

fn main() {
    let mut hello: &amp;'static str = &quot;hello&quot;;
    {
        let world = String::from(&quot;world&quot;);
        assign(&amp;mut hello, &amp;world);
    }
    println!(&quot;{hello}&quot;); // 使用在被释放后的值 😿
}
</code></pre></pre>
<p>在 <code>assign</code> 中，我们将 <code>hello</code> 引用设置为指向 <code>world</code>。
但是 <code>world</code> 在 <code>println</code> 使用 <code>hello</code> 之前就已经超出了作用域！</p>
<p>这是一个典型的在释放后使用错误！</p>
<p>我们第一反应可能是怪 <code>assign</code> 的实现，但实际上这里并没有什么错误。一个值想要赋值到一个具有相同类型的 <code>T</code> 也不奇怪。</p>
<p>所以，问题在于，我们不能假设 <code>&amp;mut &amp;'static str</code> 也可以转换成 <code>&amp;mut &amp;'b str</code>。
这意味着，即使 <code>'static</code> 是 <code>'b</code> 的子类型，<code>&amp;mut &amp;'static str</code> 也 <strong>不能</strong> 是 <code>&amp;mut &amp;'b str</code> 的子类型。</p>
<p><strong>变异性</strong> 是 Rust 引用通过它们的泛型参数，来定义引用之间的子类型关系。</p>
<blockquote>
<p>注意：为了方便起见，我们将定义一个泛型类型 <code>F&lt;T&gt;</code>，以便我们可以方便地讨论 <code>T</code>。希望这在上下文中是清楚的。</p>
</blockquote>
<p>类型 <code>F</code> 的 <em>变异性</em> 代表了其输入子类型如何影响其输出子类型。</p>
<p>在 Rust 中有三种变异性，假设 <code>Sub</code> 是 <code>Super</code> 的子类型：</p>
<ul>
<li><code>F</code> 是 <strong>协变的</strong>，如果 <code>F&lt;Sub&gt;</code> 是 <code>F&lt;Super&gt;</code> 的子类型（子类型属性被传递）(译者注：这里被传递的意思是尖括号里面的子类型关系(<code>Sub &lt;: Super</code>)被传递到尖括号外(<code>F&lt;Sub&gt; &lt;: F&lt;Super&gt;</code>))</li>
<li><code>F</code> 是 <strong>逆变的</strong>，如果 <code>F&lt;Super&gt;</code> 是 <code>F&lt;Sub&gt;</code> 的子类型（子类型属性被 &quot;反转&quot;）(译者注：即尖括号里面的子类型关系(<code>Sub &lt;: Super</code>)在尖括号外面被反转(<code>F&lt;Super&gt; &lt;: F&lt;Sub&gt;</code>))</li>
<li>否则，<code>F</code> 是 <strong>不变的</strong> （不存在子类型关系）(译者注：即尖括号里面的子类型关系不会影响尖括号外面的子类型关系)</li>
</ul>
<p>让我们回想上面的例子，如果 <code>'a</code> 是 <code>'b</code> 的子类型，我们可以将 <code>&amp;'a T</code> 视作是 <code>&amp;'b T</code> 的子类型，因而<code>&amp;'a T</code>对于 <code>'a</code> 上是协变的。</p>
<p>此外，我们注意到不能将 <code>&amp;mut &amp;'a U</code> 视为 <code>&amp;mut &amp;'b U</code> 的子类型，因此我们可以说 <code>&amp;mut T</code> 在 <code>T</code> 上是 <em>不变的</em></p>
<p>以下是一些其他泛型类型的变异性的表格：</p>
<table><thead><tr><th></th><th align="center">'a</th><th align="center">T</th><th align="center">U</th></tr></thead><tbody>
<tr><td><code>&amp;'a T </code></td><td align="center">协变</td><td align="center">协变</td><td align="center"></td></tr>
<tr><td><code>&amp;'a mut T</code></td><td align="center">协变</td><td align="center">不变</td><td align="center"></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td align="center"></td><td align="center">协变</td><td align="center"></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td align="center"></td><td align="center">协变</td><td align="center"></td></tr>
<tr><td><code>UnsafeCell&lt;T&gt;</code></td><td align="center"></td><td align="center">不变</td><td align="center"></td></tr>
<tr><td><code>Cell&lt;T&gt;</code></td><td align="center"></td><td align="center">不变</td><td align="center"></td></tr>
<tr><td><code>fn(T) -&gt; U</code></td><td align="center"></td><td align="center"><strong>逆变</strong></td><td align="center">协变</td></tr>
<tr><td><code>*const T</code></td><td align="center"></td><td align="center">协变</td><td align="center"></td></tr>
<tr><td><code>*mut T</code></td><td align="center"></td><td align="center">不变</td><td align="center"></td></tr>
</tbody></table>
<p>其中，一些类型的变异性可以直接类比成其他类型。</p>
<ul>
<li><code>Vec&lt;T&gt;</code> 以及所有其他占有所有权的集合遵循与 <code>Box&lt;T&gt;</code> 相同的逻辑</li>
<li><code>Cell&lt;T&gt;</code> 以及所有其他内部可变性类型遵循与 <code>UnsafeCell&lt;T&gt;</code> 相同的逻辑</li>
<li>具有内部可变性的 <code>UnsafeCell&lt;T&gt;</code> 使其具有与 <code>&amp;mut T</code> 相同的变异性属性 (译者注：因为具有内部可变性的<code>UnsafeCell&lt;T&gt;</code> <code>Cell&lt;T&gt;</code>等，都可以通过仅仅使用 <code>&amp;T</code> 进行 <code>&amp;mut T</code> 才能进行的操作，所以它们必须和 <code>&amp;mut T</code> 一样是不变的)</li>
<li><code>*const T</code> 遵循 <code>&amp;T</code> 的逻辑</li>
<li><code>*mut T</code> 遵循 <code>&amp;mut T</code>（或 <code>UnsafeCell&lt;T&gt;</code>）的逻辑</li>
</ul>
<p>有关其他类型，请参见<a href="../reference/subtyping.html#variance">参考手册的 &quot;变异性&quot; 部分</a>。</p>
<blockquote>
<p>注意：语言中唯一的逆变来源于函数参数，这就是为什么它实际上在实践中很少出现。调用逆变涉及到函数指针的高阶编程，这些函数指针需要具有特定生命周期（而不是通常的 &quot;任意生命周期&quot;）的引用，而这将涉及更高级别的生命周期，它们可以独立于子类型化工作。</p>
</blockquote>
<p>现在我们对变异性有了更深入的理解，让我们更详细地讨论一些例子。</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0597">fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}

fn main() {
    let mut hello: &amp;'static str = &quot;hello&quot;;
    {
        let world = String::from(&quot;world&quot;);
        assign(&amp;mut hello, &amp;world);
    }
    println!(&quot;{hello}&quot;);
}
</code></pre></pre>
<p>运行这个例子会得到什么？</p>
<pre><code class="language-text">error[E0597]: `world` does not live long enough
  --&gt; src/main.rs:9:28
   |
6  |     let mut hello: &amp;'static str = &quot;hello&quot;;
   |                    ------------ type annotation requires that `world` is borrowed for `'static`
...
9  |         assign(&amp;mut hello, &amp;world);
   |                            ^^^^^^ borrowed value does not live long enough
10 |     }
   |     - `world` dropped here while still borrowed
</code></pre>
<p>很好，它不能编译！让我们详细了解这里发生了什么。</p>
<p>首先让我们看下 <code>assign</code> 函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn assign&lt;T&gt;(input: &amp;mut T, val: T) {
    *input = val;
}
<span class="boring">}
</span></code></pre></pre>
<p>它只是接收一个可变引用和一个值，然后将该值覆盖。这个函数的关键在于它在签名中清楚地说，被引用和值必须是 <em>完全相同</em> 的类型。</p>
<p>与此同时，在调用者中，我们传入 <code>&amp;mut &amp;'static str</code> 和 <code>&amp;'world str</code>。</p>
<p>由于 <code>&amp;mut T</code> 在 <code>T</code> 上是不变的，所以编译器得出结论，它不能对第一个参数应用任何子类型化，因此 <code>T</code> 必须是 <code>&amp;'static str</code>。</p>
<p>这与 <code>&amp;T</code> 情况相反：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug&lt;T: std::fmt::Debug&gt;(a: T, b: T) {
    println!(&quot;a = {a:?} b = {b:?}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>尽管 <code>a</code> 和 <code>b</code> 必须具有相同的类型 <code>T</code>，但由于 <code>&amp;'a T</code> 在 <code>'a</code> 上是协变的，我们可以执行子类型化。因此，编译器认为，当且仅当 <code>&amp;'static str</code> 是 <code>&amp;'b str</code> 的子类型时（这种关系在 <code>'static &lt;: 'b</code> 时成立），<code>&amp;'static str</code> 才可以变为 <code>&amp;'b str</code>。这是正确的，因此编译器很乐意继续编译这段代码。</p>
<p>事实证明，Box（以及 Vec，HashMap 等）协变的原因与生命周期协变的原因相似：只要你尝试将它们放入诸如可变引用之类的东西中，就会继承不变性，从而阻止你做任何坏事。</p>
<p>然而，Box 使我们更容易关注值传递的引用问题，我们之前部分忽略了这一点。</p>
<p>与许多允许值在任何时候被自由别名的语言不同，Rust 有一个非常严格的规则：如果您可以修改或移动一个值，那么您必须确保是唯一一个可以访问该值的人(译者注：即拥有该值的所有权)。</p>
<p>考虑以下代码：</p>
<pre><code class="language-rust ignore">let hello: Box&lt;&amp;'static str&gt; = Box::new(&quot;hello&quot;);

let mut world: Box&lt;&amp;'b str&gt;;
world = hello;
</code></pre>
<p>我们已经忘记了 <code>hello</code> 的 <code>'static</code> 生命周期也没有任何问题，因为当我们将 <code>hello</code> 移动到了一个只知道它的生命周期为 <code>'b</code> 的变量时，<strong>我们销毁了唯一记住它生命周期为<code>'static</code>的东西！我们不再需要 <code>hello</code> 的生命周期更长了！</strong></p>
<p>现在还剩一件事要解释：函数指针。</p>
<p>要了解为什么 <code>fn(T) -&gt; U</code> 应该在 <code>U</code> 上是协变的，请思考一下这个签名：</p>
<!-- ignore: 简化代码 -->
<pre><code class="language-rust ignore">fn get_str() -&gt; &amp;'a str;
</code></pre>
<p>该函数声明可以生成一个由某个生命周期 <code>'a</code> 绑定的 <code>str</code>。类似地，我们可以使用以下签名来定义一个函数：</p>
<!-- ignore: 简化代码 -->
<pre><code class="language-rust ignore">fn get_static() -&gt; &amp;'static str;
</code></pre>
<p>所以当函数被调用时，它只期望一个生命周期至少为 <code>'a</code> 的 <code>&amp;str</code> 的值，至于这个值的生命周期是不是比 <code>'a</code> 更长，并不重要。</p>
<p>然而，相同的逻辑不能应用于<em>函数参数</em>。思考一下：</p>
<!-- ignore: 简化代码 -->
<pre><code class="language-rust ignore">fn store_ref(&amp;'a str);
</code></pre>
<p>和</p>
<!-- ignore: 简化代码 -->
<pre><code class="language-rust ignore">fn store_static(&amp;'static str);
</code></pre>
<p>第一个函数可以接受任何字符串引用，只要它的生命周期包含 <code>'a</code>，但第二个函数不能接受一个生命周期小于 <code>'static</code> 的字符串引用，这将导致冲突。变异性不适用于此。但是，如果我们将其反过来，实际上<em>确实</em>行得通！如果我们需要一个可以处理 <code>&amp;'static str</code> 的函数，一个可以处理<em>任意</em>引用生命周期的函数肯定可以很好地工作。</p>
<p>让我们看看实践中的例子</p>
<pre><pre class="playground"><code class="language-rust compile_fail">thread_local! {
    pub static StaticVecs: RefCell&lt;Vec&lt;&amp;'static str&gt;&gt; = RefCell::new(Vec::new());
}

/// 将给定的输入保存到一个thread local的 `Vec&lt;&amp;'static str&gt;`
fn store(input: &amp;'static str) {
    StaticVecs.with_borrow_mut(|v| v.push(input));
}

/// 用有着相同生命周期的参数 `input` 去调用给定的函数
fn demo&lt;'a&gt;(input: &amp;'a str, f: fn(&amp;'a str)) {
    f(input);
}

fn main() {
    demo(&quot;hello&quot;, store); // &quot;hello&quot; 是 'static。可以正常调用 `store`

    {
        let smuggle = String::from(&quot;smuggle&quot;);

        // `&amp;smuggle` 的生命周期并非· `'static`。
        // 如果我们用 `&amp;smuggle` 调用 `store`，
        // 我们将把一个无效的生命周期推入 `StaticVecs`。
        // 因此，`fn(&amp;'static str)` 不能是 `fn(&amp;'a str)` 的子类型
        demo(&amp;smuggle, store);
    }

    // use after free 😿
    StaticVecs.with_borrow(|v| println!(&quot;{v:?}&quot;));
}
</code></pre></pre>
<p>这就是为什么函数类型，与语言中的其他内容不同，是<em>逆变</em>的。</p>
<p>现在，你对于标准库提供的类型的变异性应有了充分的理解，但是如何确定<em>您</em>定义的类型的变异性呢？ 不太规范地说，结构体继承了其字段的变异性。如果一个结构体 <code>MyType</code> 有一个泛型参数 <code>A</code>，并且在字段 <code>a</code> 中使用了 <code>A</code>，那么 MyType 对 <code>A</code> 的变异性与 <code>a</code> 对 <code>A</code> 的变异性完全相同。</p>
<p>然而，如果 <code>A</code> 被多个字段使用：</p>
<ul>
<li>如果 <code>A</code> 的所有用途都是协变的，则 MyType 在 <code>A</code> 上是协变的</li>
<li>如果 <code>A</code> 的所有用途都是逆变的，则 MyType 在 <code>A</code> 上是逆变的</li>
<li>否则，MyType 在 <code>A</code> 上是不变的</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

struct MyType&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed&gt; {
    a: &amp;'a A,     // 对 'a 和 A 是协变的
    b: &amp;'b mut B, // 对 'b 是协变的，对 B 是不变的

    c: *const C,  // 对 C 是协变的
    d: *mut D,    // 对 D 是不变的

    e: E,         // 对 E 是协变的
    f: Vec&lt;F&gt;,    // 对 F 是协变的
    g: Cell&lt;G&gt;,   // 对 G 是不变的

    h1: H,        // 本来也会对 H 是协变的，但...
    h2: Cell&lt;H&gt;,  // 对 H 是不变的，因为不变性在所有冲突中都是胜利者

    i: fn(In) -&gt; Out,       // 对 In 是逆变的，对 Out 是协变的

    k1: fn(Mixed) -&gt; usize, // 本来会对 Mixed 是逆变的，但...
    k2: Mixed,              // 对 Mixed 是不变的，因为不变性在所有冲突中都是胜利者
}
<span class="boring">}
</span></code></pre></pre>
<p>现在你对 Rust 中的子类型和变异性概念应该有了更深入的理解。尽管本章涵盖了许多概念，但通过编译器和类型系统所提供的严密检查来确保这些规则得到遵循和安全操作。当编写泛型代码时，要确保您正确理解子类型化和变异性，以避免出现意外错误和潜在安全问题。</p>
<h1><a class="header" href="#丢弃检查" id="丢弃检查">丢弃检查</a></h1>
<p>我们已经看到了生命周期如何为我们提供了一些相当简单的规则来确保我们永远不会读到悬空的引用。但是到目前为止， <em>outlives</em> 是一种包容的关系。也就是说，当我们谈论<code>'a: 'b</code>时，<code>'a</code>可以和<code>'b</code>的寿命一样长。乍一看，这似乎是一个无意义的特点。没有什么东西会和另一个东西同时被丢弃，对吗？这就是为什么我们对以下<code>let</code>语句解语法糖：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let x;
let y;
</code></pre>
<p>解语法糖：</p>
<!-- ignore: desugared code -->
<pre><code class="language-rust ignore">{
    let x;
    {
        let y;
    }
}
</code></pre>
<p>有一些更复杂的情况不可能用作用域来解语法糖，但顺序是被定义好的——变量按其定义的相反顺序丢弃，结构体和元组的字段按其定义的顺序丢弃。在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md">RFC 1857</a> 中有一些关于丢弃顺序的更多细节。</p>
<p>让我们来试试：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let tuple = (vec![], vec![]);
</code></pre>
<p>左边的 Vec 先被丢弃。但这是否意味着在借用检查器的眼中，右边 Vec 一定活得更长？这个问题的答案是 <em>No</em>。借用检查器可以分别跟踪元组的字段，但它仍然无法知道 哪个Vec 元素活得更久，因为 Vec 元素是通过借用检查器不理解的纯库代码手动丢弃的。</p>
<p>那么，我们为什么要关心呢？是因为如果类型系统不小心，它可能会意外地产生悬空指针。比如下面这个简单的程序：</p>
<pre><pre class="playground"><code class="language-rust">struct Inspector&lt;'a&gt;(&amp;'a u8);

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days));
}
</code></pre></pre>
<p>这个程序看起来很合理，而且可以编译。事实上，<code>days</code>的寿命并没有严格地超过<code>inspector</code>的寿命，这并不重要。只要<code>inspector</code>还活着，<code>days</code>也会活着。</p>
<p>然而，如果我们添加一个析构器，程序就不会再编译了!</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct Inspector&lt;'a&gt;(&amp;'a u8);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;I was only {} days from retirement!&quot;, self.0);
    }
}

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days));
    // 如果 `days` 碰巧在这里被析构了，然后 Inspector 才被析构，就会造成`内存释放后读取`的问题！
}
</code></pre></pre>
<pre><code class="language-text">error[E0597]: `world.days` does not live long enough
  --&gt; src/main.rs:19:38
   |
19 |     world.inspector = Some(Inspector(&amp;world.days));
   |                                      ^^^^^^^^^^^ borrowed value does not live long enough
...
22 | }
   | -
   | |
   | `world.days` dropped here while still borrowed
   | borrow might be used here, when `world` is dropped and runs the destructor for type `World&lt;'_&gt;`
</code></pre>
<p>你可以尝试改变字段的顺序，或者用一个元组来代替struct，但还是不能编译。</p>
<p>实现<code>Drop</code>可以让<code>Inspector</code>在被丢弃时执行一些代码。使得它有可能观察到那些本该和它生命周期一样长的类型实际上是先被销毁的。</p>
<p>有趣的是，只有泛型需要担心这个问题。如果它们不是泛型的，那么它们唯一能承载的寿命就是<code>'static</code>，它将真正地一直活着。这就是为什么这个问题被称为 <em>sound generic drop</em>。健壮的泛型丢弃是由 <em>drop checker</em> 强制执行的。截止到本文写作时，关于丢弃检查器（也被称为<code>dropck</code>）如何验证类型的一些更细微的细节还完全是未知数。然而，“大规则”是我们这一节所关注的微妙之处：</p>
<p><strong>对于一个泛型类型来说，要健壮地实现 drop，其泛型参数必须严格超过它的寿命。</strong></p>
<p>遵守这一规则（通常）是满足借用检查器的必要条件；遵守这一规则是健壮地泛型丢弃的充分不必要条件。即如果你的类型遵守了这个规则，那么它的 drop 肯定是健壮的。</p>
<p>不一定要满足上述规则的原因是，有些 Drop 实现不会访问借用的数据，即使他们的类型给了他们这种访问的能力，或者因为我们知道具体的 Drop 顺序，且借用的数据依旧完好，即使借用检查器不知道。</p>
<p>例如，上述<code>Inspector</code>例子的这个变体永远不会访问借来的数据：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}

struct World&lt;'a&gt; {
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, &quot;gadget&quot;));
    // 假设 `days` 刚好在这里析构了，
    // 并且假设析构函数可以确保：该函数确保不会访问对 `days` 的引用
}
</code></pre></pre>
<p>同样地，下面这个变体也不会访问借来的数据：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">struct Inspector&lt;T&gt;(T, &amp;'static str);

impl&lt;T&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}

struct World&lt;T&gt; {
    inspector: Option&lt;Inspector&lt;T&gt;&gt;,
    days: Box&lt;u8&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, &quot;gadget&quot;));
    // 假设 `days` 刚好在这里析构了，
    // 并且假设析构函数可以确保：该函数确保不会访问对 `days` 的引用
}
</code></pre></pre>
<p>然而，上述两种变体在分析<code>fn main</code>时都被借用检查器拒绝了，说<code>days</code>的生命周期不够长。</p>
<p>原因是对<code>main</code>的借用检查分析时，借用检查器并不了解每个<code>Inspector</code>的<code>Drop</code>实现的内部情况。就借用检查器在分析<code>main</code>时知道的情况来看，检查器的析构器主体可能会访问这些借用的数据。</p>
<p>因此，丢弃检查器强迫一个值中的所有借用数据的生命周期严格地超过该值的生命周期。</p>
<h2><a class="header" href="#一种逃逸方法" id="一种逃逸方法">一种逃逸方法</a></h2>
<p>丢弃检查的精确规则在未来可能会减少限制。</p>
<p>目前的分析是故意保守和琐碎的；它强制一个值中的所有借来的数据的生命周期超过该值的生命周期，这当然是合理的。</p>
<p>未来版本的语言可能会使分析更加精确，以减少正确代码被拒绝为不安全的情况。这将有助于解决诸如上述两个<code>Inspector</code>知道在销毁时不访问借来的数据的情况。</p>
<p>但与此同时，有一个不稳定的属性，可以用来断言（不安全的）泛型的析构器 <em>保证</em> 不访问任何失效数据，即使它的类型赋予它这样的能力。</p>
<p>这个属性被称为<code>may_dangle</code>，是在<a href="https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md">RFC1327</a>中引入的。要在上面的<code>Inspector</code>上用上它，我们可以这么写：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(dropck_eyepatch)]

struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);

unsafe impl&lt;#[may_dangle] 'a&gt; Drop for Inspector&lt;'a&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);
    }
}

struct World&lt;'a&gt; {
    days: Box&lt;u8&gt;,
    inspector: Option&lt;Inspector&lt;'a&gt;&gt;,
}

fn main() {
    let mut world = World {
        inspector: None,
        days: Box::new(1),
    };
    world.inspector = Some(Inspector(&amp;world.days, &quot;gadget&quot;));
}
</code></pre></pre>
<p>使用这个属性需要将<code>Drop</code>标记为<code>unsafe</code>，因为编译器没有检查隐含的断言，即没有访问潜在的失效数据（例如上面的<code>self.0</code>）。</p>
<p>该属性可以应用于任何数量的生命周期和类型参数。在下面的例子中，我们断言我们没有访问寿命为<code>'b</code>的引用后面的数据，并且<code>T</code>的唯一用途是 move 或 drop，但是从<code>'a</code>和<code>U</code>中省略了该属性，因为我们确实访问具有该生命周期和该类型的数据。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(dropck_eyepatch)]
<span class="boring">fn main() {
</span>use std::fmt::Display;

struct Inspector&lt;'a, 'b, T, U: Display&gt;(&amp;'a u8, &amp;'b u8, T, U);

unsafe impl&lt;'a, #[may_dangle] 'b, #[may_dangle] T, U: Display&gt; Drop for Inspector&lt;'a, 'b, T, U&gt; {
    fn drop(&amp;mut self) {
        println!(&quot;Inspector({}, _, _, {})&quot;, self.0, self.3);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>有时很明显，不可能发生这样的访问，比如上面的情况。然而，当处理一个通用类型的参数时，这种访问可能会间接地发生，这种间接访问的例子是：</p>
<ul>
<li>调用一个回调</li>
<li>通过 trait 方法调用</li>
</ul>
<p>（未来对语言的修改，如 impl 的特化，可能会增加这种间接访问的其他途径。）</p>
<p>下面是一个回调的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Inspector&lt;T&gt;(T, &amp;'static str, Box&lt;for &lt;'r&gt; fn(&amp;'r T) -&gt; String&gt;);

impl&lt;T&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // 如果 `T` 是 `&amp;'a _` 这种类型，那么 self.2 有可能访问了被引用的变量
        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,
                 (self.2)(&amp;self.0), self.1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>下面是一个通过 trait 方法调用的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);

impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {
    fn drop(&amp;mut self) {
        // 这里可能隐藏了一个对于 `&lt;T as Display&gt;::fmt` 的调用,
        // 如果 `T` 是 `&amp;'a _` 这种类型，就可能访问了借用的变量
        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,
                 self.0, self.1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当然，所有这些访问都可以进一步隐藏在由析构器调用的一些其他方法中，而不是直接写在析构器中。</p>
<p>在上述所有在析构器中访问<code>&amp;'a u8</code>的情况下，添加<code>#[may_dangle]</code>属性使得该类型容易被误用，而借用检查器不会发现，从而导致问题。所以最好不要添加这个属性。</p>
<h2><a class="header" href="#关于丢弃顺序的附带说明" id="关于丢弃顺序的附带说明">关于丢弃顺序的附带说明</a></h2>
<p>虽然结构内部字段的删除顺序是被定义的，但对它的依赖是脆弱而微妙的。当顺序很重要时，最好使用<a href="https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html"><code>ManuallyDrop</code></a>包装器。</p>
<h2><a class="header" href="#这就是关于丢弃检查器的全部内容吗" id="这就是关于丢弃检查器的全部内容吗">这就是关于丢弃检查器的全部内容吗？</a></h2>
<p>事实证明，在编写不安全的代码时，我们通常根本不需要担心为丢弃检查器做正确的事情。然而，有一种特殊情况是需要担心的，我们将在下一节看一下。</p>
<h1><a class="header" href="#幽灵数据" id="幽灵数据">幽灵数据</a></h1>
<p>在处理不安全代码时，我们经常会遇到这样的情况：类型或生命周期在逻辑上与结构相关，但实际上并不是字段的一部分。这种情况最常发生在生命周期上。例如，<code>&amp;'a [T]</code>的<code>Iter</code>（大约）定义如下：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
}
<span class="boring">}
</span></code></pre></pre>
<p>但是由于<code>'a</code>在结构体中是未使用的，所以它是<em>无约束</em>的。<a href="https://rust-lang.github.io/rfcs/0738-variance.html#the-corner-case-unused-parameters-and-parameters-that-are-only-used-unsafely">由于这在历史上造成的麻烦</a>，在结构定义中，不受约束的生命周期和类型是<em>禁止</em>的，因此我们必须在主体中以某种方式引用这些类型，正确地做到这一点对于正确的变异性和丢弃检查是必要的。</p>
<p>我们使用<code>PhantomData</code>来做这个，它是一个特殊的标记类型。<code>PhantomData</code>不消耗空间，但为了静态分析的目的，模拟了一个给定类型的字段。这被认为比明确告诉类型系统你想要的变量类型更不容易出错，同时也提供了其他有用的东西，例如 auto traits 和 drop check 需要的信息。</p>
<p>Iter 逻辑上包含一堆<code>&amp;'a T</code>，所以这正是我们告诉<code>PhantomData</code>要模拟的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Iter&lt;'a, T: 'a&gt; {
    ptr: *const T,
    end: *const T,
    _marker: marker::PhantomData&lt;&amp;'a T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>就是这样，生命周期将被限定，而你的迭代器将在<code>'a</code>和<code>T</code>上进行协变。所有的东西都是有效的。</p>
<h1><a class="header" href="#泛型参数和-drop-检查" id="泛型参数和-drop-检查">泛型参数和 drop 检查</a></h1>
<p>在过去，曾经有另一个事情是需要仔细思考的，这篇文档曾经这么说：</p>
<blockquote>
<p>另一个重要的例子是 Vec，它（大约）定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec&lt;T&gt; {
    data: *const T, // `*const`是可变异的！
    len: usize,
    cap: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>与前面的例子不同的是，<em>看起来</em>一切都和我们想的一样。Vec 的每个通用参数至少在一个字段中出现。很好，可以开始了!</p>
<p>不对，不是这样。</p>
<p>丢弃检查器将慷慨地确定<code>Vec&lt;T&gt;</code>不拥有任何 T 类型的值。这将反过来使它得出结论，它不需要担心 Vec 在其析构器中丢弃任何 T 来确定丢弃检查的合理性。这将反过来允许人们使用 Vec 的析构器来制造不健壮性。</p>
<p>为了告诉 dropck 我们确实拥有 T 类型的值，因此在<em>我们</em>丢弃时可能会丢弃一些 T，我们必须添加一个额外的<code>PhantomData</code>，正如这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // `*const`是可变异的！
    len: usize,
    cap: usize,
    _marker: marker::PhantomData&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>但自从<a href="https://rust-lang.github.io/rfcs/1238-nonparametric-dropck.html">RFC 1238</a>之后，这就不正确也并不需要了。</p>
<p>如果你这么写：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vec&lt;T&gt; {
    data: *const T, // `*const`是可变异的！
    len: usize,
    cap: usize,
}
<span class="boring">#[cfg(any())]
</span>impl&lt;T&gt; Drop for Vec&lt;T&gt; { /* … */ }
<span class="boring">}
</span></code></pre></pre>
<p>那么<code>impl&lt;T&gt; Drop for Vec&lt;T&gt;</code>这条语句会让 Rust 知道<code>Vec&lt;T&gt;</code><em>拥有</em><code>T</code>类型的值（更准确地说：可能会在<code>Drop</code>实现中使用<code>T</code>类型的值），那么当<code>Vec&lt;T&gt;</code>被 drop 的时候，Rust 就不会允许它们 <em>悬垂</em>。</p>
<p>当一个类型已经有了 <code>Drop impl</code> 时，<strong>添加一个额外的 <code>_owns_T: PhantomData&lt;T&gt;</code> 字段是多余的，而且没有任何效果</strong>，从 dropck（Drop 检查）的角度来看（它仍然会影响变量和自动特征）。</p>
<ul>
<li>（高级边缘情况：如果包含 <code>PhantomData</code> 的类型根本没有 <code>Drop</code> 实现，但仍然有 drop glue（通过拥有另一个带有 drop glue 的字段），那么这里提到的 dropck/<code>#[may_dangle]</code> 规则也同样适用：一个 <code>PhantomData&lt;T&gt;</code> 字段将要求 <code>T</code> 在包含类型作用域结束时可被丢弃）。</li>
</ul>
<hr />
<p>但是这在某些场景下，会导致过于严格，这也是为啥标准库使用了一个不稳定并且<code>unsafe</code>的属性来切换回旧的<code>unchecked</code>的 drop 检查行为，也是接下来这个文档所警告的：<code>#[may_dangle]</code>属性。</p>
<h3><a class="header" href="#一个例外标准库的特殊情况及不稳定的may_dangle" id="一个例外标准库的特殊情况及不稳定的may_dangle">一个例外：标准库的特殊情况及不稳定的<code>#[may_dangle]</code></a></h3>
<p>如果你只是写自己的库代码，那你可以跳过这章；但是如果你想知道标准库中真正的<code>Vec</code>是怎么实现的，你会发现它仍然需要<code>_owns_T: PhantomData&lt;T&gt;</code>字段来保证可靠性。</p>
<details><summary>点这里查看原因</summary>
<p>思考以下这个例子：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v: Vec&lt;&amp;str&gt; = Vec::new();
    let s: String = &quot;Short-lived&quot;.into();
    v.push(&amp;s);
    drop(s);
} // &lt;- `v`在这里被 drop 了
</code></pre></pre>
<p>对于一个经典的<code>impl&lt;T&gt; Drop for Vec&lt;T&gt; {</code>定义，上面这段代码<a href="https://rust.godbolt.org/z/ans15Kqz3">会被编译器拒绝</a>。</p>
<p>实际上，在这个例子中，我们的<code>Vec</code>的类型实际上是<code>Vec&lt;/* T = */ &amp;'s str&gt;</code>，是一个元素为<code>'s</code>生命周期的<code>str</code>ing 的 <code>Vec</code>，但是由于上面还有一行定义<code>let s: String</code>，它在<code>Vec</code> drop 之前就被 drop 了，所以在<code>Vec</code>被 drop 的时候，<code>'s</code>已经不再有效了，这时候<code>Drop</code>的实际签名为：<code>impl&lt;'s&gt; Drop for Vec&lt;&amp;'s str&gt; {</code>。</p>
<p>这意味着，<code>Drop</code>被调用时，它将会面对一个无效的，或者说悬垂（dangling）的生命周期<code>'s</code>。这是违背了 Rust 原则的，Rust 原则要求所有的函数中的 Rust 引用都必须有效，解引用操作必须是合法的。</p>
<p>这也是为什么 Rust 会保守地拒绝这段代码。</p>
<p>然而，在真正的<code>Vec</code>中，<code>Drop</code>的实现并不关心<code>&amp;'s str</code>，毕竟它（译者注：<code>&amp;'s str</code>）没有自己的<code>Drop</code>实现（<em>since it has no drop glue of its own</em>），它想做的只是把它自己的 buffer 给释放掉。</p>
<p>换句话说，如果上述这个片段能被 Rust 接受那就再好不过了，我们通过封装<code>Vec</code>，或者说可以依赖于<code>Vec</code>一些特殊的属性：<code>Vec</code>可以承诺当它被 drop 时不会使用它拥有的<code>&amp;'s str</code>。</p>
<p>这是一种<code>unsafe</code>的承诺，可以通过<code>#[may_dangle]</code>来表达：</p>
<pre><code class="language-rust ignore">unsafe impl&lt;#[may_dangle] 's&gt; Drop for Vec&lt;&amp;'s str&gt; { /* … */ }
</code></pre>
<p>或者，更通用化的：</p>
<pre><code class="language-rust ignore">unsafe impl&lt;#[may_dangle] T&gt; Drop for Vec&lt;T&gt; { /* … */ }
</code></pre>
<p>这就是一个<code>unsafe</code>的方法用来摆脱 Rust drop 检查器这个保守的假设——一个 drop 的实例的类型参数不允许是悬垂的。</p>
<p>并且当这样做时，例如在标准库中，我们需要小心<code>T</code>有自己的<code>Drop</code>实现。比如，在这种情况下，想象用<code>struct PrintOnDrop&lt;'s&gt; /* = */ (&amp;'s str);</code>替换<code>&amp;'s str</code>，这将具有<code>Drop</code> impl，其内部的<code>&amp;'s str</code>将被解引用并打印到屏幕上。</p>
<p>实际上，<code>Drop for Vec&lt;T&gt; {</code>，在释放自己的 Buffer 之前，确实必须在每个<code>T</code>类型的元素具有自定义<code>Drop</code>实现时递归地删除它；在 <code>PrintOnDrop&lt;'s&gt;</code>的情况下，这意味着<code>Vec&lt;PrintOnDrop&lt;'s&gt;&gt;</code>的<code>Drop</code>必须在释放 Buffer 之前递归地删除<code>PrintOnDrop&lt;'s&gt;</code>的元素。</p>
<p>所以当我们说<code>'s</code> <code>#[may_dangle]</code> 时，这是一个过于宽松的说法。我们更期望这么说说：“<code>'s</code>可能会悬垂，前提是它不涉及一些<code>Drop</code>自定义实现”。或者，更一般地说，“<code>T</code>可能会悬空，前提是它不涉及某些<code>Drop</code>自定义实现”。每当**我们拥有一个<code>T</code>**时，这种“例外的例外”是一种普遍的情况。这就是为什么 Rust 的<code>#[may_dangle]</code>足够聪明，<em>当泛型参数以拥有的方式</em> 被 struct 的某个字段所保存时，会被禁用。（原文：That's why Rust's <code>#[may_dangle]</code> is smart enough to know of this opt-out, and will thus be disabled <em>when the generic parameter is held
in an owned fashion</em> by the fields of the struct.）</p>
<p>这就是为什么最终标准库是这么写的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(any())]
</span>// 我们拉勾说好，当 drop `Vec`的时候不去用`T`
unsafe impl&lt;#[may_dangle] T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            if mem::needs_drop::&lt;T&gt;() {
                /* … 除了这里，也就是说，… */
                ptr::drop_in_place::&lt;[T]&gt;(/* … */);
            }
            // …
            dealloc(/* … */)
            // …
        }
    }
}

struct Vec&lt;T&gt; {
    // … 除非事实上`Vec`拥有了`T`类型的元素，并且可能在 drop 时 drop 它们
    _owns_T: core::marker::PhantomData&lt;T&gt;,
    ptr: *const T, // `*const`是可变异的（但这本身并不能表达对`T`的所有权）
    len: usize,
    cap: usize,
}
<span class="boring">}
</span></code></pre></pre>
</details>
<hr />
<p>拥有内存分配的原始指针是如此普遍的模式，以至于标准库为自己整了一个名为<code>Unique&lt;T&gt;</code>的类型：</p>
<ul>
<li>包装一个<code>*const T</code>，用于变异</li>
<li>包括一个<code>PhantomData&lt;T&gt;</code></li>
<li>根据包含的 T 自动派生<code>Send</code>/<code>Sync</code></li>
<li>空指针的优化，将指针标记为<code>NonZero</code></li>
</ul>
<h2><a class="header" href="#phantomdata模式表" id="phantomdata模式表"><code>PhantomData</code>模式表</a></h2>
<p>下面是一个关于所有可以使用<code>PhantomData</code>的神奇方式的表格：
(covariant:协变，invariant:不变，contravariant:逆变)</p>
<table><thead><tr><th>Phantom type</th><th align="center">variance of <code>'a</code></th><th align="center">variance of <code>T</code></th><th align="center"><code>Send</code>/<code>Sync</code><br/>(or lack thereof)</th><th align="center">dangling <code>'a</code> or <code>T</code> in drop glue<br/>(<em>e.g.</em>, <code>#[may_dangle] Drop</code>)</th></tr></thead><tbody>
<tr><td><code>PhantomData&lt;T&gt;</code></td><td align="center">-</td><td align="center"><strong>cov</strong>ariant</td><td align="center">inherited</td><td align="center">disallowed (&quot;owns <code>T</code>&quot;)</td></tr>
<tr><td><code>PhantomData&lt;&amp;'a T&gt;</code></td><td align="center"><strong>cov</strong>ariant</td><td align="center"><strong>cov</strong>ariant</td><td align="center"><code>Send + Sync</code><br/>requires<br/><code>T : Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;&amp;'a mut T&gt;</code></td><td align="center"><strong>cov</strong>ariant</td><td align="center"><strong>inv</strong>ariant</td><td align="center">inherited</td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;*const T&gt;</code></td><td align="center">-</td><td align="center"><strong>cov</strong>ariant</td><td align="center"><code>!Send + !Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;*mut T&gt;</code></td><td align="center">-</td><td align="center"><strong>inv</strong>ariant</td><td align="center"><code>!Send + !Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;fn(T)&gt;</code></td><td align="center">-</td><td align="center"><strong>contra</strong>variant</td><td align="center"><code>Send + Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;fn() -&gt; T&gt;</code></td><td align="center">-</td><td align="center"><strong>cov</strong>ariant</td><td align="center"><code>Send + Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;fn(T) -&gt; T&gt;</code></td><td align="center">-</td><td align="center"><strong>inv</strong>ariant</td><td align="center"><code>Send + Sync</code></td><td align="center">allowed</td></tr>
<tr><td><code>PhantomData&lt;Cell&lt;&amp;'a ()&gt;&gt;</code></td><td align="center"><strong>inv</strong>ariant</td><td align="center">-</td><td align="center"><code>Send + !Sync</code></td><td align="center">allowed</td></tr>
</tbody></table>
<ul>
<li>注意: opt-out Unpin 自动特性需要专用的 <a href="https://doc.rust-lang.org/std/marker/struct.PhantomPinned.html"><code>PhantomPinned</code></a> 类型。</li>
</ul>
<h1><a class="header" href="#拆分-borrows" id="拆分-borrows">拆分 Borrows</a></h1>
<p>在处理复合结构时，可变引用的互斥属性会有很大的限制。借用检查器理解一些基本的东西，但是很容易就会出现问题。它对结构有足够的了解，知道有可能同时借用一个结构中不相干的字段。所以现在这个方法是可行的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: i32,
    b: i32,
    c: i32,
}

let mut x = Foo {a: 0, b: 0, c: 0};
let a = &amp;mut x.a;
let b = &amp;mut x.b;
let c = &amp;x.c;
*b += 1;
let c2 = &amp;x.c;
*a += 10;
println!(&quot;{} {} {} {}&quot;, a, b, c, c2);
<span class="boring">}
</span></code></pre></pre>
<p>然而 borrowck 完全不理解数组或 slice，所以这会挂：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = [1, 2, 3];
let a = &amp;mut x[0];
let b = &amp;mut x[1];
println!(&quot;{} {}&quot;, a, b);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">error[E0499]: cannot borrow `x[..]` as mutable more than once at a time
 --&gt; src/lib.rs:4:18
  |
3 |     let a = &amp;mut x[0];
  |                  ---- first mutable borrow occurs here
4 |     let b = &amp;mut x[1];
  |                  ^^^^ second mutable borrow occurs here
5 |     println!(&quot;{} {}&quot;, a, b);
6 | }
  | - first borrow ends here

error: aborting due to previous error
</code></pre>
<p>虽然 borrowck 能理解这个简单的案例是合理的，但对于 borrowck 来说，要理解像树这样的一般容器类型的不连通性显然是没有希望的，尤其是当不同的键<em>确实</em>映射到相同的值时。</p>
<p>为了“教导” borrowck 我们正在做的事情是正确的，我们需要使用到不安全的代码。例如，可变 slice 暴露了一个<code>split_at_mut</code>函数，它消耗这个 slice 并返回两个可变 slice。一个用于索引左边的所有内容，一个用于右边的所有内容。直观地讲，我们知道这是安全的，因为这些分片不会重叠，因此可以进行别名操作。然而，这个实现需要一些不安全代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::slice::from_raw_parts_mut;
</span><span class="boring">struct FakeSlice&lt;T&gt;(T);
</span><span class="boring">impl&lt;T&gt; FakeSlice&lt;T&gt; {
</span><span class="boring">fn len(&amp;self) -&gt; usize { unimplemented!() }
</span><span class="boring">fn as_mut_ptr(&amp;mut self) -&gt; *mut T { unimplemented!() }
</span>pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
    let len = self.len();
    let ptr = self.as_mut_ptr();

    unsafe {
        assert!(mid &lt;= len);

        (from_raw_parts_mut(ptr, mid),
         from_raw_parts_mut(ptr.add(mid), len - mid))
    }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>这实际上是有点微妙的。为了避免对同一个值进行两次<code>&amp;mut</code>，我们明确地通过原始指针构造全新的切片。</p>
<p>然而，更微妙的是产生可变引用的迭代器如何工作。迭代器 trait 定义如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>考虑到这个定义，Self::Item 与<code>self</code><em>没有</em>联系。这意味着我们可以连续多次调用<code>next</code>，并将所有的结果<em>并发地</em>保留下来。这对逐值迭代器来说是非常好的，因为它有这样的语义。这对共享引用来说也很好，因为它们允许对同一事物有任意多的引用（尽管迭代器需要和被共享的事物是一个独立的对象）。</p>
<p>但是可变的引用让这变得一团糟。乍一看，它们似乎与这个 API 完全不兼容，因为它将产生对同一个对象的多个可变引用！</p>
<p>然而它实际上<em>是</em>有效的，正是因为迭代器是一次性的对象。IterMut 产生的所有东西最多只能产生一次，所以我们实际上不会产生对同一块数据的多个可变引用。</p>
<p>也许令人惊讶的是，对于许多类型，可变迭代器不需要实现不安全的代码。</p>
<p>例如，这里有一个单向链表：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

pub struct LinkedList&lt;T&gt; {
    head: Link&lt;T&gt;,
}

pub struct IterMut&lt;'a, T: 'a&gt;(Option&lt;&amp;'a mut Node&lt;T&gt;&gt;);

impl&lt;T&gt; LinkedList&lt;T&gt; {
    fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut(self.head.as_mut().map(|node| &amp;mut **node))
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.take().map(|node| {
            self.0 = node.next.as_mut().map(|node| &amp;mut **node);
            &amp;mut node.elem
        })
    }
}
</code></pre></pre>
<p>下面是一个可变的 slice：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::mem;

pub struct IterMut&lt;'a, T: 'a&gt;(&amp;'a mut[T]);

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::take(&amp;mut self.0);
        if slice.is_empty() { return None; }

        let (l, r) = slice.split_at_mut(1);
        self.0 = r;
        l.get_mut(0)
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let slice = mem::take(&amp;mut self.0);
        if slice.is_empty() { return None; }

        let new_len = slice.len() - 1;
        let (l, r) = slice.split_at_mut(new_len);
        self.0 = l;
        r.get_mut(0)
    }
}
</code></pre></pre>
<p>接着是一个二叉树：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::collections::VecDeque;

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    left: Link&lt;T&gt;,
    right: Link&lt;T&gt;,
}

pub struct Tree&lt;T&gt; {
    root: Link&lt;T&gt;,
}

struct NodeIterMut&lt;'a, T: 'a&gt; {
    elem: Option&lt;&amp;'a mut T&gt;,
    left: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
    right: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

enum State&lt;'a, T: 'a&gt; {
    Elem(&amp;'a mut T),
    Node(&amp;'a mut Node&lt;T&gt;),
}

pub struct IterMut&lt;'a, T: 'a&gt;(VecDeque&lt;NodeIterMut&lt;'a, T&gt;&gt;);

impl&lt;T&gt; Tree&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        let mut deque = VecDeque::new();
        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));
        IterMut(deque)
    }
}

impl&lt;T&gt; Node&lt;T&gt; {
    pub fn iter_mut(&amp;mut self) -&gt; NodeIterMut&lt;T&gt; {
        NodeIterMut {
            elem: Some(&amp;mut self.elem),
            left: self.left.as_mut().map(|node| &amp;mut **node),
            right: self.right.as_mut().map(|node| &amp;mut **node),
        }
    }
}


impl&lt;'a, T&gt; Iterator for NodeIterMut&lt;'a, T&gt; {
    type Item = State&lt;'a, T&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.left.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.right.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for NodeIterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.right.take() {
            Some(node) =&gt; Some(State::Node(node)),
            None =&gt; match self.elem.take() {
                Some(elem) =&gt; Some(State::Elem(elem)),
                None =&gt; match self.left.take() {
                    Some(node) =&gt; Some(State::Node(node)),
                    None =&gt; None,
                }
            }
        }
    }
}

impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.front_mut().and_then(|node_it| node_it.next()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_front(node.iter_mut()),
                None =&gt; if let None = self.0.pop_front() { return None },
            }
        }
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        loop {
            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {
                Some(State::Elem(elem)) =&gt; return Some(elem),
                Some(State::Node(node)) =&gt; self.0.push_back(node.iter_mut()),
                None =&gt; if let None = self.0.pop_back() { return None },
            }
        }
    }
}
</code></pre></pre>
<p>所有这些都是完全安全的，并且可以在稳定的 Rust 上运行！这最终落在了我们之前看到的简单结构案例中。Rust 知道你可以安全地将一个可变的引用分割成子字段。然后我们可以通过 Options（或者在分片的情况下，用空分片替换）来消耗掉这个引用并进行编码。</p>
<h1><a class="header" href="#类型转换" id="类型转换">类型转换</a></h1>
<p>说到底，一切都只是某处的一堆比特，而类型系统只是为了帮助我们正确使用这些比特。类型系统中有两个常见的问题：需要将这些确切的位重新解释为不同的类型，以及需要改变位以对不同的类型具有同等的意义。因为 Rust 鼓励在类型系统中对重要的属性进行编码，所以这些问题是非常普遍的。因此，Rust 给了你几种方法来解决它们。</p>
<p>首先，我们将看看 Safe Rust 给你提供的重新解释值的方法。最简单的方法是把一个值分解成它的组成部分，然后从它们中建立一个新的类型：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -&gt; Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
<span class="boring">}
</span></code></pre></pre>
<p>但这最好也不过是一种烦人的做法。对于常见的转换，Rust 提供了更符合人体工程学的替代方法。</p>
<h1><a class="header" href="#强转" id="强转">强转</a></h1>
<p>在某些情况下，类型可以隐式地被强转。这些变化通常只是<em>削弱</em>类型，主要集中在指针和生命周期方面。它们的存在主要是为了让 Rust 在更多的情况下“正常工作”，而且基本上是无害的。</p>
<p>关于所有强转类型的详尽列表，请参见《The Reference》中的<a href="https://doc.rust-lang.org/reference/type-coercions.html#coercion-types">Coercion types</a>部分。</p>
<p>请注意，在匹配 Trait 时，我们不进行强制转换（除了接收者，见<a href="./dot-operator.html">下一页</a>）。如果某个类型<code>U</code>有一个<code>impl</code>，而<code>T</code>可以强转到<code>U</code>，这并不构成<code>T</code>的实现。例如，下面的内容不会通过类型检查，尽管将<code>t</code>强转到<code>&amp;T</code>是可以的，并且有针对<code>&amp;T</code>的<code>impl</code>。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">trait Trait {}

fn foo&lt;X: Trait&gt;(t: X) {}

impl&lt;'a&gt; Trait for &amp;'a i32 {}

fn main() {
    let t: &amp;mut i32 = &amp;mut 0;
    foo(t);
}
</code></pre></pre>
<p>这样编译失败：</p>
<pre><code class="language-text">error[E0277]: the trait bound `&amp;mut i32: Trait` is not satisfied
 --&gt; src/main.rs:9:9
  |
3 | fn foo&lt;X: Trait&gt;(t: X) {}
  |           ----- required by this bound in `foo`
...
9 |     foo(t);
  |         ^ the trait `Trait` is not implemented for `&amp;mut i32`
  |
  = help: the following implementations were found:
            &lt;&amp;'a i32 as Trait&gt;
  = note: `Trait` is implemented for `&amp;i32`, but not for `&amp;mut i32`
</code></pre>
<h1><a class="header" href="#点运算符" id="点运算符">点运算符</a></h1>
<p>点运算符将执行很多类型转换的魔法：它将执行自动引用、自动去引用和强制转换，直到类型匹配。方法查找的详细机制定义在<a href="https://rustc-dev-guide.rust-lang.org/method-lookup.html">这里</a>，简要的概述如下：</p>
<p>假设我们有一个函数<code>foo</code>，它有一个接收器（一个<code>self</code>、<code>&amp;self</code>或<code>&amp;mut self</code>参数）。如果我们调用<code>value.foo()</code>，编译器需要确定<code>Self</code>是什么类型，然后才能调用该函数的正确实现。在这个例子中，我们将说<code>value</code>具有<code>T</code>类型。</p>
<p>我们将使用<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">full-qualified syntax</a>来更清楚地说明我们到底是在哪个类型上调用一个函数。</p>
<ul>
<li>首先，编译器会检查是否可以直接调用<code>T::foo(value)</code>。这被称为“按值”方法调用。</li>
<li>如果它不能调用这个函数（例如，如果这个函数的类型不对，或者一个 trait 没有为<code>Self</code>实现），那么编译器就会尝试添加一个自动引用。这意味着编译器会尝试<code>&lt;&amp;T&gt;::foo(value)</code>和<code>&lt;&amp;mut T&gt;::foo(value)</code>。这被称为“autoref”方法调用。</li>
<li>如果这些候选方法都不奏效，它就对<code>T</code>解引用并再次尝试。这使用了<code>Deref</code>特性——如果<code>T: Deref&lt;Target = U&gt;</code>，那么它就用<code>U</code>而不是<code>T</code>类型再试。如果它不能解除对<code>T</code>的引用，它也可以尝试 <em>unsizing</em><code>T</code>。这只是意味着，如果<code>T</code>在编译时有一个已知的大小参数，那么在解析方法时它就会“忘记”它。例如，这个 unsizing 步骤可以通过“忘记”数组的大小将<code>[i32; 2]</code>转换成<code>[i32]</code>。</li>
</ul>
<p>下面是一个方法查找算法的例子：</p>
<pre><code class="language-rust ignore">let array: Rc&lt;Box&lt;[T; 3]&gt;&gt; = ...;
let first_entry = array[0];
</code></pre>
<p>当数组在这么多的间接点后面时，编译器是如何实际计算<code>array[0]</code>的呢？首先，<code>array[0]</code>实际上只是<a href="https://doc.rust-lang.org/std/ops/trait.Index.html"><code>Index</code></a>特性的语法糖——编译器会将<code>array[0]</code>转换成<code>array.index(0)</code>。现在，编译器检查<code>array</code>是否实现了<code>Index</code>，这样它就可以调用这个函数。</p>
<p>然后，编译器检查<code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>是否实现了<code>Index</code>，但它没有，<code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>和<code>&amp;mut Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>也没有。由于这些方法都不起作用，编译器将<code>Rc&lt;Box&lt;[T; 3]&gt;</code>解引用到<code>Box&lt;[T; 3]&gt;</code>中，并再次尝试。<code>Box&lt;[T; 3]&gt;</code>、<code>&amp;Box&lt;[T; 3]&gt;</code>和<code>&amp;mut Box&lt;[T; 3]&gt;</code>没有实现<code>Index</code>，所以它再次解引用。<code>[T; 3]</code>和它的自动引用也没有实现<code>Index</code>。它不能再继续解引用<code>[T; 3]</code>，所以编译器取消了它的大小，得到了<code>[T]</code>。最后，<code>[T]</code>实现了<code>Index</code>，所以它现在可以调用实际的<code>index</code>函数。</p>
<p>考虑一下下面这个更复杂的点运算符工作的例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_stuff&lt;T: Clone&gt;(value: &amp;T) {
    let cloned = value.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p>实现了<code>Clone</code>的是什么类型？首先，编译器检查是否可以按值调用。<code>value</code>的类型是<code>&amp;T</code>，所以<code>clone</code>函数的签名是<code>fn clone(&amp;T) -&gt; T</code>。它知道<code>T: Clone</code>，所以编译器发现<code>cloned: T</code>。</p>
<p>如果取消<code>T: Clone</code>的限制，会发生什么？它将不能按值调用，因为<code>T</code>没有实现<code>Clone</code>。所以编译器会尝试通过自动搜索来调用。在这种情况下，该函数的签名是<code>fn clone(&amp;&amp;T) -&gt; &amp;T</code>，因为<code>Self = &amp;T</code>。编译器看到<code>&amp;T: Clone</code>，然后推断出<code>cloned: &amp;T</code>。</p>
<p>下面是另一个例子，自动搜索行为被用来创造一些微妙的效果：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span>#[derive(Clone)]
struct Container&lt;T&gt;(Arc&lt;T&gt;);

fn clone_containers&lt;T&gt;(foo: &amp;Container&lt;i32&gt;, bar: &amp;Container&lt;T&gt;) {
    let foo_cloned = foo.clone();
    let bar_cloned = bar.clone();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>foo_cloned</code>和<code>bar_cloned</code>是什么类型？我们知道，<code>Container&lt;i32&gt;: Clone</code>，所以编译器按值调用<code>clone</code>，得到<code>foo_cloned: Container&lt;i32&gt;</code>。然而，<code>bar_cloned</code>实际上有<code>&amp;Container&lt;T&gt;</code>类型。这肯定是不合理的——我们给<code>Container</code>添加了<code>#[derive(Clone)]</code>，所以它必须实现<code>Clone</code>! 仔细看看，由<code>derive</code>宏产生的代码是（大致）：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Clone for Container&lt;T&gt; where T: Clone {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}
</code></pre>
<p>派生的<code>Clone</code>实现是<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html#derivable">只在<code>T: Clone</code>的地方定义</a>，所以没有<code>Container&lt;T&gt;</code>的实现。<code>Clone</code>在一般的<code>T</code>上没有实现。编译器接着查看<code>&amp;Container&lt;T&gt;</code>是否实现了<code>Clone</code>，最终发现它实现了。因此，它推断出<code>clone</code>是由 autoref 调用的，所以<code>bar_cloned</code>的类型是<code>&amp;Container&lt;T&gt;</code>。</p>
<p>我们可以通过手动实现<code>Clone</code>而不需要<code>T: Clone</code>来解决这个问题：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Clone for Container&lt;T&gt; {
    fn clone(&amp;self) -&gt; Self {
        Self(Arc::clone(&amp;self.0))
    }
}
</code></pre>
<p>现在，类型检查器推断出，<code>bar_cloned: Container&lt;T&gt;</code>。</p>
<h1><a class="header" href="#casts" id="casts">Casts</a></h1>
<p>Casts（译者注：实在没有找到合适的中文表述）是强转的超集：每个强转都可以通过 cast 来明确调用。然而，有些转换需要 cast。虽然强转是普遍存在的，而且基本上是无害的，但是这些“真正的 cast”是罕见的，而且有潜在的危险。因此，必须使用<code>as</code>关键字来明确调用 cast：<code>expr as Type</code>。</p>
<p>你可以在《The Reference》中找到一个<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">所有真正的 cast </a>和<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics"> cast 语义</a>的详尽列表。</p>
<h2><a class="header" href="#casting-的安全性" id="casting-的安全性">Casting 的安全性</a></h2>
<p>真正的 cast 通常围绕着原始指针和原始数字类型。尽管它们很危险，但这些转换在运行时是不会出错的。如果一个 cast 触发了一些微妙的边界条件，也不会有任何迹象表明发生了这种情况，cast 会成功。也就是说，cast 必须在类型的级别上有效，否则会在编译时被静态地阻止。例如，<code>7u8 as bool</code>编译会出错。</p>
<p>也就是说， cast 并不是<code>unsafe</code>的，因为它们<em>本身</em>通常不会违反内存安全。例如，将一个整数转换为一个原始指针很容易导致可怕的事情，然而，创建指针的行为本身是安全的，因为实际使用一个原始指针已经被标记为<code>unsafe</code>。</p>
<h2><a class="header" href="#一些关于-cast-的说明" id="一些关于-cast-的说明">一些关于 cast 的说明</a></h2>
<h3><a class="header" href="#cast-raw-slice-时的长度问题" id="cast-raw-slice-时的长度问题">cast raw slice 时的长度问题</a></h3>
<p>请注意，在 cast raw slice 时，长度不会被调整：<code>*const [u16] as *const [u8]</code>创建的 slice 只包括原始内存的一半。</p>
<h3><a class="header" href="#传递性" id="传递性">传递性</a></h3>
<p>Casting 不是传递的，也就是说，即使<code>e as U1 as U2</code>是一个有效的表达式，<code>e as U2</code>也不一定是。</p>
<h1><a class="header" href="#transmutes" id="transmutes">Transmutes</a></h1>
<p>类型系统，别挡着我们的路！我们要重新解释这些比特，否则就会死掉！尽管这本书是关于做不安全的事情的，但我真的必须强调，你应该深入思考找到本节中所涉及的操作以外的另一种方法。这真的是你在 Rust 中所能做的最可怕的不安全的事情，而这基本不设防。</p>
<p><a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute&lt;T, U&gt;</code></a>接收一个<code>T</code>类型的值并将其重新解释为<code>U</code>类型。唯一的限制是<code>T</code>和<code>U</code>被验证为具有相同的大小。导致未定义行为的方法是令人难以置信的。</p>
<ul>
<li>
<p>首先，创建一个具有无效状态的<em>任何</em>类型的实例都会导致无法真正预测的任意混乱。即使你从未对<code>bool</code>做过任何事情，也不要把<code>3</code>转化为<code>bool</code>。就是不要。</p>
</li>
<li>
<p>Transmute 有一个重载的返回类型。如果你不指定返回类型，它可能会为了满足类型推导而返回一个令人惊讶的类型。</p>
</li>
<li>
<p>将一个<code>&amp;</code>转为<code>&amp;mut</code>是未定义行为，尽管某些用法<em>可能</em>是安全的，但是需要注意，Rust 优化器可以自由地假设一个共享引用在它的生命周期内是不变的，而这种转换会违反这个假设。因此：</p>
<ul>
<li>将一个<code>&amp;</code>转为<code>&amp;mut</code><em>总是</em>未定义行为</li>
<li>不，你不能这样做</li>
<li>不，你并不特别</li>
</ul>
</li>
<li>
<p>Transmute 到一个没有明确提供生命周期的引用会产生一个<a href="./unbounded-lifetimes.html">无限制的寿命</a></p>
</li>
<li>
<p>当在不同的复合类型之间转换时，你必须确保它们的布局是一样的！如果布局不同，错误的字段就会被填入错误的数据，这也许仅仅让你 Debug 一阵，也可能会造成 UB（见上文）</p>
<p>那么你怎么知道布局是否相同呢？对于<code>repr(C)</code>类型和<code>repr(transparent)</code>类型，布局是精确定义的。但是对于普通的<code>repr(Rust)</code>来说，它不是。即使是同一个通用类型的不同实例也可以有截然不同的布局。<code>Vec&lt;i32&gt;</code>和<code>Vec&lt;u32&gt;</code><em>可能</em>有相同的字段顺序，也可能没有。数据布局保证了什么，或者没保证什么的细节可以参考<a href="https://rust-lang.github.io/unsafe-code-guidelines/layout.html"> UCG 工作组</a>。</p>
</li>
</ul>
<p><a href="https://doc.rust-lang.org/std/mem/fn.transmute_copy.html"><code>mem::transmute_copy&lt;T, U&gt;</code></a>比这个更不安全。它把<code>size_of&lt;U&gt;</code>字节从<code>T</code>中复制出来，并把它们解释为<code>U</code>。<code>mem::transmute</code>的大小检查没有了（因为复制出一个前缀可能是有效的），尽管<code>U</code>比<code>T</code>大是未定义行为。</p>
<p>当然，你也可以使用原始指针转换或<code>union</code>来获得这些函数的所有功能，并关闭 Lint 或其他基本的合理性检查。原始指针转换和<code>union</code>并不能神奇地避免上述规则。</p>
<h1><a class="header" href="#使用未初始化的内存" id="使用未初始化的内存">使用未初始化的内存</a></h1>
<p>Rust 程序中所有运行时分配的内存在开始时都是<em>未初始化</em>的。在这种状态下，内存的值是一堆不确定的比特，什么都有可能。试图将这个内存解释为<em>任何</em>类型的值都将导致未定义行为。请不要这样做。</p>
<p>Rust 提供了一些机制，以检查（安全）和不检查（不安全）的方式处理未初始化的内存。</p>
<h1><a class="header" href="#经检查的未初始化的内存" id="经检查的未初始化的内存">经检查的未初始化的内存</a></h1>
<p>和 C 语言一样，Rust 中的所有堆栈变量都是未初始化的，直到为它们明确赋值。与 C 不同的是，Rust 静态地阻止你读取它们，直到你为它们赋值。</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    let x: i32;
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-text">  |
3 |     println!(&quot;{}&quot;, x);
  |                    ^ 使用了没有初始化的 `x`
</code></pre>
<p>这基于一个基本的分支分析：每个分支都必须在第一次使用<code>x</code>之前给它赋值，方便起见，我们会说“x 被初始化了”或者“x 未初始化”。有趣的是，如果每个分支恰好赋值一次，Rust 不要求变量是可变的，以执行延迟初始化。然而这个分析并没有利用常量分析或类似的东西。所以下述的代码是可以编译的：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32;

    if true {
        x = 1;
    } else {
        x = 2;
    }

    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>但这个不行：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
    let x: i32;
    if true {
        x = 1;
    }
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-text">  |
6 |     println!(&quot;{}&quot;, x);
  |                    ^ 使用了可能没有初始化的 `x`
</code></pre>
<p>这个又可以了：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: i32;
    if true {
        x = 1;
        println!(&quot;{}&quot;, x);
    }
    // 不需要担心还有没有初始化 x 的分支，
    // 因为我们实际上并没有在别的分支使用 x
}
</code></pre></pre>
<p>当然，虽然分析不考虑实际值，但它对依赖关系和控制流有相对复杂的理解。例如，这样是可以编译通过的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32;

loop {
    // Rust 不知道这个分支会被无条件执行，
    // 因为它依赖于实际值
    if true {
        // 但是它确实知道循环只会有一次，
        // 因为我们会无条件 break，
        // 所以 x 不需要是可变的
        x = 0;
        break;
    }
}
// Rust 知道如果没有执行 break 的话，代码不会运行到这里
// 所以一旦运行到这里，x 一定已经初始化了
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>如果一个值从一个变量中移出，并且该值的类型不是 Copy，该变量在逻辑上就会变成未初始化。也就是说：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 0;
    let y = Box::new(0);
    let z1 = x; // x 仍然是有效的，因为 i32 可以 Copy
    let z2 = y; // 现在 y 逻辑上未初始化，因为 Box 不能 Copy
}
</code></pre></pre>
<p>然而，在这个例子中重新给<code>y</code>赋值需要将<code>y</code>标记为可变，这样一个安全的 Rust 程序就可以观察到<code>y</code>的值发生了变化：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut y = Box::new(0);
    let z = y; // 现在 y 逻辑上未初始化，因为 Box 不能 Copy
    y = Box::new(1); // 重新初始化 y
}
</code></pre></pre>
<p>否则<code>y</code>就像是一个全新的变量。</p>
<h1><a class="header" href="#丢弃标志" id="丢弃标志">丢弃标志</a></h1>
<p>上一节的例子为 Rust 引入了一个有趣的问题。我们已经看到，可以完全安全地对内存位置进行有条件的初始化、非初始化和重新初始化。对于实现了<code>Copy</code>的类型来说，这并不特别值得注意，因为它们只是一堆随机的比特。然而，带有析构器的类型是一个不同的故事。Rust 需要知道每当一个变量被赋值，或者一个变量超出范围时，是否要调用一个析构器。它怎么能用条件初始化来做到这一点呢？</p>
<p>请注意，这不是所有赋值都需要担心的问题。特别是，通过解引用的赋值会无条件地被丢弃，而相对的，在<code>let</code>中的赋值无论如何都不会被丢弃：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Box::new(0); // let 创建了一个全新的变量，所以一定(也没有必要)调用 drop
let y = &amp;mut x;
*y = Box::new(1); // 解引用假设原先的变量已经初始化了，因此一定会 drop
<span class="boring">}
</span></code></pre></pre>
<p>仅当覆盖先前初始化的变量或其子字段之一时，这才是个问题。</p>
<p>这种情况下，Rust 实际上是在<em>运行时</em>跟踪一个类型是否应该被丢弃。当一个变量被初始化和未初始化时，该变量的<em>丢弃标志</em>被切换。当一个变量可能需要被丢弃时，这个标志会被读取，以确定它是否应该被丢弃。</p>
<p>当然，通常的情况是，一个值的初始化状态在程序的每一个点上都是静态已知的。如果是这种情况，那么编译器理论上可以生成更有效的代码。例如，直线型代码就有这样的<em>静态丢弃语义（static drop semantics）</em>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = Box::new(0); // x 未初始化；仅覆盖值
let mut y = x;           // y 未初始化；仅覆盖值，并设置 x 为未初始化
x = Box::new(0);         // x 未初始化；仅覆盖值
y = x;                   // y 已初始化；销毁 y，覆盖它的值，设置 x 为未初始化
                         // y 离开作用域；y 已初始化；销毁 y
                         // x 离开作用域；x 未初始化；什么都不用做
<span class="boring">}
</span></code></pre></pre>
<p>类似地，所有分支都在初始化方面具有相同行为的代码具有静态丢弃语义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let mut x = Box::new(0); // x 未初始化；仅覆盖值
if condition {
    drop(x);             // x 失去值；设置 x 为未初始化
} else {
    println!(&quot;{}&quot;, x);
    drop(x);             // x 失去值；设置 x 为未初始化
}
x = Box::new(0);         // x 未初始化；仅覆盖值
                         // x 离开作用域；x 已初始化；销毁 x
<span class="boring">}
</span></code></pre></pre>
<p>然而像这样的代码<em>需要</em>运行时的信息来正确地 Drop：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>let x;
if condition {
    x = Box::new(0);        // x 未初始化；仅覆盖值
    println!(&quot;{}&quot;, x);
}
                            // x 离开了作用域，可能未初始化
                            // 检查 drop 标志位!
<span class="boring">}
</span></code></pre></pre>
<p>当然，在这种情况下，获得静态丢弃语义是很简单的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let condition = true;
</span>if condition {
    let x = Box::new(0);
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p>丢弃标志在栈中被跟踪。
在旧的 Rust 版本中，丢弃标志曾经是隐藏在实现<code>Drop</code>的类型中。</p>
<h1><a class="header" href="#未经检查的未初始化的内存" id="未经检查的未初始化的内存">未经检查的未初始化的内存</a></h1>
<p>这个规则的一个有趣的例外是与数组一起工作。Safe Rust 不允许你部分初始化一个数组。当你初始化一个数组时，你可以用<code>let x = [val; N]</code>将每个值设置为相同的东西，或者你可以用 <code>let x = [val1, val2, val3]</code>单独指定每个成员。不幸的是，这是很死板的，特别是当你需要以更多的增量或动态方式初始化你的数组时。</p>
<p>不安全的 Rust 给了我们一个强大的工具来处理这个问题：<a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>。这个类型可以用来处理还没有完全初始化的内存。</p>
<p>使用<code>MaybeUninit</code>，我们可以对一个数组进行逐个元素的初始化，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};

// 数组的大小是硬编码的，可以很方便地修改（改变几个硬编码的常数非常容易）
// 这表示我们不能用 [a, b, c] 这种方式初始化数组，因为我们必须要和硬编码中的 `SIZE` 保持同步！
const SIZE: usize = 10;

let x = {
    // 创建一个未初始化，类型为 `MaybeUninit` 的数组，
    // 因为这里声明的是一堆 `MaybeUninit`，不要求初始化，所以 `assume_init` 操作是安全的
    let mut x: [MaybeUninit&lt;Box&lt;u32&gt;&gt;; SIZE] = unsafe {
        MaybeUninit::uninit().assume_init()
    };

    // 因为 drop 一个 `MaybeUninit` 什么都不做，
    // 所以使用直接的裸指针赋值（而非 ptr::write）不会导致原先未初始化的变量被 drop
    // 不需要在这里考虑异常安全，因为 Box 永远不会 panic
    for i in 0..SIZE {
        x[i] = MaybeUninit::new(Box::new(i as u32));
    }

    // 一切都初始化完毕，将未初始化的类型强制转换为初始化的类型
    unsafe { mem::transmute::&lt;_, [Box&lt;u32&gt;; SIZE]&gt;(x) }
};

dbg!(x);
<span class="boring">}
</span></code></pre></pre>
<p>这段代码分三步进行：</p>
<ol>
<li>
<p>创建一个<code>MaybeUninit&lt;T&gt;</code>的数组。在当前稳定版的 Rust 中，我们必须使用不安全的代码来实现：我们取一些未初始化的内存（<code>MaybeUninit::uninit()</code>），并声称我们已经完全初始化了它（<a href="https://doc.rust-lang.org/core/mem/union.MaybeUninit.html#method.assume_init"><code>assume_init()</code></a>）。这似乎很荒谬，因为我们没有！这是正确的，因为数组本身完全由<code>MaybeUninit</code>组成，实际上不需要初始化。对于大多数其他类型，<code>MaybeUninit::uninit().assume_init()</code>会产生一个无效的类型实例，所以你荣获了一些未定义行为。</p>
</li>
<li>
<p>初始化数组。这个问题的微妙之处在于，通常情况下，当我们使用<code>=</code>赋值给一个 Rust 类型检查器认为已经初始化的值时（比如<code>x[i]</code>），存储在左边的旧值会被丢掉。这将是一场灾难。然而，在这种情况下，左边的类型是<code>MaybeUninit&lt;Box&lt;u32&gt;&gt;</code>，丢弃这个类型什么都不会发生，关于这个<code>drop</code>问题的更多讨论，见下文。</p>
</li>
<li>
<p>最后，我们必须改变我们数组的类型，以去除<code>MaybeUninit</code>。在当前稳定的 Rust 中，这需要一个<code>transmute</code>。这种转换是合法的，因为在内存中，<code>MaybeUninit&lt;T&gt;</code>看起来和<code>T</code>一样。</p>
<p>然而，请注意，在一般情况下，<code>Container&lt;MaybeUninit&lt;T&gt;&gt;</code>与<code>Container&lt;T&gt;</code>看起来<em>并不</em>一样! 假如<code>Container</code>是<code>Option</code>，而<code>T</code>是<code>bool</code>，那么<code>Option&lt;bool&gt;</code>就利用了<code>bool</code>只有两个有效值，但<code>Option&lt;MaybeUninit&lt;bool&gt;&gt;</code>不能这样做，因为<code>bool</code>不需要被初始化。</p>
<p>所以，这取决于<code>Container</code>是否允许将<code>MaybeUninit</code>转化掉。对于数组来说，它是允许的（最终标准库会通过提供适当的方法来达到这一点）。</p>
</li>
</ol>
<p>让我们在中间的循环上多花一点时间，特别是赋值运算符和它与<code>drop</code>的交互。比如这样的代码：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x[i].as_mut_ptr() = Box::new(i as u32); // 错误！
</code></pre>
<p>我们实际上会覆盖一个<code>Box&lt;u32&gt;</code>，导致在未初始化数据上调用<code>drop</code>，这将给你带来很多乐子。</p>
<p>如果由于某种原因我们不能使用<code>MaybeUninit::new</code>，正确的选择是使用<a href="https://doc.rust-lang.org/core/ptr/index.html"><code>ptr</code></a>模块。特别是，它提供了三个函数，允许我们将字节分配到内存中的某个位置而不丢弃旧值。<a href="https://doc.rust-lang.org/core/ptr/fn.write.html"><code>write</code></a>、<a href="https://doc.rust-lang.org/std/ptr/fn.copy.html"><code>copy</code></a>和<a href="https://doc.rust-lang.org/std/ptr/fn.copy_nonoverlapping.html"><code>copy_nonoverlapping</code></a>。</p>
<ul>
<li><code>ptr::write(ptr, val)</code>接收一个<code>val</code>并将其移动到<code>ptr</code>所指向的地址</li>
<li><code>ptr::copy(src, dest, count)</code>将<code>count</code>个 T 所占用的位从 src 复制到 dest(这等同于 C 的 memmove —— 注意参数顺序是相反的！)</li>
<li><code>ptr::copy_nonoverlapping(src, dest, count)</code>做的是<code>copy</code>的工作，但是在假设两个内存范围不重叠的情况下，速度更快(这等同于 C 的 memcpy —— 注意参数顺序是相反的！)</li>
</ul>
<p>自然不用说，这些函数如果被误用，会造成严重的破坏，或者直接导致未定义行为。这些函数<em>本身</em>需要的唯一东西是，你想读和写的位置已经被分配并正确对齐。然而，向内存的任意位置写入任意位的方式所带来的问题是无穷无尽的。</p>
<p>值得注意的是，你不需要担心在未实现<code>Drop</code>或者不包含<code>Drop</code>类型的类型上使用<code>ptr::write</code>带来的问题，因为 Rust 知道这个信息，并且不会调用<code>drop</code>。这也是我们在上面的例子中所依赖的。</p>
<p>然而，当你处理未初始化的内存时，你需要时刻警惕 Rust 试图在它们完全初始化之前丢弃你创建的这些值。如果它有一个析构器的话，该变量作用域内的每个控制路径必须在结束前初始化该值。<em><a href="unwinding.html">这包括 panic</a></em>。<code>MaybeUninit</code>在这方面有一点用，因为它不会隐式地丢弃它的内容——但在 panic 的情况下，这实际上意味着不是对尚未初始化的部分进行双重释放，而是对已经初始化的部分导致了内存泄漏。</p>
<p>注意，为了使用<code>ptr</code>方法，你需要首先获得一个你想初始化的数据的<em>raw pointer</em>。对未初始化的数据构建一个<em>引用</em>是非法的，这意味着你在获得上述原始指针时必须小心：</p>
<ul>
<li>对于一个<code>T</code>的数组，你可以使用<code>base_ptr.add(idx)</code>，其中<code>base_ptr: *mut T</code>来计算数组索引<code>idx</code>的地址。这依赖于数组在内存中的布局方式</li>
<li>然而，对于一个结构体，一般来说，我们不知道它是如何布局的，而且我们也不能使用<code>&amp;mut base_ptr.field</code>，因为这将创建一个引用。因此，当你使用<a href="https://doc.rust-lang.org/core/ptr/macro.addr_of_mut.html"><code>addr_of_mut</code></a>宏的时候，你必须非常小心，这将跳过中间层直接创建一个指向该字段的裸指针：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{ptr, mem::MaybeUninit};
struct Demo {
    field: bool,
}
let mut uninit = MaybeUninit::&lt;Demo&gt;::uninit();
// `&amp;uninit.as_mut().field`将会创建一个指向未初始化的`bool`的指针，而这是 UB 行为。
let f1_ptr = unsafe { ptr::addr_of_mut!((*uninit.as_mut_ptr()).field) };
unsafe { f1_ptr.write(true); }
let init = unsafe { uninit.assume_init() };
<span class="boring">}
</span></code></pre></pre>
<p>最后一句话：在阅读旧的 Rust 代码时，你可能会无意中发现被废弃的<code>mem::uninitialized</code>函数。这个函数曾经是处理栈上未初始化内存的唯一方法，但它被证明不能与语言的其他部分很好地结合在一起。在新的代码中你总是应该使用<code>MaybeUninit</code>来代替，并且当你有机会的时候，可以把旧的代码移植过来。</p>
<p>这就是与未初始化内存打交道的方法。基本上没有任何地方希望得到未初始化的内存，所以如果你要传递它，一定要<em>非常</em>小心。</p>
<h1><a class="header" href="#基于所有权的资源管理obrm的危险性" id="基于所有权的资源管理obrm的危险性">基于所有权的资源管理（OBRM）的危险性</a></h1>
<p>OBRM（又称 RAII：资源获取即初始化）是你在 Rust 中经常会用到的技巧，特别是当你使用标准库的时候。</p>
<p>粗略的说，其模式如下：要获得一个资源，你要创建一个对象来管理它。要释放资源，你只需销毁这个对象，它就会为你清理资源。这种模式管理的最常见的“资源”就是<em>内存</em>。<code>Box</code>、<code>Rc</code>以及<code>std::collection</code>中的所有东西都是一种便利，可以正确管理内存。这在 Rust 中特别重要，因为我们没有 GC 来管理内存。重点来了：Rust 是关于控制的。然而，我们并不仅仅局限于内存。几乎所有其他的系统资源，如线程、文件或套接字，都可以通过这种 API 暴露。</p>
<h1><a class="header" href="#构造" id="构造">构造</a></h1>
<p>构造一个用户定义类型的实例只有一种方法：为其命名，并一次性初始化其所有字段:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    a: u8,
    b: u32,
    c: bool,
}

enum Bar {
    X(u32),
    Y(bool),
}

struct Unit;

let foo = Foo { a: 0, b: 1, c: false };
let bar = Bar::X(0);
let empty = Unit;
<span class="boring">}
</span></code></pre></pre>
<p>就这样。其他所有构造类型实例的方法都是在调用一个完全虚无的函数，这个函数做了一些事情，最后变成了唯一的真实构造函数。</p>
<p>与 C++ 不同，Rust 没有内置的各种构造函数。没有 Copy、Default、Assignment、Move 或其他构造函数。其原因是多方面的，但主要归结为 Rust 的<em>显式</em>哲学。</p>
<p>移动构造函数在 Rust 中是没有意义的，因为我们不允许类型“关心”它们在内存中的位置。每个类型都必须准备好被盲目地移动到内存中的其他地方。这意味着纯粹的栈上但仍可移动的侵入性链表在 Rust 中根本无法（安全地）实现。</p>
<p>赋值和复制构造函数也同样不存在，因为移动语义是 Rust 中唯一的语义。<code>x = y</code>最多只是把 y 的位移到 x 变量中。Rust 确实提供了两种方法来提供 C++ 的面向拷贝的语义：<code>Copy</code>和<code>Clone</code>。Clone 类似我们所说的复制构造函数，但它从未被隐式调用。你必须在你想要克隆的元素上明确地调用<code>clone</code>。Copy 是 Clone 的一个特例，它的实现只是“复制比特”。Copy 类型<em>是</em>隐式克隆的，只要它们被移动；但由于 Copy 的定义，这只是意味着不把旧的变量当作未初始化的 —— 也就是说，啥都没干（no-op）。</p>
<p>虽然 Rust 提供了一个<code>Default</code>特性来指定了一个类似默认构造函数的东西，但这个特性很少被使用。这是因为变量<a href="uninitialized.html">不是隐式初始化的</a>。 Default 基本上只对泛型编程有用。在具体环境中，一个类型将为任何类型的“默认”构造函数提供一个静态的<code>new</code>方法。这与其他语言中的<code>new</code>没有关系，也没有特殊含义。它只是一个命名惯例。</p>
<p>TODO: talk about &quot;placement new&quot;?</p>
<h1><a class="header" href="#析构" id="析构">析构</a></h1>
<p>Rust 通过<code>Drop</code> trait 提供了完整的自动析构器，它提供了以下这个方法：</p>
<!-- ignore: function header -->
<pre><code class="language-rust ignore">fn drop(&amp;mut self);
</code></pre>
<p>这个方法给了类型一些时间来完成它正在做的事情。</p>
<p><strong>在<code>drop</code>运行后，Rust 将递归地尝试删除<code>self</code>的所有字段。</strong></p>
<p>这是一个方便的功能，这样你就不必写“析构器模板”来丢弃子字段。如果一个结构除了丢弃其子字段之外没有特殊的丢弃逻辑，那么就意味着根本不需要实现<code>Drop</code>!</p>
<p><strong>在 Rust 1.0 中没有稳定的方法来阻止这种行为。</strong></p>
<p>请注意，这里使用的是<code>&amp;mut self</code>，意味着即使你想要阻止递归的 Drop（例如将字段移出 self），Rust 也会阻止你。对于大多数类型来说，这完全没有问题。</p>
<p>一个自定义的<code>Box</code>的实现可以这样写<code>Drop</code>：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(ptr_internals, allocator_api)]

use std::alloc::{Allocator, Global, GlobalAlloc, Layout};
use std::mem;
use std::ptr::{drop_in_place, NonNull, Unique};

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;())
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>这样做是可行的，因为当 Rust 去丢弃<code>ptr</code>字段时，它只是看到一个<a href="phantom-data.html">Unique</a>，没有实际的<code>Drop</code>实现。同样的，没有任何东西可以在释放后使用<code>ptr</code>，因为当 drop 退出时，它就变得不可访问了。</p>
<p>然而下面这段代码就不可行了：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(allocator_api, ptr_internals)]

use std::alloc::{Allocator, Global, GlobalAlloc, Layout};
use std::ptr::{drop_in_place, Unique, NonNull};
use std::mem;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Box&lt;T&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // 释放 box 的内容，而不是 drop box 的内容
            let c: NonNull&lt;T&gt; = self.my_box.ptr.into();
            Global.deallocate(c.cast::&lt;u8&gt;(), Layout::new::&lt;T&gt;());
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>当我们在 SuperBox 的析构器中释放完<code>box</code>的 ptr 后，Rust 会很高兴地告诉 box 去 Drop 自己，然后，你就能开开心心去 debug use-after-free 和 double-free 的问题了。</p>
<p>请注意，递归 drop 行为适用于所有结构和枚举，无论它们是否实现了 Drop。因此，像这样的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Boxy&lt;T&gt; {
    data1: Box&lt;T&gt;,
    data2: Box&lt;T&gt;,
    info: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>在它将被丢弃时，它的 data1 和 data2 的字段就会被析构，尽管它本身并没有实现 Drop。我们说这样的类型<em>需要 Drop</em>，尽管它本身不是 Drop。</p>
<p>类似地：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Link {
    Next(Box&lt;Link&gt;),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>当且仅当一个实例存储了 Next 变量时，它的内部 Box 字段将被丢弃。</p>
<p>一般来说，这种设计非常好，因为当你重构数据布局时，你不需要担心添加/删除<code>Drop</code>的问题。当然，也有很多需要用析构器做更棘手的事情的例子。</p>
<p>经典的覆盖递归 drop 行为并允许在<code>drop</code>过程中移出 Self 的安全的解决方案是，使用一个 Option：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(allocator_api, ptr_internals)]

use std::alloc::{Allocator, GlobalAlloc, Global, Layout};
use std::ptr::{drop_in_place, Unique, NonNull};
use std::mem;

struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }

impl&lt;T&gt; Drop for Box&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            drop_in_place(self.ptr.as_ptr());
            let c: NonNull&lt;T&gt; = self.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
        }
    }
}

struct SuperBox&lt;T&gt; { my_box: Option&lt;Box&lt;T&gt;&gt; }

impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            // 释放 box 的内容，而不是 drop box 的内容，
            // 需要将 box 字段设置为 None，防止 Rust 对 box 成员可能存在的drop操作
            let my_box = self.my_box.take().unwrap();
            let c: NonNull&lt;T&gt; = my_box.ptr.into();
            Global.deallocate(c.cast(), Layout::new::&lt;T&gt;());
            mem::forget(my_box);
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>然而这有相当奇怪的语义：你是说一个<em>应该</em>总是 Some 的字段<em>可能</em>是 None，只是因为这发生在析构器中。当然，这也有一定的意义：你可以在析构器中调用 self 上的任意方法，这应该可以防止你在释放字段后这样做；而并不是说它能阻止你产生无效的状态。</p>
<p>总的来说，这是个可以接受的选择。当然，你应该在默认情况下达到这样的效果。然而，在未来，我们希望有一种更好的方式来指明一个字段不应该被自动 drop 掉。</p>
<h1><a class="header" href="#泄漏" id="泄漏">泄漏</a></h1>
<p>基于所有权的资源管理是为了简化组合：你在创建对象时获得资源，在对象被销毁时释放资源。由于销毁是自动为你处理的，这意味着你不能忘记释放资源，而且会尽快地释放！当然这很完美，我们所有的问题都解决了…………么？</p>
<p>一切都很糟糕，我们有新的、奇特的问题需要去解决。</p>
<p>很多人相信 Rust 能防止资源泄漏。在实践中，这基本上是对的。如果你看到一个安全的 Rust 程序以不受控制的方式泄漏资源，你会感到惊讶。</p>
<p>然而从理论的角度来看，无论你怎么看，都绝对不是这样的。在最严格的意义上，“泄漏”是如此抽象，以至于无法预防。在程序开始时初始化一个集合，用大量带有析构器的对象填充它，然后进入一个从未引用过它的无限事件循环，这是非常容易的。这个集合将毫无用处地坐着，守着它宝贵的资源，直到程序终止（无论如何，这时所有这些资源都会被操作系统回收）。</p>
<p>我们可以考虑一种更有限的泄漏形式：未能丢弃一个无法到达的值。Rust 也没有防止这种情况。事实上，Rust <em>有一个函数可以做到这一点</em>。<code>mem::forget</code>。这个函数消耗它所传递的值，<em>然后不运行它的析构器</em>。</p>
<p>在过去，<code>mem::forget</code>被标记为不安全，作为对使用它的一种提示，因为不调用一个析构器通常不是一件好的事情（尽管对一些特殊的不安全代码很有用）。然而，这通常被认为是一种站不住脚的立场：在安全代码中，有很多方法可以不调用析构函数。最著名的例子是使用内部可变性创建一个引用计数指针的循环引用。</p>
<p>对于安全代码来说，假设析构器的泄漏不会发生是合理的，因为任何泄漏析构器的程序都可能是错误的。然而，<em>不安全的</em>代码不能依赖析构器的运行来保证安全。对于大多数类型来说，这并不重要：如果你泄露了析构函数，那么根据定义，该类型是不可访问的，所以这并不重要，对吗？例如，如果你泄露了一个<code>Box&lt;u8&gt;</code>，那么你会浪费一些内存，但这几乎不会违反内存安全。</p>
<p>然而，我们必须注意的是<em>代理</em>类型的解构器泄露。这些类型管理对一个独立对象的访问，但实际上并不拥有它。代理对象是相当罕见的，你需要关注的代理对象就更少了。我们将专注于标准库中三个有趣的例子：</p>
<ul>
<li><code>vec::Drain</code></li>
<li><code>Rc</code></li>
<li><code>thread::scoped::JoinGuard</code></li>
</ul>
<h2><a class="header" href="#drain" id="drain">Drain</a></h2>
<p><code>drain</code>是一个 collections API，它将数据从容器中移出而不消耗容器。这使我们能够在对一个<code>Vec</code>的所有内容都获得所有权后重新使用其底层的内存分配。它产生了一个迭代器（Drain），并按值返回 Vec 的内容。</p>
<p>现在，考虑一下迭代中的 Drain：一些值已经被移出，而另一些还没有。这意味着 Vec 的一部分现在充满了逻辑上未初始化的数据! 我们可以在每次移出一个值的时候对 Vec 中的所有元素进行后移，但这将会产生非常灾难性的性能后果。</p>
<p>相反，我们希望 Drain 能在 Vec 被删除时修复它底层需要的内存分配（译者注：也就是 Vec 的内存分配）。它应该自己运行直到完成，并回移任何没有被移除的元素（drain 支持子范围），然后修复 Vec 的<code>len</code>。它甚至是 unwind 安全的。很简单!</p>
<p>现在考虑下面的情况：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut vec = vec![Box::new(0); 4];

{
    // 开始 drain，vec 无法被再次访问
    let mut drainer = vec.drain(..);

    // 从 drain 中取出两个元素，然后立刻销毁它们
    drainer.next();
    drainer.next();

    // 销毁 drainer，但是不调用它的 drop 函数
    mem::forget(drainer);
}

// Oops，vec[0] 已经被 drop 了，我们正在读一块已经释放的内存
println!(&quot;{}&quot;, vec[0]);
</code></pre>
<p>这很明显不是好事。不幸的是，我们正处于两难境地：在每一步保持一致的状态有巨大的成本（并且会抵消 API 带来的任何好处）。如果不能保持一致的状态，我们就会在安全代码中出现未定义的行为（使 API 不健全）。</p>
<p>那么我们能做什么呢？好吧，我们可以选择一个微弱的一致性状态：当我们开始迭代时，将 Vec 的 len 设置为 0，并在必要时在析构器中修复它。这样一来，如果一切执行正常，我们就能以最小的开销获得所需的行为。但是如果有人<em>胆敢</em>在迭代过程中 forget 了我们，那大不了就是<em>泄露更多</em>（并且可能让 Vec 处于一个虽然意外的但其他方面保持一致的状态）。既然我们已经接受了 mem::forget 是安全的，那么这就必须绝对是安全的。我们把一个泄漏导致更多的泄漏称为<em>泄漏放大</em>。</p>
<h2><a class="header" href="#rc" id="rc">Rc</a></h2>
<p>Rc 是一个有趣的例子，因为乍一看，它似乎根本就不是一个代理值。毕竟，它管理着它所指向的数据，丢掉一个值的所有 Rcs 就会丢掉这个值。泄露一个 Rc 似乎并不特别危险。它将使 refcount 永久增加，并阻止数据被释放或丢弃，但这似乎就像 Box，对吗？</p>
<p>并不是这样。</p>
<p>让我们考虑一下 Rc 的一个简化实现：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct Rc&lt;T&gt; {
    ptr: *mut RcBox&lt;T&gt;,
}

struct RcBox&lt;T&gt; {
    data: T,
    ref_count: usize,
}

impl&lt;T&gt; Rc&lt;T&gt; {
    fn new(data: T) -&gt; Self {
        unsafe {
            // 如果 heap::allocate 像这样不是很好吗？
            let ptr = heap::allocate::&lt;RcBox&lt;T&gt;&gt;();
            ptr::write(ptr, RcBox {
                data: data,
                ref_count: 1,
            });
            Rc { ptr: ptr }
        }
    }

    fn clone(&amp;self) -&gt; Self {
        unsafe {
            (*self.ptr).ref_count += 1;
        }
        Rc { ptr: self.ptr }
    }
}

impl&lt;T&gt; Drop for Rc&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            (*self.ptr).ref_count -= 1;
            if (*self.ptr).ref_count == 0 {
                // drop 数据并且释放所占据的内存
                ptr::read(self.ptr);
                heap::deallocate(self.ptr);
            }
        }
    }
}
</code></pre>
<p>这段代码包含了一个隐含的、微妙的假设：<code>ref_count</code>可以装入<code>usize</code>，因为内存中的 Rcs 不能超过<code>usize::MAX</code>。然而这本身就假设<code>ref_count</code>准确反映了内存中的 Rcs 数量，我们知道用<code>mem::forget</code>是错误的。使用<code>mem::forget</code>我们可以溢出<code>ref_count</code>，然后用大量的 Rcs 将其降至 0。然后我们就可以愉快地对内部数据进行 use-after-free 了。负负得正？</p>
<p>这个问题可以通过检查<code>ref_count</code>并做一些防御来解决。标准库的立场是直接 abort，因为你的程序肯定是摊上事儿了，摊上大事儿了。卧槽，这真是一个可笑的边界情况。</p>
<h2><a class="header" href="#threadscopedjoinguard" id="threadscopedjoinguard">thread::scoped::JoinGuard</a></h2>
<blockquote>
<p>实际上这个 API 很早就从标准库中删除了，具体原因可以参考 https://github.com/rust-lang/rust/issues/24292。</p>
<p>原文也有人提过 issue 询问是否可以删除，得到了答复说，这个例子仍然是非常重要的，所以保留了下来：https://github.com/rust-lang/nomicon/issues/57。</p>
</blockquote>
<p>thread::scoped API 旨在允许引用其父线程栈上的数据的线程被创建出来，而不需要对这些数据进行任何同步。它确保父线程在任何共享数据失效之前 join 子线程。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn scoped&lt;'a, F&gt;(f: F) -&gt; JoinGuard&lt;'a&gt;
    where F: FnOnce() + Send + 'a
</code></pre>
<p>这里<code>f</code>是一些闭包，供其他线程执行。这里我们定义<code>F: Send +'a</code>意思是它捕获了生命周期为<code>'a</code>的数据，而且它要么拥有该数据，要么该数据是<code>Sync</code>的（暗示<code>&amp;data</code>是<code>Send</code>）。</p>
<p>因为 JoinGuard 有一个生命周期，它通过借用捕获了所有它需要的父线程中的数据。这意味着 JoinGuard 不能超过其他线程正在处理的数据的生命周期。当<em>JoinGuard</em>被丢弃时，它会 block 父线程，确保子线程中捕获的数据在父线程中 drop 之前失效。</p>
<p>使用方法看起来像这样：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
{
    let mut guards = vec![];
    for x in &amp;mut data {
        // 将可变引用移入闭包，并且在另外一个线程执行闭包，
        // 闭包有一个生命周期，由其保存的引用的生命周期决定，
        // 返回的句柄和闭包也有相同的生命周期，
        // 所以它也和闭包一样可变引用了 x，
        // 也就意味着在句柄（线程）销毁之前，我们不能访问 x
        let guard = thread::scoped(move || {
            *x *= 2;
        });
        // 将线程句柄保存起来之后使用
        guards.push(guard);
    }
    // 所有的句柄在这里被 drop, 强制线程 Join（主线程在此阻塞），
    // 等到所有的线程 join 之后，其借用的数据就过期了，
    // 因此又可以在主线程中访问了
}
// 在这里数据绝对已经改变了
</code></pre>
<p>原则上，这完全是可行的！Rust 的所有权系统完美地保证了这一点！……只是它必须依赖于一个保证被调用到的析构器才是安全的。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let mut data = Box::new(0);
{
    let guard = thread::scoped(|| {
        // 好一点的情况是存在数据竞争，更坏的是释放内存后使用的问题
        *data += 1;
    });
    //  因为 guard 被主动 forget 了，不会调用 drop 方法，主线程不会阻塞等待 guard 结束
    mem::forget(guard);
}
// Box在这里被销毁，而不确定子线程是否会在这里尝试访问它
</code></pre>
<p>在这里，一个会运行的析构器对 API 来说是非常基本的。因此它不得不被废弃，而采用完全不同的设计。</p>
<h1><a class="header" href="#unwinding" id="unwinding">Unwinding</a></h1>
<blockquote>
<p>译者注：unwind 可以翻译为展开、解卷等等，但是没有找到合适的信达雅的翻译，所以暂且保留英文原文，作为固定词语处理。</p>
</blockquote>
<p>Rust 有一个<em>分等级</em>的错误处理方案：</p>
<ul>
<li>如果某些东西可能不存在，则使用 Option</li>
<li>如果出了问题并且可以合理地处理，则使用 Result</li>
<li>如果有什么东西出错了，而且不能合理地处理，线程就会 panic</li>
<li>如果发生了灾难性的事情，程序就会直接中止（abort）</li>
</ul>
<p>在大多数情况下，Option 和 Result 是绝大多数人的首选，特别是因为它们可以提供了 API，可以根据用户的决定被提升为 panic 或中止。panic 会导致线程停止正常的执行，并 unwind 它的堆栈，调用析构器，就像每个函数瞬间返回一样。</p>
<p>从 1.0 开始，Rust 在涉及到 panic 时有两种想法。在很久以前，Rust 很像 Erlang，有轻量级的任务，而任务的目的是在达到无法维持的状态时用 panic 来杀死自己。与 Java 或 C++ 中的异常不同，panic 不能在任何时候被捕获。panic 只能被任务的所有者捕捉到，这时必须对其进行处理，否则<em>该</em>任务本身就会出现 panic。</p>
<p>unwind 对这个故事很重要，因为如果一个任务的析构器没有被调用，就会导致内存和其他系统资源的泄漏。由于任务会在正常执行过程中死亡，这将使 Rust 在长期运行的系统中变得非常糟糕。</p>
<p>随着我们今天所知道的 Rust 的出现，这种编程风格在对越来越少的抽象的推动下逐渐失去了时尚。轻量级的任务在重量级的操作系统线程中被杀死。尽管如此，在 1.0 版本的稳定版 Rust 上，panic 只能由父线程捕捉。这意味着捕捉 panic 需要使用一整个操作系统线程。不幸的是，这与 Rust 的零成本抽象理念有冲突。</p>
<p>有一个叫做<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>的 API，可以在不产生线程的情况下捕捉到一个 panic。不过，我们还是鼓励你少用这个方法。特别是，Rust 目前的 unwind 实现为“不 unwind”的情况做了大量的优化。如果一个程序没有 unwind，那么这个程序在仅仅预备好 unwind 时就不应该有运行时成本。因此，实际 unwind 的成本会比 Java 中的成本高。在正常情况下，不要让你的程序来 unwind。理想情况下，你应该只为编程错误或<em>极端</em>的问题而 panic。</p>
<p>Rust 的 unwind 策略没有被指定为与任何其他语言的 unwind 在本质上兼容。因此，从其他语言 unwind 到 Rust，或者从 Rust unwind 到其他语言，都是未定义行为。你必须在 FFI 的边界上<em>绝对地</em>捕捉任何 panic！你在这时候（FFI 边界上捕捉到 panic 后）做什么完全由你自己决定，但你<em>必须</em>做一些事情。如果你没有做到这一点，最好的情况是你的应用程序会崩溃，在最坏的情况下，你的应用程序<em>不会</em>崩溃，但至于会发生什么？祝你好运。</p>
<h1><a class="header" href="#异常安全" id="异常安全">异常安全</a></h1>
<p>尽管程序应该很少使用 unwind，但是有很多代码是<em>可以</em> panic 的。如果你 unwrap 一个 None，索引出界，或者除以 0，你的程序就会 panic。在 debug build 中，每一个算术运算如果溢出，都会引起 panic。除非你非常小心并严格控制代码的运行，否则几乎所有的东西都可能 unwind，你需要做好准备。</p>
<p>在更广泛的编程世界中，为 unwind 做好准备通常被称为<em>异常安全</em>。在 Rust 中，有两个级别的异常安全需要关注：</p>
<ul>
<li>在不安全的代码中，我们<em>必须</em>保证异常安全到不违反内存安全的程度。我们把这称为<em>最小</em>的异常安全。</li>
<li>在安全代码中，保证异常安全到你的程序能做正确的事情的程度（也就是说，啥都不影响，都恢复了）。我们称其为<em>最大限度的</em>异常安全。</li>
</ul>
<p>正如 Rust 中许多地方的情况一样，不安全的代码必须准备好处理有问题的安全代码，当它涉及到 unwind 时。有可能在某一时刻创建不健壮状态的代码必须注意，panic 不会导致该状态被使用。也就是说，这意味着当这些状态存在时，只有非 panicking 的代码才会被运行；或者你需要做一个防护，在 panic 的情况下清理该状态。这并不一定意味着 panic 所见证的状态是一个完全一致的状态。我们只需要保证它是一个<em>安全</em>的状态。</p>
<p>大多数不安全代码都是属于叶子代码（也就是不会再调用其它函数/逻辑），因此相当容易使异常安全化。它控制着所有运行的代码，而且大多数代码都不会发生 panic。然而，不安全代码在重复调用调用者提供的代码时，与未初始化的数组打交道是很常见的。这样的代码需要小心谨慎，并考虑异常安全。</p>
<h2><a class="header" href="#vecpush_all" id="vecpush_all">Vec::push_all</a></h2>
<p><code>Vec::push_all</code>是一个临时性的 hack，可以在没有特例化的情况下，通过一个 slice 来高效地扩展一个 Vec。下面是一个简单的实现：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Vec&lt;T&gt; {
    fn push_all(&amp;mut self, to_push: &amp;[T]) {
        self.reserve(to_push.len());
        unsafe {
            // 因为我们刚刚预留了空间，所以这里不会溢出
            self.set_len(self.len() + to_push.len());

            for (i, x) in to_push.iter().enumerate() {
                self.ptr().add(i).write(x.clone());
            }
        }
    }
}
</code></pre>
<p>我们绕过了<code>push</code>，以避免对我们明确知道有容量的 Vec 进行多余的容量和<code>len</code>检查。这个逻辑是完全正确的，只是我们的代码有一个微妙的问题：它不是异常安全的！<code>set_len</code>、<code>add</code>和<code>write</code>都没问题；但<code>clone</code>是我们忽略的 panic 炸弹。</p>
<p>Clone 完全不受我们的控制，而且完全可以自由地 panic。如果它这样做，我们的函数将提前退出；而因为 Vec 的长度被设置得太大了，如果 Vec 被读取或丢弃，未初始化的内存将被读取！</p>
<p>这种情况下的修复方法相当简单，如果我们想保证我们<em>已经</em>复制的值被丢弃，我们可以在每个循环迭代中设置<code>len</code>。如果我们只是想保证未初始化的内存不能被观察到，我们可以在循环之后设置<code>len</code>。</p>
<h2><a class="header" href="#binaryheapsift_up" id="binaryheapsift_up">BinaryHeap::sift_up</a></h2>
<p>把一个元素扔到堆中，比扩展一个 Vec 要复杂一些。伪代码如下：</p>
<pre><code class="language-text">bubble_up(heap, index):
    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:
        heap.swap(index, parent(index))
        index = parent(index)
</code></pre>
<p>将这段代码按字面意思翻译成 Rust 是完全没有问题的，但是有一个坑爹的性能问题：<code>self</code>元素被无用地反复交换。因此，我们可以这么做：</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>这段代码确保每个元素尽可能少地被复制（事实上，在一般情况下，elem 有必要被复制两次）。但是它现在暴露了一些异常安全问题! 在任何时候，一个值都存在两个副本。如果我们在这个函数中 panic，就会有东西被重复 drop。不幸的是，我们对执行的代码并没有完全的掌控力——因为比较方法是用户定义的！</p>
<p>与 Vec 不同，这里的修复并不容易。一个可选的方案是将用户定义的代码和不安全的代码分成两个独立的阶段：</p>
<pre><code class="language-text">bubble_up(heap, index):
    let end_index = index;
    while end_index != 0 &amp;&amp; heap[end_index] &lt; heap[parent(end_index)]:
        end_index = parent(end_index)

    let elem = heap[index]
    while index != end_index:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</code></pre>
<p>如果用户定义的代码炸了，那就没有问题了，因为我们还没有真正接触到堆的状态。一旦我们开始接触堆，我们就只与我们信任的数据和函数打交道，所以不存在 panic 的问题。</p>
<p>也许你对这种设计并不满意，不过我不得不说，这确实是在作弊! 而且我们还得做复杂的堆遍历<em>两次</em>! 好吧，让我们咬咬牙，把不可信任的和不安全的代码混在一起。</p>
<p>如果 Rust 像 Java 一样有<code>try</code>和<code>finally</code>，我们就可以做以下事情：</p>
<pre><code class="language-text">bubble_up(heap, index):
    let elem = heap[index]
    try:
        while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
            heap[index] = heap[parent(index)]
            index = parent(index)
    finally:
        heap[index] = elem
</code></pre>
<p>基本的想法很简单：如果比较出现问题，我们就把松散的元素扔到逻辑上未初始化的索引中，然后就直接返回。任何观察堆的人都会看到一个潜在的<em>不一致</em>的堆，但至少它不会导致任何双重释放问题。而如果算法正常终止，那么这个操作恰好与我们的结束方式不谋而合。</p>
<p>遗憾的是，Rust 没有这样的结构，所以我们需要推出我们自己的结构。这样做的方法是将算法的状态存储在一个单独的结构中，并为“最终”逻辑设置一个析构函数。无论我们是否 panic，这个析构函数都会在我们之后运行和清理：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct Hole&lt;'a, T: 'a&gt; {
    data: &amp;'a mut [T],
    /// `elt` 从始至终都是 Some
    elt: Option&lt;T&gt;,
    pos: usize,
}

impl&lt;'a, T&gt; Hole&lt;'a, T&gt; {
    fn new(data: &amp;'a mut [T], pos: usize) -&gt; Self {
        unsafe {
            let elt = ptr::read(&amp;data[pos]);
            Hole {
                data: data,
                elt: Some(elt),
                pos: pos,
            }
        }
    }

    fn pos(&amp;self) -&gt; usize { self.pos }

    fn removed(&amp;self) -&gt; &amp;T { self.elt.as_ref().unwrap() }

    fn get(&amp;self, index: usize) -&gt; &amp;T { &amp;self.data[index] }

    unsafe fn move_to(&amp;mut self, index: usize) {
        let index_ptr: *const _ = &amp;self.data[index];
        let hole_ptr = &amp;mut self.data[self.pos];
        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
        self.pos = index;
    }
}

impl&lt;'a, T&gt; Drop for Hole&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // fill the hole again
        unsafe {
            let pos = self.pos;
            ptr::write(&amp;mut self.data[pos], self.elt.take().unwrap());
        }
    }
}

impl&lt;T: Ord&gt; BinaryHeap&lt;T&gt; {
    fn sift_up(&amp;mut self, pos: usize) {
        unsafe {
            // 取出 `pos` 的值，然后创建一个 hole
            let mut hole = Hole::new(&amp;mut self.data, pos);

            while hole.pos() != 0 {
                let parent = parent(hole.pos());
                if hole.removed() &lt;= hole.get(parent) { break }
                hole.move_to(parent);
            }
            // 无论是否 panic，这里的 hole 都会被无条件填充
        }
    }
}
</code></pre>
<h1><a class="header" href="#poisoning" id="poisoning">Poisoning</a></h1>
<p>尽管所有不安全的代码都<em>必须</em>确保其具有最小的异常安全，但并非所有类型都能确保<em>最大</em>的异常安全；而即使类型保证了，你的代码也可能导致额外的问题。例如，一个整数当然是异常安全的，但它本身没有语义。panic 的代码有可能无法正确地更新整数，从而产生不一致的程序状态。</p>
<p>这<em>通常</em>是没问题的，因为任何见证异常的东西都会被销毁。例如，如果你发送一个 Vec 给另一个线程，而那个线程 panic 了，那么这个 Vec 是否处于一个奇怪的状态并不重要。它将被丢弃并永远消失。然而，有些类型特别擅长跨越 panic 边界获取值。</p>
<p>这些类型可以选择明确地 <em>毒害（Poison）</em> 自己，如果他们遇到了一个 panic。Poisoning 并不意味着什么特别的事情。一般来说，它只是意味着阻止正常的使用继续进行。这方面最明显的例子是标准库的 Mutex 类型。如果 Mutex 的一个 MutexGuards（当获得锁时返回的东西）在 panic 中被丢弃，Mutex 将自我中毒。今后任何试图锁定 Mutex 的行为都会返回<code>Err</code>或 panic。</p>
<p>Mutex 中毒不是为了 Rust 通常关心的真正的安全。它是作为一种安全防护措施，防止盲目地使用在锁定时发生了 panic 的 Mutex 中的数据。这样的 Mutex 中的数据可能正在被修改中，因此可能处于不一致或不完整的状态。需要注意的是，如果正确地编写了这样一个类型，就不会违反内存安全。毕竟，它必须是最低限度的异常安全的。</p>
<p>然而，如果 Mutex 包含，比如说，一个实际上不具备堆属性的 BinaryHeap，那么任何使用它的代码都不可能按照作者的意图运行。因此，程序不应该正常进行。不过，如果你确信你可以对这个值做<em>一些</em>事情，Mutex 还是暴露了一个方法来获得锁。毕竟，它<em>是</em>安全的，只是可能是无稽之谈。</p>
<h1><a class="header" href="#并发和并行" id="并发和并行">并发和并行</a></h1>
<p>Rust 作为一种语言，对如何进行并发或并行并没有什么意见。标准库暴露了操作系统线程和阻塞系统调用，因为每个人都有这些东西，而且它们足够统一，你可以以一种相对没有争议的方式提供对它们的抽象。消息传递、绿色线程和异步 API 都是多种多样的，任何对它们的抽象都会涉及到我们不愿意在 1.0 中承诺的 trade-off。</p>
<p>然而，Rust 建立的并发模型，使得将你自己的并发范式设计成一个库变得相对容易，并且让其他人的代码可以与你的代码一起工作。只要要求正确的生命周期、<code>Sync</code>和<code>Send</code>，你就可以不用担心数据竞争了。</p>
<h1><a class="header" href="#数据竞争和竞态条件" id="数据竞争和竞态条件">数据竞争和竞态条件</a></h1>
<p>安全的 Rust 保证没有数据竞争，数据竞争的定义是：</p>
<ul>
<li>两个或多个线程同时访问一个内存位置</li>
<li>其中一个或多个线程是写的</li>
<li>其中一个或多个是非同步的</li>
</ul>
<p>数据竞争具有未定义行为，因此在 Safe Rust 中不可能执行。数据竞争主要是通过 Rust 的所有权系统来防止的：不可能别名一个可变引用，所以不可能进行数据竞争。但内部可变性使其更加复杂，这也是我们有 Send 和 Sync Trait 的主要原因（见下个章节更详细的说明）。</p>
<p><strong>然而，Rust 并没有（也无法）阻止更广泛的竞态条件。</strong></p>
<p>在你无法控制调度器的情况下，这在数学上是不可能的，而对于普通的操作系统环境来说你是无法控制调度器的。如果你确实控制了抢占，那么 <em>有可能</em> 防止一般的竞态——这种技术被像 <a href="https://github.com/rtic-rs/rtic">RTIC</a> 这样的框架所使用。然而，实际上拥有对调度的控制是一个非常罕见的情况。</p>
<p>因此，对于一个安全的 Rust 程序来说，在不正确的同步下出现死锁或做一些无意义的事情是完全“正常”的。很明显，这样的程序有问题，但 Rust 只能帮你到这里。不过，Rust 程序中的竞态条件本身并不能违反内存安全；只有与其他不安全的代码结合在一起，竞态条件才能真正违反内存安全。比如说：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];
// 使用 Arc，这样即使程序执行完毕，存储 AtomicUsize 的内存依然存在，
// 否则由于 thread::spawn 的生命周期限制，Rust 不会为我们编译这段代码
let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move` 捕获了 other_idx 的值，将它移入这个线程
thread::spawn(move || {
    // 因为这是一个原子变量，不存在数据竞争问题，所以可以修改 other_idx 的值
    other_idx.fetch_add(10, Ordering::SeqCst);
});

// 因为我们只读取了一次原子的内存，因此用原子中的值做索引是安全的，
// 然后将读出的值的拷贝传递给 Vec 做为索引，
// 索引过程可以做正确的边界检查，并且在执行索引期间这个值也不会发生改变。
// 但是，如果上面的线程在执行这句代码之前增加了这个值，这段代码会 panic。
// 因为程序的正确执行（panic 几乎不可能是正确的），所以这就是一个 *竞态*，
// 其执行结果依赖于线程的执行顺序
println!(&quot;{}&quot;, data[idx.load(Ordering::SeqCst)]);
<span class="boring">}
</span></code></pre></pre>
<p>如果我们提前进行边界检查，然后使用未经检查的值不安全地访问数据，我们就可能引起数据竞争：</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

let data = vec![1, 2, 3, 4];

let idx = Arc::new(AtomicUsize::new(0));
let other_idx = idx.clone();

// `move` 捕获了 other_idx 值，将它移入这个线程
thread::spawn(move || {
    // 因为这是一个原子变量，不存在数据竞争问题，所以可以修改 other_idx 的值
    other_idx.fetch_add(10, Ordering::SeqCst);
});

if idx.load(Ordering::SeqCst) &lt; data.len() {
    unsafe {
        // 所以在边界检查之后读取 idx 的值可能是不正确的
        // 因为我们这里会 `get_unchecked`, 而这个操作是 `unsafe` 的，
        // 所以这里就存在着竞态，并且 *非常危险*！
        println!(&quot;{}&quot;, data.get_unchecked(idx.load(Ordering::SeqCst)));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#send-和-sync" id="send-和-sync">Send 和 Sync</a></h1>
<p>并不是所有的东西都服从于继承的可变性。有些类型允许你在内存中对一个位置有多个别名，并且同时修改它。除非这些类型使用同步手段来管理这种访问，否则它们绝对不是线程安全的。Rust 通过 <code>Send</code>和<code>Sync</code> Trait 来解决这个问题：</p>
<ul>
<li>如果将一个类型发送到另一个线程是安全的，那么它就是<code>Send</code></li>
<li>如果一个类型可以安全地在线程间共享，那么它就是<code>Sync</code>的（当且仅当<code>&amp;T</code>是<code>Send</code>时，<code>T</code>是<code>Sync</code>的）</li>
</ul>
<p>Send 和 Sync 是 Rust 的并发故事的基础。因此，存在大量的特殊工具来使它们正常工作。首先，它们是<a href="safe-unsafe-meaning.html">不安全的 Trait</a>,这意味着它们的实现是不安全的，而其他不安全的代码可以认为它们是正确实现的。由于它们是<em>标记特性</em>（它们没有像方法那样的相关项目），正确实现仅仅意味着它们具有实现者应该具有的内在属性。不正确地实现 Send 或 Sync 会导致未定义行为。</p>
<p>Send 和 Sync 也是自动派生的 Trait。这意味着，与其它 Trait 不同，如果一个类型完全由 Send 或 Sync 类型组成，那么它就是 Send 或 Sync。几乎所有的基本数据类型都是<code>Send</code>和<code>Sync</code>，因此，几乎所有你将与之交互的类型都是<code>Send</code>和<code>Sync</code>。</p>
<p>主要的例外情况包括：</p>
<ul>
<li>原始指针既不是 Send 也不是 Sync（因为它们没有安全防护）</li>
<li><code>UnsafeCell</code>不是 Sync 的（因此<code>Cell</code>和<code>RefCell</code>也不是）</li>
<li><code>Rc</code>不是 Send 或 Sync 的（因为 Refcount 是共享的、不同步的）</li>
</ul>
<p><code>Rc</code>和<code>UnsafeCell</code>从根本上说不是线程安全的：它们共享了非同步的可变状态。然而，严格来说，原始指针被标记为线程不安全，更像是一个<em>提示</em>。用原始指针做任何有用的事情都需要对其进行解引用，这已经是不安全的了；当然，从这个角度上说，人们也可以认为将它们标记为线程安全的做法也没啥问题。</p>
<p>然而，更重要的是，它们不是线程安全的，是为了防止包含它们的类型被自动标记为线程安全的。这些类型的所有权并不明确，它们的作者也不太可能认真考虑线程安全问题。在<code>Rc</code>的例子中，我们有一个很好的例子，它包含一个绝对不是线程安全的<code>*mut</code>类型。</p>
<p>如果需要的话，那些没有自动派生的类型可以很简单地实现它们：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<p>在<em>难以置信</em>的罕见情况下，一个类型被不恰当地自动派生为 Send 或 Sync，那么我们也可以不实现 Send 和 Sync：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(negative_impls)]

<span class="boring">fn main() {
</span>// 假设我这里存在一些魔法，对于同步原语有着非常神奇的语义
struct SpecialThreadToken(u8);

impl !Send for SpecialThreadToken {}
impl !Sync for SpecialThreadToken {}
<span class="boring">}
</span></code></pre></pre>
<p>请注意，<em>正常情况下</em>是不可能错误地派生出 Send 和 Sync 的。只有那些被其他不安全代码赋予特殊意义的类型才有可能因为不正确的 Send 或 Sync 而造成麻烦。</p>
<p>大多数对原始指针的使用应该被封装在一个足够的抽象后面，以便 Send 和 Sync 可以被派生。例如，所有 Rust 的标准集合都是 Send 和 Sync（当它们包含 Send 和 Sync 类型时），尽管它们普遍使用原始指针来管理内存分配和复杂的所有权。同样的，大多数这些集合的迭代器都是 Send 和 Sync 的，因为它们在很大程度上表现得像集合的<code>&amp;</code>或<code>&amp;mut</code>。</p>
<h2><a class="header" href="#示例" id="示例">示例</a></h2>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>由于<a href="https://manishearth.github.io/blog/2017/01/10/rust-tidbits-box-is-special/">各种原因</a>，编译器将其作为自己的特殊内建类型来实现，但是我们可以自己实现一些具有类似行为的东西，来看看什么时候实现 Send 和 Sync 是合理的。让我们把它叫做<code>Carton</code>。</p>
<p>我们先写代码，把分配在栈上的一个值，转移到堆上：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub mod libc {
</span><span class="boring">   pub use ::std::os::raw::{c_int, c_void};
</span><span class="boring">   #[allow(non_camel_case_types)]
</span><span class="boring">   pub type size_t = usize;
</span><span class="boring">   extern &quot;C&quot; { pub fn posix_memalign(memptr: *mut *mut c_void, align: size_t, size: size_t) -&gt; c_int; }
</span><span class="boring">}
</span>use std::{
    mem::{align_of, size_of},
    ptr,
    cmp::max,
};

struct Carton&lt;T&gt;(ptr::NonNull&lt;T&gt;);

impl&lt;T&gt; Carton&lt;T&gt; {
    pub fn new(value: T) -&gt; Self {
        // 在堆上分配足够的可以存储一个类型 T 大小的空间
        assert_ne!(size_of::&lt;T&gt;(), 0, &quot;Zero-sized types are out of the scope of this example&quot;);
        let mut memptr: *mut T = ptr::null_mut();
        unsafe {
            let ret = libc::posix_memalign(
                (&amp;mut memptr as *mut *mut T).cast(),
                max(align_of::&lt;T&gt;(), size_of::&lt;usize&gt;()),
                size_of::&lt;T&gt;()
            );
            assert_eq!(ret, 0, &quot;Failed to allocate or invalid alignment&quot;);
        };

        // NonNull 仅仅是对于指针的一层封装，强制要求指针是非空的
        let ptr = {
            // 安全保证：因为我们从一个引用创建了 memptr，并且独占了所有权，所以可以解引用
            ptr::NonNull::new(memptr.cast::&lt;T&gt;())
                .expect(&quot;Guaranteed non-null if posix_memalign returns 0&quot;)
        };

        // 将数据从栈上复制到堆上
        unsafe {
            // 安全保证：如果 ptr 是非空的，posix_memalign 会返回一个已经内存对齐的有效的可写指针
            ptr.as_ptr().write(value);
        }

        Self(ptr)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这不是很有用，因为一旦我们的用户给了我们一个值，他们就没有办法访问它。<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>实现了<a href="https://doc.rust-lang.org/core/ops/trait.Deref.html"><code>Deref</code></a>和<a href="https://doc.rust-lang.org/core/ops/trait.DerefMut.html"><code>DerefMut</code></a>，这样你就可以访问内部的值。让我们来做这件事：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::{Deref, DerefMut};

<span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span><span class="boring">
</span>impl&lt;T&gt; Deref for Carton&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        unsafe {
            // 安全保证：self 指针已经内存对齐，并且初始化了, 在 `Self::new` 方法中已经解引用，
            // 我们要求 readers 引用 Carton，而这里返回值的生命周期和输入的 self 的生命周期对齐，
            // 因此 borrow checker 会强制保证这一点：
            // 直到这个引用被 drop，不能修改 Carton 中的内容
            self.0.as_ref()
        }
    }
}

impl&lt;T&gt; DerefMut for Carton&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        unsafe {
            // 安全保证：self 指针已经内存对齐，并且初始化了, 在 `Self::new` 方法中已经解引用，
            // 我们要求 writer 可写引用 Carton，而这里返回值的生命周期和输入的 self 的生命周期对齐，
            // 因此 borrow checker 会强制保证这一点:
            // 直到这个引用被 drop，不能访问 Carton 中的内容
            self.0.as_mut()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，让我们考虑一下我们的<code>Carton</code>是否是 Send 和 Sync。一些东西可以安全地成为 Send，除非它与其他东西共享可变的状态，而不对其实施排他性访问。每个<code>Carton</code>都有一个唯一的指针，所以我们可以标记为 Send：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>// 安全保证：除了我们没有人拥有Carton中的裸指针，因此，只需要T可以Send，Carton就可以Send
unsafe impl&lt;T&gt; Send for Carton&lt;T&gt; where T: Send {}
<span class="boring">}
</span></code></pre></pre>
<p>那么 Sync 呢？为了使<code>Carton</code>能够 Sync，我们必须强制规定，你不能对存储在一个<code>Carton</code>中的东西进行写入，而这个东西可以从另一个<code>Carton</code>中读出或写入。因为你需要一个<code>&amp;mut Carton</code>来写指针，并且借用检查器强制要求可变引用必须是排他的，所以把<code>Carton</code>标记为<code>Sync</code>也没啥问题：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>// 安全保证：存在将 `&amp;Carton&lt;T&gt;` 转变为 `&amp;T` 的公开 API，
// 而这些 API 是 unsynchronized 的（比如 `Deref`），
// 因此只有在T是 `Sync` 的情况下，`Carton&lt;T&gt;` 才可以是 `Sync` 的，
// 反过来说，`Carton` 本身没有使用到任何 `内部可变性`，
// 所有可变引用都只能通过独占的方式获取 (`&amp;mut`)，
// 这也就意味着 `T` 的 `Sync` 特性可以传递给 `Carton&lt;T&gt;`
unsafe impl&lt;T&gt; Sync for Carton&lt;T&gt; where T: Sync  {}
<span class="boring">}
</span></code></pre></pre>
<p>当我们断言我们的类型是 Send 和 Sync 时，我们通常需要强制要求每个包含的类型都是 Send 和 Sync。当编写行为像标准库类型的自定义类型时，我们可以断言我们有相同的要求。例如，下面的代码断言，如果同类的 Box 是 Send，那么 Carton 就是 Send —— 在这种情况下，这就等于说 T 是 Send：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span>unsafe impl&lt;T&gt; Send for Carton&lt;T&gt; where Box&lt;T&gt;: Send {}
<span class="boring">}
</span></code></pre></pre>
<p>现在<code>Carton&lt;T&gt;</code>有一个内存泄漏，因为它从未释放它分配的内存。一旦我们解决了这个问题，我们就必须确保满足 Send 的新要求：我们需要确认<code>free</code>释放由另一个线程的分配产生的指针。我们可以在<a href="https://linux.die.net/man/3/free"><code>libc::free</code></a>的文档中来确认这么做是可行的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Carton&lt;T&gt;(std::ptr::NonNull&lt;T&gt;);
</span><span class="boring">mod libc {
</span><span class="boring">    pub use ::std::os::raw::c_void;
</span><span class="boring">    extern &quot;C&quot; { pub fn free(p: *mut c_void); }
</span><span class="boring">}
</span>impl&lt;T&gt; Drop for Carton&lt;T&gt; {
    fn drop(&amp;mut self) {
        unsafe {
            libc::free(self.0.as_ptr().cast());
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一个不会发生这种情况的好例子是 MutexGuard：注意<a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html#impl-Send">它不是 Send</a>。MutexGuard 的实现<a href="https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326">使用的库</a>要求你确保不会释放你在不同线程中获得的锁。如果你能够将 MutexGuard 发送到另一个线程，那么析构器就会在新的线程中运行，这就违反了该要求。但 MutexGuard 仍然可以是 Sync，因为你能发送给另一个线程的只是一个<code>&amp;MutexGuard</code>，丢弃一个引用并没有什么作用。</p>
<p>TODO: 更好地解释什么可以或不可以是 Send 或 Sync。仅仅针对数据竞争就足够了？</p>
<h1><a class="header" href="#atomics" id="atomics">Atomics</a></h1>
<p>Rust 非常明目张胆地从 C++20 继承了原子的内存模型。这并不是因为这个模型特别优秀或容易理解。事实上，这个模型相当复杂，而且已知有<a href="http://plv.mpi-sws.org/c11comp/popl15.pdf">几个缺陷</a>。但不论怎么说，这是一个务实的让步，因为<em>每个人</em>在原子建模方面都相当糟糕。至少，我们可以从现有的工具和围绕 C/C++ 内存模型的研究中获益（你会经常看到这个模型被称为“C/C++11”或只是“C11”。C 只是复制了 C++ 的内存模型；而 C++11 是该模型的第一个版本，但从那时起它已经得到了一些错误的修正）。</p>
<p>试图在这本书中完全解释这个模型是相当无望的。它被定义为疯狂的因果关系图，需要一整本书来正确理解。如果你想了解所有琐碎的细节，你应该看看<a href="https://en.cppreference.com/w/cpp/atomic/memory_order"> C++ 规范</a>。不过，我们还是会试着介绍一下基础知识和 Rust 开发者面临的一些问题。</p>
<p>C++ 内存模型从根本上说是为了弥补我们想要的语义、编译器想要的优化和我们的硬件想要的之间不一致的混乱之间的差距。<em>我们</em>想只写程序，让它们完全按照我们说的做，但是，你知道，一定要快。那不是很好吗？</p>
<h2><a class="header" href="#编译器重排序" id="编译器重排序">编译器重排序</a></h2>
<p>编译器从根本上希望能够进行各种复杂的转换，以减少数据的依赖性，消除死代码。特别是，他们可能会从根本上改变事件的实际顺序，或者使事件永远不会发生！比如这样的代码：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 1;
y = 3;
x = 2;
</code></pre>
<p>编译器可能会得出结论，如果你的程序这样做，那会更好：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">x = 2;
y = 3;
</code></pre>
<p>这颠倒了事件的顺序，并且完全删除了一个事件。从单线程的角度来看，这是完全无法观察到的：在所有语句执行完毕后，我们处于完全相同的状态。但是如果我们的程序是多线程的，我们可能一直依赖<code>x</code>在<code>y</code>被分配之前实际被分配为 1。我们希望编译器能够进行这类优化，因为它们可以大量地提高性能；而另一方面，我们也希望能够相信我们的程序<em>做我们所说的事情</em>。</p>
<h2><a class="header" href="#硬件重排序" id="硬件重排序">硬件重排序</a></h2>
<p>另一方面，即使编译器完全理解我们的意图并尊重我们的意愿，我们的硬件可能反而会给我们带来麻烦。麻烦来自于 CPU 的内存层次结构。在你的硬件中确实有一个全局共享的内存空间，但从每个 CPU 核心的角度来看，它是<em>非常遥远的</em>，而且<em>非常慢</em>。每个 CPU 宁可使用其本地的数据缓存，而只在其缓存中没有该内存的时候才去和共享内存对话，这是很痛苦的。</p>
<p>毕竟，这就是缓存的全部意义所在，对吗？如果每次从缓存中读出的数据都要跑回共享内存中去仔细检查是否有变化，那还有什么意义呢？最终的结果是，硬件并不能保证在<em>一个</em>线程上以某种顺序发生的事件，在<em>另一个</em>线程上以同样的顺序发生。为了保证这一点，我们必须向 CPU 发出特殊指令，让它变得不那么聪明。</p>
<p>例如，假设我们说服编译器发出这样的逻辑：</p>
<pre><code class="language-text">initial state: x = 0, y = 1

线程 1           线程 2
y = 3;          if x == 1 {
x = 1;              y *= 2;
                }
</code></pre>
<p>理想情况下，这个程序有两种可能的最终状态：</p>
<ul>
<li><code>y = 3</code>：线程 2 在线程 1 完成之前做了检查</li>
<li><code>y = 6</code>：线程 2 在线程 1 完成后做了检查</li>
</ul>
<p>然而，还有第三种潜在的状态是硬件可以实现的：</p>
<ul>
<li><code>y = 2</code>：线程 2 看到了<code>x = 1</code>，但没有看到<code>y = 3</code>，然后改写了<code>y = 3</code></li>
</ul>
<p>值得注意的是，不同种类的 CPU 提供不同的保证。通常将硬件分为两类：强有序和弱有序。最值得注意的是 x86/64 提供强有序保证，而 ARM 提供弱有序保证。这对并发编程有两个后果：</p>
<ul>
<li>在强有序的硬件上要求更强的保证可能很便宜，甚至是无开销的，因为它们已经无条件地提供了强保证；较弱的保证可能只在弱有序的硬件上产生性能优势</li>
<li>在强有序硬件上要求太弱的保证，更有可能<em>恰巧</em>发生作用，即使你的程序严格来说是不正确的；如果可能的话，并发算法应该在弱有序的硬件上进行测试</li>
</ul>
<h2><a class="header" href="#数据访问" id="数据访问">数据访问</a></h2>
<p>C++ 内存模型试图通过允许我们谈论我们程序的<em>因果性</em>来弥补这一差距。一般来说，这是通过在程序的各个部分和运行它们的线程之间建立一种<em>happen-before</em>的关系。这给了硬件和编译器一定的自由度，在没有建立严格的 happen-before 关系的地方更积极地优化程序，但也迫使他们在建立了关系的地方更加小心。我们沟通这些关系的方式是通过<em>数据访问（data accesses）<em>和</em>原子访问（atomic accesses）</em>。</p>
<p>数据访问是编程世界的主体，它们从根本上说是不同步的，编译器可以自由地对它们进行积极的优化。特别是，数据访问可以自由地被编译器重新排序，前提是程序是单线程的。硬件也可以自由地将数据访问中的变化传播给其他线程，只要它想，就可以懒散地、不一致地传播。最关键的是，数据访问是数据竞争发生的方式。数据访问对硬件和编译器非常友好，但正如我们所看到的，如果试图用它来编写同步代码，它提供的语义太弱了。</p>
<p><strong>仅仅使用数据访问是不可能写出正确的同步代码的</strong>。</p>
<p>原子访问是我们告诉硬件和编译器我们的程序是多线程的方式。每个原子访问都可以用一个<em>顺序</em>来标记，指定它与其他访问的关系。在实践中，这可以归结为告诉编译器和硬件它们<em>不能</em>做的某些事情。对于编译器来说，这主要是围绕着指令的重新排序展开的。对于硬件来说，这主要是围绕着如何将写操作传播给其他线程。Rust 所提供的顺序集合是：</p>
<ul>
<li>顺序一致（Squentially Consistent，SeqCst）</li>
<li>Release</li>
<li>Acquire</li>
<li>Relaxed</li>
</ul>
<p>（注意：我们明确地不暴露 C++ 的 <em>consume</em> 排序）</p>
<p>TODO：消极推理与积极推理？TODO：“不能忘记同步”</p>
<h2><a class="header" href="#顺序一致性" id="顺序一致性">顺序一致性</a></h2>
<p>顺序一致是所有顺序中最强大的，它意味着包含所有其他顺序的限制。直观地说，一个顺序一致的操作不能被重新排序：一个线程上所有发生在 SeqCst 访问之前和之后的访问都保持在它之前和之后。一个只使用顺序一致的原子和数据访问的无数据竞争程序有一个非常好的特性，即有一个所有线程都同意的程序指令的单一全局执行的顺序。这种执行方式也特别好推理：它只是每个线程的单独执行的交错。如果你开始使用较弱的原子顺序，这就不成立了（译者注：也就是说，同一时刻，针对同一个别名/内存位置，仅能有一条指令在执行，不能出现并发）。</p>
<p>顺序一致性对开发者的相对友好并不是免费的。即使在强排序的平台上，顺序一致性也会涉及到内存屏障。</p>
<p>在实践中，顺序一致性对于程序的正确性很少有必要。然而，如果你对其他的内存顺序没有信心的话，顺序一致性绝对是正确的选择。让你的程序运行得比它需要的慢一点，肯定比它运行得不正确要好！从机制上来说，降低原子操作的等级，以便在以后拥有较弱的一致性也是很容易的。只要把<code>SeqCst</code>改成<code>Relaxed</code>就可以了! 当然，证明这种转换是<em>正确的</em>是一个完全不同的问题。</p>
<h2><a class="header" href="#acquire-release" id="acquire-release">Acquire-Release</a></h2>
<p>Acquire 和 Release 在很大程度上是用来配对使用的。它们的名字暗示了它们的使用情况：它们非常适合于获取和释放锁，并确保关键部分不会重叠。</p>
<p>直观地说，一个 Acquire 的访问可以确保它之后的每一个访问都保持在它之后。然而，在 Acquire 之前发生的操作可以自由地被重新排序到它之后发生。同样地，一个 Release 访问确保它之前的每一个访问都保持在它之前。然而，在 Release 之后发生的操作可以自由地被重新排序到它之前发生。</p>
<p>当线程 A Release 了内存中的一个位置，然后线程 B 随后 Acquire 了内存中<em>相同</em>的位置，因果关系就建立了。在 A Release 之前发生的每一个写（包括非原子写和 Relaxed 的原子写）都会在 B Acquire 之后被观察到。然而，与任何其他线程的因果关系都没有建立。同样地，如果 A 和 B 访问内存中<em>不同</em>的位置，也不会建立因果关系。</p>
<p>因此，Release-Acquire 的基本用法很简单：你 Acquire 一个内存位置来开始关键部分，然后 Release 这个位置来结束它。例如，一个简单的自旋锁可能看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // 我上锁了吗

    // ... 用某种方式将锁分发到各个线程(thread::spawn) ...

    // 尝试将原子变量设置为 true，以此来获得锁
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // 从循环中跳出，说明此时已经获取了锁

    // ... 恐怖的数据访问 ...

    // 工作完成了，释放锁
    lock.store(false, Ordering::Release);
}
</code></pre></pre>
<p>在强有序平台上，大多数访问都有 Release 或 Acquire 语义，使得 Release 和 Acquire 往往是完全免费的。而在弱有序平台上则不是这样。</p>
<h2><a class="header" href="#relaxed" id="relaxed">Relaxed</a></h2>
<p>Relaxed 的访问是绝对最弱的。它们可以被自由地重新排序，并且不提供任何 happen-before 的关系。不过，Relaxed 的操作仍然是原子性的。也就是说，它们不算是数据访问，对它们进行的任何读-改-写操作都是原子性的。Relaxed 操作适用于那些你肯定希望发生，但并不特别在意的事情。例如，如果你不使用计数器来同步任何其他访问，那么多个线程可以安全地使用 Relaxed 的<code>fetch_add</code>来增加一个计数器。</p>
<p>在强有序平台上，Relaxed 操作很少有好处，因为它们通常提供 Release-Acquire 的语义。然而，在弱有序平台上，Relaxed 的操作会更便宜。</p>
<h1><a class="header" href="#示例实现-vec" id="示例实现-vec">示例：实现 Vec</a></h1>
<p>为了将所有的东西整合起来，我们将从头开始编写<code>std::Vec</code>。我们将限制自己使用稳定的 Rust。特别是我们不会使用任何可以让我们的代码变得更漂亮或更高效的内建指令，因为内建指令是永远不稳定的。尽管许多内建指令<em>确实</em>在其他地方变得稳定了（<code>std::ptr</code>和<code>std::mem</code>由许多内建指令组成）。</p>
<p>最终，这意味着我们的实现可能不会利用所有可能的优化，但它也绝不是<em>简陋</em>的。我们肯定会在细枝末节的细节上钻牛角尖，即使问题并不<em>真的</em>值得这样做。</p>
<p>你想要高级的。我们要的就是高级。</p>
<h1><a class="header" href="#布局" id="布局">布局</a></h1>
<p>首先，我们需要想出结构布局。一个 Vec 有三个部分：一个指向分配的指针，分配的大小，以及已经初始化的元素数量。</p>
<p>直观来说，这意味着我们只需要这样的设计：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct Vec&lt;T&gt; {
    ptr: *mut T,
    cap: usize,
    len: usize,
}
</code></pre>
<p>这确实可以编译成功。但是不幸的是，这有些过于严格了。编译器会给我们太严格的可变性（variance）。比如一个<code>&amp;Vec&lt;&amp;'static str&gt;</code>不能用在预期<code>&amp;Vec&lt;&amp;'a str&gt;</code>的地方。参见<a href="vec/../ownership.html">所有权和生命周期一章</a>中关于可变和 drop checker 的所有细节。</p>
<p>正如我们在所有权一章中看到的，当标准库拥有一个分配对象的原始指针时，它使用<code>Unique&lt;T&gt;</code>来代替<code>*mut T</code>。Unique 是不稳定的，所以如果可能的话，我们希望不要使用它。</p>
<p>简而言之，Unique 是一个原始指针的包装，并声明以下内容：</p>
<ul>
<li>我们对<code>T</code>是协变的</li>
<li>我们可以拥有一个<code>T</code>类型的值（这和我们在这的例子无关，但是可以参考<a href="vec/../phantom-data.html"><code>PhantonData</code></a>那章来看看为什么真正的<code>std::vec::Vec&lt;T&gt;</code>需要这个）</li>
<li>如果<code>T</code>是<code>Send/Sync</code>，我们就是<code>Send/Sync</code>。</li>
<li>我们的指针从不为空（所以<code>Option&lt;Vec&lt;T&gt;&gt;</code>是空指针优化的）</li>
</ul>
<p>我们可以在稳定的 Rust 中实现上述所有的要求。为此，我们不使用<code>Unique&lt;T&gt;</code>，而是使用<a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a>，这是对原始指针的另一种包装，它为我们提供了上述的两个属性，即它在<code>T</code>上是协变的，并且被声明为永不为空。通过在<code>T</code>是<code>Send/Sync</code>的情况下实现<code>Send/Sync</code>，我们得到与使用<code>Unique&lt;T&gt;</code>相同的结果：</p>
<pre><pre class="playground"><code class="language-rust">use std::ptr::NonNull;

pub struct Vec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
    len: usize,
}

unsafe impl&lt;T: Send&gt; Send for Vec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for Vec&lt;T&gt; {}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h1><a class="header" href="#分配内存" id="分配内存">分配内存</a></h1>
<p>使用<code>NonNull</code>会给 Vec（甚至是所有的 std collections）的一个重要特性带来麻烦：创建一个空的 Vec 实际上根本就没有分配。这与分配一个零大小的内存块不同，因为全局分配器不允许这样做（会导致未定义行为！）。所以，如果我们不能分配，但也不能在<code>ptr</code>里放一个空指针，我们在<code>Vec::new</code>里做什么？好吧，我们只是在里面放一些其他的垃圾值。</p>
<p>这并不会有问题，因为我们已经有了<code>cap == 0</code>作为尚未分配的哨兵。我们甚至不需要在任何代码中特别处理它，因为我们通常需要检查<code>cap &gt; len</code>或<code>len &gt; 0</code>。在这里，Rust 推荐使用的值是<code>mem::align_of::&lt;T&gt;()</code>。<code>NonNull</code>为此提供了一个便利。<code>NonNull::dangling()</code>。有相当多的地方我们会想使用<code>dangling</code>，因为没有真正的分配可言，但<code>null</code>会让编译器做坏事。</p>
<p>所以，代码如下：</p>
<!-- ignore: explanation code -->
<pre><code class="language-rust ignore">use std::mem;

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;We're not ready to handle ZSTs&quot;);
        Vec {
            ptr: NonNull::dangling(),
            len: 0,
            cap: 0,
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre>
<p>我在这里使用了断言，是因为零大小的类型需要在我们的代码中进行一些特殊的处理，我想把这个问题暂时延后。如果没有这个断言，我们早期的一些实现会导致一些非常糟糕的事情。</p>
<p>接下来，我们需要弄清楚，当我们<em>确实</em>想要分配内存时，究竟该怎么做。为此，我们使用全局分配函数<a href="https://doc.rust-lang.org/alloc/alloc/fn.alloc.html"><code>alloc</code></a>、<a href="https://doc.rust-lang.org/alloc/alloc/fn.realloc.html"><code>realloc</code></a>和<a href="https://doc.rust-lang.org/alloc/alloc/fn.dealloc.html"><code>dealloc</code></a>，这些函数在稳定的 Rust 中可以使用<a href="https://doc.rust-lang.org/alloc/alloc/index.html"><code>std::alloc</code></a>。在<a href="https://doc.rust-lang.org/std/alloc/struct.Global.html"><code>std::alloc::Global</code></a>类型稳定后，这些函数将被废弃。</p>
<p>我们还需要一种方法来处理内存不足（OOM）的情况。标准库提供了一个函数<a href="https://doc.rust-lang.org/alloc/alloc/fn.handle_alloc_error.html"><code>alloc::handle_alloc_error</code></a>，它将以特定平台的方式中止程序。我们选择中止而不是 panic 的原因是，unwinding 会导致分配的发生，而当你的分配器刚刚回来说“嘿，我没有更多的内存了”时，这似乎是一件坏事。</p>
<p>当然，这看起来有点蠢，因为大多数平台实际上不会以传统方式耗尽内存。如果你顺理成章地用完了所有的内存，你的操作系统可能会通过其他方式杀死这个应用程序。我们最有可能触发 OOM 的方式是一次性要求大量的内存（例如，理论地址空间的一半）。因此，panic <em>可能</em>是没问题的，不会发生什么坏事。不过，我们还是想尽可能地像标准库一样，所以我们就把整个程序杀掉。</p>
<p>好了，现在我们可以写 grow 的代码了，简单来说，逻辑应该是这样的：</p>
<pre><code class="language-text">if cap == 0:
    allocate()
    cap = 1
else:
    reallocate()
    cap *= 2
</code></pre>
<p>但是 Rust 唯一支持的分配器 API 太低级了，我们需要做相当多的额外工作。我们还需要防范一些特殊情况，这些情况可能发生在真正的大分配或空分配中。</p>
<p>特别是，<code>ptr::offset</code>会给我们带来很多麻烦，因为它有 LLVM 的 GEP（译者注：<a href="https://llvm.org/docs/LangRef.html#getelementptr-instruction">GetElementPtr</a>） inbounds 指令的语义。如果你有幸没有处理过这个指令，这里是 GEP 的大致故事：别名分析、别名分析、别名分析！对于一个优化的编译器来说，能够推理出数据的依赖性和别名是超级重要的。</p>
<p>作为一个简单的例子，考虑下面的代码片段：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">*x *= 7;
*y *= 3;
</code></pre>
<p>如果编译器能够证明<code>x</code>和<code>y</code>指向内存中的不同位置，理论上这两个操作可以并行执行（例如将它们加载到不同的寄存器中，并对它们独立工作）。然而，编译器在一般情况下不能这样做，因为如果 x 和 y 指向内存中的同一位置，操作需要对相同的值进行，而且它们不能在事后被合并。</p>
<p>当你使用 GEP inbounds 时，你就是在明确地告诉 LLVM，你要做的偏移是在一个“已分配”对象的范围内（within the bounds of a single &quot;allocated&quot; entity.）。这达到的效果是，LLVM 可以假设，如果两个指针已知指向两个不相干的对象，那么这些指针的所有偏移量<em>也</em>被认为不会导致别名（因为你不会在内存中的某个随机地方结束）。LLVM 对 GEP 的偏移量进行了大量的优化，而界内偏移量（inbounds offsets）是所有偏移量中最好的，所以我们尽可能地使用它们是很重要的。</p>
<p>这是 GEP 的作用，它怎么会给我们带来麻烦呢？</p>
<p>第一个问题是，我们用无符号的整数来索引数组，但是 GEP（以及由此产生的<code>ptr::offset</code>）需要一个有符号的整数。这意味着一半的看似有效的数组索引会溢出 GEP，并且在实际上是走错了方向！因此，我们必须将所有的分配限制在<code>isize::MAX</code>元素。这实际上意味着我们只需要担心字节大小的对象，因为例如<code>&gt; isize::MAX``u16</code>s 将真正耗尽系统的所有内存。然而，为了避免出现微妙的边界情况，即有人将一些<code>&lt; isize::MAX</code>对象的数组重新解释为字节，std 将所有分配限制为<code>isize::MAX</code>字节。</p>
<p>在 Rust 目前支持的所有 64 位平台上，我们被人为地限制在明显少于所有 64 位的地址空间（现代 x64 平台只暴露了 48 位寻址），所以我们可以依靠首先耗尽内存。然而，在 32 位目标上，特别是那些有扩展使用更多地址空间的目标（PAE x86 或 x32），理论上是可以成功分配超过<code>isize::MAX</code>字节的内存的。</p>
<p>然而，由于这是一个教程，我们在这里不会特别优化，只是无条件地检查，而不是使用聪明的平台特定的<code>cfg</code>s。</p>
<p>我们需要担心的另一个情况是空分配。我们需要担心两种空分配的情况。对于任意 T：<code>cap = 0</code>；和对于零大小的类型（zero-sized types）<code>cap &gt; 0</code>。</p>
<p>这些情况很棘手，因为它们归结于 LLVM 对“分配”的理解。LLVM 的分配概念要比我们通常使用的方式抽象得多。因为 LLVM 需要与不同语言的语义和自定义分配器一起工作，所以它不能真正深入地理解分配。相反，分配背后的主要想法是“不与其他东西重叠”。也就是说，堆分配、栈分配和 globals 不会随机地重叠在一起。没错，这就是别名分析。因此，Rust 在技术上可以对分配的概念做一些快速和松散的处理，只要它是<em>一致的</em>。</p>
<p>回到空分配的情况，有几个地方我们想用 0 来抵消，这是通用代码的结果。那么问题来了：这样做是否一致？对于零大小的类型，我们的结论是，用任意数量的元素进行 GEP 界内偏移确实是一致的。这是一个运行时的无用功，因为每个元素都不占用空间，假装在<code>0x01</code>处有无限的零尺寸类型分配也是可以的。没有分配器会分配这个地址，因为他们不会分配<code>0x00</code>，而且他们一般会分配到高于一个字节的最小对齐。另外，一般来说，整个第一页的内存是被保护的，不会被分配（在许多平台上，是整个 4k）。</p>
<p>然而，对于正值大小的类型怎么办呢？这个问题就有点棘手了。原则上，你可以说 0 的偏移量没有给 LLVM 带来任何信息：要么地址之前有一个元素，要么在它之后，但它不能知道是哪个。然而，我们选择了保守的假设，即它可能会做坏事。因此，我们将明确地防止这种情况。</p>
<p><em>呼</em>。</p>
<p>好了，说了这么多废话，让我们实际分配一些内存吧：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::alloc::{self, Layout};

impl&lt;T&gt; Vec&lt;T&gt; {
    fn grow(&amp;mut self) {
        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1).unwrap())
        } else {
            // 因为 self.cap &lt;= isize::MAX，所以不会溢出
            let new_cap = 2 * self.cap;

            // `Layout::array` 会检查申请的空间是否小于等于 usize::MAX，
            // 但是因为 old_layout.size() &lt;= isize::MAX，
            // 所以这里的 unwrap 永远不可能失败
            let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();
            (new_cap, new_layout)
        };

        // 保证新申请的内存没有超出 `isize::MAX` 字节的大小
        assert!(new_layout.size() &lt;= isize::MAX as usize, &quot;Allocation too large&quot;);

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 如果分配失败，`new_ptr` 就会成为空指针，我们需要对应 abort 的操作
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}
<span class="boring">fn main() {}
</span></code></pre>
<h1><a class="header" href="#push-和-pop" id="push-和-pop">Push 和 Pop</a></h1>
<p>好了，我们现在可以初始化，也可以分配了。让我们实际实现一些功能吧! 让我们从<code>push</code>开始。它所需要做的就是检查我们是否已经满了并 grow，然后无条件地写到下一个索引，接着增加我们的长度。</p>
<p>在写入时，我们必须注意不要对我们想要写入的内存做解引用。最坏的情况是，它是来自分配器的真正未初始化的内存（里面是垃圾值）。最好的情况是，它是我们 pop 出的一些旧值的地址。无论是哪种情况，我们都不能索引到那个地址并解引用，因为这将把该内存认为是一个 T 类型的存活的实例；更糟的是，<code>foo[idx] = x</code>会试图在<code>foo[idx]</code>的旧值上调用<code>drop</code>!</p>
<p>正确的方法是使用<code>ptr::write</code>，它只是盲目地用我们提供的值的位来覆盖目标地址，而不会对该地址做解引用。</p>
<p>对于<code>push</code>，如果旧的 len（在 push 被调用之前）是 0，那么我们正好想写到第 0 个索引，所以我们应该用旧的 len 来作为写入的索引。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn push(&amp;mut self, elem: T) {
    if self.len == self.cap { self.grow(); }

    unsafe {
        ptr::write(self.ptr.as_ptr().add(self.len), elem);
    }

    // 不可能出错，因为出错之前一定会 OOM(out of memory)
    self.len += 1;
}
</code></pre>
<p>是不是很简单! 那么<code>pop</code>呢？虽然这次我们要访问的索引被初始化了，但 Rust 不会让我们直接解构内存的位置来把实例移动（move）出去，因为这将使内存未被初始化（译者注：和 push 一样，如果 pop 出的是在 Vec 的内存中的值，那么当这个值被丢弃后，Vec 的这块内存会被 drop，这就出大事了）! 为此我们需要<code>ptr::read</code>，它只是从目标地址复制出 bit，并将其解释为 T 类型的值。这将使这个地址的内存在逻辑上未被初始化，尽管事实上那里有一个完美的 T 的实例。</p>
<p>对于<code>pop</code>，举个例子，如果旧的 len 是 1，那我们正好想从第 0 个索引中读出，所以我们应该用新的 len 来作为读出的索引。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    if self.len == 0 {
        None
    } else {
        self.len -= 1;
        unsafe {
            Some(ptr::read(self.ptr.as_ptr().add(self.len)))
        }
    }
}
</code></pre>
<h1><a class="header" href="#释放内存" id="释放内存">释放内存</a></h1>
<p>接下来我们应该实现 Drop，这样我们就不会大规模地泄漏大量的资源。最简单的方法是直接调用<code>pop</code>，直到它产生 None，然后再释放我们的 buffer。注意，如果<code>T: !Drop</code>的话，调用<code>pop</code>是不需要的。理论上，我们可以询问 Rust 是否<code>T</code> <code>need_drop</code>并省略对<code>pop</code>的调用。然而在实践中，LLVM 在做类似这样的简单的无副作用的删除代码方面<em>非常</em>好，所以我就省得麻烦了，除非你注意到它没有被优化掉（在这种情况下它被优化了）。</p>
<p>要注意的是，当<code>self.cap == 0</code>时，我们不能调用<code>alloc::dealloc</code>，因为在这种情况下我们实际上没有分配任何内存。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            while let Some(_) = self.pop() { }
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#deref" id="deref">Deref</a></h1>
<p>好了！我们已经实现了一个基本像样的栈。我们可以 push 和 pop，我们还可以自己 drop。然而，我们还需要一大堆的功能。特别是， 尽管我们有了一个合适的数组，但还没有切片的功能。这其实很容易解决：我们可以实现<code>Deref&lt;Target=[T]&gt;</code>。这将神奇地使我们的 Vec 在各种条件下强制成为一个切片，并且表现得像一个切片。</p>
<p>我们只需要<code>slice::from_raw_parts</code>。它将为我们正确处理空切片。之后当我们设置了零大小的类型支持，它也会对这些类型进行正确的处理。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe {
            std::slice::from_raw_parts(self.ptr.as_ptr(), self.len)
        }
    }
}
</code></pre>
<p>还有 DerefMut：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::DerefMut;

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe {
            std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len)
        }
    }
}
</code></pre>
<p>现在我们有了<code>len</code>、<code>first</code>、<code>last</code>、索引、切片、排序、<code>iter</code>、<code>iter_mut</code>，以及 slice 提供的其他各种功能啦！</p>
<h1><a class="header" href="#插入和删除" id="插入和删除">插入和删除</a></h1>
<p>slice <em>不</em>提供的东西是<code>insert</code>和<code>remove</code>，所以我们接下来做这些。</p>
<p>insert 需要将目标索引的所有元素向右移动一个。要做到这一点，我们需要使用<code>ptr::copy</code>，它是 C 语言<code>memmove</code>的 Rust 版本。它将一些内存块从一个位置复制到另一个位置，正确处理源和目标重叠的情况（这在这里肯定会发生）。</p>
<p>如果我们在索引<code>i</code>处插入，我们要使用旧的 len 将<code>[i ... len]</code>转移到<code>[i+1 ... len+1]</code>。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn insert(&amp;mut self, index: usize, elem: T) {
    // 注意：`&lt;=` 是因为我们可以把值插入到任何索引范围 ([0,length-1]) 内的位置之后
    // 这种情况等同于 push
    assert!(index &lt;= self.len, &quot;index out of bounds&quot;);
    if self.len == self.cap { self.grow(); }

    unsafe {
        // ptr::copy(src, dest, len) 的含义： &quot;从 src 复制连续的 len 个元素到 dst &quot;
        ptr::copy(
            self.ptr.as_ptr().add(index),
            self.ptr.as_ptr().add(index + 1),
            self.len - index,
        );
        ptr::write(self.ptr.as_ptr().add(index), elem);
    }

    self.len += 1;
}
</code></pre>
<p>remove 的行为方式正好相反。我们需要将所有的元素从<code>[i+1 ... len + 1]</code>转移到<code>[i ... len]</code>，使用<em>新的</em> len。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub fn remove(&amp;mut self, index: usize) -&gt; T {
    // 注意：使用 `&lt;` 是因为 index 不能删除超出元素下标的范围
    assert!(index &lt; self.len, &quot;index out of bounds&quot;);
    unsafe {
        self.len -= 1;
        let result = ptr::read(self.ptr.as_ptr().add(index));
        ptr::copy(
            self.ptr.as_ptr().add(index + 1),
            self.ptr.as_ptr().add(index),
            self.len - index,
        );
        result
    }
}
</code></pre>
<h1><a class="header" href="#intoiter" id="intoiter">IntoIter</a></h1>
<p>让我们继续，接下来写迭代器。<code>iter</code>和<code>iter_mut</code>已经为我们写好了，感谢 Deref 的魔法。然而，有两个有趣的迭代器是 Vec 提供的，而 slice 不能提供：<code>into_iter</code>和<code>drain</code>。</p>
<p>IntoIter 通过消耗掉 Vec 的值（获取 Vec 的所有权），并因此可以产生其元素的值（所有权）。为了实现这个目的，IntoIter 需要控制 Vec 的分配。</p>
<p>IntoIter 也需要是 DoubleEnded，以便能够从两端读取。从后面读取可以通过调用<code>pop</code>来实现，但是从前面读取就比较困难了。我们可以调用<code>remove(0)</code>，但这将是非常昂贵的。相反，我们将使用<code>ptr::read</code>来复制 Vec 两端的值，而不改变缓冲区。</p>
<p>为了做到这一点，我们将使用一个非常常见的 C 语言的数组迭代习惯。我们将建立两个指针；一个指向数组的开始，另一个指向数组结束后的一个元素。当我们想从一端获得一个元素时，我们将读出指向那一端的值，并将指针移到另一端。当这两个指针相等时，我们就知道我们已经完成了。</p>
<p>注意，对于<code>next</code>和<code>next_back</code>来说，读取和偏移的顺序是相反的。对于<code>next_back</code>来说，指针总是在它想读取的元素之后，而对于<code>next</code>来说，指针正好在它想读取的元素上。要想知道为什么会这样，请考虑除一个元素外的所有元素都已经产生的情况。</p>
<p>这个数组看起来像这样：</p>
<pre><code class="language-text">          S  E
[X, X, X, O, X, X, X]
</code></pre>
<p>如果 E 直接指向它想产生的下一个元素，它将与没有更多元素可以产生的情况没有区别。</p>
<p>虽然我们在迭代过程中实际上并不关心它，但我们也需要保留 Vec 的分配信息，以便在 IntoIter 被丢弃后释放它。</p>
<p>所以我们将使用下面的结构。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    buf: NonNull&lt;T&gt;,
    cap: usize,
    start: *const T,
    end: *const T,
}
</code></pre>
<p>而这就是我们最终的初始化结果：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // 确保 Vec 不会被 drop，因为那样会释放内存
        let vec = ManuallyDrop::new(self);

        // 因为 Vec 实现了 Drop，所以我们不能销毁它
        let ptr = vec.ptr;
        let cap = vec.cap;
        let len = vec.len;

        IntoIter {
            buf: ptr,
            cap,
            start: ptr.as_ptr(),
            end: if cap == 0 {
                // 不能通过这个指针获取偏移，因为没有分配内存
                ptr.as_ptr()
            } else {
                unsafe { ptr.as_ptr().add(len) }
            },
        }
    }
}
</code></pre>
<p>向前迭代：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                let result = ptr::read(self.start);
                self.start = self.start.offset(1);
                Some(result)
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let len = (self.end as usize - self.start as usize)
                  / mem::size_of::&lt;T&gt;();
        (len, Some(len))
    }
}
</code></pre>
<p>向后迭代：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                self.end = self.end.offset(-1);
                Some(ptr::read(self.end))
            }
        }
    }
}
</code></pre>
<p>因为 IntoIter 拥有其分配的所有权，它需要实现 Drop 来释放它；并且，它也需要在 Drop 里丢弃它所包含的任何没有被迭代到的元素。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            // 将剩下的元素 drop
            for _ in &amp;mut *self {}
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.buf.as_ptr() as *mut u8, layout);
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#rawvec" id="rawvec">RawVec</a></h1>
<p>我们实际上在这里达到了一个有趣的状态：我们在 Vec 和 IntoIter 中重复了指定缓冲区和释放其内存的逻辑。现在我们已经实现了它，并且确定了<em>实际的</em>逻辑重复，这是一个进行一些逻辑压缩的好时机。</p>
<p>我们将抽象出<code>(ptr, cap)</code>对，并为它们编写分配、增长和释放的逻辑：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct RawVec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
}

unsafe impl&lt;T: Send&gt; Send for RawVec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for RawVec&lt;T&gt; {}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;TODO: implement ZST support&quot;);
        RawVec {
            ptr: NonNull::dangling(),
            cap: 0,
        }
    }

    fn grow(&amp;mut self) {
        // 保证新申请的内存没有超出 `isize::MAX` 字节
        let new_cap = if self.cap == 0 { 1 } else { 2 * self.cap };

        // `Layout::array` 会检查申请的空间是否小于等于 usize::MAX，
        // 但是因为 old_layout.size() &lt;= isize::MAX，
        // 所以这里的 unwrap 永远不可能失败
        let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();

        // 保证新申请的内存没有超出 `isize::MAX` 字节
        assert!(new_layout.size() &lt;= isize::MAX as usize, &quot;Allocation too large&quot;);

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 如果分配失败，`new_ptr` 就会成为空指针，我们需要对应 abort 的操作
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        if self.cap != 0 {
            let layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}
</code></pre>
<p>随后，把 Vec 改成这样：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T {
        self.buf.ptr.as_ptr()
    }

    fn cap(&amp;self) -&gt; usize {
        self.buf.cap
    }

    pub fn new() -&gt; Self {
        Vec {
            buf: RawVec::new(),
            len: 0,
        }
    }

    // push/pop/insert/remove 这些操作做了小小的改变，如下所示:
    // * `self.ptr.as_ptr() -&gt; self.ptr()`
    // * `self.cap -&gt; self.cap()`
    // * `self.grow() -&gt; self.buf.grow()`
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // RawVec 来负责释放内存
    }
}
</code></pre>
<p>最后，我们可以把 IntoIter 改得相当简单：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, // 我们实际上并不关心这个，只需要他们保证分配的空间不被释放
    start: *const T,
    end: *const T,
}

// next 和 next_back 保持不变，因为它们并没有用到 buf

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        // 我们只需要确保 Vec 中所有元素都被读取了，
        // 在这之后这些元素会被自动清理
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        // 需要使用 ptr::read 非安全地把 buf 移出，因为它没有实现 Copy，
        // 而且 Vec 实现了 Drop Trait (因此我们不能销毁它)
        let buf = unsafe { ptr::read(&amp;self.buf) };
        let len = self.len;
        mem::forget(self);

        IntoIter {
            start: buf.ptr.as_ptr(),
            end: if buf.cap == 0 {
                // 不能通过这个指针获取偏移，除非已经分配了内存
                buf.ptr.as_ptr()
            } else {
                unsafe { buf.ptr.as_ptr().add(len) }
            },
            _buf: buf,
        }
    }
}
</code></pre>
<p>是不是好多了！</p>
<h1><a class="header" href="#drain-1" id="drain-1">Drain</a></h1>
<p>接下来，让我们来实现 Drain。 Drain 与 IntoIter 大体上相同，只是它不是消耗 Vec，而是借用 Vec，并且不会修改到其分配。现在我们只实现“基本”的全范围版本。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::marker::PhantomData;

struct Drain&lt;'a, T: 'a&gt; {
    // 这里需要限制生命周期, 因此我们使用了 `&amp;'a mut Vec&lt;T&gt;`，
    // 也就是我们语义上包含的内容，
    // 我们只会调用 `pop()` 和 `remove(0)` 两个方法
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    start: *const T,
    end: *const T,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
</code></pre>
<p>——等等，这看着好像很眼熟？IntoIter 和 Drain 有完全相同的结构，让我们再做一些抽象：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    // 构建 RawValIter 是不安全的，因为它没有关联的生命周期，
    // 将 RawValIter 存储在与它实际分配相同的结构体中是非常有必要的，
    // 但这里是具体的实现细节，不用对外公开
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if slice.len() == 0 {
                // 如果 `len = 0`, 说明没有分配内存，需要避免使用 offset，
                // 因为那样会给 LLVM 的 GEP 传递错误的信息
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            }
        }
    }
}

// Iterator 和 DoubleEndedIterator 和 IntoIter 实现起来很类似
</code></pre>
<p>IntoIter 我们可以改成这样：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        unsafe {
            let iter = RawValIter::new(&amp;self);

            let buf = ptr::read(&amp;self.buf);
            mem::forget(self);

            IntoIter {
                iter,
                _buf: buf,
            }
        }
    }
}
</code></pre>
<p>请注意，我在这个设计中留下了一些奇怪之处，以使升级 Drain 来处理任意的子范围更容易一些。特别是我们<em>可以</em>让 RawValIter 在 drop 时 drain 自身，但这对更复杂的 Drain 来说是不合适的。我们还使用了一个 slice 来简化 Drain 的初始化。</p>
<p>好了，现在实现 Drain 真的很容易了：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::marker::PhantomData;

pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

impl&lt;T&gt; Vec&lt;T&gt; {
    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        let iter = unsafe { RawValIter::new(&amp;self) };

        // 这里事关 mem::forget 的安全。
        // 如果 Drain 被 forget，我们就会泄露整个 Vec 的内存，
        // 既然我们始终要做这一步，为何不在这里完成呢？
        self.len = 0;

        Drain {
            iter: iter,
            vec: PhantomData,
        }
    }
}
</code></pre>
<p>关于<code>mem::forget</code>问题的更多细节，参见<a href="vec/../leaking.html">关于泄漏的章节</a>。</p>
<h1><a class="header" href="#处理零大小的类型" id="处理零大小的类型">处理零大小的类型</a></h1>
<p>是时候了！我们将与 ZST（零大小类型）这个幽灵作斗争。安全的 Rust 从来不需要关心这个问题，但是 Vec 在原始指针和原始分配上非常密集，这正是需要关心零尺寸类型的两种情况。我们需要注意两件事：</p>
<ul>
<li>如果你在分配大小上传入 0，原始分配器 API 有未定义的行为。</li>
<li>原始指针偏移量对于零大小的类型来说是无效的（no-ops），这将破坏我们的 C 风格指针迭代器。</li>
</ul>
<p>幸好我们之前把指针迭代器和分配处理分别抽象为<code>RawValIter</code>和<code>RawVec</code>。现在回过头来看，多么的方便啊。</p>
<h2><a class="header" href="#分配零大小的类型" id="分配零大小的类型">分配零大小的类型</a></h2>
<p>那么，如果分配器 API 不支持零大小的分配，我们到底要把什么作为我们的分配来存储呢？当然是<code>NonNull::dangling()</code>! 几乎所有使用 ZST 的操作都是 no-op，因为 ZST 正好有且仅有一个值，因此在存储或加载它们时不需要考虑状态。这实际上延伸到了<code>ptr::read</code>和<code>ptr::write</code>：它们实际上根本不会去用指针。因此，我们从来不需要改变指针。</p>
<p>然而，请注意，我们之前对在溢出前耗尽内存的防御，在零大小的类型中不再有效了。我们必须明确地防止零大小类型的容量溢出。</p>
<p>由于我们目前的架构，这意味着要写 3 个边界处理，在<code>RawVec</code>的每个方法中都有一个：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        // 这一段分支代码在编译期间就可以计算出结果返回的结果，返回给 cap
        let cap = if mem::size_of::&lt;T&gt;() == 0 { usize::MAX } else { 0 };

        // `NonNull::dangling()` 有双重含义:
        // `未分配内存 (unallocated)`, `零尺寸 (zero-sized allocation)`
        RawVec {
            ptr: NonNull::dangling(),
            cap: cap,
        }
    }

    fn grow(&amp;mut self) {
        // 因为当 T 的尺寸为 0 时我们设置了 cap 为 usize::MAX
        // 这一步成立意味着 Vec 溢出了
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;capacity overflow&quot;);

        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1).unwrap())
        } else {
            // 保证新申请的内存没有超出 `isize::MAX` 字节
            let new_cap = 2 * self.cap;

            // `Layout::array` 会检查申请的空间是否小于等于 usize::MAX，
            // 但是因为 old_layout.size() &lt;= isize::MAX，
            // 所以这里的 unwrap 永远不可能失败
            let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();
            (new_cap, new_layout)
        };

        // 保证新申请的内存没有超出 `isize::MAX` 字节
        assert!(new_layout.size() &lt;= isize::MAX as usize, &quot;Allocation too large&quot;);

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 如果分配失败，`new_ptr` 就会成为空指针，我们需要处理这个意外情况
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        if self.cap != 0 &amp;&amp; elem_size != 0 {
            unsafe {
                alloc::dealloc(
                    self.ptr.as_ptr() as *mut u8,
                    Layout::array::&lt;T&gt;(self.cap).unwrap(),
                );
            }
        }
    }
}
</code></pre>
<p>搞定！我们现在支持 push 和 pop 零大小类型。不过，我们的迭代器（不是由 slice Deref 提供的）仍然是一团浆糊。</p>
<h2><a class="header" href="#迭代-zst" id="迭代-zst">迭代 ZST</a></h2>
<p>零大小的偏移量是 no-op。这意味着我们目前的设计总是将<code>start</code>和<code>end</code>初始化为相同的值，而我们的迭代器将一无所获。目前的解决方案是将指针转为整数，增加，然后再转回。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            },
        }
    }
}
</code></pre>
<p>现在，我们有了另一个 bug：我们的迭代器不再是完全不运行，而是现在的迭代器<em>永远</em>都在运行。我们需要在我们的迭代器 impls 中做同样的技巧。另外，我们的 size_hint 计算代码将对 ZST 除以 0。既然我们会把这两个指针当作是指向字节的，所以我们就把大小 0 映射到除以 1，这样的话<code>next</code>的代码如下：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
    if self.start == self.end {
        None
    } else {
        unsafe {
            let result = ptr::read(self.start);
            self.start = if mem::size_of::&lt;T&gt;() == 0 {
                (self.start as usize + 1) as *const _
            } else {
                self.start.offset(1)
            };
            Some(result)
        }
    }
}
</code></pre>
<p>你找到 bug 了嘛？没人看到！连最初的作者也是几年之后闲逛这个页面的时候，觉得这段代码比较可疑，因为这里直接滥用了迭代器的指针当作了<em>计数器</em>，而这就使得了指针不对齐！在使用 ZST 的时候，我们<em>唯一的工作</em>就是必须保证指针对齐！<em>啊这</em>！</p>
<p>原始指针在任何时候都不需要对齐，所以使用指针作为计数器的基本技巧是<em>没问题的</em>，但是当它们被传递给<code>ptr::read</code>时，它们<em>应该</em>是对齐的! 这<em>可能</em>是不必要的迂腐操作，因为<code>ptr::read</code>在处理 ZST 时其实是个 noop，但让我们<em>稍微</em>负责一点，当遇到 ZST 时从<code>NonNull::dangling</code>读取。</p>
<p>（或者你也可以在 ZST 路径上调用<code>read_unaligned</code>。两者都可以。因为无论哪种方式，我们都是在无中生有，而且都最终编译成 noop。）</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.start = (self.start as usize + 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    let old_ptr = self.start;
                    self.start = self.start.offset(1);
                    Some(ptr::read(old_ptr))
                }
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.end = (self.end as usize - 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    self.end = self.end.offset(-1);
                    Some(ptr::read(self.end))
                }
            }
        }
    }
}
</code></pre>
<p>好啦，迭代器也搞定啦！</p>
<h1><a class="header" href="#最终的代码" id="最终的代码">最终的代码</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::alloc::{self, Layout};
use std::marker::PhantomData;
use std::mem;
use std::ops::{Deref, DerefMut};
use std::ptr::{self, NonNull};

struct RawVec&lt;T&gt; {
    ptr: NonNull&lt;T&gt;,
    cap: usize,
}

unsafe impl&lt;T: Send&gt; Send for RawVec&lt;T&gt; {}
unsafe impl&lt;T: Sync&gt; Sync for RawVec&lt;T&gt; {}

impl&lt;T&gt; RawVec&lt;T&gt; {
    fn new() -&gt; Self {
        // !0 等价于 usize::MAX， 这一段分支代码在编译期间就可以计算出结果返回的结果，返回给 cap
        let cap = if mem::size_of::&lt;T&gt;() == 0 { !0 } else { 0 };

        // `NonNull::dangling()` 有双重含义:
        // `未分配内存 (unallocated)`, `零尺寸 (zero-sized allocation)`
        RawVec {
            ptr: NonNull::dangling(),
            cap: cap,
        }
    }

    fn grow(&amp;mut self) {
        // 因为当 T 的尺寸为 0 时，我们设置了 cap 为 usize::MAX，
        // 这一步成立便意味着 Vec 溢出了.
        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;capacity overflow&quot;);

        let (new_cap, new_layout) = if self.cap == 0 {
            (1, Layout::array::&lt;T&gt;(1).unwrap())
        } else {
            // 保证新申请的内存没有超出 `isize::MAX` 字节
            let new_cap = 2 * self.cap;

            // `Layout::array` 会检查申请的空间是否小于等于 usize::MAX，
            // 但是因为 old_layout.size() &lt;= isize::MAX，
            // 所以这里的 unwrap 永远不可能失败
            let new_layout = Layout::array::&lt;T&gt;(new_cap).unwrap();
            (new_cap, new_layout)
        };

        // 保证新申请的内存没有超出 `isize::MAX` 字节
        assert!(
            new_layout.size() &lt;= isize::MAX as usize,
            &quot;Allocation too large&quot;
        );

        let new_ptr = if self.cap == 0 {
            unsafe { alloc::alloc(new_layout) }
        } else {
            let old_layout = Layout::array::&lt;T&gt;(self.cap).unwrap();
            let old_ptr = self.ptr.as_ptr() as *mut u8;
            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }
        };

        // 如果分配失败，`new_ptr` 就会成为空指针，我们需要处理该意外情况
        self.ptr = match NonNull::new(new_ptr as *mut T) {
            Some(p) =&gt; p,
            None =&gt; alloc::handle_alloc_error(new_layout),
        };
        self.cap = new_cap;
    }
}

impl&lt;T&gt; Drop for RawVec&lt;T&gt; {
    fn drop(&amp;mut self) {
        let elem_size = mem::size_of::&lt;T&gt;();

        if self.cap != 0 &amp;&amp; elem_size != 0 {
            unsafe {
                alloc::dealloc(
                    self.ptr.as_ptr() as *mut u8,
                    Layout::array::&lt;T&gt;(self.cap).unwrap(),
                );
            }
        }
    }
}

pub struct Vec&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: usize,
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn ptr(&amp;self) -&gt; *mut T {
        self.buf.ptr.as_ptr()
    }

    fn cap(&amp;self) -&gt; usize {
        self.buf.cap
    }

    pub fn new() -&gt; Self {
        Vec {
            buf: RawVec::new(),
            len: 0,
        }
    }
    pub fn push(&amp;mut self, elem: T) {
        if self.len == self.cap() {
            self.buf.grow();
        }

        unsafe {
            ptr::write(self.ptr().add(self.len), elem);
        }

        // 不会溢出，会先 OOM
        self.len += 1;
    }

    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            unsafe { Some(ptr::read(self.ptr().add(self.len))) }
        }
    }

    pub fn insert(&amp;mut self, index: usize, elem: T) {
        assert!(index &lt;= self.len, &quot;index out of bounds&quot;);
        if self.len == self.cap() {
            self.buf.grow();
        }

        unsafe {
            ptr::copy(
                self.ptr().add(index),
                self.ptr().add(index + 1),
                self.len - index,
            );
            ptr::write(self.ptr().add(index), elem);
        }

        self.len += 1;
    }

    pub fn remove(&amp;mut self, index: usize) -&gt; T {
        assert!(index &lt; self.len, &quot;index out of bounds&quot;);

        self.len -= 1;

        unsafe {
            let result = ptr::read(self.ptr().add(index));
            ptr::copy(
                self.ptr().add(index + 1),
                self.ptr().add(index),
                self.len - index,
            );
            result
        }
    }

    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {
        let iter = unsafe { RawValIter::new(&amp;self) };

        // 这里事关 mem::forget 的安全。
        // 如果 Drain 被 forget，我们就会泄露整个 Vec 的内存
        // 既然我们始终要做这一步，为何不在这里完成呢？
        self.len = 0;

        Drain {
            iter: iter,
            vec: PhantomData,
        }
    }
}

impl&lt;T&gt; Drop for Vec&lt;T&gt; {
    fn drop(&amp;mut self) {
        while let Some(_) = self.pop() {}
        // RawVec 来负责释放内存
    }
}

impl&lt;T&gt; Deref for Vec&lt;T&gt; {
    type Target = [T];
    fn deref(&amp;self) -&gt; &amp;[T] {
        unsafe { std::slice::from_raw_parts(self.ptr(), self.len) }
    }
}

impl&lt;T&gt; DerefMut for Vec&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut [T] {
        unsafe { std::slice::from_raw_parts_mut(self.ptr(), self.len) }
    }
}

impl&lt;T&gt; IntoIterator for Vec&lt;T&gt; {
    type Item = T;
    type IntoIter = IntoIter&lt;T&gt;;
    fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        let (iter, buf) = unsafe {
            (RawValIter::new(&amp;self), ptr::read(&amp;self.buf))
        };

        mem::forget(self);

        IntoIter {
            iter: iter,
            _buf: buf,
        }
    }
}

struct RawValIter&lt;T&gt; {
    start: *const T,
    end: *const T,
}

impl&lt;T&gt; RawValIter&lt;T&gt; {
    unsafe fn new(slice: &amp;[T]) -&gt; Self {
        RawValIter {
            start: slice.as_ptr(),
            end: if mem::size_of::&lt;T&gt;() == 0 {
                ((slice.as_ptr() as usize) + slice.len()) as *const _
            } else if slice.len() == 0 {
                slice.as_ptr()
            } else {
                slice.as_ptr().add(slice.len())
            },
        }
    }
}

impl&lt;T&gt; Iterator for RawValIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.start = (self.start as usize + 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    let old_ptr = self.start;
                    self.start = self.start.offset(1);
                    Some(ptr::read(old_ptr))
                }
            }
        }
    }

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        let elem_size = mem::size_of::&lt;T&gt;();
        let len = (self.end as usize - self.start as usize)
                  / if elem_size == 0 { 1 } else { elem_size };
        (len, Some(len))
    }
}

impl&lt;T&gt; DoubleEndedIterator for RawValIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.start == self.end {
            None
        } else {
            unsafe {
                if mem::size_of::&lt;T&gt;() == 0 {
                    self.end = (self.end as usize - 1) as *const _;
                    Some(ptr::read(NonNull::&lt;T&gt;::dangling().as_ptr()))
                } else {
                    self.end = self.end.offset(-1);
                    Some(ptr::read(self.end))
                }
            }
        }
    }
}

pub struct IntoIter&lt;T&gt; {
    _buf: RawVec&lt;T&gt;,    // 我们实际上并不关心这个，只需要他们保证分配的空间不被释放
    iter: RawValIter&lt;T&gt;,
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next_back()
    }
}

impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {
    fn drop(&amp;mut self) {
        for _ in &amp;mut *self {}
    }
}

pub struct Drain&lt;'a, T: 'a&gt; {
    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next()
    }
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) {
        self.iter.size_hint()
    }
}

impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.iter.next_back()
    }
}

impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        // 消耗drain
        for _ in &amp;mut *self {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    tests::create_push_pop();
</span><span class="boring">    tests::iter_test();
</span><span class="boring">    tests::test_drain();
</span><span class="boring">    tests::test_zst();
</span><span class="boring">    println!(&quot;All tests finished OK&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn create_push_pop() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        v.push(1);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">        assert_eq!(1, v[0]);
</span><span class="boring">        for i in v.iter_mut() {
</span><span class="boring">            *i += 1;
</span><span class="boring">        }
</span><span class="boring">        v.insert(0, 5);
</span><span class="boring">        let x = v.pop();
</span><span class="boring">        assert_eq!(Some(2), x);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">        v.push(10);
</span><span class="boring">        let x = v.remove(0);
</span><span class="boring">        assert_eq!(5, x);
</span><span class="boring">        assert_eq!(1, v.len());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn iter_test() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for i in 0..10 {
</span><span class="boring">            v.push(Box::new(i))
</span><span class="boring">        }
</span><span class="boring">        let mut iter = v.into_iter();
</span><span class="boring">        let first = iter.next().unwrap();
</span><span class="boring">        let last = iter.next_back().unwrap();
</span><span class="boring">        drop(iter);
</span><span class="boring">        assert_eq!(0, *first);
</span><span class="boring">        assert_eq!(9, *last);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn test_drain() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for i in 0..10 {
</span><span class="boring">            v.push(Box::new(i))
</span><span class="boring">        }
</span><span class="boring">        {
</span><span class="boring">            let mut drain = v.drain();
</span><span class="boring">            let first = drain.next().unwrap();
</span><span class="boring">            let last = drain.next_back().unwrap();
</span><span class="boring">            assert_eq!(0, *first);
</span><span class="boring">            assert_eq!(9, *last);
</span><span class="boring">        }
</span><span class="boring">        assert_eq!(0, v.len());
</span><span class="boring">        v.push(Box::new(1));
</span><span class="boring">        assert_eq!(1, *v.pop().unwrap());
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn test_zst() {
</span><span class="boring">        let mut v = Vec::new();
</span><span class="boring">        for _i in 0..10 {
</span><span class="boring">            v.push(())
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let mut count = 0;
</span><span class="boring">
</span><span class="boring">        for _ in v.into_iter() {
</span><span class="boring">            count += 1
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        assert_eq!(10, count);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#实现-arc-和-mutex" id="实现-arc-和-mutex">实现 Arc 和 Mutex</a></h1>
<p>了解理论是很好的，但是理解某件事<strong>最好</strong>的方法是使用它。为了更好地理解原子和内部可变性，我们将实现标准库中的<code>Arc</code>和<code>Mutex</code>类型。</p>
<p>TODO：编写<code>Mutex</code>章节。</p>
<h1><a class="header" href="#实现-arc" id="实现-arc">实现 Arc</a></h1>
<p>在本节中，我们将实现一个更简单的<code>std::sync::Arc</code>。与<a href="arc-mutex/../vec/vec.html">我们之前做的<code>Vec</code>的实现</a>类似，我们不会像标准库那样利用许多优化、内建指令或不稳定的代码。</p>
<p>这个实现大致上基于标准库的实现（技术上可以认为是取自 1.49 中的<code>alloc::sync</code>，因为它实际上是在那里实现的），但它目前不支持弱引用，因为它们使实现稍微复杂一些。</p>
<p>请注意，这一部分目前还处于 WIP 阶段。</p>
<h1><a class="header" href="#布局-1" id="布局-1">布局</a></h1>
<p>让我们开始为我们的<code>Arc</code>的实现做布局。</p>
<p>一个<code>Arc&lt;T&gt;</code>为<code>T</code>类型的值提供了线程安全的共享所有权，并在堆中分配。在 Rust 中，共享意味着不变性，所以我们不需要设计任何东西来管理对该值的访问，对吧？虽然像 Mutex 这样的内部可变性类型允许 Arc 的用户创建共享可变性，但 Arc 本身并不需要关注这些问题。</p>
<p>然而，有一个地方 Arc 需要关注可变：销毁。当 Arc 的所有所有者都销毁时，我们需要能够<code>drop</code>其内容并释放其分配。所以我们需要一种方法让所有者知道它是否是最后一个所有者，而最简单的方法就是对所有者进行计数——引用计数。</p>
<p>不幸的是，这种引用计数本质上是共享的可变状态，所以 Arc <em>需要</em> 考虑同步问题。我们可以为此使用 Mutex，但那太过于杀鸡用牛刀了。相反，我们将使用 atomics。既然每个人都需要一个指向 T 的分配的指针，我们也可以把引用计数放在同一个分配中。</p>
<p>直观地说，它看起来就像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic;

pub struct Arc&lt;T&gt; {
    ptr: *mut ArcInner&lt;T&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: atomic::AtomicUsize,
    data: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>这可以编译通过，然而它是不正确的。首先，编译器会给我们太严格的可变性。例如，在期望使用<code>Arc&lt;&amp;'a str&gt;</code>的地方不能使用<code>Arc&lt;&amp;'static str&gt;</code>。更重要的是，它将给 drop checker 提供不正确的所有权信息，因为它将假定我们不拥有任何<code>T</code>类型的值。由于这是一个提供值的共享所有权的结构，在某些时候会有一个完全拥有其数据的结构实例。参见<a href="arc-mutex/../ownership.html">关于所有权和生命周期的章节</a>，了解关于变异和 drop checker 的所有细节。</p>
<p>为了解决第一个问题，我们可以使用<code>NonNull&lt;T&gt;</code>。请注意，<code>NonNull&lt;T&gt;</code>是一个围绕原始指针的包装，并声明以下内容：</p>
<ul>
<li>我们是<code>T</code>的协变</li>
<li>我们的指针从不为空</li>
</ul>
<p>为了解决第二个问题，我们可以包含一个包含<code>ArcInner&lt;T&gt;</code>的<code>PhantomData</code>标记。这将告诉 drop checker，我们对<code>ArcInner&lt;T&gt;</code>（它本身包含<code>T</code>）的值有一些所有权的概念。</p>
<p>通过这些改变，我们得到了最终的结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use std::ptr::NonNull;
use std::sync::atomic::AtomicUsize;

pub struct Arc&lt;T&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: AtomicUsize,
    data: T,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#基本代码" id="基本代码">基本代码</a></h1>
<p>现在我们已经确定了实现<code>Arc</code>的布局，让我们开始写一些基本代码。</p>
<h2><a class="header" href="#构建-arc" id="构建-arc">构建 Arc</a></h2>
<p>我们首先需要一种方法来构造一个<code>Arc&lt;T&gt;</code>。</p>
<p>这很简单，因为我们只需要把<code>ArcInner&lt;T&gt;</code>扔到一个 Box 里并得到一个<code>NonNull&lt;T&gt;</code>的指针。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 当前的指针就是第一个引用，因此初始时设置 count 为 1
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // 我们从 Box::into_raw 得到该指针，因此使用 `.unwrap()` 是完全可行的
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}
</code></pre>
<h2><a class="header" href="#send-和-sync-1" id="send-和-sync-1">Send 和 Sync</a></h2>
<p>由于我们正在构建并发原语，因此我们需要能够跨线程发送它。因此，我们可以实现<code>Send</code>和<code>Sync</code>标记特性。有关这些的更多信息，请参阅<a href="arc-mutex/../send-and-sync.html">有关<code>Send</code>和<code>Sync</code>的部分</a>。</p>
<p>这是没问题的，因为：</p>
<ul>
<li>当且仅当你拥有唯一的 Arc 引用时，你才能获得其引用数据的可变引用（这仅发生在<code>Drop</code>中）</li>
<li>我们使用原子操作进行共享可变引用计数</li>
</ul>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}
</code></pre>
<p>我们需要约束<code>T: Sync + Send</code>，因为如果我们不提供这些约束，就有可能通过<code>Arc</code>跨越线程边界共享不安全的值，这有可能导致数据竞争或不可靠。</p>
<p>例如，如果没有这些约束，<code>Arc&lt;Rc&lt;u32&gt;&gt;</code>将是<code>Sync + Send</code>，这意味着你可以从<code>Arc</code>中克隆出<code>Rc</code>来跨线程发送（不需要创建一个全新的<code>Rc</code>），这将产生数据竞争，因为<code>Rc</code>不是线程安全的.</p>
<h2><a class="header" href="#获取arcinner" id="获取arcinner">获取<code>ArcInner</code></a></h2>
<p>为了将<code>NonNull&lt;T&gt;</code>指针解引用为<code>T</code>，我们可以调用<code>NonNull::as_ref</code>。这是不安全的，与普通的<code>as_ref</code>函数不同，所以我们必须这样调用它。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe { self.ptr.as_ref() }
</code></pre>
<p>在这段代码中，我们将多次使用这个片段（通常与相关的<code>let</code>绑定）。</p>
<p>这种不安全是没问题的，因为当这个<code>Arc</code>存活的时候，我们可以保证内部指针是有效的。</p>
<h2><a class="header" href="#deref-1" id="deref-1">Deref</a></h2>
<p>好了。现在我们可以制作<code>Arc</code>了（很快就能正确地克隆和销毁它们），但是我们怎样才能获得里面的数据呢？</p>
<p>我们现在需要的是一个<code>Deref</code>的实现。</p>
<p>我们需要导入该 Trait：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;
</code></pre>
<p>这里是实现：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}
</code></pre>
<p>看着很简单，对不？这只是解除了对<code>ArcInner&lt;T&gt;</code>的<code>NonNull</code>指针的引用，然后得到了对里面数据的引用。</p>
<h2><a class="header" href="#代码" id="代码">代码</a></h2>
<p>下面是本节的所有代码。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::ops::Deref;

impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 当前的指针就是第一个引用，因此初始时设置 count 为 1
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // 我们从 Box::into_raw 得到该指针，因此使用 `.unwrap()` 是完全可行的
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}

unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}


impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}
</code></pre>
<h1><a class="header" href="#克隆" id="克隆">克隆</a></h1>
<p>现在我们已经有了一些基本的代码，我们需要一种方法来克隆<code>Arc</code>。</p>
<p>我们大致需要：</p>
<ol>
<li>递增原子引用计数</li>
<li>从内部指针构建一个新的<code>Arc</code>实例</li>
</ol>
<p>首先，我们需要获得对<code>ArcInner</code>的访问。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let inner = unsafe { self.ptr.as_ref() };
</code></pre>
<p>我们可以通过以下方式更新原子引用计数：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let old_rc = inner.rc.fetch_add(1, Ordering::???);
</code></pre>
<p>但是我们在这里应该使用什么顺序？我们实际上没有任何代码在克隆时需要原子同步，因为我们在克隆时不修改内部值。因此，我们可以在这里使用 Relaxed 顺序，这意味着没有 happen-before 的关系，但却是原子性的。然而，当<code>Drop</code> Arc 时，我们需要在递减引用计数时进行原子同步。这在<a href="arc-mutex/arc-drop.html">关于<code>Arc</code>的<code>Drop</code>实现部分</a>中有更多描述。关于原子关系和 Relaxed ordering 的更多信息，请参见<a href="arc-mutex/../atomics.html">atomics 部分</a>。</p>
<p>因此，代码变成了这样：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);
</code></pre>
<p>我们需要增加一个导入来使用<code>Ordering</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::Ordering;
<span class="boring">}
</span></code></pre></pre>
<p>然而，我们现在的这个实现有一个问题：如果有人决定<code>mem::forget</code>一堆 Arc 怎么办？到目前为止，我们所写的代码（以及将要写的代码）假设引用计数准确地描绘了内存中的 Arc 的数量，但在<code>mem::forget</code>的情况下，这是错误的。因此，当越来越多的 Arc 从这个 Arc 中克隆出来，而它们又没有被<code>Drop</code>和参考计数被递减时，我们就会溢出！这将导致释放后使用（use-after-free）。这是<strong>非常糟糕的事情！</strong></p>
<p>为了处理这个问题，我们需要检查引用计数是否超过某个任意值（低于<code>usize::MAX</code>，因为我们把引用计数存储为<code>AtomicUsize</code>），并<em>做一些防御</em>。</p>
<p>标准库的实现决定，如果任何线程上的引用计数达到<code>isize::MAX</code>（大约是<code>usize::MAX</code>的一半），就直接中止程序（因为在正常代码中这是非常不可能的情况，如果它发生，程序可能是非常有问题的）。基于的假设是，不应该有大约 20 亿个线程（或者在一些 64 位机器上大约<strong>9万亿</strong>个）在同时增加引用计数。这就是我们要做的。</p>
<p>实现这种行为是非常简单的。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">if old_rc &gt;= isize::MAX as usize {
    std::process::abort();
}
</code></pre>
<p>然后，我们需要返回一个新的<code>Arc</code>的实例。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">Self {
    ptr: self.ptr,
    phantom: PhantomData
}
</code></pre>
<p>现在，让我们把这一切包在<code>Clone</code>的实现中。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">use std::sync::atomic::Ordering;

impl&lt;T&gt; Clone for Arc&lt;T&gt; {
    fn clone(&amp;self) -&gt; Arc&lt;T&gt; {
        let inner = unsafe { self.ptr.as_ref() };
        // 我们没有修改 Arc 中的数据，因此在这里不需要任何原子的同步操作，
        // 使用 relax 这种排序方式也就完全可行了
        let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);

        if old_rc &gt;= isize::MAX as usize {
            std::process::abort();
        }

        Self {
            ptr: self.ptr,
            phantom: PhantomData,
        }
    }
}
</code></pre>
<h1><a class="header" href="#丢弃" id="丢弃">丢弃</a></h1>
<p>我们现在需要一种方法来减少引用计数，并在计数足够低时丢弃数据，否则数据将永远存在于堆中。</p>
<p>为了做到这一点，我们可以实现<code>Drop</code>。</p>
<p>我们大致需要：</p>
<ol>
<li>递减引用计数</li>
<li>如果数据只剩下一个引用，那么：</li>
<li>原子化地对数据进行屏障，以防止对数据的使用和删除进行重新排序</li>
<li>丢弃内部数据</li>
</ol>
<p>首先，我们需要获得对<code>ArcInner</code>的访问：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">let inner = unsafe { self.ptr.as_ref() };
</code></pre>
<p>现在，我们需要递减引用计数。为了简化我们的代码，如果从<code>fetch_sub</code>返回的值（递减引用计数之前的值）不等于<code>1</code>，我们可以直接返回（我们不是数据的最后一个引用）。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
    return;
}
</code></pre>
<p>然后我们需要创建一个原子屏障来防止重新排序使用数据和删除数据。正如<a href="https://github.com/rust-lang/rust/blob/e1884a8e3c3e813aada8254edfa120e85bf5ffca/library/alloc/src/sync.rs#L1440-L1467">标准库对<code>Arc</code>的实现</a>中所述。</p>
<blockquote>
<p>需要这个内存屏障来防止数据使用的重新排序和数据的删除。因为它被标记为<code>Release</code>，引用计数的减少与<code>Acquire</code>屏障同步。这意味着数据的使用发生在减少引用计数之前，而减少引用计数发生在这个屏障之前，而屏障发生在数据的删除之前。（译者注：use &lt; decrease &lt; 屏障 &lt; delete）</p>
<p>正如<a href="https://www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html">Boost 文档</a>中所解释的那样。</p>
<blockquote>
<p>强制要求一个线程中对该对象的任何可能的访问（通过现有的引用）<em>发生在不同线程中删除该对象之前</em>是很重要的。这可以通过在丢弃一个引用后的“Release”操作来实现（任何通过该引用对对象的访问显然必须在之前发生），以及在删除对象前的“Acquire”操作。</p>
</blockquote>
<p>特别是，虽然 Arc 的内容通常是不可改变的，但有可能对类似 Mutex 的东西进行内部可变。由于 Mutex 在被删除时不会被获取，我们不能依靠它的同步逻辑来使线程 A 的写操作对线程 B 的析构器可见。</p>
<p>还要注意的是，这里的 Acquire fence 可能可以用 Acquire load 来代替，这可以在高度竞争的情况下提高性能。
参见<a href="https://github.com/rust-lang/rust/pull/41714">2</a>。</p>
</blockquote>
<p>为了做到这一点，我们可以这么做：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::atomic::Ordering;
</span>use std::sync::atomic;
atomic::fence(Ordering::Acquire);
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们可以 drop 数据本身。我们使用<code>Box::from_raw</code>来丢弃 Box 中的<code>ArcInner&lt;T&gt;</code>和它的数据。这需要一个<code>*mut T</code>而不是<code>NonNull&lt;T&gt;</code>，所以我们必须使用<code>NonNull::as_ptr</code>进行转换。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">unsafe { Box::from_raw(self.ptr.as_ptr()); }
</code></pre>
<p>这是安全的，因为我们知道我们拥有的是最后一个指向<code>ArcInner</code>的指针，而且其指针是有效的。</p>
<p>现在，让我们在<code>Drop</code>的实现中把这一切整合起来。</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for Arc&lt;T&gt; {
    fn drop(&amp;mut self) {
        let inner = unsafe { self.ptr.as_ref() };
        if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        // 我们需要防止针对 inner 的使用和删除的重排序，
        // 因此使用 fence 来进行保护是非常有必要的
        atomic::fence(Ordering::Acquire);
        // 安全保证：我们知道这是最后一个对 ArcInner 的引用，并且这个指针是有效的
        unsafe { Box::from_raw(self.ptr.as_ptr()); }
    }
}
</code></pre>
<h1><a class="header" href="#最终代码" id="最终代码">最终代码</a></h1>
<p>这就是我们的最终代码，我在这里加了一些额外的注释并排序了一下 imports：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker::PhantomData;
use std::ops::Deref;
use std::ptr::NonNull;
use std::sync::atomic::{self, AtomicUsize, Ordering};

pub struct Arc&lt;T&gt; {
    ptr: NonNull&lt;ArcInner&lt;T&gt;&gt;,
    phantom: PhantomData&lt;ArcInner&lt;T&gt;&gt;,
}

pub struct ArcInner&lt;T&gt; {
    rc: AtomicUsize,
    data: T,
}

impl&lt;T&gt; Arc&lt;T&gt; {
    pub fn new(data: T) -&gt; Arc&lt;T&gt; {
        // 当前的指针就是第一个引用，因此初始时设置 count 为 1
        let boxed = Box::new(ArcInner {
            rc: AtomicUsize::new(1),
            data,
        });
        Arc {
            // 我们从 Box::into_raw 得到该指针，因此使用 `.unwrap()` 是完全可行的
            ptr: NonNull::new(Box::into_raw(boxed)).unwrap(),
            phantom: PhantomData,
        }
    }
}

unsafe impl&lt;T: Sync + Send&gt; Send for Arc&lt;T&gt; {}
unsafe impl&lt;T: Sync + Send&gt; Sync for Arc&lt;T&gt; {}

impl&lt;T&gt; Deref for Arc&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        let inner = unsafe { self.ptr.as_ref() };
        &amp;inner.data
    }
}

impl&lt;T&gt; Clone for Arc&lt;T&gt; {
    fn clone(&amp;self) -&gt; Arc&lt;T&gt; {
        let inner = unsafe { self.ptr.as_ref() };
        // 我们没有修改 Arc 中的数据，因此在这里不需要任何原子的同步操作，
        // 使用 relax 这种排序方式也就完全可行
        let old_rc = inner.rc.fetch_add(1, Ordering::Relaxed);

        if old_rc &gt;= isize::MAX as usize {
            std::process::abort();
        }

        Self {
            ptr: self.ptr,
            phantom: PhantomData,
        }
    }
}

impl&lt;T&gt; Drop for Arc&lt;T&gt; {
    fn drop(&amp;mut self) {
        let inner = unsafe { self.ptr.as_ref() };
        if inner.rc.fetch_sub(1, Ordering::Release) != 1 {
            return;
        }
        // 我们需要防止针对 inner 的使用和删除的重排序
        // 因此使用 fence 来进行保护是非常有必要
        atomic::fence(Ordering::Acquire);

        // 安全保证：我们知道这是最后一个对 ArcInner 的引用，并且这个指针是有效的
        unsafe { Box::from_raw(self.ptr.as_ptr()); }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#外部函数接口ffi" id="外部函数接口ffi">外部函数接口（FFI）</a></h1>
<h2><a class="header" href="#简介" id="简介">简介</a></h2>
<p>本指南将使用<a href="https://github.com/google/snappy">snappy</a>压缩/解压缩库作为为外部代码编写绑定的示例。Rust 目前无法直接调用 C++ 库，但 snappy 包括一个 C 接口（在<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>）。</p>
<h2><a class="header" href="#关于-libc-的说明" id="关于-libc-的说明">关于 libc 的说明</a></h2>
<p>这些例子中有许多使用了<a href="https://crates.io/crates/libc">the <code>libc</code> crate</a>，它为 C 类型提供了各种类型定义，以及其他东西。如果你要自己尝试这些例子, 你需要在你的<code>Cargo.toml</code>中加入<code>libc</code>：</p>
<pre><code class="language-toml">[dependencies]
libc = &quot;0.2.0&quot;
</code></pre>
<h2><a class="header" href="#调用外部函数" id="调用外部函数">调用外部函数</a></h2>
<p>下面是一个调用外部函数的最小例子，如果你安装了 snappy，它就可以被编译：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::size_t;

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!(&quot;max compressed length of a 100 byte buffer: {}&quot;, x);
}
</code></pre>
<p><code>extern</code>块是一个外部库中的函数签名列表，在本例中是平台的 C ABI。<code>#[link(...)]</code>属性用来指示链接器与 snappy 库进行链接，以便解析这些符号。</p>
<p>外部函数被认为是不安全的，所以对它们的调用需要用<code>unsafe {}</code>来包装，作为对编译器的承诺，其中包含的所有内容都是安全的。C 库经常暴露出不是线程安全的接口，而且几乎所有接受指针参数的函数都对一些输入是无效的，因为指针可能是悬空的，而原始指针不在 Rust 的安全内存模型之内。</p>
<p>当声明一个外部函数的参数类型时，Rust 编译器不能检查声明是否正确，所以正确指定它是在运行时保持绑定正确的一部分。</p>
<p><code>extern</code>块可以被扩展到覆盖整个 snappy API：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::{c_int, size_t};

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
<span class="boring">fn main() {}
</span></code></pre>
<h2><a class="header" href="#创建一个安全的接口" id="创建一个安全的接口">创建一个安全的接口</a></h2>
<p>原始的 C 语言 API 需要被包装起来，以提供内存安全，并使用更高级别的概念，如向量。一个库可以选择只公开安全的高级接口而隐藏不安全的内部细节。</p>
<p>封装一个需要内存 buffer 参数的函数需要使用<code>slice::raw</code>模块来操作 Rust Vec 作为内存的指针。Rust 的 Vec 被保证为一个连续的内存块，长度是当前包含的元素数，容量是分配的内存的总大小（元素），其中长度必定小于或等于容量：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}
</code></pre>
<p>上面的<code>validate_compressed_buffer</code>包装器使用了一个<code>unsafe</code>块，但它通过在函数签名中去掉<code>unsafe</code>来保证调用它对所有输入都是安全的。</p>
<p><code>snappy_compress</code>和<code>snappy_uncompress</code>函数更复杂，因为还需要分配一个缓冲区来容纳输出。</p>
<p><code>snappy_max_compressed_length</code>函数可以用来分配一个最大容量的 Vec，以容纳压缩后的输出，然后该向量可以作为输出参数传递给<code>snappy_compress</code>函数。还会传递一个输出参数来检索压缩后的真实长度，以便设置长度：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
</span><span class="boring">                          d: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
</span><span class="boring">fn main() {}
</span>pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}
</code></pre>
<p>解压缩也是类似的，因为 snappy 将未压缩的大小作为压缩格式的一部分来存储，<code>snappy_uncompressed_length</code>将检索出所需的确切缓冲区大小：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{size_t, c_int};
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t) -&gt; c_int { 0 }
</span><span class="boring">fn main() {}
</span>pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}
</code></pre>
<p>然后，我们可以添加一些测试来展示如何使用它们：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore"><span class="boring">use libc::{c_int, size_t};
</span><span class="boring">unsafe fn snappy_compress(input: *const u8,
</span><span class="boring">                          input_length: size_t,
</span><span class="boring">                          compressed: *mut u8,
</span><span class="boring">                          compressed_length: *mut size_t)
</span><span class="boring">                          -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_uncompress(compressed: *const u8,
</span><span class="boring">                            compressed_length: size_t,
</span><span class="boring">                            uncompressed: *mut u8,
</span><span class="boring">                            uncompressed_length: *mut size_t)
</span><span class="boring">                            -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t { 0 }
</span><span class="boring">unsafe fn snappy_uncompressed_length(compressed: *const u8,
</span><span class="boring">                                     compressed_length: size_t,
</span><span class="boring">                                     result: *mut size_t)
</span><span class="boring">                                     -&gt; c_int { 0 }
</span><span class="boring">unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,
</span><span class="boring">                                            compressed_length: size_t)
</span><span class="boring">                                            -&gt; c_int { 0 }
</span><span class="boring">fn main() { }
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn valid() {
        let d = vec![0xde, 0xad, 0xd0, 0x0d];
        let c: &amp;[u8] = &amp;compress(&amp;d);
        assert!(validate_compressed_buffer(c));
        assert!(uncompress(c) == Some(d));
    }

    #[test]
    fn invalid() {
        let d = vec![0, 0, 0, 0];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
    }

    #[test]
    fn empty() {
        let d = vec![];
        assert!(!validate_compressed_buffer(&amp;d));
        assert!(uncompress(&amp;d).is_none());
        let c = compress(&amp;d);
        assert!(validate_compressed_buffer(&amp;c));
        assert!(uncompress(&amp;c) == Some(d));
    }
}
</code></pre>
<h2><a class="header" href="#析构器" id="析构器">析构器</a></h2>
<p>外部的库经常把资源的所有权交给调用代码，当这种情况发生时，我们必须使用 Rust 的析构器来提供安全并保证这些资源的释放（尤其是在 panic 的情况下）。</p>
<p>关于析构器的更多信息，请参见 <a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html">Drop trait</a>。</p>
<h2><a class="header" href="#从-c-调用-rust-代码" id="从-c-调用-rust-代码">从 C 调用 Rust 代码</a></h2>
<p>你可能想要把 Rust 代码编译成某种形式，以便在 C 中调用。这个并不难，不过需要一些额外的步骤。</p>
<h3><a class="header" href="#rust-代码侧" id="rust-代码侧">Rust 代码侧</a></h3>
<p>首先，我们假设你有一个 lib 库名字叫<code>rust_from_c</code>，其中的<code>lib.rs</code>应该包含类似这样的代码：</p>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn hello_from_rust() {
    println!(&quot;Hello from Rust!&quot;);
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>extern &quot;C&quot;</code>使得这个函数使用 C 的调用规约，正如下文<a href="ffi.html#%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E8%A7%84%E7%BA%A6">外部调用规约</a>一章所述。
<code>no_mangle</code>属性关闭了 Rust 的 name mangling 特性，这使得我们在链接时有个明确定义的符号名。</p>
<p>接下来，为了把我们的 Rust 代码编译成一个可以直接从 C 调用的共享库，我们需要加这些到<code>Cargo.toml</code>中：</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>（注意：我们也可以用<code>staticlib</code>类型，不过这会需要我们修改一些链接的参数。）</p>
<p>接下来，执行<code>cargo build</code>，Rust 侧就搞定啦！</p>
<h3><a class="header" href="#c-代码侧" id="c-代码侧">C 代码侧</a></h3>
<p>我们将写一段 C 代码来调用<code>hello_from_rust</code>并用<code>gcc</code>来编译。</p>
<p>C 代码大致是这样：</p>
<pre><code class="language-c">extern void hello_from_rust();

int main(void) {
    hello_from_rust();
    return 0;
}
</code></pre>
<p>我们把这个文件命名为<code>call_rust.c</code>，并且把它放到我们 crate 的根目录下，然后编译：</p>
<pre><code class="language-sh">gcc call_rust.c -o call_rust -lrust_from_c -L./target/debug
</code></pre>
<p><code>-l</code>和<code>-L</code>告诉 gcc 去找我们的 Rust 库。</p>
<p>最后，我们可以通过指定<code>LD_LIBRARY_PATH</code>来从 C 调用 Rust：</p>
<pre><code class="language-sh">$ LD_LIBRARY_PATH=./target/debug ./call_rust
Hello from Rust!
</code></pre>
<p>搞定！
如果需要更多实际的例子，可以参考<a href="https://github.com/eqrion/cbindgen"><code>cbindgen</code></a>。</p>
<h2><a class="header" href="#从-c-代码到-rust-函数的回调" id="从-c-代码到-rust-函数的回调">从 C 代码到 Rust 函数的回调</a></h2>
<p>一些外部库需要使用回调来向调用者报告其当前状态或中间数据，我们可以将 Rust 中定义的函数传递给外部库。这方面的要求是，回调函数被标记为“extern”，并有正确的调用约定，使其可以从 C 代码中调用。</p>
<p>然后，回调函数可以通过注册调用发送到 C 库中，之后再从那里调用。</p>
<p>一个基本的例子是：</p>
<p>Rust 代码：</p>
<pre><pre class="playground"><code class="language-rust no_run">extern fn callback(a: i32) {
    println!(&quot;I'm called from C with value {0}&quot;, a);
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // 触发回调
    }
}
</code></pre></pre>
<p>C 代码：</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // 在 Rust 中会调用回调函数 callback(7)
}
</code></pre>
<p>在这个例子中，Rust 的<code>main()</code>将调用 C 语言中的<code>trigger_callback()</code>，而这又会回调 Rust 中的<code>callback()</code>。</p>
<h2><a class="header" href="#针对-rust-对象的回调" id="针对-rust-对象的回调">针对 Rust 对象的回调</a></h2>
<p>前面的例子展示了如何从 C 代码中调用一个全局函数，然而，人们通常希望回调是针对一个特殊的 Rust 对象，这可能是代表相应的 C 对象的封装器的对象。</p>
<p>这可以通过向 C 库传递一个指向该对象的原始指针来实现，然后，C 库可以在通知中包含指向 Rust 对象的指针，这将使回调能够不安全地访问引用的 Rust 对象。</p>
<p>Rust 代码：</p>
<pre><pre class="playground"><code class="language-rust no_run">struct RustObject {
    a: i32,
    // 其余的成员...
}

extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
    println!(&quot;I'm called from C with value {0}&quot;, a);
    unsafe {
        // 在回调函数中更新 RustObject 的内容
        (*target).a = a;
    }
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // 创建一个会被在回调函数中引用的 RustObject
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}
</code></pre></pre>
<p>C 代码：</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // 这会调用 Rust 代码中的 callback(&amp;rustObject, 7)
}
</code></pre>
<h2><a class="header" href="#异步回调" id="异步回调">异步回调</a></h2>
<p>在之前给出的例子中，回调是作为对外部 C 库的函数调用的同步调用的。为了执行回调，对当前线程的控制从 Rust 切换到 C，再切换到 Rust，但最终回调是在调用触发回调的函数的同一线程上执行。</p>
<p>当外部库生成自己的线程并从那里调用回调时，事情会变得更加复杂。在这种情况下，对回调中的 Rust 数据结构的访问特别不安全，必须使用适当的同步机制。除了像 mutex 这样的经典同步机制，Rust 中的一种可能性是使用通道（在<code>std::sync::mpsc</code>中），将数据从调用回调的 C 线程转发到 Rust 线程。</p>
<p>如果一个异步回调的目标是 Rust 地址空间中的一个特殊对象，那么在相应的 Rust 对象被销毁后，C 库也绝对不能再进行回调。这可以通过在对象的析构器中取消对回调的注册来实现，并以保证在取消注册后不执行回调的方式设计库。</p>
<h2><a class="header" href="#链接" id="链接">链接</a></h2>
<p><code>extern</code>块上的<code>link</code>属性提供了基本的构建模块，用于指示 rustc 如何链接到本地库。现在有两种可接受的 link 属性的形式：</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>在这两种情况下，<code>foo</code>是我们要链接的本地库的名称，在第二种情况下，<code>bar</code>是编译器要链接的本地库的类型。目前已知有三种类型的本地库：</p>
<ul>
<li>动态 - <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>静态 - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>框架 - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>注意，框架只在 macOS 上可用。</p>
<p>不同的<code>kind</code>值是为了区分本地库如何参与链接。从链接的角度来看，Rust 编译器创建了两种类型的工件：部分（rlib/staticlib）和最终（dylib/binary）。原生的动态库和框架依赖被传播到最终的可执行文件中，而静态库的依赖则完全不被传播，因为静态库被直接集成到后续的可执行文件中的。</p>
<p>来看几个这个模型如何使用的例子：</p>
<ul>
<li>
<p>一个本地构建依赖。有时在编写一些 Rust 代码时需要一些 C/C++ 胶水，但以库的形式分发 C/C++ 代码是一种负担。在这种情况下，代码将被归档到<code>libfoo.a</code>，然后 Rust crate 将通过<code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>声明一个依赖关系。</p>
<p>无论 crate 的输出是什么，本地静态库都会被包含在输出中，这意味着本地静态库的分发是没有必要的。</p>
</li>
<li>
<p>一个正常的动态依赖。常见的系统库（如<code>readline</code>）在大量的系统上可用，而这些库的静态副本往往找不到。当这种依赖被包含在 Rust crate 中时，部分目标（如 rlibs）将不会链接到该库，但当 rlib 被包含在最终目标（如二进制）中时，本地库将被链接进来。</p>
</li>
</ul>
<p>在 macOS 上，框架的行为与动态库的语义相同。</p>
<h2><a class="header" href="#不安全块" id="不安全块">不安全块</a></h2>
<p>一些操作，如取消引用原始指针或调用被标记为不安全的函数，只允许在不安全块中进行。不安全块隔离了不安全因素，并向编译器承诺不安全因素不会从块中泄露出去。</p>
<p>另一方面，不安全的函数则向世界公布了它。一个不安全的函数是这样写的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
<span class="boring">}
</span></code></pre></pre>
<p>这个函数只能从一个“不安全”块或另一个“不安全”函数中调用。</p>
<h2><a class="header" href="#访问外部的全局变量" id="访问外部的全局变量">访问外部的全局变量</a></h2>
<p>外部的 API 经常输出一个全局变量，它可以做一些类似于跟踪全局状态的事情。为了访问这些变量，你可以在<code>extern</code>块中用<code>static</code>关键字来声明它们：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[link(name = &quot;readline&quot;)]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!(&quot;You have readline version {} installed.&quot;,
             unsafe { rl_readline_version as i32 });
}
</code></pre>
<p>另外，你可能需要改变由外部接口提供的全局状态。要做到这一点，可以用<code>mut</code>声明全局变量，这样我们就可以改变它们：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!(&quot;{:?}&quot;, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</code></pre>
<p>注意，所有“可变全局变量”的交互都是不安全的，包括读和写。处理全局可变状态需要非常小心。</p>
<h2><a class="header" href="#外部调用规约" id="外部调用规约">外部调用规约</a></h2>
<p>大多数外部代码都暴露了一个 C ABI，Rust 在调用外部函数时默认使用平台的 C 调用约定。一些外部函数，最明显的是 Windows API，使用了其他的调用约定。Rust 提供了一种方法来告诉编译器应该使用哪种约定：</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">#[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]
#[link(name = &quot;kernel32&quot;)]
#[allow(non_snake_case)]
extern &quot;stdcall&quot; {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
<span class="boring">fn main() { }
</span></code></pre>
<p>这适用于整个<code>extern</code>块。支持的 ABI 约束列表如下：</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>thiscall</code></li>
<li><code>vectorcall</code> 这是目前隐藏在<code>abi_vectorcall</code>特性开关后面的，可能会有变化</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>这个列表中的大多数 ABI 是不言自明的，但是<code>system</code> ABI 可能看起来有点奇怪。这个约束条件选择了任何合适的 ABI 来与目标库进行交互操作。例如，在 x86 架构的 win32 上，这意味着使用的 ABI 是<code>stdcall</code>。然而，在 x86_64 上，windows 使用<code>C</code>调用惯例，所以将使用<code>C</code>。这意味着在我们之前的例子中，我们可以使用<code>extern &quot;system&quot; { ... }</code>来为所有的 windows 系统定义一个块，而不仅仅是 x86 系统。</p>
<h2><a class="header" href="#与外部代码的互操作性" id="与外部代码的互操作性">与外部代码的互操作性</a></h2>
<p>只有当<code>#[repr(C)]</code>属性应用于一个<code>struct</code>时，Rust 才能保证该结构的布局与平台的 C 语言表示兼容。<code>#[repr(C, packed)]</code>可以用来布局结构成员而不需要填充。<code>#[repr(C)]</code>也可以应用于枚举。</p>
<p>Rust 的 Box 类型（<code>Box&lt;T&gt;</code>）使用不可为空的指针作为句柄，指向所包含的对象。然而，它们不应该被手动创建，因为它们是由内部分配器管理的。引用可以安全地被认为是直接指向该类型的不可归零的指针。然而，打破借用检查或可变性规则是不安全的，所以如果需要的话，最好使用原始指针（<code>*</code>），因为编译器不能对它们做出那么多假设。</p>
<p>向量和字符串共享相同的基本内存布局，并且在<code>vec</code>和<code>str</code>模块中提供了与 C API 工作的实用程序。然而，字符串不是以<code>\0</code>结束的。如果你需要一个以 NUL 结尾的字符串与 C 语言互通，你应该使用<code>std::ffi</code>模块中的<code>CString</code>类型。</p>
<p>crates.io 上的<a href="https://crates.io/crates/libc"><code>libc</code> crate</a>包括<code>libc</code>模块中的 C 标准库的类型别名和函数定义，Rust 默认与<code>libc</code>和<code>libm</code>链接。</p>
<h2><a class="header" href="#variadic-函数" id="variadic-函数">Variadic 函数</a></h2>
<p>在 C 语言中，函数可以是“variadic”，这意味着它们接受可变数量的参数。这在 Rust 中可以通过在外部函数声明的参数列表中指定“...”来实现：</p>
<pre><code class="language-no_run">extern {
    fn foo(x: i32, ...);
}

fn main() {
    unsafe {
        foo(10, 20, 30, 40, 50);
    }
}
</code></pre>
<p>正常的 Rust 函数<em>不能</em>是可变参数的：</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这不会编译通过

fn foo(x: i32, ...) {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#空指针优化" id="空指针优化">&quot;空指针优化&quot;</a></h2>
<p>某些 Rust 类型被定义为永不为“空”。这包括引用（<code>&amp;T</code>, <code>&amp;mut T</code>）, Box（<code>Box&lt;T&gt;</code>）, 和函数指针（<code>extern &quot;abi&quot; fn()</code>）。当与 C 语言对接时，经常使用可能为“空”的指针，这似乎需要一些混乱的<code>transmute</code>和/或不安全的代码来处理与 Rust 类型的转换。然而，尝试构造或者使用这些无效的值<strong>是 undefined behavior</strong>，所以你应当使用如下的变通方法。</p>
<p>作为一种特殊情况，如果一个<code>enum</code>正好包含两个变体，其中一个不包含数据，另一个包含上面列出的非空类型的字段，那么它就有资格获得“空指针优化”。这意味着不需要额外的空间来进行判别；相反，空的变体是通过将一个<code>null</code>的值放入不可空的字段来表示。这被称为“优化”，但与其他优化不同，它保证适用于符合条件的类型。</p>
<p>最常见的利用空指针优化的类型是<code>Option&lt;T&gt;</code>，其中<code>None</code>对应于<code>null</code>。所以<code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code>是使用 C ABI（对应于 C 类型<code>int (*)(int)</code>）来表示可空函数指针的一种正确方式。</p>
<p>这里有一个臆造的例子：假设某个 C 库有一个用于注册回调的工具，在某些情况下会被调用。回调被传递给一个函数指针和一个整数，它应该以整数为参数运行该函数。所以我们有函数指针在 FFI 边界上双向飞行。</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">use libc::c_int;

<span class="boring">#[cfg(hidden)]
</span>extern &quot;C&quot; {
    /// 注册回调函数
    fn register(cb: Option&lt;extern &quot;C&quot; fn(Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}
<span class="boring">unsafe fn register(_: Option&lt;extern &quot;C&quot; fn(Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;,
</span><span class="boring">                                           c_int) -&gt; c_int&gt;)
</span><span class="boring">{}
</span>
// 这个函数其实没什么实际的用处，
// 它从C代码接受一个函数指针和一个整数，
// 用整数做参数，调用指针指向的函数，并返回函数的返回值，
// 如果没有指定函数，那默认就返回整数的平方
extern &quot;C&quot; fn apply(process: Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    match process {
        Some(f) =&gt; f(int),
        None    =&gt; int * int
    }
}

fn main() {
    unsafe {
        register(Some(apply));
    }
}
</code></pre>
<p>而 C 语言方面的代码看起来是这样的：</p>
<pre><code class="language-c">void register(int (*f)(int (*)(int), int)) {
    ...
}
</code></pre>
<p>实际上，不需要<code>transmute</code>!</p>
<h2><a class="header" href="#ffi-和-unwinding" id="ffi-和-unwinding">FFI 和 unwinding</a></h2>
<p>在使用 FFI 时，必须注意 unwinding。大多数 ABI 的名称有两种变体，一种带有 <code>-unwind</code> 后缀而另一种不带。<code>Rust</code> 的 ABI 总是允许 unwinding，所以不存在 <code>Rust-unwind</code> ABI。</p>
<p>如果你希望 Rust <code>panic</code>s 或是外部（例如：C++）的异常能够穿越 FFI 的边界，则必须使用正确的 <code>-unwind</code> ABI。相反，如果你不希望 unwinding 可以穿越 FFI 边界，使用非 <code>unwind</code> 的 ABI。</p>
<blockquote>
<p>注意：编译时指定 <code>panic=abort</code> 会导致 <code>panic!</code> 立即终止进程，无论发生 <code>panic</code> 的函数指定了何种 ABI。</p>
</blockquote>
<p>如果一个 unwinding 操作遇到了不允许 unwind 的 ABI 边界，具体行为会由 unwinding 的源头决定（Rust <code>panic</code> 或是外部异常）：</p>
<ul>
<li><code>panic</code> 会导致进程安全终止。</li>
<li>外部异常会导致未定义行为。</li>
</ul>
<p>注意 <code>catch_unwind</code> 和外部异常的交互行为<strong>是未定义的</strong>，同样，<code>panic</code> 和外部异常处理机制的交互也是一样（尤其是 C++ 的 <code>try</code>/<code>catch</code>）。</p>
<h3><a class="header" href="#rust-panic-与-c-unwind" id="rust-panic-与-c-unwind">Rust <code>panic</code> 与 <code>&quot;C-unwind&quot;</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[no_mangle]
extern &quot;C-unwind&quot; fn example() {
    panic!(&quot;Uh oh&quot;);
}
</code></pre>
<p>该函数（当编译时指定 <code>panic=unwind</code> 时）可以 unwind C++ 的栈帧。</p>
<pre><code class="language-text">[通过 `catch_unwind` 停止 unwinding 的 Rust 函数 ]
      |
     ...
      |
   [C++ 栈]
      |                           ^
      | (调用)                     | (向上 unwinding)
      v                           |
[Rust 函数 `example`]              |
      |                           |
      +----- rust 函数 panics -----+
</code></pre>
<p>如果 C++ 的栈上包含对象，它们将会被析构。</p>
<h3><a class="header" href="#c-throw-与-c-unwind" id="c-throw-与-c-unwind">C++ <code>throw</code> 与 <code>&quot;C-unwind&quot;</code></a></h3>
<!-- ignore: using unstable feature -->
<pre><code class="language-rust ignore">#[link(...)]
extern &quot;C-unwind&quot; {
    // 一个可能会抛出异常的 C++ 函数
    fn may_throw();
}
#[no_mangle]
extern &quot;C-unwind&quot; fn rust_passthrough() {
    let b = Box::new(5);
    unsafe { may_throw(); }
    println!(&quot;{:?}&quot;, &amp;b);
}
</code></pre>
<p>一个有 <code>try</code> 语句块的 C++ 函数可以通过调用 <code>rust_passthrough</code> 捕获被 <code>may_throw</code> 抛出的异常。</p>
<pre><code class="language-text">[在 `try` 语句块中调用 `rust_passthrough`的 C++ 函数]
      |
     ...
      |
[Rust 函数 `rust_passthrough`]
      |                            ^
      | (调用)                      | (向上 unwinding)
      v                            |
[C++ 函数 `may_throw`]              |
      |                            |
      +------ C++ 函数抛出异常 ------+
</code></pre>
<p>如果 <code>may_throw</code> 抛出了一个异常，<code>b</code> 会被正常丢弃。否则将会打印 <code>5</code>。</p>
<h3><a class="header" href="#panic-可以在-abi-边界处停止" id="panic-可以在-abi-边界处停止"><code>panic</code> 可以在 ABI 边界处停止</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern &quot;C&quot; fn assert_nonzero(input: u32) {
    assert!(input != 0)
}
<span class="boring">}
</span></code></pre></pre>
<p>如果以 <code>0</code> 为参数调用了 <code>assert_nonzero</code>，运行时可以保证（安全地）终止进程, 无论编译时是否指定了 <code>panic=abort</code>。</p>
<h3><a class="header" href="#提前捕获-panic" id="提前捕获-panic">提前捕获 <code>panic</code></a></h3>
<p>在写可能会 panic 的 Rust 代码时，如果不希望进程在其 panic 时被终止，必须使用 <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>：</p>
<pre><pre class="playground"><code class="language-rust">use std::panic::catch_unwind;

#[no_mangle]
pub extern &quot;C&quot; fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!(&quot;Oops!&quot;);
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}
</code></pre></pre>
<p>请注意，<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>只捕捉 unwind 的 panic，而不是那些中止进程的 panic。更多信息请参见<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>的文档。</p>
<h2><a class="header" href="#表示不透明opaque的结构" id="表示不透明opaque的结构">表示不透明（opaque）的结构</a></h2>
<p>有时，一个 C 语言库想提供一个指向某东西的指针，但又不想让你知道它想要的东西的内部细节。一个稳定而简单的方法是使用一个<code>void *</code>参数。</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>我们可以在 Rust 中用<code>c_void</code>类型来表示。</p>
<!-- ignore: requires libc crate -->
<pre><code class="language-rust ignore">extern &quot;C&quot; {
    pub fn foo(arg: *mut libc::c_void);
    pub fn bar(arg: *mut libc::c_void);
}
<span class="boring">fn main() {}
</span></code></pre>
<p>这是一种完全有效的处理方式。然而，我们可以做得更好一点。为了解决这个问题，一些 C 库会创建一个<code>struct</code>，其中结构的细节和内存布局是私有的，这提供了某种程度的类型安全。这些结构被称为“不透明的”。下面是一个例子，在 C 语言中：</p>
<pre><code class="language-c">struct Foo; /* Foo 是一个接口，但它的内容不属于公共接口 */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>
<p>为了在 Rust 中做到这一点，让我们创建我们自己的不透明类型：</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
pub struct Foo {
    _data: [u8; 0],
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}
#[repr(C)]
pub struct Bar {
    _data: [u8; 0],
    _marker:
        core::marker::PhantomData&lt;(*mut u8, core::marker::PhantomPinned)&gt;,
}

extern &quot;C&quot; {
    pub fn foo(arg: *mut Foo);
    pub fn bar(arg: *mut Bar);
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>通过包括至少一个私有字段和没有构造函数，我们创建了一个不透明的类型，我们不能在这个模块之外实例化（否则，一个没有字段的结构可以被任何人实例化）。我们也想在 FFI 中使用这个类型，所以我们必须添加<code>#[repr(C)]</code>。该标记确保编译器不会将该结构标记为<code>Send</code>、<code>Sync</code>，并且<code>Unpin</code>也不会应用于该结构（<code>*mut u8</code>不是<code>Send</code>或者<code>Sync</code>，<code>PhantomPinned</code>也不是<code>Unpin</code>）。</p>
<p>但是因为我们的<code>Foo</code>和<code>Bar</code>类型不同，我们将在它们两个之间获得类型安全，所以我们不能意外地将<code>Foo</code>的指针传递给<code>bar()</code>。</p>
<p>注意，使用空枚举作为 FFI 类型是一个非常糟糕的主意。编译器假设空枚举是无法使用的，所以处理<code>&amp;Empty</code>类型的值会是意料之外的，并可能导致错误的程序行为（通过触发未定义行为）。</p>
<blockquote>
<p><strong>注意：</strong> 最简单的方法还是使用“extern 类型”。但它目前（截至 2021 年 10 月）还不稳定，而且还有一些未解决的问题，更多细节请参见<a href="https://rust-lang.github.io/rfcs/1861-extern-types.html">RFC 页面</a>和<a href="https://github.com/rust-lang/rust/issues/43467">跟踪 Issue</a>。</p>
</blockquote>
<h1><a class="header" href="#在-std-之下" id="在-std-之下">在 <code>std</code> 之下</a></h1>
<p>本节介绍了通常由 <code>std</code> crate 提供的功能，以及 <code>#![no_std]</code> 开发者在构建 <code>#![no_std]</code> 二进制 crate 时需要处理（即提供）的功能。</p>
<h2><a class="header" href="#使用-libc" id="使用-libc">使用 <code>libc</code></a></h2>
<p>为了构建一个 <code>#[no_std]</code> 可执行文件，我们需要将 <code>libc</code> 作为依赖项。我们可以在 <code>Cargo.toml</code> 文件中指定这个依赖：</p>
<pre><code class="language-toml">[dependencies]
libc = { version = &quot;0.2.146&quot;, default-features = false }
</code></pre>
<p>注意已经禁用了默认功能。这是一个关键步骤——** <code>libc</code> 的默认功能包括 <code>std</code> crate，因此必须禁用。**</p>
<p>另外，我们可以像下述例子一样，结合使用不稳定的 <code>rustc_private</code> 私有功能和 <code>extern crate libc;</code> 声明。需要注意的是，windows-msvc target 不需要 libc，对应的在 sysroot 中也不存在 <code>libc</code> 这个 crate，因此在 windows-msvc target 下，我们不需要添加这个声明，并且添加了这个声明会导致编译错误。</p>
<h2><a class="header" href="#在没有-std-的情况下编写可执行文件" id="在没有-std-的情况下编写可执行文件">在没有 <code>std</code> 的情况下编写可执行文件</a></h2>
<p>我们可能需要编译器的 nightly 版本来生成 <code>#![no_std]</code> 可执行文件，因为在许多平台上，我们必须提供不稳定的 <code>eh_personality</code> <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/lang-items.html">lang item</a>。</p>
<p>可以通过两种方式控制入口点：<code>#[start]</code> 属性，或者用您自己的函数覆盖 C 语言 <code>main</code> 函数的默认实现。此外，还需要定义一个 <a href="panic-handler.html">panic handler function</a>。</p>
<p>标记为 <code>#[start]</code> 的函数会以与 C 语言相同的格式传递命令行参数（除了使用的确切整数类型）：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(start, lang_items, core_intrinsics, rustc_private)]
#![allow(internal_features)]
#![no_std]

// 在 cfg(unix) 平台上，对于 `panic = &quot;unwind&quot;` 构建来说是必要的。
#![feature(panic_unwind)]
extern crate unwind;

// 导入 crt0.o 可能需要的系统 libc 库。
#[cfg(not(windows))]
extern crate libc;

use core::panic::PanicInfo;

// 本程序的入口点。
#[start]
fn main(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// 编译器使用这些函数，但对于像这样的空程序来说并不需要。
// 它们通常由 `std` 提供。
#[lang = &quot;eh_personality&quot;]
fn rust_eh_personality() {}
#[panic_handler]
fn panic_handler(_info: &amp;PanicInfo) -&gt; ! { core::intrinsics::abort() }
</code></pre></pre>
<p>要覆盖编译器插入的 <code>main</code> shim，我们必须使用 <code>#![no_main]</code> 禁用它，然后使用正确的 ABI 和正确的名称创建适当的符号，这需要覆盖编译器的名称改编：</p>
<pre><pre class="playground"><code class="language-rust">#![feature(lang_items, core_intrinsics, rustc_private)]
#![allow(internal_features)]
#![no_std]
#![no_main]

// 在 cfg(unix) 平台上，对于 `panic = &quot;unwind&quot;` 构建来说是必要的。
#![feature(panic_unwind)]
extern crate unwind;

// 导入 crt0.o 可能需要的系统 libc 库。
#[cfg(not(windows))]
extern crate libc;

use core::ffi::{c_char, c_int};
use core::panic::PanicInfo;

// 本程序的入口点。
#[no_mangle] // 确保将此符号作为 `main` 包含在输出中
extern &quot;C&quot; fn main(_argc: c_int, _argv: *const *const c_char) -&gt; c_int {
    0
}

// 编译器使用这些函数，但对于像这样的空程序来说并不需要。
// 它们通常由 `std` 提供。
#[lang = &quot;eh_personality&quot;]
fn rust_eh_personality() {}
#[panic_handler]
fn panic_handler(_info: &amp;PanicInfo) -&gt; ! { core::intrinsics::abort() }
</code></pre></pre>
<p>如果您正在使用一个没有通过 rustup 提供标准库二进制版本的目标（这可能意味着您正在自己构建 <code>core</code> crate）并且需要 compiler-rt intrinsics（即您可能在构建可执行文件时遇到链接错误：<code>undefined reference to '__aeabi_memcpy'</code>），您需要手动链接到 <a href="https://crates.io/crates/compiler_builtins"><code>compiler_builtins</code> crate</a> 来获取这些 intrinsics 并解决链接错误。</p>
<h1><a class="header" href="#panic_handler" id="panic_handler">#[panic_handler]</a></h1>
<p><code>#[panic_handler]</code>用于定义<code>panic!</code>在<code>#![no_std]</code>程序中的行为。<code>#[panic_handler]</code>必须应用于签名为<code>fn(&amp;PanicInfo) -&gt; !</code>的函数，并且这样的函数仅能在一个二进制程序/动态链接库的整个依赖图中仅出现一次。<code>PanicInfo</code>的 API 可以在 <a href="https://doc.rust-lang.org/core/panic/struct.PanicInfo.html">API docs</a> 中找到。</p>
<p>鉴于<code>#![no_std]</code>应用程序没有<em>标准</em>的输出，并且一些<code>#![no_std]</code>应用程序，例如嵌入式应用程序，在开发和发布时需要不同的 panic 行为，因此拥有专门的 panic crate，即只包含<code>#[panic_handler]</code>的 crate 是有帮助的。这样，应用程序可以通过简单地链接到一个不同的 panic crate 来轻松地选择 panic 行为。</p>
<p>下面是一个例子，根据使用开发配置文件（<code>cargo build</code>）或使用发布配置文件（<code>cargo build --release</code>）编译的应用程序具有不同的恐慌行为：</p>
<p><code>panic-semihosting</code>crate —— 使用 semihosting 将 panic 信息记录到主机 stderr：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{Write, self};
use core::panic::PanicInfo;

struct HStderr {
    // ..
<span class="boring">    _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl HStderr {
</span><span class="boring">    fn new() -&gt; HStderr { HStderr { _0: () } }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for HStderr {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut host_stderr = HStderr::new();

    // 输出日志: &quot;panicked at '$reason', src/main.rs:27:4&quot; 
    writeln!(host_stderr, &quot;{}&quot;, info).ok();

    loop {}
}
</code></pre>
<p><code>panic-halt</code>crate —— panic 时停止线程；消息被丢弃：</p>
<!-- ignore: simplified code -->
<pre><code class="language-rust ignore">#![no_std]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p><code>app</code> crate：</p>
<!-- ignore: requires the above crates -->
<pre><code class="language-rust ignore">#![no_std]

// dev profile
#[cfg(debug_assertions)]
extern crate panic_semihosting;

// release profile
#[cfg(not(debug_assertions))]
extern crate panic_halt;

fn main() {
    // ..
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script>
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js"></script>
        
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>
        

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </div>
    </body>
</html>
