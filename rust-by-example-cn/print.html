<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>通过例子学 Rust 中文版</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="通过例子学 Rust, Rust By Example 中文版，RBE 中文版，本书通过详细的可运行的 Rust 程序来讲解 Rust 语言有关的知识点，通俗易懂，是 Rust 初学者必备的学习参考书，同时也能作为 Rust 工程师日常工作中快速查找知识点的必备查询手册。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><a href="hello.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> 注释</a></li><li class="chapter-item expanded "><a href="hello/print.html"><strong aria-hidden="true">1.2.</strong> 格式化输出</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello/print/print_debug.html"><strong aria-hidden="true">1.2.1.</strong> 调试（debug）</a></li><li class="chapter-item expanded "><a href="hello/print/print_display.html"><strong aria-hidden="true">1.2.2.</strong> 显示（display）</a></li><li class="chapter-item expanded "><a href="hello/print/print_display/testcase_list.html"><strong aria-hidden="true">1.2.3.</strong> 测试实例：List</a></li><li class="chapter-item expanded "><a href="hello/print/fmt.html"><strong aria-hidden="true">1.2.4.</strong> 格式化</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">2.</strong> 原生类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> 字面量和运算符</a></li><li class="chapter-item expanded "><a href="primitives/tuples.html"><strong aria-hidden="true">2.2.</strong> 元组</a></li><li class="chapter-item expanded "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> 数组和切片</a></li></ol></li><li class="chapter-item expanded "><a href="custom_types.html"><strong aria-hidden="true">3.</strong> 自定义类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="custom_types/enum.html"><strong aria-hidden="true">3.2.</strong> 枚举</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom_types/enum/enum_use.html"><strong aria-hidden="true">3.2.1.</strong> 使用 use</a></li><li class="chapter-item expanded "><a href="custom_types/enum/c_like.html"><strong aria-hidden="true">3.2.2.</strong> C 风格用法</a></li><li class="chapter-item expanded "><a href="custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> 测试实例：链表</a></li></ol></li><li class="chapter-item expanded "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> 常量</a></li></ol></li><li class="chapter-item expanded "><a href="variable_bindings.html"><strong aria-hidden="true">4.</strong> 变量绑定</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> 可变变量</a></li><li class="chapter-item expanded "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> 作用域和遮蔽</a></li><li class="chapter-item expanded "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> 变量先声明</a></li><li class="chapter-item expanded "><a href="variable_bindings/freeze.html"><strong aria-hidden="true">4.4.</strong> 冻结</a></li></ol></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">5.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/cast.html"><strong aria-hidden="true">5.1.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> 字面量</a></li><li class="chapter-item expanded "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> 类型推断</a></li><li class="chapter-item expanded "><a href="types/alias.html"><strong aria-hidden="true">5.4.</strong> 别名</a></li></ol></li><li class="chapter-item expanded "><a href="conversion.html"><strong aria-hidden="true">6.</strong> 类型转换</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From 和 Into</a></li><li class="chapter-item expanded "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFrom 和 TryInto</a></li><li class="chapter-item expanded "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> ToString 和 FromStr</a></li></ol></li><li class="chapter-item expanded "><a href="expression.html"><strong aria-hidden="true">7.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="flow_control.html"><strong aria-hidden="true">8.</strong> 流程控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item expanded "><a href="flow_control/loop.html"><strong aria-hidden="true">8.2.</strong> loop 循环</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> 嵌套循环和标签</a></li><li class="chapter-item expanded "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> 从 loop 循环返回</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while 循环</a></li><li class="chapter-item expanded "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for 循环和区间</a></li><li class="chapter-item expanded "><a href="flow_control/match.html"><strong aria-hidden="true">8.5.</strong> match 匹配</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/match/destructuring.html"><strong aria-hidden="true">8.5.1.</strong> 解构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">8.5.1.1.</strong> 元组</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">8.5.1.2.</strong> 枚举</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> 指针和引用</a></li><li class="chapter-item expanded "><a href="flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">8.5.1.4.</strong> 结构体</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/match/guard.html"><strong aria-hidden="true">8.5.2.</strong> 卫语句</a></li><li class="chapter-item expanded "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> 绑定</a></li></ol></li><li class="chapter-item expanded "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item expanded "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item expanded "><a href="fn.html"><strong aria-hidden="true">9.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/methods.html"><strong aria-hidden="true">9.1.</strong> 方法</a></li><li class="chapter-item expanded "><a href="fn/closures.html"><strong aria-hidden="true">9.2.</strong> 闭包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/closures/capture.html"><strong aria-hidden="true">9.2.1.</strong> 捕获</a></li><li class="chapter-item expanded "><a href="fn/closures/input_parameters.html"><strong aria-hidden="true">9.2.2.</strong> 作为输入参数</a></li><li class="chapter-item expanded "><a href="fn/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> 类型匿名</a></li><li class="chapter-item expanded "><a href="fn/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> 输入函数</a></li><li class="chapter-item expanded "><a href="fn/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> 作为输出参数</a></li><li class="chapter-item expanded "><a href="fn/closures/closure_examples.html"><strong aria-hidden="true">9.2.6.</strong> std 中的例子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item expanded "><a href="fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fn/hof.html"><strong aria-hidden="true">9.3.</strong> 高阶函数</a></li><li class="chapter-item expanded "><a href="fn/diverging.html"><strong aria-hidden="true">9.4.</strong> 发散函数</a></li></ol></li><li class="chapter-item expanded "><a href="mod.html"><strong aria-hidden="true">10.</strong> 模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mod/visibility.html"><strong aria-hidden="true">10.1.</strong> 可见性</a></li><li class="chapter-item expanded "><a href="mod/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> 结构体的可见性</a></li><li class="chapter-item expanded "><a href="mod/use.html"><strong aria-hidden="true">10.3.</strong> use 声明</a></li><li class="chapter-item expanded "><a href="mod/super.html"><strong aria-hidden="true">10.4.</strong> super 和 self</a></li><li class="chapter-item expanded "><a href="mod/split.html"><strong aria-hidden="true">10.5.</strong> 文件分层</a></li></ol></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">11.</strong> crate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="crates/lib.html"><strong aria-hidden="true">11.1.</strong> 库</a></li><li class="chapter-item expanded "><a href="crates/using_lib.html"><strong aria-hidden="true">11.2.</strong> 使用库</a></li></ol></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">12.</strong> cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cargo/deps.html"><strong aria-hidden="true">12.1.</strong> 依赖</a></li><li class="chapter-item expanded "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> 约定规范</a></li><li class="chapter-item expanded "><a href="cargo/test.html"><strong aria-hidden="true">12.3.</strong> 测试</a></li><li class="chapter-item expanded "><a href="cargo/build_scripts.html"><strong aria-hidden="true">12.4.</strong> 构建脚本</a></li></ol></li><li class="chapter-item expanded "><a href="attribute.html"><strong aria-hidden="true">13.</strong> 属性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attribute/unused.html"><strong aria-hidden="true">13.1.</strong> 死代码 dead_code</a></li><li class="chapter-item expanded "><a href="attribute/crate.html"><strong aria-hidden="true">13.2.</strong> crate</a></li><li class="chapter-item expanded "><a href="attribute/cfg.html"><strong aria-hidden="true">13.3.</strong> cfg</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="attribute/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> 自定义条件</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">14.</strong> 泛型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/gen_fn.html"><strong aria-hidden="true">14.1.</strong> 函数</a></li><li class="chapter-item expanded "><a href="generics/impl.html"><strong aria-hidden="true">14.2.</strong> 实现</a></li><li class="chapter-item expanded "><a href="generics/gen_trait.html"><strong aria-hidden="true">14.3.</strong> trait</a></li><li class="chapter-item expanded "><a href="generics/bounds.html"><strong aria-hidden="true">14.4.</strong> 约束</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/bounds/testcase_empty.html"><strong aria-hidden="true">14.4.1.</strong> 测试实例：空约束</a></li></ol></li><li class="chapter-item expanded "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> 多重约束</a></li><li class="chapter-item expanded "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> where 子句</a></li><li class="chapter-item expanded "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> newtype 惯用法</a></li><li class="chapter-item expanded "><a href="generics/assoc_items.html"><strong aria-hidden="true">14.8.</strong> 关联项</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> 存在问题</a></li><li class="chapter-item expanded "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> 关联类型</a></li></ol></li><li class="chapter-item expanded "><a href="generics/phantom.html"><strong aria-hidden="true">14.9.</strong> 虚类型参数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> 测试实例：单位检查</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="scope.html"><strong aria-hidden="true">15.</strong> 作用域规则</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item expanded "><a href="scope/move.html"><strong aria-hidden="true">15.2.</strong> 所有权和移动</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/move/mut.html"><strong aria-hidden="true">15.2.1.</strong> 可变性</a></li><li class="chapter-item expanded "><a href="scope/move/partial_move.html"><strong aria-hidden="true">15.2.2.</strong> 部分移动</a></li></ol></li><li class="chapter-item expanded "><a href="scope/borrow.html"><strong aria-hidden="true">15.3.</strong> 借用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/borrow/mut.html"><strong aria-hidden="true">15.3.1.</strong> 可变性</a></li><li class="chapter-item expanded "><a href="scope/borrow/alias.html"><strong aria-hidden="true">15.3.2.</strong> 别名使用</a></li><li class="chapter-item expanded "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> ref 模式</a></li></ol></li><li class="chapter-item expanded "><a href="scope/lifetime.html"><strong aria-hidden="true">15.4.</strong> 生命周期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> 显式标注</a></li><li class="chapter-item expanded "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> 函数</a></li><li class="chapter-item expanded "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> 方法</a></li><li class="chapter-item expanded "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> trait</a></li><li class="chapter-item expanded "><a href="scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">15.4.6.</strong> 约束</a></li><li class="chapter-item expanded "><a href="scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">15.4.7.</strong> 强制转换</a></li><li class="chapter-item expanded "><a href="scope/lifetime/static_lifetime.html"><strong aria-hidden="true">15.4.8.</strong> static</a></li><li class="chapter-item expanded "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> 省略</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="trait.html"><strong aria-hidden="true">16.</strong> 特质 trait</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> 派生</a></li><li class="chapter-item expanded "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> 使用 dyn 返回 trait</a></li><li class="chapter-item expanded "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> 运算符重载</a></li><li class="chapter-item expanded "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> Drop</a></li><li class="chapter-item expanded "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item expanded "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> Clone</a></li><li class="chapter-item expanded "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> 父 trait</a></li><li class="chapter-item expanded "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> 消除重叠 trait</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">17.</strong> 使用 macro_rules! 来创建宏</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/syntax.html"><strong aria-hidden="true">17.1.</strong> 语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros/designators.html"><strong aria-hidden="true">17.1.1.</strong> 指示符</a></li><li class="chapter-item expanded "><a href="macros/overload.html"><strong aria-hidden="true">17.1.2.</strong> 重载</a></li><li class="chapter-item expanded "><a href="macros/repeat.html"><strong aria-hidden="true">17.1.3.</strong> 重复</a></li></ol></li><li class="chapter-item expanded "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (不写重复代码)</a></li><li class="chapter-item expanded "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (领域专用语言)</a></li><li class="chapter-item expanded "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> 可变参数接口</a></li></ol></li><li class="chapter-item expanded "><a href="error.html"><strong aria-hidden="true">18.</strong> 错误处理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item expanded "><a href="error/option_unwrap.html"><strong aria-hidden="true">18.2.</strong> Option 和 unwrap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.2.1.</strong> 使用 ? 解开 Option</a></li><li class="chapter-item expanded "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.2.2.</strong> 组合算子：map</a></li><li class="chapter-item expanded "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.2.3.</strong> 组合算子：and_then</a></li></ol></li><li class="chapter-item expanded "><a href="error/result.html"><strong aria-hidden="true">18.3.</strong> 结果 Result</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/result/result_map.html"><strong aria-hidden="true">18.3.1.</strong> Result 的 map</a></li><li class="chapter-item expanded "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.3.2.</strong> 给 Result 取别名</a></li><li class="chapter-item expanded "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.3.3.</strong> 提前返回</a></li><li class="chapter-item expanded "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.3.4.</strong> 引入 ?</a></li></ol></li><li class="chapter-item expanded "><a href="error/multiple_error_types.html"><strong aria-hidden="true">18.4.</strong> 处理多种错误类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.4.1.</strong> 从 Option 中取出 Result</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.4.2.</strong> 定义一种错误类型</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.4.3.</strong> 把错误 “装箱”</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.4.4.</strong> ? 的其他用法</a></li><li class="chapter-item expanded "><a href="error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">18.4.5.</strong> 包裹错误</a></li></ol></li><li class="chapter-item expanded "><a href="error/iter_result.html"><strong aria-hidden="true">18.5.</strong> 遍历 Result</a></li></ol></li><li class="chapter-item expanded "><a href="std.html"><strong aria-hidden="true">19.</strong> 标准库类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> 箱子、栈和堆</a></li><li class="chapter-item expanded "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> 动态数组 vector</a></li><li class="chapter-item expanded "><a href="std/str.html"><strong aria-hidden="true">19.3.</strong> 字符串 String</a></li><li class="chapter-item expanded "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> 选项 Option</a></li><li class="chapter-item expanded "><a href="std/result.html"><strong aria-hidden="true">19.5.</strong> 结果 Result</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ? 用法</a></li></ol></li><li class="chapter-item expanded "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item expanded "><a href="std/hash.html"><strong aria-hidden="true">19.7.</strong> 散列表 HashMap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> 更改或自定义关键字类型</a></li><li class="chapter-item expanded "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> 散列集 HashSet</a></li></ol></li><li class="chapter-item expanded "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> 引用计数 Rc</a></li><li class="chapter-item expanded "><a href="std/arc.html"><strong aria-hidden="true">19.9.</strong> 共享引用计数 Arc</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc.html"><strong aria-hidden="true">20.</strong> 标准库更多介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/threads.html"><strong aria-hidden="true">20.1.</strong> 线程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">20.1.1.</strong> 测试实例：map-reduce</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/channels.html"><strong aria-hidden="true">20.2.</strong> 通道</a></li><li class="chapter-item expanded "><a href="std_misc/path.html"><strong aria-hidden="true">20.3.</strong> 路径</a></li><li class="chapter-item expanded "><a href="std_misc/file.html"><strong aria-hidden="true">20.4.</strong> 文件输入输出（I/O）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/file/open.html"><strong aria-hidden="true">20.4.1.</strong> 打开文件 open</a></li><li class="chapter-item expanded "><a href="std_misc/file/create.html"><strong aria-hidden="true">20.4.2.</strong> 创建文件 create</a></li><li class="chapter-item expanded "><a href="std_misc/file/read_lines.html"><strong aria-hidden="true">20.4.3.</strong> 读取行 read lines</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/process.html"><strong aria-hidden="true">20.5.</strong> 子进程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/process/pipe.html"><strong aria-hidden="true">20.5.1.</strong> 管道</a></li><li class="chapter-item expanded "><a href="std_misc/process/wait.html"><strong aria-hidden="true">20.5.2.</strong> 等待</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/fs.html"><strong aria-hidden="true">20.6.</strong> 文件系统操作</a></li><li class="chapter-item expanded "><a href="std_misc/arg.html"><strong aria-hidden="true">20.7.</strong> 程序参数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std_misc/arg/matching.html"><strong aria-hidden="true">20.7.1.</strong> 参数解析</a></li></ol></li><li class="chapter-item expanded "><a href="std_misc/ffi.html"><strong aria-hidden="true">20.8.</strong> 外部语言函数接口</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">21.</strong> 测试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/unit_testing.html"><strong aria-hidden="true">21.1.</strong> 单元测试</a></li><li class="chapter-item expanded "><a href="testing/doc_testing.html"><strong aria-hidden="true">21.2.</strong> 文档测试</a></li><li class="chapter-item expanded "><a href="testing/integration_testing.html"><strong aria-hidden="true">21.3.</strong> 集成测试</a></li><li class="chapter-item expanded "><a href="testing/dev_dependencies.html"><strong aria-hidden="true">21.4.</strong> 开发依赖</a></li></ol></li><li class="chapter-item expanded "><a href="unsafe.html"><strong aria-hidden="true">22.</strong> 不安全操作</a></li><li class="chapter-item expanded "><a href="compatibility.html"><strong aria-hidden="true">23.</strong> 兼容性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compatibility/raw_identifiers.html"><strong aria-hidden="true">23.1.</strong> 原始标志符</a></li></ol></li><li class="chapter-item expanded "><a href="meta.html"><strong aria-hidden="true">24.</strong> 补充</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="meta/doc.html"><strong aria-hidden="true">24.1.</strong> 文档</a></li><li class="chapter-item expanded "><a href="meta/playpen.html"><strong aria-hidden="true">24.2.</strong> Playpen</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">通过例子学 Rust 中文版</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-cn/rust-by-example-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#通过例子学-rust" id="通过例子学-rust">通过例子学 Rust</a></h1>
<blockquote>
<p>中文翻译注（Chinese translation of the <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>）：</p>
<ul>
<li>👉 查看更多 <a href="https://rustwiki.org/" style="color:#97ca00;font-weight:bold;">Rust 官方文档中英文双语教程</a>，包括双语版<a href="https://rustwiki.org/zh-CN/book/">《Rust 程序设计语言》</a>（出版书名为《Rust 权威指南》），本站还提供了 <a href="https://rustwiki.org/zh-CN/std/">Rust 标准库中文版</a>。</li>
<li>《通过例子学 Rust》(Rust By Example 中文版)翻译自 <a href="https://doc.rust-lang.org/rust-by-example/">Rust By Example</a>，中文版最后更新时间：2022-1-26。查看此书的 <a href="https://github.com/rust-lang-cn/rust-by-example-cn">Github 翻译项目和源码</a>。</li>
<li><a href="https://rustwiki.org/en/rust-by-example" style="color:red;">本站支持文档中英文切换</a>，点击页面右上角语言图标可切换到相同章节的英文页面，<strong>英文版每天都会自动同步一次官方的最新版本</strong>。</li>
<li>若发现本页表达错误或帮助我们改进翻译，可点击右上角的编辑按钮打开本页对应源码文件进行编辑和修改，Rust 中文资源的开源组织发展离不开大家，感谢您的支持和帮助！</li>
</ul>
</blockquote>
<p><a href="https://www.rust-lang.org/">Rust</a> 是一门注重安全（safety）、速度（speed）和并发（concurrency）的现代系统编程语言。Rust 通过内存安全来实现以上目标，但不使用垃圾回收机制（garbage collection, GC）。</p>
<p>《通过例子学 Rust》（Rust By Example, RBE）内容由一系列可运行的实例组成，通过这些例子阐明了各种 Rust 的概念和基本库。想获取这些例子外的更多内容，不要忘了<a href="https://www.rust-lang.org/tools/install">安装 Rust 到本地</a>并查阅<a href="https://rustwiki.org/zh-CN/std/">官方标准库文档</a>。另外为了满足您的好奇心，您还可以<a href="https://github.com/rust-lang-cn/rust-by-example-cn">查阅本网站的源代码</a>。</p>
<p>现在让我们开始学习吧！</p>
<ul>
<li>
<p><a href="hello.html">Hello World</a> - 从经典的 “Hello World” 程序开始学习。</p>
</li>
<li>
<p><a href="primitives.html">原生类型</a> - 学习有符号整型，无符号整型和其他原生类型。</p>
</li>
<li>
<p><a href="custom_types.html">自定义类型</a> - 结构体 <code>struct</code> 和 枚举 <code>enum</code>。</p>
</li>
<li>
<p><a href="variable_bindings.html">变量绑定</a> - 变量绑定，作用域，变量遮蔽。</p>
</li>
<li>
<p><a href="types.html">类型系统</a> - 学习改变和定义类型。</p>
</li>
<li>
<p><a href="conversion.html">类型转换</a></p>
</li>
<li>
<p><a href="expression.html">表达式</a></p>
</li>
<li>
<p><a href="flow_control.html">流程控制</a> - <code>if</code>/<code>else</code>，<code>for</code>，以及其他流程控制有关内容。</p>
</li>
<li>
<p><a href="fn.html">函数</a> - 学习方法、闭包和高阶函数。</p>
</li>
<li>
<p><a href="mod.html">模块</a> - 使用模块来组织代码。</p>
</li>
<li>
<p><a href="crates.html">Crate</a> - crate 是 Rust 中的编译单元。学习创建一个库。</p>
</li>
<li>
<p><a href="cargo.html">Cargo</a> - 学习官方的 Rust 包管理工具的一些基本功能。</p>
</li>
<li>
<p><a href="attribute.html">属性</a> - 属性是应用于某些模块、crate 或项的元数据（metadata）。</p>
</li>
<li>
<p><a href="generics.html">泛型</a> - 学习编写能够适用于多种类型参数的函数或数据类型。</p>
</li>
<li>
<p><a href="scope.html">作用域规则</a> - 作用域在所有权（ownership）、借用（borrowing）和生命周期（lifetime）中起着重要作用。</p>
</li>
<li>
<p><a href="trait.html">特性 trait</a> - trait 是对未知类型（<code>Self</code>）定义的方法集。</p>
</li>
<li>
<p><a href="macros.html">宏</a></p>
</li>
<li>
<p><a href="error.html">错误处理</a> - 学习 Rust 语言处理失败的方式。</p>
</li>
<li>
<p><a href="std.html">标准库类型</a> - 学习 <code>std</code> 标准库提供的一些自定义类型。</p>
</li>
<li>
<p><a href="std_misc.html">标准库更多介绍</a> - 更多关于文件处理、线程的自定义类型。</p>
</li>
<li>
<p><a href="testing.html">测试</a> - Rust 语言的各种测试手段。</p>
</li>
<li>
<p><a href="unsafe.html">不安全操作</a></p>
</li>
<li>
<p><a href="compatibility.html">兼容性</a></p>
</li>
<li>
<p><a href="meta.html">补充</a> - 文档和基准测试</p>
</li>
</ul>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>这是传统的 Hello World 程序的源码。</p>
<pre><pre class="playground"><code class="language-rust editable">// 这是注释内容，将会被编译器忽略掉
// 可以单击那边的按钮 &quot;Run&quot; 来测试这段代码 -&gt;
// 若想用键盘操作，可以使用快捷键 &quot;Ctrl + Enter&quot; 来运行

// 这段代码支持编辑，你可以自由地修改代码！
// 通过单击 &quot;Reset&quot; 按钮可以使代码恢复到初始状态 -&gt;

// 这是主函数
fn main() {
    // 调用编译生成的可执行文件时，这里的语句将被运行。

    // 将文本打印到控制台
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code> 是一个<a href="macros.html"><strong>宏</strong></a>（macros），可以将文本输出到控制台（console）。</p>
<p>使用 Rust 的编译器 <code>rustc</code> 可以从源程序生成可执行文件：</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p>使用 <code>rustc</code> 编译后将得到可执行文件 <code>hello</code>。</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3><a class="header" href="#动手试一试" id="动手试一试">动手试一试</a></h3>
<p>单击上面的 &quot;Run&quot; 按钮并观察输出结果。然后增加一行代码，再一次使用宏 <code>println!</code>，得到下面结果：</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<h1><a class="header" href="#注释" id="注释">注释</a></h1>
<p>注释对任何程序都不可缺少，同样 Rust 支持几种不同的注释方式。</p>
<ul>
<li><strong>普通注释</strong>，其内容将被编译器忽略掉：
<ul>
<li><code>// 单行注释，注释内容直到行尾。</code></li>
<li><code>/* 块注释，注释内容一直到结束分隔符。 */</code></li>
</ul>
</li>
<li><strong>文档注释</strong>，其内容将被解析成 HTML 帮助<a href="hello/../meta/doc.html">文档</a>：
<ul>
<li><code>/// 为接下来的项生成帮助文档。</code></li>
<li><code>//! 为注释所属于的项（译注：如 crate、模块或函数）生成帮助文档。</code></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 这是行注释的例子
    // 注意有两个斜线在本行的开头
    // 在这里面的所有内容都不会被编译器读取

    // println!(&quot;Hello, world!&quot;);

    // 请运行一下，你看到结果了吗？现在请将上述语句的两条斜线删掉，并重新运行。

    /*
     * 这是另外一种注释——块注释。一般而言，行注释是推荐的注释格式，
     * 不过块注释在临时注释大块代码特别有用。/* 块注释可以 /* 嵌套, */ */
     * 所以只需很少按键就可注释掉这些 main() 函数中的行。/*/*/* 自己试试！*/*/*/
     */

    /*
    注意，上面的例子中纵向都有 `*`，这只是一种风格，实际上这并不是必须的。
    */

    // 观察块注释是如何简单地对表达式进行修改的，行注释则不能这样。
    // 删除注释分隔符将会改变结果。
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}
</code></pre></pre>
<h3><a class="header" href="#参见" id="参见">参见:</a></h3>
<p><a href="hello/../meta/doc.html">文档注释</a></p>
<h1><a class="header" href="#格式化输出" id="格式化输出">格式化输出</a></h1>
<p>打印操作由 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 里面所定义的一系列<a href="hello/../macros.html">宏</a>来处理，包括：</p>
<ul>
<li><code>format!</code>：将格式化文本写到<a href="hello/../std/str.html">字符串</a>。</li>
<li><code>print!</code>：与 <code>format!</code> 类似，但将文本输出到控制台（io::stdout）。</li>
<li><code>println!</code>: 与 <code>print!</code> 类似，但输出结果追加一个换行符。</li>
<li><code>eprint!</code>：与 <code>print!</code> 类似，但将文本输出到标准错误（io::stderr）。</li>
<li><code>eprintln!</code>：与 <code>eprint!</code> 类似，但输出结果追加一个换行符。</li>
</ul>
<p>这些宏都以相同的做法解析文本。有个额外优点是格式化的正确性会在编译时检查。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 通常情况下，`{}` 会被任意变量内容所替换。
    // 变量内容会转化成字符串。
    println!(&quot;{} days&quot;, 31);

    // 不加后缀的话，31 就自动成为 i32 类型。
    // 你可以添加后缀来改变 31 的类型（例如使用 31i64 声明 31 为 i64 类型）。

    // 用变量替换字符串有多种写法。
    // 比如可以使用位置参数。
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // 可以使用命名参数。
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // 可以在 `:` 后面指定特殊的格式。
    println!(&quot;{} of {:b} people know binary, the other half don't&quot;, 1, 2);

    // 你可以按指定宽度来右对齐文本。
    // 下面语句输出 &quot;     1&quot;，5 个空格后面连着 1。
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // 你可以在数字左边补 0。下面语句输出 &quot;000001&quot;。
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // println! 会检查使用到的参数数量是否正确。
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;);
    // 改正 ^ 补上漏掉的参数：&quot;James&quot;

    // 创建一个包含单个 `i32` 的结构体（structure）。命名为 `Structure`。
    #[allow(dead_code)]
    struct Structure(i32);

    // 但是像结构体这样的自定义类型需要更复杂的方式来处理。
    // 下面语句无法运行。
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3));
    // 改正 ^ 注释掉此行。
}
</code></pre></pre>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 包含多种 <a href="hello/../trait.html"><code>trait</code></a>（特质）来控制文字显示，其中重要的两种 trait 的基本形式如下：</p>
<ul>
<li><code>fmt::Debug</code>：使用 <code>{:?}</code> 标记。格式化文本以供调试使用。</li>
<li><code>fmt::Display</code>：使用 <code>{}</code> 标记。以更优雅和友好的风格来格式化文本。</li>
</ul>
<p>上例使用了 <code>fmt::Display</code>，因为标准库提供了那些类型的实现。若要打印自定义类型的文本，需要更多的步骤。</p>
<h3><a class="header" href="#动手试一试-1" id="动手试一试-1">动手试一试</a></h3>
<ul>
<li>改正上面代码中的两个错误（见 “改正”），使它可以没有错误地运行。</li>
<li>再用一个 <code>println!</code> 宏，通过控制显示的小数位数来打印：<code>Pi is roughly 3.142</code>（Pi 约等于 3.142）。为了达到练习目的，使用 <code>let pi = 3.141592</code> 作为 Pi 的近似值（提示：设置小数位的显示格式可以参考文档 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>）。</li>
</ul>
<h3><a class="header" href="#参见-1" id="参见-1">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>, <a href="hello/../macros.html"><code>macros</code></a>, <a href="hello/../custom_types/structs.html"><code>struct</code></a> 和 <a href="hello/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#调试debug" id="调试debug">调试（Debug）</a></h1>
<p>所有的类型，若想用 <code>std::fmt</code> 的格式化打印，都要求实现至少一个可打印的 <code>traits</code>。仅有一些类型提供了自动实现，比如 <code>std</code> 库中的类型。所有其他类型都<strong>必须</strong>手动实现。</p>
<p><code>fmt::Debug</code> 这个 <code>trait</code> 使这项工作变得相当简单。所有类型都能派生（<code>derive</code>，即自动创建）<code>fmt::Debug</code> 的实现。但是 <code>fmt::Display</code> 需要手动实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个结构体不能使用 `fmt::Display` 或 `fmt::Debug` 来进行打印。
struct UnPrintable(i32);

// `derive` 属性会自动创建所需的实现，使这个 `struct` 能使用 `fmt::Debug` 打印。
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<p>所有 <code>std</code> 库类型都天生可以使用 <code>{:?}</code> 来打印：</p>
<pre><pre class="playground"><code class="language-rust editable">// 推导 `Structure` 的 `fmt::Debug` 实现。
// `Structure` 是一个包含单个 `i32` 的结构体。
#[derive(Debug)]
struct Structure(i32);

// 将 `Structure` 放到结构体 `Deep` 中。然后使 `Deep` 也能够打印。
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // 使用 `{:?}` 打印和使用 `{}` 类似。
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure` 也可以打印！
    println!(&quot;Now {:?} will print!&quot;, Structure(3));
    
    // 使用 `derive` 的一个问题是不能控制输出的形式。
    // 假如我只想展示一个 `7` 怎么办？
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>所以 <code>fmt::Debug</code> 确实使这些内容可以打印，但是牺牲了一些美感。Rust 也通过 <code>{:#?}</code> 提供了 “美化打印” 的功能：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // 美化打印
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>你可以通过手动实现 <code>fmt::Display</code> 来控制显示效果。</p>
<h3><a class="header" href="#参见-2" id="参见-2">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/attributes.html">attributes</a>, <a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 和 <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#显示display" id="显示display">显示（Display）</a></h1>
<p><code>fmt::Debug</code> 通常看起来不太简洁，因此自定义输出的外观经常是更可取的。这需要通过手动实现 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>fmt::Display</code></a> 来做到。<code>fmt::Display</code> 采用 <code>{}</code> 标记。实现方式看起来像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// （使用 `use`）导入 `fmt` 模块使 `fmt::Display` 可用
use std::fmt;

// 定义一个结构体，咱们会为它实现 `fmt::Display`。以下是个简单的元组结构体
// `Structure`，包含一个 `i32` 元素。
struct Structure(i32);

// 为了使用 `{}` 标记，必须手动为类型实现 `fmt::Display` trait。
impl fmt::Display for Structure {
    // 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 仅将 self 的第一个元素写入到给定的输出流 `f`。返回 `fmt:Result`，此
        // 结果表明操作成功或失败。注意 `write!` 的用法和 `println!` 很相似。
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code> 的效果可能比 <code>fmt::Debug</code> 简洁，但对于 <code>std</code> 库来说，这就有一个问题。模棱两可的类型该如何显示呢？举个例子，假设标准库对所有的 <code>Vec&lt;T&gt;</code> 都实现了同一种输出样式，那么它应该是哪种样式？下面两种中的一种吗？</p>
<ul>
<li><code>Vec&lt;path&gt;</code>：<code>/:/etc:/home/username:/bin</code>（使用 <code>:</code> 分割）</li>
<li><code>Vec&lt;number&gt;</code>：<code>1,2,3</code>（使用 <code>,</code> 分割）</li>
</ul>
<p>我们没有这样做，因为没有一种合适的样式适用于所有类型，标准库也并不擅自规定一种样式。对于 <code>Vec&lt;T&gt;</code> 或其他任意泛型容器（generic container），<code>fmt::Display</code> 都没有实现。因此在这些泛型的情况下要用 <code>fmt::Debug</code>。</p>
<p>这并不是一个问题，因为对于任何<strong>非</strong>泛型的<strong>容器</strong>类型， <code>fmt::Display</code> 都能够实现。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // 导入 `fmt`

// 带有两个数字的结构体。推导出 `Debug`，以便与 `Display` 的输出进行比较。
#[derive(Debug)]
struct MinMax(i64, i64);

// 实现 `MinMax` 的 `Display`。
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 使用 `self.number` 来表示各个数据。
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// 为了比较，定义一个含有具名字段的结构体。
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// 类似地对 `Point2D` 实现 `Display`
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 自定义格式，使得仅显示 `x` 和 `y` 的值。
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // 报错。`Debug` 和 `Display` 都被实现了，但 `{:b}` 需要 `fmt::Binary`
    // 得到实现。这语句不能运行。
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<p><code>fmt::Display</code> 被实现了，而 <code>fmt::Binary</code> 没有，因此 <code>fmt::Binary</code> 不能使用。
<code>std::fmt</code> 有很多这样的 <a href="hello/print/../../trait.html"><code>trait</code></a>，它们都要求有各自的实现。这些内容将在后面的 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a> 章节中详细介绍。</p>
<h3><a class="header" href="#动手试一试-2" id="动手试一试-2">动手试一试</a></h3>
<p>检验上面例子的输出，然后在示例程序中，仿照 <code>Point2D</code> 结构体增加一个名为 <code>Complex</code> 的结构体。
使用一样的方式打印，输出结果要求是这个样子：</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3><a class="header" href="#参见-3" id="参见-3">参见：</a></h3>
<p><a href="hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a>, <a href="hello/print/../../macros.html">macros</a>, <a href="hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/../../trait.html"><code>trait</code></a>, 和 <a href="hello/print/../../mod/use.html">use</a></p>
<h1><a class="header" href="#测试实例list" id="测试实例list">测试实例：List</a></h1>
<p>对一个结构体实现 <code>fmt::Display</code>，其中的元素需要一个接一个地处理到，这可能会很麻烦。问题在于每个 <code>write!</code> 都要生成一个 <code>fmt::Result</code>。正确的实现需要处理<strong>所有</strong>的 Result。Rust 专门为解决这个问题提供了 <code>?</code> 操作符。</p>
<p>在 <code>write!</code> 上使用 <code>?</code> 会像是这样：</p>
<pre><code class="language-rust ignore">// 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。
// 否则（没有出错）继续执行后面的语句。
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>另外，你也可以使用 <code>try!</code> 宏，它和 <code>?</code> 是一样的。这种写法比较罗嗦，故不再推荐，
但在老一些的 Rust 代码中仍会看到。使用 <code>try!</code> 看起来像这样：</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>有了 <code>?</code>，对一个 <code>Vec</code> 实现 <code>fmt::Display</code> 就很简单了：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt; // 导入 `fmt` 模块。

// 定义一个包含单个 `Vec` 的结构体 `List`。
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 使用元组的下标获取值，并创建一个 `vec` 的引用。
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // 使用 `v` 对 `vec` 进行迭代，并用 `count` 记录迭代次数。
        for (count, v) in vec.iter().enumerate() {
            // 对每个元素（第一个元素除外）加上逗号。
            // 使用 `?` 或 `try!` 来返回错误。
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // 加上配对中括号，并返回一个 fmt::Result 值。
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3><a class="header" href="#动手试一试-3" id="动手试一试-3">动手试一试：</a></h3>
<p>更改程序使 vector 里面每个元素的下标也能够打印出来。新的结果如下：</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3><a class="header" href="#参见-4" id="参见-4">参见：</a></h3>
<p><a href="hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, 和 <a href="hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<h1><a class="header" href="#格式化" id="格式化">格式化</a></h1>
<p>我们已经看到，格式化的方式是通过<strong>格式字符串</strong>来指定的：</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>根据使用的<strong>参数类型</strong>是 <code>X</code>、<code>o</code> 还是<strong>未指定</strong>，同样的变量（<code>foo</code>）能够格式化成不同的形式。</p>
<p>这个格式化的功能是通过 trait 实现的，每种参数类型都对应一种 trait。最常见的格式化 trait 就是 <code>Display</code>，它可以处理参数类型为未指定的情况，比如 <code>{}</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // 纬度
    lat: f32,
    // 经度
    lon: f32,
}

impl Display for City {
    // `f` 是一个缓冲区（buffer），此方法必须将格式化后的字符串写入其中
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` 和 `format!` 类似，但它会将格式化后的字符串写入
        // 一个缓冲区（即第一个参数f）中。
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // 在添加了针对 fmt::Display 的实现后，请改用 {} 检验效果。
        println!(&quot;{:?}&quot;, *color)
    }
}
</code></pre></pre>
<p>在 <a href="https://rustwiki.org/zh-CN/std/fmt/"><code>fmt::fmt</code></a> 文档中可以查看<a href="https://rustwiki.org/zh-CN/std/fmt/#formatting-traits">格式化 traits 一览表</a>和它们的参数类型。</p>
<h3><a class="header" href="#动手试一试-4" id="动手试一试-4">动手试一试</a></h3>
<p>为上面的 <code>Color</code> 结构体实现 <code>fmt::Display</code>，应得到如下的输出结果：</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>如果感到疑惑，可看下面两条提示：</p>
<ul>
<li>你<a href="https://rustwiki.org/zh-CN/std/fmt/#argument-types">可能需要多次列出每个颜色</a>，</li>
<li>你可以使用 <code>:02</code> <a href="https://rustwiki.org/zh-CN/std/fmt/#width">补零使位数为 2 位</a>。</li>
</ul>
<h3><a class="header" href="#参见-5" id="参见-5">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/fmt/"><code>std::fmt</code></a></p>
<h1><a class="header" href="#原生类型" id="原生类型">原生类型</a></h1>
<p>Rust 提供了多种原生类型（<code>primitives</code>），包括：</p>
<h2><a class="header" href="#标量类型scalar-type" id="标量类型scalar-type">标量类型（scalar type）</a></h2>
<ul>
<li>有符号整数（signed integers）：<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code> 和 <code>isize</code>（指针宽度）</li>
<li>无符号整数（unsigned integers）： <code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code> 和 <code>usize</code>（指针宽度）</li>
<li>浮点数（floating point）： <code>f32</code>、<code>f64</code></li>
<li><code>char</code>（字符）：单个 Unicode 字符，如 <code>'a'</code>，<code>'α'</code> 和 <code>'∞'</code>（每个都是 4 字节）</li>
<li><code>bool</code>（布尔型）：只能是 <code>true</code> 或 <code>false</code></li>
<li>单元类型（unit type）：<code>()</code>。其唯一可能的值就是 <code>()</code> 这个空元组</li>
</ul>
<p>尽管单元类型的值是个元组，它却并不被认为是复合类型，因为并不包含多个值。</p>
<h2><a class="header" href="#复合类型compound-type" id="复合类型compound-type">复合类型（compound type）</a></h2>
<ul>
<li>数组（array）：如 <code>[1, 2, 3]</code></li>
<li>元组（tuple）：如 <code>(1, true)</code></li>
</ul>
<p>变量都能够显式地给出<strong>类型说明</strong>（type annotation）。数字还可以通过<strong>后缀</strong>（suffix）或<strong>默认方式</strong>来声明类型。整型默认为 <code>i32</code> 类型，浮点型默认为 <code>f64</code>类型。注意 Rust 还可以根据上下文来推断（infer）类型（译注：比如一个未声明类型整数和 <code>i64</code> 的整数相加，则该整数会自动推断为 <code>i64</code> 类型。仅当根据环境无法推断时，才按默认方式取整型数值为 <code>i32</code>，浮点数值为 <code>f64</code>）。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 变量可以给出类型说明。
    let logical: bool = true;

    let a_float: f64 = 1.0;  // 常规说明
    let an_integer   = 5i32; // 后缀说明

    // 否则会按默认方式决定类型。
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`

    // 类型也可根据上下文自动推断。
    let mut inferred_type = 12; // 根据下一行的赋值推断为 i64 类型
    inferred_type = 4294967296i64;

    // 可变的（mutable）变量，其值可以改变。
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;

    // 报错！变量的类型并不能改变。
    mutable = true;

    // 但可以用遮蔽（shadow）来覆盖前面的变量。
    let mutable = true;
}
</code></pre></pre>
<h3><a class="header" href="#参见-6" id="参见-6">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/"><code>std</code> 库</a>、<a href="variable_bindings/mut.html"><code>mut</code></a>、<a href="types/inference.html">类型推断</a> 和 <a href="variable_bindings/scope.html">变量遮蔽</a></p>
<h1><a class="header" href="#字面量和运算符" id="字面量和运算符">字面量和运算符</a></h1>
<p>整数 <code>1</code>、浮点数 <code>1.2</code>、字符 <code>'a'</code>、字符串 <code>&quot;abc&quot;</code>、布尔值 <code>true</code> 和单元类型 <code>()</code> 可以用数字、文字或符号之类的 “字面量”（literal）来表示。</p>
<p>另外，通过加前缀 <code>0x</code>、<code>0o</code>、<code>0b</code>，数字可以用十六进制、八进制或二进制记法表示。</p>
<p>为了改善可读性，可以在数值字面量中插入下划线，比如：<code>1_000</code> 等同于 <code>1000</code>，<code>0.000_001</code> 等同于 <code>0.000001</code>。</p>
<p>我们需要把字面量的类型告诉编译器。如前面学过的，我们使用 <code>u32</code> 后缀来表明字面量是一个 32 位无符号整数，<code>i32</code> 后缀表明字面量是一个 32 位有符号整数。</p>
<p><a href="https://rustwiki.org/zh-CN/reference/expressions.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">Rust</a> 提供了一系列的运算符（operator），它们的优先级和<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">类 C 语言</a>类似。（译注：类 C 语言包括 C/C++、Java、PHP 等语言）</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 整数相加
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // 整数相减
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // 试一试 ^ 尝试将 `1i32` 改为 `1u32`，体会为什么类型声明这么重要

    // 短路求值的布尔逻辑
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // 位运算
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // 使用下划线改善数字的可读性！
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<h1><a class="header" href="#元组" id="元组">元组</a></h1>
<p>元组是一个可以包含各种类型值的组合。元组使用括号 <code>()</code> 来构造（construct），而每个元组自身又是一个类型标记为 <code>(T1, T2, ...)</code> 的值，其中 <code>T1</code>、<code>T2</code> 是每个元素的类型。函数可以使用元组来返回多个值，因为元组可以拥有任意多个值。</p>
<pre><pre class="playground"><code class="language-rust editable">// 元组可以充当函数的参数和返回值
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // 可以使用 `let` 把一个元组的成员绑定到一些变量
    let (integer, boolean) = pair;

    (boolean, integer)
}

// 在 “动手试一试” 的练习中要用到下面这个结构体。
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // 包含各种不同类型的元组
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // 通过元组的下标来访问具体的值
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // 元组也可以充当元组的元素
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // 元组可以打印
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);

    // 但很长的元组无法打印
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
    // 试一试 ^ 取消上面两行的注释，阅读编译器给出的错误信息。

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // 创建单元素元组需要一个额外的逗号，这是为了和被括号包含的字面量作区分。
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    // 元组可以被解构（deconstruct），从而将值绑定给变量
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix)

}
</code></pre></pre>
<h3><a class="header" href="#动手试一试-5" id="动手试一试-5">动手试一试</a></h3>
<ol>
<li>
<p><strong>复习</strong>：在上面的例子中给 Matrix <code>结构体</code> 加上 <code>fmt::Display</code> trait，这样当你从 Debug 格式化 <code>{:?}</code> 切换到 Display 格式化 <code>{}</code> 时，会得到如下的输出：</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>可以回顾之前学过的<a href="primitives/../hello/print/print_display.html">显示（display）</a>的例子。</p>
</li>
<li>
<p>以 <code>reverse</code> 函数作为样板，写一个 <code>transpose</code> 函数，它可以接受一个 Matrix 作为参数，并返回一个右上 - 左下对角线上的两元素交换后的 Matrix。举个例子：</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>输出结果：</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<h1><a class="header" href="#数组和切片" id="数组和切片">数组和切片</a></h1>
<p>数组（array）是一组拥有相同类型 <code>T</code> 的对象的集合，在内存中是连续存储的。数组使用中括号 <code>[]</code> 来创建，且它们的大小在编译时会被确定。数组的类型标记为 <code>[T; length]</code>（译注：<code>T</code> 为元素类型，<code>length</code> 表示数组大小）。</p>
<p>切片（slice）类型和数组类似，但其大小在编译时是不确定的。相反，切片是一个双字对象（two-word object），第一个字是一个指向数据的指针，第二个字是切片的长度。这个 “字” 的宽度和 usize 相同，由处理器架构决定，比如在 x86-64 平台上就是 64 位。slice 可以用来借用数组的一部分。slice 的类型标记为 <code>&amp;[T]</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// 此函数借用一个 slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // 定长数组（类型标记是多余的）
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // 所有元素可以初始化成相同的值
    let ys: [i32; 500] = [0; 500];

    // 下标从 0 开始
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` 返回数组的大小
    println!(&quot;array size: {}&quot;, xs.len());

    // 数组是在栈中分配的
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // 数组可以自动被借用成为 slice
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // slice 可以指向数组的一部分
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // 越界的下标会引发致命错误（panic）
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<h1><a class="header" href="#自定义类型" id="自定义类型">自定义类型</a></h1>
<p>Rust 自定义数据类型主要是通过下面这两个关键字来创建：</p>
<ul>
<li><code>struct</code>： 定义一个结构体（structure）</li>
<li><code>enum</code>： 定义一个枚举类型（enumeration）</li>
</ul>
<p>而常量（constant）可以通过 <code>const</code> 和 <code>static</code> 关键字来创建。</p>
<h1><a class="header" href="#结构体" id="结构体">结构体</a></h1>
<p>结构体（structure，缩写成 struct）有 3 种类型，使用 <code>struct</code> 关键字来创建：</p>
<ul>
<li>元组结构体（tuple struct），事实上就是具名元组而已。</li>
<li>经典的 <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C 语言风格结构体</a>（C struct）。</li>
<li>单元结构体（unit struct），不带字段，在泛型中很有用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// 单元结构体
struct Unit;

// 元组结构体
struct Pair(i32, f32);

// 带有两个字段的结构体
struct Point {
    x: f32,
    y: f32,
}

// 结构体可以作为另一个结构体的字段
#[allow(dead_code)]
struct Rectangle {
    // 可以在空间中给定左上角和右下角在空间中的位置来指定矩形。
    top_left: Point,
    bottom_right: Point,
}

fn main() {
    // 使用简单的写法初始化字段，并创建结构体
    let name = String::from(&quot;Peter&quot;);
    let age = 27;
    let peter = Person { name, age };

    // 以 Debug 方式打印结构体
    println!(&quot;{:?}&quot;, peter);

    // 实例化结构体 `Point`
    let point: Point = Point { x: 10.3, y: 0.4 };

    // 访问 point 的字段
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // 使用结构体更新语法创建新的 point，
    // 这样可以用到之前的 point 的字段
    let bottom_right = Point { x: 5.2, ..point };

    // `bottom_right.y` 与 `point.y` 一样，因为这个字段就是从 `point` 中来的
    println!(&quot;second point: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // 使用 `let` 绑定来解构 point
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Rectangle {
        // 结构体的实例化也是一个表达式
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // 实例化一个单元结构体
    let _unit = Unit;

    // 实例化一个元组结构体
    let pair = Pair(1, 0.1);

    // 访问元组结构体的字段
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // 解构一个元组结构体
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3><a class="header" href="#动手试一试-6" id="动手试一试-6">动手试一试:</a></h3>
<ol>
<li>增加一个计算 <code>Rectangle</code> （长方形）面积的函数 <code>rect_area</code>（尝试使用嵌套的解构方式）。</li>
<li>增加一个函数 <code>square</code>，接受的参数是一个 <code>Point</code> 和一个 <code>f32</code>，并返回一个 <code>Rectangle</code>（长方形），其左上角位于该点上，长和宽都对应于 <code>f32</code>。</li>
</ol>
<h3><a class="header" href="#参见-7" id="参见-7">参见:</a></h3>
<p><a href="custom_types/../attribute.html">属性</a> 和 <a href="custom_types/../flow_control/match/destructuring.html">解构</a></p>
<h1><a class="header" href="#枚举" id="枚举">枚举</a></h1>
<p><code>enum</code> 关键字允许创建一个从数个不同取值中选其一的枚举类型（enumeration）。任何一个在 <code>struct</code> 中合法的取值在 <code>enum</code> 中也合法。</p>
<pre><pre class="playground"><code class="language-rust editable">// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]

// 创建一个 `enum`（枚举）来对 web 事件分类。注意变量名和类型共同指定了 `enum`
// 取值的种类：`PageLoad` 不等于 `PageUnload`，`KeyPress(char)` 不等于
// `Paste(String)`。各个取值不同，互相独立。
enum WebEvent {
    // 一个 `enum` 可以是单元结构体（称为 `unit-like` 或 `unit`），
    PageLoad,
    PageUnload,
    // 或者一个元组结构体，
    KeyPress(char),
    Paste(String),
    // 或者一个普通的结构体。
    Click { x: i64, y: i64 }
}

// 此函数将一个 `WebEvent` enum 作为参数，无返回值。
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // 从 `enum` 里解构出 `c`。
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // 把 `Click` 解构给 `x` and `y`。
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` 从一个字符串切片中创建一个具有所有权的 `String`。
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre></pre>
<h2><a class="header" href="#类型别名" id="类型别名">类型别名</a></h2>
<p>若使用类型别名，则可以通过其别名引用每个枚举变量。当枚举的名称太长或者太一般化，且你想要对其重命名，那么这对你会有所帮助。</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// 创建一个类型别名
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // 我们可以通过别名引用每个枚举变量，避免使用又长又不方便的枚举名字
    let x = Operations::Add;
}
</code></pre></pre>
<p>最常见的情况就是在 <code>impl</code> 块中使用 <code>Self</code> 别名。</p>
<pre><pre class="playground"><code class="language-rust editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre></pre>
<p>该功能已在 Rust 中稳定下来， 可以阅读 <a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">stabilization report</a> 来了解更多有关枚举和类型别名的知识。</p>
<h3><a class="header" href="#参见-8" id="参见-8">参见：</a></h3>
<p><a href="custom_types/../flow_control/match.html"><code>match</code></a>, <a href="custom_types/../fn.html"><code>fn</code></a>, 和 <a href="custom_types/../std/str.html"><code>String</code></a>, <a href="https://rust-lang.github.io/rfcs/2338-type-alias-enum-variants.html">“类型别名枚举变量” 的 RFC</a></p>
<h1><a class="header" href="#使用-use" id="使用-use">使用 use</a></h1>
<p>使用 <code>use</code> 声明的话，就可以不写出名称的完整路径了：</p>
<pre><pre class="playground"><code class="language-rust editable">// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // 显式地 `use` 各个名称使他们直接可用，而不需要指定它们来自 `Status`。
    use Status::{Poor, Rich};
    // 自动地 `use` `Work` 内部的各个名称。
    use Work::*;

    // `Poor` 等价于 `Status::Poor`。
    let status = Poor;
    // `Civilian` 等价于 `Work::Civilian`。
    let work = Civilian;

    match status {
        // 注意这里没有用完整路径，因为上面显式地使用了 `use`。
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        // 再次注意到没有用完整路径。
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-9" id="参见-9">参见：</a></h3>
<p><a href="custom_types/enum/../../flow_control/match.html"><code>match</code></a> 和 <a href="custom_types/enum/../../mod/use.html"><code>use</code></a></p>
<h1><a class="header" href="#c-风格用法" id="c-风格用法">C 风格用法</a></h1>
<p><code>enum</code> 也可以像 C 语言风格的枚举类型那样使用。</p>
<pre><pre class="playground"><code class="language-rust editable">// 该属性用于隐藏对未使用代码的警告。
#![allow(dead_code)]

// 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum
enum Number {
    Zero,
    One,
    Two,
}

// 拥有显式辨别值（explicit discriminator）的 enum
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enum` 可以转成整型。
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3><a class="header" href="#参考" id="参考">参考：</a></h3>
<p><a href="custom_types/enum/../../types/cast.html">类型转换</a></p>
<h1><a class="header" href="#测试实例链表" id="测试实例链表">测试实例：链表</a></h1>
<p><code>enum</code> 的一个常见用法就是创建链表（linked-list）：</p>
<pre><pre class="playground"><code class="language-rust editable">use List::*;

enum List {
    // Cons：元组结构体，包含链表的一个元素和一个指向下一节点的指针
    Cons(u32, Box&lt;List&gt;),
    // Nil：末结点，表明链表结束
    Nil,
}

// 可以为 enum 定义方法
impl List {
    // 创建一个空的 List 实例
    fn new() -&gt; List {
        // `Nil` 为 `List` 类型（译注：因 `Nil` 的完整名称是 `List::Nil`）
        Nil
    }

    // 处理一个 List，在其头部插入新元素，并返回该 List
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` 同样为 List 类型
        Cons(elem, Box::new(self))
    }

    // 返回 List 的长度
    fn len(&amp;self) -&gt; u32 {
        // 必须对 `self` 进行匹配（match），因为这个方法的行为取决于 `self` 的
        // 取值种类。
        // `self` 为 `&amp;List` 类型，`*self` 为 `List` 类型，匹配一个具体的 `T`
        // 类型要好过匹配引用 `&amp;T`。
        match *self {
            // 不能得到 tail 的所有权，因为 `self` 是借用的；
            // 因此使用一个对 tail 的引用
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // （递归的）基准情形（base case）：一个长度为 0 的空列表
            Nil =&gt; 0
        }
    }

    // 返回列表的字符串表示（该字符串是堆分配的）
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` 和 `print!` 类似，但返回的是一个堆分配的字符串，
                // 而不是打印结果到控制台上
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // 创建一个空链表
    let mut list = List::new();

    // 追加一些元素
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 显示链表的最后状态
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3><a class="header" href="#参见-10" id="参见-10">参见：</a></h3>
<p><a href="custom_types/enum/../../std/box.html"><code>Box</code></a> 和 <a href="custom_types/enum/../../fn/methods.html">方法</a></p>
<h1><a class="header" href="#常量" id="常量">常量</a></h1>
<p>Rust 有两种常量，可以在任意作用域声明，包括全局作用域。它们都需要显式的类型声明：</p>
<ul>
<li><code>const</code>：不可改变的值（通常使用这种）。</li>
<li><code>static</code>：具有 <a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a> 生命周期的，可以是可变的变量（译注：须使用
<code>static mut</code> 关键字）。</li>
</ul>
<p>有个特例就是 <code>&quot;string&quot;</code> 字面量。它可以不经改动就被赋给一个 <code>static</code> 变量，因为它的类型标记：<code>&amp;'static str</code> 就包含了所要求的生命周期 <code>'static</code>。其他的引用类型都必须特地声明，使之拥有 <code>'static</code> 生命周期。这两种引用类型的差异似乎也无关紧要，因为无论如何，<code>static</code> 变量都得显式地声明。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 全局变量是在所有其他作用域之外声明的。
static LANGUAGE: &amp;'static str = &quot;Rust&quot;;
const  THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // 在一般函数中访问常量
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 在 main 函数（主函数）中访问常量
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // 报错！不能修改一个 `const` 常量。
    THRESHOLD = 5;
    // 改正 ^ 注释掉此行
}
</code></pre></pre>
<h3><a class="header" href="#参见-11" id="参见-11">参见：</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md"><code>const</code>/<code>static</code> RFC</a>,
<a href="custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code> 生命周期</a></p>
<h1><a class="header" href="#变量绑定" id="变量绑定">变量绑定</a></h1>
<p>Rust 通过静态类型确保类型安全。变量绑定可以在声明时说明类型，不过在多数情况下，编译器能够从上下文推导出变量的类型，从而大大减少了类型说明的工作。</p>
<p>使用 <code>let</code> 绑定操作可以将值（比如字面量）绑定（bind）到变量。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // 将 `an_integer` 复制到 `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // 编译器会对未使用的变量绑定产生警告；可以给变量名加上下划线前缀来消除警告。
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // 改正 ^ 在变量名前加上下划线以消除警告
}
</code></pre></pre>
<h1><a class="header" href="#可变变量" id="可变变量">可变变量</a></h1>
<p>变量绑定默认是不可变的（immutable），但加上 <code>mut</code> 修饰语后变量就可以改变。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // 正确代码
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // 错误！
    _immutable_binding += 1;
    // 改正 ^ 将此行注释掉
}
</code></pre></pre>
<p>编译器会给出关于变量可变性的详细诊断信息。</p>
<h1><a class="header" href="#作用域和遮蔽" id="作用域和遮蔽">作用域和遮蔽</a></h1>
<p>变量绑定有一个作用域（scope），它被限定只在一个<strong>代码块</strong>（block）中生存（live）。
代码块是一个被 <code>{}</code> 包围的语句集合。另外也允许<a href="https://en.wikipedia.org/wiki/Variable_shadowing">变量遮蔽</a>（variable
shadowing）。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 此绑定生存于 main 函数中
    let long_lived_binding = 1;

    // 这是一个代码块，比 main 函数拥有更小的作用域
    {
        // 此绑定只存在于本代码块
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // 此绑定*遮蔽*了外面的绑定
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // 代码块结束

    // 报错！`short_lived_binding` 在此作用域上不存在
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // 改正 ^ 注释掉这行

    println!(&quot;outer long: {}&quot;, long_lived_binding);

    // 此绑定同样*遮蔽*了前面的绑定
    let long_lived_binding = 'a';

    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<h1><a class="header" href="#变量先声明" id="变量先声明">变量先声明</a></h1>
<p>可以先声明（declare）变量绑定，后面才将它们初始化（initialize）。但是这种做法很少用，因为这样可能导致使用未初始化的变量。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 声明一个变量绑定
    let a_binding;

    {
        let x = 2;

        // 初始化一个绑定
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // 报错！使用了未初始化的绑定
    println!(&quot;another binding: {}&quot;, another_binding);
    // 改正 ^ 注释掉此行

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>编译器禁止使用未经初始化的变量，因为这会产生未定义行为（undefined behavior）。</p>
<h1><a class="header" href="#冻结" id="冻结">冻结</a></h1>
<p>当数据被相同的名称不变地绑定时，它还会<strong>冻结</strong>（freeze）。在不可变绑定超出作用域之前，无法修改已冻结的数据：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // 被不可变的 `_mutable_integer` 遮蔽
        let _mutable_integer = _mutable_integer;

        // 报错！`_mutable_integer` 在本作用域被冻结
        _mutable_integer = 50;
        // 改正 ^ 注释掉上面这行

        // `_mutable_integer` 离开作用域
    }

    // 正常运行！ `_mutable_integer` 在这个作用域没有冻结
    _mutable_integer = 3;
}
</code></pre></pre>
<h1><a class="header" href="#类型系统" id="类型系统">类型系统</a></h1>
<p>Rust 提供了多种机制，用于改变或定义原生类型和用户定义类型。接下来会讲到：</p>
<ul>
<li>原生类型的<a href="types/cast.html">类型转换</a>（cast）。</li>
<li>指定<a href="types/literals.html">字面量</a>的类型。</li>
<li>使用<a href="types/inference.html">类型推断</a>（type inference）。</li>
<li>给类型<a href="types/alias.html">取别名</a>（alias）。</li>
</ul>
<h1><a class="header" href="#类型转换" id="类型转换">类型转换</a></h1>
<p>Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 <code>as</code> 关键字进行显式类型转换（casting）。</p>
<p>整型之间的转换大体遵循 C 语言的惯例，除了 C 会产生未定义行为的情形。在 Rust 中所有整型转换都是定义良好的。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 不显示类型转换产生的溢出警告。
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // 错误！不提供隐式转换
    let integer: u8 = decimal;
    // 改正 ^ 注释掉这一行

    // 可以显式转换
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // 当把任何类型转换为无符号类型 T 时，会不断加上或减去 (std::T::MAX + 1)
    // 直到值位于新类型 T 的范围内。

    // 1000 已经在 u16 的范围内
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // 事实上的处理方式是：从最低有效位（LSB，least significant bits）开始保留
    // 8 位，然后剩余位置，直到最高有效位（MSB，most significant bit）都被抛弃。
    // 译注：MSB 就是二进制的最高位，LSB 就是二进制的最低位，按日常书写习惯就是
    // 最左边一位和最右边一位。
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // 对正数，这就和取模一样。
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // 当转换到有符号类型时，（位操作的）结果就和 “先转换到对应的无符号类型，
    // 如果 MSB 是 1，则该值为负” 是一样的。

    // 当然如果数值已经在目标类型的范围内，就直接把它放进去。
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 转成 u8 还是 128，但转到 i8 相当于给 128 取八位的二进制补码，其值是：
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // 重复之前的例子
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // 232 的二进制补码是 -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<h1><a class="header" href="#字面量" id="字面量">字面量</a></h1>
<p>对数值字面量，只要把类型作为后缀加上去，就完成了类型说明。比如指定字面量 <code>42</code> 的类型是 <code>i32</code>，只需要写 <code>42i32</code>。</p>
<p>无后缀的数值字面量，其类型取决于怎样使用它们。如果没有限制，编译器会对整数使用 <code>i32</code>，对浮点数使用 <code>f64</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 带后缀的字面量，其类型在初始化时已经知道了。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // 无后缀的字面量，其类型取决于如何使用它们。
    let i = 1;
    let f = 1.0;

    // `size_of_val` 返回一个变量所占的字节数
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>上面的代码使用了一些还没有讨论过的概念。心急的读者可以看看下面的简短解释：</p>
<ul>
<li><code>fun(&amp;foo)</code> 用<strong>传引用</strong>（pass by reference）的方式把变量传给函数，而非传值（pass by value，写法是 <code>fun(foo)</code>）。更多细节请看<a href="types/../scope/borrow.html">借用</a>。</li>
<li><code>std::mem::size_of_val</code> 是一个函数，这里使用其<strong>完整路径</strong>（full path）调用。代码可以分成一些叫做<strong>模块</strong>（module）的逻辑单元。在本例中，<code>size_of_val</code> 函数是在 <code>mem</code> 模块中定义的，而 <code>mem</code> 模块又是在 <code>std</code> <strong>crate</strong> 中定义的。更多细节请看<a href="types/../mod.html">模块</a>和<a href="types/../crates.html">crate</a>.</li>
</ul>
<h1><a class="header" href="#类型推断" id="类型推断">类型推断</a></h1>
<p>Rust 的类型推断引擎是很聪明的，它不只是在初始化时看看<a href="https://en.wikipedia.org/wiki/Value_%28computer_science%29#lrvalue">右值</a>（r-value）的类型而已，它还会考察变量之后会怎样使用，借此推断类型。这是一个类型推导的进阶例子：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 因为有类型说明，编译器知道 `elem` 的类型是 u8。
    let elem = 5u8;

    // 创建一个空向量（vector，即不定长的，可以增长的数组）。
    let mut vec = Vec::new();
    // 现在编译器还不知道 `vec` 的具体类型，只知道它是某种东西构成的向量（`Vec&lt;_&gt;`）
    
    // 在向量中插入 `elem`。
    vec.push(elem);
    // 啊哈！现在编译器知道 `vec` 是 u8 的向量了（`Vec&lt;u8&gt;`）。
    // 试一试 ^ 注释掉 `vec.push(elem)` 这一行。

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>没有必要写类型说明，编译器和程序员皆大欢喜！</p>
<h1><a class="header" href="#别名" id="别名">别名</a></h1>
<p>可以用 <code>type</code> 语句给已有的类型取个新的名字。类型的名字必须遵循驼峰命名法（像是
<code>CamelCase</code> 这样），否则编译器将给出警告。原生类型是例外，比如：
<code>usize</code>、<code>f32</code>，等等。</p>
<pre><pre class="playground"><code class="language-rust editable">// `NanoSecond` 是 `u64` 的新名字。
type NanoSecond = u64;
type Inch = u64;

// 通过这个属性屏蔽警告。
#[allow(non_camel_case_types)]
type u64_t = u64;
// 试一试 ^ 移除上面那个属性

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 注意类型别名*并不能*提供额外的类型安全，因为别名*并不是*新的类型。
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 <code>IoResult&lt;T&gt;</code>
是 <code>Result&lt;T, IoError&gt;</code> 类型的别名。</p>
<h3><a class="header" href="#参见-12" id="参见-12">参见:</a></h3>
<p><a href="types/../attribute.html">属性</a></p>
<h1><a class="header" href="#类型转换-1" id="类型转换-1">类型转换</a></h1>
<p>Rust 使用 <a href="trait.html">trait</a> 解决类型之间的转换问题。最一般的转换会用到 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>Into</code></a> 两个 trait。不过，即便常见的情况也可能会用到特别的 trait，尤其是从 <code>String</code> 转换到别的类型，以及把别的类型转换到 <code>String</code> 时。</p>
<h1><a class="header" href="#from-和-into" id="from-和-into"><code>From</code> 和 <code>Into</code></a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>Into</code></a> 两个 trait 是内部相关联的，实际上这是它们实现的一部分。如果我们能够从类型 B 得到类型 A，那么很容易相信我们也能够把类型 B 转换为类型 A。</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> trait 允许一种类型定义 “怎么根据另一种类型生成自己”，因此它提供了一种类型转换的简单机制。在标准库中有无数 <code>From</code> 的实现，规定原生类型及其他常见类型的转换功能。</p>
<p>比如，可以很容易地把 <code>str</code> 转换成 <code>String</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<p>也可以为我们自己的类型定义转换机制：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.Into.html"><code>Into</code></a> trait 就是把 <code>From</code> trait 倒过来而已。也就是说，如果你为你的类型实现了 <code>From</code>，那么同时你也就免费获得了 <code>Into</code>。</p>
<p>使用 <code>Into</code> trait 通常要求指明要转换到的类型，因为编译器大多数时候不能推断它。不过考虑到我们免费获得了 <code>Into</code>，这点代价不值一提。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 试试删除类型说明
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h1><a class="header" href="#tryfrom-and-tryinto" id="tryfrom-and-tryinto"><code>TryFrom</code> and <code>TryInto</code></a></h1>
<p>类似于 <a href="conversion/from_into.html"><code>From</code> 和 <code>Into</code></a>，<a href="https://rustwiki.org/zh-CN/std/convert/trait.TryFrom.html"><code>TryFrom</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/convert/trait.TryInto.html"><code>TryInto</code></a> 是类型转换的通用 trait。不同于 <code>From</code>/<code>Into</code> 的是，<code>TryFrom</code> 和 <code>TryInto</code> trait 用于易出错的转换，也正因如此，其返回值是 <a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 型。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom

    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto

    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<h1><a class="header" href="#tostring-和-fromstr" id="tostring-和-fromstr"><code>ToString</code> 和 <code>FromStr</code></a></h1>
<h2><a class="header" href="#tostring" id="tostring"><code>ToString</code></a></h2>
<p>要把任何类型转换成 <code>String</code>，只需要实现那个类型的 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html"><code>ToString</code></a> trait。然而不要直接这么做，您应该实现<a href="https://rustwiki.org/zh-CN/std/fmt/trait.Display.html"><code>fmt::Display</code></a> trait，它会自动提供 <a href="https://rustwiki.org/zh-CN/std/string/trait.ToString.html"><code>ToString</code></a>，并且还可以用来打印类型，就像 <a href="conversion/../hello/print.html"><code>print!</code></a> 一节中讨论的那样。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Circle of radius {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<p>译注：一个实现 <code>ToString</code> 的例子</p>
<pre><pre class="playground"><code class="language-rust editable">use std::string::ToString;

struct Circle {
    radius: i32
}

impl ToString for Circle {
    fn to_string(&amp;self) -&gt; String {
        format!(&quot;Circle of radius {:?}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2><a class="header" href="#解析字符串" id="解析字符串">解析字符串</a></h2>
<p>我们经常需要把字符串转成数字。完成这项工作的标准手段是用 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse</code></a> 函数。我们得提供要转换到的类型，这可以通过不使用类型推断，或者用 “涡轮鱼” 语法（turbo fish，<code>&lt;&gt;</code>）实现。</p>
<p>只要对目标类型实现了 <a href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html"><code>FromStr</code></a> trait，就可以用 <code>parse</code> 把字符串转换成目标类型。
标准库中已经给无数种类型实现了 <code>FromStr</code>。如果要转换到用户定义类型，只要手动实现
<code>FromStr</code> 就行。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!{&quot;Sum: {:?}&quot;, sum};
}
</code></pre></pre>
<h1><a class="header" href="#表达式" id="表达式">表达式</a></h1>
<p>Rust 程序（大部分）由一系列语句构成：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 语句
    // 语句
    // 语句
}
</code></pre></pre>
<p>Rust 有多种语句。最普遍的语句类型有两种：一种是声明绑定变量，另一种是表达式带上英文分号(;)：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 变量绑定
    let x = 5;

    // 表达式;
    x;
    x + 1;
    15;
}
</code></pre></pre>
<p>代码块也是表达式，所以它们可以用作赋值中的值。代码块中的最后一个表达式将赋给适当的表达式，例如局部变量。但是，如果代码块的最后一个表达式结尾处有分号，则返回值为 <code>()</code>（译注：代码块中的最后一个语句是代码块中<strong>实际执行</strong>的最后一个语句，而不一定是代码块中最后一行的语句）。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 将此表达式赋给 `y`
        x_cube + x_squared + x
    };

    let z = {
        // 分号结束了这个表达式，于是将 `()` 赋给 `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h1><a class="header" href="#流程控制" id="流程控制">流程控制</a></h1>
<p>任何编程语言都包含的一个必要部分就是改变控制流程：<code>if</code>/<code>else</code>，<code>for</code> 等。让我们谈谈 Rust 语言中的这部分内容。</p>
<h1><a class="header" href="#ifelse" id="ifelse"><code>if/else</code></a></h1>
<p><code>if</code>-<code>else</code> 分支判断和其他语言类似。不同的是，Rust 语言中的布尔判断条件不必使用小括号包裹，且每个条件后面都跟着一个代码块。<code>if</code>-<code>else</code> 条件选择是一个表达式，并且所有分支都必须返回相同的类型。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            // 这个表达式返回一个 `i32` 类型。
            10 * n
        } else {
            println!(&quot;, and is a big number, half the number&quot;);

            // 这个表达式也必须返回一个 `i32` 类型。
            n / 2
            // 试一试 ^ 试着加上一个分号来结束这条表达式。
        };
    //   ^ 不要忘记在这里加上一个分号！所有的 `let` 绑定都需要它。

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<h1><a class="header" href="#loop-循环" id="loop-循环">loop 循环</a></h1>
<p>Rust 提供了 <code>loop</code> 关键字来表示一个无限循环。</p>
<p>可以使用 <code>break</code> 语句在任何时候退出一个循环，还可以使用 <code>continue</code> 跳过循环体的剩余部分并开始下一轮循环。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // 无限循环
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // 跳过这次迭代的剩下内容
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // 退出循环
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#嵌套循环和标签" id="嵌套循环和标签">嵌套循环和标签</a></h1>
<p>在处理嵌套循环的时候可以 <code>break</code> 或 <code>continue</code> 外层循环。在这类情形中，循环必须用一些 <code>'label</code>（标签）来注明，并且标签必须传递给 <code>break</code>/<code>continue</code> 语句。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // 这只是中断内部的循环
            //break;

            // 这会中断外层循环
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#从-loop-循环中返回" id="从-loop-循环中返回">从 loop 循环中返回</a></h1>
<p><code>loop</code> 有个用途是尝试一个操作直到成功为止。若操作返回一个值，则可能需要将其传递给代码的其余部分：将该值放在 <code>break</code> 之后，它就会被 <code>loop</code> 表达式返回。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while-循环" id="while-循环">while 循环</a></h1>
<p><code>while</code> 关键字可以用作当型循环（当条件满足时循环）。</p>
<p>让我们用 <code>while</code> 循环写一下臭名昭著的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>（译者补充：<a href="https://leetcode-cn.com/problems/fizz-buzz/">LeetCode 上的 FizzBuzz 问题描述</a>） 程序。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 计数器变量
    let mut n = 1;

    // 当 `n` 小于 101 时循环
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // 计数器值加 1
        n += 1;
    }
}
</code></pre></pre>
<h1><a class="header" href="#for-循环" id="for-循环">for 循环</a></h1>
<h2><a class="header" href="#for-与区间" id="for-与区间">for 与区间</a></h2>
<p><code>for in</code> 结构可以遍历一个 <code>Iterator</code>（迭代器）。创建迭代器的一个最简单的方法是使用区间标记 <code>a..b</code>。这会生成从 <code>a</code>（包含此值） 到 <code>b</code>（不含此值）的，步长为 1 的一系列值。</p>
<p>让我们使用 <code>for</code> 代替 <code>while</code> 来写 FizzBuzz 程序。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n` 将在每次迭代中分别取 1, 2, ..., 100
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>或者，可以使用<code>a..=b</code>表示两端都包含在内的范围。上面的代码可以写成：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `n` 将在每次迭代中分别取 1, 2, ..., 100
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#for-与迭代器" id="for-与迭代器">for 与迭代器</a></h2>
<p><code>for in</code> 结构能以几种方式与 <code>Iterator</code> 互动。在 <a href="flow_control/../trait/iter.html">迭代器</a> trait 一节将会谈到，如果没有特别指定，<code>for</code> 循环会对给出的集合应用 <code>into_iter</code> 函数，把它转换成一个迭代器。这并不是把集合变成迭代器的唯一方法，其他的方法有 <code>iter</code> 和<code>iter_mut</code> 函数。</p>
<p>这三个函数会以不同的方式返回集合中的数据。</p>
<ul>
<li><code>iter</code> - 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍可以使用。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<p>译注：Ferris 是 Rust 的<a href="https://www.rustacean.net/">非官方吉祥物</a>。</p>
<ul>
<li><code>into_iter</code> - 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }
    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>在上面这些代码中，注意 <code>match</code> 的分支中所写的类型不同，这是不同迭代方式的关键区别。因为类型不同，能够执行的操作当然也不同。</p>
<h3><a class="header" href="#参见-13" id="参见-13">参见：</a></h3>
<p><a href="flow_control/../trait/iter.html">Iterator</a></p>
<h1><a class="header" href="#match-匹配" id="match-匹配">match 匹配</a></h1>
<p>Rust 通过 <code>match</code> 关键字来提供模式匹配，和 C 语言的 <code>switch</code> 用法类似。第一个匹配分支会被比对，并且所有可能的值都必须被覆盖。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 13;
    // 试一试 ^ 将不同的值赋给 `number`

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // 匹配单个值
        1 =&gt; println!(&quot;One!&quot;),
        // 匹配多个值
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // 试一试 ^ 将 13 添加到质数列表中
        // 匹配一个闭区间范围
        13..=19 =&gt; println!(&quot;A teen&quot;),
        // 处理其他情况
        _ =&gt; println!(&quot;Ain't special&quot;),
        // 试一试 ^ 注释掉这个总括性的分支
    }

    let boolean = true;
    // match 也是一个表达式
    let binary = match boolean {
        // match 分支必须覆盖所有可能的值
        false =&gt; 0,
        true =&gt; 1,
        // 试一试 ^ 将其中一条分支注释掉
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<h1><a class="header" href="#解构" id="解构">解构</a></h1>
<p><code>match</code> 代码块能以多种方式解构物件。</p>
<ul>
<li><a href="flow_control/match/destructuring/destructure_tuple.html">解构元组</a></li>
<li><a href="flow_control/match/destructuring/destructure_enum.html">解构枚举</a></li>
<li><a href="flow_control/match/destructuring/destructure_pointers.html">解构指针</a></li>
<li><a href="flow_control/match/destructuring/destructure_structures.html">解构结构体</a></li>
</ul>
<h1><a class="header" href="#元组-1" id="元组-1">元组</a></h1>
<p>元组可以在 <code>match</code> 中解构，如下所示：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let triple = (0, -2, 3);
    // 试一试 ^ 将不同的值赋给 `triple`

    println!(&quot;Tell me about {:?}&quot;, triple);
    // match 可以解构一个元组
    match triple {
        // 解构出第二个和第三个元素
        (0, y, z) =&gt; println!(&quot;First is `0`, `y` is {:?}, and `z` is {:?}&quot;, y, z),
        (1, ..)  =&gt; println!(&quot;First is `1` and the rest doesn't matter&quot;),
        // `..` 可用来忽略元组的其余部分
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_` 表示不将值绑定到变量
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-14" id="参见-14">参见：</a></h3>
<p><a href="flow_control/match/destructuring/../../../primitives/tuples.html">元组</a></p>
<h1><a class="header" href="#枚举-1" id="枚举-1">枚举</a></h1>
<p>和前面相似，解构 <code>enum</code> 的方式如下：</p>
<pre><pre class="playground"><code class="language-rust editable">// 需要 `allow` 来消除警告，因为只使用了枚举类型的一种取值。
#[allow(dead_code)]
enum Color {
    // 这三个取值仅由它们的名字（而非类型）来指定。
    Red,
    Blue,
    Green,
    // 这些则把 `u32` 元组赋予不同的名字，以色彩模型命名。
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // 试一试 ^ 将不同的值赋给 `color`

    println!(&quot;What color is it?&quot;);
    // 可以使用 `match` 来解构 `enum`。
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // 不需要其它分支，因为所有的情形都已覆盖
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-15" id="参见-15">参见：</a></h3>
<p><a href="flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">色彩模型</a> 和 <a href="flow_control/match/destructuring/../../../custom_types/enum.html"><code>enum</code></a></p>
<h1><a class="header" href="#指针和引用" id="指针和引用">指针和引用</a></h1>
<p>对指针来说，解构（destructure）和解引用（dereference）要区分开，因为这两者的概念是不同的，和 <code>C</code> 那样的语言用法不一样。</p>
<ul>
<li>解引用使用 <code>*</code></li>
<li>解构使用 <code>&amp;</code>、<code>ref</code>、和 <code>ref mut</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 获得一个 `i32` 类型的引用。`&amp;` 表示取引用。
    let reference = &amp;4;

    match reference {
        // 如果用 `&amp;val` 这个模式去匹配 `reference`，就相当于做这样的比较：
        // `&amp;i32`（译注：即 `reference` 的类型）
        // `&amp;val`（译注：即用于匹配的模式）
        // ^ 我们看到，如果去掉匹配的 `&amp;`，`i32` 应当赋给 `val`。
        // 译注：因此可用 `val` 表示被 `reference` 引用的值 4。
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // 如果不想用 `&amp;`，需要在匹配前解引用。
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // 如果一开始就不用引用，会怎样？ `reference` 是一个 `&amp;` 类型，因为赋值语句
    // 的右边已经是一个引用。但下面这个不是引用，因为右边不是。
    let _not_a_reference = 3;

    // Rust 对这种情况提供了 `ref`。它更改了赋值行为，从而可以对具体值创建引用。
    // 下面这行将得到一个引用。
    let ref _is_a_reference = 3;

    // 相应地，定义两个非引用的变量，通过 `ref` 和 `ref mut` 仍可取得其引用。
    let value = 5;
    let mut mut_value = 6;

    // 使用 `ref` 关键字来创建引用。
    // 译注：下面的 r 是 `&amp;i32` 类型，它像 `i32` 一样可以直接打印，因此用法上
    // 似乎看不出什么区别。但读者可以把 `println!` 中的 `r` 改成 `*r`，仍然能
    // 正常运行。前面例子中的 `println!` 里就不能是 `*val`，因为不能对整数解
    // 引用。
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // 类似地使用 `ref mut`。
    match mut_value {
        ref mut m =&gt; {
            // 已经获得了 `mut_value` 的引用，先要解引用，才能改变它的值。
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-16" id="参见-16">参见：</a></h3>
<p><a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">ref 模式</a></p>
<h1><a class="header" href="#结构体-1" id="结构体-1">结构体</a></h1>
<p>类似地，解构 <code>struct</code> 如下所示：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    struct Foo { x: (u32, u32), y: u32 }

    // 解构结构体的成员
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!(&quot;a = {}, b = {},  y = {} &quot;, a, b, y);

    // 可以解构结构体并重命名变量，成员顺序并不重要

    let Foo { y: i, x: j } = foo;
    println!(&quot;i = {:?}, j = {:?}&quot;, i, j);

    // 也可以忽略某些变量
    let Foo { y, .. } = foo;
    println!(&quot;y = {}&quot;, y);

    // 这将得到一个错误：模式中没有提及 `x` 字段
    // let Foo { y } = foo;
}
</code></pre></pre>
<h3><a class="header" href="#参见-17" id="参见-17">参见：</a></h3>
<p><a href="flow_control/match/destructuring/../../../custom_types/structs.html">结构体</a>, <a href="flow_control/match/destructuring/../../../scope/borrow/ref.html">ref 模式</a></p>
<h1><a class="header" href="#卫语句" id="卫语句">卫语句</a></h1>
<p>可以加上 <code>match</code> <strong>卫语句</strong>（guard） 来过滤分支。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // 试一试 ^ 将不同的值赋给 `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // ^ `if` 条件部分是一个卫语句
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-18" id="参见-18">参见：</a></h3>
<p><a href="flow_control/match/../../primitives/tuples.html">元组</a></p>
<h1><a class="header" href="#绑定" id="绑定">绑定</a></h1>
<p>在 <code>match</code> 中，若间接地访问一个变量，则不经过重新绑定就无法在分支中再使用它。<code>match</code> 提供了 <code>@</code> 符号来绑定变量到名称：</p>
<pre><pre class="playground"><code class="language-rust editable">// `age` 函数，返回一个 `u32` 值。
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I haven't celebrated my first birthday yet&quot;),
        // 可以直接匹配（`match`） 1 ..= 12，但那样的话孩子会是几岁？
        // 相反，在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // 不符合上面的范围。返回结果。
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<p>你也可以使用绑定来“解构” <code>enum</code> 变体，例如 <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust editable">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // 得到 `Some` 可变类型，如果它的值（绑定到 `n` 上）等于 42，则匹配。
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // 匹配任意其他数字。
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // 匹配任意其他值（`None` 可变类型）。
        _            =&gt; (),
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-19" id="参见-19">参见：</a></h3>
<p><a href="flow_control/match/../../fn.html"><code>函数</code></a>，<a href="flow_control/match/../../custom_types/enum.html"><code>枚举</code></a> 和 <a href="flow_control/match/../../std/option.html"><code>Option</code></a></p>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>在一些场合下，用 <code>match</code> 匹配枚举类型并不优雅。比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 将 `optional` 定为 `Option&lt;i32&gt;` 类型
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ 行首需要 2 层缩进。这里从 optional 中解构出 `i`。
        // 译注：正确的缩进是好的，但并不是 “不缩进就不能运行” 这个意思。
    },
    _ =&gt; {},
    // ^ 必须有，因为 `match` 需要覆盖全部情况。不觉得这行很多余吗？
};

<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> 在这样的场合要简洁得多，并且允许指明数种失败情形下的选项：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 全部都是 `Option&lt;i32&gt;` 类型
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let` 结构读作：若 `let` 将 `number` 解构成 `Some(i)`，则执行
    // 语句块（`{}`）
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // 如果要指明失败情形，就使用 else：
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // 解构失败。切换到失败情形。
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    };

    // 提供另一种失败情况下的条件。
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // 解构失败。使用 `else if` 来判断是否满足上面提供的条件。
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // 条件的值为 false。于是以下是默认的分支：
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    };
}
</code></pre></pre>
<p>同样，可以用 <code>if let</code> 匹配任何枚举值：</p>
<pre><pre class="playground"><code class="language-rust editable">// 以这个 enum 类型为例
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 创建变量
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);

    // 变量 a 匹配到了 Foo::Bar
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }

    // 变量 b 没有匹配到 Foo::Bar，因此什么也不会打印。
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }

    // 变量 c 匹配到了 Foo::Qux，它带有一个值，就和上面例子中的 Some() 类似。
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }
}
</code></pre></pre>
<p>另一个好处是：<code>if let</code> 允许匹配枚举非参数化的变量，即枚举未注明 <code>#[derive(PartialEq)]</code>，我们也没有为其实现 <code>PartialEq</code>。在这种情况下，通常 <code>if Foo::Bar==a</code> 会出错，因为此类枚举的实例不具有可比性。但是，<code>if let</code> 是可行的。</p>
<p>你想挑战一下吗？使用 <code>if let</code>修复以下示例：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 该枚举故意未注明 `#[derive(PartialEq)]`，
// 并且也没为其实现 `PartialEq`。这就是为什么下面比较 `Foo::Bar==a` 会失败的原因。
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // 变量匹配 Foo::Bar
    if Foo::Bar == a {
    // ^-- 这就是编译时发现的错误。使用 `if let` 来替换它。
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-20" id="参见-20">参见：</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>枚举</code></a>，<a href="flow_control/../std/option.html"><code>Option</code></a>，和相关的 <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<h1><a class="header" href="#while-let" id="while-let">while let</a></h1>
<p>和 <code>if let</code> 类似，<code>while let</code> 也可以把别扭的 <code>match</code> 改写得好看一些。考虑下面这段使 <code>i</code> 不断增加的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 将 `optional` 设为 `Option&lt;i32&gt;` 类型
let mut optional = Some(0);

// 重复运行这个测试。
loop {
    match optional {
        // 如果 `optional` 解构成功，就执行下面语句块。
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ 需要三层缩进！
        },
        // 当解构失败时退出循环：
        _ =&gt; { break; }
        // ^ 为什么必须写这样的语句呢？肯定有更优雅的处理方式！
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用 <code>while let</code> 可以使这段代码变得更加优雅：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 将 `optional` 设为 `Option&lt;i32&gt;` 类型
    let mut optional = Some(0);

    // 这读作：当 `let` 将 `optional` 解构成 `Some(i)` 时，就
    // 执行语句块（`{}`）。否则就 `break`。
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ 使用的缩进更少，并且不用显式地处理失败情况。
    }
    // ^ `if let` 有可选的 `else`/`else if` 分句，
    // 而 `while let` 没有。
}
</code></pre></pre>
<h3><a class="header" href="#参见-21" id="参见-21">参见：</a></h3>
<p><a href="flow_control/../custom_types/enum.html"><code>枚举</code></a>，<a href="flow_control/../std/option.html"><code>Option</code></a>，和相关的 <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<h1><a class="header" href="#函数" id="函数">函数</a></h1>
<p>函数（function）使用 <code>fn</code> 关键字来声明。函数的参数需要标注类型，就和变量一样，如果函数返回一个值，返回类型必须在箭头 <code>-&gt;</code> 之后指定。</p>
<p>函数最后的表达式将作为返回值。也可以在函数内使用 <code>return</code> 语句来提前返一个值，甚至可以在循环或 <code>if</code> 内部使用。</p>
<p>让我们使用函数来重写 FizzBuzz 程序吧！</p>
<pre><pre class="playground"><code class="language-rust editable">// 和 C/C++ 不一样，Rust 的函数定义位置是没有限制的
fn main() {
    // 我们可以在这里使用函数，后面再定义它
    fizzbuzz_to(100);
}

// 一个返回布尔值的函数
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // 边界情况，提前返回
    if rhs == 0 {
        return false;
    }

    // 这是一个表达式，可以不用 `return` 关键字
    lhs % rhs == 0
}

// 一个 “不” 返回值的函数。实际上会返回一个单元类型 `()`。
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// 当函数返回 `()` 时，函数签名可以省略返回类型
fn fizzbuzz_to(n: u32) {
    for n in 1..=n {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<h1><a class="header" href="#方法" id="方法">方法</a></h1>
<p>方法（method）是依附于对象的函数。这些方法通过关键字 <code>self</code> 来访问对象中的数据和其他。方法在 <code>impl</code> 代码块中定义。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// 实现的代码块，`Point` 的所有方法都在这里给出
impl Point {
    // 这是一个静态方法（static method）
    // 静态方法不需要被实例调用
    // 这类方法一般用作构造器（constructor）
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 另外一个静态方法，需要两个参数：
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // 这是一个实例方法（instance method）
    // `&amp;self` 是 `self: &amp;Self` 的语法糖（sugar），其中 `Self` 是方法调用者的
    // 类型。在这个例子中 `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` 通过点运算符来访问结构体字段
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` 是一个 `f64` 类型的方法，返回调用者的绝对值
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // 这个方法要求调用者是可变的
    // `&amp;mut self` 为 `self: &amp;mut Self` 的语法糖
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` 拥有资源：两个堆分配的整型
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // 这个方法会 “消耗” 调用者的资源
    // `self` 为 `self: Self` 的语法糖
    fn destroy(self) {
        // 解构 `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` 和 `second` 离开作用域后释放
    }
}

fn main() {
    let rectangle = Rectangle {
        // 静态方法使用双冒号调用
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // 实例方法通过点运算符来调用
    // 注意第一个参数 `&amp;self` 是隐式传递的，亦即：
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // 报错！ `rectangle` 是不可变的，但这方法需要一个可变对象
    //rectangle.translate(1.0, 0.0);
    // 试一试 ^ 去掉此行的注释

    // 正常运行！可变对象可以调用可变方法
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // 报错！前面的 `destroy` 调用 “消耗了” `pair`
    //pair.destroy();
    // 试一试 ^ 将此行注释去掉
}
</code></pre></pre>
<h1><a class="header" href="#闭包" id="闭包">闭包</a></h1>
<p>Rust 中的闭包（closure），也叫做 lambda 表达式或者 lambda，是一类能够捕获周围作用域中变量的函数。例如，一个可以捕获 x 变量的闭包如下：</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>它们的语法和能力使它们在临时（on the fly）使用时相当方便。调用一个闭包和调用一个函数完全相同，不过调用闭包时，输入和返回类型两者都<strong>可以</strong>自动推导，而输入变量名<strong>必须</strong>指明。</p>
<p>其他的特点包括：</p>
<ul>
<li>声明时使用 <code>||</code> 替代 <code>()</code> 将输入参数括起来。</li>
<li>函数体定界符（<code>{}</code>）对于单个表达式是可选的，其他情况必须加上。</li>
<li>有能力捕获外部环境的变量。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 通过闭包和函数分别实现自增。
    // 译注：下面这行是使用函数的实现
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // 闭包是匿名的，这里我们将它们绑定到引用。
    // 类型标注和函数的一样，不过类型标注和使用 `{}` 来围住函数体都是可选的。
    // 这些匿名函数（nameless function）被赋值给合适地命名的变量。
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    // 译注：将闭包绑定到引用的说法可能不准。
    // 据[语言参考](https://doc.rust-lang.org/beta/reference/types.html#closure-types)
    // 闭包表达式产生的类型就是 “闭包类型”，不属于引用类型，而且确实无法对上面两个
    // `closure_xxx` 变量解引用。

    let i = 1;
    // 调用函数和闭包。
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // 没有参数的闭包，返回一个 `i32` 类型。
    // 返回类型是自动推导的。
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());
}
</code></pre></pre>
<h1><a class="header" href="#捕获" id="捕获">捕获</a></h1>
<p>闭包本质上很灵活，能做功能要求的事情，使闭包在没有类型标注的情况下运行。这使得捕获（capture）能够灵活地适应用例，既可移动（move），又可借用（borrow）。闭包可以通过以下方式捕获变量：</p>
<ul>
<li>通过引用：<code>&amp;T</code></li>
<li>通过可变引用：<code>&amp;mut T</code></li>
<li>通过值：<code>T</code></li>
</ul>
<p>闭包优先通过引用来捕获变量，并且仅在需要时使用其他方式。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    use std::mem;

    let color = String::from(&quot;green&quot;);

    // 这个闭包打印 `color`。它会立即借用（通过引用，`&amp;`）`color` 并将该借用和
    // 闭包本身存储到 `print` 变量中。`color` 会一直保持被借用状态直到
    // `print` 离开作用域。
    //
    // `println!` 只需传引用就能使用，而这个闭包捕获的也是变量的引用，因此无需
    // 进一步处理就可以使用 `println!`。
    let print = || println!(&quot;`color`: {}&quot;, color);

    // 使用借用来调用闭包 `color`。
    print();

    // `color` 可再次被不可变借用，因为闭包只持有一个指向 `color` 的不可变引用。
    let _reborrow = &amp;color;
    print();

    // 在最后使用 `print` 之后，移动或重新借用都是允许的。
    let _color_moved = color;

    let mut count = 0;
    // 这个闭包使 `count` 值增加。要做到这点，它需要得到 `&amp;mut count` 或者
    // `count` 本身，但 `&amp;mut count` 的要求没那么严格，所以我们采取这种方式。
    // 该闭包立即借用 `count`。
    //
    // `inc` 前面需要加上 `mut`，因为闭包里存储着一个 `&amp;mut` 变量。调用闭包时，
    // 该变量的变化就意味着闭包内部发生了变化。因此闭包需要是可变的。
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // 使用可变借用调用闭包
    inc();

    // 因为之后调用闭包，所以仍然可变借用 `count`
    // 试图重新借用将导致错误
    // let _reborrow = &amp;count;
    // ^ 试一试：将此行注释去掉。
    inc();

    // 闭包不再借用 `&amp;mut count`，因此可以正确地重新借用
    let _count_reborrowed = &amp;mut count;

    // 不可复制类型（non-copy type）。
    let movable = Box::new(3);

    // `mem::drop` 要求 `T` 类型本身，所以闭包将会捕获变量的值。这种情况下，
    // 可复制类型将会复制给闭包，从而原始值不受影响。不可复制类型必须移动
    // （move）到闭包中，因而 `movable` 变量在这里立即移动到了闭包中。
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` 消耗了该变量，所以该闭包只能调用一次。
    consume();
    //consume();
    // ^ 试一试：将此行注释去掉。
}
</code></pre></pre>
<p>在竖线 <code>|</code> 之前使用 <code>move</code> 会强制闭包取得被捕获变量的所有权：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // `Vec` 在语义上是不可复制的。
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    //println!(&quot;There're {} elements in vec&quot;, haystack.len());
    // ^ 取消上面一行的注释将导致编译时错误，因为借用检查不允许在变量被移动走
    // 之后继续使用它。

    // 在闭包的签名中删除 `move` 会导致闭包以不可变方式借用 `haystack`，因此之后
    // `haystack` 仍然可用，取消上面的注释也不会导致错误。
}
</code></pre></pre>
<h3><a class="header" href="#参见-22" id="参见-22">参见：</a></h3>
<p><a href="fn/closures/../../std/box.html"><code>Box</code></a> 和 <a href="https://rustwiki.org/zh-CN/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<h1><a class="header" href="#作为输入参数" id="作为输入参数">作为输入参数</a></h1>
<p>虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法是不允许的。当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 <code>trait</code> 中的一种来指定的。其受限制程度按以下顺序递减：</p>
<ul>
<li><code>Fn</code>：表示捕获方式为通过引用（<code>&amp;T</code>）的闭包</li>
<li><code>FnMut</code>：表示捕获方式为通过可变引用（<code>&amp;mut T</code>）的闭包</li>
<li><code>FnOnce</code>：表示捕获方式为通过值（<code>T</code>）的闭包</li>
</ul>
<blockquote>
<p>译注：顺序之所以是这样，是因为 <code>&amp;T</code> 只是获取了不可变的引用，<code>&amp;mut T</code> 则可以改变变量，<code>T</code> 则是拿到了变量的所有权而非借用。</p>
</blockquote>
<p>对闭包所要捕获的每个变量，编译器都将以限制最少的方式来捕获。</p>
<blockquote>
<p>译注：这句可能说得不对，事实上是在满足使用需求的前提下尽量以限制最多的方式捕获。</p>
</blockquote>
<p>例如用一个类型说明为 <code>FnOnce</code> 的闭包作为参数。这说明闭包可能采取 <code>&amp;T</code>，<code>&amp;mut T</code> 或 <code>T</code> 中的一种捕获方式，但编译器最终是根据所捕获变量在闭包里的使用情况决定捕获方式。</p>
<p>这是因为如果能以移动的方式捕获变量，则闭包也有能力使用其他方式借用变量。注意反过来就不再成立：如果参数的类型说明是 <code>Fn</code>，那么不允许该闭包通过 <code>&amp;mut T</code> 或 <code>T</code> 捕获变量。</p>
<p>在下面的例子中，试着分别用一用 <code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>，看看会发生什么：</p>
<pre><pre class="playground"><code class="language-rust editable">// 该函数将闭包作为参数并调用它。
fn apply&lt;F&gt;(f: F) where
    // 闭包没有输入值和返回值。
    F: FnOnce() {
    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。

    f();
}

// 输入闭包，返回一个 `i32` 整型的函数。
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // 不可复制的类型。
    // `to_owned` 从借用的数据创建有所有权的数据。
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。
    let diary = || {
        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。
        println!(&quot;I said {}.&quot;, greeting);

        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。
        // 现在需要 `FnMut`。
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // 手动调用 drop 又要求闭包通过值获取 `farewell`。
        // 现在需要 `FnOnce`。
        mem::drop(farewell);
    };

    // 以闭包作为参数，调用函数 `apply`。
    apply(diary);

    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3><a class="header" href="#参见-23" id="参见-23">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#类型匿名" id="类型匿名">类型匿名</a></h1>
<p>闭包从周围的作用域中捕获变量是简单明了的。这样会有某些后果吗？确实有。观察一下使用闭包作为函数参数，这要求闭包是<a href="fn/closures/../../generics.html">泛型</a>的，闭包定义的方式决定了这是必要的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `F` 必须是泛型的。
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>当闭包被定义，编译器会隐式地创建一个匿名类型的结构体，用以储存闭包捕获的变量，同时为这个未知类型的结构体实现函数功能，通过 <code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code> 三种 <code>trait</code> 中的一种。</p>
<p>若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。然而，使用未限定类型的参数 <code>&lt;T&gt;</code> 过于不明确，并且是不允许的。事实上，指明为该结构体实现的是 <code>Fn</code>、<code>FnMut</code>、或 <code>FnOnce</code> 中的哪种 <code>trait</code>，对于约束该结构体的类型而言就已经足够了。</p>
<pre><pre class="playground"><code class="language-rust editable">// `F` 必须为一个没有输入参数和返回值的闭包实现 `Fn`，这和对 `print` 的
// 要求恰好一样。
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 捕获 `x` 到匿名类型中，并为它实现 `Fn`。
    // 将闭包存储到 `print` 中。
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3><a class="header" href="#参见-24" id="参见-24">参见：</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">详尽分析</a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#输入函数" id="输入函数">输入函数</a></h1>
<p>既然闭包可以作为参数，你很可能想知道函数是否也可以呢。确实可以！如果你声明一个接受闭包作为参数的函数，那么任何满足该闭包的 trait 约束的函数都可以作为其参数。</p>
<pre><pre class="playground"><code class="language-rust editable">// 定义一个函数，可以接受一个由 `Fn` 限定的泛型 `F` 参数并调用它。
fn call_me&lt;F: Fn()&gt;(f: F) {
    f()
}

// 定义一个满足 `Fn` 约束的封装函数（wrapper function）。
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // 定义一个满足 `Fn` 约束的闭包。
    let closure = || println!(&quot;I'm a closure!&quot;);
    
    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>多说一句，<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code> 这些 <code>trait</code> 明确了闭包如何从周围的作用域中捕获变量。</p>
<h3><a class="header" href="#参见-25" id="参见-25">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#作为输出参数" id="作为输出参数">作为输出参数</a></h1>
<p>闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是可能的。然而返回闭包类型会有问题，因为目前 Rust 只支持返回具体（非泛型）的类型。按照定义，匿名的闭包的类型是未知的，所以只有使用<code>impl Trait</code>才能返回一个闭包。</p>
<p>返回闭包的有效特征是：</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>除此之外，还必须使用 <code>move</code> 关键字，它表明所有的捕获都是通过值进行的。这是必须的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。</p>
<pre><pre class="playground"><code class="language-rust editable">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();
    
    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}

</code></pre></pre>
<h3><a class="header" href="#参见-26" id="参见-26">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://rustwiki.org/zh-CN/std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="fn/closures/../../generics.html">泛型</a> 和 <a href="fn/closures/../../trait/impl_trait.html">impl Trait</a>.</p>
<h1><a class="header" href="#std-中的例子" id="std-中的例子"><code>std</code> 中的例子</a></h1>
<p>本小节列出几个标准库中使用闭包的例子。</p>
<h1><a class="header" href="#iteratorany" id="iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> 是一个函数，若传给它一个迭代器（iterator），当其中任一元素满足谓词（predicate）时它将返回 <code>true</code>，否则返回 <code>false</code>（译注：谓词是闭包规定的， <code>true</code>/<code>false</code> 是闭包作用在元素上的返回值）。它的签名如下：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // 被迭代的类型。
    type Item;

    // `any` 接受 `&amp;mut self` 参数（译注：回想一下，这是 `self: &amp;mut Self` 的简写）
    // 表明函数的调用者可以被借用和修改，但不会被消耗。
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。
        // `Self::Item` 表明变量是通过值传递给闭包（译注：是迭代器对应的元素的类型）
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 对 vec 的 `iter()` 举出 `&amp;i32`。（通过用 `&amp;x` 匹配）把它解构成 `i32`。
    // 译注：注意 `any` 方法会自动地把 `vec.iter()` 举出的迭代器的元素一个个地
    // 传给闭包。因此闭包接收到的参数是 `&amp;i32` 类型的。
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // 对 vec 的 `into_iter()` 举出 `i32` 类型。无需解构。
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 对数组的 `iter()` 举出 `&amp;i32`。
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // 对数组的 `into_iter()` 举出 `i32`。
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#参见-27" id="参见-27">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<h1><a class="header" href="#iteratorfind" id="iteratorfind">Iterator::find</a></h1>
<p><code>Iterator::find</code> 是一个函数，在传给它一个迭代器时，将用 <code>Option</code> 类型返回第一个满足谓词的元素。它的签名如下：</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // 被迭代的类型。
    type Item;

    // `find` 接受 `&amp;mut self` 参数，表明函数的调用者可以被借用和修改，
    // 但不会被消耗。
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` 表示被捕获的变量最多只能被修改，而不能被消耗。
        // `&amp;Self::Item` 指明了被捕获变量的类型（译注：是对迭代器元素的引用类型）
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // 对 vec1 的 `iter()` 举出 `&amp;i32` 类型。
    let mut iter = vec1.iter();
    // 对 vec2 的 `into_iter()` 举出 `i32` 类型。
    let mut into_iter = vec2.into_iter();

    // 对迭代器举出的元素的引用是 `&amp;&amp;i32` 类型。解构成 `i32` 类型。
    // 译注：注意 `find` 方法会把迭代器元素的引用传给闭包。迭代器元素自身
    // 是 `&amp;i32` 类型，所以传给闭包的是 `&amp;&amp;i32` 类型。
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // 对迭代器举出的元素的引用是 `&amp;i32` 类型。解构成 `i32` 类型。
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // 对数组的 `iter()` 举出 `&amp;i32`。
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // 对数组的 `into_iter()` 通常举出 `i32`。
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#参见-28" id="参见-28">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<h1><a class="header" href="#高阶函数" id="高阶函数">高阶函数</a></h1>
<p>Rust 提供了高阶函数（Higher Order Function, HOF），指那些输入一个或多个函数，并且/或者产生一个更有用的函数的函数。HOF 和惰性迭代器（lazy iterator）给 Rust 带来了函数式（functional）编程的风格。</p>
<pre><pre class="playground"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // 命令式（imperative）的写法
    // 声明累加器变量
    let mut acc = 0;
    // 迭代：0，1, 2, ... 到无穷大
    for n in 0.. {
        // 数字的平方
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 若大于上限则退出循环
            break;
        } else if is_odd(n_squared) {
            // 如果是奇数就计数
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // 函数式的写法
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)             // 所有自然数取平方
             .take_while(|&amp;n| n &lt; upper) // 取小于上限的
             .filter(|&amp;n| is_odd(n))     // 取奇数
             .fold(0, |sum, i| sum + i); // 最后加起来
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://rustwiki.org/zh-CN/core/option/enum.Option.html">Option</a> 和 <a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html">迭代器</a> 都实现了不少高阶函数。</p>
<h1><a class="header" href="#发散函数" id="发散函数">发散函数</a></h1>
<p>发散函数（diverging function）绝不会返回。 它们使用 <code>!</code> 标记，这是一个空类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>和所有其他类型相反，这个类型无法实例化，因为此类型可能具有的所有可能值的集合为空。 注意，它与 <code>()</code> 类型不同，后者只有一个可能的值。</p>
<p>如下面例子，虽然返回值中没有信息，但此函数会照常返回。</p>
<pre><pre class="playground"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>下面这个函数相反，这个函数永远不会将控制内容返回给调用者。</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>虽然这看起来像是一个抽象的概念，但实际上这非常有用且方便。这种类型的主要优点是它可以被转换为任何其他类型，从而可以在需要精确类型的地方使用，例如在 <code>match</code> 匹配分支。 这允许我们编写如下代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // 注意这个 match 表达式的返回值必须为 u32，
            // 因为 “addition” 变量是这个类型。
            let addition: u32 = match i%2 == 1 {
                // “i” 变量的类型为 u32，这毫无问题。
                true =&gt; i,
                // 另一方面，“continue” 表达式不返回 u32，但它仍然没有问题，
                // 因为它永远不会返回，因此不会违反匹配表达式的类型要求。
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>这也是永远循环（如 <code>loop {}</code>）的函数（如网络服务器）或终止进程的函数（如 <code>exit()</code>）的返回类型。</p>
<h1><a class="header" href="#模块" id="模块">模块</a></h1>
<p>Rust 提供了一套强大的模块（module）系统，可以将代码按层次分成多个逻辑单元（模块），并管理这些模块之间的可见性（公有（public）或私有（private））。</p>
<p>模块是项（item）的集合，项可以是：函数，结构体，trait，<code>impl</code> 块，甚至其它模块。</p>
<h1><a class="header" href="#可见性" id="可见性">可见性</a></h1>
<p>默认情况下，模块中的项拥有私有的可见性（private visibility），不过可以加上 <code>pub</code> 修饰语来重载这一行为。模块中只有公有的（public）项可以从模块外的作用域访问。</p>
<pre><pre class="playground"><code class="language-rust editable">// 一个名为 `my_mod` 的模块
mod my_mod {
    // 模块中的项默认具有私有的可见性
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // 使用 `pub` 修饰语来改变默认可见性。
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // 在同一模块中，项可以访问其它项，即使它是私有的。
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // 模块也可以嵌套
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。
        // `path` 必须是父模块（parent module）或祖先模块（ancestor module）
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // 使用 `pub(super)` 语法定义的函数只在父模块中可见。
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // `pub(crate)` 使得函数只在当前 crate 中可见
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // 嵌套模块的可见性遵循相同的规则
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // 模块机制消除了相同名字的项之间的歧义。
    function();
    my_mod::function();

    // 公有项，包括嵌套模块内的，都可以在父模块外部访问。
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) 项可以在同一个 crate 中的任何地方访问
    my_mod::public_function_in_crate();

    // pub(in path) 项只能在指定的模块中访问
    // 报错！函数 `public_function_in_my_mod` 是私有的
    //my_mod::nested::public_function_in_my_mod();
    // 试一试 ^ 取消该行的注释

    // 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的

    // 报错！`private_function` 是私有的
    //my_mod::private_function();
    // 试一试 ^ 取消此行注释

    // 报错！`private_function` 是私有的
    //my_mod::nested::private_function();
    // 试一试 ^ 取消此行的注释

    // 报错！`private_nested` 是私有的
    //my_mod::private_nested::function();
    // 试一试 ^ 取消此行的注释
}
</code></pre></pre>
<h1><a class="header" href="#结构体的可见性" id="结构体的可见性">结构体的可见性</a></h1>
<p>结构体的字段也是一个可见性的层次。字段默认拥有私有的可见性，也可以加上 <code>pub</code> 修饰语来重载该行为。只有从结构体被定义的模块之外访问其字段时，这个可见性才会起作用，其意义是隐藏信息（即封装，encapsulation）。</p>
<pre><pre class="playground"><code class="language-rust editable">mod my {
    // 一个公有的结构体，带有一个公有的字段（类型为泛型 `T`）
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // 一个公有的结构体，带有一个私有的字段（类型为泛型 `T`）    
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // 一个公有的构造器方法
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // 带有公有字段的公有结构体，可以像平常一样构造
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // 并且它们的字段可以正常访问到。
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // 带有私有字段的公有结构体不能使用字段名来构造。
    // 报错！`ClosedBox` 含有私有字段。
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // 试一试 ^ 取消此行注释


    // 不过带有私有字段的结构体可以使用公有的构造器来创建。
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // 并且一个结构体中的私有字段不能访问到。
    // 报错！`content` 字段是私有的。
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // 试一试 ^ 取消此行注释    

}
</code></pre></pre>
<h3><a class="header" href="#参见-29" id="参见-29">参见：</a></h3>
<p><a href="mod/../generics.html">泛型</a> 和 <a href="mod/../fn/methods.html">方法</a></p>
<h1><a class="header" href="#use-声明" id="use-声明"><code>use</code> 声明</a></h1>
<p><code>use</code> 声明可以将一个完整的路径绑定到一个新的名字，从而更容易访问。</p>
<pre><pre class="playground"><code class="language-rust editable">// 将 `deeply::nested::function` 路径绑定到 `other_function`。
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;)
        }
    }
}

fn main() {
    // 更容易访问 `deeply::nested::funcion`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // 这和 `use deeply::nested::function as function` 等价。
        // 此 `function()` 将遮蔽外部的同名函数。
        use deeply::nested::function;
        function();

        // `use` 绑定拥有局部作用域。在这个例子中，`function()`
        // 的遮蔽只存在这个代码块中。
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<h1><a class="header" href="#super-和-self" id="super-和-self"><code>super</code> 和 <code>self</code></a></h1>
<p>可以在路径中使用 <code>super</code> （父级）和 <code>self</code>（自身）关键字，从而在访问项时消除歧义，以及防止不必要的路径硬编码。</p>
<pre><pre class="playground"><code class="language-rust editalbe">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // 让我们从这个作用域中访问所有名为 `function` 的函数！
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // `self` 关键字表示当前的模块作用域——在这个例子是 `my`。
        // 调用 `self::function()` 和直接调用 `function()` 都得到相同的结果，
        // 因为他们表示相同的函数。
        self::function();
        function();
        
        // 我们也可以使用 `self` 来访问 `my` 内部的另一个模块：
        self::cool::function();
        
        // `super` 关键字表示父作用域（在 `my` 模块外面）。
        super::function();
        
        // 这将在 *crate* 作用域内绑定 `cool::function` 。
        // 在这个例子中，crate 作用域是最外面的作用域。
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<h1><a class="header" href="#文件分层" id="文件分层">文件分层</a></h1>
<p>模块可以分配到文件/目录的层次结构中。让我们将《可见性》一节中的<a href="mod/visibility.html">例子</a>的代码拆分到多个文件中：</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p><code>split.rs</code> 的内容：</p>
<pre><code class="language-rust ignore">// 此声明将会查找名为 `my.rs` 或 `my/mod.rs` 的文件，并将该文件的内容放到
// 此作用域中一个名为 `my` 的模块里面。
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
</code></pre>
<p><code>my/mod.rs</code> 的内容：</p>
<pre><code class="language-rust ignore">// 类似地，`mod inaccessible` 和 `mod nested` 将找到 `nested.rs` 和
// `inaccessible.rs` 文件，并在它们放到各自的模块中。
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p><code>my/nested.rs</code> 的内容：</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p><code>my/inaccessible.rs</code> 的内容：</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>我们看到代码仍然正常运行，就和前面的一样：</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<h1><a class="header" href="#crate" id="crate">crate</a></h1>
<p>crate（中文有 “包，包装箱” 之意）是 Rust 的编译单元。当调用 <code>rustc some_file.rs</code>
时，<code>some_file.rs</code> 被当作 <strong>crate 文件</strong>。如果 <code>some_file.rs</code> 里面含有 <code>mod</code>
声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处。换句话说，模块<strong>不会</strong>单独被编译，只有 crate 才会被编译。</p>
<p>crate 可以编译成二进制可执行文件（binary）或库文件（library）。默认情况下，<code>rustc</code> 将从 crate 产生二进制可执行文件。这种行为可以通过 <code>rustc</code> 的选项 <code>--crate-type</code>
重载。</p>
<h1><a class="header" href="#库" id="库">库</a></h1>
<p>让我们创建一个库，然后看看如何把它链接到另一个 crate。</p>
<pre><pre class="playground"><code class="language-rust editable">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>默认情况下，库会使用 crate 文件的名字，前面加上 “lib” 前缀，但这个默认名称可以使用 <a href="crates/../attribute/crate.html"><code>crate_name</code> 属性</a> 覆盖。</p>
<h1><a class="header" href="#使用库" id="使用库">使用库</a></h1>
<p>要将一个 crate 链接到上节新建的库，可以使用 <code>rustc</code> 的 <code>--extern</code> 选项。然后将所有的物件导入到与库名相同的模块下。此模块的操作通常与任何其他模块相同。</p>
<pre><code class="language-rust ignore">// extern crate rary; // 在 Rust 2015 版或更早版本需要这个导入语句

fn main() {
    rary::public_function();

    // 报错！ `private_function` 是私有的
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># library.rlib 是已编译好的库的路径，这里假设它在同一目录下：
$ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable 
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">cargo</a></h1>
<p><code>cargo</code> 是官方的 Rust 包管理工具。 它有很多非常有用的功能来提高代码质量和开发人员的开发效率！ 这些功能包括：</p>
<ul>
<li>依赖管理和与 <a href="https://crates.io">crates.io</a>（官方 Rust 包注册服务）集成</li>
<li>方便的单元测试</li>
<li>方便的基准测试</li>
</ul>
<p>本章将介绍一些快速入门的基础知识，不过你可以在 <a href="https://doc.rust-lang.org/cargo/">cargo 官方手册</a>中找到详细内容。</p>
<h1><a class="header" href="#依赖" id="依赖">依赖</a></h1>
<p>大多数程序都会依赖于某些库。如果你曾经手动管理过库依赖，那么你就知道这会带来的极大的痛苦。幸运的是，Rust 的生态链标配 <code>cargo</code> 工具！<code>cargo</code> 可以管理项目的依赖关系。</p>
<p>下面创建一个新的 Rust 项目：</p>
<pre><code class="language-sh"># 二进制可执行文件
cargo new foo

# 或者库
cargo new --lib foo
</code></pre>
<p>对于本章的其余部分，我们选定创建的都是二进制可执行文件而不是库，但所有的概念都是相同的。</p>
<p>完成上述命令后，将看到如下内容：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p><code>main.rs</code> 是新项目的入口源文件——这里没什么新东西。 <code>Cargo.toml</code> 是本项目（<code>foo</code>）的 <code>cargo</code> 的配置文件。 浏览 <code>Cargo.toml</code> 文件，将看到类似以下的的内容：</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p><code>package</code> 下面的 <code>name</code> 字段表明项目的名称。 如果您发布 crate（后面将做更多介绍），那么 <code>crates.io</code> 将使用此字段标明的名称。 这也是编译时输出的二进制可执行文件的名称。</p>
<p><code>version</code> 字段是使用<a href="https://semver.org/">语义版本控制</a>（Semantic
Versioning）的 crate 版本号。</p>
<p><code>authors</code> 字段表明发布 crate 时的作者列表。</p>
<p><code>dependencies</code> 这部分可以让你为项目添加依赖。</p>
<p>举个例子，假设我们希望程序有一个很棒的命令行界面（command-line interface，CLI））。 你可以在 <a href="https://crates.io">crates.io</a>（官方的 Rust 包注册服务）上找到很多很棒的 Rust 包。其中一个受欢迎的包是 <a href="https://crates.io/crates/clap">clap</a>（译注：一个命令行参数的解析器）。在撰写本文时，[clap] 最新发布的版本为 <code>2.27.1</code>。要在程序中添加依赖，我们可以很简单地在 <code>Cargo.toml</code> 文件中的 <code>dependencies</code> 项后面将以下内容添加进来 ：<code>clap = &quot;2.27.1&quot;</code>。当然，在 <code>main.rs</code> 文件中写上 <code>extern crate clap</code>，就和平常一样。 就是这样！你就可以在程序中开始使用 <code>clap</code> 了。</p>
<p><code>cargo</code> 还支持<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">其他类型的依赖</a>。 下面是一个简单的示例：</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # 来自 crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # 来自网上的仓库
bar = { path = &quot;../bar&quot; } # 来自本地文件系统的路径
</code></pre>
<p><code>cargo</code> 不仅仅是一个包依赖管理器。<code>Cargo.toml</code> 的所有可用配置选项都列在 <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">格式规范</a>中。</p>
<p>要构建我们的项目，我们可以在项目目录中的任何位置（包括子目录！）执行 <code>cargo build</code>。我们也可以执行 <code>cargo run</code> 来构建和运行。请注意，这些命令将处理所有依赖，在需要时下载 crate，并构建所有内容，包括 crate。（请注意，它只重新构建尚未构建的内容，这和 <code>make</code> 类似）。</p>
<p>瞧！这里的所有都和 <code>cargo</code> 有关！</p>
<h1><a class="header" href="#约定规范" id="约定规范">约定规范</a></h1>
<p>在上一小节中，我们看到了以下目录层次结构：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>假设我们要在同一个项目中有两个二进制可执行文件。 那要怎样做呢？</p>
<p>很显然，<code>cargo</code> 支持这一点。正如我们之前看到的，默认二进制名称是 <code>main</code>，但可以通过将文件放在 <code>bin/</code> 目录中来添加其他二进制可执行文件：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>为了使得 <code>cargo</code> 编译或运行这个二进制可执行文件而不是默认或其他二进制可执行文件，我们只需给 <code>cargo</code> 增加一个参数 <code>--bin my_other_bin</code>，其中 <code>my_other_bin</code> 是我们想要使用的二进制可执行文件的名称。</p>
<p>除了可添加其他二进制可执行文件外，<code>cargo</code> 还支持<a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">更多功能</a>，如基准测试，测试和示例。</p>
<p>在下一节中，我们将更仔细地学习测试的内容。</p>
<h1><a class="header" href="#测试" id="测试">测试</a></h1>
<p>我们知道测试是任何软件不可缺少的一部分！Rust 对单元和集成测试提供一流的支持（参见《Rust 程序设计语言》中的关于<a href="https://rustwiki.org/zh-CN/book/ch11-00-testing.html">测试的章节</a>）。</p>
<p>通过上面链接的关于测试章节，我们看到了如何编写单元测试和集成测试。在代码目录组织上，我们可以将单元测试放在需要测试的模块中，并将集成测试放在源码中 <code>tests/</code> 目录中：</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p><code>tests</code> 目录下的每个文件都是一个单独的集成测试。</p>
<p><code>cargo</code> 很自然地提供了一种便捷的方法来运行所有测试！</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>你将会看到像这样的输出：</p>
<pre><code class="language-txt">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>你还可以运行如下测试，其中名称匹配一个模式：</p>
<pre><code class="language-sh">cargo test test_foo
</code></pre>
<pre><code class="language-txt">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>需要注意的一点是：<code>cargo</code> 可能同时进行多项测试，因此请确保它们不会相互竞争。例如，如果它们都输出到文件，则应该将它们写入不同的文件。</p>
<h1><a class="header" href="#构建脚本" id="构建脚本">构建脚本</a></h1>
<p>有时使用 <code>cargo</code> 正常构建还是不够的。也许你的 crate 在 cargo 成功编译之前需要一些先决条件，比如代码生成或者需要编译的一些本地代码。为了解决这个问题，我们构建了 cargo 可以运行的脚本。</p>
<p>要向包中添加构建脚本，可以在 <code>Cargo.toml</code> 中指定它，如下所示：</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>跟默认情况不同，这里 cargo 将在项目目录中优先查找 <code>build.rs</code> 文件。（本句采用意译，英文原文为：Otherwise Cargo will look for a <code>build.rs</code> file in the project directory by default.）</p>
<h2><a class="header" href="#怎么使用构建脚本" id="怎么使用构建脚本">怎么使用构建脚本</a></h2>
<p>构建脚本只是另一个 Rust 文件，此文件将在编译包中的任何其他内容之前，优先进行编译和调用。 因此，此文件可实现满足 crate 的先决条件。</p>
<p>cargo 通过<a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">此处指定</a>的可以使用的环境变量为脚本提供输入。（英文原文：Cargo provides the script with inputs via environment variables <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">specified
here</a> that can be used.）</p>
<p>此脚本通过 stdout （标准输出）提供输出。打印的所有行都写入到 <code>target/debug/build/&lt;pkg&gt;/output</code>。另外，以 <code>cargo:</code> 为前缀的行将由 cargo 直接解析，因此可用于定义包编译的参数。</p>
<p>有关进一步的说明和示例，请阅读 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">cargo 规定说明文档</a>。</p>
<h1><a class="header" href="#属性" id="属性">属性</a></h1>
<p>属性是应用于某些模块、crate 或项的元数据（metadata）。这元数据可以用来：</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="./attribute/cfg.html">条件编译代码</a></li>
<li><a href="./attribute/crate.html">设置 crate 名称、版本和类型（二进制文件或库）</a></li>
<li>禁用 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lint</a> （警告）</li>
<li>启用编译器的特性（宏、全局导入（glob import）等）</li>
<li>链接到一个非 Rust 语言的库</li>
<li>标记函数作为单元测试</li>
<li>标记函数作为基准测试的某个部分</li>
</ul>
<p>当属性作用于整个 crate 时，它们的语法为 <code>#![crate_attribute]</code>，当它们用于模块或项时，语法为 <code>#[item_attribute]</code>（注意少了感叹号 <code>!</code>）。</p>
<p>属性可以接受参数，有不同的语法形式：</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>属性可以多个值，它们可以分开到多行中：</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]

#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<h1><a class="header" href="#死代码-dead_code" id="死代码-dead_code">死代码 <code>dead_code</code></a></h1>
<p>编译器提供了 <code>dead_code</code>（死代码，无效代码）<a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>lint</em></a>，这会对未使用的函数产生警告。可以用一个<strong>属性</strong>来禁用这个 lint。</p>
<pre><pre class="playground"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` 属性可以禁用 `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// 改正 ^ 增加一个属性来消除警告

fn main() {
    used_function();
}
</code></pre></pre>
<p>注意在实际程序中，需要将死代码清除掉。由于本书的例子是交互性的，因而其中需要允许一些死代码的出现。</p>
<h1><a class="header" href="#crate-1" id="crate-1"><code>crate</code></a></h1>
<p><code>crate_type</code> 属性可以告知编译器 crate 是一个二进制的可执行文件还是一个库（甚至是哪种类型的库），<code>crate_name</code> 属性可以设定 crate 的名称。</p>
<p>不过，一定要注意在使用 cargo 时，这两种类型时都<strong>没有</strong>作用。由于大多数 Rust
工程都使用 cargo，这意味着 <code>crate_type</code> 和 <code>crate_name</code> 的作用事实上很有限。</p>
<pre><pre class="playground"><code class="language-rust editable">// 这个 crate 是一个库文件
#![crate_type = &quot;lib&quot;]
// 库的名称为 “rary”
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>当用到 <code>crate_type</code> 属性时，就不再需要给 <code>rustc</code> 命令加上 <code>--crate-type</code> 标记。</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<h1><a class="header" href="#cfg" id="cfg"><code>cfg</code></a></h1>
<p>条件编译可能通过两种不同的操作符实现：</p>
<ul>
<li><code>cfg</code> 属性：在属性位置中使用 <code>#[cfg(...)]</code></li>
<li><code>cfg!</code> 宏：在布尔表达式中使用 <code>cfg!(...)</code></li>
</ul>
<p>两种形式使用的参数语法都相同。</p>
<pre><pre class="playground"><code class="language-rust editable">// 这个函数仅当目标系统是 Linux 的时候才会编译
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;)
}

// 而这个函数仅当目标系统 **不是** Linux 时才会编译
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;)
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#参见-30" id="参见-30">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/conditional-compilation.html">引用</a>, <a href="https://rustwiki.org/zh-CN/std/macro.cfg!.html"><code>cfg!</code></a>, 和 <a href="attribute/../macros.html">宏</a>.</p>
<h1><a class="header" href="#自定义条件" id="自定义条件">自定义条件</a></h1>
<p>有部分条件如 <code>target_os</code> 是由 <code>rustc</code> 隐式地提供的，但是自定义条件必须使用
<code>--cfg</code> 标记来传给 <code>rustc</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;)
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>试试不使用自定义的 <code>cfg</code> 标记会发生什么：</p>
<pre><code class="language-bash">$ rustc custom.rs &amp;&amp; ./custom
No such file or directory (os error 2)
</code></pre>
<p>使用自定义的 <code>cfg</code> 标记：</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<h1><a class="header" href="#泛型" id="泛型">泛型</a></h1>
<p><strong>泛型</strong>（generic）是关于泛化类型和函数功能，以扩大其适用范围的话题。泛型极大地减少了代码的重复，但它自身的语法很要求细心。也就是说，采用泛型意味着仔细地指定泛型类型具体化时，什么样的具体类型是合法的。泛型最简单和常用的用法是用于类型参数。</p>
<blockquote>
<p>译注：定义泛型类型或泛型函数之类的东西时，我们会用 <code>&lt;A&gt;</code> 或者 <code>&lt;T&gt;</code> 这类标记
作为类型的代号，就像函数的形参一样。在使用时，为把 <code>&lt;A&gt;</code>、<code>&lt;T&gt;</code> 具体化，我们
会把类型说明像实参一样使用，像是 <code>&lt;i32&gt;</code> 这样。这两种把（泛型的或具体的）类型
当作参数的用法就是<strong>类型参数</strong>。</p>
</blockquote>
<p>泛型的类型参数是使用尖括号和<a href="https://en.wikipedia.org/wiki/CamelCase">大驼峰命名</a>的名称：<code>&lt;Aaa, Bbb, ...&gt;</code>
来指定的。泛型类型参数一般用 <code>&lt;T&gt;</code> 来表示。在 Rust 中，“泛型的” 除了表示类型，还表示可以接受一个或多个泛型类型参数 <code>&lt;T&gt;</code> 的任何内容。任何用泛型类型参数表示的类型都是泛型，其他的类型都是具体（非泛型）类型。</p>
<p>例如定义一个名为 <code>foo</code> 的 <strong>泛型函数</strong>，它可接受类型为 <code>T</code> 的任何参数 <code>arg</code>：</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>因为我们使用了泛型类型参数 <code>&lt;T&gt;</code>，所以这里的 <code>(arg: T)</code> 中的 <code>T</code> 就是泛型类型。即使 <code>T</code> 在之前被定义为 <code>struct</code>，这里的 <code>T</code> 仍然代表泛型。</p>
<p>下面例子展示了泛型语法的使用：</p>
<pre><pre class="playground"><code class="language-rust editable">// 一个具体类型 `A`。
struct A;

// 在定义类型 `Single` 时，第一次使用类型 `A` 之前没有写 `&lt;A&gt;`。
// 因此，`Single` 是个具体类型，`A` 取上面的定义。
struct Single(A);
//            ^ 这里是 `Single` 对类型 `A` 的第一次使用。

// 此处 `&lt;T&gt;` 在第一次使用 `T` 前出现，所以 `SingleGen` 是一个泛型类型。
// 因为 `T` 是泛型的，所以它可以是任何类型，包括在上面定义的具体类型 `A`。
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` 是具体类型，并且显式地使用类型 `A`。
    let _s = Single(A);
    
    // 创建一个 `SingleGen&lt;char&gt;` 类型的变量 `_char`，并令其值为 `SingleGen('a')`
    // 这里的 `SingleGen` 的类型参数是显式指定的。
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` 的类型参数也可以隐式地指定。
    let _t    = SingleGen(A); // 使用在上面定义的 `A`。
    let _i32  = SingleGen(6); // 使用 `i32` 类型。
    let _char = SingleGen('a'); // 使用 `char`。
}
</code></pre></pre>
<h3><a class="header" href="#参见-31" id="参见-31">参见：</a></h3>
<p><a href="custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#函数-1" id="函数-1">函数</a></h1>
<p>同样的规则也适用于函数：在使用类型 <code>T</code> 前给出 <code>&lt;T&gt;</code>，那么 <code>T</code> 就变成了泛型。</p>
<p>调用泛型函数有时需要显式地指明类型参量。这可能是因为调用了返回类型是泛型的函数，或者编译器没有足够的信息来推断类型参数。</p>
<p>调用函数时，使用显式指定的类型参数会像是这样：<code>fun::&lt;A, B, ...&gt;()</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">struct A;          // 具体类型 `A`。
struct S(A);       // 具体类型 `S`。
struct SGen&lt;T&gt;(T); // 泛型类型 `SGen`。

// 下面全部函数都得到了变量的所有权，并立即使之离开作用域，将变量释放。

// 定义一个函数 `reg_fn`，接受一个 `S` 类型的参数 `_s`。
// 因为没有 `&lt;T&gt;` 这样的泛型类型参数，所以这不是泛型函数。
fn reg_fn(_s: S) {}

// 定义一个函数 `gen_spec_t`，接受一个 `SGen&lt;A&gt;` 类型的参数 `_s`。
// `SGen&lt;&gt;` 显式地接受了类型参数 `A`，且在 `gen_spec_t` 中，`A` 没有被用作
// 泛型类型参数，所以函数不是泛型的。
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// 定义一个函数 `gen_spec_i32`，接受一个 `SGen&lt;i32&gt;` 类型的参数 `_s`。
// `SGen&lt;&gt;` 显式地接受了类型参量 `i32`，而 `i32` 是一个具体类型。
// 由于 `i32` 不是一个泛型类型，所以这个函数也不是泛型的。
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// 定义一个函数 `generic`，接受一个 `SGen&lt;T&gt;` 类型的参数 `_s`。
// 因为 `SGen&lt;T&gt;` 之前有 `&lt;T&gt;`，所以这个函数是关于 `T` 的泛型函数。
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // 使用非泛型函数
    reg_fn(S(A));          // 具体类型。
    gen_spec_t(SGen(A));   // 隐式地指定类型参数 `A`。
    gen_spec_i32(SGen(6)); // 隐式地指定类型参数 `i32`。

    // 为 `generic()` 显式地指定类型参数 `char`。
    generic::&lt;char&gt;(SGen('a'));

    // 为 `generic()` 隐式地指定类型参数 `char`。
    generic(SGen('c'));
}
</code></pre></pre>
<h3><a class="header" href="#参见-32" id="参见-32">参见：</a></h3>
<p><a href="generics/../fn.html">函数</a> 和 <a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<h1><a class="header" href="#实现" id="实现">实现</a></h1>
<p>和函数类似，<code>impl</code> 块要想实现泛型，也需要很仔细。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S; // 具体类型 `S`
struct GenericVal&lt;T&gt;(T,); // 泛型类型 `GenericVal`

// GenericVal 的 `impl`，此处我们显式地指定了类型参数：
impl GenericVal&lt;f32&gt; {} // 指定 `f32` 类型
impl GenericVal&lt;S&gt; {} // 指定为上面定义的 `S`

// `&lt;T&gt;` 必须在类型之前写出来，以使类型 `T` 代表泛型。
impl &lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// Val 的 `impl`
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// GenVal 的 `impl`，指定 `T` 是泛型类型
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };
    
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3><a class="header" href="#参见-33" id="参见-33">参见：</a></h3>
<p><a href="generics/../scope/lifetime/fn.html">返回引用的函数</a>, <a href="generics/../fn/methods.html"><code>impl</code></a>, 和 <a href="generics/../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#trait" id="trait">trait</a></h1>
<p>当然 <code>trait</code> 也可以是泛型的。我们在这里定义了一个 <code>trait</code>，它把 <code>Drop</code> <code>trait</code>
作为泛型方法实现了，可以 <code>drop</code>（丢弃）调用者本身和一个输入参数。</p>
<pre><pre class="playground"><code class="language-rust editable">// 不可复制的类型。
struct Empty;
struct Null;

// `T` 的泛型 trait。
trait DoubleDrop&lt;T&gt; {
    // 定义一个调用者的方法，接受一个额外的参数 `T`，但不对它做任何事。
    fn double_drop(self, _: T);
}

// 对泛型的调用者类型 `U` 和任何泛型类型 `T` 实现 `DoubleDrop&lt;T&gt;` 。
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // 此方法获得两个传入参数的所有权，并释放它们。
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // 释放 `empty` 和 `null`。
    empty.double_drop(null);

    //empty;
    //null;
    // ^ 试一试：去掉这两行的注释。
}
</code></pre></pre>
<h3><a class="header" href="#参见-34" id="参见-34">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#约束" id="约束">约束</a></h1>
<p>在使用泛型时，类型参数常常必须使用 trait 作为<strong>约束</strong>（bound）来明确规定类型应实现哪些功能。例如下面的例子用到了 <code>Display</code> trait 来打印，所以它用
<code>Display</code> 来约束 <code>T</code>，也就是说 <code>T</code> <strong>必须</strong>实现 <code>Display</code>。</p>
<pre><code class="language-rust ignore">// 定义一个函数 `printer`，接受一个类型为泛型 `T` 的参数，
// 其中 `T` 必须实现 `Display` trait。
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>约束把泛型类型限制为符合约束的类型。请看：</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// 报错！`Vec&lt;T&gt;` 未实现 `Display`。此次泛型具体化失败。
let s = S(vec![1]);
</code></pre>
<p>约束的另一个作用是泛型的实例可以访问作为约束的 trait 的方法。例如：</p>
<pre><pre class="playground"><code class="language-rust editable">// 这个 trait 用来实现打印标记：`{:?}`。
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// 泛型 `T` 必须实现 `Debug` 。只要满足这点，无论什么类型
// 都可以让下面函数正常工作。
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` 必须实现 `HasArea`。任意符合该约束的泛型的实例
// 都可访问 `HasArea` 的 `area` 函数
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ 试一试：取消上述语句的注释。
    // | 报错：未实现 `Debug` 或 `HasArea`。
}
</code></pre></pre>
<p>多说一句，某些情况下也可使用 <a href="generics/../generics/where.html"><code>where</code></a> 分句来形成约束，这拥有更好的表现力。</p>
<h3><a class="header" href="#参见-35" id="参见-35">参见：</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a>, <a href="generics/../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#测试实例空约束" id="测试实例空约束">测试实例：空约束</a></h1>
<p>约束的工作机制会产生这样的效果：即使一个 <code>trait</code> 不包含任何功能，你仍然可以用它作为约束。标准库中的 <code>Eq</code> 和 <code>Ord</code> 就是这样的 <code>trait</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 这些函数只对实现了相应的 trait 的类型有效。
// 事实上这些 trait 内部是空的，但这没有关系。
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ 试一试：去掉此行注释。
}
</code></pre></pre>
<h3><a class="header" href="#参见-36" id="参见-36">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code></a>, 和 <a href="generics/bounds/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#多重约束" id="多重约束">多重约束</a></h1>
<p>多重约束（multiple bounds）可以用 <code>+</code> 连接。和平常一样，类型之间使用 <code>,</code> 隔开。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // 试一试 ^ 将此行注释去掉。

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3><a class="header" href="#参见-37" id="参见-37">参见：</a></h3>
<p><a href="generics/../hello/print.html"><code>std::fmt</code></a> 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#where-分句" id="where-分句">where 分句</a></h1>
<p>约束也可以使用 <code>where</code> 分句来表达，它放在 <code>{</code> 的前面，而不需写在类型第一次出现之前。另外 <code>where</code> 从句可以用于任意类型的限定，而不局限于类型参数本身。</p>
<p><code>where</code> 在下面一些情况下很有用：</p>
<ul>
<li>当分别指定泛型的类型和约束会更清晰时：</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// 使用 `where` 从句来表达约束
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>当使用 <code>where</code> 从句比正常语法更有表现力时。本例中的 <code>impl</code> 如果不用
<code>where</code> 从句，就无法直接表达。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// 这里需要一个 `where` 从句，否则就要表达成 `T: Debug`（这样意思就变了），
// 或者改用另一种间接的方法。
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 我们要将 `Option&lt;T&gt;: Debug` 作为约束，因为那是要打印的内容。
    // 否则我们会给出错误的约束。
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3><a class="header" href="#参见-38" id="参见-38">参见：</a></h3>
<p>相关的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>、<a href="generics/../custom_types/structs.html"><code>struct</code></a> 和 <a href="generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#new-type-惯用法" id="new-type-惯用法">new type 惯用法</a></h1>
<p><code>newtype</code> 惯用法（译注：即为不同种类的数据分别定义新的类型）能保证在编译时，提供给程序的都是正确的类型。</p>
<p>比如说，实现一个 “年龄认证” 函数，它要求输入<strong>必须</strong>是 <code>Years</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// 舍去不满一年的部分
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>取消最后一行的注释，就可以发现提供给 <code>old_enough</code> 的必须是 <code>Years</code> 类型。</p>
<h3><a class="header" href="#see-also" id="see-also">See also:</a></h3>
<p><a href="generics/../custom_types/structs.html"><code>structs</code></a></p>
<h1><a class="header" href="#关联项" id="关联项">关联项</a></h1>
<p>“关联项”（associated item）指与多种类型的<a href="https://rustwiki.org/zh-CN/reference/items.html">项</a>有关的一组规则。它是 <code>trait</code>
泛型的扩展，允许在 <code>trait</code> 内部定义新的项。</p>
<p>一个这样的项就叫做一个关联类型。当 <code>trait</code> 对于实现了它的容器类型是泛型的，关联项就提供了简单的使用方法。</p>
<blockquote>
<p>译注：“关联项”这个说法实际上只在 RFC 里出现了，官方的《The Rust Programming
Language》第一版和第二版都只有“关联类型”的说法。如果觉得这里的说法很别扭的话
不要理会就是了。TRPL 对关联类型的定义是：“一种将类型占位符与 trait 联系起来的
做法，这样 trait 中的方法签名中就可以使用这些占位符类型。trait 的实现会指定在
该实现中那些占位符对应什么具体类型。”等看完这一节再回头看这个定义就很明白了。</p>
</blockquote>
<h3><a class="header" href="#参见-39" id="参见-39">参见：</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<h1><a class="header" href="#存在问题" id="存在问题">存在问题</a></h1>
<p><code>trait</code> 如果对实现了它的容器类型是泛型的，则须遵守类型规范要求——<code>trait</code> 的使用者<strong>必须</strong>指出 <code>trait</code> 的全部泛型类型。</p>
<p>在下面例子中，<code>Contains</code> <code>trait</code> 允许使用泛型类型 <code>A</code> 和 <code>B</code>。然后我们为
<code>Container</code> 类型实现了这个 trait，将 <code>A</code> 和 <code>B</code> 指定为 <code>i32</code>，这样就可以对它们使用 <code>difference()</code> 函数。</p>
<p>因为 <code>Contains</code> 是泛型的，我们必须在 <code>fn difference()</code> 中显式地指出<strong>所有的</strong>泛型类型。但实际上，我们想要表达，<code>A</code> 和 <code>B</code> 究竟是什么类型是由输入 <code>C</code> 决定的。在下一节会看到，关联类型恰好提供了这样的功能。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// 这个 trait 检查给定的 2 个项是否储存于容器中
// 并且能够获得容器的第一个或最后一个值。
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // 显式地要求 `A` 和 `B`
    fn first(&amp;self) -&gt; i32; // 未显式地要求 `A` 或 `B`
    fn last(&amp;self) -&gt; i32;  // 未显式地要求 `A` 或 `B`
}

impl Contains&lt;i32, i32&gt; for Container {
    // 如果存储的数字和给定的相等则为真。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一个数字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最后一个数字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// 容器 `C` 就包含了 `A` 和 `B` 类型。鉴于此，必须指出 `A` 和 `B` 显得很麻烦。
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3><a class="header" href="#参见-40" id="参见-40">参见：</a></h3>
<p><a href="generics/assoc_items/../../custom_types/structs.html"><code>struct</code></a>, 和 <a href="generics/assoc_items/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#关联类型" id="关联类型">关联类型</a></h1>
<p>通过把容器内部的类型放到 <code>trait</code> 中作为<strong>输出类型</strong>，使用 “关联类型” 增加了代码的可读性。这样的 <code>trait</code> 的定义语法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `A` 和 `B` 在 trait 里面通过 `type` 关键字来定义。
// （注意：此处的 `type` 不同于为类型取别名时的 `type`）。
trait Contains {
    type A;
    type B;

	// 这种语法能够泛型地表示这些新类型。
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>注意使用了 <code>Contains</code> <code>trait</code> 的函数就不需要写出 <code>A</code> 或 <code>B</code> 了：</p>
<pre><code class="language-rust ignore">// 不使用关联类型
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 使用关联类型
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>让我们使用关联类型来重写上一小节的例子：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Container(i32, i32);

// 这个 trait 检查给定的 2 个项是否储存于容器中
// 并且能够获得容器的第一个或最后一个值。
trait Contains {
    // 在这里定义可以被方法使用的泛型类型。
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // 指出 `A` 和 `B` 是什么类型。如果 `input`（输入）类型
    // 为 `Container(i32, i32)`，那么 `output`（输出）类型
    // 会被确定为 `i32` 和 `i32`。
    type A = i32;
    type B = i32;

    // `&amp;Self::A` 和 `&amp;Self::B` 在这里也是合法的类型。
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 得到第一个数字。
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 得到最后一个数字。
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h1><a class="header" href="#虚类型参数" id="虚类型参数">虚类型参数</a></h1>
<p>虚类型（phantom type）参数是一种在运行时不出现，而在（且仅在）编译时进行静态检查的类型参数。</p>
<p>可以用额外的泛型类型参数指定数据类型，该类型可以充当标记，也可以供编译时类型检查使用。这些额外的参数没有存储值，也没有运行时行为。</p>
<p>在下面例子中，我们使用 <a href="https://rustwiki.org/zh-CN/std/marker/struct.PhantomData.html">std::marker::PhantomData</a> 作为虚类型参数的类型，创建包含不同数据类型的元组。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::marker::PhantomData;

// 这个虚元组结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。
#[derive(PartialEq)] // 允许这种类型进行相等测试（equality test）。
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// 这个虚类型结构体对 `A` 是泛型的，并且带有隐藏参数 `B`。
#[derive(PartialEq)] // 允许这种类型进行相等测试。
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// 注意：对于泛型 `A` 会分配存储空间，但 `B` 不会。
//       因此，`B` 不能参与运算。

fn main() {
    // 这里的 `f32` 和 `f64` 是隐藏参数。
    // 被指定为 `&lt;char, f32&gt;` 的 `PhantomTuple` 类型。
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // 被指定为 `&lt;char, f64&gt;` `PhantomTuple` 类型。
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // 被指定为 `&lt;char, f32&gt;` 的类型。
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // 被指定为 `&lt;char, f64&gt;` 的类型。
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // 编译期错误！类型不匹配，所以这些值不能够比较：
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // 编译期错误！类型不匹配，所以这些值不能够比较：
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3><a class="header" href="#参见-41" id="参见-41">参见：</a></h3>
<p><a href="generics/../trait/derive.html">Derive</a>, <a href="generics/../custom_types/structs.html">结构体</a>, 和 <a href="generics/../custom_types/structs.html">元组结构体</a></p>
<h1><a class="header" href="#测试实例单位说明" id="测试实例单位说明">测试实例：单位说明</a></h1>
<p>通过实现一个带虚类型参数的 <code>Add</code> trait 可以实现单位检查。这种 <code>Add</code> trait 的代码如下：</p>
<pre><code class="language-rust ignore">// 这个 `trait` 会要求 `Self + RHS = Output`。`&lt;RHS = Self&gt;` 表示 RHS 的默认值
// 为 Self 类型，也就是如果没有在实现中另行指定，RHS 就取 Self 类型。
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` 必须是 `T&lt;U&gt;` 类型，所以是 `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`。
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>完整实现：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// 创建空枚举类型来表示单位。
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` 是一个带有虚类型参数 `Unit` 的类型，
/// 而且对于表示长度的类型（即 `f64`）而言，`Length` 不是泛型的。
///
/// `f64` 已经实现了 `Clone` 和 `Copy` trait.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// `Add` trait 定义了 `+` 运算符的行为。
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() 返回一个含有和的新的 `Length` 结构体。
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` 调用了针对 `f64` 类型的 `Add` 实现。
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // 指定 `one_foot` 拥有虚类型参数 `Inch`。
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` 拥有虚类型参数 `Mm`。
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` 调用了我们对 `Length&lt;Unit&gt;` 实现的 `add()` 方法。
    //
    // 由于 `Length` 了实现了 `Copy`，`add()` 不会消耗 `one_foot`
    // 和 `one_meter`，而是复制它们作为 `self` 和 `rhs`。
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // 加法正常执行。
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // 无意义的运算当然会失败：
    // 编译期错误：类型不匹配。
    //let one_feter = one_foot + one_meter;
}

</code></pre></pre>
<h3><a class="header" href="#参见-42" id="参见-42">参见：</a></h3>
<p><a href="generics/phantom/../../scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="generics/phantom/../../generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="generics/phantom/../../custom_types/enum.html">enum</a>, <a href="generics/phantom/../../fn/methods.html">impl &amp; self</a>,
<a href="generics/phantom/../../trait/ops.html">Overloading</a>, <a href="generics/phantom/../../scope/borrow/ref.html">ref</a>, <a href="generics/phantom/../../trait.html">Traits (<code>X for Y</code>)</a>, 和 <a href="generics/phantom/../../custom_types/structs.html">TupleStructs</a>.</p>
<h1><a class="header" href="#作用域规则" id="作用域规则">作用域规则</a></h1>
<p>作用域在所有权（ownership）、借用（borrow）和生命周期（lifetime）中起着重要作用。也就是说，作用域告诉编译器什么时候借用是合法的、什么时候资源可以释放、以及变量何时被创建或销毁。</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>Rust 的变量不只是在栈中保存数据：它们也<strong>占有</strong>资源，比如 <code>Box&lt;T&gt;</code> 占有堆（heap）中的内存。Rust 强制实行 <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>（Resource Acquisition Is Initialization，资源获取即初始化），所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。</p>
<p>这种行为避免了<strong>资源泄漏</strong>（resource leak），所以你再也不用手动释放内存或者担心内存泄漏（memory leak）！下面是个快速入门示例：</p>
<pre><pre class="playground"><code class="language-rust editable">// raii.rs
fn create_box() {
    // 在堆上分配一个整型数据
    let _box1 = Box::new(3i32);

    // `_box1` 在这里被销毁，内存得到释放
}

fn main() {
    // 在堆上分配一个整型数据
    let _box2 = Box::new(5i32);

    // 嵌套作用域：
    {
        // 在堆上分配一个整型数据
        let _box3 = Box::new(4i32);

        // `_box3` 在这里被销毁，内存得到释放
    }

    // 创建一大堆 box（只是因为好玩）。
    // 完全不需要手动释放内存！
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` 在这里被销毁，内存得到释放
}
</code></pre></pre>
<p>当然我们可以使用 <a href="https://valgrind.org/info/"><code>valgrind</code></a> 对内存错误进行仔细检查：</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>完全没有泄漏！</p>
<h2><a class="header" href="#析构函数" id="析构函数">析构函数</a></h2>
<p>Rust 中的析构函数概念是通过 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 提供的。当资源离开作用域，就调用析构函数。你无需为每种类型都实现 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait，只要为那些需要自己的析构函数逻辑的类型实现就可以了。</p>
<p>运行下列例子，看看 <a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 是怎样工作的。当 <code>main</code> 函数中的变量离开作用域，自定义的析构函数就会被调用：</p>
<pre><pre class="playground"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#参见-43" id="参见-43">参见：</a></h3>
<p><a href="scope/../std/box.html">Box</a></p>
<h1><a class="header" href="#所有权和移动" id="所有权和移动">所有权和移动</a></h1>
<p>因为变量要负责释放它们拥有的资源，所以<strong>资源只能拥有一个所有者</strong>。这也防止了资源的重复释放。注意并非所有变量都拥有资源（例如<a href="scope/../flow_control/match/destructuring/destructure_pointers.html">引用</a>）。</p>
<p>在进行赋值（<code>let x = y</code>）或通过值来传递函数参数（<code>foo(x)</code>）的时候，资源的<strong>所有权</strong>（ownership）会发生转移。按照 Rust 的说法，这被称为资源的<strong>移动</strong>（move）。</p>
<p>在移动资源之后，原来的所有者不能再被使用，这可避免悬挂指针（dangling pointer）的产生。</p>
<pre><pre class="playground"><code class="language-rust editable">// 此函数取得堆分配的内存的所有权
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` 被销毁且内存得到释放
}

fn main() {
    // 栈分配的整型
    let x = 5u32;

    // 将 `x` *复制*到 `y`——不存在资源移动
    let y = x;

    // 两个值各自都可以使用
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` 是一个指向堆分配的整数的指针
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *移动* `a` 到 `b`
    let b = a;
    // 把 `a` 的指针地址（而非数据）复制到 `b`。现在两者都指向
    // 同一个堆分配的数据，但是现在是 `b` 拥有它。

    // 报错！`a` 不能访问数据，因为它不再拥有那部分堆上的内存。
    //println!(&quot;a contains: {}&quot;, a);
    // 试一试 ^ 去掉此行注释

    // 此函数从 `b` 中取得堆分配的内存的所有权
    destroy_box(b);

    // 此时堆内存已经被释放，这个操作会导致解引用已释放的内存，而这是编译器禁止的。
    // 报错！和前面出错的原因一样。
    //println!(&quot;b contains: {}&quot;, b);
    // 试一试 ^ 去掉此行注释
}
</code></pre></pre>
<h1><a class="header" href="#可变性" id="可变性">可变性</a></h1>
<p>当所有权转移时，数据的可变性可能发生改变。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // 可变性错误
    //*immutable_box = 4;

    // *移动* box，改变所有权（和可变性）
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // 修改 box 的内容
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<h1><a class="header" href="#部分移动" id="部分移动">部分移动</a></h1>
<p>在单个变量的<a href="scope/move/../../flow_control/match/destructuring.html">解构</a>内，可以同时使用 <code>by-move</code> 和 <code>by-reference</code> 模式绑定。这样做将导致变量的<strong>部分移动</strong>（partial move），这意味着变量的某些部分将被移动，而其他部分将保留。在这种情况下，后面不能整体使用父级变量，但是仍然可以使用只引用（而不移动）的部分。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 20,
    };

    // `name` 从 person 中移走，但 `age` 只是引用
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // 报错！部分移动值的借用：`person` 部分借用产生
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` 不能使用，但 `person.age` 因为没有被移动而可以继续使用
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h3><a class="header" href="#参见-44" id="参见-44">参见：</a></h3>
<p><a href="scope/move/../../flow_control/match/destructuring.html">解构</a></p>
<h1><a class="header" href="#借用" id="借用">借用</a></h1>
<p>多数情况下，我们更希望能访问数据，同时不取得其所有权。为实现这点，Rust 使用了<strong>借用</strong>（borrowing）机制。对象可以通过引用（<code>&amp;T</code>）来传递，从而取代通过值（<code>T</code>）来传递。</p>
<p>编译器（通过借用检查）静态地保证了引用<strong>总是</strong>指向有效的对象。也就是说，当存在引用指向一个对象时，该对象不能被销毁。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 此函数取得一个 box 的所有权并销毁它
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// 此函数借用了一个 i32 类型
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // 创建一个装箱的 i32 类型，以及一个存在栈中的 i32 类型。
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // 借用了 box 的内容，但没有取得所有权，所以 box 的内容之后可以再次借用。
    // 译注：请注意函数自身就是一个作用域，因此下面两个函数运行完成以后，
    // 在函数中临时创建的引用也就不复存在了。
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // 取得一个对 box 中数据的引用
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // 报错！
        // 当 `boxed_i32` 里面的值之后在作用域中被借用时，不能将其销毁。
        eat_box_i32(boxed_i32);
        // 改正 ^ 注释掉此行

        // 在 `_ref_to_i32` 里面的值被销毁后，尝试借用 `_ref_to_i32`
        //（译注：如果此处不借用，则在上一行的代码中，eat_box_i32(boxed_i32)可以将 `boxed_i32` 销毁。）
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` 离开作用域且不再被借用。
    }

    // `boxed_i32` 现在可以将所有权交给 `eat_box_i32` 并被销毁。
    //（译注：能够销毁是因为已经不存在对 `boxed_i32` 的引用）
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<h1><a class="header" href="#可变性-1" id="可变性-1">可变性</a></h1>
<p>可变数据可以使用 <code>&amp;mut T</code> 进行可变借用。这叫做<strong>可变引用</strong>（mutable reference），它使借用者可以读/写数据。相反，<code>&amp;T</code> 通过不可变引用（immutable reference）来借用数据，借用者可以读数据而不能更改数据：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` 是一个对分配在只读内存区的字符串的引用
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// 此函数接受一个对 Book 类型的引用
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// 此函数接受一个对可变的 Book 类型的引用，它把年份 `year` 改为 2014 年
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // 创建一个名为 `immutabook` 的不可变的 Book 实例
    let immutabook = Book {
        // 字符串字面量拥有 `&amp;'static str` 类型
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // 创建一个 `immutabook` 的可变拷贝，命名为 `mutabook`
    let mut mutabook = immutabook;

    // 不可变地借用一个不可变对象
    borrow_book(&amp;immutabook);

    // 不可变地借用一个可变对象
    borrow_book(&amp;mutabook);

    // 可变地借用一个可变对象
    new_edition(&amp;mut mutabook);

    // 报错！不能可变地借用一个不可变对象
    new_edition(&amp;mut immutabook);
    // 改正 ^ 注释掉此行
}
</code></pre></pre>
<h3><a class="header" href="#参见-45" id="参见-45">参见：</a></h3>
<p><a href="scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<h1><a class="header" href="#别名使用" id="别名使用">别名使用</a></h1>
<p>数据可以多次不可变借用，但是在不可变借用的同时，原始数据不能使用可变借用。或者说，同一时间内只允许<strong>一次</strong>可变借用。仅当最后一次使用可变引用<strong>之后</strong>，原始数据才可以再次借用。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // 数据可以通过引用或原始类型来访问
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);
    
    // 报错！`point` 不能以可变方式借用，因为当前还有不可变借用。
    // let mutable_borrow = &amp;mut point;
    // TODO ^ 试一试去掉此行注释

    // 被借用的值在这里被重新使用
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // 不可变的引用不再用于其余的代码，因此可以使用可变的引用重新借用。
    let mutable_borrow = &amp;mut point;

    // 通过可变引用来修改数据
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // 报错！不能再以不可变方式来借用 `point`，因为它当前已经被可变借用。
    // let y = &amp;point.y;
    // TODO ^ 试一试去掉此行注释

    // 报错！无法打印，因为 `println!` 用到了一个不可变引用。
    // println!(&quot;Point Z coordinate is {}&quot;, point.z);
    // TODO ^ 试一试去掉此行注释

    // 正常运行！可变引用能够以不可变类型传入 `println!`
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // 可变引用不再用于其余的代码，因此可以重新借用
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<h1><a class="header" href="#ref-模式" id="ref-模式"><code>ref</code> 模式</a></h1>
<p>在通过 <code>let</code> 绑定来进行模式匹配或解构时，<code>ref</code> 关键字可用来创建结构体/元组的字段的引用。下面的例子展示了几个实例，可看到 <code>ref</code> 的作用：</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // 赋值语句中左边的 `ref` 关键字等价于右边的 `&amp;` 符号。
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // 在解构一个结构体时 `ref` 同样有效。
    let _copy_of_x = {
        // `ref_to_x` 是一个指向 `point` 的 `x` 字段的引用。
        let Point { x: ref ref_to_x, y: _ } = point;

        // 返回一个 `point` 的 `x` 字段的拷贝。
        *ref_to_x
    };

    // `point` 的可变拷贝
    let mut mutable_point = point;

    {
        // `ref` 可以与 `mut` 结合以创建可变引用。
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // 通过可变引用来改变 `mutable_point` 的字段 `y`。
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // 包含一个指针的可变元组
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // 解构 `mutable_tuple` 来改变 `last` 的值。
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<h1><a class="header" href="#生命周期" id="生命周期">生命周期</a></h1>
<p><strong>生命周期</strong>（lifetime）是这样一种概念，编译器（中的借用检查器）用它来保证所有的借用都是有效的。确切地说，一个变量的生命周期在它创建的时候开始，在它销毁的时候结束。虽然生命周期和作用域经常被一起提到，但它们并不相同。</p>
<p>例如考虑这种情况，我们通过 <code>&amp;</code> 来借用一个变量。该借用拥有一个生命周期，此生命周期由它声明的位置决定。于是，只要该借用在出借者（lender）被销毁前结束，借用就是有效的。然而，借用的作用域则是由使用引用的位置决定的。</p>
<p>在下面的例子和本章节剩下的内容里，我们将看到生命周期和作用域的联系与区别。</p>
<blockquote>
<p>译注：如果代码中的生命周期示意图乱掉了，请把它复制到任何编辑器中，用等宽字体查看。为避免中文的显示问题，下面一些注释没有翻译。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable">// 下面使用连线来标注各个变量的创建和销毁，从而显示出生命周期。
// `i` 的生命周期最长，因为它的作用域完全覆盖了 `borrow1` 和
// `borrow2` 的。`borrow1` 和 `borrow2` 的周期没有关联，
// 因为它们各不相交。
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>注意到这里没有用到名称或类型来标注生命周期，这限制了生命周期的用法，在后面我们将会看到生命周期更强大的功能。</p>
<h1><a class="header" href="#显式标注" id="显式标注">显式标注</a></h1>
<p>借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久。在生命周期没有省略<sup class="footnote-reference"><a href="#1">1</a></sup>的情况下，Rust 需要显式标注来确定引用的生命周期应该是什么样的。可以用撇号显式地标出生命周期，语法如下：</p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` 带有一个生命周期参数 `'a`
</code></pre>
<p>和<a href="scope/lifetime/../../fn/closures/anonymity.html">闭包</a>类似，使用生命周期需要泛型。另外这个生命周期的语法也表明了 <code>foo</code> 的生命周期不能超出 <code>'a</code> 的周期。若要给类型显式地标注生命周期，其语法会像是 <code>&amp;'a T</code> 这样，其中 <code>'a</code> 的作用刚刚已经介绍了。</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` 带有生命周期参数 `'a` 和 `'b`
</code></pre>
<p>在上面这种情形中，<code>foo</code> 的生命周期不能超出 <code>'a</code> 和 <code>'b</code> 中任一个的周期。</p>
<p>看下面的例子，了解显式生命周期标注的运用：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` 接受两个 `i32` 的引用，它们有不同的生命周期 `'a` 和 `'b`。
// 这两个生命周期都必须至少要和 `print_refs` 函数一样长。
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// 不带参数的函数，不过有一个生命周期参数 `'a`。
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // 报错：`_x` 的生命周期不够长
    //let y: &amp;'a i32 = &amp;_x;
    // 在函数内部使用生命周期 `'a` 作为显式类型标注将导致失败，因为 `&amp;_x` 的
    // 生命周期比 `y` 的短。短生命周期不能强制转换成长生命周期。
}

fn main() {
    // 创建变量，稍后用于借用。
    let (four, nine) = (4, 9);

    // 两个变量的借用（`&amp;`）都传进函数。
    print_refs(&amp;four, &amp;nine);
    // 任何被借用的输入量都必须比借用者生存得更长。
    // 也就是说，`four` 和 `nine` 的生命周期都必须比 `print_refs` 的长。

    failed_borrow();
    // `failed_borrow` 未包含引用，因此不要求 `'a` 长于函数的生命周期，
    // 但 `'a` 寿命确实更长。因为该生命周期从未被约束，所以默认为 `'static`。
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="scope/lifetime/elision.html">省略</a> 隐式地标注了生命周期，所以情况不同。</p>
</div>
<h3><a class="header" href="#参见-46" id="参见-46">参见：</a></h3>
<p><a href="scope/lifetime/../../generics.html">泛型</a> 和 <a href="scope/lifetime/../../fn/closures.html">闭包</a></p>
<h1><a class="header" href="#函数-2" id="函数-2">函数</a></h1>
<p>排除<a href="scope/lifetime/elision.html">省略</a>（elision）的情况，带上生命周期的函数签名有一些限制：</p>
<ul>
<li>任何引用<strong>都必须</strong>拥有标注好的生命周期。</li>
<li>任何被返回的引用<strong>都必须</strong>有和某个输入量相同的生命周期或是静态类型（<code>static</code>）。</li>
</ul>
<p>另外要注意，如果没有输入的函数返回引用，有时会导致返回的引用指向无效数据，这种情况下禁止它返回这样的引用。下面例子展示了一些合法的带有生命周期的函数：</p>
<pre><pre class="playground"><code class="language-rust editable">// 一个拥有生命周期 `'a` 的输入引用，其中 `'a` 的存活时间
// 至少与函数的一样长。
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// 可变引用同样也可能拥有生命周期。
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 拥有不同生命周期的多个元素。对下面这种情形，两者即使拥有
// 相同的生命周期 `'a` 也没问题，但对一些更复杂的情形，可能
// 就需要不同的生命周期了。
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// 返回传递进来的引用也是可行的。
// 但必须返回正确的生命周期。
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// 上面代码是无效的：`'a` 存活的时间必须比函数的长。
// 这里的 `&amp;String::from(&quot;foo&quot;)` 将会创建一个 `String` 类型，然后对它取引用。
// 数据在离开作用域时删掉，返回一个指向无效数据的引用。

fn main() {
    let x = 7;
    let y = 9;

    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);

    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3><a class="header" href="#参见-47" id="参见-47">参见：</a></h3>
<p><a href="scope/lifetime/fn.html">函数</a></p>
<h1><a class="header" href="#方法-1" id="方法-1">方法</a></h1>
<p>方法的标注和函数类似：</p>
<pre><pre class="playground"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // 标注生命周期，就像独立的函数一样。
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner  = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<blockquote>
<p>译注：方法一般是不需要标明生命周期的，因为 <code>self</code> 的生命周期会赋给所有的输出生命周期参数，详见 <a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">TRPL</a>。</p>
</blockquote>
<h3><a class="header" href="#参见-48" id="参见-48">参见：</a></h3>
<p><a href="scope/lifetime/../../fn/methods.html">方法</a></p>
<h1><a class="header" href="#结构体-2" id="结构体-2">结构体</a></h1>
<p>在结构体中标注生命周期也和函数的类似：</p>
<pre><pre class="playground"><code class="language-rust editable">// 一个 `Borrowed` 类型，含有一个指向 `i32` 类型的引用。
// 该引用必须比 `Borrowed` 寿命更长。
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 和前面类似，这里的两个引用都必须比这个结构体长寿。
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// 一个枚举类型，其取值不是 `i32` 类型就是一个指向 `i32` 的引用。
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<h3><a class="header" href="#参见-49" id="参见-49">参见：</a></h3>
<p><a href="scope/lifetime/../../custom_types/structs.html">结构体</a></p>
<h1><a class="header" href="#trait-1" id="trait-1">trait</a></h1>
<p>trait 方法中生命期的标注基本上与函数类似。注意，<code>impl</code> 也可能有生命周期的标注。</p>
<pre><pre class="playground"><code class="language-rust editable">// 带有生命周期标注的结构体。
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// 给 impl 标注生命周期。
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3><a class="header" href="#参见-50" id="参见-50">参见：</a></h3>
<p><a href="scope/lifetime/../../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#约束-1" id="约束-1">约束</a></h1>
<p>就如泛型类型能够被约束一样，生命周期（它们本身就是泛型）也可以使用约束。<code>:</code> 字符的意义在这里稍微有些不同，不过 <code>+</code> 是相同的。注意下面的说明：</p>
<ol>
<li><code>T: 'a</code>：在 <code>T</code> 中的<strong>所有</strong>引用都必须比生命周期 <code>'a</code> 活得更长。</li>
<li><code>T: Trait + 'a</code>：<code>T</code> 类型必须实现 <code>Trait</code> trait，并且在 <code>T</code> 中的<strong>所有</strong>引用都必须比 <code>'a</code> 活得更长。</li>
</ol>
<p>下面例子展示了上述语法的实际应用：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::fmt::Debug; // 用于约束的 trait。

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` 包含一个指向泛型类型 `T` 的引用，其中 `T` 拥有一个未知的生命周期
// `'a`。`T` 拥有生命周期限制， `T` 中的任何*引用*都必须比 `'a` 活得更长。另外
// `Ref` 的生命周期也不能超出 `'a`。

// 一个泛型函数，使用 `Debug` trait 来打印内容。
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// 这里接受一个指向 `T` 的引用，其中 `T` 实现了 `Debug` trait，并且在 `T` 中的
// 所有*引用*都必须比 `'a'` 存活时间更长。另外，`'a` 也要比函数活得更长。
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3><a class="header" href="#参见-51" id="参见-51">参见：</a></h3>
<p><a href="scope/lifetime/../../generics.html">泛型</a>, <a href="scope/lifetime/../../generics/bounds.html">泛型中的约束</a>, 以及 <a href="scope/lifetime/../../generics/multi_bounds.html">泛型中的多重约束</a></p>
<h1><a class="header" href="#强制转换" id="强制转换">强制转换</a></h1>
<p>一个较长的生命周期可以强制转成一个较短的生命周期，使它在一个通常情况下不能工作的作用域内也能正常工作。强制转换可由编译器隐式地推导并执行，也可以通过声明不同的生命周期的形式实现。</p>
<pre><pre class="playground"><code class="language-rust editable">// 在这里，Rust 推导了一个尽可能短的生命周期。
// 然后这两个引用都被强制转成这个生命周期。
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` 读作生命周期 `'a` 至少和 `'b` 一样长。
// 在这里我们我们接受了一个 `&amp;'a i32` 类型并返回一个 `&amp;'b i32` 类型，这是
// 强制转换得到的结果。
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 较长的生命周期

    {
        let second = 3; // 较短的生命周期

        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<h1><a class="header" href="#static" id="static">static</a></h1>
<p><code>'static</code> 生命周期是可能的生命周期中最长的，它会在整个程序运行的时期中存在。<code>'static</code> 生命周期也可被强制转换成一个更短的生命周期。有两种方式使变量拥有 <code>'static</code> 生命周期，它们都把数据保存在可执行文件的只读内存区：</p>
<ul>
<li>使用 <code>static</code> 声明来产生常量（constant）。</li>
<li>产生一个拥有 <code>&amp;'static str</code> 类型的 <code>string</code> 字面量。</li>
</ul>
<p>看下面的例子，了解列举到的各个方法：</p>
<pre><pre class="playground"><code class="language-rust editable">// 产生一个拥有 `'static` 生命周期的常量。
static NUM: i32 = 18;

// 返回一个指向 `NUM` 的引用，该引用不取 `NUM` 的 `'static` 生命周期，
// 而是被强制转换成和输入参数的一样。
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // 产生一个 `string` 字面量并打印它：
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // 当 `static_string` 离开作用域时，该引用不能再使用，不过
        // 数据仍然存在于二进制文件里面。
    }

    {
        // 产生一个整型给 `coerce_static` 使用：
        let lifetime_num = 9;

        // 将对 `NUM` 的引用强制转换成 `lifetime_num` 的生命周期：
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h3><a class="header" href="#参见-52" id="参见-52">参见：</a></h3>
<p><a href="scope/lifetime/../../custom_types/constants.html"><code>'static</code> 常量</a></p>
<h1><a class="header" href="#省略" id="省略">省略</a></h1>
<p>有些生命周期的模式太常用了，所以借用检查器将会隐式地添加它们以减少程序输入量和增强可读性。这种隐式添加生命周期的过程称为省略（elision）。在 Rust 使用省略仅仅是因为这些模式太普遍了。</p>
<p>下面代码展示了一些省略的例子。对于省略的详细描述，可以参考官方文档的<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">生命周期省略</a>。</p>
<pre><pre class="playground"><code class="language-rust editable">// `elided_input` 和 `annotated_input` 事实上拥有相同的签名，
// `elided_input` 的生命周期会被编译器自动添加：
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x)
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x)
}

// 类似地，`elided_pass` 和 `annotated_pass` 也拥有相同的签名，
// 生命周期会被隐式地添加进 `elided_pass`：
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3><a class="header" href="#参见-53" id="参见-53">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">省略</a></p>
<h1><a class="header" href="#特质-trait" id="特质-trait">特质 trait</a></h1>
<p><code>trait</code> 是对未知类型 <code>Self</code> 定义的方法集。该类型也可以访问同一个 trait 中定义的其他方法。</p>
<p>对任何数据类型都可以实现 trait。在下面例子中，我们定义了包含一系列方法的 <code>Animal</code>。然后针对 <code>Sheep</code> 数据类型实现 <code>Animal</code> <code>trait</code>，因而 <code>Sheep</code> 的实例可以使用 <code>Animal</code> 中的所有方法。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // 静态方法签名；`Self` 表示实现者类型（implementor type）。
    fn new(name: &amp;'static str) -&gt; Self;

    // 实例方法签名；这些方法将返回一个字符串。
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // trait 可以提供默认的方法定义。
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // 实现者可以使用它的 trait 方法。
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// 对 `Sheep` 实现 `Animal` trait。
impl Animal for Sheep {
    // `Self` 是实现者类型：`Sheep`。
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // 默认 trait 方法可以重载。
    fn talk(&amp;self) {
        // 例如我们可以增加一些安静的沉思。
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // 这种情况需要类型标注。
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // 试一试 ^ 移除类型标注。

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h1><a class="header" href="#派生" id="派生">派生</a></h1>
<p>通过 <code>#[derive]</code> <a href="trait/../attribute.html">属性</a>，编译器能够提供某些 trait 的基本实现。如果需要更复杂的行为，这些 trait 也可以手动实现。</p>
<p>下面是可以自动派生的 trait：</p>
<ul>
<li>比较 trait:
<a href="https://rustwiki.org/zh-CN/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://rustwiki.org/zh-CN/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
<li><a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html"><code>Clone</code></a>, 用来从 <code>&amp;T</code> 创建副本 <code>T</code>。</li>
<li><a href="https://rustwiki.org/zh-CN/core/marker/trait.Copy.html"><code>Copy</code></a>，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。</li>
<li><a href="https://rustwiki.org/zh-CN/std/hash/trait.Hash.html"><code>Hash</code></a>，从 <code>&amp;T</code> 计算哈希值（hash）。</li>
<li><a href="https://rustwiki.org/zh-CN/std/default/trait.Default.html"><code>Default</code></a>, 创建数据类型的一个空实例。</li>
<li><a href="https://rustwiki.org/zh-CN/std/fmt/trait.Debug.html"><code>Debug</code></a>，使用 <code>{:?}</code> formatter 来格式化一个值。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// `Centimeters`，可以比较的元组结构体
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`，可以打印的元组结构体
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`，不带附加属性的元组结构体
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // 试一试 ^ 取消此行注释

    // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // 试一试 ^ 取消此行注释

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3><a class="header" href="#参见-54" id="参见-54">参见</a></h3>
<p><a href="https://rustwiki.org/zh-CN/reference/attributes.html#%E6%B4%BE%E7%94%9F"><code>derive</code></a></p>
<h1><a class="header" href="#使用-dyn-返回-trait" id="使用-dyn-返回-trait">使用 <code>dyn</code> 返回 trait</a></h1>
<p>Rust 编译器需要知道每个函数的返回类型需要多少空间。这意味着所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p>
<p>但是，有一个简单的解决方法。相比于直接返回一个 trait 对象，我们的函数返回一个包含一些 <code>Animal</code> 的 <code>Box</code>。<code>box</code> 只是对堆中某些内存的引用。因为引用的大小是静态已知的，并且编译器可以保证引用指向已分配的堆 <code>Animal</code>，所以我们可以从函数中返回 trait！</p>
<p>每当在堆上分配内存时，Rust 都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的 trait 指针，则需要使用 <code>dyn</code> 关键字编写返回类型，例如 <code>Box&lt;dyn Animal&gt;</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Sheep {}
struct Cow {}

trait Animal {
    // 实例方法签名
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// 实现 `Sheep` 的 `Animal` trait。
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// 实现 `Cow` 的 `Animal` trait。
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// 返回一些实现 Animal 的结构体，但是在编译时我们不知道哪个结构体。
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}

</code></pre></pre>
<h1><a class="header" href="#运算符重载" id="运算符重载">运算符重载</a></h1>
<p>在 Rust 中，很多运算符可以通过 trait 来重载。也就是说，这些运算符可以根据它们的输入参数来完成不同的任务。这之所以可行，是因为运算符就是方法调用的语法糖。例如，<code>a + b</code> 中的 <code>+</code> 运算符会调用 <code>add</code> 方法（也就是 <code>a.add(b)</code>）。这个 <code>add</code> 方法是 <code>Add</code> trait 的一部分。因此，<code>+</code> 运算符可以被任何 <code>Add</code> trait 的实现者使用。</p>
<p>会重载运算符的 <code>trait</code>（比如 <code>Add</code> 这种）可以在<a href="https://rustwiki.org/zh-CN/core/ops/">这里</a>查看。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops::Add` trait 用来指明 `+` 的功能，这里我们实现 `Add&lt;Bar&gt;`，它是用于
// 把对象和 `Bar` 类型的右操作数（RHS）加起来的 `trait`。
// 下面的代码块实现了 `Foo + Bar = FooBar` 这样的运算。
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// 通过颠倒类型，我们实现了不服从交换律的加法。
// 这里我们实现 `Add&lt;Foo&gt;`，它是用于把对象和 `Foo` 类型的右操作数加起来的 trait。
// 下面的代码块实现了 `Bar + Foo = BarFoo` 这样的运算。
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3><a class="header" href="#参见-55" id="参见-55">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/core/ops/trait.Add.html">Add</a>, <a href="https://rustwiki.org/zh-CN/book/appendix-02-operators.html">语法索引</a></p>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/ops/trait.Drop.html"><code>Drop</code></a> trait 只有一个方法：<code>drop</code>，当对象离开作用域时会自动调用该方法。<code>Drop</code> trait 的主要作用是释放实现者的实例拥有的资源。</p>
<p><code>Box</code>，<code>Vec</code>，<code>String</code>，<code>File</code>，以及 <code>Process</code> 是一些实现了 <code>Drop</code> trait 来释放资源的类型。<code>Drop</code> trait 也可以为任何自定义数据类型手动实现。</p>
<p>下面示例给 <code>drop</code> 函数增加了打印到控制台的功能，用于宣布它在什么时候被调用。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// 这个简单的 `drop` 实现添加了打印到控制台的功能。
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // 代码块 A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // 代码块 B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // 变量可以手动使用 `drop` 函数来销毁。
    drop(_a);
    // 试一试 ^ 将此行注释掉。

    println!(&quot;end of the main function&quot;);

    // `_a` *不会*在这里再次销毁，因为它已经被（手动）销毁。
}
</code></pre></pre>
<h1><a class="header" href="#iterator" id="iterator">Iterator</a></h1>
<p><code>Iterator</code> trait 用来对集合（collection）类型（比如数组）实现迭代器。</p>
<p>这个 trait 只需定义一个返回 <code>next</code>（下一个）元素的方法，这可手动在 <code>impl</code> 代码块中定义，或者自动定义（比如在数组或区间中）。</p>
<p>为方便起见，<code>for</code> 结构会使用 <a href="https://rustwiki.org/zh-CN/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a> 方法将一些集合类型转换为迭代器。</p>
<p>下面例子展示了如何使用 <code>Iterator</code> trait 的方法，更多可用的方法可以看<a href="https://rustwiki.org/zh-CN/core/iter/trait.Iterator.html">这里</a>。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// 为 `Fibonacci`（斐波那契）实现 `Iterator`。
// `Iterator` trait 只需定义一个能返回 `next`（下一个）元素的方法。
impl Iterator for Fibonacci {
    type Item = u32;
    
    // 我们在这里使用 `.curr` 和 `.next` 来定义数列（sequence）。
    // 返回类型为 `Option&lt;T&gt;`：
    //     * 当 `Iterator` 结束时，返回 `None`。
    //     * 其他情况，返回被 `Some` 包裹（wrap）的下一个值。
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // 既然斐波那契数列不存在终点，那么 `Iterator` 将不可能
        // 返回 `None`，而总是返回 `Some`。
        Some(self.curr)
    }
}

// 返回一个斐波那契数列生成器
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` 是一个 `Iterator`，会产生：0、1 和 2。
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` 遍历 `Iterator` 直到返回 `None`，
    // 并且每个 `Some` 值都被解包（unwrap），然后绑定给一个变量（这里是 `i`）。       
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 。
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter` 方法对数组/slice 产生一个 `Iterator`。
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#impl-trait" id="impl-trait"><code>impl Trait</code></a></h1>
<p>如果函数返回实现了 <code>MyTrait</code> 的类型，可以将其返回类型编写为 <code>-&gt; impl MyTrait</code>。这可以大大简化你的类型签名！</p>
<pre><pre class="playground"><code class="language-rust editable">use std::iter;
use std::vec::IntoIter;

// 该函数组合了两个 `Vec &lt;i32&gt;` 并在其上返回一个迭代器。
// 看看它的返回类型多么复杂！
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// 这是完全相同的函数，但其返回类型使用 `impl Trait`。
// 看看它多么简单！
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>更重要的是，某些 Rust 类型无法写出。例如，每个闭包都有自己未命名的具体类型。在使用 <code>impl Trait</code> 语法之前，必须在堆上进行分配才能返回闭包。但是现在你可以像下面这样静态地完成所有操作：</p>
<pre><pre class="playground"><code class="language-rust editable">// 返回一个将输入和 `y` 相加的函数
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p>您还可以使用 <code>impl Trait</code> 返回使用 <code>map</code> 或 <code>filter</code> 闭包的迭代器！这使得使用 <code>map</code> 和 <code>filter</code> 更容易。因为闭包类型没有名称，所以如果函数返回带闭包的迭代器，则无法写出显式的返回类型。但是有了 <code>impl Trait</code>，你就可以轻松地做到这一点：</p>
<pre><pre class="playground"><code class="language-rust editable">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<h1><a class="header" href="#clone" id="clone">Clone</a></h1>
<p>当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要把资源复制一份。</p>
<p><a href="https://rustwiki.org/zh-CN/std/clone/trait.Clone.html"><code>Clone</code></a> trait 正好帮助我们完成这任务。通常，我们可以使用由 <code>Clone</code>
trait 定义的 <code>.clone()</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust editable">// 不含资源的单元结构体
#[derive(Debug, Clone, Copy)]
struct Nil;

// 一个包含资源的结构体，它实现了 `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // 实例化 `Nil`
    let nil = Nil;
    // 复制 `Nil`，没有资源用于移动（move）
    let copied_nil = nil;

    // 两个 `Nil` 都可以独立使用
    println!(&quot;original: {:?}&quot;, nil);
    println!(&quot;copy: {:?}&quot;, copied_nil);

    // 实例化 `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // 将 `pair` 绑定到 `moved_pair`，移动（move）了资源
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // 报错！`pair` 已失去了它的资源。
    //println!(&quot;original: {:?}&quot;, pair);
    // 试一试 ^ 取消此行注释。

    // 将 `moved_pair`（包括其资源）克隆到 `cloned_pair`。
    let cloned_pair = moved_pair.clone();
    // 使用 std::mem::drop 来销毁原始的 pair。
    drop(moved_pair);

    // 报错！`moved_pair` 已被销毁。
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // 试一试 ^ 将此行注释掉。

    // 由 .clone() 得来的结果仍然可用！
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<h1><a class="header" href="#父-trait" id="父-trait">父 trait</a></h1>
<p>Rust 没有“继承”，但是您可以将一个 trait 定义为另一个 trait 的超集（即父 trait）。例如：</p>
<pre><pre class="playground"><code class="language-rust editable">trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person 是 Student 的父 trait。
// 实现 Student 需要你也 impl 了 Person。
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student，计算机科学的学生) 是 Programmer 和 Student 两者的子类。
// 实现 CompSciStudent 需要你同时 impl 了两个父 trait。
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<h3><a class="header" href="#参见-56" id="参见-56">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch19-03-advanced-traits.html#%E7%88%B6-trait-%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA-trait-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9F%90-trait-%E7%9A%84%E5%8A%9F%E8%83%BD">《Rust 程序设计语言》的“父级 trait”章节</a></p>
<h1><a class="header" href="#消除重叠-trait" id="消除重叠-trait">消除重叠 trait</a></h1>
<p>一个类型可以实现许多不同的 trait。如果两个 trait 都需要相同的名称怎么办？例如，许多 trait 可能拥有名为 <code>get()</code> 的方法。他们甚至可能有不同的返回类型！</p>
<p>有个好消息：由于每个 trait 实现都有自己的 <code>impl</code> 块，因此很清楚您要实现哪个 trait 的 <code>get</code> 方法。</p>
<p>何时需要<strong>调用</strong>这些方法呢？为了消除它们之间的歧义，我们必须使用完全限定语法（Fully Qualified Syntax）。</p>
<pre><pre class="playground"><code class="language-rust editable">trait UsernameWidget {
    // 从这个 widget 中获取选定的用户名
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // 从这个 widget 中获取选定的年龄
    fn get(&amp;self) -&gt; u8;
}

// 同时具有 UsernameWidget 和 AgeWidget 的表单
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // 如果取消注释此行，则会收到一条错误消息，提示 “multiple `get` found”（找到了多个`get`）。
    // 因为毕竟有多个名为 `get` 的方法。
    // println!(&quot;{}&quot;, form.get());

    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<h3><a class="header" href="#参见-57" id="参见-57">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch19-03-advanced-traits.html#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%B6%88%E6%AD%A7%E4%B9%89%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95">《Rust 程序设计语言》中关于“完全限定语法”的章节</a></p>
<h1><a class="header" href="#使用-macro_rules-来创建宏" id="使用-macro_rules-来创建宏">使用 <code>macro_rules!</code> 来创建宏</a></h1>
<p>Rust 提供了一个强大的宏系统，可进行元编程（metaprogramming）。你已经在前面的章节中看到，宏看起来和函数很像，只不过名称末尾有一个感叹号 <code>!</code> 。宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起被编译。Rust 又有一点和 C
以及其他语言都不同，那就是 Rust 的宏会展开为抽象语法树（AST，abstract syntax
tree），而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。</p>
<p>宏是通过 <code>macro_rules!</code> 宏来创建的。</p>
<pre><pre class="playground"><code class="language-rust editable">// 这是一个简单的宏，名为 `say_hello`。
macro_rules! say_hello {
    // `()` 表示此宏不接受任何参数。
    () =&gt; {
        // 此宏将会展开成这个代码块里面的内容。
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // 这个调用将会展开成 `println!(&quot;Hello!&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>为什么宏是有用的？</p>
<ol>
<li>不写重复代码（DRY，Don't repeat yourself.）。很多时候你需要在一些地方针对不同
的类型实现类似的功能，这时常常可以使用宏来避免重复代码（稍后详述）。</li>
<li>领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的
语法（稍后详述）。</li>
<li>可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如
<code>println!</code>，根据格式化字符串的不同，它需要接受任意多的参数（稍后详述）。</li>
</ol>
<h1><a class="header" href="#语法" id="语法">语法</a></h1>
<p>在下面的小节中，我们将展示如何在 Rust 中定义宏。基本的概念有三个：</p>
<ul>
<li><a href="macros/designators.html">模式与指示符</a></li>
<li><a href="macros/overload.html">重载</a></li>
<li><a href="macros/repeat.html">重复</a></li>
</ul>
<h1><a class="header" href="#指示符" id="指示符">指示符</a></h1>
<p>宏的参数使用一个美元符号 <code>$</code> 作为前缀，并使用一个<strong>指示符</strong>（designator）来注明类型：</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! create_function {
    // 此宏接受一个 `ident` 指示符表示的参数，并创建一个名为 `$func_name` 的函数。
    // `ident` 指示符用于变量名或函数名
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // `stringify!` 宏把 `ident` 转换成字符串。
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name))
        }
    };
}

// 借助上述宏来创建名为 `foo` 和 `bar` 的函数。
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // 此宏接受一个 `expr` 类型的表达式，并将它作为字符串，连同其结果一起
    // 打印出来。
    // `expr` 指示符表示表达式。
    ($expression:expr) =&gt; {
        // `stringify!` 把表达式*原样*转换成一个字符串。
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression)
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // 回想一下，代码块也是表达式！
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>这里列出全部指示符：</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> 用于表达式</li>
<li><code>ident</code> 用于变量名或函数名</li>
<li><code>item</code></li>
<li><code>literal</code> 用于字面常量</li>
<li><code>pat</code> (<strong>模式</strong> <em>pattern</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<strong>语句</strong> <em>statement</em>)</li>
<li><code>tt</code> (<strong>标记树</strong> <em>token tree</em>)</li>
<li><code>ty</code> (<strong>类型</strong> <em>type</em>)</li>
<li><code>vis</code> (<em>可见性描述符</em>)</li>
</ul>
<p>完整列表详见 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference</a>。</p>
<h1><a class="header" href="#重载" id="重载">重载</a></h1>
<p>宏可以重载，从而接受不同的参数组合。在这方面，<code>macro_rules!</code> 的作用类似于匹配（match）代码块：</p>
<pre><pre class="playground"><code class="language-rust editable">// 根据你调用它的方式，`test!` 将以不同的方式来比较 `$left` 和 `$right`。
macro_rules! test {
    // 参数不需要使用逗号隔开。
    // 参数可以任意组合！
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ 每个分支都必须以分号结束。
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<h1><a class="header" href="#重复" id="重复">重复</a></h1>
<p>宏在参数列表中可以使用 <code>+</code> 来表示一个参数可能出现一次或多次，使用 <code>*</code> 来表示该参数可能出现零次或多次。</p>
<p>在下面例子中，把模式这样： <code>$(...),+</code> 包围起来，就可以匹配一个或多个用逗号隔开的表达式。另外注意到，宏定义的最后一个分支可以不用分号作为结束。</p>
<pre><pre class="playground"><code class="language-rust editable">// `min!` 将求出任意数量的参数的最小值。
macro_rules! find_min {
    // 基本情形：
    ($x:expr) =&gt; ($x);
    // `$x` 后面跟着至少一个 `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // 对 `$x` 后面的 `$y` 们调用 `find_min!` 
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<h1><a class="header" href="#dry-不写重复代码" id="dry-不写重复代码">DRY (不写重复代码)</a></h1>
<p>通过提取函数或测试集的公共部分，宏可以让你写出 DRY 的代码（DRY 是 Don't Repeat Yourself 的缩写，意思为 “不要写重复代码”）。这里给出一个例子，对 <code>Vec&lt;T&gt;</code> 实现并测试了关于 <code>+=</code>、<code>*=</code> 和 <code>-=</code> 等运算符。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt`（token tree，标记树）指示符表示运算符和标记。
    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// 实现 `add_assign`、`mul_assign` 和 `sub_assign` 等函数。
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        }
    }

    // 测试 `add_assign`、`mul_assign` 和 `sub_assign`
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}

</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#dsl领域专用语言" id="dsl领域专用语言">DSL（领域专用语言）</a></h1>
<p>DSL 是 Rust 的宏中集成的微型 “语言”。这种语言是完全合法的，因为宏系统会把它转换成普通的 Rust 语法树，它只不过看起来像是另一种语言而已。这就允许你为一些特定功能创造一套简洁直观的语法（当然是有限制的）。</p>
<p>比如说我想要定义一套小的计算器 API，可以传给它表达式，它会把结果打印到控制台上。</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {
        {
            let val: usize = $e; // 强制类型为整型
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    };
}

fn main() {
    calculate! {
        eval 1 + 2 // 看到了吧，`eval` 可并不是 Rust 的关键字！
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>输出:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>这个例子非常简单，但是已经有很多利用宏开发的复杂接口了，比如
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> 和
<a href="https://crates.io/crates/clap"><code>clap</code></a>。</p>
<h1><a class="header" href="#可变参数接口" id="可变参数接口">可变参数接口</a></h1>
<p>可变参数接口可以接受任意数目的参数。比如说 <code>println</code> 就可以，其参数的数目是由格式化字符串指定的。</p>
<p>我们可以把之前的 <code>calculate!</code> 宏改写成可变参数接口：</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! calculate {
    // 单个 `eval` 的模式
    (eval $e:expr) =&gt; {
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    };

    // 递归地拆解多重的 `eval`
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // 妈妈快看，可变参数的 `calculate!`！
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>输出：</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<h1><a class="header" href="#错误处理" id="错误处理">错误处理</a></h1>
<p>错误处理（error handling）是处理可能发生的失败情况的过程。例如读取一个文件时失败了，如果继续使用这个<strong>无效的</strong>输入，那显然是有问题的。注意到并且显式地处理这种错误可以避免程序的其他部分产生潜在的问题。</p>
<p>在 Rust 中有多种处理错误的方式，在接下来的小节中会一一介绍。它们多少有些区别，使用场景也不尽相同。总的来说：</p>
<ul>
<li>显式的 <code>panic</code> 主要用于测试，以及处理不可恢复的错误。在原型开发中这很有用，比如
用来测试还没有实现的函数，不过这时使用 <code>unimplemented</code> 更能表达意图。另外在
测试中，<code>panic</code> 是一种显式地失败（fail）的好方法。</li>
<li><code>Option</code> 类型是为了值是可选的、或者缺少值并不是错误的情况准备的。比如说寻找
父目录时，<code>/</code> 和 <code>C:</code> 这样的目录就没有父目录，这应当并不是一个错误。当处理
<code>Option</code> 时，<code>unwrap</code> 可用于原型开发，也可以用于能够确定 <code>Option</code> 中一定有值
的情形。然而 <code>expect</code> 更有用，因为它允许你指定一条错误信息，以免万一还是出现
了错误。</li>
<li>当错误有可能发生，且应当由调用者处理时，使用 <code>Result</code>。你也可以 <code>unwrap</code> 然后
使用 <code>expect</code>，但是除了在测试或者原型开发中，请不要这样做。</li>
</ul>
<p>有关错误处理的更多内容，可参考<a href="https://rustwiki.org/zh-CN/book/ch09-00-error-handling.html">官方文档</a>的错误处理的章节。</p>
<h1><a class="header" href="#panic" id="panic"><code>panic</code></a></h1>
<p>我们将要看到的最简单的错误处理机制就是 <code>panic</code>。它会打印一个错误消息，开始回退（unwind）任务，且通常会退出程序。这里我们显式地在错误条件下调用 <code>panic</code>：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // 公主讨厌蛇，所以如果公主表示厌恶的话我们要停止！
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#option-和-unwrap" id="option-和-unwrap"><code>Option</code> 和 <code>unwrap</code></a></h1>
<p>上个例子展示了如何主动地引入程序失败（program failure）。当公主收到蛇这件不合适的礼物时，我们就让程序 <code>panic</code>。但是，如果公主期待收到礼物，却没收到呢？这同样是一件糟糕的事情，所以我们要想办法来解决这个问题！</p>
<p>我们<strong>可以</strong>检查空字符串（<code>&quot;&quot;</code>），就像处理蛇那样。但既然我们在用 Rust，不如让编译器辨别没有礼物的情况。</p>
<p>在标准库（<code>std</code>）中有个叫做 <code>Option&lt;T&gt;</code>（option 中文意思是 “选项”）的枚举类型，用于有 “不存在” 的可能性的情况。它表现为以下两个 “option”（选项）中的一个：</p>
<ul>
<li><code>Some(T)</code>：找到一个属于 <code>T</code> 类型的元素</li>
<li><code>None</code>：找不到相应元素</li>
</ul>
<p>这些选项可以通过 <code>match</code> 显式地处理，或使用 <code>unwrap</code> 隐式地处理。隐式处理要么返回 <code>Some</code> 内部的元素，要么就 <code>panic</code>。</p>
<p>请注意，手动使用 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.expect">expect</a> 方法自定义 <code>panic</code> 信息是可能的，但相比显式处理，<code>unwrap</code> 的输出仍显得不太有意义。在下面例子中，显式处理将举出更受控制的结果，同时如果需要的话，仍然可以使程序 <code>panic</code>。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 平民（commoner）们见多识广，收到什么礼物都能应对。
// 所有礼物都显式地使用 `match` 来处理。
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // 指出每种情况下的做法。
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm throwing that snake in a fire.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// 养在深闺人未识的公主见到蛇就会 `panic`（恐慌）。
// 这里所有的礼物都使用 `unwrap` 隐式地处理。
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` 在接收到 `None` 时将返回 `panic`。
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;chicken&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<h1><a class="header" href="#使用--解开-option" id="使用--解开-option">使用 <code>?</code> 解开 <code>Option</code></a></h1>
<p>你可以使用 <code>match</code> 语句来解开 <code>Option</code>，但使用 <code>?</code> 运算符通常会更容易。如果 <code>x</code> 是 <code>Option</code>，那么若 <code>x</code> 是 <code>Some</code> ，对<code>x?</code>表达式求值将返回底层值，否则无论函数是否正在执行都将终止且返回 <code>None</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
    // 如果 `current_age` 是 `None`，这将返回 `None`。
    // 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<p>你可以将多个 <code>?</code> 链接在一起，以使代码更具可读性。</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {

    // 获取此人的工作电话号码的区号（如果存在的话）。
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // 没有`？`运算符的话，这将需要很多的嵌套的 `match` 语句。
        // 这将需要更多代码——尝试自己编写一下，看看哪个更容易。
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<h1><a class="header" href="#组合算子map" id="组合算子map">组合算子：<code>map</code></a></h1>
<p><code>match</code> 是处理 <code>Option</code> 的一个可用的方法，但你会发现大量使用它会很繁琐，特别是当操作只对一种输入是有效的时。这时，可以使用<a href="https://rustwiki.org/zh-CN/reference/glossary.html#%E7%BB%84%E5%90%88%E7%AE%97%E5%AD%90">组合算子</a>（combinator），以模块化的风格来管理控制流。</p>
<p><code>Option</code> 有一个内置方法 <code>map()</code>，这个组合算子可用于 <code>Some -&gt; Some</code> 和
<code>None -&gt; None</code> 这样的简单映射。多个不同的 <code>map()</code> 调用可以串起来，这样更加灵活。</p>
<p>在下面例子中，<code>process()</code> 轻松取代了前面的所有函数，且更加紧凑。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 削皮。如果没有食物，就返回 `None`。否则返回削好皮的食物。
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 切食物。如果没有食物，就返回 `None`。否则返回切好的食物。
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 烹饪食物。这里，我们使用 `map()` 来替代 `match` 以处理各种情况。
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// 这个函数会完成削皮切块烹饪一条龙。我们把 `map()` 串起来，以简化代码。
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// 在尝试吃食物之前确认食物是否存在是非常重要的！
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));

    // 现在让我们试试看起来更简单的 `process()`。
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3><a class="header" href="#参见-58" id="参见-58">参见：</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">闭包</a>, <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html"><code>Option</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<h1><a class="header" href="#组合算子and_then" id="组合算子and_then">组合算子：<code>and_then</code></a></h1>
<p><code>map()</code> 以链式调用的方式来简化 <code>match</code> 语句。然而，如果以返回类型是 <code>Option&lt;T&gt;</code>
的函数作为 <code>map()</code> 的参数，会导致出现嵌套形式 <code>Option&lt;Option&lt;T&gt;&gt;</code>。这样多层串联调用就会变得混乱。所以有必要引入 <code>and_then()</code>，在某些语言中它叫做 flatmap。</p>
<p><code>and_then()</code> 使用被 <code>Option</code> 包裹的值来调用其输入函数并返回结果。 如果 <code>Option</code>
是 <code>None</code>，那么它返回 <code>None</code>。</p>
<p>在下面例子中，<code>cookable_v2()</code> 会产生一个 <code>Option&lt;Food&gt;</code>。如果在这里使用 <code>map()</code>
而不是 <code>and_then()</code> 将会得到 <code>Option&lt;Option&lt;Food&gt;&gt;</code>，这对 <code>eat()</code> 来说是一个无效类型。</p>
<pre><pre class="playground"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// 我们没有制作寿司所需的原材料（ingredient）（有其他的原材料）。
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// 我们拥有全部食物的食谱，除了法国蓝带猪排（Cordon Bleu）的。
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}


// 要做一份好菜，我们需要原材料和食谱。
// 我们可以借助一系列 `match` 来表达这个逻辑：
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_ingredients(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_recipe(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑：
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_ingredients(food).and_then(have_recipe)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3><a class="header" href="#参见-59" id="参见-59">参见：</a></h3>
<p><a href="error/option_unwrap/../../fn/closures.html">闭包</a>，<a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.map"><code>Option::map()</code></a>, 和 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<h1><a class="header" href="#结果-result" id="结果-result">结果 <code>Result</code></a></h1>
<p><a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 是 <a href="https://rustwiki.org/zh-CN/std/option/enum.Option.html"><code>Option</code></a> 类型的更丰富的版本，描述的是可能的<strong>错误</strong>而不是可能的<strong>不存在</strong>。</p>
<p>也就是说，<code>Result&lt;T，E&gt;</code> 可以有两个结果的其中一个：</p>
<ul>
<li><code>Ok&lt;T&gt;</code>：找到 <code>T</code> 元素</li>
<li><code>Err&lt;E&gt;</code>：找到 <code>E</code> 元素，<code>E</code> 即表示错误的类型。</li>
</ul>
<p>按照约定，预期结果是 “Ok”，而意外结果是 “Err”。</p>
<p><code>Result</code> 有很多类似 <code>Option</code> 的方法。例如 <code>unwrap()</code>，它要么举出元素
<code>T</code>，要么就 <code>panic</code>。 对于事件的处理，<code>Result</code> 和 <code>Option</code> 有很多相同的组合算子。</p>
<p>在使用 Rust 时，你可能会遇到返回 <code>Result</code> 类型的方法，例如 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse()</code></a>
方法。它并不是总能把字符串解析成指定的类型，所以 <code>parse()</code> 返回一个
<code>Result</code> 表示可能的失败。</p>
<p>我们来看看当 <code>parse()</code> 字符串成功和失败时会发生什么：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // 我们试着用 `unwrap()` 把数字放出来。它会咬我们一口吗？
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>在失败的情况下，<code>parse()</code> 产生一个错误，留给 <code>unwrap()</code> 来解包并产生 <code>panic</code>。另外，<code>panic</code> 会退出我们的程序，并提供一个让人很不爽的错误消息。</p>
<p>为了改善错误消息的质量，我们应该更具体地了解返回类型并考虑显式地处理错误。</p>
<h1><a class="header" href="#result-的-map" id="result-的-map"><code>Result</code> 的 <code>map</code></a></h1>
<p>上一节的 <code>multiply</code> 函数的 panic 设计不是健壮的（robust）。一般地，我们希望把错误返回给调用者，这样它可以决定回应错误的正确方式。</p>
<p>首先，我们需要了解需要处理的错误类型是什么。为了确定 <code>Err</code> 的类型，我们可以用 <a href="https://rustwiki.org/zh-CN/std/primitive.str.html#method.parse"><code>parse()</code></a> 来试验。Rust 已经为 <a href="https://rustwiki.org/zh-CN/std/primitive.i32.html"><code>i32</code></a> 类型使用
<a href="https://rustwiki.org/zh-CN/std/str/trait.FromStr.html"><code>FromStr</code></a> trait 实现了 <code>parse()</code>。结果表明，这里的 <code>Err</code> 类型被指定为
<a href="https://rustwiki.org/zh-CN/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>。</p>
<blockquote>
<p>译注：原文没有具体讲如何确定 <code>Err</code> 的类型。由于目前用于获取类型的函数仍然是不
稳定的，我们可以用间接的方法。使用下面的代码：</p>
<pre><code class="language-rust editable ignore">fn main () {
    let i: () = &quot;t&quot;.parse::&lt;i32&gt;();
}
</code></pre>
<p>由于不可能把 <code>Result</code> 类型赋给单元类型变量 <code>i</code>，编译器会提示我们：</p>
<pre><code class="language-text">note: expected type `()`
         found type `std::result::Result&lt;i32, std::num::ParseIntError&gt;`
</code></pre>
<p>这样就知道了 <code>parse&lt;i32&gt;</code> 函数的返回类型详情。</p>
</blockquote>
<p>在下面的例子中，使用简单的 <code>match</code> 语句导致了更加繁琐的代码。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// 修改了上一节中的返回类型，现在使用模式匹配而不是 `unwrap()`。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // 这种情形下仍然会给出正确的答案。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // 这种情况下就会提供一条更有用的错误信息。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>幸运的是，<code>Option</code> 的 <code>map</code>、<code>and_then</code>、以及很多其他组合算子也为 <code>Result</code> 实现了。官方文档的 <a href="https://rustwiki.org/zh-CN/std/result/enum.Result.html"><code>Result</code></a> 一节包含完整的方法列表。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// 就像 `Option` 那样，我们可以使用 `map()` 之类的组合算子。
// 除去写法外，这个函数与上面那个完全一致，它的作用是：
// 如果值是合法的，计算其乘积，否则返回错误。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // 这种情况下仍然会给出正确的答案。
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // 这种情况下就会提供一条更有用的错误信息。
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<h1><a class="header" href="#给-result-取别名" id="给-result-取别名">给 <code>Result</code> 取别名</a></h1>
<p>当我们要重用某个 <code>Result</code> 类型时，该怎么办呢？回忆一下，Rust 允许我们创建<a href="error/result/../../types/alias.html">别名</a>。若某个 <code>Result</code> 有可能被重用，我们可以方便地给它取一个别名。</p>
<p>在模块的层面上创建别名特别有帮助。同一模块中的错误常常会有相同的 <code>Err</code> 类型，所以单个别名就能简便地定义<strong>所有</strong>相关的 <code>Result</code>。这太有用了，以至于标准库也提供了一个别名： <a href="https://rustwiki.org/zh-CN/std/io/type.Result.html"><code>io::Result</code></a>！</p>
<p>下面给出一个简短的示例来展示语法：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

// 为带有错误类型 `ParseIntError` 的 `Result` 定义一个泛型别名。
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// 使用上面定义过的别名来表示上一节中的 `Result&lt;i32,ParseIntError&gt;` 类型。
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// 在这里使用别名又让我们节省了一些代码量。
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#参见-60" id="参见-60">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/io/type.Result.html"><code>io::Result</code></a></p>
<h1><a class="header" href="#提前返回" id="提前返回">提前返回</a></h1>
<p>在上一个例子中，我们显式地使用组合算子处理了错误。另一种处理错误的方式是使用
<code>match</code> 语句和<strong>提前返回</strong>（early return）的结合。</p>
<p>这也就是说，如果发生错误，我们可以停止函数的执行然后返回错误。对有些人来说，这样的代码更好写，更易读。这次我们使用提前返回改写之前的例子：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>到此为止，我们已经学会了如何使用组合算子和提前返回显式地处理错误。我们一般是想要避免 panic 的，但显式地处理所有错误确实显得过于繁琐。</p>
<p>在下一部分，我们将看到，当只是需要 <code>unwrap</code> 并且不产生 <code>panic</code> 时，可以使用
<code>?</code> 来达到同样的效果。</p>
<h1><a class="header" href="#引入-" id="引入-">引入 <code>?</code></a></h1>
<p>有时我们只是想 <code>unwrap</code> 且避免产生 <code>panic</code>。到现在为止，对 <code>unwrap</code> 的错误处理都在强迫我们一层层地嵌套，然而我们只是想把里面的变量拿出来。<code>?</code> 正是为这种情况准备的。</p>
<p>当找到一个 <code>Err</code> 时，可以采取两种行动：</p>
<ol>
<li><code>panic!</code>，不过我们已经决定要尽可能避免 panic 了。</li>
<li>返回它，因为 <code>Err</code> 就意味着它已经不能被处理了。</li>
</ol>
<p><code>?</code> <strong>几乎</strong><sup class="footnote-reference"><a href="#†">1</a></sup> 就等于一个会返回 <code>Err</code> 而不是 <code>panic</code> 的 <code>unwrap</code>。我们来看看怎样简化之前使用组合算子的例子：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#try-宏" id="try-宏"><code>try!</code> 宏</a></h2>
<p>在 <code>?</code> 出现以前，相同的功能是使用 <code>try!</code> 宏完成的。现在我们推荐使用 <code>?</code> 运算符，但是在老代码中仍然会看到 <code>try!</code>。如果使用 <code>try!</code> 的话，上一个例子中的 <code>multiply</code> 函数看起来会像是这样：</p>
<pre><pre class="playground"><code class="language-rust editable edition2015">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>更多细节请看<a href="error/result/../multiple_error_types/reenter_question_mark.html"><code>?</code> 的更多用法</a>。</p>
</div>
<h1><a class="header" href="#处理多种错误类型" id="处理多种错误类型">处理多种错误类型</a></h1>
<p>前面出现的例子都是很方便的情况；都是 <code>Result</code> 和其他 <code>Result</code> 交互，还有 <code>Option</code>
和其他 <code>Option</code> 交互。</p>
<p>有时 <code>Option</code> 需要和 <code>Result</code> 进行交互，或是 <code>Result&lt;T, Error1&gt;</code> 需要和
<code>Result&lt;T, Error2&gt;</code> 进行交互。在这类情况下，我们想要以一种方式来管理不同的错误类型，使得它们可组合且易于交互。</p>
<p>在下面代码中，<code>unwrap</code> 的两个实例生成了不同的错误类型。<code>Vec::first</code> 返回一个
<code>Option</code>，而 <code>parse::&lt;i32&gt;</code> 返回一个 <code>Result&lt;i32, ParseIntError&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // 生成错误 1
    2 * first.parse::&lt;i32&gt;().unwrap() // 生成错误 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    
    println!(&quot;The first doubled is {}&quot;, double_first(numbers));
    
    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // 错误1：输入 vector 为空
    
    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // 错误2：此元素不能解析成数字
}
</code></pre></pre>
<p>在下面几节中，我们会看到处理这类问题的几种策略。</p>
<h1><a class="header" href="#从-option-中取出-result" id="从-option-中取出-result">从 <code>Option</code> 中取出 <code>Result</code></a></h1>
<p>处理混合错误类型的最基本的手段就是让它们互相包含。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>有时候我们不想再处理错误（比如使用 <a href="error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a> 的时候），但如果
<code>Option</code> 是 <code>None</code> 则继续处理错误。一些组合算子可以让我们轻松地交换 <code>Result</code> 和
<code>Option</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#定义一个错误类型" id="定义一个错误类型">定义一个错误类型</a></h1>
<p>有时候把所有不同的错误都视为一种错误类型会简化代码。我们将用一个自定义错误类型来演示这一点。</p>
<p>Rust 允许我们定义自己的错误类型。一般来说，一个 “好的” 错误类型应当：</p>
<ul>
<li>用同一个类型代表了多种错误</li>
<li>向用户提供了清楚的错误信息</li>
<li>能够容易地与其他类型比较
<ul>
<li>好的例子：<code>Err(EmptyVec)</code></li>
<li>坏的例子：<code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>能够容纳错误的具体信息
<ul>
<li>好的例子：<code>Err(BadChar(c, position))</code></li>
<li>坏的例子：<code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>能够与其他错误很好地整合</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug, Clone)]
// 定义我们的错误类型，这种类型可以根据错误处理的实际情况定制。
// 我们可以完全自定义错误类型，也可以在类型中完全采用底层的错误实现，
// 也可以介于二者之间。
struct DoubleError;

// 错误的生成与它如何显示是完全没关系的。没有必要担心复杂的逻辑会导致混乱的显示。
//
// 注意我们没有储存关于错误的任何额外信息，也就是说，如果不修改我们的错误类型定义的话，
// 就无法指明是哪个字符串解析失败了。
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

// 为 `DoubleError` 实现 `Error` trait，这样其他错误可以包裹这个错误类型。
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // 泛型错误，没有记录其内部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       // 把错误换成我们的新类型。
       .ok_or(DoubleError)
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // 这里也换成新类型。
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#把错误-装箱" id="把错误-装箱">把错误 “装箱”</a></h1>
<p>如果又想写简单的代码，又想保存原始错误信息，一个方法是把它们<a href="https://rustwiki.org/zh-CN/std/boxed/struct.Box.html">装箱</a>（<code>Box</code>）。这样做的坏处就是，被包装的错误类型只能在运行时了解，而不能被<a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">静态地判别</a>。</p>
<p>对任何实现了 <code>Error</code> trait 的类型，标准库的 <code>Box</code> 通过 <a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From</code></a> 为它们提供了到 <code>Box&lt;Error&gt;</code> 的转换。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// 为 `Box&lt;error::Error&gt;` 取别名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn error::Error&gt; {
        // 泛型错误。没有记录其内部原因。
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
       .ok_or_else(|| EmptyVec.into())  // 装箱
       .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into())  // 装箱
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3><a class="header" href="#参见-61" id="参见-61">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/book/ch17-02-trait-objects.html#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">动态分发</a> and <a href="https://rustwiki.org/zh-CN/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<h1><a class="header" href="#-的其他用法" id="-的其他用法"><code>?</code> 的其他用法</a></h1>
<p>注意在上一个例子中，我们调用 <code>parse</code> 后总是立即将错误从标准库的错误 <code>map</code>（映射）到装箱错误。</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>因为这个操作很简单常见，如果有省略写法就好了。遗憾的是 <code>and_then</code> 不够灵活，所以实现不了这样的写法。不过，我们可以使用 <code>?</code> 来代替它。</p>
<p><code>?</code> 之前被解释为要么 <code>unwrap</code>，要么 <code>return Err(err)</code>，这只是在大多数情况下是正确的。<code>?</code> 实际上是指  <code>unwrap</code> 或 <code>return Err(From::from(err))</code>。由于 <code>From::from</code> 是不同类型之间的转换工具，也就是说，如果在错误可转换成返回类型地方使用 <code>?</code>，它将自动转换成返回类型。</p>
<p>我们在这里使用 <code>?</code> 重写之前的例子。重写后，只要为我们的错误类型实现 <code>From::from</code>，就可以不再使用 <code>map_err</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::fmt;

// 为 `Box&lt;error::Error&gt;` 取别名。
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

// 这里的结构和之前一样，但是这次没有把所有的 `Result` 和 `Option` 串起来，
// 而是使用 `?` 立即得到内部值。
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>这段代码已经相当清晰了。与原来的 <code>panic</code> 相比，除了返回类型是 <code>Result</code> 之外，它就像是把所有的 <code>unwrap</code> 调用都换成 <code>?</code> 一样。因此必须在顶层解构它们。</p>
<h3><a class="header" href="#参见-62" id="参见-62">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From::from</code></a> 和 <a href="https://rustwiki.org/zh-CN/reference/expressions/operator-expr.html#%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>?</code></a></p>
<h1><a class="header" href="#包裹错误" id="包裹错误">包裹错误</a></h1>
<p>把错误装箱这种做法也可以改成把它包裹到你自己的错误类型中。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // 在这个错误类型中，我们采用 `parse` 的错误类型中 `Err` 部分的实现。
    // 若想提供更多信息，则该类型中还需要加入更多数据。
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // 这是一个封装（wrapper），它采用内部各类型对 `fmt` 的实现。
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 原因采取内部对错误类型的实现。它隐式地转换成了 trait 对象 `&amp;error:Error`。
            // 这可以工作，因为内部的类型已经实现了 `Error` trait。
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// 实现从 `ParseIntError` 到 `DoubleError` 的转换。
// 在使用 `?` 时，或者一个 `ParseIntError` 需要转换成 `DoubleError` 时，它会被自动调用。
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>这种做法会在错误处理中增加一些模板化的代码，而且也不是所有的应用都需要这样做。一些库可以帮你处理模板化代码的问题。</p>
<h3><a class="header" href="#see-also-1" id="see-also-1">See also:</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/convert/trait.From.html"><code>From::from</code></a> and <a href="error/multiple_error_types/../../custom_types/enum.html"><code>枚举类型</code></a></p>
<h1><a class="header" href="#遍历-result" id="遍历-result">遍历 <code>Result</code></a></h1>
<p><code>Iter::map</code> 操作可能失败，比如：</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>我们来看一些处理这种问题的策略：</p>
<h2><a class="header" href="#使用-filter_map-忽略失败的项" id="使用-filter_map-忽略失败的项">使用 <code>filter_map()</code> 忽略失败的项</a></h2>
<p><code>filter_map</code> 会调用一个函数，过滤掉为 <code>None</code> 的所有结果。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2><a class="header" href="#使用-collect-使整个操作失败" id="使用-collect-使整个操作失败">使用 <code>collect()</code> 使整个操作失败</a></h2>
<p><code>Result</code> 实现了 <code>FromIter</code>，因此结果的向量（<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>）可以被转换成结果包裹着向量（<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>）。一旦找到一个 <code>Result::Err</code> ，遍历就被终止。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>同样的技巧可以对 <code>Option</code> 使用。</p>
<h2><a class="header" href="#使用-partition-收集所有合法的值与错误" id="使用-partition-收集所有合法的值与错误">使用 <code>Partition()</code> 收集所有合法的值与错误</a></h2>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>当你看着这些结果时，你会发现所有东西还在 <code>Result</code> 中保存着。要取出它们，需要一些模板化的代码。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<h1><a class="header" href="#标准库类型" id="标准库类型">标准库类型</a></h1>
<p>标准库提供了很多自定义类型，在<strong>原生类型</strong>基础上进行了大量扩充。这是部分自定义类型：</p>
<ul>
<li>可增长的 <code>String</code>（字符串），如: <code>&quot;hello world&quot;</code></li>
<li>可增长的向量（vector）: <code>[1, 2, 3]</code></li>
<li>选项类型（optional types）: <code>Option&lt;i32&gt;</code></li>
<li>错误处理类型（error handling types）: <code>Result&lt;i32, i32&gt;</code></li>
<li>堆分配的指针（heap allocated pointers）: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3><a class="header" href="#参见-63" id="参见-63">参见：</a></h3>
<p><a href="primitives.html">原生类型</a> 和 <a href="https://rustwiki.org/zh-CN/std/">标准库</a></p>
<h1><a class="header" href="#箱子栈和堆" id="箱子栈和堆">箱子、栈和堆</a></h1>
<p>在 Rust 中，所有值默认都是栈分配的。通过创建 <code>Box&lt;T&gt;</code>，可以把值<strong>装箱</strong>（boxed）来使它在堆上分配。箱子（box，即 <code>Box&lt;T&gt;</code> 类型的实例）是一个智能指针，指向堆分配的 <code>T</code> 类型的值。当箱子离开作用域时，它的析构函数会被调用，内部的对象会被销毁，堆上分配的内存也会被释放。</p>
<p>被装箱的值可以使用 <code>*</code> 运算符进行解引用；这会移除掉一层装箱。</p>
<pre><pre class="playground"><code class="language-rust editalbe">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // 在堆上分配这个点（point），并返回一个指向它的指针
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // （所有的类型标注都不是必需的）
    // 栈分配的变量
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // 堆分配的 rectangle（矩形）
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // 函数的输出可以装箱
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // 两层装箱
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box 的宽度就是指针宽度
    println!(&quot;Boxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // 将包含在 `boxed_point` 中的数据复制到 `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes in the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<h1><a class="header" href="#动态数组-vector" id="动态数组-vector">动态数组 vector</a></h1>
<p>vector 是大小可变的数组。和 slice（切片）类似，它们的大小在编译时是未知的，但它们可以随时扩大或缩小。一个 vector 使用 3 个词来表示：一个指向数据的指针，vector 的长度，还有它的容量。此容量指明了要为这个 vector 保留多少内存。vector 的长度只要小于该容量，就可以随意增长；当需要超过这个阈值时，会给 vector 重新分配一段更大的容量。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // 迭代器可以被收集到 vector 中
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // `vec!` 宏可用来初始化一个 vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // 在 vector 的尾部插入一个新的元素
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // 报错！不可变 vector 不可增长
    collected_iterator.push(0);
    // 改正 ^ 将此行注释掉

    // `len` 方法获得一个 vector 的当前大小
    println!(&quot;Vector size: {}&quot;, xs.len());

    // 下标使用中括号表示（从 0 开始）
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` 移除 vector 的最后一个元素并将它返回
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // 超出下标范围将抛出一个 panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // 改正 ^ 注释掉此行

    // 迭代一个 `Vector` 很容易
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // 可以在迭代 `Vector` 的同时，使用独立变量（`i`）来记录迭代次数
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // 多亏了 `iter_mut`，可变的 `Vector` 在迭代的同时，其中每个值都能被修改
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>更多 <code>Vec</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/vec/">std::vec</a> 模块中找到。</p>
<h1><a class="header" href="#字符串" id="字符串">字符串</a></h1>
<p>Rust 中有两种字符串类型：<code>String</code> 和 <code>&amp;str</code>。</p>
<p><code>String</code> 被存储为由字节组成的 vector（<code>Vec&lt;u8&gt;</code>），但保证了它一定是一个有效的
UTF-8 序列。<code>String</code> 是堆分配的，可增长的，且不是零结尾的（null terminated）。</p>
<p><code>&amp;str</code> 是一个总是指向有效 UTF-8 序列的切片（<code>&amp;[u8]</code>），并可用来查看 <code>String</code> 的内容，就如同 <code>&amp;[T]</code> 是 <code>Vec&lt;T&gt;</code> 的全部或部分引用。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // （所有的类型标注都不是必需的）
    // 一个对只读内存中分配的字符串的引用
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // 逆序迭代单词，这里并没有分配新的字符串
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // 复制字符到一个 vector，排序并移除重复值
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // 创建一个空的且可增长的 `String`
    let mut string = String::new();
    for c in chars {
        // 在字符串的尾部插入一个字符
        string.push(c);
        // 在字符串尾部插入一个字符串
        string.push_str(&quot;, &quot;);
    }

    // 这个缩短的字符串是原字符串的一个切片，所以没有执行新的分配操作
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // 堆分配一个字符串
    let alice = String::from(&quot;I like dogs&quot;);
    // 分配新内存并存储修改过的字符串
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>更多 <code>str</code>/<code>String</code> 方法可以在 <a href="https://rustwiki.org/zh-CN/std/str/">std::str</a> 和 <a href="https://rustwiki.org/zh-CN/std/string/">std::string</a> 模块中找到。</p>
<h2><a class="header" href="#字面量与转义字符" id="字面量与转义字符">字面量与转义字符</a></h2>
<p>书写含有特殊字符的字符串字面量有很多种方法。它们都会产生类似的 <code>&amp;str</code>，所以最好选择最方便的写法。类似地，字节串（byte string）字面量也有多种写法，它们都会产生
<code>&amp;[u8; N]</code> 类型。</p>
<p>通常特殊字符是使用反斜杠字符 <code>\</code> 来转义的，这样你就可以在字符串中写入各种各样的字符，甚至是不可打印的字符以及你不知道如何输入的字符。如果你需要反斜杠字符，再用另一个反斜杠来转义它就可以，像这样：<code>\\</code>。</p>
<p>字面量中出现的字符串或字符定界符必须转义：<code>&quot;\&quot;&quot;</code>、<code>'\''</code>。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // 通过转义，可以用十六进制值来表示字节。
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // 也可以使用 Unicode 码位表示。
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>有时会有太多需要转义的字符，或者是直接原样写出会更便利。这时可以使用原始字符串（raw string）。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // 如果你要在原始字符串中写引号，请在两边加一对 #
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // 如果字符串中需要写 &quot;#，那就在定界符中使用更多的 #。
    // 可使用的 # 的数目没有限制。
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>想要非 UTF-8 字符串（记住，<code>&amp;str</code> 和 <code>String</code> 都必须是合法的 UTF-8 序列），或者需要一个字节数组，其中大部分是文本？请使用字节串（byte string）！</p>
<pre><pre class="playground"><code class="language-rust editable">use std::str;

fn main() {
    // 注意这并不是一个 &amp;str
    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;

    // 字节串没有实现 Display，所以它们的打印功能有些受限
    println!(&quot;A bytestring: {:?}&quot;, bytestring);

    // 字节串可以使用单字节的转义字符...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...但不能使用 Unicode 转义字符
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // 原始字节串和原始字符串的写法一样
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // 把字节串转换为 &amp;str 可能失败
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // 字节串可以不使用 UTF-8 编码
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // SHIFT-JIS 编码的 &quot;ようこそ&quot;

    // 但这样的话它们就无法转换成 &amp;str 了
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}

</code></pre></pre>
<p>若需要在编码间转换，请使用 <a href="https://crates.io/crates/encoding">encoding</a> crate。</p>
<p>Rust 参考中的 <a href="https://rustwiki.org/zh-CN/reference/tokens.html">Tokens</a> 一章详细地列出了书写字符串字面量和转义字符的方法。</p>
<h1><a class="header" href="#选项-option" id="选项-option">选项 <code>Option</code></a></h1>
<p>有时候想要捕捉到程序某部分的失败信息，而不是调用 <code>panic!</code>；这可使用 <code>Option</code>
枚举类型来实现。</p>
<p><code>Option&lt;T&gt;</code> 有两个变量：</p>
<ul>
<li><code>None</code>，表明失败或缺少值</li>
<li><code>Some(value)</code>，元组结构体，封装了一个 <code>T</code> 类型的值 <code>value</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 不会 `panic!` 的整数除法。
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // 失败表示成 `None` 取值
        None
    } else {
        // 结果 Result 被包装到 `Some` 取值中
        Some(dividend / divisor)
    }
}

// 此函数处理可能失败的除法
fn try_division(dividend: i32, divisor: i32) {
    // `Option` 值可以进行模式匹配，就和其他枚举类型一样
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // 绑定 `None` 到一个变量需要类型标注
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // 解包 `Some` 将取出被包装的值。
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // 解包 `None` 将会引发 `panic!`。
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<h1><a class="header" href="#结果-result-1" id="结果-result-1">结果 <code>Result</code></a></h1>
<p>我们已经看到 <code>Option</code> 枚举类型可以用作可能失败的函数的返回值，其中返回 <code>None</code> 可以表明失败。但是有时要强调<strong>为什么</strong>一个操作会失败。为做到这点，我们提供了 <code>Result</code> 枚举类型。</p>
<p><code>Result&lt;T, E&gt;</code> 类型拥有两个取值：</p>
<ul>
<li><code>Ok(value)</code> 表示操作成功，并包装操作返回的 <code>value</code>（<code>value</code> 拥有 <code>T</code> 类型）。</li>
<li><code>Err(why)</code>，表示操作失败，并包装 <code>why</code>，它（但愿）能够解释失败的原因（<code>why</code> 拥有 <code>E</code> 类型）。</li>
</ul>
<pre><pre class="playground"><code class="language-rust editalbe ignore mdbook-runnable">mod checked {
    // 我们想要捕获的数学 “错误”
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NegativeLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // 此操作将会失败，那么（与其让程序崩溃）不如把失败的原因包装在
            // `Err` 中并返回
            Err(MathError::DivisionByZero)
        } else {
            // 此操作是有效的，返回包装在 `Ok` 中的结果
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // 这是一个三层的 match 金字塔！
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // 这会失败吗？
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<h1><a class="header" href="#-运算符" id="-运算符"><code>?</code> 运算符</a></h1>
<p>把 result 用 match 连接起来会显得很难看；幸运的是，<code>?</code> 运算符可以把这种逻辑变得干净漂亮。<code>?</code> 运算符用在返回值为 <code>Result</code> 的表达式后面，它等同于这样一个匹配表达式：其中 <code>Err(err)</code> 分支展开成提前返回的 <code>return Err(err)</code>，而 <code>Ok(ok)</code> 分支展开成 <code>ok</code> 表达式。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NegativeLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // 中间函数
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // 如果 `div` “失败” 了，那么返回 `DivisionByZero`
        let ratio = div(x, y)?;

        // 如果 `ln` “失败” 了，那么返回 `NegativeLogarithm`
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(&quot;{}&quot;,match why {
                MathError::NegativeLogarithm
                    =&gt; &quot;logarithm of negative number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>记得查阅<a href="https://rustwiki.org/zh-CN/std/result/index.html">文档</a>，里面有很多匹配/组合 <code>Result</code> 的方法。</p>
<h1><a class="header" href="#panic-1" id="panic-1"><code>panic!</code></a></h1>
<p><code>panic!</code> 宏可用于产生一个 panic （恐慌），并开始回退（unwind）它的栈。在回退栈的同时，运行时将会释放该线程所<strong>拥有</strong>的所有资源，这是通过调用线程中所有对象的析构函数完成的。</p>
<p>因为我们正在处理的程序只有一个线程，<code>panic!</code> 将会引发程序报告 panic 消息并退出。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">// 整型除法（/）的重新实现
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // 除以 0 会引发 panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// `main` 任务
fn main() {
    // 堆分配的整数
    let _x = Box::new(0i32);

    // 此操作将会引发一个任务失败
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` 应当会在此处被销毁
}
</code></pre></pre>
<p>可以看到，<code>panic!</code> 不会泄露内存：</p>
<pre><code class="language-bash">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h1><a class="header" href="#散列表-hashmap" id="散列表-hashmap">散列表 HashMap</a></h1>
<p>vector 通过整型下标来存储值，而 <code>HashMap</code>（散列表）通过键（key）来存储值。<code>HashMap</code> 的键可以是布尔型、整型、字符串，或任意实现了 <code>Eq</code> 和 <code>Hash</code> trait 的其他类型。在下一节将进一步介绍。</p>
<p>和 vector 类似，<code>HashMap</code> 也是可增长的，但 HashMap 在占据了多余空间时还可以缩小自己。可以使用 <code>HashMap::with_capacity(unit)</code> 创建具有一定初始容量的 HashMap，也可以使用 <code>HashMap::new()</code> 来获得一个带有默认初始容量的 HashMap（这是推荐方式）。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // 接受一个引用并返回 Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`，
    // 否则返回 `Some(value)`
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;(&quot;Ashley&quot;)); 

    // `HashMap::iter()` 返回一个迭代器，该迭代器以任意顺序举出
    // (&amp;'a key, &amp;'a value) 对。
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>想要了解更多关于散列（hash）与散列表（hash map）（有时也称作 hash table）的工作原理，可以查看 Wikipedia 的<a href="https://en.wikipedia.org/wiki/Hash_table">散列表</a>词条。</p>
<h1><a class="header" href="#更改或自定义关键字类型" id="更改或自定义关键字类型">更改或自定义关键字类型</a></h1>
<p>任何实现了 <code>Eq</code> 和 <code>Hash</code> trait 的类型都可以充当 <code>HashMap</code> 的键。这包括：</p>
<ul>
<li><code>bool</code> （当然这个用处不大，因为只有两个可能的键）</li>
<li><code>int</code>，<code>unit</code>，以及其他整数类型</li>
<li><code>String</code> 和 <code>&amp;str</code>（友情提示：如果使用 <code>String</code> 作为键来创建 <code>HashMap</code>，则可以
将 <code>&amp;str</code> 作为散列表的 <code>.get()</code> 方法的参数，以获取值）</li>
</ul>
<p>注意到 <code>f32</code> 和 <code>f64</code> <strong>没有</strong>实现 <code>Hash</code>，这很大程度上是由于若使用浮点数作为散列表的键，<a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">浮点精度误差</a>会很容易导致错误。</p>
<p>对于所有的集合类（collection class），如果它们包含的类型都分别实现了 <code>Eq</code>
和 <code>Hash</code>，那么这些集合类也就实现了 <code>Eq</code> 和 <code>Hash</code>。例如，若 <code>T</code> 实现了
<code>Hash</code>，则 <code>Vec&lt;T&gt;</code> 也实现了 <code>Hash</code>。</p>
<p>对自定义类型可以轻松地实现 <code>Eq</code> 和 <code>Hash</code>，只需加上一行代码：<code>#[derive(PartialEq, Eq, Hash)]</code>。</p>
<p>编译器将会完成余下的工作。如果你想控制更多的细节，你可以手动实现 <code>Eq</code> 和/或 <code>Hash</code>。本指南不包含实现 <code>Hash</code> 的细节内容。</p>
<p>为了试验 <code>HashMap</code> 中的 <code>struct</code>，让我们试着做一个非常简易的用户登录系统：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::collections::HashMap;

// Eq 要求你对此类型推导 PartiaEq。
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#散列集-hashset" id="散列集-hashset">散列集 HashSet</a></h1>
<p>请把 <code>HashSet</code> 当成这样一个 <code>HashMap</code>：我们只关心其中的键而非值（<code>HashSet&lt;T&gt;</code>
实际上只是对 <code>HashMap&lt;T, ()&gt;</code> 的封装）。</p>
<p>你可能会问：“这有什么意义呢？我完全可以将键存储到一个 <code>Vec</code> 中呀。”</p>
<p><code>HashSet</code> 的独特之处在于，它保证了不会出现重复的元素。这是任何 set 集合类型（set
collection）遵循的规定。<code>HashSet</code> 只是它的一个实现。（参见：<a href="https://rustwiki.org/zh-CN/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>）</p>
<p>如果插入的值已经存在于 <code>HashSet</code> 中（也就是，新值等于已存在的值，并且拥有相同的散列值），那么新值将会替换旧的值。</p>
<p>如果你不想要一样东西出现多于一次，或者你要判断一样东西是不是已经存在，这种做法就很有用了。</p>
<p>不过集合（set）可以做更多的事。</p>
<p>集合（set）拥有 4 种基本操作（下面的调用全部都返回一个迭代器）：</p>
<ul>
<li>
<p><code>union</code>（并集）：获得两个集合中的所有元素（不含重复值）。</p>
</li>
<li>
<p><code>difference</code>（差集）：获取属于第一个集合而不属于第二集合的所有元素。</p>
</li>
<li>
<p><code>intersection</code>（交集）：获取同时属于两个集合的所有元素。</p>
</li>
<li>
<p><code>symmetric_difference</code>（对称差）：获取所有只属于其中一个集合，而不同时属于
两个集合的所有元素。</p>
</li>
</ul>
<p>在下面的例子中尝试使用这些操作。</p>
<pre><pre class="playground"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // 如果值已经存在，那么 `HashSet::insert()` 返回 false。
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // 改正 ^ 将此行注释掉。

    b.insert(5);

    // 若一个集合（collection）的元素类型实现了 `Debug`，那么该集合也就实现了 `Debug`。
    // 这通常将元素打印成这样的格式 `[elem1, elem2, ...]
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // 乱序打印 [1, 2, 3, 4, 5]。
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 这将会打印出 [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 乱序打印 [2, 3, 4]。
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 打印 [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>（例子改编自<a href="https://rustwiki.org/zh-CN/std/collections/struct.HashSet.html#method.difference">文档</a>。）</p>
<h1><a class="header" href="#引用计数-rc" id="引用计数-rc">引用计数 <code>Rc</code></a></h1>
<p>当需要多个所有权时，可以使用 <code>Rc</code>（引用计数，Reference Counting 缩写）。<code>Rc</code> 跟踪引用的数量，这相当于包裹在 <code>Rc</code> 值的所有者的数量.</p>
<p>每当克隆一个 <code>Rc</code> 时，<code>Rc</code> 的引用计数就会增加 1，而每当克隆得到的 <code>Rc</code> 退出作用域时，引用计数就会减少 1。当 <code>Rc</code> 的引用计数变为 0 时，这意味着已经没有所有者，<code>Rc</code> 和值两者都将被删除。</p>
<p>克隆 <code>Rc</code> 从不执行深拷贝。克隆只创建另一个指向包裹值的指针，并增加计数。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // 如果两者内部的值相等的话，则两个 `Rc` 相等。
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
                        
            // 我们可以直接使用值的方法
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // 报错！`rc_examples` 已经移入 `rc_a`。
    // 而且当 `rc_a` 被删时，`rc_examples` 也被一起删除。
    // println!(&quot;rc_examples: {}&quot;, rc_examples);
    // 试一试 ^ 注释掉此行代码
}
</code></pre></pre>
<h3><a class="header" href="#参见-64" id="参见-64">参见：</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/rc/index.html">std::rc</a> 和 <a href="https://rustwiki.org/zh-CN/std/sync/struct.Arc.html">std::sync::arc</a>。</p>
<h1><a class="header" href="#共享引用计数-arc" id="共享引用计数-arc">共享引用计数 Arc</a></h1>
<p>当线程之间所有权需要共享时，可以使用<code>Arc</code>（共享引用计数，Atomic Reference Counted 缩写）可以使用。这个结构通过 <code>Clone</code> 实现可以为内存堆中的值的位置创建一个引用指针，同时增加引用计数器。由于它在线程之间共享所有权，因此当指向某个值的最后一个引用指针退出作用域时，该变量将被删除。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Arc;
use std::thread;

fn main() {
    // 这个变量声明用来指定其值的地方。
    let apple = Arc::new(&quot;the same apple&quot;);

    for _ in 0..10 {
        // 这里没有数值说明，因为它是一个指向内存堆中引用的指针。
        let apple = Arc::clone(&amp;apple);

        thread::spawn(move || {
            // 由于使用了Arc，线程可以使用分配在 `Arc` 变量指针位置的值来生成。
            println!(&quot;{:?}&quot;, apple);
        });
    }
}

</code></pre></pre>
<h1><a class="header" href="#标准库更多介绍" id="标准库更多介绍">标准库更多介绍</a></h1>
<p>标准库也提供了很多其他类型来支持某些功能，例如：</p>
<ul>
<li>线程（Threads）</li>
<li>信道（Channels）</li>
<li>文件输入输出（File I/O）</li>
</ul>
<p>这些内容在<a href="primitives.html">原生类型</a>之外进行了有效扩充。</p>
<h3><a class="header" href="#参见-65" id="参见-65">参见：</a></h3>
<p><a href="primitives.html">原生类型</a> 和 <a href="https://rustwiki.org/zh-CN/std/">标准库类型</a></p>
<h1><a class="header" href="#线程" id="线程">线程</a></h1>
<p>Rust 通过 <code>spawn</code> 函数提供了创建本地操作系统（native OS）线程的机制，该函数的参数是一个通过值捕获变量的闭包（moving closure）。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// 这是主（`main`）线程
fn main() {
    // 提供一个 vector 来存放所创建的子线程（children）。
    let mut children = vec![];

    for i in 0..NTHREADS {
        // 启动（spin up）另一个线程
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i)
        }));
    }

    for child in children {
        // 等待线程结束。返回一个结果。
        let _ = child.join();
    }
}
</code></pre></pre>
<p>这些线程由操作系统调度（schedule）。</p>
<h1><a class="header" href="#测试实例map-reduce" id="测试实例map-reduce">测试实例：map-reduce</a></h1>
<p>Rust 使数据的并行化处理非常简单，在 Rust 中你无需面对并行处理的很多传统难题。</p>
<p>标准库提供了开箱即用的线程类型，把它和 Rust 的所有权概念与别名规则结合起来，可以自动地避免数据竞争（data race）。</p>
<p>当某状态对某线程是可见的，别名规则（即一个可变引用 XOR 一些只读引用。译注：XOR
是异或的意思，即「二者仅居其一」）就自动地避免了别的线程对它的操作。（当需要同步处理时，请使用 <code>Mutex</code> 或 <code>Channel</code> 这样的同步类型。）</p>
<p>在本例中，我们将会计算一堆数字中每一位的和。我们将把它们分成几块，放入不同的线程。每个线程会把自己那一块数字的每一位加起来，之后我们再把每个线程提供的结果再加起来。</p>
<p>注意到，虽然我们在线程之间传递了引用，但 Rust 理解我们是在传递只读的引用，因此不会发生数据竞争等不安全的事情。另外，因为我们把数据块 <code>move</code> 到了线程中，Rust
会保证数据存活至线程退出，因此不会产生悬挂指针。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

// 这是 `main` 线程
fn main() {

    // 这是我们要处理的数据。
    // 我们会通过线程实现 map-reduce 算法，从而计算每一位的和
    // 每个用空白符隔开的块都会分配给单独的线程来处理
    //
    // 试一试：插入空格，看看输出会怎样变化！
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // 创建一个向量，用于储存将要创建的子线程
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; 阶段
     *
     * 把数据分段，并进行初始化处理
     ************************************************************************/

    // 把数据分段，每段将会单独计算
    // 每段都是完整数据的一个引用（&amp;str）
    let chunked_data = data.split_whitespace();

    // 对分段的数据进行迭代。
    // .enumerate() 会把当前的迭代计数与被迭代的元素以元组 (index, element)
    // 的形式返回。接着立即使用 “解构赋值” 将该元组解构成两个变量，
    // `i` 和 `data_segment`。
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // 用单独的线程处理每一段数据
        //
        // spawn() 返回新线程的句柄（handle），我们必须拥有句柄，
        // 才能获取线程的返回值。
        //
        // 'move || -&gt; u32' 语法表示该闭包：
        // * 没有参数（'||'）
        // * 会获取所捕获变量的所有权（'move'）
        // * 返回无符号 32 位整数（'-&gt; u32'）
        //
        // Rust 可以根据闭包的内容推断出 '-&gt; u32'，所以我们可以不写它。
        //
        // 试一试：删除 'move'，看看会发生什么
        children.push(thread::spawn(move || -&gt; u32 {
            // 计算该段的每一位的和：
            let result = data_segment
                        // 对该段中的字符进行迭代..
                        .chars()
                        // ..把字符转成数字..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // ..对返回的数字类型的迭代器求和
                        .sum();

            // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中
            // 最后求值的表达式就是代码块的值。
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; 阶段
     *
     * 收集中间结果，得出最终结果
     ************************************************************************/

    // 把每个线程产生的中间结果收入一个新的向量中
    let mut intermediate_sums = vec![];
    for child in children {
        // 收集每个子线程的返回值
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // 把所有中间结果加起来，得到最终结果
    //
    // 我们用 “涡轮鱼” 写法 ::&lt;&gt; 来为 sum() 提供类型提示。
    //
    // 试一试：不使用涡轮鱼写法，而是显式地指定 intermediate_sums 的类型
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3><a class="header" href="#作业" id="作业">作业</a></h3>
<p>根据用户输入的数据来决定线程的数量是不明智的。如果用户输入的数据中有一大堆空格怎么办？我们<strong>真的</strong>想要创建 2000 个线程吗？</p>
<p>请修改程序，使得数据总是被分成有限数目的段，这个数目是由程序开头的静态常量决定的。</p>
<h3><a class="header" href="#参见-66" id="参见-66">参见:</a></h3>
<ul>
<li><a href="std_misc/threads/../threads.html">线程</a></li>
<li><a href="std_misc/threads/../../std/vec.html">向量</a>和<a href="std_misc/threads/../../trait/iter.html">迭代器</a></li>
<li><a href="std_misc/threads/../../fn/closures.html">闭包</a>、<a href="std_misc/threads/../../scope/move.html">移动</a>语义和<a href="https://rustwiki.org/zh-CN/book/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code>闭包</a></li>
<li><a href="https://rustwiki.org/zh-CN/book/ch18-03-pattern-syntax.html#%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC">解构</a>赋值</li>
<li>使用<a href="https://rustwiki.org/zh-CN/std/iter/trait.Iterator.html#method.collect">涡轮鱼写法</a>帮助类型推断</li>
<li><a href="std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://rustwiki.org/zh-CN/book/ch03-05-control-flow.html#%E4%BD%BF%E7%94%A8-loop-%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81">枚举类型</a></li>
</ul>
<h1><a class="header" href="#通道" id="通道">通道</a></h1>
<p>Rust 为线程之间的通信提供了异步的通道（<code>channel</code>）。通道允许两个端点之间信息的单向流动：<code>Sender</code>（发送端） 和 <code>Receiver</code>（接收端）。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // 通道有两个端点：`Sender&lt;T&gt;` 和 `Receiver&lt;T&gt;`，其中 `T` 是要发送
    // 的消息的类型（类型标注是可选的）
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();

    for id in 0..NTHREADS {
        // sender 端可被复制
        let thread_tx = tx.clone();

        // 每个线程都将通过通道来发送它的 id
        thread::spawn(move || {
            // 被创建的线程取得 `thread_tx` 的所有权
            // 每个线程都把消息放在通道的消息队列中
            thread_tx.send(id).unwrap();

            // 发送是一个非阻塞（non-blocking）操作，线程将在发送完消息后
            // 会立即继续进行
            println!(&quot;thread {} finished&quot;, id);
        });
    }

    // 所有消息都在此处被收集
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // `recv` 方法从通道中拿到一个消息
        // 若无可用消息的话，`recv` 将阻止当前线程
        ids.push(rx.recv());
    }

    // 显示消息被发送的次序
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<h1><a class="header" href="#路径" id="路径">路径</a></h1>
<p><code>Path</code> 结构体代表了底层文件系统的文件路径。<code>Path</code> 分为两种：<code>posix::Path</code>，针对类 UNIX 系统；以及 <code>windows::Path</code>，针对 Windows。prelude 会选择并输出符合平台类型的 <code>Path</code> 种类。</p>
<blockquote>
<p>译注：prelude 是 Rust 自动地在每个程序中导入的一些通用的东西，这样我们就不必每写
一个程序就手动导入一番。</p>
</blockquote>
<p><code>Path</code> 可从 <code>OsStr</code> 类型创建，并且它提供数种方法，用于获取路径指向的文件/目录的信息。</p>
<p>注意 <code>Path</code> 在内部并不是用 UTF-8 字符串表示的，而是存储为若干字节（<code>Vec&lt;u8&gt;</code>）的 vector。因此，将 <code>Path</code> 转化成 <code>&amp;str</code> 并非零开销的（free），且可能失败（因此它返回一个 <code>Option</code>）。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::path::Path;

fn main() {
    // 从 `&amp;'static str` 创建一个 `Path`
    let path = Path::new(&quot;.&quot;);

    // `display` 方法返回一个可显示（showable）的结构体
    let display = path.display();

    // `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // 将路径转换成一个字符串切片
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}
</code></pre></pre>
<p>记得看看其他的 <code>Path</code> 方法（<code>posix::Path</code> 或 <code>windows::Path</code> 的），还有 <code>Metadata</code> 结构体类型。</p>
<h3><a class="header" href="#参见-67" id="参见-67">参见</a></h3>
<p><a href="https://rustwiki.org/zh-CN/std/ffi/struct.OsStr.html">OsStr</a> 和 <a href="https://rustwiki.org/zh-CN/std/fs/struct.Metadata.html">Metadata</a>。</p>
<h1><a class="header" href="#文件输入输出io" id="文件输入输出io">文件输入输出（I/O）</a></h1>
<p><code>File</code> 结构体表示一个被打开的文件（它包裹了一个文件描述符），并赋予了对所表示的文件的读写能力。</p>
<p>由于在进行文件 I/O（输入/输出）操作时可能出现各种错误，因此 <code>File</code> 的所有方法都返回 <code>io::Result&lt;T&gt;</code> 类型，它是 <code>Result&lt;T, io::Error&gt;</code> 的别名。</p>
<p>这使得所有 I/O 操作的失败都变成<strong>显式的</strong>。借助这点，程序员可以看到所有的失败路径，并被鼓励主动地处理这些情形。</p>
<h1><a class="header" href="#打开文件-open" id="打开文件-open">打开文件 <code>open</code></a></h1>
<p><code>open</code> 静态方法能够以只读模式（read-only mode）打开一个文件。</p>
<p><code>File</code> 拥有资源，即文件描述符（file descriptor），它会在自身被 <code>drop</code> 时关闭文件。</p>
<pre><code class="language-rust editable ignore">use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 创建指向所需的文件的路径
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // 以只读方式打开路径，返回 `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // `io::Error` 的 `description` 方法返回一个描述错误的字符串。
        Err(why) =&gt; panic!(&quot;couldn't open {}: {:?}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // 读取文件内容到一个字符串，返回 `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {:?}&quot;, display, why),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` 离开作用域，并且 `hello.txt` 文件将被关闭。
}
</code></pre>
<p>下面是所希望的成功的输出：</p>
<pre><code class="language-bash">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>（我们鼓励您在不同的失败条件下测试前面的例子：hello.txt 不存在，或 hello.txt 不可读，等等。）</p>
<h1><a class="header" href="#创建文件-create" id="创建文件-create">创建文件 <code>create</code></a></h1>
<p><code>create</code> 静态方法以只写模式（write-only mode）打开一个文件。若文件已经存在，则旧内容将被销毁。否则，将创建一个新文件。</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;'static str =
&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // 以只写模式打开文件，返回 `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {:?}&quot;, display, why),
        Ok(file) =&gt; file,
    };

    // 将 `LOREM_IPSUM` 字符串写进 `file`，返回 `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!(&quot;couldn't write to {}: {:?}&quot;, display, why)
        },
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>下面是预期成功的输出：</p>
<pre><code class="language-bash">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>（和前面例子一样，我们鼓励你在失败条件下测试这个例子。）</p>
<p>还有一个更通用的 <code>open_mode</code> 方法，这能够以其他方式来来打开文件，如：read+write（读 + 写），追加（append），等等。</p>
<h1><a class="header" href="#读取行" id="读取行">读取行</a></h1>
<p>方法 <code>lines()</code> 在文件的行上返回一个迭代器。</p>
<p><code>File::open</code> 需要一个泛型 <code>AsRef&lt;Path&gt;</code>。这正是 <code>read_lines()</code> 期望的输入。</p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // 在生成输出之前，文件 `hosts` 必须存在于当前路径中
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // 使用迭代器，返回一个（可选）字符串
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }      
        }   
    }
}

// 输出包裹在 Result 中以允许匹配错误，
// 将迭代器返回给文件行的读取器（Reader）。
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>运行此程序将一行行将内容打印出来。</p>
<pre><code class="language-bash">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>这个过程比在内存中创建 <code>String</code> 更有效，特别是处理更大的文件。</p>
<h1><a class="header" href="#子进程" id="子进程">子进程</a></h1>
<p><code>process::Output</code> 结构体表示已结束的子进程（child process）的输出，而
<code>process::Command</code> 结构体是一个进程创建者（process builder）。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre></pre>
<p>（再试试上面的例子，给 <code>rustc</code> 命令传入一个错误的 flag）</p>
<h1><a class="header" href="#管道" id="管道">管道</a></h1>
<p><code>std::Child</code> 结构体代表了一个正在运行的子进程，它暴露了 <code>stdin</code>（标准输入），<code>stdout</code>（标准输出）和 <code>stderr</code>（标准错误）句柄，从而可以通过管道与所代表的进程交互。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // 启动 `wc` 命令
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {:?}&quot;, why),
        Ok(process) =&gt; process,
    };

    // 将字符串写入 `wc` 的 `stdin`。
    //
    // `stdin` 拥有 `Option&lt;ChildStdin&gt;` 类型，不过我们已经知道这个实例不为空值，
    // 因而可以直接 `unwrap 它。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {:?}&quot;, why),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // 因为 `stdin` 在上面调用后就不再存活，所以它被 `drop` 了，管道也被关闭。
    //
    // 这点非常重要，因为否则 `wc` 就不会开始处理我们刚刚发送的输入。

    // `stdout` 字段也拥有 `Option&lt;ChildStdout&gt;` 类型，所以必需解包。
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {:?}&quot;, why),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre></pre>
<h1><a class="header" href="#等待" id="等待">等待</a></h1>
<p>如果你想等待一个 <code>process::Child</code> 完成，就必须调用 <code>Child::wait</code>，这会返回一个 <code>process::ExitStatus</code>。</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
reached end of main
# `wait` keeps running for 5 seconds
# `sleep 5` command ends, and then our `wait` program finishes
</code></pre>
<h1><a class="header" href="#文件系统操作" id="文件系统操作">文件系统操作</a></h1>
<p><code>std::io::fs</code> 模块包含几个处理文件系统的函数。</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// `% cat path` 的简单实现
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// `% echo s &gt; path` 的简单实现
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// `% touch path` 的简单实现（忽略已存在的文件）
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // 创建一个目录，返回 `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // 前面的匹配可以用 `unwrap_or_else` 方法简化
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // 递归地创建一个目录，返回 `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // 创建一个符号链接，返回 `io::Resutl&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // 读取目录的内容，返回 `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // 删除一个文件，返回 `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // 移除一个空目录，返回 `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}
</code></pre>
<p>下面是所期望的成功的输出：</p>
<pre><code class="language-bash">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>且 <code>a</code> 目录的最终状态为：</p>
<pre><code class="language-text">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>另一种定义 <code>cat</code> 函数的方式是使用 <code>?</code> 标记：</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3><a class="header" href="#参见-68" id="参见-68">参见：</a></h3>
<p><a href="std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<h1><a class="header" href="#程序参数" id="程序参数">程序参数</a></h1>
<h2><a class="header" href="#标准库" id="标准库">标准库</a></h2>
<p>命令行参数可使用 <code>std::env::args</code> 进行接收，这将返回一个迭代器，该迭代器会对每个参数举出一个字符串。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // 第一个参数是调用本程序的路径
    println!(&quot;My path is {}.&quot;, args[0]);

    // 其余的参数是被传递给程序的命令行参数。
    // 请这样调用程序：
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2><a class="header" href="#crate-2" id="crate-2">crate</a></h2>
<p>另外，也有很多 crate 提供了编写命令行应用的额外功能。<a href="https://rust-lang-nursery.github.io/rust-cookbook/app.html#ex-clap-basic">Rust Cookbook</a> 展示了使用最流行的命令行参数 crate，即 <code>clap</code> 的最佳实践。</p>
<h1><a class="header" href="#参数解析" id="参数解析">参数解析</a></h1>
<p>可以用模式匹配来解析简单的参数：</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // 没有传入参数
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // 一个传入参数
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // 传入一条命令和一个参数
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // 解析数字
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    println!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // 解析命令
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    println!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // 所有其他情况
        _ =&gt; {
            // 显示帮助信息
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<h1><a class="header" href="#外部语言函数接口" id="外部语言函数接口">外部语言函数接口</a></h1>
<p>Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。外部语言函数必须在一个 <code>extern</code> 代码块中声明，且该代码块要带有一个包含库名称的 <code>#[link]</code> 属性。</p>
<pre><code class="language-rust ignore">use std::fmt;

// 这个 extern 代码块链接到 libm 库
#[link(name = &quot;m&quot;)]
extern {
    // 这个外部函数用于计算单精度复数的平方根
    fn csqrtf(z: Complex) -&gt; Complex;

    // 这个用来计算单精度复数的复变余弦
    fn ccosf(z: Complex) -&gt; Complex;
}

// 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // 调用外部语言函数是不安全操作
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // 调用不安全操作的安全的 API 封装
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// 单精度复数的最简实现
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<h1><a class="header" href="#测试-1" id="测试-1">测试</a></h1>
<p>Rust 是一门非常重视正确性的语言，这门语言本身就提供了对编写软件测试的支持。</p>
<p>测试有三种风格：</p>
<ul>
<li><a href="testing/unit_testing.html">单元</a>测试。</li>
<li><a href="testing/doc_testing.html">文档</a>测试。</li>
<li><a href="testing/integration_testing.html">集成</a>测试。</li>
</ul>
<p>Rust 也支持在测试中指定额外的依赖：</p>
<ul>
<li><a href="testing/dev_dependencies.html">开发依赖</a></li>
</ul>
<h2><a class="header" href="#参见-69" id="参见-69">参见</a></h2>
<ul>
<li><a href="https://rustwiki.org/zh-CN/book/second-edition/ch11-00-testing.html">TRPL</a> 中关于测试的章节</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API 指导原则</a>中关于文档测试的部分</li>
</ul>
<h1><a class="header" href="#单元测试" id="单元测试">单元测试</a></h1>
<p>测试（test）是这样一种 Rust 函数：它保证其他部分的代码按照所希望的行为正常运行。测试函数的函数体通常会进行一些配置，运行我们想要测试的代码，然后断言（assert）结果是不是我们所期望的。</p>
<p>大多数单元测试都会被放到一个叫 <code>tests</code> 的、带有 <code>#[cfg(test)]</code> 属性的<a href="testing/../mod.html">模块</a>中，测试函数要加上 <code>#[test]</code> 属性。</p>
<p>当测试函数中有什么东西 <a href="testing/../std/panic.html">panic</a> 了，测试就失败。有一些这方面的辅助<a href="testing/../macros.html">宏</a>：</p>
<ul>
<li><code>assert!(expression)</code> - 如果表达式的值是 <code>false</code> 则 panic。</li>
<li><code>assert_eq!(left, right)</code> 和 <code>assert_ne!(left, right)</code> - 检验左右两边是否
相等/不等。</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// 这个加法函数写得很差，本例中我们会使它失败。
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // 这个断言会导致测试失败。注意私有的函数也可以被测试！
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>可以使用 <code>cargo test</code> 来运行测试。</p>
<pre><code class="language-bash">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#测试-panic" id="测试-panic">测试 panic</a></h2>
<p>一些函数应当在特定条件下 panic。为测试这种行为，请使用 <code>#[should_panic]</code> 属性。这个属性接受可选参数 <code>expected = </code> 以指定 panic 时的消息。如果你的函数能以多种方式
panic，这个属性就保证了你在测试的确实是所指定的 panic。</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>运行这些测试会输出：</p>
<pre><code class="language-bash">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#运行特定的测试" id="运行特定的测试">运行特定的测试</a></h2>
<p>要运行特定的测试，只要把测试名称传给 <code>cargo test</code> 命令就可以了。</p>
<pre><code class="language-bash">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>要运行多个测试，可以仅指定测试名称中的一部分，用它来匹配所有要运行的测试。</p>
<pre><code class="language-bash">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#忽略测试" id="忽略测试">忽略测试</a></h2>
<p>可以把属性 <code>#[ignore]</code> 赋予测试以排除某些测试，或者使用 <code>cargo test -- --ignored</code>
命令来运行它们。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ cargo test
running 1 test
test tests::ignored_test ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#文档测试" id="文档测试">文档测试</a></h1>
<p>为 Rust 工程编写文档的主要方式是在源代码中写注释。文档注释使用 <a href="https://daringfireball.net/projects/markdown/">markdown</a> 语法书写，支持代码块。Rust 很注重正确性，这些注释中的代码块也会被编译并且用作测试。</p>
<pre><code class="language-rust ignore">/// 第一行是对函数的简短描述。
///
/// 接下来数行是详细文档。代码块用三个反引号开启，Rust 会隐式地在其中添加
/// `fn main()` 和 `extern crate &lt;cratename&gt;`。比如测试 `doccomments` crate：
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// 文档注释通常可能带有 &quot;Examples&quot;、&quot;Panics&quot; 和 &quot;Failures&quot; 这些部分。
///
/// 下面的函数将两数相除。
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// 如果第二个参数是 0，函数将会 panic。
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>这些测试仍然可以通过 <code>cargo test</code> 执行：</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#文档测试的目的" id="文档测试的目的">文档测试的目的</a></h2>
<p>文档测试的主要目的是作为使用函数功能的例子，这是最重要的<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">指导原则</a>之一。文档测试应当可以作为完整的代码段被直接使用（很多用户会复制文档中的代码来用，所以例子要写得完善）。但使用 <code>?</code> 符号会导致编译失败，因为 <code>main</code> 函数会返回 <code>unit</code> 类型。幸运的是，我们可以在文档中隐藏几行源代码：你可以写 <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code> 这样的函数，把它隐藏起来，然后在隐藏的 <code>main</code> 中展开它。听起来很复杂？请看例子：</p>
<pre><code class="language-rust ignore">/// 在文档测试中使用隐藏的 `try_main`。
///
/// ```
/// # // 被隐藏的行以 `#` 开始，但它们仍然会被编译！
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // 隐藏行包围了文档中显示的函数体
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // 从 try_main 返回
/// # }
/// # fn main() { // 开始主函数，其中将展开 `try_main` 函数
/// #    try_main().unwrap(); // 调用并展开 try_main，这样出错时测试会 panic
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2><a class="header" href="#参见-70" id="参见-70">参见</a></h2>
<ul>
<li>关于文档风格的 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a></li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API 指导原则</a>中关于文档的原则</li>
</ul>
<h1><a class="header" href="#集成测试" id="集成测试">集成测试</a></h1>
<p><a href="testing/unit_testing.html">单元测试</a>一次仅能单独测试一个模块，这种测试是小规模的，并且能测试私有代码；集成测试是 crate 外部的测试，并且仅使用 crate 的公共接口，就像其他使用该 crate 的程序那样。集成测试的目的是检验你的库的各部分是否能够正确地协同工作。</p>
<p>cargo 在与 <code>src</code> 同级别的 <code>tests</code> 目录寻找集成测试。</p>
<p>文件 <code>src/lib.rs</code>：</p>
<pre><code class="language-rust ignore">// 在一个叫做 'adder' 的 crate 中定义此函数。
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>包含测试的文件：<code>tests/integration_test.rs</code>：</p>
<pre><code class="language-rust ignore">
#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>使用 <code>cargo test</code> 命令：</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><code>tests</code> 目录中的每一个 Rust 源文件都被编译成一个单独的 crate。在集成测试中要想共享代码，一种方式是创建具有公用函数的模块，然后在测试中导入并使用它。</p>
<p>文件 <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // 一些配置代码，比如创建文件/目录，开启服务器等等。
}
</code></pre>
<p>包含测试的文件：<code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// 导入共用模块。
mod common;

#[test]
fn test_add() {
    // 使用共用模块。
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>带有共用代码的模块遵循和普通的<a href="testing/../mod.html">模块</a>一样的规则，所以完全可以把公共模块写在 <code>tests/common/mod.rs</code> 文件中。</p>
<h1><a class="header" href="#开发依赖" id="开发依赖">开发依赖</a></h1>
<p>有时仅在测试中才需要一些依赖（比如基准测试相关的）。这种依赖要写在 <code>Cargo.toml</code>
的 <code>[dev-dependencies]</code> 部分。这些依赖不会传播给其他依赖于这个包的包。</p>
<p>比如说使用 <code>pretty_assertions</code>，这是扩展了标准的 <code>assert!</code> 宏的一个 crate。</p>
<p>文件 <code>Cargo.toml</code>:</p>
<pre><code class="language-ignore"># 这里省略了标准的 crate 数据
[dev-dependencies]
pretty_assertions = &quot;1&quot;
</code></pre>
<p>文件 <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq; // 仅用于测试, 不能在非测试代码中使用

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2><a class="header" href="#参见-71" id="参见-71">参见</a></h2>
<p><a href="https://doc.crates.io/specifying-dependencies.html">Cargo</a> 文档中关于指定依赖的部分。</p>
<h1><a class="header" href="#不安全操作" id="不安全操作">不安全操作</a></h1>
<p>在本章一开始，我们借用<a href="unsafe">官方文档</a>的一句话，“在整个代码库（code base，指构建一个软件系统所使用的全部代码）中，要尽可能减少不安全代码的量”。记住这句话，接着我们进入学习！在 Rust 中，不安全代码块用于避开编译器的保护策略；具体地说，不安全代码块主要用于四件事情：</p>
<ul>
<li>解引用裸指针</li>
<li>通过 FFI 调用函数（这已经在<a href="std_misc/ffi.html">之前的章节</a>介绍过了）</li>
<li>调用不安全的函数</li>
<li>内联汇编（inline assembly）</li>
</ul>
<h3><a class="header" href="#原始指针" id="原始指针">原始指针</a></h3>
<p>原始指针（raw pointer，裸指针）<code>*</code> 和引用 <code>&amp;T</code> 有类似的功能，但引用总是安全的，因为借用检查器保证了它指向一个有效的数据。解引用一个裸指针只能通过不安全代码块执行。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3><a class="header" href="#调用不安全函数" id="调用不安全函数">调用不安全函数</a></h3>
<p>一些函数可以声明为不安全的（<code>unsafe</code>），这意味着在使用它时保证正确性不再是编译器的责任，而是程序员的。一个例子就是 <a href="https://rustwiki.org/zh-CN/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a>，向它传入指向第一个元素的指针和长度参数，它会创建一个切片。</p>
<pre><pre class="playground"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);
        
        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p><code>slice::from_raw_parts</code> 假设传入的指针指向有效的内存，且被指向的内存具有正确的数据类型，我们<strong>必须</strong>满足这一假设，否则程序的行为是未定义的（undefined），于是我们就不能预测会发生些什么了。</p>
<h1><a class="header" href="#兼容性" id="兼容性">兼容性</a></h1>
<p>Rust 语言正在快速发展，因此尽管努力确保尽可能向前兼容，但仍可能出现某些兼容性问题。</p>
<ul>
<li><a href="compatibility/raw_identifiers.html">原始标识符</a></li>
</ul>
<h1><a class="header" href="#原始标志符" id="原始标志符">原始标志符</a></h1>
<p>与许多编程语言一样，Rust 拥有“关键字”的概念。 这些标识符对语言有特定意义，所以不能在变量名、函数名和其他位置使用它们。 原始标识符允许你使用通常不允许的关键字。 当 Rust 引入新关键字时，使用旧版 Rust 的库拥有与新版本中引入的关键字同名的变量或函数，这一点就特别有用。</p>
<p>举个例子，使用 2015 版 Rust 编译的 crate <code>foo</code>，它导出一个名为 <code>try</code> 的函数。 此关键字（<em>try</em>）在 2018 版本的新功能中保留下来，因此如果没有原始标识符，我们将无法命名该功能。</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>将得到如下错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>使用原始标志符重写上述代码：</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<h1><a class="header" href="#补充" id="补充">补充</a></h1>
<p>在软件工程中，有些主题和写程序并没有直接的关联，但它们为你提供了工具和基础设施支持，使得软件对每个人都变得更易用。这些主题包括：</p>
<ul>
<li>文档：通过附带的 <code>rustdoc</code> 生成库文档给用户。</li>
<li>测试：为库创建测试套件，确保库准确地实现了你想要的功能。</li>
<li>基准测试（benchmark）：对功能进行基准测试，保证其运行速度足够快。</li>
</ul>
<h1><a class="header" href="#文档" id="文档">文档</a></h1>
<p>用 <code>cargo doc</code> 构建文档到 <code>target/doc</code>。</p>
<p>用 <code>cargo test</code> 运行所有测试（包括文档测试），用 <code>cargo test --doc</code> 仅运行文档测试。</p>
<p>这些命令会恰当地按需调用 <code>rustdoc</code>（以及 <code>rustc</code>）。</p>
<h2><a class="header" href="#文档注释" id="文档注释">文档注释</a></h2>
<p>文档注释对于需要文档的大型项目来说非常重要。当运行 <code>rustdoc</code>，文档注释就会编译成文档。它们使用 <code>///</code> 标记，并支持 <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>。</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// 这里给出一个“人”的表示
pub struct Person {
    /// 一个人必须有名字（不管 Juliet 多讨厌她自己的名字）。
    name: String,
}

impl Person {
    /// 返回具有指定名字的一个人
    ///
    /// # 参数
    ///
    /// * `name` - 字符串切片，代表人的名字
    ///
    /// # 示例
    ///
    /// ```
    /// // 在文档注释中，你可以书写代码块
    /// // 如果向 `rustdoc` 传递 --test 参数，它还会帮你测试注释文档中的代码！
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// 给一个友好的问候！
    /// 对被叫到的 `Person` 说 &quot;Hello, [name]&quot; 。
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>要运行测试，首先将代码构建为库，然后告诉 <code>rustdoc</code> 在哪里找到库，这样它就可以使每个文档中的程序链接到库：</p>
<pre><code class="language-shell">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h2><a class="header" href="#文档属性" id="文档属性">文档属性</a></h2>
<p>下面是一些使用 <code>rustdoc</code> 时最常使用的 <code>#[doc]</code> 属性的例子。</p>
<h3><a class="header" href="#inline" id="inline"><code>inline</code></a></h3>
<p>用于内联文档，而不是链接到单独的页面。</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;

/// bar 的文档
mod bar {
    /// Bar 的文档
    pub struct Bar;
}
</code></pre>
<h3><a class="header" href="#no_inline" id="no_inline"><code>no_inline</code></a></h3>
<p>用于防止链接到单独的页面或其他位置。</p>
<pre><code class="language-rust ignore">// 来自 libcore/prelude 的例子
#[doc(no_inline)]
pub use crate::mem::drop;
</code></pre>
<h3><a class="header" href="#hidden" id="hidden"><code>hidden</code></a></h3>
<p>使用此属性来告诉 <code>rustdoc</code> 不要包含此项到文档中：</p>
<pre><code class="language-rust editable ignore">// 来自 futures-rs 库的例子
#[doc(hidden)]
pub use self::async_await::*;
</code></pre>
<p>对文档来说，<code>rustdoc</code> 被社区广泛采用。<a href="https://doc.rust-lang.org/std/">标准库文档</a>也是用它生成的。</p>
<h3><a class="header" href="#参见-72" id="参见-72">参见:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<h1><a class="header" href="#playpen" id="playpen">Playpen</a></h1>
<p><a href="https://github.com/rust-lang/rust-playpen">Rust Playpen</a> 是一个在线运行 Rust 代码的网络接口。现在该项目通常称为 <a href="https://play.rust-lang.org/">Rust Playground</a>。</p>
<h2><a class="header" href="#在-mdbook-使用" id="在-mdbook-使用">在 <code>mdbook</code> 使用</a></h2>
<p>在 <a href="https://github.com/rust-lang/mdBook"><code>mdbook</code></a> 中，你可以让示例代码运行和编辑。</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>这使读者既可以运行你的代码示例，也可以对其进行修改和调整。此处的关键是将单词添加 <code>editable</code> 到代码块中，并用逗号分隔。</p>
<pre><code class="language-markdown">```rust,editable
//...将你的代码写在这里
```
</code></pre>
<p>此外，如果想要 <code>mdbook</code> 在构建和测试时跳过该代码，则可以添加 <code>ignore</code>。</p>
<pre><code class="language-markdown">```rust,editable,ignore
//...将你的代码写在这里
```
</code></pre>
<h2><a class="header" href="#在文档中使用" id="在文档中使用">在文档中使用</a></h2>
<p>可能你已经在某些 <a href="https://rustwiki.org/zh-CN/core/">Rust 官方文档</a>中注意到了一个名为 “Run” 的按钮，该按钮在 Rust Playground 的新选项卡中打开了代码示例。如果使用名为的 <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html#html_playground_url"><code>html_playground_url</code></a> 的 #[doc] 属性，则启用此功能。</p>
<h3><a class="header" href="#参见-73" id="参见-73">参见：</a></h3>
<ul>
<li><a href="https://play.rust-lang.org/">The Rust Playground</a></li>
<li><a href="https://github.com/integer32llc/rust-playground/">下一代 playpen</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">官方文档</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="language.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
