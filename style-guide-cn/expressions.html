<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>表达式 - Rust 语言风格指南 中文版</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">1.</strong> 程序项</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">2.</strong> 语句</a></li><li class="chapter-item expanded "><a href="expressions.html" class="active"><strong aria-hidden="true">3.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">4.</strong> 类型和约束</a></li><li class="chapter-item expanded "><a href="advice.html"><strong aria-hidden="true">5.</strong> 其他风格建议</a></li><li class="chapter-item expanded "><a href="cargo.html"><strong aria-hidden="true">6.</strong> Cargo.toml 的约定</a></li><li class="chapter-item expanded "><a href="principles.html"><strong aria-hidden="true">7.</strong> 指导原则和基本原理</a></li><li class="chapter-item expanded "><a href="nightly.html"><strong aria-hidden="true">8.</strong> 开发版特定语法</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 语言风格指南 中文版</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rust-lang-cn/style-guide-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#表达式" id="表达式">表达式</a></h1>
<h2><a class="header" href="#块" id="块">块</a></h2>
<p>块表达式必须在首行 <code>{</code> 后和末行 <code>}</code> 前加换行符，除非根据其他样式规则可以写成单行。</p>
<p>代码块前的关键字（如 <code>unsafe</code> 或 <code>async</code>）必须与开头的括号在同一行，关键字与开头的括号之间用一个空格隔开。缩进代码块的内容。</p>
<pre><code class="language-rust ignore">fn block_as_stmt() {
    a_call();

    {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}

fn block_as_expr() {
    let foo = {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    };
}

fn unsafe_block_as_stmt() {
    a_call();

    unsafe {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}
</code></pre>
<p>If a block has an attribute, put it on its own line before the block:</p>
<pre><code class="language-rust ignore">fn block_as_stmt() {
    #[an_attribute]
    {
        #![an_inner_attribute]

        // a comment in a block
        the_value
    }
}
</code></pre>
<p>Avoid writing comments on the same lines as either of the braces.</p>
<p>Write an empty block as <code>{}</code>.</p>
<p>Write a block on a single line if:</p>
<ul>
<li>it is either used in expression position (not statement position) or is an
unsafe block in statement position,</li>
<li>it contains a single-line expression and no statements, and</li>
<li>it contains no comments</li>
</ul>
<p>For a single-line block, put spaces after the opening brace and before the
closing brace.</p>
<p>Examples:</p>
<pre><code class="language-rust ignore">fn main() {
    // Single line
    let _ = { a_call() };
    let _ = unsafe { a_call() };

    // Not allowed on one line
    // Statement position.
    {
        a_call()
    }

    // Contains a statement
    let _ = {
        a_call();
    };
    unsafe {
        a_call();
    }

    // Contains a comment
    let _ = {
        // A comment
    };
    let _ = {
        // A comment
        a_call()
    };

    // Multiple lines
    let _ = {
        a_call();
        another_call()
    };
    let _ = {
        a_call(
            an_argument,
            another_arg,
        )
    };
}
</code></pre>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Don't put any extra spaces before the first <code>|</code> (unless the closure is prefixed
by a keyword such as <code>move</code>); put a space between the second <code>|</code> and the
expression of the closure. Between the <code>|</code>s, use function definition syntax,
but elide types where possible.</p>
<p>Use closures without the enclosing <code>{}</code>, if possible. Add the <code>{}</code> when you have
a return type, when there are statements, when there are comments inside the
closure, or when the body expression is a control-flow expression that spans
multiple lines. If using braces, follow the rules above for blocks. Examples:</p>
<pre><code class="language-rust ignore">|arg1, arg2| expr

move |arg1: i32, arg2: i32| -&gt; i32 {
    expr1;
    expr2
}

|| Foo {
    field1,
    field2: 0,
}

|| {
    if true {
        blah
    } else {
        boo
    }
}

|x| unsafe {
    expr
}
</code></pre>
<h2><a class="header" href="#struct-literals" id="struct-literals">Struct literals</a></h2>
<p>If a struct literal is <em>small</em>, format it on a single line, and do not use a
trailing comma. If not, split it across multiple lines, with each field on its
own block-indented line, and use a trailing comma.</p>
<p>For each <code>field: value</code> entry, put a space after the colon only.</p>
<p>Put a space before the opening brace. In the single-line form, put spaces after
the opening brace and before the closing brace.</p>
<pre><code class="language-rust ignore">Foo { field1, field2: 0 }
let f = Foo {
    field1,
    field2: an_expr,
};
</code></pre>
<p>Functional record update syntax is treated like a field, but it must never have
a trailing comma. Do not put a space after <code>..</code>.</p>
<pre><code class="language-rust ignore">let f = Foo {
    field1,
    ..an_expr
};
</code></pre>
<h2><a class="header" href="#tuple-literals" id="tuple-literals">Tuple literals</a></h2>
<p>Use a single-line form where possible. Do not put spaces between the opening
parenthesis and the first element, or between the last element and the closing
parenthesis. Separate elements with a comma followed by a space.</p>
<p>Where a single-line form is not possible, write the tuple across
multiple lines, with each element of the tuple on its own block-indented line,
and use a trailing comma.</p>
<pre><code class="language-rust ignore">(a, b, c)

let x = (
    a_long_expr,
    another_very_long_expr,
);
</code></pre>
<h2><a class="header" href="#tuple-struct-literals" id="tuple-struct-literals">Tuple struct literals</a></h2>
<p>Do not put space between the identifier and the opening parenthesis. Otherwise,
follow the rules for tuple literals:</p>
<pre><code class="language-rust ignore">Foo(a, b, c)

let x = Foo(
    a_long_expr,
    another_very_long_expr,
);
</code></pre>
<h2><a class="header" href="#enum-literals" id="enum-literals">Enum literals</a></h2>
<p>Follow the formatting rules for the various struct literals. Prefer using the
name of the enum as a qualifying name, unless the enum is in the prelude:</p>
<pre><code class="language-rust ignore">Foo::Bar(a, b)
Foo::Baz {
    field1,
    field2: 1001,
}
Ok(an_expr)
</code></pre>
<h2><a class="header" href="#array-literals" id="array-literals">Array literals</a></h2>
<p>Write small array literals on a single line. Do not put spaces between the opening
square bracket and the first element, or between the last element and the closing
square bracket. Separate elements with a comma followed by a space.</p>
<p>If using the repeating initializer, put a space after the semicolon
only.</p>
<p>Apply the same rules if using <code>vec!</code> or similar array-like macros; always use
square brackets with such macros. Examples:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = [1, 2, 3];
    let y = vec![a, b, c, d];
    let a = [42; 10];
}
</code></pre>
<p>For arrays that have to be broken across lines, if using the repeating
initializer, break after the <code>;</code>, not before. Otherwise, follow the rules below
for function calls. In any case, block-indent the contents of the initializer,
and put line breaks after the opening square bracket and before the closing
square bracket:</p>
<pre><code class="language-rust ignore">fn main() {
    [
        a_long_expression();
        1234567890
    ]
    let x = [
        an_expression,
        another_expression,
        a_third_expression,
    ];
}
</code></pre>
<h2><a class="header" href="#array-accesses-indexing-and-slicing" id="array-accesses-indexing-and-slicing">Array accesses, indexing, and slicing.</a></h2>
<p>Don't put spaces around the square brackets. Avoid breaking lines if possible.
Never break a line between the target expression and the opening square
bracket. If the indexing expression must be broken onto a subsequent line, or
spans multiple lines itself, then block-indent the indexing expression, and put
newlines after the opening square bracket and before the closing square
bracket:</p>
<p>Examples:</p>
<pre><code class="language-rust ignore">fn main() {
    foo[42];
    &amp;foo[..10];
    bar[0..100];
    foo[4 + 5 / bar];
    a_long_target[
        a_long_indexing_expression
    ];
}
</code></pre>
<h2><a class="header" href="#unary-operations" id="unary-operations">Unary operations</a></h2>
<p>Do not include a space between a unary op and its operand (i.e., <code>!x</code>, not
<code>! x</code>). However, there must be a space after <code>&amp;mut</code>. Avoid line-breaking
between a unary operator and its operand.</p>
<h2><a class="header" href="#binary-operations" id="binary-operations">Binary operations</a></h2>
<p>Do include spaces around binary ops (i.e., <code>x + 1</code>, not <code>x+1</code>) (including <code>=</code>
and other assignment operators such as <code>+=</code> or <code>*=</code>).</p>
<p>For comparison operators, because for <code>T op U</code>, <code>&amp;T op &amp;U</code> is also implemented:
if you have <code>t: &amp;T</code>, and <code>u: U</code>, prefer <code>*t op u</code> to <code>t op &amp;u</code>. In general,
within expressions, prefer dereferencing to taking references, unless necessary
(e.g. to avoid an unnecessarily expensive operation).</p>
<p>Use parentheses liberally; do not necessarily elide them due to precedence.
Tools should not automatically insert or remove parentheses. Do not use spaces
to indicate precedence.</p>
<p>If line-breaking, block-indent each subsequent line. For assignment operators,
break after the operator; for all other operators, put the operator on the
subsequent line. Put each sub-expression on its own line:</p>
<pre><code class="language-rust ignore">foo_bar
    + bar
    + baz
    + qux
    + whatever
</code></pre>
<p>Prefer line-breaking at an assignment operator (either <code>=</code> or <code>+=</code>, etc.) rather
than at other binary operators.</p>
<h2><a class="header" href="#control-flow" id="control-flow">Control flow</a></h2>
<p>Do not include extraneous parentheses for <code>if</code> and <code>while</code> expressions.</p>
<pre><code class="language-rust ignore">if true {
}
</code></pre>
<p>is better than</p>
<pre><code class="language-rust ignore">if (true) {
}
</code></pre>
<p>Do include extraneous parentheses if it makes an arithmetic or logic expression
easier to understand (<code>(x * 15) + (y * 20)</code> is fine)</p>
<h2><a class="header" href="#function-calls" id="function-calls">Function calls</a></h2>
<p>Do not put a space between the function name, and the opening parenthesis.</p>
<p>Do not put a space between an argument, and the comma which follows.</p>
<p>Do put a space between an argument, and the comma which precedes it.</p>
<p>Prefer not to break a line in the callee expression.</p>
<h3><a class="header" href="#single-line-calls" id="single-line-calls">Single-line calls</a></h3>
<p>Do not put a space between the function name and open paren, between the open
paren and the first argument, or between the last argument and the close paren.</p>
<p>Do not put a comma after the last argument.</p>
<pre><code class="language-rust ignore">foo(x, y, z)
</code></pre>
<h3><a class="header" href="#multi-line-calls" id="multi-line-calls">Multi-line calls</a></h3>
<p>If the function call is not <em>small</em>, it would otherwise over-run the max width,
or any argument or the callee is multi-line, then format the call across
multiple lines. In this case, put each argument on its own block-indented line,
break after the opening parenthesis and before the closing parenthesis,
and use a trailing comma:</p>
<pre><code class="language-rust ignore">a_function_call(
    arg1,
    a_nested_call(a, b),
)
</code></pre>
<h2><a class="header" href="#method-calls" id="method-calls">Method calls</a></h2>
<p>Follow the function rules for calling.</p>
<p>Do not put any spaces around the <code>.</code>.</p>
<pre><code class="language-rust ignore">x.foo().bar().baz(x, y, z);
</code></pre>
<h2><a class="header" href="#macro-uses" id="macro-uses">Macro uses</a></h2>
<p>If a macro can be parsed like other constructs, format it like those
constructs. For example, a macro use <code>foo!(a, b, c)</code> can be parsed like a
function call (ignoring the <code>!</code>), so format it using the rules for function
calls.</p>
<h3><a class="header" href="#special-case-macros" id="special-case-macros">Special case macros</a></h3>
<p>For macros which take a format string, if all other arguments are <em>small</em>,
format the arguments before the format string on a single line if they fit, and
format the arguments after the format string on a single line if they fit, with
the format string on its own line. If the arguments are not small or do not
fit, put each on its own line as with a function. For example:</p>
<pre><code class="language-rust ignore">println!(
    &quot;Hello {} and {}&quot;,
    name1, name2,
);

assert_eq!(
    x, y,
    &quot;x and y were not equal, see {}&quot;,
    reason,
);
</code></pre>
<h2><a class="header" href="#casts-as" id="casts-as">Casts (<code>as</code>)</a></h2>
<p>Put spaces before and after <code>as</code>:</p>
<pre><code class="language-rust ignore">let cstr = &quot;Hi\0&quot; as *const str as *const [u8] as *const std::os::raw::c_char;
</code></pre>
<h2><a class="header" href="#chains-of-fields-and-method-calls" id="chains-of-fields-and-method-calls">Chains of fields and method calls</a></h2>
<p>A chain is a sequence of field accesses, method calls, and/or uses of the try
operator <code>?</code>. E.g., <code>a.b.c().d</code> or <code>foo?.bar().baz?</code>.</p>
<p>Format the chain on one line if it is &quot;small&quot; and otherwise possible to do so.
If formatting on multiple lines, put each field access or method call in the
chain on its own line, with the line-break before the <code>.</code> and after any <code>?</code>.
Block-indent each subsequent line:</p>
<pre><code class="language-rust ignore">let foo = bar
    .baz?
    .qux();
</code></pre>
<p>If the length of the last line of the first element plus its indentation is
less than or equal to the indentation of the second line, then combine the
first and second lines if they fit. Apply this rule recursively.</p>
<pre><code class="language-rust ignore">x.baz?
    .qux()

x.y.z
    .qux()

let foo = x
    .baz?
    .qux();

foo(
    expr1,
    expr2,
).baz?
    .qux();
</code></pre>
<h3><a class="header" href="#multi-line-elements" id="multi-line-elements">Multi-line elements</a></h3>
<p>If any element in a chain is formatted across multiple lines, put that element
and any later elements on their own lines.</p>
<pre><code class="language-rust ignore">a.b.c()?
    .foo(
        an_expr,
        another_expr,
    )
    .bar
    .baz
</code></pre>
<p>Note there is block indent due to the chain and the function call in the above
example.</p>
<p>Prefer formatting the whole chain in multi-line style and each element on one
line, rather than putting some elements on multiple lines and some on a single
line, e.g.,</p>
<pre><code class="language-rust ignore">// Better
self.pre_comment
    .as_ref()
    .map_or(false, |comment| comment.starts_with(&quot;//&quot;))

// Worse
self.pre_comment.as_ref().map_or(
    false,
    |comment| comment.starts_with(&quot;//&quot;),
)
</code></pre>
<h2><a class="header" href="#control-flow-expressions" id="control-flow-expressions">Control flow expressions</a></h2>
<p>This section covers <code>if</code>, <code>if let</code>, <code>loop</code>, <code>while</code>, <code>while let</code>, and <code>for</code>
expressions.</p>
<p>Put the keyword, any initial clauses, and the opening brace of the block all on
a single line, if they fit. Apply the usual rules for <a href="#blocks">block
formatting</a> to the block.</p>
<p>If there is an <code>else</code> component, then put the closing brace, <code>else</code>, any
following clause, and the opening brace all on the same line, with a single
space before and after the <code>else</code> keyword:</p>
<pre><code class="language-rust ignore">if ... {
    ...
} else {
    ...
}

if let ... {
    ...
} else if ... {
    ...
} else {
    ...
}
</code></pre>
<p>If the control line needs to be broken, prefer to break before the <code>=</code> in <code>* let</code> expressions and before <code>in</code> in a <code>for</code> expression; block-indent the
following line. If the control line is broken for any reason, put the opening
brace on its own line, not indented. Examples:</p>
<pre><code class="language-rust ignore">while let Some(foo)
    = a_long_expression
{
    ...
}

for foo
    in a_long_expression
{
    ...
}

if a_long_expression
    &amp;&amp; another_long_expression
    || a_third_long_expression
{
    ...
}
</code></pre>
<p>Where the initial clause spans multiple lines and ends with one or more closing
parentheses, square brackets, or braces, and there is nothing else on that
line, and that line is not indented beyond the indent on the first line of the
control flow expression, then put the opening brace of the block on the same
line with a preceding space. For example:</p>
<pre><code class="language-rust ignore">if !self.config.file_lines().intersects(
    &amp;self.codemap.lookup_line_range(
        stmt.span,
    ),
) {  // Opening brace on same line as initial clause.
    ...
}
</code></pre>
<h3><a class="header" href="#single-line-if-else" id="single-line-if-else">Single line <code>if else</code></a></h3>
<p>Put an <code>if else</code> or <code>if let else</code> on a single line if it occurs in expression
context (i.e., is not a standalone statement), it contains a single <code>else</code>
clause, and is <em>small</em>:</p>
<pre><code class="language-rust ignore">let y = if x { 0 } else { 1 };

// Examples that must be multi-line.
let y = if something_very_long {
    not_small
} else {
    also_not_small
};

if x {
    0
} else {
    1
}
</code></pre>
<h2><a class="header" href="#match" id="match">Match</a></h2>
<p>Prefer not to line-break inside the discriminant expression. Always break after
the opening brace and before the closing brace. Block-indent the match arms
once:</p>
<pre><code class="language-rust ignore">match foo {
    // arms
}

let x = match foo.bar.baz() {
    // arms
};
</code></pre>
<p>Use a trailing comma for a match arm if and only if not using a block.</p>
<p>Never start a match arm pattern with <code>|</code>:</p>
<pre><code class="language-rust ignore">match foo {
    // Don't do this.
    | foo =&gt; bar,
    // Or this.
    | a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_fourth_pattern =&gt; {
        ...
    }
}
</code></pre>
<p>Prefer:</p>
<pre><code class="language-rust ignore">match foo {
    foo =&gt; bar,
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_fourth_pattern =&gt; {
        ...
    }
}
</code></pre>
<p>Avoid splitting the left-hand side (before the <code>=&gt;</code>) of a match arm where
possible. If the right-hand side of the match arm is kept on the same line,
never use a block (unless the block is empty).</p>
<p>If the right-hand side consists of multiple statements, or has line comments,
or the start of the line does not fit on the same line as the left-hand side,
use a block. Do not flatten a right-hand side block containing a single macro call
because its expanded form could contain a trailing semicolon.</p>
<p>Block-indent the body of a block arm.</p>
<p>Examples:</p>
<pre><code class="language-rust ignore">match foo {
    foo =&gt; bar,
    a_very_long_pattern | another_pattern if an_expression() =&gt; {
        no_room_for_this_expression()
    }
    foo =&gt; {
        // A comment.
        an_expression()
    }
    foo =&gt; {
        let a = statement();
        an_expression()
    }
    bar =&gt; {}
    // Trailing comma on last item.
    foo =&gt; bar,
    baz =&gt; qux!(),
    lorem =&gt; {
        ipsum!()
    }
}
</code></pre>
<p>If the body is a single expression with no line comments and not a control flow
expression, start it on the same line as the left-hand side. If not, then it
must be in a block. Example:</p>
<pre><code class="language-rust ignore">match foo {
    // A combinable expression.
    foo =&gt; a_function_call(another_call(
        argument1,
        argument2,
    )),
    // A non-combinable expression
    bar =&gt; {
        a_function_call(
            another_call(
                argument1,
                argument2,
            ),
            another_argument,
        )
    }
}
</code></pre>
<h3><a class="header" href="#line-breaking" id="line-breaking">Line-breaking</a></h3>
<p>If using a block form on the right-hand side of a match arm makes it possible
to avoid breaking on the left-hand side, do that:</p>
<pre><code class="language-rust ignore">    // Assuming the following line does not fit in the max width
    a_very_long_pattern | another_pattern =&gt; ALongStructName {
        ...
    },
    // Prefer this
    a_very_long_pattern | another_pattern =&gt; {
        ALongStructName {
            ...
        }
    }
    // To splitting the pattern.
</code></pre>
<p>Never break after <code>=&gt;</code> without using the block form of the body.</p>
<p>If the left-hand side must be split and there is an <code>if</code> clause, break before
the <code>if</code> and block indent. In this case, always use a block body and start the
body on a new line:</p>
<pre><code class="language-rust ignore">    a_very_long_pattern | another_pattern
        if expr =&gt;
    {
        ...
    }
</code></pre>
<p>If required to break the pattern, put each clause of the pattern on its own
line with no additional indent, breaking before the <code>|</code>. If there is an <code>if</code>
clause, use the above form:</p>
<pre><code class="language-rust ignore">    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern =&gt; {
        ...
    }
    a_very_long_pattern
    | another_pattern
    | yet_another_pattern
    | a_forth_pattern
        if expr =&gt;
    {
        ...
    }
</code></pre>
<p>If the pattern is multi-line, and the last line is less wide than the indent, do
not put the <code>if</code> clause on a new line. E.g.,</p>
<pre><code class="language-rust ignore">    Token::Dimension {
         value,
         ref unit,
         ..
    } if num_context.is_ok(context.parsing_mode, value) =&gt; {
        ...
    }
</code></pre>
<p>If every clause in a pattern is <em>small</em>, but the whole pattern does not fit on
one line, then format the pattern across multiple lines with as many clauses
per line as possible. Again, break before a <code>|</code>:</p>
<pre><code class="language-rust ignore">    foo | bar | baz
    | qux =&gt; {
        ...
    }
</code></pre>
<p>We define a pattern clause to be <em>small</em> if it fits on a single line and
matches &quot;small&quot; in the following grammar:</p>
<pre><code class="language-text">small:
    - small_no_tuple
    - unary tuple constructor: `(` small_no_tuple `,` `)`
    - `&amp;` small

small_no_tuple:
    - single token
    - `&amp;` small_no_tuple
</code></pre>
<p>E.g., <code>&amp;&amp;Some(foo)</code> matches, <code>Foo(4, Bar)</code> does not.</p>
<h2><a class="header" href="#combinable-expressions" id="combinable-expressions">Combinable expressions</a></h2>
<p>Where a function call has a single argument, and that argument is formatted
across multiple-lines, format the outer call as if it were a single-line call,
if the result fits. Apply the same combining behaviour to any similar
expressions which have multi-line, block-indented lists of sub-expressions
delimited by parentheses (e.g., macros or tuple struct literals). E.g.,</p>
<pre><code class="language-rust ignore">foo(bar(
    an_expr,
    another_expr,
))

let x = foo(Bar {
    field: whatever,
});

foo(|param| {
    action();
    foo(param)
})

let x = combinable([
    an_expr,
    another_expr,
]);

let arr = [combinable(
    an_expr,
    another_expr,
)];
</code></pre>
<p>Apply this behavior recursively.</p>
<p>For a function with multiple arguments, if the last argument is a multi-line
closure with an explicit block, there are no other closure arguments, and all
the arguments and the first line of the closure fit on the first line, use the
same combining behavior:</p>
<pre><code class="language-rust ignore">foo(first_arg, x, |param| {
    action();
    foo(param)
})
</code></pre>
<h2><a class="header" href="#ranges" id="ranges">Ranges</a></h2>
<p>Do not put spaces in ranges, e.g., <code>0..10</code>, <code>x..=y</code>, <code>..x.len()</code>, <code>foo..</code>.</p>
<p>When writing a range with both upper and lower bounds, if the line must be
broken within the range, break before the range operator and block indent the
second line:</p>
<pre><code class="language-rust ignore">a_long_expression
    ..another_long_expression
</code></pre>
<p>For the sake of indicating precedence, if either bound is a compound
expression, use parentheses around it, e.g., <code>..(x + 1)</code>, <code>(x.f)..(x.f.len())</code>,
or <code>0..(x - 10)</code>.</p>
<h2><a class="header" href="#hexadecimal-literals" id="hexadecimal-literals">Hexadecimal literals</a></h2>
<p>Hexadecimal literals may use upper- or lower-case letters, but they must not be
mixed within the same literal. Projects should use the same case for all
literals, but we do not make a recommendation for either lower- or upper-case.</p>
<h1><a class="header" href="#patterns" id="patterns">Patterns</a></h1>
<p>Format patterns like their corresponding expressions. See the section on
<code>match</code> for additional formatting for patterns in match arms.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="statements.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="statements.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="language.js"></script>
        

        

    </body>
</html>
